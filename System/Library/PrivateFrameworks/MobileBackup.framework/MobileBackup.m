uint64_t sub_100005E1C()
{
  Swift::String v0;
  Swift::String v1;
  Swift::String v2;
  Swift::String v3;
  Swift::String v4;
  Swift::String v5;
  Swift::String v6;

  _StringGuts.grow(_:)(74);
  v0._countAndFlagsBits = 0xD000000000000025;
  v0._object = (void *)0x8000000100303EA0;
  String.append(_:)(v0);
  type metadata accessor for UUID();
  sub_1000070F4(&qword_10047CE20, (void (*)(uint64_t))&type metadata accessor for UUID);
  v1._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
  String.append(_:)(v1);
  swift_bridgeObjectRelease();
  v2._object = (void *)0x8000000100303ED0;
  v2._countAndFlagsBits = 0xD000000000000010;
  String.append(_:)(v2);
  v3._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
  String.append(_:)(v3);
  swift_bridgeObjectRelease();
  v4._countAndFlagsBits = 0x6F69746165726320;
  v4._object = (void *)0xEE003A657461446ELL;
  String.append(_:)(v4);
  type metadata accessor for Date();
  sub_1000070F4(&qword_10047CE28, (void (*)(uint64_t))&type metadata accessor for Date);
  v5._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
  String.append(_:)(v5);
  swift_bridgeObjectRelease();
  v6._countAndFlagsBits = 62;
  v6._object = (void *)0xE100000000000000;
  String.append(_:)(v6);
  return 0;
}

uint64_t sub_100005FF8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_10004F094(*a1, *a2);
}

Swift::Int sub_100006004()
{
  return Hasher._finalize()();
}

uint64_t sub_1000060C0()
{
  String.hash(into:)();
  return swift_bridgeObjectRelease();
}

Swift::Int sub_100006168()
{
  return Hasher._finalize()();
}

unint64_t sub_100006220@<X0>(Swift::String *a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t result = sub_1000074A4(*a1);
  *a2 = result;
  return result;
}

void sub_100006250(unint64_t *a1@<X8>)
{
  int v2 = *v1;
  unint64_t v3 = 0x8000000100303D50;
  unint64_t v4 = 0xEE0044495555656DLL;
  uint64_t v5 = 0x756C6F5673667061;
  if (v2 != 1)
  {
    uint64_t v5 = 0x6E6F697461657263;
    unint64_t v4 = 0xEC00000065746144;
  }
  BOOL v6 = v2 == 0;
  if (*v1) {
    unint64_t v7 = v5;
  }
  else {
    unint64_t v7 = 0xD000000000000010;
  }
  if (!v6) {
    unint64_t v3 = v4;
  }
  *a1 = v7;
  a1[1] = v3;
}

unint64_t sub_1000062C8()
{
  uint64_t v1 = 0x756C6F5673667061;
  if (*v0 != 1) {
    uint64_t v1 = 0x6E6F697461657263;
  }
  if (*v0) {
    return v1;
  }
  else {
    return 0xD000000000000010;
  }
}

unint64_t sub_10000633C@<X0>(Swift::String a1@<X1:X0>, unsigned char *a2@<X8>)
{
  unint64_t result = sub_1000074A4(a1);
  *a2 = result;
  return result;
}

uint64_t sub_100006364()
{
  return 0;
}

void sub_100006370(unsigned char *a1@<X8>)
{
  *a1 = 3;
}

uint64_t sub_10000637C(uint64_t a1)
{
  unint64_t v2 = sub_100007050();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000063B8(uint64_t a1)
{
  unint64_t v2 = sub_100007050();
  return CodingKey.debugDescription.getter(a1, v2);
}

id sub_1000063F4(void *a1)
{
  ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v22 = type metadata accessor for Date();
  uint64_t v20 = *(void *)(v22 - 8);
  ((void (*)(void))__chkstk_darwin)();
  v21 = (char *)v19 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = type metadata accessor for UUID();
  uint64_t v23 = *(void *)(v4 - 8);
  uint64_t v5 = ((uint64_t (*)(void))__chkstk_darwin)();
  unint64_t v7 = (char *)v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v5);
  v25 = (void (*)(void))((char *)v19 - v8);
  uint64_t v27 = sub_100006FC8(&qword_10047CD28);
  uint64_t v24 = *(void *)(v27 - 8);
  __chkstk_darwin(v27);
  v10 = (char *)v19 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_10000700C(a1, a1[3]);
  sub_100007050();
  v11 = v1;
  v26 = v10;
  uint64_t v12 = (uint64_t)v29;
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (v12)
  {
    sub_1000070A4((uint64_t)a1);
    id v18 = ObjectType;

    swift_deallocPartialClassInstance();
  }
  else
  {
    v29 = a1;
    char v31 = 0;
    sub_1000070F4(&qword_10047CD38, (void (*)(uint64_t))&type metadata accessor for UUID);
    KeyedDecodingContainer.decode<A>(_:forKey:)();
    v14 = *(void (**)(void))(v23 + 32);
    v19[1] = &v11[OBJC_IVAR____TtC7backupd18MBVolumeIdentifier_backupVolumeUUID];
    v25 = v14;
    v14();
    char v31 = 1;
    KeyedDecodingContainer.decode<A>(_:forKey:)();
    ((void (*)(char *, char *, uint64_t))v25)(&v11[OBJC_IVAR____TtC7backupd18MBVolumeIdentifier_apfsVolumeUUID], v7, v4);
    char v31 = 2;
    sub_1000070F4(&qword_10047CD40, (void (*)(uint64_t))&type metadata accessor for Date);
    v16 = v21;
    uint64_t v15 = v22;
    v17 = v26;
    KeyedDecodingContainer.decode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v24 + 8))(v17, v27);
    (*(void (**)(char *, char *, uint64_t))(v20 + 32))(&v11[OBJC_IVAR____TtC7backupd18MBVolumeIdentifier_creationDate], v16, v15);

    v30.receiver = v11;
    v30.super_class = ObjectType;
    id v18 = objc_msgSendSuper2(&v30, "init");
    sub_1000070A4((uint64_t)v29);
  }
  return v18;
}

uint64_t sub_100006914(void *a1)
{
  uint64_t v3 = sub_100006FC8(&qword_10047CD48);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  uint64_t v6 = &v8[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_10000700C(a1, a1[3]);
  sub_100007050();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v8[15] = 0;
  type metadata accessor for UUID();
  sub_1000070F4(&qword_10047CD50, (void (*)(uint64_t))&type metadata accessor for UUID);
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v1)
  {
    v8[14] = 1;
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    v8[13] = 2;
    type metadata accessor for Date();
    sub_1000070F4(&qword_10047CD58, (void (*)(uint64_t))&type metadata accessor for Date);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v4 + 8))(v6, v3);
}

id sub_100006B88()
{
  v2.receiver = v0;
  v2.super_class = (Class)swift_getObjectType();
  return objc_msgSendSuper2(&v2, "dealloc");
}

uint64_t sub_100006CA4()
{
  return type metadata accessor for MBVolumeIdentifier();
}

uint64_t type metadata accessor for MBVolumeIdentifier()
{
  uint64_t result = qword_10047CB60;
  if (!qword_10047CB60) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t sub_100006CF8()
{
  uint64_t result = type metadata accessor for UUID();
  if (v1 <= 0x3F)
  {
    uint64_t result = type metadata accessor for Date();
    if (v2 <= 0x3F)
    {
      uint64_t result = swift_updateClassMetadata2();
      if (!result) {
        return 0;
      }
    }
  }
  return result;
}

void type metadata accessor for MBServiceManagerState(uint64_t a1)
{
}

void type metadata accessor for os_unfair_lock_s(uint64_t a1)
{
}

void type metadata accessor for MBProtectionClass(uint64_t a1)
{
}

void type metadata accessor for MBAccountType(uint64_t a1)
{
}

void type metadata accessor for MBSnapshotFormat(uint64_t a1)
{
}

void type metadata accessor for MBAssetType(uint64_t a1)
{
}

uint64_t initializeBufferWithCopyOfBuffer for MBRestoreSummary(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a1 = *a2;
  uint64_t v3 = v2 + 16;
  swift_retain();
  return v3;
}

__n128 sub_100006E74(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t sub_100006E98(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 72)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_100006EB8(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 72) = v3;
  return result;
}

void type metadata accessor for MBNode(uint64_t a1)
{
}

id sub_100006F08@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  id v6 = objc_allocWithZone(v2);
  id result = sub_1000063F4(a1);
  if (!v3) {
    *a2 = result;
  }
  return result;
}

uint64_t sub_100006F58(void *a1)
{
  return sub_100006914(a1);
}

BOOL sub_100006F7C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void *sub_100006F90@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *result;
  *(unsigned char *)(a2 + 8) = 0;
  return result;
}

void sub_100006FA0(void *a1@<X8>)
{
  *a1 = *v1;
}

unsigned __int8 *sub_100006FAC@<X0>(unsigned __int8 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void sub_100006FBC(unsigned char *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t sub_100006FC8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }
  return result;
}

void *sub_10000700C(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80)));
  return result;
}

unint64_t sub_100007050()
{
  unint64_t result = qword_10047CD30;
  if (!qword_10047CD30)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047CD30);
  }
  return result;
}

uint64_t sub_1000070A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t sub_1000070F4(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

void type metadata accessor for MBFileCompressionMethod(uint64_t a1)
{
}

void type metadata accessor for MBRestoreAssetState(uint64_t a1)
{
}

void type metadata accessor for BGSystemTaskExpirationReason(uint64_t a1)
{
}

void type metadata accessor for MBRestorableState(uint64_t a1)
{
}

unsigned char *initializeBufferWithCopyOfBuffer for MBVolumeIdentifier.CodingKeys(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for MBVolumeIdentifier.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBVolumeIdentifier.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    *uint64_t result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1000072F4);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 2;
        break;
    }
  }
  return result;
}

uint64_t sub_10000731C(unsigned __int8 *a1)
{
  return *a1;
}

unsigned char *sub_100007328(unsigned char *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

ValueMetadata *type metadata accessor for MBVolumeIdentifier.CodingKeys()
{
  return &type metadata for MBVolumeIdentifier.CodingKeys;
}

void type metadata accessor for MBNode.__Unnamed_struct__is(uint64_t a1)
{
}

void sub_100007354(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }
}

unint64_t sub_1000073A0()
{
  unint64_t result = qword_10047CE58;
  if (!qword_10047CE58)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047CE58);
  }
  return result;
}

unint64_t sub_1000073F8()
{
  unint64_t result = qword_10047CE60;
  if (!qword_10047CE60)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047CE60);
  }
  return result;
}

unint64_t sub_100007450()
{
  unint64_t result = qword_10047CE68;
  if (!qword_10047CE68)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047CE68);
  }
  return result;
}

unint64_t sub_1000074A4(Swift::String string)
{
  object = string._object;
  v2._countAndFlagsBits = string._countAndFlagsBits;
  v2._object = object;
  unint64_t v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_10040EF58, v2);
  swift_bridgeObjectRelease();
  if (v3 >= 3) {
    return 3;
  }
  else {
    return v3;
  }
}

id sub_100007500(unint64_t a1, unint64_t a2)
{
  return sub_10000793C(a1, a2, (SEL *)&selRef_logRenameForRestorable_state_source_target_, 0);
}

id sub_100007558(unint64_t a1)
{
  if (a1 >> 62)
  {
    if (a1 >> 62 == 1)
    {
      uint64_t v1 = *(void **)swift_projectBox();
      return v1;
    }
    else
    {
      uint64_t v4 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
      swift_retain();
      uint64_t v5 = sub_100007558(v4);
      swift_release();
      return (id)v5;
    }
  }
  else
  {
    id v3 = objc_allocWithZone((Class)NSFileHandle);
    return [v3 initWithFileDescriptor:4294967294 closeOnDealloc:0];
  }
}

uint64_t sub_100007610(unint64_t a1)
{
  uint64_t v2 = type metadata accessor for FilePath();
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v12 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!(a1 >> 62))
  {
    uint64_t v7 = swift_projectBox();
    goto LABEL_5;
  }
  if (a1 >> 62 == 1)
  {
    uint64_t v6 = sub_100006FC8(&qword_10047CFF0);
    uint64_t v7 = swift_projectBox() + *(int *)(v6 + 64);
LABEL_5:
    (*(void (**)(char *, uint64_t, uint64_t))(v3 + 16))(v5, v7, v2);
    uint64_t v8 = FilePath.string.getter();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v5, v2);
    return v8;
  }
  uint64_t v10 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
  swift_retain();
  uint64_t v11 = sub_100007610(v10);
  swift_release();
  return v11;
}

uint64_t sub_100007780(unint64_t a1)
{
  uint64_t v2 = type metadata accessor for FilePath();
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v11 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!(a1 >> 62)) {
    return 47;
  }
  if (a1 >> 62 == 1)
  {
    uint64_t v6 = sub_100006FC8(&qword_10047CFF0);
    uint64_t v7 = swift_projectBox();
    (*(void (**)(char *, uint64_t, uint64_t))(v3 + 16))(v5, v7 + *(int *)(v6 + 48), v2);
    uint64_t v8 = FilePath.string.getter();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v5, v2);
  }
  else
  {
    uint64_t v9 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
    swift_retain();
    uint64_t v8 = sub_100007780(v9);
    swift_release();
  }
  return v8;
}

id sub_1000078E4(unint64_t a1, unint64_t a2)
{
  return sub_10000793C(a1, a2, (SEL *)&selRef_logMoveForRestorable_state_source_target_, 4);
}

id sub_10000793C(unint64_t a1, unint64_t a2, SEL *a3, uint64_t a4)
{
  if (a2 >> 62 == 2)
  {
    sub_1000091FC((a2 & 0x3FFFFFFFFFFFFFFFLL) + 16, (uint64_t)v27);
    unint64_t v8 = *(void *)((a2 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
    sub_1000092A4(v27, (uint64_t)v28);
    uint64_t v9 = (id *)sub_10000700C(v28, v28[3]);
    id v10 = v9[1];
    id v26 = *v9;
    swift_retain();
    sub_10000793C(a1, v8, &selRef_logMoveForRestorable_state_source_target_, 4);
    if (v4) {
      uint64_t v11 = 6;
    }
    else {
      uint64_t v11 = 5;
    }
    if (v4) {
      uint64_t v12 = v4;
    }
    else {
      uint64_t v12 = 0;
    }
    sub_10002D270(a1);
    NSString v13 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    sub_10002D270(v8);
    NSString v14 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    objc_msgSend(v26, *a3, v10, v11, v13, v14);

    if (v12) {
      swift_willThrow();
    }
    swift_release();
    return (id)sub_1000070A4((uint64_t)v28);
  }
  else
  {
    v17 = self;
    id v18 = sub_100007558(a2);
    id v19 = [v18 fileDescriptor];

    sub_100007610(a2);
    NSString v20 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    sub_100007780(a1);
    NSString v21 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v22 = sub_100007558(a1);
    id v23 = [v22 fileDescriptor];

    sub_100007610(a1);
    NSString v24 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    *(void *)&v27[0] = 0;
    LODWORD(a4) = [v17 rename:v19 sourceRpath:v20 destinationBasePath:v21 destinationBaseFD:v23 destinationRpath:v24 flags:a4 error:v27];

    if (a4)
    {
      return *(id *)&v27[0];
    }
    else
    {
      id v25 = *(id *)&v27[0];
      _convertNSErrorToError(_:)();

      return (id)swift_willThrow();
    }
  }
}

id sub_100007BF0(unint64_t a1, unint64_t a2)
{
  return sub_100007CD0(a1, a2, (void (*)(unint64_t, unint64_t))sub_100007BF0, (SEL *)&selRef_logCloneForRestorable_state_source_target_, (SEL *)&selRef_clone_sourceRpath_destinationBasePath_destinationBaseFD_destinationRpath_error_);
}

id sub_100007C60(unint64_t a1, unint64_t a2)
{
  return sub_100007CD0(a1, a2, (void (*)(unint64_t, unint64_t))sub_100007C60, (SEL *)&selRef_logLinkForRestorable_state_source_target_, (SEL *)&selRef_hardlink_sourceRpath_destinationBasePath_destinationBaseFD_destinationRpath_error_);
}

id sub_100007CD0(unint64_t a1, unint64_t a2, void (*a3)(unint64_t, unint64_t), SEL *a4, SEL *a5)
{
  if (a2 >> 62 == 2)
  {
    sub_1000091FC((a2 & 0x3FFFFFFFFFFFFFFFLL) + 16, (uint64_t)v29);
    unint64_t v10 = *(void *)((a2 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
    sub_1000092A4(v29, (uint64_t)v30);
    uint64_t v11 = (id *)sub_10000700C(v30, v30[3]);
    id v12 = v11[1];
    id v28 = *v11;
    swift_retain();
    a3(a1, v10);
    if (v5) {
      uint64_t v13 = 6;
    }
    else {
      uint64_t v13 = 5;
    }
    if (v5) {
      uint64_t v14 = v5;
    }
    else {
      uint64_t v14 = 0;
    }
    sub_10002D270(a1);
    NSString v15 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    sub_10002D270(v10);
    NSString v16 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    objc_msgSend(v28, *a4, v12, v13, v15, v16);

    if (v14) {
      swift_willThrow();
    }
    swift_release();
    return (id)sub_1000070A4((uint64_t)v30);
  }
  else
  {
    id v19 = self;
    id v20 = sub_100007558(a2);
    id v21 = [v20 fileDescriptor];

    sub_100007610(a2);
    NSString v22 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    sub_100007780(a1);
    NSString v23 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v24 = sub_100007558(a1);
    id v25 = [v24 fileDescriptor];

    sub_100007610(a1);
    NSString v26 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    *(void *)&v29[0] = 0;
    LODWORD(a5) = objc_msgSend(v19, *a5, v21, v22, v23, v25, v26, v29);

    if (a5)
    {
      return *(id *)&v29[0];
    }
    else
    {
      id v27 = *(id *)&v29[0];
      _convertNSErrorToError(_:)();

      return (id)swift_willThrow();
    }
  }
}

id sub_100007F74(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 == 2)
  {
    sub_1000091FC((a2 & 0x3FFFFFFFFFFFFFFFLL) + 16, (uint64_t)v19);
    unint64_t v5 = *(void *)((a2 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
    sub_1000092A4(v19, (uint64_t)v20);
    uint64_t v6 = (void **)sub_10000700C(v20, v20[3]);
    uint64_t v7 = *v6;
    unint64_t v8 = v6[1];
    swift_retain();
    sub_100007F74(a1, v5);
    if (v2) {
      uint64_t v9 = 6;
    }
    else {
      uint64_t v9 = 5;
    }
    if (v2) {
      uint64_t v10 = v2;
    }
    else {
      uint64_t v10 = 0;
    }
    sub_10002D270(v5);
    NSString v11 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    [v7 logCreateDirectoryForRestorable:v8 state:v9 absolutePath:v11];

    if (v10) {
      swift_willThrow();
    }
    swift_release();
    return (id)sub_1000070A4((uint64_t)v20);
  }
  else
  {
    uint64_t v13 = self;
    id v14 = sub_100007558(a2);
    id v15 = [v14 fileDescriptor];

    sub_100007780(a2);
    NSString v16 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    sub_100007610(a2);
    NSString v17 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    *(void *)&v19[0] = 0;
    LODWORD(v13) = [v13 createDirectories:v15 destinationBasePath:v16 destinationRpath:v17 permissions:(unsigned __int16)a1 error:v19];

    if (v13)
    {
      return *(id *)&v19[0];
    }
    else
    {
      id v18 = *(id *)&v19[0];
      _convertNSErrorToError(_:)();

      return (id)swift_willThrow();
    }
  }
}

id sub_10000819C(unint64_t a1)
{
  if (a1 >> 62 == 2)
  {
    sub_1000091FC((a1 & 0x3FFFFFFFFFFFFFFFLL) + 16, (uint64_t)v18);
    unint64_t v3 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
    sub_1000092A4(v18, (uint64_t)v19);
    uint64_t v4 = (void **)sub_10000700C(v19, v19[3]);
    unint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    swift_retain();
    sub_10000819C(v3);
    if (v1) {
      uint64_t v7 = 6;
    }
    else {
      uint64_t v7 = 5;
    }
    if (v1) {
      uint64_t v8 = v1;
    }
    else {
      uint64_t v8 = 0;
    }
    sub_10002D270(v3);
    NSString v9 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    [v5 logUnlinkForRestorable:v6 state:v7 absolutePath:v9];

    if (v8) {
      swift_willThrow();
    }
    swift_release();
    return (id)sub_1000070A4((uint64_t)v19);
  }
  else
  {
    NSString v11 = self;
    id v12 = sub_100007558(a1);
    id v13 = [v12 fileDescriptor];

    sub_100007780(a1);
    NSString v14 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    sub_100007610(a1);
    NSString v15 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    *(void *)&v18[0] = 0;
    unsigned int v16 = [v11 unlink:v13 targetBasePath:v14 targetRpath:v15 error:v18];

    if (v16)
    {
      return *(id *)&v18[0];
    }
    else
    {
      id v17 = *(id *)&v18[0];
      _convertNSErrorToError(_:)();

      return (id)swift_willThrow();
    }
  }
}

id sub_1000083B8(unint64_t a1)
{
  id v2 = [objc_allocWithZone((Class)NSFileManager) init];
  sub_10002D270(a1);
  NSString v3 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v7 = 0;
  unsigned int v4 = objc_msgSend(v2, "mb_moveToTmpDirThenRemoveItemAtPath:error:", v3, &v7);

  if (v4) {
    return v7;
  }
  id v6 = v7;
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

uint64_t sub_1000084B4(uint64_t a1, unint64_t a2)
{
  NSString v3 = self;
  id v23 = 0;
  id v4 = [v3 keysForPathFSR:a1 error:&v23];
  id v5 = v23;
  if (v4)
  {
    id v6 = v4;
    uint64_t v7 = static Array._unconditionallyBridgeFromObjectiveC(_:)();
    id v8 = v5;

    uint64_t v9 = *(void *)(v7 + 16);
    if (v9)
    {
      uint64_t v10 = (void **)(v7 + 40);
      for (uint64_t i = v9 - 1; ; --i)
      {
        uint64_t v13 = (uint64_t)*(v10 - 1);
        id v12 = *v10;
        id v23 = 0;
        unint64_t v24 = 0xE000000000000000;
        swift_bridgeObjectRetain();
        _StringGuts.grow(_:)(26);
        swift_bridgeObjectRelease();
        id v23 = (id)0xD000000000000010;
        unint64_t v24 = 0x8000000100304160;
        v14._countAndFlagsBits = v13;
        v14._object = v12;
        String.append(_:)(v14);
        v15._countAndFlagsBits = 0x206D6F726620;
        v15._object = (void *)0xE600000000000000;
        String.append(_:)(v15);
        v16._countAndFlagsBits = sub_10002D874(a2);
        String.append(_:)(v16);
        swift_bridgeObjectRelease();
        sub_100045F18((uint64_t)v23, v24, 0x706F2D656C69663DLL, 0xEA0000000000203DLL);
        swift_bridgeObjectRelease();
        NSString v17 = String._bridgeToObjectiveC()();
        swift_bridgeObjectRelease();
        id v23 = 0;
        LODWORD(v12) = [v3 removeAttributeForKey:v17 forPathFSR:a1 error:&v23];

        if (!v12)
        {
          id v19 = v23;
          swift_bridgeObjectRelease();
          goto LABEL_10;
        }
        if (!i) {
          break;
        }
        v10 += 2;
        id v18 = v23;
      }
      id v21 = v23;
      return swift_bridgeObjectRelease();
    }
    else
    {
      return swift_bridgeObjectRelease();
    }
  }
  else
  {
    id v19 = v23;
LABEL_10:
    _convertNSErrorToError(_:)();

    return swift_willThrow();
  }
}

id sub_100008700(unint64_t a1)
{
  id v2 = [self defaultManager];
  sub_10002D270(a1);
  NSString v3 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v7 = 0;
  unsigned int v4 = objc_msgSend(v2, "mb_markAsPurgeableItemAtPath:error:", v3, &v7);

  if (v4) {
    return v7;
  }
  id v6 = v7;
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

uint64_t sub_100008804(unint64_t a1)
{
  char v11 = 0;
  id v2 = self;
  sub_100007780(a1);
  NSString v3 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v4 = sub_100007558(a1);
  id v5 = [v4 fileDescriptor];

  sub_100007610(a1);
  NSString v6 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v10 = 0;
  LOBYTE(a1) = [v2 exists:&v11 atBasePath:v3 baseFD:v5 rpath:v6 error:&v10];

  if (a1)
  {
    LOBYTE(v7) = v11;
    id v8 = v10;
  }
  else
  {
    id v7 = v10;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
  return v7 & 1;
}

uint64_t sub_10000894C(void *a1, unint64_t a2)
{
  unint64_t v25 = a2;
  uint64_t v3 = type metadata accessor for FilePath();
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = __chkstk_darwin(v3);
  id v7 = (char *)&v24 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = __chkstk_darwin(v5);
  id v10 = (char *)&v24 - v9;
  __chkstk_darwin(v8);
  id v12 = (char *)&v24 - v11;
  id v13 = [a1 relativePath];
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  FilePath.init(_:)();
  uint64_t v27 = v4;
  Swift::String v14 = *(void (**)(char *, char *, uint64_t))(v4 + 16);
  objc_super v30 = v12;
  v14(v7, v12, v3);
  FilePath.removingLastComponent()();
  uint64_t v15 = sub_100006FC8(&qword_10047CFF0);
  uint64_t v16 = swift_allocBox();
  id v18 = (char *)v17 + *(int *)(v15 + 64);
  unint64_t v19 = v25;
  id *v17 = sub_100007558(v25);
  sub_100007610(v19);
  FilePath.init(_:)();
  v14(v18, v10, v3);
  uint64_t v20 = v26;
  sub_100007F74(511, v16 | 0x4000000000000000);
  if (v20)
  {
    uint64_t v28 = 0;
    unint64_t v29 = 0xE000000000000000;
    _StringGuts.grow(_:)(35);
    swift_bridgeObjectRelease();
    uint64_t v28 = 0xD000000000000021;
    unint64_t v29 = 0x8000000100304130;
    v21._countAndFlagsBits = sub_10002D874(v16 | 0x4000000000000000);
    String.append(_:)(v21);
    swift_bridgeObjectRelease();
    sub_100045F30(v20, 0xF000000000000007, v28, v29, 0x706F2D656C69663DLL, 0xEA0000000000203DLL);
    swift_bridgeObjectRelease();
    swift_willThrow();
    swift_release();
    swift_errorRelease();
  }
  else
  {
    swift_release();
  }
  NSString v22 = *(void (**)(char *, uint64_t))(v27 + 8);
  v22(v10, v3);
  return ((uint64_t (*)(char *, uint64_t))v22)(v30, v3);
}

uint64_t sub_100008C50(unint64_t a1)
{
  uint64_t v3 = type metadata accessor for FilePath();
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = __chkstk_darwin(v3);
  id v7 = (char *)v52 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = __chkstk_darwin(v5);
  id v10 = (char *)v52 - v9;
  uint64_t v11 = __chkstk_darwin(v8);
  id v13 = (char *)v52 - v12;
  __chkstk_darwin(v11);
  uint64_t v15 = (char *)v52 - v14;
  unsigned int v58 = -1;
  if (a1 >> 62)
  {
    if (a1 >> 62 == 1)
    {
      v54 = v1;
      uint64_t v16 = sub_100006FC8(&qword_10047CFF0);
      NSString v17 = (void **)swift_projectBox();
      id v18 = *v17;
      unint64_t v19 = (char *)v17 + *(int *)(v16 + 48);
      uint64_t v20 = (char *)v17 + *(int *)(v16 + 64);
      uint64_t v57 = v4;
      Swift::String v21 = *(void (**)(char *, char *, uint64_t))(v4 + 16);
      v21(v13, v19, v3);
      v53 = v21;
      v21(v10, v20, v3);
      uint64_t v55 = self;
      v56 = v18;
      id v22 = [v56 fileDescriptor];
      FilePath.string.getter();
      NSString v23 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      v59[0] = 0;
      LOBYTE(v22) = [(id)v55 openFD:&v58 baseFD:v22 rpath:v23 flags:0x100000 error:v59];

      id v24 = v59[0];
      if (v22)
      {
        uint64_t v55 = swift_allocBox();
        uint64_t v26 = v25;
        v52[0] = (char *)v25 + *(int *)(v16 + 48);
        v52[1] = (char *)v25 + *(int *)(v16 + 64);
        uint64_t v27 = v58;
        id v28 = objc_allocWithZone((Class)NSFileHandle);
        id v29 = v24;
        void *v26 = [v28 initWithFileDescriptor:v27 closeOnDealloc:1];
        v53(v7, v13, v3);
        FilePath.string.getter();
        FilePath.appending(_:)();
        FilePath.init()();

        objc_super v30 = *(void (**)(char *, uint64_t))(v57 + 8);
        v30(v10, v3);
        v30(v13, v3);
        return v55 | 0x4000000000000000;
      }
      else
      {
        id v48 = v59[0];
        _convertNSErrorToError(_:)();

        swift_willThrow();
        v49 = *(void (**)(char *, uint64_t))(v57 + 8);
        v49(v10, v3);
        return ((uint64_t (*)(char *, uint64_t))v49)(v13, v3);
      }
    }
    else
    {
      uint64_t v45 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
      sub_1000091FC((a1 & 0x3FFFFFFFFFFFFFFFLL) + 16, (uint64_t)v59);
      uint64_t v46 = swift_allocObject();
      sub_1000091FC((uint64_t)v59, v46 + 16);
      swift_retain();
      uint64_t v47 = sub_100008C50(v45);
      if (v1)
      {
        sub_1000070A4((uint64_t)v59);
        swift_release();
        sub_1000070A4(v46 + 16);
        return swift_deallocUninitializedObject();
      }
      else
      {
        uint64_t v51 = v47;
        sub_1000070A4((uint64_t)v59);
        swift_release();
        *(void *)(v46 + 56) = v51;
        return v46 | 0x8000000000000000;
      }
    }
  }
  else
  {
    uint64_t v32 = swift_projectBox();
    v33 = *(void (**)(char *, uint64_t, uint64_t))(v4 + 16);
    v33(v15, v32, v3);
    v34 = self;
    FilePath.string.getter();
    NSString v35 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    v59[0] = 0;
    unsigned __int8 v36 = [v34 openFD:&v58 baseFD:4294967294 rpath:v35 flags:0x100000 error:v59];

    id v37 = v59[0];
    if (v36)
    {
      uint64_t v38 = sub_100006FC8(&qword_10047CFF0);
      v56 = v33;
      uint64_t v39 = v38;
      uint64_t v57 = swift_allocBox();
      v41 = v40;
      v54 = (char *)v40 + *(int *)(v39 + 48);
      uint64_t v55 = (uint64_t)v40 + *(int *)(v39 + 64);
      uint64_t v42 = v58;
      id v43 = objc_allocWithZone((Class)NSFileHandle);
      id v44 = v37;
      void *v41 = [v43 initWithFileDescriptor:v42 closeOnDealloc:1];
      v56(v54, (uint64_t)v15, v3);
      FilePath.init()();
      (*(void (**)(char *, uint64_t))(v4 + 8))(v15, v3);
      return v57 | 0x4000000000000000;
    }
    else
    {
      id v50 = v59[0];
      _convertNSErrorToError(_:)();

      swift_willThrow();
      return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v15, v3);
    }
  }
}

uint64_t sub_1000091FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t sub_100009260()
{
  sub_1000070A4(v0 + 16);
  swift_release();
  return _swift_deallocObject(v0, 64, 7);
}

uint64_t sub_1000092A4(long long *a1, uint64_t a2)
{
  long long v2 = *a1;
  long long v3 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

BOOL sub_1000092BC(void *a1, void *a2)
{
  return *a1 == *a2;
}

Swift::Int sub_1000092D0()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_100009318()
{
  Hasher._combine(_:)(*v0);
}

Swift::Int sub_100009344()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

unint64_t sub_100009388@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = sub_10000BBF0(*a1);
  *(void *)a2 = result;
  *(unsigned char *)(a2 + 8) = v4 & 1;
  return result;
}

uint64_t sub_1000093BC()
{
  uint64_t result = 0x6E776F6E6B6E55;
  switch(*v0)
  {
    case 0:
      return result;
    case 1:
      unsigned int v2 = 1634038339;
      goto LABEL_6;
    case 2:
      uint64_t result = 0x646564616F4CLL;
      break;
    case 3:
      unsigned int v2 = 1633972309;
LABEL_6:
      uint64_t result = v2 | 0x64657400000000;
      break;
    default:
      uint64_t result = 0x44494C41564E49;
      break;
  }
  return result;
}

uint64_t static Enumerator.Options.descendRecursively.getter()
{
  return 1;
}

Swift::Int sub_1000094C4()
{
  return Hasher._finalize()();
}

uint64_t sub_10000951C()
{
  return String.hash(into:)();
}

Swift::Int sub_100009538()
{
  return Hasher._finalize()();
}

uint64_t sub_10000958C@<X0>(Swift::String *a1@<X0>, BOOL *a2@<X8>)
{
  Swift::Int v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_10040EFC0, *a1);
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v3 != 0;
  return result;
}

void sub_1000095E0(void *a1@<X8>)
{
  *a1 = 0xD000000000000020;
  a1[1] = 0x8000000100303D80;
}

unint64_t sub_100009600()
{
  return 0xD000000000000020;
}

uint64_t sub_10000961C@<X0>(Swift::String string@<0:X0, 8:X1>, BOOL *a2@<X8>)
{
  object = string._object;
  v3._countAndFlagsBits = string._countAndFlagsBits;
  v3._object = object;
  Swift::Int v5 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_10040EFF8, v3);
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v5 != 0;
  return result;
}

void sub_100009674(unsigned char *a1@<X8>)
{
  *a1 = 1;
}

uint64_t sub_100009680(uint64_t a1)
{
  unint64_t v2 = sub_10000B98C();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000096BC(uint64_t a1)
{
  unint64_t v2 = sub_10000B98C();
  return CodingKey.debugDescription.getter(a1, v2);
}

void *sub_1000096F8(void *a1)
{
  Swift::String v3 = v1;
  ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v5 = sub_100006FC8(&qword_10047D028);
  uint64_t v12 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  id v7 = (char *)&v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = sub_10000700C(a1, a1[3]);
  sub_10000B98C();
  uint64_t v9 = v3;
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (v2)
  {

    sub_1000070A4((uint64_t)a1);
    swift_deallocPartialClassInstance();
  }
  else
  {
    uint64_t v10 = v12;
    sub_100006FC8(&qword_10047D038);
    sub_10000B9E0();
    KeyedDecodingContainer.decode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v10 + 8))(v7, v5);
    *(void *)&v9[OBJC_IVAR____TtC7backupd11MBVolumeMap__volumeIdentifiersByAPFSVolumeUUID] = v15;

    v14.receiver = v9;
    v14.super_class = ObjectType;
    uint64_t v8 = objc_msgSendSuper2(&v14, "init");
    sub_1000070A4((uint64_t)a1);
  }
  return v8;
}

uint64_t sub_1000098FC(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_100006FC8(&qword_10047D050);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  id v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_10000700C(a1, a1[3]);
  sub_10000B98C();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  uint64_t v8 = (uint64_t *)(v2 + OBJC_IVAR____TtC7backupd11MBVolumeMap__volumeIdentifiersByAPFSVolumeUUID);
  swift_beginAccess();
  uint64_t v10 = *v8;
  sub_100006FC8(&qword_10047D038);
  sub_10000BB0C();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

void *sub_100009A70(uint64_t a1)
{
  Swift::String v3 = (uint64_t *)(v1 + OBJC_IVAR____TtC7backupd11MBVolumeMap__volumeIdentifiersByAPFSVolumeUUID);
  swift_beginAccess();
  uint64_t v4 = *v3;
  if (*(void *)(v4 + 16) && (unint64_t v5 = sub_1000314D0(a1), (v6 & 1) != 0))
  {
    id v7 = *(void **)(*(void *)(v4 + 56) + 8 * v5);
    id v8 = v7;
  }
  else
  {
    id v7 = 0;
  }
  swift_endAccess();
  return v7;
}

uint64_t sub_100009C90(uint64_t a1)
{
  uint64_t v3 = type metadata accessor for UUID();
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  char v6 = (char *)&v26 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_100006FC8(&qword_10047D080);
  __chkstk_darwin(v7 - 8);
  uint64_t v9 = (char *)&v26 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = v1 + OBJC_IVAR____TtC7backupd11MBVolumeMap__volumeIdentifiersByAPFSVolumeUUID;
  swift_beginAccess();
  if (v10 != *(void *)(*(void *)v11 + 16)) {
    return 0;
  }
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v26 = a1 + 56;
  uint64_t v13 = 1 << *(unsigned char *)(a1 + 32);
  uint64_t v14 = -1;
  if (v13 < 64) {
    uint64_t v14 = ~(-1 << v13);
  }
  unint64_t v15 = v14 & v12;
  uint64_t v29 = v4 + 16;
  objc_super v30 = (void (**)(char *, uint64_t, uint64_t, uint64_t))(v4 + 56);
  int64_t v27 = (unint64_t)(v13 + 63) >> 6;
  uint64_t v28 = v4 + 48;
  uint64_t v16 = (void (**)(char *, uint64_t))(v4 + 8);
  uint64_t v31 = a1;
  uint64_t result = swift_bridgeObjectRetain();
  int64_t v18 = 0;
  if (!v15) {
    goto LABEL_6;
  }
LABEL_5:
  unint64_t v19 = __clz(__rbit64(v15));
  v15 &= v15 - 1;
  for (unint64_t i = v19 | (v18 << 6); ; unint64_t i = __clz(__rbit64(v22)) + (v18 << 6))
  {
    (*(void (**)(char *, unint64_t, uint64_t))(v4 + 16))(v9, *(void *)(v31 + 48) + *(void *)(v4 + 72) * i, v3);
    (*(void (**)(char *, void, uint64_t, uint64_t))(v4 + 56))(v9, 0, 1, v3);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v4 + 48))(v9, 1, v3) == 1)
    {
      swift_release();
      return 1;
    }
    (*(void (**)(char *, char *, uint64_t))(v4 + 32))(v6, v9, v3);
    swift_beginAccess();
    if (!*(void *)(*(void *)v11 + 16) || (sub_1000314D0((uint64_t)v6), (v24 & 1) == 0))
    {
      swift_endAccess();
      (*v16)(v6, v3);
      swift_release();
      return 0;
    }
    swift_endAccess();
    uint64_t result = ((uint64_t (*)(char *, uint64_t))*v16)(v6, v3);
    if (v15) {
      goto LABEL_5;
    }
LABEL_6:
    int64_t v21 = v18 + 1;
    if (__OFADD__(v18, 1))
    {
      __break(1u);
      goto LABEL_31;
    }
    if (v21 >= v27) {
      goto LABEL_29;
    }
    unint64_t v22 = *(void *)(v26 + 8 * v21);
    ++v18;
    if (!v22)
    {
      int64_t v18 = v21 + 1;
      if (v21 + 1 >= v27) {
        goto LABEL_29;
      }
      unint64_t v22 = *(void *)(v26 + 8 * v18);
      if (!v22)
      {
        int64_t v18 = v21 + 2;
        if (v21 + 2 >= v27) {
          goto LABEL_29;
        }
        unint64_t v22 = *(void *)(v26 + 8 * v18);
        if (!v22) {
          break;
        }
      }
    }
LABEL_19:
    unint64_t v15 = (v22 - 1) & v22;
  }
  int64_t v23 = v21 + 3;
  if (v23 >= v27)
  {
LABEL_29:
    uint64_t v25 = 1;
    (*v30)(v9, 1, 1, v3);
    swift_release();
    return v25;
  }
  unint64_t v22 = *(void *)(v26 + 8 * v23);
  if (v22)
  {
    int64_t v18 = v23;
    goto LABEL_19;
  }
  while (1)
  {
    int64_t v18 = v23 + 1;
    if (__OFADD__(v23, 1)) {
      break;
    }
    if (v18 >= v27) {
      goto LABEL_29;
    }
    unint64_t v22 = *(void *)(v26 + 8 * v18);
    ++v23;
    if (v22) {
      goto LABEL_19;
    }
  }
LABEL_31:
  __break(1u);
  return result;
}

void sub_10000A064(uint64_t a1)
{
  uint64_t v130 = type metadata accessor for Date();
  unint64_t v117 = *(void *)(v130 - 8);
  uint64_t v3 = __chkstk_darwin(v130);
  v121 = (char *)&v114 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v3);
  v126 = (char *)&v114 - v5;
  uint64_t v6 = sub_100006FC8(&qword_10047D080);
  __chkstk_darwin(v6 - 8);
  v123 = (char *)&v114 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for UUID();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = __chkstk_darwin(v8);
  v125 = (char *)&v114 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = __chkstk_darwin(v10);
  v120 = (char *)&v114 - v13;
  uint64_t v14 = __chkstk_darwin(v12);
  v132 = (char *)&v114 - v15;
  uint64_t v16 = __chkstk_darwin(v14);
  int64_t v18 = (char *)&v114 - v17;
  __chkstk_darwin(v16);
  uint64_t v20 = (char *)&v114 - v19;
  uint64_t v21 = sub_100006FC8(&qword_10047D088);
  uint64_t v22 = __chkstk_darwin(v21 - 8);
  char v24 = (char *)&v114 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v22);
  uint64_t v26 = (char *)&v114 - v25;
  int64_t v27 = (uint64_t *)(v1 + OBJC_IVAR____TtC7backupd11MBVolumeMap__volumeIdentifiersByAPFSVolumeUUID);
  v131 = v27;
  swift_beginAccess();
  uint64_t v28 = *v27;
  uint64_t v29 = *(void *)(*v27 + 64);
  uint64_t v118 = *v27 + 64;
  uint64_t v30 = 1 << *(unsigned char *)(v28 + 32);
  if (v30 < 64) {
    uint64_t v31 = ~(-1 << v30);
  }
  else {
    uint64_t v31 = -1;
  }
  unint64_t v32 = v31 & v29;
  unint64_t v33 = (unint64_t)(v30 + 63) >> 6;
  v133 = (void (**)(char *, char *, uint64_t))(v9 + 32);
  uint64_t v138 = a1 + 56;
  uint64_t v139 = v9 + 16;
  uint64_t v136 = v9;
  v140 = (void (**)(char *, uint64_t))(v9 + 8);
  uint64_t v141 = a1;
  unint64_t v114 = v33 - 1;
  uint64_t v34 = swift_bridgeObjectRetain();
  unint64_t v35 = v32;
  unint64_t v36 = 0;
  v122 = (void (**)(char *, char *, uint64_t))v33;
  unint64_t v115 = v33 - 5;
  id v37 = (uint64_t *)&unk_10047D090;
  uint64_t v127 = v34;
  uint64_t v116 = v34 + 104;
  int64_t v124 = 0x80000001003042F0;
  v129 = v24;
  v128 = v26;
  while (1)
  {
    if (v35)
    {
      uint64_t v135 = (v35 - 1) & v35;
      unint64_t v40 = __clz(__rbit64(v35)) | (v36 << 6);
LABEL_10:
      uint64_t v41 = v127;
      (*(void (**)(char *, unint64_t, uint64_t))(v136 + 16))(v24, *(void *)(v127 + 48) + *(void *)(v136 + 72) * v40, v8);
      uint64_t v42 = *(void *)(v41 + 56);
      uint64_t v43 = sub_100006FC8(v37);
      id v44 = *(void **)(v42 + 8 * v40);
      *(void *)&v24[*(int *)(v43 + 48)] = v44;
      (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v43 - 8) + 56))(v24, 0, 1, v43);
      id v45 = v44;
      goto LABEL_17;
    }
    uint64_t v46 = v36 + 1;
    if (__OFADD__(v36, 1))
    {
      __break(1u);
LABEL_67:
      __break(1u);
      goto LABEL_68;
    }
    if (v46 >= (uint64_t)v122)
    {
      unint64_t v48 = v36;
    }
    else
    {
      unint64_t v47 = *(void *)(v118 + 8 * v46);
      if (v47) {
        goto LABEL_14;
      }
      unint64_t v48 = v36 + 1;
      if ((uint64_t)(v36 + 2) < (uint64_t)v122)
      {
        unint64_t v47 = *(void *)(v118 + 8 * (v36 + 2));
        if (v47)
        {
          uint64_t v46 = v36 + 2;
LABEL_14:
          uint64_t v135 = (v47 - 1) & v47;
          unint64_t v40 = __clz(__rbit64(v47)) + (v46 << 6);
          unint64_t v36 = v46;
          goto LABEL_10;
        }
        unint64_t v48 = v36 + 2;
        if ((uint64_t)(v36 + 3) < (uint64_t)v122)
        {
          unint64_t v47 = *(void *)(v118 + 8 * (v36 + 3));
          if (v47)
          {
            uint64_t v46 = v36 + 3;
            goto LABEL_14;
          }
          uint64_t v46 = v36 + 4;
          unint64_t v48 = v36 + 3;
          if ((uint64_t)(v36 + 4) < (uint64_t)v122)
          {
            unint64_t v47 = *(void *)(v118 + 8 * v46);
            if (v47) {
              goto LABEL_14;
            }
            while (v115 != v36)
            {
              unint64_t v47 = *(void *)(v116 + 8 * v36++);
              if (v47)
              {
                uint64_t v46 = v36 + 4;
                goto LABEL_14;
              }
            }
            unint64_t v48 = v114;
          }
        }
      }
    }
    uint64_t v49 = sub_100006FC8(v37);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v49 - 8) + 56))(v24, 1, 1, v49);
    uint64_t v135 = 0;
    unint64_t v36 = v48;
LABEL_17:
    sub_10000C718((uint64_t)v24, (uint64_t)v26);
    uint64_t v50 = sub_100006FC8(v37);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(v50 - 8) + 48))(v26, 1, v50) == 1) {
      break;
    }
    unint64_t v134 = v36;
    uint64_t v51 = v37;
    v137 = *(void **)&v26[*(int *)(v50 + 48)];
    (*v133)(v20, v26, v8);
    if (*(void *)(v141 + 16)
      && (uint64_t v52 = v141,
          sub_10000C780((unint64_t *)&qword_10047D400, 255, (void (*)(uint64_t))&type metadata accessor for UUID), v53 = dispatch thunk of Hashable._rawHashValue(seed:)(), v54 = -1 << *(unsigned char *)(v52 + 32), unint64_t v55 = v53 & ~v54, ((*(void *)(v138 + ((v55 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v55) & 1) != 0))
    {
      uint64_t v56 = ~v54;
      uint64_t v57 = *(void *)(v136 + 72);
      unsigned int v58 = *(void (**)(char *, unint64_t, uint64_t))(v136 + 16);
      while (1)
      {
        v58(v18, *(void *)(v141 + 48) + v57 * v55, v8);
        sub_10000C780(&qword_10047D098, 255, (void (*)(uint64_t))&type metadata accessor for UUID);
        char v59 = dispatch thunk of static Equatable.== infix(_:_:)();
        v60 = *v140;
        (*v140)(v18, v8);
        if (v59) {
          break;
        }
        unint64_t v55 = (v55 + 1) & v56;
        if (((*(void *)(v138 + ((v55 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v55) & 1) == 0) {
          goto LABEL_23;
        }
      }
      v60(v20, v8);

      char v24 = v129;
      uint64_t v26 = v128;
      id v37 = v51;
    }
    else
    {
LABEL_23:
      uint64_t v144 = 0;
      unint64_t v145 = 0xE000000000000000;
      _StringGuts.grow(_:)(29);
      swift_bridgeObjectRelease();
      uint64_t v144 = 0xD00000000000001BLL;
      unint64_t v145 = v124;
      id v61 = [v137 description];
      uint64_t v62 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      v64 = v63;

      v65._countAndFlagsBits = v62;
      v65._object = v64;
      String.append(_:)(v65);
      swift_bridgeObjectRelease();
      sub_100046294(v144, v145, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);
      swift_bridgeObjectRelease();
      v66 = v131;
      swift_beginAccess();
      swift_bridgeObjectRetain();
      unint64_t v67 = sub_1000314D0((uint64_t)v20);
      LOBYTE(v64) = v68;
      swift_bridgeObjectRelease();
      uint64_t v39 = 0;
      id v37 = v51;
      if (v64)
      {
        char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
        uint64_t v70 = *v66;
        uint64_t v142 = *v66;
        uint64_t *v66 = 0x8000000000000000;
        if ((isUniquelyReferenced_nonNull_native & 1) == 0)
        {
          sub_100033090();
          uint64_t v70 = v142;
        }
        (*(void (**)(unint64_t, uint64_t))(v136 + 8))(*(void *)(v70 + 48) + *(void *)(v136 + 72) * v67, v8);
        uint64_t v38 = v142;
        uint64_t v39 = *(void **)(*(void *)(v142 + 56) + 8 * v67);
        sub_1000437B0(v67, v142);
        uint64_t *v66 = v38;
        swift_bridgeObjectRelease();
      }
      swift_endAccess();

      (*v140)(v20, v8);
      char v24 = v129;
      uint64_t v26 = v128;
    }
    unint64_t v36 = v134;
    unint64_t v35 = v135;
  }
  swift_release();
  uint64_t v71 = 1 << *(unsigned char *)(v141 + 32);
  uint64_t v72 = -1;
  if (v71 < 64) {
    uint64_t v72 = ~(-1 << v71);
  }
  unint64_t v73 = v72 & *(void *)(v141 + 56);
  int64_t v124 = (unint64_t)(v71 + 63) >> 6;
  v128 = (char *)(v136 + 56);
  uint64_t v127 = v136 + 48;
  v122 = (void (**)(char *, char *, uint64_t))(v117 + 16);
  v137 = (void *)(v117 + 8);
  swift_bridgeObjectRetain();
  int64_t v74 = 0;
  uint64_t v118 = 0x80000001003042A0;
  unint64_t v117 = 0x80000001003042C0;
  v75 = v123;
  v76 = v131;
  v119 = v18;
  while (1)
  {
    if (v73)
    {
      unint64_t v95 = __clz(__rbit64(v73));
      v73 &= v73 - 1;
      unint64_t v96 = v95 | (v74 << 6);
      v97 = v133;
      goto LABEL_60;
    }
    int64_t v98 = v74 + 1;
    v97 = v133;
    if (__OFADD__(v74, 1)) {
      goto LABEL_67;
    }
    if (v98 >= v124)
    {
LABEL_64:
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))v128)(v75, 1, 1, v8);
LABEL_65:
      swift_release();
      return;
    }
    unint64_t v99 = *(void *)(v138 + 8 * v98);
    ++v74;
    if (!v99)
    {
      int64_t v74 = v98 + 1;
      if (v98 + 1 >= v124) {
        goto LABEL_64;
      }
      unint64_t v99 = *(void *)(v138 + 8 * v74);
      if (!v99)
      {
        int64_t v74 = v98 + 2;
        if (v98 + 2 >= v124) {
          goto LABEL_64;
        }
        unint64_t v99 = *(void *)(v138 + 8 * v74);
        if (!v99) {
          break;
        }
      }
    }
LABEL_59:
    unint64_t v73 = (v99 - 1) & v99;
    unint64_t v96 = __clz(__rbit64(v99)) + (v74 << 6);
LABEL_60:
    uint64_t v101 = v136;
    v102 = *(void (**)(char *, unint64_t, uint64_t))(v136 + 16);
    v102(v75, *(void *)(v141 + 48) + *(void *)(v136 + 72) * v96, v8);
    (*(void (**)(char *, void, uint64_t, uint64_t))(v101 + 56))(v75, 0, 1, v8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v101 + 48))(v75, 1, v8) == 1) {
      goto LABEL_65;
    }
    uint64_t v103 = (uint64_t)v132;
    (*v97)(v132, v75, v8);
    swift_beginAccess();
    uint64_t v104 = *v76;
    if (*(void *)(*v76 + 16) && (unint64_t v105 = sub_1000314D0(v103), (v106 & 1) != 0))
    {
      v107 = *(void **)(*(void *)(v104 + 56) + 8 * v105);
      swift_endAccess();
      uint64_t v144 = 0;
      unint64_t v145 = 0xE000000000000000;
      id v108 = v107;
      _StringGuts.grow(_:)(38);
      swift_bridgeObjectRelease();
      uint64_t v144 = 0xD000000000000024;
      unint64_t v145 = v117;
      id v109 = [v108 description];
      uint64_t v110 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      v112 = v111;

      v113._countAndFlagsBits = v110;
      v113._object = v112;
      String.append(_:)(v113);
      swift_bridgeObjectRelease();
      sub_100046294(v144, v145, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);

      swift_bridgeObjectRelease();
      (*v140)(v132, v8);
    }
    else
    {
      swift_endAccess();
      UUID.init()();
      v77 = v126;
      static Date.now.getter();
      uint64_t v135 = v74;
      uint64_t v78 = (uint64_t)v120;
      v102(v120, (unint64_t)v18, v8);
      v79 = v125;
      v102(v125, v103, v8);
      v80 = *v122;
      unint64_t v134 = v73;
      v81 = v121;
      v80(v121, v77, v130);
      v82 = (objc_class *)type metadata accessor for MBVolumeIdentifier();
      v83 = (char *)objc_allocWithZone(v82);
      v102(&v83[OBJC_IVAR____TtC7backupd18MBVolumeIdentifier_backupVolumeUUID], v78, v8);
      v102(&v83[OBJC_IVAR____TtC7backupd18MBVolumeIdentifier_apfsVolumeUUID], (unint64_t)v79, v8);
      uint64_t v84 = v130;
      v80(&v83[OBJC_IVAR____TtC7backupd18MBVolumeIdentifier_creationDate], v81, v130);
      int64_t v18 = v119;
      v143.receiver = v83;
      v143.super_class = v82;
      id v85 = objc_msgSendSuper2(&v143, "init");
      v129 = (char *)*v137;
      ((void (*)(char *, uint64_t))v129)(v81, v84);
      v86 = *v140;
      v76 = v131;
      (*v140)(v125, v8);
      v86((char *)v78, v8);
      v102((char *)v78, (unint64_t)v132, v8);
      swift_beginAccess();
      id v87 = v85;
      char v88 = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v142 = *v76;
      uint64_t *v76 = 0x8000000000000000;
      sub_100032B14((uint64_t)v87, v78, v88);
      uint64_t *v76 = v142;
      swift_bridgeObjectRelease();
      uint64_t v89 = v78;
      int64_t v74 = v135;
      v86((char *)v89, v8);
      swift_endAccess();
      uint64_t v144 = 0;
      unint64_t v145 = 0xE000000000000000;
      _StringGuts.grow(_:)(32);
      swift_bridgeObjectRelease();
      uint64_t v144 = 0xD00000000000001ELL;
      unint64_t v145 = v118;
      id v90 = [v87 description];
      uint64_t v91 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      v93 = v92;

      v94._countAndFlagsBits = v91;
      v94._object = v93;
      String.append(_:)(v94);
      swift_bridgeObjectRelease();
      sub_100046294(v144, v145, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);

      swift_bridgeObjectRelease();
      ((void (*)(char *, uint64_t))v129)(v126, v130);
      v86(v18, v8);
      v86(v132, v8);
      unint64_t v73 = v134;
    }
    v75 = v123;
  }
  int64_t v100 = v98 + 3;
  if (v100 >= v124) {
    goto LABEL_64;
  }
  unint64_t v99 = *(void *)(v138 + 8 * v100);
  if (v99)
  {
    int64_t v74 = v100;
    goto LABEL_59;
  }
  while (1)
  {
    int64_t v74 = v100 + 1;
    if (__OFADD__(v100, 1)) {
      break;
    }
    if (v74 >= v124) {
      goto LABEL_64;
    }
    unint64_t v99 = *(void *)(v138 + 8 * v74);
    ++v100;
    if (v99) {
      goto LABEL_59;
    }
  }
LABEL_68:
  __break(1u);
}

void sub_10000B0AC(uint64_t a1)
{
  uint64_t ObjectType = swift_getObjectType();
  uint64_t v2 = type metadata accessor for URLResourceValues();
  uint64_t v35 = *(void *)(v2 - 8);
  uint64_t v36 = v2;
  __chkstk_darwin(v2);
  uint64_t v4 = (char *)&v34 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = type metadata accessor for URL.DirectoryHint();
  uint64_t v38 = *(void *)(v5 - 8);
  uint64_t v39 = v5;
  __chkstk_darwin(v5);
  id v37 = (char *)&v34 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_100006FC8(&qword_10047D068);
  __chkstk_darwin(v7 - 8);
  uint64_t v9 = (char *)&v34 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = type metadata accessor for URL();
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v42 = v10;
  uint64_t v43 = v11;
  __chkstk_darwin(v10);
  id v44 = (char *)&v34 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = type metadata accessor for FilePath();
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = __chkstk_darwin(v13);
  __chkstk_darwin(v15);
  uint64_t v17 = (char *)&v34 - v16;
  swift_bridgeObjectRetain();
  FilePath.init(_:)();
  FilePath.removingLastComponent()();
  FilePath.string.getter();
  (*(void (**)(char *, uint64_t))(v14 + 8))(v17, v13);
  sub_10000C680();
  id v18 = v45;
  id v19 = sub_10002DC58();
  if (!v18)
  {
    uint64_t v20 = v4;
    id v45 = v19;
    id v21 = objc_msgSend(v19, "makeTemporaryFilePath", a1);
    uint64_t v22 = static String._unconditionallyBridgeFromObjectiveC(_:)();

    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v43 + 56))(v9, 1, 1, v42);
    (*(void (**)(char *, void, uint64_t))(v38 + 104))(v37, enum case for URL.DirectoryHint.inferFromPath(_:), v39);
    swift_bridgeObjectRetain();
    URL.init(filePath:directoryHint:relativeTo:)();
    type metadata accessor for PropertyListEncoder();
    swift_allocObject();
    PropertyListEncoder.init()();
    uint64_t v46 = v40;
    sub_10000C780(&qword_10047D078, v23, (void (*)(uint64_t))type metadata accessor for MBVolumeMap);
    uint64_t v24 = dispatch thunk of PropertyListEncoder.encode<A>(_:)();
    unint64_t v26 = v25;
    uint64_t v27 = v43;
    swift_release();
    Data.write(to:options:)();
    uint64_t ObjectType = v22;
    uint64_t v28 = v20;
    URLResourceValues.init()();
    URLResourceValues.isExcludedFromBackup.setter();
    URL.setResourceValues(_:)();
    sub_100006FC8((uint64_t *)&unk_10047D910);
    unint64_t v29 = swift_allocBox();
    FilePath.init(_:)();
    unint64_t v30 = swift_allocBox();
    swift_bridgeObjectRetain();
    FilePath.init(_:)();
    sub_100007500(v30, v29);
    uint64_t v32 = v35;
    uint64_t v31 = v36;
    swift_release();
    swift_release();
    sub_10000C6C0(v24, v26);
    (*(void (**)(char *, uint64_t))(v32 + 8))(v28, v31);
    (*(void (**)(char *, uint64_t))(v27 + 8))(v44, v42);
    id v33 = v45;
    [v45 dispose];
  }
}

uint64_t type metadata accessor for MBVolumeMap()
{
  return self;
}

void *sub_10000B918@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  id v6 = objc_allocWithZone(v2);
  uint64_t result = sub_1000096F8(a1);
  if (!v3) {
    *a2 = result;
  }
  return result;
}

uint64_t sub_10000B968(void *a1)
{
  return sub_1000098FC(a1);
}

unint64_t sub_10000B98C()
{
  unint64_t result = qword_10047D030;
  if (!qword_10047D030)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D030);
  }
  return result;
}

unint64_t sub_10000B9E0()
{
  unint64_t result = qword_10047D040;
  if (!qword_10047D040)
  {
    sub_10000BAC4(&qword_10047D038);
    sub_10000C780(&qword_10047CD38, 255, (void (*)(uint64_t))&type metadata accessor for UUID);
    sub_10000C780(&qword_10047D048, 255, (void (*)(uint64_t))type metadata accessor for MBVolumeIdentifier);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D040);
  }
  return result;
}

uint64_t sub_10000BAC4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState2();
    *a1 = result;
  }
  return result;
}

unint64_t sub_10000BB0C()
{
  unint64_t result = qword_10047D058;
  if (!qword_10047D058)
  {
    sub_10000BAC4(&qword_10047D038);
    sub_10000C780(&qword_10047CD50, 255, (void (*)(uint64_t))&type metadata accessor for UUID);
    sub_10000C780(&qword_10047D060, 255, (void (*)(uint64_t))type metadata accessor for MBVolumeIdentifier);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D058);
  }
  return result;
}

unint64_t sub_10000BBF0(unint64_t result)
{
  if (result > 3) {
    return 0;
  }
  return result;
}

id sub_10000BC00(uint64_t a1, void *a2)
{
  uint64_t v30 = type metadata accessor for URL.DirectoryHint();
  uint64_t v4 = *(void *)(v30 - 8);
  __chkstk_darwin(v30);
  id v6 = (char *)&v29 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_100006FC8(&qword_10047D068);
  __chkstk_darwin(v7 - 8);
  uint64_t v9 = (char *)&v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = type metadata accessor for URL();
  uint64_t v29 = *(void *)(v10 - 8);
  __chkstk_darwin(v10);
  uint64_t v12 = (char *)&v29 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  id v13 = [self defaultManager];
  NSString v14 = String._bridgeToObjectiveC()();
  unsigned __int8 v15 = [v13 fileExistsAtPath:v14];

  if (v15)
  {
    uint64_t v16 = v29;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 56))(v9, 1, 1, v10);
    (*(void (**)(char *, void, uint64_t))(v4 + 104))(v6, enum case for URL.DirectoryHint.inferFromPath(_:), v30);
    swift_bridgeObjectRetain();
    URL.init(filePath:directoryHint:relativeTo:)();
    uint64_t v17 = Data.init(contentsOf:options:)();
    unint64_t v19 = v18;
    uint64_t v20 = v10;
    uint64_t v21 = v16;
    uint64_t v23 = v17;
    uint64_t v24 = v20;
    type metadata accessor for PropertyListDecoder();
    swift_allocObject();
    PropertyListDecoder.init()();
    type metadata accessor for MBVolumeMap();
    sub_10000C780(&qword_10047D0A8, v25, (void (*)(uint64_t))type metadata accessor for MBVolumeMap);
    dispatch thunk of PropertyListDecoder.decode<A>(_:from:)();
    swift_release();
    uint64_t v27 = v31;
    uint64_t v31 = 0;
    unint64_t v32 = 0xE000000000000000;
    _StringGuts.grow(_:)(23);
    swift_bridgeObjectRelease();
    uint64_t v31 = 0xD000000000000015;
    unint64_t v32 = 0x8000000100304380;
    v28._countAndFlagsBits = a1;
    v28._object = a2;
    String.append(_:)(v28);
    sub_100045F18(v31, v32, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);
    sub_10000C6C0(v23, v19);
    swift_bridgeObjectRelease();
    (*(void (**)(char *, uint64_t))(v21 + 8))(v12, v24);
  }
  else
  {
    uint64_t v31 = 0;
    unint64_t v32 = 0xE000000000000000;
    _StringGuts.grow(_:)(34);
    swift_bridgeObjectRelease();
    uint64_t v31 = 0xD000000000000020;
    unint64_t v32 = 0x8000000100304310;
    v22._countAndFlagsBits = a1;
    v22._object = a2;
    String.append(_:)(v22);
    sub_100046294(v31, v32, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);
    swift_bridgeObjectRelease();
    return [objc_allocWithZone((Class)type metadata accessor for MBVolumeMap()) init];
  }
  return (id)v27;
}

id sub_10000C170(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v43 = a2;
  uint64_t v41 = a4;
  uint64_t v42 = a1;
  uint64_t v5 = type metadata accessor for UUID();
  uint64_t v6 = __chkstk_darwin(v5);
  uint64_t v49 = (char *)&v40 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = __chkstk_darwin(v6);
  uint64_t v48 = (uint64_t)&v40 - v9;
  __chkstk_darwin(v8);
  uint64_t v12 = (char *)&v40 - v11;
  v51[1] = &_swiftEmptySetSingleton;
  uint64_t v13 = *(void *)(a3 + 56);
  uint64_t v45 = a3 + 56;
  uint64_t v14 = 1 << *(unsigned char *)(a3 + 32);
  uint64_t v15 = -1;
  if (v14 < 64) {
    uint64_t v15 = ~(-1 << v14);
  }
  uint64_t v16 = v15 & v13;
  int64_t v46 = (unint64_t)(v14 + 63) >> 6;
  unint64_t v47 = (void (**)(char *, char *, uint64_t))(v10 + 16);
  uint64_t v17 = (void (**)(uint64_t, uint64_t))(v10 + 8);
  uint64_t v50 = a3;
  swift_bridgeObjectRetain();
  int64_t v18 = 0;
  if (!v16) {
    goto LABEL_5;
  }
LABEL_4:
  for (v16 &= v16 - 1; ; uint64_t v16 = (v20 - 1) & v20)
  {
    Swift::String v22 = self;
    swift_bridgeObjectRetain();
    NSString v23 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    v51[0] = 0;
    id v24 = [v22 volumeUUIDWithVolumeMountPoint:v23 error:v51];

    id v25 = v51[0];
    if (!v24)
    {
      id v30 = v51[0];
      _convertNSErrorToError(_:)();

      swift_willThrow();
      swift_release();
      goto LABEL_29;
    }
    static UUID._unconditionallyBridgeFromObjectiveC(_:)();
    id v26 = v25;

    uint64_t v27 = v49;
    (*v47)(v49, v12, v5);
    uint64_t v28 = v48;
    sub_100012F28(v48, v27);
    uint64_t v29 = *v17;
    (*v17)(v28, v5);
    v29((uint64_t)v12, v5);
    if (v16) {
      goto LABEL_4;
    }
LABEL_5:
    int64_t v19 = v18 + 1;
    if (__OFADD__(v18, 1))
    {
      __break(1u);
      goto LABEL_36;
    }
    if (v19 >= v46) {
      goto LABEL_23;
    }
    uint64_t v20 = *(void *)(v45 + 8 * v19);
    ++v18;
    if (!v20)
    {
      int64_t v18 = v19 + 1;
      if (v19 + 1 >= v46) {
        goto LABEL_23;
      }
      uint64_t v20 = *(void *)(v45 + 8 * v18);
      if (!v20)
      {
        int64_t v18 = v19 + 2;
        if (v19 + 2 >= v46) {
          goto LABEL_23;
        }
        uint64_t v20 = *(void *)(v45 + 8 * v18);
        if (!v20) {
          break;
        }
      }
    }
LABEL_18:
    ;
  }
  int64_t v21 = v19 + 3;
  if (v21 < v46)
  {
    uint64_t v20 = *(void *)(v45 + 8 * v21);
    if (!v20)
    {
      while (1)
      {
        int64_t v18 = v21 + 1;
        if (__OFADD__(v21, 1)) {
          break;
        }
        if (v18 >= v46) {
          goto LABEL_23;
        }
        uint64_t v20 = *(void *)(v45 + 8 * v18);
        ++v21;
        if (v20) {
          goto LABEL_18;
        }
      }
LABEL_36:
      __break(1u);
    }
    int64_t v18 = v21;
    goto LABEL_18;
  }
LABEL_23:
  swift_release();
  uint64_t v31 = v42;
  id v24 = sub_10000BC00(v42, v43);
  char v33 = v32;
  if (v32)
  {
    uint64_t v34 = v44;
    goto LABEL_27;
  }
  uint64_t v35 = swift_bridgeObjectRetain();
  char v36 = sub_100009C90(v35);
  swift_bridgeObjectRelease();
  uint64_t v34 = v44;
  if ((v36 & 1) == 0)
  {
LABEL_27:
    uint64_t v38 = swift_bridgeObjectRetain();
    sub_10000A064(v38);
    swift_bridgeObjectRelease();
    sub_10000B0AC(v31);
    if (!v34)
    {
      if (v33)
      {
        sub_100045F18(0xD000000000000016, 0x8000000100304240, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);
        uint64_t v37 = 1;
      }
      else
      {
        sub_100045F18(0xD000000000000016, 0x8000000100304220, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);
        uint64_t v37 = 3;
      }
      goto LABEL_33;
    }

LABEL_29:
    swift_bridgeObjectRelease();
    return v24;
  }
  sub_100045F18(0xD000000000000015, 0x8000000100304260, 0x2D656D756C6F763DLL, 0xED0000203D70616DLL);
  uint64_t v37 = 2;
LABEL_33:
  uint64_t *v41 = v37;
  swift_bridgeObjectRelease();
  return v24;
}

unint64_t sub_10000C680()
{
  unint64_t result = qword_10047D070;
  if (!qword_10047D070)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_10047D070);
  }
  return result;
}

uint64_t sub_10000C6C0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_release();
  }
  return swift_release();
}

uint64_t sub_10000C718(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100006FC8(&qword_10047D088);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t sub_10000C780(unint64_t *a1, uint64_t a2, void (*a3)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a3(a2);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

void sub_10000C7C8(void *a1, uint64_t *a2)
{
  id v5 = [a1 volumeMapPlistPath];
  uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v8 = v7;

  id v9 = [a1 volumesToBackUp];
  uint64_t v10 = static Set._unconditionallyBridgeFromObjectiveC(_:)();

  uint64_t v11 = (char *)sub_10000C170(v6, v8, v10, a2);
  if (v2)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v12 = &v11[OBJC_IVAR____TtC7backupd11MBVolumeMap__volumeIdentifiersByAPFSVolumeUUID];
  swift_beginAccess();
  uint64_t v13 = *(void *)v12;
  uint64_t v37 = *(void *)v12 + 64;
  uint64_t v14 = 1 << *(unsigned char *)(*(void *)v12 + 32);
  uint64_t v15 = -1;
  if (v14 < 64) {
    uint64_t v15 = ~(-1 << v14);
  }
  unint64_t v16 = v15 & *(void *)(*(void *)v12 + 64);
  int64_t v38 = (unint64_t)(v14 + 63) >> 6;
  swift_bridgeObjectRetain();
  int64_t v17 = 0;
  if (v16) {
    goto LABEL_8;
  }
LABEL_9:
  int64_t v20 = v17 + 1;
  if (!__OFADD__(v17, 1))
  {
    if (v20 < v38)
    {
      unint64_t v21 = *(void *)(v37 + 8 * v20);
      int64_t v22 = v17 + 1;
      if (v21) {
        goto LABEL_24;
      }
      int64_t v22 = v17 + 2;
      if (v17 + 2 >= v38) {
        goto LABEL_30;
      }
      unint64_t v21 = *(void *)(v37 + 8 * v22);
      if (v21) {
        goto LABEL_24;
      }
      int64_t v22 = v17 + 3;
      if (v17 + 3 >= v38) {
        goto LABEL_30;
      }
      unint64_t v21 = *(void *)(v37 + 8 * v22);
      if (v21) {
        goto LABEL_24;
      }
      int64_t v22 = v17 + 4;
      if (v17 + 4 >= v38) {
        goto LABEL_30;
      }
      unint64_t v21 = *(void *)(v37 + 8 * v22);
      if (v21)
      {
LABEL_24:
        unint64_t v16 = (v21 - 1) & v21;
        int64_t v41 = v22;
        for (unint64_t i = __clz(__rbit64(v21)) + (v22 << 6); ; unint64_t i = v18 | (v17 << 6))
        {
          id v24 = *(void **)(*(void *)(v13 + 56) + 8 * i);
          uint64_t v39 = 0;
          unint64_t v40 = 0xE000000000000000;
          id v25 = v24;
          _StringGuts.grow(_:)(28);
          swift_bridgeObjectRelease();
          uint64_t v39 = 0xD00000000000001ALL;
          unint64_t v40 = 0x80000001003043A0;
          id v26 = [v25 description];
          uint64_t v27 = static String._unconditionallyBridgeFromObjectiveC(_:)();
          uint64_t v29 = v28;

          v30._countAndFlagsBits = v27;
          v30._object = v29;
          String.append(_:)(v30);
          swift_bridgeObjectRelease();
          uint64_t v32 = v39;
          unint64_t v31 = v40;
          if (qword_10047CB30 != -1) {
            swift_once();
          }
          uint64_t v33 = type metadata accessor for Logger();
          sub_10000CC8C(v33, (uint64_t)qword_10047F400);
          swift_bridgeObjectRetain_n();
          uint64_t v34 = Logger.logObject.getter();
          os_log_type_t v35 = static os_log_type_t.default.getter();
          if (os_log_type_enabled(v34, v35))
          {
            uint64_t v36 = swift_slowAlloc();
            uint64_t v39 = swift_slowAlloc();
            *(_DWORD *)uint64_t v36 = 136315394;
            *(void *)(v36 + 4) = sub_100046E00(0x2D656D756C6F763DLL, 0xED0000203D70616DLL, &v39);
            *(_WORD *)(v36 + 12) = 2080;
            swift_bridgeObjectRetain();
            *(void *)(v36 + 14) = sub_100046E00(v32, v31, &v39);
            swift_bridgeObjectRelease_n();
            _os_log_impl((void *)&_mh_execute_header, v34, v35, "%s%s", (uint8_t *)v36, 0x16u);
            swift_arrayDestroy();
            swift_slowDealloc();
            swift_slowDealloc();

            swift_bridgeObjectRelease();
            int64_t v17 = v41;
            if (!v16) {
              goto LABEL_9;
            }
          }
          else
          {

            swift_bridgeObjectRelease_n();
            int64_t v17 = v41;
            if (!v16) {
              goto LABEL_9;
            }
          }
LABEL_8:
          unint64_t v18 = __clz(__rbit64(v16));
          v16 &= v16 - 1;
          int64_t v41 = v17;
        }
      }
      uint64_t v23 = v17 + 5;
      if (v17 + 5 < v38)
      {
        unint64_t v21 = *(void *)(v37 + 8 * v23);
        if (v21)
        {
          int64_t v22 = v17 + 5;
          goto LABEL_24;
        }
        while (1)
        {
          int64_t v22 = v23 + 1;
          if (__OFADD__(v23, 1)) {
            goto LABEL_32;
          }
          if (v22 >= v38) {
            break;
          }
          unint64_t v21 = *(void *)(v37 + 8 * v22);
          ++v23;
          if (v21) {
            goto LABEL_24;
          }
        }
      }
    }
LABEL_30:
    swift_release();
    return;
  }
  __break(1u);
LABEL_32:
  __break(1u);
}

uint64_t sub_10000CC8C(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(*(void *)(a1 - 8) + 82) & 2) != 0) {
    return *(void *)a2;
  }
  return a2;
}

uint64_t getEnumTagSinglePayload for MBVolumeMap.CodingKeys(unsigned int *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if ((a2 + 1) >= 0x10000) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) < 0x100) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4) {
    return *a1;
  }
  if (v3 == 2) {
    return *(unsigned __int16 *)a1;
  }
  return *(unsigned __int8 *)a1;
}

unsigned char *storeEnumTagSinglePayload for MBVolumeMap.CodingKeys(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *uint64_t result = a2;
        return result;
      case 2:
        *(_WORD *)uint64_t result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)uint64_t result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *uint64_t result = 0;
      break;
    case 2:
      *(_WORD *)uint64_t result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x10000CDB4);
    case 4:
      *(_DWORD *)uint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_10000CDDC()
{
  return 0;
}

ValueMetadata *type metadata accessor for MBVolumeMap.CodingKeys()
{
  return &type metadata for MBVolumeMap.CodingKeys;
}

ValueMetadata *type metadata accessor for MBVolumeMapLoadType()
{
  return &type metadata for MBVolumeMapLoadType;
}

unint64_t sub_10000CE08()
{
  unint64_t result = qword_10047D0B0;
  if (!qword_10047D0B0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D0B0);
  }
  return result;
}

unint64_t sub_10000CE60()
{
  unint64_t result = qword_10047D0B8;
  if (!qword_10047D0B8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D0B8);
  }
  return result;
}

unint64_t sub_10000CEB8()
{
  unint64_t result = qword_10047D0C0;
  if (!qword_10047D0C0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D0C0);
  }
  return result;
}

unint64_t sub_10000CF10()
{
  unint64_t result = qword_10047D0C8;
  if (!qword_10047D0C8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D0C8);
  }
  return result;
}

uint64_t type metadata accessor for MBFetchedAsset()
{
  return self;
}

unsigned char *storeEnumTagSinglePayload for MBFetchedAssetType(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    *unint64_t result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x10000D20CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 2;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBFetchedAssetType()
{
  return &type metadata for MBFetchedAssetType;
}

unint64_t sub_10000D248()
{
  unint64_t result = qword_10047D130;
  if (!qword_10047D130)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D130);
  }
  return result;
}

unint64_t sub_10000D29C()
{
  uint64_t v1 = v0;
  unint64_t v2 = 0xE000000000000000;
  _StringGuts.grow(_:)(33);
  swift_bridgeObjectRelease();
  unint64_t v23 = 0xD000000000000010;
  unint64_t v24 = 0x8000000100304510;
  id v3 = *(id *)(v0 + OBJC_IVAR____TtC7backupd14MBFetchedAsset_metadata);
  id v4 = [v3 description];
  uint64_t v5 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v7 = v6;

  v8._countAndFlagsBits = v5;
  v8._object = v7;
  String.append(_:)(v8);

  swift_bridgeObjectRelease();
  v9._countAndFlagsBits = 0x3A6F6E692820;
  v9._object = (void *)0xE600000000000000;
  String.append(_:)(v9);
  v22[0] = *(void *)(v1 + OBJC_IVAR____TtC7backupd14MBFetchedAsset_originalInode);
  v10._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
  String.append(_:)(v10);
  swift_bridgeObjectRelease();
  if (*(_DWORD *)(v1 + OBJC_IVAR____TtC7backupd14MBFetchedAsset__linkCount) == 1)
  {
    uint64_t v11 = 0;
  }
  else
  {
    _StringGuts.grow(_:)(16);
    swift_bridgeObjectRelease();
    strcpy((char *)v22, ", hardlinks: ");
    HIWORD(v22[1]) = -4864;
    v12._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v12);
    swift_bridgeObjectRelease();
    v13._countAndFlagsBits = 44;
    v13._object = (void *)0xE100000000000000;
    String.append(_:)(v13);
    uint64_t v11 = v22[0];
    unint64_t v2 = v22[1];
  }
  unint64_t v14 = v2;
  String.append(_:)(*(Swift::String *)&v11);
  swift_bridgeObjectRelease();
  v15._countAndFlagsBits = 32;
  v15._object = (void *)0xE100000000000000;
  String.append(_:)(v15);
  uint64_t v16 = v1 + OBJC_IVAR____TtC7backupd14MBFetchedAsset__debugRpath;
  uint64_t v17 = *(void *)(v1 + OBJC_IVAR____TtC7backupd14MBFetchedAsset__debugRpath);
  unint64_t v18 = *(void **)(v16 + 8);
  swift_bridgeObjectRetain();
  v19._countAndFlagsBits = v17;
  v19._object = v18;
  String.append(_:)(v19);
  swift_bridgeObjectRelease();
  v20._countAndFlagsBits = 15913;
  v20._object = (void *)0xE200000000000000;
  String.append(_:)(v20);
  return v23;
}

Swift::Int sub_10000D4BC()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_10000D504()
{
  Hasher._combine(_:)(*v0);
}

Swift::Int sub_10000D530()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

id sub_10000D574(void *a1, char a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  Swift::String v8 = v7;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  *(void *)&v8[OBJC_IVAR____TtC7backupd14MBFetchedAsset_metadata] = a1;
  v8[OBJC_IVAR____TtC7backupd14MBFetchedAsset_protectionClass] = a2;
  *(void *)&v8[OBJC_IVAR____TtC7backupd14MBFetchedAsset_originalFileSize] = a3;
  *(void *)&v8[OBJC_IVAR____TtC7backupd14MBFetchedAsset_originalInode] = a4;
  uint64_t v17 = v8;
  id v18 = a1;
  id v19 = [v18 assetType];
  unsigned int v20 = [v18 compressionMethod];
  char v21 = 2 * (v19 == (id)2);
  if (v20) {
    char v21 = 1;
  }
  v17[OBJC_IVAR____TtC7backupd14MBFetchedAsset_type] = v21;
  *(_DWORD *)&v17[OBJC_IVAR____TtC7backupd14MBFetchedAsset__linkCount] = a5;
  int64_t v22 = &v17[OBJC_IVAR____TtC7backupd14MBFetchedAsset__debugRpath];
  *int64_t v22 = a6;
  v22[1] = a7;

  v24.receiver = v17;
  v24.super_class = ObjectType;
  return objc_msgSendSuper2(&v24, "init");
}

void *initializeBufferWithCopyOfBuffer for MBRestorableOperationLogger(void *a1, uint64_t a2)
{
  id v3 = *(void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  *a1 = *(void *)a2;
  a1[1] = v4;
  id v5 = v3;
  swift_unknownObjectRetain();
  return a1;
}

uint64_t destroy for MBRestorableOperationLogger(id *a1)
{
  return swift_unknownObjectRelease();
}

uint64_t assignWithCopy for MBRestorableOperationLogger(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  id v5 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  id v6 = v4;

  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  return a1;
}

__n128 initializeWithTake for MBRestorableOperationLogger(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

id *assignWithTake for MBRestorableOperationLogger(id *a1, _OWORD *a2)
{
  *(_OWORD *)a1 = *a2;
  swift_unknownObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for MBRestorableOperationLogger(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for MBRestorableOperationLogger(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBRestorableOperationLogger()
{
  return &type metadata for MBRestorableOperationLogger;
}

char *sub_10000D84C(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13)
{
  unint64_t v14 = v13;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v15 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext__failures;
  sub_100006FC8(&qword_10047D3B8);
  uint64_t v16 = swift_allocObject();
  type metadata accessor for MBUnfairLock();
  uint64_t v17 = swift_allocObject();
  id v18 = v14;
  id v19 = (_DWORD *)swift_slowAlloc();
  *(void *)(v17 + 16) = v19;
  *id v19 = 0;
  *(void *)(v16 + 16) = v17;
  *(void *)(v16 + 24) = _swiftEmptyArrayStorage;
  *(void *)&v14[v15] = v16;
  uint64_t v78 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext__summary;
  type metadata accessor for MBRestoreSummarizer(0);
  uint64_t v20 = swift_allocObject();
  *(_OWORD *)(v20 + 16) = 0u;
  *(_OWORD *)(v20 + 32) = 0u;
  *(_OWORD *)(v20 + 48) = 0u;
  *(_OWORD *)(v20 + 64) = 0u;
  *(_OWORD *)(v20 + 80) = 0u;
  *(_OWORD *)(v20 + 96) = 0u;
  *(_OWORD *)(v20 + 112) = 0u;
  *(void *)(v20 + 128) = 0;
  uint64_t v21 = v20 + OBJC_IVAR____TtC7backupd19MBRestoreSummarizer__assetFetchDuration;
  static Date.now.getter();
  uint64_t v22 = type metadata accessor for _MillisecondSegmentedDuration(0);
  type metadata accessor for IndexSet();
  v81 = _swiftEmptyArrayStorage;
  sub_1000179D0(&qword_10047D3C0, (void (*)(uint64_t))&type metadata accessor for IndexSet);
  sub_100006FC8(&qword_10047D3C8);
  sub_100016CF0();
  dispatch thunk of SetAlgebra.init<A>(_:)();
  uint64_t v23 = v21 + *(int *)(v22 + 24);
  *(void *)uint64_t v23 = 0;
  *(unsigned char *)(v23 + 8) = 1;
  uint64_t v24 = v20 + OBJC_IVAR____TtC7backupd19MBRestoreSummarizer__restorablePlacementDuration;
  static Date.now.getter();
  v81 = _swiftEmptyArrayStorage;
  dispatch thunk of SetAlgebra.init<A>(_:)();
  uint64_t v25 = v24 + *(int *)(v22 + 24);
  *(void *)uint64_t v25 = 0;
  *(unsigned char *)(v25 + 8) = 1;
  sub_100006FC8(&qword_10047D3D8);
  uint64_t v26 = swift_allocObject();
  uint64_t v27 = swift_allocObject();
  uint64_t v28 = (_DWORD *)swift_slowAlloc();
  *(void *)(v27 + 16) = v28;
  *uint64_t v28 = 0;
  *(void *)(v26 + 16) = v27;
  *(void *)(v26 + 24) = v20;
  *(void *)&v18[v78] = v26;
  uint64_t v61 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath;
  *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath] = a1;
  uint64_t v62 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_metadataPath;
  *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_metadataPath] = a2;
  *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_foregroundDomainNames] = a3;
  *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_backgroundDomainNames] = a4;
  uint64_t v29 = a6;
  v69 = &v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_snapshotUUID];
  *(void *)v69 = v29;
  *((void *)v69 + 1) = a7;
  swift_retain();
  swift_retain();
  id v30 = objc_msgSend(a8, "accountIdentifier", v61, v62);
  uint64_t v31 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v33 = v32;

  uint64_t v34 = (uint64_t *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_accountUUID];
  uint64_t *v34 = v31;
  v34[1] = v33;
  id v35 = [a8 persona];
  uint64_t v71 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona;
  *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona] = v35;
  uint64_t v65 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress;
  *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress] = a13;
  *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__restoreSnapshotsDir] = a5;
  uint64_t v36 = self;
  swift_retain();
  id v73 = a13;
  sub_10002D270(a1);
  NSString v37 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  v81 = 0;
  id v38 = [v36 volumeMountPointForFile:v37 error:&v81];

  id v39 = v81;
  if (v38)
  {
    uint64_t v40 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v42 = v41;
    id v43 = v39;

    uint64_t v44 = (uint64_t *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__volumeMountPoint];
    *uint64_t v44 = v40;
    v44[1] = v42;
    unsigned __int8 v45 = [a8 isPrimaryAccount];
    v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__isRestoringPrimaryAccount] = v45;
    *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__appManager] = a9;
    uint64_t v46 = *(void *)&v18[v71];
    id v47 = objc_allocWithZone((Class)MBDomainManager);
    id v74 = a9;
    id v48 = [v47 initWithPersona:v46];
    *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager] = v48;
    *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__tracker] = a10;
    *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__device] = a11;
    *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__depot] = a12;
    id v75 = a10;
    id v77 = a11;
    id v49 = a12;
    if (MBIsInternalInstall()
      && (id v50 = [self sharedOptions],
          unsigned int v51 = [v50 useRestoreOperationLog],
          v50,
          v51))
    {
      id v52 = [*(id *)&v18[v71] restoreOperationLogPath];
      static String._unconditionallyBridgeFromObjectiveC(_:)();

      id v53 = objc_allocWithZone((Class)MBRestoreOperationLogger);
      NSString v54 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v55 = [v53 initWithPath:v54];
    }
    else
    {
      id v55 = 0;
    }
    *(void *)&v18[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__logger] = v55;

    v80.receiver = v18;
    v80.super_class = ObjectType;
    uint64_t v56 = (char *)objc_msgSendSuper2(&v80, "init");
    uint64_t v57 = *(void **)&v56[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager];
    id v18 = v56;
    id v58 = v57;
    [v58 setDelegate:v18];

    swift_release();
    swift_release();
    swift_release();
  }
  else
  {
    char v59 = v81;
    _convertNSErrorToError(_:)();

    swift_willThrow();
    swift_release();
    swift_release();
    swift_release();

    swift_release();
    swift_release();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();

    swift_release();
    swift_release();

    swift_release();
    swift_deallocPartialClassInstance();
  }
  return v18;
}

void sub_10000E000(uint64_t a1)
{
  uint64_t v3 = self;
  uint64_t v4 = (void *)_convertErrorToNSError(_:)();
  LOBYTE(v3) = [(id)v3 isCancelledError:v4];

  if ((v3 & 1) == 0)
  {
    uint64_t v5 = *(void *)(v1 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__failures);
    uint64_t v6 = *(void *)(v5 + 16);
    os_unfair_lock_lock(*(os_unfair_lock_t *)(v6 + 16));
    uint64_t v7 = (char **)(v5 + 24);
    swift_beginAccess();
    Swift::String v8 = *(char **)(v5 + 24);
    swift_errorRetain();
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    *(void *)(v5 + 24) = v8;
    if ((isUniquelyReferenced_nonNull_native & 1) == 0)
    {
      Swift::String v8 = sub_10003E0A0(0, *((void *)v8 + 2) + 1, 1, v8);
      *uint64_t v7 = v8;
    }
    unint64_t v11 = *((void *)v8 + 2);
    unint64_t v10 = *((void *)v8 + 3);
    if (v11 >= v10 >> 1)
    {
      Swift::String v8 = sub_10003E0A0((char *)(v10 > 1), v11 + 1, 1, v8);
      *uint64_t v7 = v8;
    }
    *((void *)v8 + 2) = v11 + 1;
    *(void *)&v8[8 * v11 + 32] = a1;
    swift_endAccess();
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v6 + 16));
  }
}

id sub_10000E134()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__failures);
  uint64_t v2 = *(void *)(v1 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v2 + 16));
  swift_beginAccess();
  uint64_t v3 = *(void *)(v1 + 24);
  if (*(void *)(v3 + 16))
  {
    uint64_t v4 = self;
    sub_10000E210(v3);
    Class isa = Array._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    id v6 = [v4 errorWithErrors:isa];
  }
  else
  {
    id v6 = 0;
  }
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v2 + 16));
  return v6;
}

void *sub_10000E210(uint64_t a1)
{
  int64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = _swiftEmptyArrayStorage;
  if (v1)
  {
    Swift::String v9 = _swiftEmptyArrayStorage;
    sub_1000149CC(0, v1, 0);
    uint64_t v4 = a1 + 32;
    uint64_t v2 = _swiftEmptyArrayStorage;
    do
    {
      swift_errorRetain();
      sub_100006FC8(&qword_10047D0A0);
      swift_dynamicCast();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        sub_1000149CC(0, v2[2] + 1, 1);
        uint64_t v2 = v9;
      }
      unint64_t v6 = v2[2];
      unint64_t v5 = v2[3];
      if (v6 >= v5 >> 1)
      {
        sub_1000149CC(v5 > 1, v6 + 1, 1);
        uint64_t v2 = v9;
      }
      v2[2] = v6 + 1;
      sub_100016C78(&v8, &v2[4 * v6 + 4]);
      v4 += 8;
      --v1;
    }
    while (v1);
  }
  return v2;
}

__n128 sub_10000E340@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__summary);
  uint64_t v4 = *(void *)(v3 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v4 + 16));
  swift_beginAccess();
  uint64_t v5 = *(void *)(v3 + 24);
  uint64_t v6 = *(void *)(v5 + 24);
  uint64_t v7 = *(void *)(v5 + 32);
  long long v17 = *(_OWORD *)(v5 + 64);
  long long v18 = *(_OWORD *)(v5 + 48);
  long long v15 = *(_OWORD *)(v5 + 96);
  long long v16 = *(_OWORD *)(v5 + 80);
  __n128 v14 = *(__n128 *)(v5 + 112);
  uint64_t v8 = *(void *)(v5 + 128);
  swift_beginAccess();
  sub_10001CBB4();
  uint64_t v10 = v9;
  swift_endAccess();
  swift_beginAccess();
  sub_10001CBB4();
  uint64_t v12 = v11;
  swift_endAccess();
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 16));
  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = v7;
  *(void *)(a1 + 24) = v12;
  *(_OWORD *)(a1 + 32) = v18;
  *(_OWORD *)(a1 + 48) = v17;
  *(_OWORD *)(a1 + 64) = v16;
  *(_OWORD *)(a1 + 80) = v15;
  __n128 result = v14;
  *(__n128 *)(a1 + 96) = v14;
  *(void *)(a1 + 112) = v8;
  return result;
}

uint64_t type metadata accessor for MBDryRestoreContext()
{
  return self;
}

id sub_10000E638()
{
  return sub_10000E718(34, (void *)0xD000000000000019, 0x80000001003049B0, (SEL *)&selRef_createDatabaseAt_restoreSnapshotsDir_snapshotUUID_error_);
}

id sub_10000E6A8()
{
  return sub_10000E718(33, (void *)0xD000000000000018, 0x80000001003049D0, (SEL *)&selRef_openDatabaseAt_restoreSnapshotsDir_snapshotUUID_error_);
}

id sub_10000E718(Swift::Int a1, void *a2, unint64_t a3, SEL *a4)
{
  uint64_t v8 = v4;
  _StringGuts.grow(_:)(a1);
  swift_bridgeObjectRelease();
  id v25 = a2;
  unint64_t v26 = a3;
  unint64_t v9 = *(void *)(v4 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_metadataPath);
  unint64_t v10 = sub_10002D538(0x5F65726F74736572, 0xEF62642E6E616C70, v9);
  v11._countAndFlagsBits = sub_10002D874(v10);
  String.append(_:)(v11);
  swift_bridgeObjectRelease();
  swift_release();
  v12._countAndFlagsBits = 0x20726F6620;
  v12._object = (void *)0xE500000000000000;
  String.append(_:)(v12);
  uint64_t v13 = *(void *)(v4 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_snapshotUUID);
  __n128 v14 = *(void **)(v4 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_snapshotUUID + 8);
  swift_bridgeObjectRetain();
  v15._countAndFlagsBits = v13;
  v15._object = v14;
  String.append(_:)(v15);
  swift_bridgeObjectRelease();
  sub_100045F18((uint64_t)v25, v26, 0xD000000000000016, 0x80000001003047B0);
  swift_bridgeObjectRelease();
  long long v16 = self;
  unint64_t v17 = sub_10002D538(0x5F65726F74736572, 0xEF62642E6E616C70, v9);
  sub_10002D270(v17);
  swift_release();
  NSString v18 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  sub_10002D270(*(void *)(v8 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__restoreSnapshotsDir));
  NSString v19 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  NSString v20 = String._bridgeToObjectiveC()();
  id v25 = 0;
  id v21 = objc_msgSend(v16, *a4, v18, v19, v20, &v25);

  if (v21)
  {
    id v22 = v25;
  }
  else
  {
    id v23 = v25;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
  return v21;
}

id sub_10000E990()
{
  uint64_t v1 = *(unsigned char **)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
  uint64_t v2 = *(void **)&v1[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona];
  unsigned int v3 = [v2 isDataSeparatedPersona];
  uint64_t v4 = self;
  uint64_t v5 = &selRef_foregroundDataSeparatedRestoreMode;
  if (!v3) {
    uint64_t v5 = &selRef_foregroundRestoreMode;
  }
  id v6 = [v4 *v5];
  uint64_t v7 = *(void **)&v1[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__appManager];
  id v8 = v2;
  id v20 = v7;
  id v9 = MBAllCKPlugins();
  sub_100006FC8((uint64_t *)&unk_10047D370);
  static Array._unconditionallyBridgeFromObjectiveC(_:)();

  id result = (id)MBBuildVersion();
  if (result)
  {
    Swift::String v11 = result;
    static String._unconditionallyBridgeFromObjectiveC(_:)();

    HIDWORD(v19) = [v8 shouldRestoreToSharedVolume];
    char v12 = v1[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__isRestoringPrimaryAccount];
    id v13 = objc_allocWithZone((Class)MBRestorePolicy);
    id v14 = v6;
    Swift::String v15 = v1;
    Class isa = Array._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    NSString v17 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    BYTE2(v19) = 1;
    BYTE1(v19) = v12;
    LOBYTE(v19) = BYTE4(v19);
    id v18 = objc_msgSend(v13, "initWithPersona:enginePolicyProvider:appManager:plugins:serviceRestoreMode:osBuildVersionOfBackup:shouldRestoreSystemFiles:isRestoringPrimaryAccount:shouldCreateMissingIntermediateDirectories:", v8, v15, v20, isa, v14, v17, v19);

    return v18;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_10000EB88()
{
  sub_100045F18(0xD000000000000034, 0x80000001003047D0, 0xD000000000000016, 0x80000001003047B0);
  id v2 = sub_10000E990();
  unsigned int v3 = v2;
  uint64_t v4 = *(void *)(*(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context)
                 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_foregroundDomainNames);
  uint64_t v5 = *(void *)(v4 + 16);
  if (v5)
  {
    id v6 = *(void **)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
    swift_bridgeObjectRetain();
    uint64_t v7 = v4 + 40;
    while (1)
    {
      swift_bridgeObjectRetain();
      sub_10000ECA8(v6, v3);
      if (v1) {
        break;
      }
      v7 += 16;
      swift_bridgeObjectRelease();
      if (!--v5) {
        goto LABEL_8;
      }
    }
    swift_bridgeObjectRelease();
LABEL_8:

    swift_bridgeObjectRelease();
  }
  else
  {
  }
}

void sub_10000ECA8(void *a1, void *a2)
{
  NSString v5 = String._bridgeToObjectiveC()();
  aBlock[0] = 0;
  unsigned int v6 = [a1 ingestFileListForDomainNamed:v5 error:aBlock];

  if (v6)
  {
    uint64_t v7 = *(void **)(v2 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager);
    id v8 = aBlock[0];
    NSString v9 = String._bridgeToObjectiveC()();
    id v10 = [v7 domainForName:v9];

    if (v10)
    {
      aBlock[0] = 0;
      id v11 = [a1 planForDomain:v10 restoreType:2 error:aBlock];
      id v12 = aBlock[0];
      if (v11)
      {
        id v13 = v11;
        uint64_t v14 = swift_allocObject();
        *(void *)(v14 + 16) = a2;
        Swift::String v15 = (void *)swift_allocObject();
        v15[2] = sub_100012EC4;
        v15[3] = v14;
        aBlock[4] = sub_100012EE8;
        aBlock[5] = v15;
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = (id)1107296256;
        aBlock[2] = sub_100010C14;
        aBlock[3] = &unk_10040F7C8;
        long long v16 = _Block_copy(aBlock);
        id v17 = v12;
        id v18 = a2;
        swift_retain();
        swift_release();
        aBlock[0] = 0;
        unsigned __int8 v19 = [v13 enumerateAndMarkATCRestorables:aBlock enumerator:v16];
        _Block_release(v16);
        id v20 = aBlock[0];
        LOBYTE(v16) = swift_isEscapingClosureAtFileLocation();
        swift_release();
        if (v16) {
          __break(1u);
        }
        if ((v19 & 1) == 0)
        {
          _convertNSErrorToError(_:)();

          swift_willThrow();
        }
        swift_release();
        swift_unknownObjectRelease();
      }
      else
      {
        id v22 = aBlock[0];
        _convertNSErrorToError(_:)();

        swift_willThrow();
      }
    }
    else
    {
      __break(1u);
    }
  }
  else
  {
    id v21 = aBlock[0];
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
}

uint64_t sub_10000EF94()
{
  sub_100045F18(0xD00000000000001CLL, 0x8000000100304830, 0xD000000000000016, 0x80000001003047B0);
  uint64_t v1 = *(void *)(*(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context)
                 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_backgroundDomainNames);
  uint64_t v4 = *(void *)(v1 + 56);
  uint64_t v3 = v1 + 56;
  uint64_t v2 = v4;
  uint64_t v5 = 1 << *(unsigned char *)(*(void *)(*(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context)
                                   + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_backgroundDomainNames)
                       + 32);
  uint64_t v6 = -1;
  if (v5 < 64) {
    uint64_t v6 = ~(-1 << v5);
  }
  uint64_t v7 = v6 & v2;
  uint64_t v8 = OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB;
  int64_t v18 = (unint64_t)(v5 + 63) >> 6;
  swift_bridgeObjectRetain();
  int64_t v9 = 0;
  if (!v7) {
    goto LABEL_5;
  }
LABEL_4:
  for (v7 &= v7 - 1; ; uint64_t v7 = (v11 - 1) & v11)
  {
    id v13 = *(void **)(v0 + v8);
    swift_bridgeObjectRetain();
    NSString v14 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v19 = 0;
    LODWORD(v13) = [v13 ingestFileListForDomainNamed:v14 error:&v19];

    if (!v13)
    {
      id v16 = v19;
      _convertNSErrorToError(_:)();

      swift_willThrow();
      return swift_release();
    }
    id v15 = v19;
    if (v7) {
      goto LABEL_4;
    }
LABEL_5:
    int64_t v10 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_25;
    }
    if (v10 >= v18) {
      return swift_release();
    }
    uint64_t v11 = *(void *)(v3 + 8 * v10);
    ++v9;
    if (!v11)
    {
      int64_t v9 = v10 + 1;
      if (v10 + 1 >= v18) {
        return swift_release();
      }
      uint64_t v11 = *(void *)(v3 + 8 * v9);
      if (!v11)
      {
        int64_t v9 = v10 + 2;
        if (v10 + 2 >= v18) {
          return swift_release();
        }
        uint64_t v11 = *(void *)(v3 + 8 * v9);
        if (!v11) {
          break;
        }
      }
    }
LABEL_18:
    ;
  }
  int64_t v12 = v10 + 3;
  if (v12 < v18)
  {
    uint64_t v11 = *(void *)(v3 + 8 * v12);
    if (!v11)
    {
      while (1)
      {
        int64_t v9 = v12 + 1;
        if (__OFADD__(v12, 1)) {
          break;
        }
        if (v9 >= v18) {
          return swift_release();
        }
        uint64_t v11 = *(void *)(v3 + 8 * v9);
        ++v12;
        if (v11) {
          goto LABEL_18;
        }
      }
LABEL_25:
      __break(1u);
    }
    int64_t v9 = v12;
    goto LABEL_18;
  }
  return swift_release();
}

void sub_10000F214()
{
  unint64_t v29 = (unint64_t)"Ingesting Background domains";
  sub_100045F18(0xD00000000000001CLL, 0x8000000100304850, 0xD000000000000016, 0x80000001003047B0);
  id v1 = sub_10000E990();
  uint64_t v2 = *(char **)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
  unint64_t v3 = *(void *)&v2[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__restoreSnapshotsDir];
  id v4 = v1;
  sub_10002D270(v3);
  id v5 = objc_allocWithZone((Class)MBRestoreSnapshotIntegrityVerifier);
  swift_bridgeObjectRetain();
  uint64_t v6 = v2;
  NSString v7 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  NSString v8 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v31 = [v5 initWithPolicy:v4 snapshotFormat:2 snapshotDir:v7 snapshotUUID:v8 delegate:v6];

  int64_t v9 = *(void **)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
  id v10 = *(id *)&v6[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress];
  uint64_t v11 = swift_bridgeObjectRetain();
  sub_100015914(v11);
  swift_bridgeObjectRelease();
  Class isa = Set._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  id v32 = 0;
  LODWORD(v5) = [v9 addRemainingProgress:v10 forDomainNames:isa error:&v32];

  id v14 = v32;
  if (v5)
  {
    v28[1] = v28;
    __chkstk_darwin(v13);
    v27[2] = v0;
    id v15 = v6;
    id v16 = v14;
    id v17 = v31;
    v28[0] = v31;
    uint64_t v18 = swift_bridgeObjectRetain();
    uint64_t v19 = v30;
    sub_100016854(v18, (uint64_t)v15);
    unint64_t v21 = v20;

    __chkstk_darwin(v22);
    v26[2] = sub_1000159AC;
    v26[3] = v27;
    v26[4] = v9;
    v26[5] = v15;
    v26[6] = v4;
    v26[7] = v17;
    sub_100010C6C((void (*)(uint64_t *__return_ptr, id *, uint64_t *))sub_1000159E0, (uint64_t)v26, v21);
    if (v19)
    {

      id v23 = v28[0];
      swift_bridgeObjectRelease();
    }
    else
    {
      id v25 = v28[0];

      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      sub_1000185E0(0xD00000000000001CLL, (void *)(v29 | 0x8000000000000000));
    }
    swift_bridgeObjectRelease();
  }
  else
  {
    id v24 = v32;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
}

void sub_10000F5B0()
{
  sub_100045F18(0xD00000000000001CLL, 0x8000000100304870, 0xD000000000000016, 0x80000001003047B0);
  id v1 = *(void **)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
  uint64_t v2 = *(char **)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
  id v3 = *(id *)&v2[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress];
  swift_bridgeObjectRetain();
  Class isa = Set._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  id v15 = 0;
  unsigned int v5 = [v1 addRemainingProgress:v3 forDomainNames:isa error:&v15];

  id v7 = v15;
  if (v5)
  {
    v14[0] = v14;
    __chkstk_darwin(v6);
    NSString v8 = v2;
    id v9 = v1;
    id v10 = v7;
    uint64_t v11 = swift_bridgeObjectRetain();
    uint64_t v12 = v14[1];
    sub_100015B38(v11, v8, v9, 1, (uint64_t (*)(void *))sub_100016A80);
    swift_bridgeObjectRelease();

    if (!v12)
    {
      sub_1000185E0(0xD00000000000001CLL, (void *)0x8000000100304870);
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    id v13 = v15;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
}

void sub_10000F7D8(void *a1, char *a2, void *a3)
{
}

void sub_10000F878(void *a1, char *a2, void *a3)
{
}

void sub_10000F918(void *a1, char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, void (*a9)(unint64_t, char *, id, id, char *))
{
  id aBlock[6] = _swiftEmptyArrayStorage;
  unint64_t v9 = *(void *)&a2[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_foregroundDomainNames];
  id v77 = *(char **)(v9 + 16);
  if (v77)
  {
    id v78 = *(id *)&a2[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager];
    id v70 = a3;
    swift_bridgeObjectRetain();
    id v10 = 0;
    unint64_t v76 = v9;
    while (1)
    {
      if ((unint64_t)v10 >= *(void *)(v9 + 16))
      {
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        __break(1u);
LABEL_48:
        swift_bridgeObjectRetain();
        uint64_t v47 = _CocoaArrayWrapper.endIndex.getter();
        swift_bridgeObjectRelease();
        goto LABEL_29;
      }
      swift_bridgeObjectRetain();
      NSString v11 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v12 = [v78 domainForName:v11];

      if (!v12) {
        goto LABEL_50;
      }
      aBlock[0] = 0;
      id v13 = [a1 planForDomain:v12 restoreType:2 error:aBlock];
      id v14 = aBlock[0];
      if (!v13)
      {
        id v37 = aBlock[0];
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        _convertNSErrorToError(_:)();

        swift_willThrow();
        goto LABEL_44;
      }
      id v15 = v13;
      aBlock[0] = 0;
      id v16 = v14;
      id v17 = objc_msgSend(v15, "atcFileInfosMatchingRelativePath:pendingOnly:range:error:", 0, 1, 0, 0x7FFFFFFFFFFFFFFFLL, aBlock);
      id v18 = aBlock[0];
      if (!v17)
      {
        id v38 = aBlock[0];
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        _convertNSErrorToError(_:)();

        swift_willThrow();
        swift_unknownObjectRelease();
        goto LABEL_44;
      }
      uint64_t v19 = v17;
      v81 = v10;
      sub_100016B2C();
      unint64_t v20 = static Array._unconditionallyBridgeFromObjectiveC(_:)();
      id v21 = v18;

      if (v20 >> 62)
      {
        swift_bridgeObjectRetain();
        uint64_t v22 = _CocoaArrayWrapper.endIndex.getter();
        swift_bridgeObjectRelease();
        if (!v22)
        {
LABEL_20:
          swift_bridgeObjectRelease();
          id v24 = _swiftEmptyArrayStorage;
          goto LABEL_3;
        }
      }
      else
      {
        uint64_t v22 = *(void *)((v20 & 0xFFFFFFFFFFFFFF8) + 0x10);
        if (!v22) {
          goto LABEL_20;
        }
      }
      aBlock[0] = _swiftEmptyArrayStorage;
      sub_1000149EC(0, v22 & ~(v22 >> 63), 0);
      if (v22 < 0) {
        goto LABEL_46;
      }
      id v80 = v12;
      uint64_t v23 = 0;
      id v24 = aBlock[0];
      unint64_t v82 = v20 & 0xC000000000000001;
      unint64_t v25 = v20;
      uint64_t v26 = v22;
      do
      {
        if (v82) {
          id v27 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
        }
        else {
          id v27 = *(id *)(v20 + 8 * v23 + 32);
        }
        uint64_t v28 = v27;
        id v29 = objc_msgSend(v27, "path", v70);
        uint64_t v30 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v32 = v31;

        aBlock[0] = v24;
        unint64_t v34 = v24[2];
        unint64_t v33 = v24[3];
        if (v34 >= v33 >> 1)
        {
          sub_1000149EC(v33 > 1, v34 + 1, 1);
          id v24 = aBlock[0];
        }
        ++v23;
        v24[2] = v34 + 1;
        id v35 = &v24[2 * v34];
        v35[4] = v30;
        v35[5] = v32;
        unint64_t v20 = v25;
      }
      while (v26 != v23);
      swift_bridgeObjectRelease();
      id v12 = v80;
LABEL_3:
      id v10 = v81 + 1;
      sub_100011814((uint64_t)v24);
      swift_unknownObjectRelease();

      unint64_t v9 = v76;
      if (v81 + 1 == v77)
      {
        swift_bridgeObjectRelease();
        goto LABEL_25;
      }
    }
  }
  id v36 = a3;
LABEL_25:
  sub_100014E94();
  id v39 = self;
  swift_bridgeObjectRetain();
  Class isa = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  id v80 = [v39 backgroundFilesRestoreModeWithPaths:isa];

  swift_bridgeObjectRetain();
  Class v41 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  uint64_t v42 = swift_allocObject();
  unint64_t v9 = (unint64_t)a2;
  *(void *)(v42 + 16) = a2;
  id v43 = (void *)swift_allocObject();
  v43[2] = a6;
  v43[3] = v42;
  aBlock[4] = a7;
  aBlock[5] = v43;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = (id)1107296256;
  aBlock[2] = sub_100011EF8;
  aBlock[3] = a8;
  uint64_t v44 = _Block_copy(aBlock);
  v81 = a2;
  swift_retain();
  swift_release();
  aBlock[0] = 0;
  id v45 = [a1 atcRestorePlansForAbsolutePaths:v41 domainProvider:v44 error:aBlock];
  _Block_release(v44);

  id v46 = aBlock[0];
  LOBYTE(v44) = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (v44) {
    goto LABEL_47;
  }
  if (v45)
  {
    sub_100006FC8(&qword_10047D390);
    unint64_t v9 = static Array._unconditionallyBridgeFromObjectiveC(_:)();

    if (v9 >> 62) {
      goto LABEL_48;
    }
    uint64_t v47 = *(void *)((v9 & 0xFFFFFFFFFFFFFF8) + 0x10);
LABEL_29:
    id v48 = v81;
    id v49 = _swiftEmptyArrayStorage;
    if (v47)
    {
      aBlock[0] = _swiftEmptyArrayStorage;
      sub_1000149EC(0, v47 & ~(v47 >> 63), 0);
      if (v47 < 0)
      {
        __break(1u);
LABEL_50:

        __break(1u);
      }
      uint64_t v50 = 0;
      id v49 = aBlock[0];
      unint64_t v83 = v9 & 0xC000000000000001;
      unint64_t v51 = v9;
      do
      {
        if (v83)
        {
          id v52 = (void *)specialized _ArrayBuffer._getElementSlowPath(_:)();
        }
        else
        {
          id v52 = *(void **)(v9 + 8 * v50 + 32);
          swift_unknownObjectRetain();
        }
        id v53 = objc_msgSend(v52, "domain", v70);
        id v54 = [v53 name];

        uint64_t v55 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v57 = v56;
        swift_unknownObjectRelease();

        aBlock[0] = v49;
        unint64_t v59 = v49[2];
        unint64_t v58 = v49[3];
        if (v59 >= v58 >> 1)
        {
          sub_1000149EC(v58 > 1, v59 + 1, 1);
          id v49 = aBlock[0];
        }
        ++v50;
        v49[2] = v59 + 1;
        v60 = &v49[2 * v59];
        v60[4] = v55;
        v60[5] = v57;
        unint64_t v9 = v51;
      }
      while (v47 != v50);
      id v48 = v81;
    }
    uint64_t v61 = *(void *)&v48[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress];
    sub_100015914((uint64_t)v49);
    swift_bridgeObjectRelease();
    Class v62 = Set._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    aBlock[0] = 0;
    unsigned __int8 v63 = [a1 addRemainingProgress:v61 forDomainNames:v62 error:aBlock];

    id v64 = aBlock[0];
    if (v63)
    {
      id v65 = a3;
      v66 = v48;
      id v67 = v80;
      id v68 = v64;
      a9(v9, v66, v67, v65, v84);

      swift_release();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return;
    }
    id v69 = aBlock[0];
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    _convertNSErrorToError(_:)();
  }
  else
  {
    swift_bridgeObjectRelease();
    _convertNSErrorToError(_:)();
  }
  swift_willThrow();

  swift_release();
  id v12 = v80;
LABEL_44:
}

void sub_1000101C4()
{
  id v1 = v0;
  sub_100045F18(0xD00000000000003ELL, 0x8000000100304930, 0xD000000000000016, 0x80000001003047B0);
  id v2 = sub_10000E990();
  id v3 = *(char **)&v0[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context];
  unint64_t v4 = *(void *)&v3[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__restoreSnapshotsDir];
  id v5 = v2;
  sub_10002D270(v4);
  id v6 = objc_allocWithZone((Class)MBRestoreSnapshotIntegrityVerifier);
  swift_bridgeObjectRetain();
  id v7 = v3;
  NSString v8 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  NSString v9 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v10 = [v6 initWithPolicy:v5 snapshotFormat:2 snapshotDir:v8 snapshotUUID:v9 delegate:v7];

  NSString v11 = *(void **)&v1[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB];
  uint64_t v12 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_foregroundDomainNames;
  id v43 = v1;
  id v13 = v7;
  id v33 = v10;
  uint64_t v14 = swift_bridgeObjectRetain();
  sub_100016854(v14, (uint64_t)v13);
  unint64_t v16 = v15;

  id v36 = sub_100017A1C;
  id v37 = &v42;
  id v38 = v11;
  id v39 = v13;
  id v40 = v5;
  id v41 = v10;
  sub_100010C6C((void (*)(uint64_t *__return_ptr, id *, uint64_t *))sub_1000159E0, (uint64_t)v35, v16);
  if (v34)
  {

    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v32 = v11;

    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    BOOL v17 = sub_1000185E0(0xD00000000000001CLL, (void *)0x8000000100304850);
    swift_bridgeObjectRelease();
    if (v17)
    {
      uint64_t v18 = *(void *)&v7[v12];
      unint64_t v19 = *(void *)&v13[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath];
      swift_retain();
      swift_bridgeObjectRetain();
      unint64_t v20 = sub_10002D538(0x756F726765726F46, 0xEA0000000000646ELL, v19);
      swift_release();
      id v21 = sub_1000107B0(v11, v33, v18, v20);
      uint64_t v23 = v22;
      swift_bridgeObjectRelease();
      swift_release();
      BOOL v24 = sub_1000185E0((uint64_t)v21, v23);
      swift_bridgeObjectRelease();
      uint64_t v25 = swift_bridgeObjectRelease();
      if (v24)
      {
        __chkstk_darwin(v25);
        uint64_t v26 = v13;
        id v27 = v32;
        uint64_t v28 = swift_bridgeObjectRetain();
        sub_100015B38(v28, v26, v27, 1, (uint64_t (*)(void *))sub_100017A20);
        swift_bridgeObjectRelease();

        BOOL v29 = sub_1000185E0(0xD00000000000001CLL, (void *)0x8000000100304870);
        swift_bridgeObjectRelease();
        if (v29)
        {
          sub_10000F918(v27, v26, v1, (uint64_t)&unk_10040F8F0, (uint64_t)&unk_10040F918, (uint64_t)sub_100017A18, sub_100017A68, &unk_10040F930, (void (*)(unint64_t, char *, id, id, char *))sub_100015CE0);
          sub_1000185E0(v30, v31);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
        }
      }
    }
  }
}

id sub_1000106D8(void *a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(*(void *)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context)
                 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath);
  swift_retain();
  unint64_t v4 = sub_10002D538(0x756F726765726F46, 0xEA0000000000646ELL, v3);
  swift_release();
  id result = [a1 rootPath];
  if (result)
  {
    id v6 = result;
    uint64_t v7 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v9 = v8;

    unint64_t v10 = sub_10002D538(v7, v9, v4);
    swift_bridgeObjectRelease();
    swift_release();
    return (id)v10;
  }
  else
  {
    __break(1u);
  }
  return result;
}

id sub_1000107B0(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  id v6 = *(id *)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona];
  id v35 = objc_msgSend(self, "restoreDirectoryAnnotatorWithPersona:engineType:backupPolicy:shouldRestoreSystemFiles:encrypted:", v6, 3, 0, objc_msgSend(v6, "shouldRestoreToSharedVolume"), 1);

  uint64_t v7 = v4;
  sub_100016854(a3, (uint64_t)v7);
  unint64_t v9 = v8;
  uint64_t v31 = v7;

  if (!(v9 >> 62))
  {
    uint64_t v10 = *(void *)((v9 & 0xFFFFFFFFFFFFFF8) + 0x10);
    if (v10) {
      goto LABEL_3;
    }
LABEL_11:
    swift_bridgeObjectRelease();
    sub_100006FC8((uint64_t *)&unk_10047D3A0);
    uint64_t v23 = swift_allocObject();
    *(_OWORD *)(v23 + 16) = xmmword_1003B1EE0;
    BOOL v24 = (void *)swift_allocObject();
    v24[2] = a2;
    v24[3] = v31;
    v24[4] = a1;
    v24[5] = a4;
    aBlock[4] = sub_100016C64;
    aBlock[5] = v24;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1107296256;
    aBlock[2] = sub_100010F1C;
    aBlock[3] = &unk_10040F9A8;
    uint64_t v25 = _Block_copy(aBlock);
    uint64_t v26 = self;
    swift_retain();
    id v27 = v31;
    id v28 = a2;
    id v29 = a1;
    id v30 = [v26 blockOperationWithBlock:v25];
    _Block_release(v25);
    swift_release();
    *(void *)(v23 + 32) = v30;
    aBlock[0] = v23;
    specialized Array._endMutation()();

    return (id)0xD000000000000028;
  }
LABEL_14:
  uint64_t v10 = _CocoaArrayWrapper.endIndex.getter();
  if (!v10) {
    goto LABEL_11;
  }
LABEL_3:
  uint64_t v11 = 4;
  while (1)
  {
    if ((v9 & 0xC000000000000001) != 0) {
      id v12 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
    }
    else {
      id v12 = *(id *)(v9 + 8 * v11);
    }
    id v13 = v12;
    uint64_t v14 = v11 - 3;
    if (__OFADD__(v11 - 4, 1))
    {
      __break(1u);
      goto LABEL_14;
    }
    id result = [v12 rootPath];
    if (!result) {
      break;
    }
    unint64_t v16 = result;
    uint64_t v17 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v19 = v18;

    unint64_t v20 = sub_10002D538(v17, v19, a4);
    swift_bridgeObjectRelease();
    sub_10002D270(v20);
    NSString v21 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v22 = [v35 annotateDomain:v13 atDomainRoot:v21];

    if (v22)
    {
      swift_bridgeObjectRelease();
      swift_willThrow();

      return (id)swift_release();
    }

    swift_release();
    ++v11;
    if (v14 == v10) {
      goto LABEL_11;
    }
  }
  __break(1u);
  return result;
}

unint64_t sub_100010B1C(void *a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(*(void *)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context)
                 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath);
  swift_retain();
  unint64_t v4 = sub_10002D538(0x756F72676B636142, 0xEA0000000000646ELL, v3);
  swift_release();
  id v5 = [a1 name];
  uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v8 = v7;

  unint64_t v9 = sub_10002D538(v6, v8, v4);
  swift_bridgeObjectRelease();
  swift_release();
  return v9;
}

uint64_t sub_100010BEC(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  return a3();
}

uint64_t sub_100010C14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 32);
  swift_unknownObjectRetain();
  uint64_t v6 = v5(a2, a3);
  swift_unknownObjectRelease();
  return v6;
}

void *sub_100010C6C(void (*a1)(uint64_t *__return_ptr, id *, uint64_t *), uint64_t a2, unint64_t a3)
{
  if (a3 >> 62) {
    goto LABEL_16;
  }
  uint64_t v6 = *(void *)((a3 & 0xFFFFFFFFFFFFFF8) + 0x10);
  while (1)
  {
    id result = _swiftEmptyArrayStorage;
    if (!v6) {
      break;
    }
    uint64_t v14 = _swiftEmptyArrayStorage;
    id result = (void *)specialized ContiguousArray.reserveCapacity(_:)();
    if (v6 < 0)
    {
      __break(1u);
      return result;
    }
    uint64_t v8 = 0;
    while (v6 != v8)
    {
      if ((a3 & 0xC000000000000001) != 0) {
        id v9 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
      }
      else {
        id v9 = *(id *)(a3 + 8 * v8 + 32);
      }
      uint64_t v10 = v9;
      id v12 = v9;
      a1(&v13, &v12, &v11);

      if (v3) {
        return (void *)swift_release();
      }
      ++v8;
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
      specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
      specialized ContiguousArray._endMutation()();
      if (v6 == v8) {
        return v14;
      }
    }
    __break(1u);
LABEL_16:
    swift_bridgeObjectRetain();
    uint64_t v6 = _CocoaArrayWrapper.endIndex.getter();
    swift_bridgeObjectRelease();
  }
  return result;
}

id sub_100010DE0(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager);
  sub_10002D270(a4);
  NSString v7 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v12 = 0;
  LODWORD(a3) = [a1 verifyIntermediateDirectoryAfterForegroundRestoreWithDomainManager:v6 plan:a3 overridePath:v7 error:&v12];

  id v8 = v12;
  if (a3)
  {
    return v8;
  }
  else
  {
    id v10 = v12;
    uint64_t v11 = _convertNSErrorToError(_:)();

    swift_willThrow();
    sub_10000E000(v11);
    return (id)swift_errorRelease();
  }
}

uint64_t sub_100010F1C(uint64_t a1)
{
  id v1 = *(void (**)(uint64_t))(a1 + 32);
  uint64_t v2 = swift_retain();
  v1(v2);
  return swift_release();
}

uint64_t sub_100010F60@<X0>(void *a1@<X0>, uint64_t (*a2)(void)@<X1>, void *a3@<X3>, void *a4@<X4>, void *a5@<X5>, void *a6@<X6>, uint64_t *a7@<X7>, void *a8@<X8>)
{
  uint64_t v13 = (void *)*a1;
  uint64_t v14 = a2(*a1);
  id v29 = 0;
  id v15 = [a3 planForDomain:v13 restoreType:1 error:&v29];
  id v16 = v29;
  if (v15)
  {
    id v17 = v15;
    uint64_t v18 = (void *)swift_allocObject();
    v18[2] = a4;
    long long v18[3] = v14;
    v18[4] = a5;
    v18[5] = v17;
    v18[6] = a6;
    objc_allocWithZone((Class)type metadata accessor for _DryRestoreDomainOperation());
    id v19 = a6;
    id v20 = a4;
    id v21 = v16;
    id v22 = v13;
    swift_retain();
    id v23 = a5;
    id v24 = sub_100015A14(v20, v14, v22, (uint64_t)sub_1000159FC, (uint64_t)v18);

    swift_release();
    uint64_t result = swift_release();
    *a8 = v24;
  }
  else
  {
    id v26 = v29;
    uint64_t v27 = _convertNSErrorToError(_:)();

    swift_willThrow();
    uint64_t result = swift_release();
    *a7 = v27;
  }
  return result;
}

id sub_100011128(void *a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, void *a6)
{
  return sub_1000116E4(a1, a2, a3, a4, a5, a6);
}

void sub_100011140(unsigned char *a1@<X1>, void *a2@<X2>, char a3@<W3>, uint64_t (*a4)(void *)@<X4>, uint64_t *a5@<X6>, void *a6@<X8>)
{
  id v9 = self;
  NSString v10 = String._bridgeToObjectiveC()();
  id v11 = [v9 containerIDWithName:v10];

  id v12 = *(void **)&a1[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__appManager];
  id v13 = [v12 containerWithIdentifier:v11];

  if (!v13)
  {
    id v16 = *(void **)&a1[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager];
    NSString v17 = String._bridgeToObjectiveC()();
    id v15 = [v16 domainForName:v17];

    if (v15) {
      goto LABEL_5;
    }
LABEL_15:
    __break(1u);
    return;
  }
  id v14 = [v13 domain];
  if (!v14)
  {
    __break(1u);
    goto LABEL_15;
  }
  id v15 = v14;

LABEL_5:
  id v54 = v15;
  id v49 = a4;
  uint64_t v50 = a6;
  id v18 = sub_100011638(v15);
  id v19 = *(id *)&a1[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona];
  id v55 = v12;
  id v20 = MBAllCKPlugins();
  sub_100006FC8((uint64_t *)&unk_10047D370);
  static Array._unconditionallyBridgeFromObjectiveC(_:)();

  id v21 = (id)MBBuildVersion();
  if (!v21) {
    __break(1u);
  }
  id v22 = v21;
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  unsigned __int8 v52 = [v19 shouldRestoreToSharedVolume];
  char v23 = a1[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__isRestoringPrimaryAccount];
  id v24 = objc_allocWithZone((Class)MBRestorePolicy);
  id v25 = v18;
  id v26 = a1;
  Class isa = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  NSString v28 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  BYTE2(v47) = 1;
  BYTE1(v47) = v23;
  LOBYTE(v47) = v52;
  id v29 = objc_msgSend(v24, "initWithPersona:enginePolicyProvider:appManager:plugins:serviceRestoreMode:osBuildVersionOfBackup:shouldRestoreSystemFiles:isRestoringPrimaryAccount:shouldCreateMissingIntermediateDirectories:", v19, v26, v55, isa, v25, v28, v47);

  id v58 = 0;
  id v30 = [a2 planForDomain:v54 restoreType:2 error:&v58];
  if (v30)
  {
    id v31 = v30;
    if (a3)
    {
      id v57 = v29;
      unint64_t v32 = *(void *)&v26[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__restoreSnapshotsDir];
      id v33 = v58;
      id v53 = v57;
      sub_10002D270(v32);
      id v34 = objc_allocWithZone((Class)MBRestoreSnapshotIntegrityVerifier);
      id v35 = v26;
      swift_bridgeObjectRetain();
      NSString v36 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      NSString v37 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v38 = [v34 initWithPolicy:v53 snapshotFormat:2 snapshotDir:v36 snapshotUUID:v37 delegate:v35];

      id v29 = v57;
    }
    else
    {
      id v41 = v58;
      id v38 = 0;
    }
    uint64_t v42 = v49(v54);
    id v43 = (void *)swift_allocObject();
    v43[2] = v26;
    v43[3] = v42;
    v43[4] = v29;
    v43[5] = v31;
    v43[6] = v38;
    id v44 = objc_allocWithZone((Class)type metadata accessor for _DryRestoreDomainOperation());
    swift_retain();
    id v45 = v26;
    id v46 = sub_100015A14(v45, v42, v54, (uint64_t)sub_1000159FC, (uint64_t)v43);

    swift_release();
    swift_release();
    *uint64_t v50 = v46;
  }
  else
  {
    id v39 = v58;
    uint64_t v40 = _convertNSErrorToError(_:)();

    swift_willThrow();
    *a5 = v40;
  }
}

id sub_100011638(void *a1)
{
  unsigned int v3 = [*(id *)(v1 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona) isDataSeparatedPersona];
  id result = [a1 containerID];
  id v5 = result;
  if (v3)
  {
    if (result)
    {
      uint64_t v6 = &selRef_backgroundDataSeparatedAppRestoreModeWithBundleID_;
LABEL_6:
      id v7 = objc_msgSend(self, *v6, result);

      return v7;
    }
    __break(1u);
  }
  else if (result)
  {
    uint64_t v6 = &selRef_backgroundAppRestoreModeWithBundleID_;
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

id sub_1000116E4(void *a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, void *a6)
{
  uint64_t v11 = sub_10002D270(a3);
  uint64_t v23 = v12;
  uint64_t v24 = v11;
  id v13 = *(void **)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__depot);
  id v14 = *(void **)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress);
  id v15 = *(void **)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__logger);
  objc_allocWithZone((Class)MBRestoreDomainEngine);
  id v25 = v15;
  id v16 = a4;
  id v17 = v13;
  id v18 = a1;
  swift_unknownObjectRetain();
  id v19 = v14;
  id v20 = a6;
  id v21 = sub_100016964(v24, v23, (uint64_t)v16, (uint64_t)v17, (uint64_t)v18, a5, (uint64_t)v14, (uint64_t)a6, (uint64_t)v15);

  swift_unknownObjectRelease();
  return v21;
}

uint64_t sub_100011814(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = *(void **)v1;
  int64_t v4 = *(void *)(*(void *)v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  char isUniquelyReferenced_nonNull_native = (void *)swift_isUniquelyReferenced_nonNull_native();
  if (isUniquelyReferenced_nonNull_native && v5 <= v3[3] >> 1)
  {
    if (*(void *)(a1 + 16)) {
      goto LABEL_5;
    }
    goto LABEL_18;
  }
  if (v4 <= v5) {
    int64_t v14 = v4 + v2;
  }
  else {
    int64_t v14 = v4;
  }
  unsigned int v3 = sub_10003E1B0(isUniquelyReferenced_nonNull_native, v14, 1, v3);
  if (!*(void *)(a1 + 16))
  {
LABEL_18:
    if (!v2) {
      goto LABEL_19;
    }
    goto LABEL_21;
  }
LABEL_5:
  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  unint64_t v9 = (unint64_t)&v3[2 * v8 + 4];
  if (a1 + 32 < v9 + 16 * v2 && v9 < a1 + 32 + 16 * v2) {
    goto LABEL_24;
  }
  swift_arrayInitWithCopy();
  if (!v2)
  {
LABEL_19:
    uint64_t result = swift_bridgeObjectRelease();
    *(void *)uint64_t v1 = v3;
    return result;
  }
  uint64_t v11 = v3[2];
  BOOL v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }
LABEL_23:
  __break(1u);
LABEL_24:
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_100011968(uint64_t result)
{
  uint64_t v3 = *(void *)(result + 16);
  int64_t v4 = *(void **)v1;
  int64_t v5 = *(void *)(*(void *)v1 + 16);
  int64_t v6 = v5 + v3;
  if (__OFADD__(v5, v3))
  {
    __break(1u);
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v7 = result;
  char isUniquelyReferenced_nonNull_native = (void *)swift_isUniquelyReferenced_nonNull_native();
  if (!isUniquelyReferenced_nonNull_native || (int64_t v9 = v4[3] >> 1, v9 < v6))
  {
    if (v5 <= v6) {
      int64_t v10 = v5 + v3;
    }
    else {
      int64_t v10 = v5;
    }
    int64_t v4 = sub_10003E1B0(isUniquelyReferenced_nonNull_native, v10, 1, v4);
    int64_t v9 = v4[3] >> 1;
  }
  uint64_t v11 = v4[2];
  uint64_t v12 = v9 - v11;
  uint64_t result = sub_100015314((uint64_t)v38, &v4[2 * v11 + 4], v9 - v11, v7);
  if (result < v3) {
    goto LABEL_15;
  }
  if (result)
  {
    uint64_t v14 = v4[2];
    BOOL v15 = __OFADD__(v14, result);
    uint64_t v16 = v14 + result;
    if (v15)
    {
      __break(1u);
      goto LABEL_48;
    }
    v4[2] = v16;
  }
  if (result != v12)
  {
LABEL_13:
    uint64_t result = sub_100016C70();
    *(void *)uint64_t v1 = v4;
    return result;
  }
LABEL_16:
  int64_t v2 = v4[2];
  uint64_t v3 = v38[0];
  uint64_t v37 = v38[1];
  uint64_t v13 = v39;
  int64_t v6 = v40;
  if (v41)
  {
    unint64_t v17 = (v41 - 1) & v41;
    unint64_t v18 = __clz(__rbit64(v41)) | (v40 << 6);
    int64_t v36 = (unint64_t)(v39 + 64) >> 6;
    goto LABEL_18;
  }
LABEL_48:
  int64_t v32 = v6 + 1;
  if (__OFADD__(v6, 1)) {
    goto LABEL_66;
  }
  int64_t v36 = (unint64_t)(v13 + 64) >> 6;
  if (v32 >= v36) {
    goto LABEL_13;
  }
  unint64_t v33 = *(void *)(v37 + 8 * v32);
  int64_t v34 = v6 + 1;
  if (!v33)
  {
    int64_t v34 = v6 + 2;
    if (v6 + 2 >= v36) {
      goto LABEL_13;
    }
    unint64_t v33 = *(void *)(v37 + 8 * v34);
    if (!v33)
    {
      int64_t v34 = v6 + 3;
      if (v6 + 3 >= v36) {
        goto LABEL_13;
      }
      unint64_t v33 = *(void *)(v37 + 8 * v34);
      if (!v33)
      {
        int64_t v34 = v6 + 4;
        if (v6 + 4 >= v36) {
          goto LABEL_13;
        }
        unint64_t v33 = *(void *)(v37 + 8 * v34);
        if (!v33)
        {
          int64_t v34 = v6 + 5;
          if (v6 + 5 >= v36) {
            goto LABEL_13;
          }
          unint64_t v33 = *(void *)(v37 + 8 * v34);
          if (!v33)
          {
            int64_t v35 = v6 + 6;
            do
            {
              if (v36 == v35) {
                goto LABEL_13;
              }
              unint64_t v33 = *(void *)(v37 + 8 * v35++);
            }
            while (!v33);
            int64_t v34 = v35 - 1;
          }
        }
      }
    }
  }
  unint64_t v17 = (v33 - 1) & v33;
  unint64_t v18 = __clz(__rbit64(v33)) + (v34 << 6);
  int64_t v6 = v34;
LABEL_18:
  id v19 = (uint64_t *)(*(void *)(v3 + 48) + 16 * v18);
  uint64_t v21 = *v19;
  uint64_t v20 = v19[1];
  uint64_t result = swift_bridgeObjectRetain();
  while (1)
  {
    unint64_t v22 = v4[3];
    int64_t v23 = v22 >> 1;
    if ((uint64_t)(v22 >> 1) < v2 + 1) {
      break;
    }
    if (v2 < v23) {
      goto LABEL_23;
    }
LABEL_20:
    v4[2] = v2;
  }
  uint64_t result = (uint64_t)sub_10003E1B0((void *)(v22 > 1), v2 + 1, 1, v4);
  int64_t v4 = (void *)result;
  int64_t v23 = *(void *)(result + 24) >> 1;
  if (v2 >= v23) {
    goto LABEL_20;
  }
  while (1)
  {
LABEL_23:
    uint64_t v24 = &v4[2 * v2 + 4];
    *uint64_t v24 = v21;
    v24[1] = v20;
    ++v2;
    if (v17)
    {
      unint64_t v25 = __clz(__rbit64(v17));
      v17 &= v17 - 1;
      unint64_t v26 = v25 | (v6 << 6);
      goto LABEL_41;
    }
    int64_t v27 = v6 + 1;
    if (__OFADD__(v6, 1)) {
      break;
    }
    if (v27 >= v36) {
      goto LABEL_45;
    }
    unint64_t v28 = *(void *)(v37 + 8 * v27);
    int64_t v29 = v6 + 1;
    if (!v28)
    {
      int64_t v29 = v6 + 2;
      if (v6 + 2 >= v36) {
        goto LABEL_45;
      }
      unint64_t v28 = *(void *)(v37 + 8 * v29);
      if (!v28)
      {
        int64_t v29 = v6 + 3;
        if (v6 + 3 >= v36) {
          goto LABEL_45;
        }
        unint64_t v28 = *(void *)(v37 + 8 * v29);
        if (!v28)
        {
          int64_t v29 = v6 + 4;
          if (v6 + 4 >= v36) {
            goto LABEL_45;
          }
          unint64_t v28 = *(void *)(v37 + 8 * v29);
          if (!v28)
          {
            int64_t v29 = v6 + 5;
            if (v6 + 5 >= v36) {
              goto LABEL_45;
            }
            unint64_t v28 = *(void *)(v37 + 8 * v29);
            if (!v28)
            {
              int64_t v30 = v6 + 6;
              while (v36 != v30)
              {
                unint64_t v28 = *(void *)(v37 + 8 * v30++);
                if (v28)
                {
                  int64_t v29 = v30 - 1;
                  goto LABEL_40;
                }
              }
LABEL_45:
              v4[2] = v2;
              goto LABEL_13;
            }
          }
        }
      }
    }
LABEL_40:
    unint64_t v17 = (v28 - 1) & v28;
    unint64_t v26 = __clz(__rbit64(v28)) + (v29 << 6);
    int64_t v6 = v29;
LABEL_41:
    id v31 = (uint64_t *)(*(void *)(v3 + 48) + 16 * v26);
    uint64_t v21 = *v31;
    uint64_t v20 = v31[1];
    if (v2 >= v23)
    {
      uint64_t result = swift_bridgeObjectRetain();
      goto LABEL_20;
    }
    uint64_t result = swift_bridgeObjectRetain();
  }
  __break(1u);
LABEL_66:
  __break(1u);
  return result;
}

uint64_t sub_100011D34(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void **)v1;
  int64_t v4 = *(void *)(*(void *)v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  char isUniquelyReferenced_nonNull_native = (void *)swift_isUniquelyReferenced_nonNull_native();
  if (isUniquelyReferenced_nonNull_native && v5 <= v3[3] >> 1)
  {
    if (*(void *)(a1 + 16)) {
      goto LABEL_5;
    }
    goto LABEL_18;
  }
  if (v4 <= v5) {
    int64_t v14 = v4 + v2;
  }
  else {
    int64_t v14 = v4;
  }
  uint64_t v3 = sub_10003E658(isUniquelyReferenced_nonNull_native, v14, 1, v3);
  if (!*(void *)(a1 + 16))
  {
LABEL_18:
    if (!v2) {
      goto LABEL_19;
    }
    goto LABEL_21;
  }
LABEL_5:
  uint64_t v8 = v3[2];
  if ((v3[3] >> 1) - v8 < v2)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  unint64_t v9 = (unint64_t)&v3[2 * v8 + 4];
  if (a1 + 32 < v9 + 16 * v2 && v9 < a1 + 32 + 16 * v2) {
    goto LABEL_24;
  }
  sub_100006FC8(&qword_10047D3E0);
  swift_arrayInitWithCopy();
  if (!v2)
  {
LABEL_19:
    uint64_t result = swift_bridgeObjectRelease();
    *(void *)uint64_t v1 = v3;
    return result;
  }
  uint64_t v11 = v3[2];
  BOOL v12 = __OFADD__(v11, v2);
  uint64_t v13 = v11 + v2;
  if (!v12)
  {
    v3[2] = v13;
    goto LABEL_19;
  }
LABEL_23:
  __break(1u);
LABEL_24:
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

void sub_100011E98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a3 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager);
  NSString v4 = String._bridgeToObjectiveC()();
  id v5 = [v3 domainForName:v4];

  if (!v5) {
    __break(1u);
  }
}

id sub_100011EF8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t))(a1 + 32);
  uint64_t v2 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v3 = (void *)v1(v2);
  swift_bridgeObjectRelease();
  return v3;
}

id sub_100011F54(void *a1, unsigned char *a2, void *a3, unint64_t a4, void *a5)
{
  uint64_t v7 = *(void **)&a2[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__appManager];
  id v8 = *(id *)&a2[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona];
  id v40 = v7;
  id v9 = MBAllCKPlugins();
  sub_100006FC8((uint64_t *)&unk_10047D370);
  static Array._unconditionallyBridgeFromObjectiveC(_:)();

  id result = (id)MBBuildVersion();
  if (result)
  {
    uint64_t v11 = result;
    static String._unconditionallyBridgeFromObjectiveC(_:)();

    unsigned __int8 v39 = [v8 shouldRestoreToSharedVolume];
    char v12 = a2[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__isRestoringPrimaryAccount];
    id v13 = objc_allocWithZone((Class)MBRestorePolicy);
    id v14 = a3;
    BOOL v15 = a2;
    Class isa = Array._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    NSString v17 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    BYTE2(v38) = 1;
    BYTE1(v38) = v12;
    LOBYTE(v38) = v39;
    id v18 = objc_msgSend(v13, "initWithPersona:enginePolicyProvider:appManager:plugins:serviceRestoreMode:osBuildVersionOfBackup:shouldRestoreSystemFiles:isRestoringPrimaryAccount:shouldCreateMissingIntermediateDirectories:", v8, v15, v40, isa, v14, v17, v38);

    unint64_t v19 = *(void *)&v15[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__restoreSnapshotsDir];
    id v20 = v18;
    sub_10002D270(v19);
    id v21 = objc_allocWithZone((Class)MBRestoreSnapshotIntegrityVerifier);
    unint64_t v22 = v15;
    swift_bridgeObjectRetain();
    NSString v23 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    NSString v24 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v41 = [v21 initWithPolicy:v20 snapshotFormat:2 snapshotDir:v23 snapshotUUID:v24 delegate:v22];

    uint64_t v25 = sub_10002D270(a4);
    uint64_t v27 = v26;
    unint64_t v28 = *(void **)&v22[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__depot];
    int64_t v29 = *(void **)&v22[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress];
    int64_t v30 = *(void **)&v22[OBJC_IVAR____TtC7backupd19MBDryRestoreContext__logger];
    id v31 = objc_allocWithZone((Class)type metadata accessor for MBRestoreATCEngine());
    id v32 = v30;
    id v33 = v20;
    id v34 = v28;
    id v35 = a1;
    swift_unknownObjectRetain();
    id v36 = v29;
    id v37 = sub_100024554(v25, v27, v33, v34, (uint64_t)v35, a5, v29, 0, v30);

    return v37;
  }
  else
  {
    __break(1u);
  }
  return result;
}

id sub_100012274()
{
  uint64_t v1 = self;
  uint64_t v2 = *(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__tracker);
  uint64_t v3 = *(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__device);
  id v8 = 0;
  id v4 = [v1 assetFetcherWithOperationTracker:v2 device:v3 error:&v8];
  if (v4)
  {
    id v5 = v8;
  }
  else
  {
    id v6 = v8;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
  return v4;
}

uint64_t sub_10001234C()
{
  uint64_t v1 = v0;
  double Current = CFAbsoluteTimeGetCurrent();
  id v3 = [*(id *)(v0 + OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__domain) name];
  uint64_t v4 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  id v6 = v5;

  unint64_t v7 = *(void *)(v1
                 + OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__restorePath);
  sub_100007F74(511, v7);
  _StringGuts.grow(_:)(29);
  swift_bridgeObjectRelease();
  v8._countAndFlagsBits = v4;
  v8._object = v6;
  String.append(_:)(v8);
  v9._countAndFlagsBits = 544175136;
  v9._object = (void *)0xE400000000000000;
  String.append(_:)(v9);
  swift_retain();
  v10._countAndFlagsBits = sub_10002D874(v7);
  String.append(_:)(v10);
  swift_release();
  swift_bridgeObjectRelease();
  sub_100045F18(0xD000000000000015, 0x8000000100304B40, 0xD000000000000016, 0x80000001003047B0);
  swift_bridgeObjectRelease();
  sub_100012864(v1);
  CFAbsoluteTime v12 = CFAbsoluteTimeGetCurrent() - Current;
  _StringGuts.grow(_:)(41);
  swift_bridgeObjectRelease();
  v13._countAndFlagsBits = v4;
  v13._object = v6;
  String.append(_:)(v13);
  swift_bridgeObjectRelease();
  v14._countAndFlagsBits = 544106784;
  v14._object = (void *)0xE400000000000000;
  String.append(_:)(v14);
  sub_100006FC8((uint64_t *)&unk_10047D8F0);
  uint64_t v15 = swift_allocObject();
  *(_OWORD *)(v15 + 16) = xmmword_1003B1EF0;
  *(void *)(v15 + 56) = &type metadata for Double;
  *(void *)(v15 + 64) = &protocol witness table for Double;
  *(CFAbsoluteTime *)(v15 + 32) = v12;
  v16._countAndFlagsBits = String.init(format:_:)();
  String.append(_:)(v16);
  swift_bridgeObjectRelease();
  v17._countAndFlagsBits = 115;
  v17._object = (void *)0xE100000000000000;
  String.append(_:)(v17);
  sub_100045F18(0xD000000000000020, 0x8000000100304B60, 0xD000000000000016, 0x80000001003047B0);
  return swift_bridgeObjectRelease();
}

uint64_t sub_100012774()
{
  v6.receiver = v0;
  v6.super_class = (Class)type metadata accessor for _DryRestoreDomainOperation();
  objc_msgSendSuper2(&v6, "cancel");
  uint64_t v1 = *(void *)&v0[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine];
  uint64_t v2 = *(void *)(v1 + 16);
  id v3 = *(os_unfair_lock_s **)(v2 + 16);
  swift_retain();
  os_unfair_lock_lock(v3);
  swift_beginAccess();
  uint64_t v4 = *(void **)(v1 + 24);
  if (v4) {
    [v4 cancel];
  }
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v2 + 16));
  return swift_release();
}

void sub_100012864(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__context);
  id v4 = sub_100012274();
  if (!v1)
  {
    id v5 = v4;
    objc_super v6 = (void *)(*(uint64_t (**)(void))(a1
                                      + OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engineCreationBlock))();
    uint64_t v7 = OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine;
    uint64_t v8 = *(void *)(a1
                   + OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine);
    uint64_t v9 = *(void *)(v8 + 16);
    Swift::String v10 = *(os_unfair_lock_s **)(v9 + 16);
    swift_retain();
    swift_unknownObjectRetain();
    os_unfair_lock_lock(v10);
    swift_beginAccess();
    *(void *)(v8 + 24) = v6;
    uint64_t v11 = *(os_unfair_lock_s **)(v9 + 16);
    swift_unknownObjectRetain();
    os_unfair_lock_unlock(v11);
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    swift_release();
    v21[0] = 0;
    if ([v6 runWithError:v21])
    {
      uint64_t v12 = *(void *)(a1 + v7);
      uint64_t v13 = *(void *)(v12 + 16);
      Swift::String v14 = *(os_unfair_lock_s **)(v13 + 16);
      id v15 = v21[0];
      swift_retain();
      os_unfair_lock_lock(v14);
      swift_beginAccess();
      *(void *)(v12 + 24) = 0;
      os_unfair_lock_unlock(*(os_unfair_lock_t *)(v13 + 16));
      swift_unknownObjectRelease();
      swift_release();
      Swift::String v16 = [v6 assetFetchSummary];
      id v17 = [v6 restorablePlacementSummary];
      uint64_t v18 = *(void *)(*(void *)(v3 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__summary) + 16);
      unint64_t v19 = *(os_unfair_lock_s **)(v18 + 16);
      swift_retain();
      os_unfair_lock_lock(v19);
      swift_beginAccess();
      sub_10001C24C(v16, (uint64_t)v17);
      swift_endAccess();
      os_unfair_lock_unlock(*(os_unfair_lock_t *)(v18 + 16));
      swift_release();
    }
    else
    {
      id v20 = v21[0];
      _convertNSErrorToError(_:)();

      swift_willThrow();
    }
    swift_unknownObjectRelease();
    sub_100012AE8(v5);
  }
}

id sub_100012AE8(void *a1)
{
  id v13 = 0;
  unsigned int v2 = [a1 disposeWithError:&v13];
  id v3 = v13;
  if (v2)
  {
    return v3;
  }
  else
  {
    id v5 = v13;
    uint64_t v6 = _convertNSErrorToError(_:)();

    swift_willThrow();
    id v13 = 0;
    unint64_t v14 = 0xE000000000000000;
    _StringGuts.grow(_:)(28);
    swift_bridgeObjectRelease();
    id v13 = (id)0xD00000000000001ALL;
    unint64_t v14 = 0x8000000100304B90;
    id v7 = [a1 description];
    uint64_t v8 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    Swift::String v10 = v9;

    v11._countAndFlagsBits = v8;
    v11._object = v10;
    String.append(_:)(v11);
    swift_bridgeObjectRelease();
    id v12 = sub_100045F30(v6, 0xF000000000000007, (uint64_t)v13, v14, 0xD000000000000016, 0x80000001003047B0);
    swift_bridgeObjectRelease();
    sub_10000E000((uint64_t)v12);
    swift_errorRelease();
    return (id)swift_errorRelease();
  }
}

id sub_100012CE4()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for _DryRestoreDomainOperation();
  return objc_msgSendSuper2(&v2, "dealloc");
}

uint64_t type metadata accessor for _DryRestoreDomainOperation()
{
  return self;
}

uint64_t sub_100012E8C()
{
  return _swift_deallocObject(v0, 24, 7);
}

id sub_100012EC4(uint64_t a1)
{
  return [*(id *)(v1 + 16) foregroundStateForRestorable:a1];
}

uint64_t sub_100012ED8()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100012EE8()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_100012F10(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_100012F20()
{
  return swift_release();
}

uint64_t sub_100012F28(uint64_t a1, char *a2)
{
  id v3 = v2;
  uint64_t v6 = type metadata accessor for UUID();
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)v26 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *v2;
  sub_1000179D0((unint64_t *)&qword_10047D400, (void (*)(uint64_t))&type metadata accessor for UUID);
  swift_bridgeObjectRetain();
  id v33 = a2;
  uint64_t v11 = dispatch thunk of Hashable._rawHashValue(seed:)();
  uint64_t v12 = -1 << *(unsigned char *)(v10 + 32);
  unint64_t v13 = v11 & ~v12;
  uint64_t v32 = v10 + 56;
  if ((*(void *)(v10 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13))
  {
    unint64_t v28 = v2;
    uint64_t v29 = a1;
    uint64_t v30 = ~v12;
    uint64_t v27 = v7;
    Swift::String v16 = *(void (**)(void, void, void))(v7 + 16);
    uint64_t v15 = v7 + 16;
    unint64_t v14 = v16;
    uint64_t v31 = *(void *)(v15 + 56);
    id v17 = (void (**)(char *, uint64_t))(v15 - 8);
    v26[1] = v15 & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
    while (1)
    {
      uint64_t v18 = v10;
      unint64_t v19 = v31 * v13;
      id v20 = v14;
      v14(v9, *(void *)(v10 + 48) + v31 * v13, v6);
      sub_1000179D0(&qword_10047D098, (void (*)(uint64_t))&type metadata accessor for UUID);
      char v21 = dispatch thunk of static Equatable.== infix(_:_:)();
      unint64_t v22 = *v17;
      (*v17)(v9, v6);
      if (v21) {
        break;
      }
      unint64_t v13 = (v13 + 1) & v30;
      uint64_t v10 = v18;
      unint64_t v14 = v20;
      if (((*(void *)(v32 + ((v13 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v13) & 1) == 0)
      {
        swift_bridgeObjectRelease();
        id v3 = v28;
        a1 = v29;
        uint64_t v7 = v27;
        goto LABEL_7;
      }
    }
    swift_bridgeObjectRelease();
    v22(v33, v6);
    v20(v29, *(void *)(*v28 + 48) + v19, v6);
    return 0;
  }
  else
  {
    swift_bridgeObjectRelease();
    unint64_t v14 = *(void (**)(void, void, void))(v7 + 16);
LABEL_7:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    NSString v24 = v33;
    v14(v9, v33, v6);
    uint64_t v34 = *v3;
    *id v3 = 0x8000000000000000;
    sub_100013AD8((uint64_t)v9, v13, isUniquelyReferenced_nonNull_native);
    *id v3 = v34;
    swift_bridgeObjectRelease();
    (*(void (**)(uint64_t, char *, uint64_t))(v7 + 32))(a1, v24, v6);
    return 1;
  }
}

uint64_t sub_10001324C(Swift::Int *a1, Swift::Int a2, Swift::Int a3)
{
  uint64_t v7 = *v3;
  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  Swift::Int v8 = Hasher._finalize()();
  uint64_t v9 = -1 << *(unsigned char *)(v7 + 32);
  unint64_t v10 = v8 & ~v9;
  if ((*(void *)(v7 + 56 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10))
  {
    uint64_t v11 = *(void *)(v7 + 48);
    uint64_t v12 = (void *)(v11 + 16 * v10);
    BOOL v13 = *v12 == a2 && v12[1] == a3;
    if (v13 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
    {
LABEL_7:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      unint64_t v14 = (Swift::Int *)(*(void *)(*v3 + 48) + 16 * v10);
      Swift::Int v15 = v14[1];
      *a1 = *v14;
      a1[1] = v15;
      swift_bridgeObjectRetain();
      return 0;
    }
    uint64_t v17 = ~v9;
    while (1)
    {
      unint64_t v10 = (v10 + 1) & v17;
      if (((*(void *)(v7 + 56 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10) & 1) == 0) {
        break;
      }
      uint64_t v18 = (void *)(v11 + 16 * v10);
      BOOL v19 = *v18 == a2 && v18[1] == a3;
      if (v19 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
        goto LABEL_7;
      }
    }
  }
  swift_bridgeObjectRelease();
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v21 = *v3;
  *id v3 = 0x8000000000000000;
  swift_bridgeObjectRetain();
  sub_100013D78(a2, a3, v10, isUniquelyReferenced_nonNull_native);
  *id v3 = v21;
  swift_bridgeObjectRelease();
  *a1 = a2;
  a1[1] = a3;
  return 1;
}

uint64_t sub_1000133FC()
{
  uint64_t v1 = v0;
  uint64_t v42 = type metadata accessor for UUID();
  uint64_t v2 = *(void *)(v42 - 8);
  __chkstk_darwin(v42);
  id v41 = (char *)&v35 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = *v0;
  sub_100006FC8((uint64_t *)&unk_10047D410);
  uint64_t v5 = static _SetStorage.resize(original:capacity:move:)();
  uint64_t v6 = v5;
  if (*(void *)(v4 + 16))
  {
    uint64_t v7 = 1 << *(unsigned char *)(v4 + 32);
    uint64_t v8 = *(void *)(v4 + 56);
    id v37 = (void *)(v4 + 56);
    if (v7 < 64) {
      uint64_t v9 = ~(-1 << v7);
    }
    else {
      uint64_t v9 = -1;
    }
    unint64_t v10 = v9 & v8;
    id v35 = v0;
    int64_t v36 = (unint64_t)(v7 + 63) >> 6;
    uint64_t v39 = v2;
    uint64_t v11 = v5 + 56;
    uint64_t result = swift_retain();
    int64_t v13 = 0;
    uint64_t v38 = v6;
    unint64_t v14 = v41;
    uint64_t v15 = v42;
    while (1)
    {
      if (v10)
      {
        unint64_t v17 = __clz(__rbit64(v10));
        v10 &= v10 - 1;
        int64_t v40 = v13;
        unint64_t v18 = v17 | (v13 << 6);
      }
      else
      {
        int64_t v19 = v13 + 1;
        if (__OFADD__(v13, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v19 >= v36) {
          goto LABEL_33;
        }
        unint64_t v20 = v37[v19];
        int64_t v21 = v13 + 1;
        if (!v20)
        {
          int64_t v21 = v13 + 2;
          if (v13 + 2 >= v36) {
            goto LABEL_33;
          }
          unint64_t v20 = v37[v21];
          if (!v20)
          {
            int64_t v21 = v13 + 3;
            if (v13 + 3 >= v36) {
              goto LABEL_33;
            }
            unint64_t v20 = v37[v21];
            if (!v20)
            {
              uint64_t v22 = v13 + 4;
              if (v13 + 4 >= v36)
              {
LABEL_33:
                swift_release();
                uint64_t v1 = v35;
                uint64_t v34 = 1 << *(unsigned char *)(v4 + 32);
                if (v34 > 63) {
                  bzero(v37, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  *id v37 = -1 << v34;
                }
                *(void *)(v4 + 16) = 0;
                break;
              }
              unint64_t v20 = v37[v22];
              if (!v20)
              {
                while (1)
                {
                  int64_t v21 = v22 + 1;
                  if (__OFADD__(v22, 1)) {
                    goto LABEL_39;
                  }
                  if (v21 >= v36) {
                    goto LABEL_33;
                  }
                  unint64_t v20 = v37[v21];
                  ++v22;
                  if (v20) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v21 = v13 + 4;
            }
          }
        }
LABEL_23:
        unint64_t v10 = (v20 - 1) & v20;
        int64_t v40 = v21;
        unint64_t v18 = __clz(__rbit64(v20)) + (v21 << 6);
      }
      uint64_t v23 = v4;
      uint64_t v24 = *(void *)(v4 + 48);
      uint64_t v25 = *(void *)(v39 + 72);
      uint64_t v26 = *(void (**)(char *, unint64_t, uint64_t))(v39 + 32);
      v26(v14, v24 + v25 * v18, v15);
      uint64_t v6 = v38;
      sub_1000179D0((unint64_t *)&qword_10047D400, (void (*)(uint64_t))&type metadata accessor for UUID);
      uint64_t result = dispatch thunk of Hashable._rawHashValue(seed:)();
      uint64_t v27 = -1 << *(unsigned char *)(v6 + 32);
      unint64_t v28 = result & ~v27;
      unint64_t v29 = v28 >> 6;
      if (((-1 << v28) & ~*(void *)(v11 + 8 * (v28 >> 6))) != 0)
      {
        unint64_t v16 = __clz(__rbit64((-1 << v28) & ~*(void *)(v11 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v30 = 0;
        unint64_t v31 = (unint64_t)(63 - v27) >> 6;
        do
        {
          if (++v29 == v31 && (v30 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v32 = v29 == v31;
          if (v29 == v31) {
            unint64_t v29 = 0;
          }
          v30 |= v32;
          uint64_t v33 = *(void *)(v11 + 8 * v29);
        }
        while (v33 == -1);
        unint64_t v16 = __clz(__rbit64(~v33)) + (v29 << 6);
      }
      *(void *)(v11 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v16;
      uint64_t result = ((uint64_t (*)(unint64_t, char *, uint64_t))v26)(*(void *)(v6 + 48) + v16 * v25, v41, v42);
      ++*(void *)(v6 + 16);
      uint64_t v4 = v23;
      int64_t v13 = v40;
    }
  }
  uint64_t result = swift_release();
  uint64_t *v1 = v6;
  return result;
}

uint64_t sub_1000137F8()
{
  uint64_t v1 = v0;
  uint64_t v2 = *v0;
  sub_100006FC8(&qword_10047D380);
  uint64_t v3 = static _SetStorage.resize(original:capacity:move:)();
  uint64_t v4 = v3;
  if (*(void *)(v2 + 16))
  {
    uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
    char v30 = (void *)(v2 + 56);
    if (v5 < 64) {
      uint64_t v6 = ~(-1 << v5);
    }
    else {
      uint64_t v6 = -1;
    }
    unint64_t v7 = v6 & *(void *)(v2 + 56);
    int64_t v8 = (unint64_t)(v5 + 63) >> 6;
    uint64_t v9 = v3 + 56;
    uint64_t result = swift_retain();
    int64_t v11 = 0;
    while (1)
    {
      if (v7)
      {
        unint64_t v14 = __clz(__rbit64(v7));
        v7 &= v7 - 1;
        unint64_t v15 = v14 | (v11 << 6);
      }
      else
      {
        int64_t v16 = v11 + 1;
        if (__OFADD__(v11, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v16 >= v8) {
          goto LABEL_33;
        }
        unint64_t v17 = v30[v16];
        ++v11;
        if (!v17)
        {
          int64_t v11 = v16 + 1;
          if (v16 + 1 >= v8) {
            goto LABEL_33;
          }
          unint64_t v17 = v30[v11];
          if (!v17)
          {
            int64_t v11 = v16 + 2;
            if (v16 + 2 >= v8) {
              goto LABEL_33;
            }
            unint64_t v17 = v30[v11];
            if (!v17)
            {
              int64_t v18 = v16 + 3;
              if (v18 >= v8)
              {
LABEL_33:
                swift_release();
                uint64_t v1 = v0;
                uint64_t v29 = 1 << *(unsigned char *)(v2 + 32);
                if (v29 > 63) {
                  bzero(v30, ((unint64_t)(v29 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  *char v30 = -1 << v29;
                }
                *(void *)(v2 + 16) = 0;
                break;
              }
              unint64_t v17 = v30[v18];
              if (!v17)
              {
                while (1)
                {
                  int64_t v11 = v18 + 1;
                  if (__OFADD__(v18, 1)) {
                    goto LABEL_39;
                  }
                  if (v11 >= v8) {
                    goto LABEL_33;
                  }
                  unint64_t v17 = v30[v11];
                  ++v18;
                  if (v17) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v11 = v18;
            }
          }
        }
LABEL_23:
        unint64_t v7 = (v17 - 1) & v17;
        unint64_t v15 = __clz(__rbit64(v17)) + (v11 << 6);
      }
      int64_t v19 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v15);
      uint64_t v20 = *v19;
      uint64_t v21 = v19[1];
      Hasher.init(_seed:)();
      String.hash(into:)();
      uint64_t result = Hasher._finalize()();
      uint64_t v22 = -1 << *(unsigned char *)(v4 + 32);
      unint64_t v23 = result & ~v22;
      unint64_t v24 = v23 >> 6;
      if (((-1 << v23) & ~*(void *)(v9 + 8 * (v23 >> 6))) != 0)
      {
        unint64_t v12 = __clz(__rbit64((-1 << v23) & ~*(void *)(v9 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v25 = 0;
        unint64_t v26 = (unint64_t)(63 - v22) >> 6;
        do
        {
          if (++v24 == v26 && (v25 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v27 = v24 == v26;
          if (v24 == v26) {
            unint64_t v24 = 0;
          }
          v25 |= v27;
          uint64_t v28 = *(void *)(v9 + 8 * v24);
        }
        while (v28 == -1);
        unint64_t v12 = __clz(__rbit64(~v28)) + (v24 << 6);
      }
      *(void *)(v9 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v12;
      int64_t v13 = (void *)(*(void *)(v4 + 48) + 16 * v12);
      *int64_t v13 = v20;
      v13[1] = v21;
      ++*(void *)(v4 + 16);
    }
  }
  uint64_t result = swift_release();
  uint64_t *v1 = v4;
  return result;
}

uint64_t sub_100013AD8(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v31 = a1;
  uint64_t v6 = type metadata accessor for UUID();
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v28 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v10 = *(void *)(*v3 + 16);
  unint64_t v11 = *(void *)(*v3 + 24);
  uint64_t v28 = v3;
  uint64_t v29 = v7;
  if (v11 > v10 && (a3 & 1) != 0) {
    goto LABEL_12;
  }
  if (a3)
  {
    sub_1000133FC();
  }
  else
  {
    if (v11 > v10)
    {
      sub_100013F14();
      goto LABEL_12;
    }
    sub_10001436C();
  }
  uint64_t v12 = *v3;
  sub_1000179D0((unint64_t *)&qword_10047D400, (void (*)(uint64_t))&type metadata accessor for UUID);
  uint64_t v13 = dispatch thunk of Hashable._rawHashValue(seed:)();
  uint64_t v14 = -1 << *(unsigned char *)(v12 + 32);
  a2 = v13 & ~v14;
  uint64_t v30 = v12;
  uint64_t v15 = v12 + 56;
  if ((*(void *)(v12 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
  {
    uint64_t v16 = ~v14;
    int64_t v19 = *(void (**)(char *, unint64_t, uint64_t))(v7 + 16);
    uint64_t v18 = v7 + 16;
    unint64_t v17 = v19;
    uint64_t v20 = *(void *)(v18 + 56);
    do
    {
      v17(v9, *(void *)(v30 + 48) + v20 * a2, v6);
      sub_1000179D0(&qword_10047D098, (void (*)(uint64_t))&type metadata accessor for UUID);
      char v21 = dispatch thunk of static Equatable.== infix(_:_:)();
      (*(void (**)(char *, uint64_t))(v18 - 8))(v9, v6);
      if (v21) {
        goto LABEL_15;
      }
      a2 = (a2 + 1) & v16;
    }
    while (((*(void *)(v15 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) != 0);
  }
LABEL_12:
  uint64_t v22 = v29;
  uint64_t v23 = *v28;
  *(void *)(v23 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v22 + 32))(*(void *)(v23 + 48) + *(void *)(v22 + 72) * a2, v31, v6);
  uint64_t v25 = *(void *)(v23 + 16);
  BOOL v26 = __OFADD__(v25, 1);
  uint64_t v27 = v25 + 1;
  if (!v26)
  {
    *(void *)(v23 + 16) = v27;
    return result;
  }
  __break(1u);
LABEL_15:
  uint64_t result = ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
  __break(1u);
  return result;
}

Swift::Int sub_100013D78(Swift::Int result, Swift::Int a2, unint64_t a3, char a4)
{
  uint64_t v5 = v4;
  Swift::Int v8 = result;
  unint64_t v9 = *(void *)(*v4 + 16);
  unint64_t v10 = *(void *)(*v4 + 24);
  if (v10 > v9 && (a4 & 1) != 0) {
    goto LABEL_22;
  }
  if (a4)
  {
    sub_1000137F8();
  }
  else
  {
    if (v10 > v9)
    {
      uint64_t result = (Swift::Int)sub_1000141B8();
      goto LABEL_22;
    }
    sub_10001471C();
  }
  uint64_t v11 = *v4;
  Hasher.init(_seed:)();
  String.hash(into:)();
  uint64_t result = Hasher._finalize()();
  uint64_t v12 = -1 << *(unsigned char *)(v11 + 32);
  a3 = result & ~v12;
  uint64_t v13 = v11 + 56;
  if ((*(void *)(v11 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3))
  {
    uint64_t v14 = *(void *)(v11 + 48);
    uint64_t v15 = (void *)(v14 + 16 * a3);
    BOOL v16 = *v15 == v8 && v15[1] == a2;
    if (v16 || (uint64_t result = _stringCompareWithSmolCheck(_:_:expecting:)(), (result & 1) != 0))
    {
LABEL_21:
      uint64_t result = ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
      __break(1u);
    }
    else
    {
      uint64_t v17 = ~v12;
      while (1)
      {
        a3 = (a3 + 1) & v17;
        if (((*(void *)(v13 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3) & 1) == 0) {
          break;
        }
        uint64_t v18 = (void *)(v14 + 16 * a3);
        if (*v18 != v8 || v18[1] != a2)
        {
          uint64_t result = _stringCompareWithSmolCheck(_:_:expecting:)();
          if ((result & 1) == 0) {
            continue;
          }
        }
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  uint64_t v20 = *v5;
  *(void *)(*v5 + 8 * (a3 >> 6) + 56) |= 1 << a3;
  char v21 = (Swift::Int *)(*(void *)(v20 + 48) + 16 * a3);
  Swift::Int *v21 = v8;
  v21[1] = a2;
  uint64_t v22 = *(void *)(v20 + 16);
  BOOL v23 = __OFADD__(v22, 1);
  uint64_t v24 = v22 + 1;
  if (v23) {
    __break(1u);
  }
  else {
    *(void *)(v20 + 16) = v24;
  }
  return result;
}

void *sub_100013F14()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for UUID();
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v21 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100006FC8((uint64_t *)&unk_10047D410);
  uint64_t v6 = *v0;
  uint64_t v7 = static _SetStorage.copy(original:)();
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    uint64_t result = (void *)swift_release();
LABEL_27:
    uint64_t *v1 = v8;
    return result;
  }
  uint64_t v22 = v1;
  uint64_t result = (void *)(v7 + 56);
  unint64_t v10 = (unint64_t)((1 << *(unsigned char *)(v8 + 32)) + 63) >> 6;
  if (v8 != v6 || (unint64_t)result >= v6 + 56 + 8 * v10) {
    uint64_t result = memmove(result, (const void *)(v6 + 56), 8 * v10);
  }
  uint64_t v23 = v6 + 56;
  int64_t v11 = 0;
  *(void *)(v8 + 16) = *(void *)(v6 + 16);
  uint64_t v12 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v13 = -1;
  if (v12 < 64) {
    uint64_t v13 = ~(-1 << v12);
  }
  unint64_t v14 = v13 & *(void *)(v6 + 56);
  int64_t v24 = (unint64_t)(v12 + 63) >> 6;
  while (1)
  {
    if (v14)
    {
      unint64_t v15 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v16 = v15 | (v11 << 6);
      goto LABEL_9;
    }
    int64_t v18 = v11 + 1;
    if (__OFADD__(v11, 1))
    {
      __break(1u);
      goto LABEL_29;
    }
    if (v18 >= v24) {
      goto LABEL_25;
    }
    unint64_t v19 = *(void *)(v23 + 8 * v18);
    ++v11;
    if (!v19)
    {
      int64_t v11 = v18 + 1;
      if (v18 + 1 >= v24) {
        goto LABEL_25;
      }
      unint64_t v19 = *(void *)(v23 + 8 * v11);
      if (!v19)
      {
        int64_t v11 = v18 + 2;
        if (v18 + 2 >= v24) {
          goto LABEL_25;
        }
        unint64_t v19 = *(void *)(v23 + 8 * v11);
        if (!v19) {
          break;
        }
      }
    }
LABEL_24:
    unint64_t v14 = (v19 - 1) & v19;
    unint64_t v16 = __clz(__rbit64(v19)) + (v11 << 6);
LABEL_9:
    unint64_t v17 = *(void *)(v3 + 72) * v16;
    (*(void (**)(char *, unint64_t, uint64_t))(v3 + 16))(v5, *(void *)(v6 + 48) + v17, v2);
    uint64_t result = (void *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v3 + 32))(*(void *)(v8 + 48) + v17, v5, v2);
  }
  int64_t v20 = v18 + 3;
  if (v20 >= v24)
  {
LABEL_25:
    uint64_t result = (void *)swift_release();
    uint64_t v1 = v22;
    goto LABEL_27;
  }
  unint64_t v19 = *(void *)(v23 + 8 * v20);
  if (v19)
  {
    int64_t v11 = v20;
    goto LABEL_24;
  }
  while (1)
  {
    int64_t v11 = v20 + 1;
    if (__OFADD__(v20, 1)) {
      break;
    }
    if (v11 >= v24) {
      goto LABEL_25;
    }
    unint64_t v19 = *(void *)(v23 + 8 * v11);
    ++v20;
    if (v19) {
      goto LABEL_24;
    }
  }
LABEL_29:
  __break(1u);
  return result;
}

void *sub_1000141B8()
{
  uint64_t v1 = v0;
  sub_100006FC8(&qword_10047D380);
  uint64_t v2 = *v0;
  uint64_t v3 = static _SetStorage.copy(original:)();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_28:
    uint64_t result = (void *)swift_release();
    uint64_t *v1 = v4;
    return result;
  }
  uint64_t result = (void *)(v3 + 56);
  uint64_t v6 = v2 + 56;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 56 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 56), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 56);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v20 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_30;
    }
    if (v20 >= v13) {
      goto LABEL_28;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v20);
    ++v9;
    if (!v21)
    {
      int64_t v9 = v20 + 1;
      if (v20 + 1 >= v13) {
        goto LABEL_28;
      }
      unint64_t v21 = *(void *)(v6 + 8 * v9);
      if (!v21)
      {
        int64_t v9 = v20 + 2;
        if (v20 + 2 >= v13) {
          goto LABEL_28;
        }
        unint64_t v21 = *(void *)(v6 + 8 * v9);
        if (!v21) {
          break;
        }
      }
    }
LABEL_27:
    unint64_t v12 = (v21 - 1) & v21;
    unint64_t v15 = __clz(__rbit64(v21)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 16 * v15;
    unint64_t v17 = (void *)(*(void *)(v2 + 48) + v16);
    uint64_t v18 = v17[1];
    unint64_t v19 = (void *)(*(void *)(v4 + 48) + v16);
    *unint64_t v19 = *v17;
    v19[1] = v18;
    uint64_t result = (void *)swift_bridgeObjectRetain();
  }
  int64_t v22 = v20 + 3;
  if (v22 >= v13) {
    goto LABEL_28;
  }
  unint64_t v21 = *(void *)(v6 + 8 * v22);
  if (v21)
  {
    int64_t v9 = v22;
    goto LABEL_27;
  }
  while (1)
  {
    int64_t v9 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_28;
    }
    unint64_t v21 = *(void *)(v6 + 8 * v9);
    ++v22;
    if (v21) {
      goto LABEL_27;
    }
  }
LABEL_30:
  __break(1u);
  return result;
}

uint64_t sub_10001436C()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for UUID();
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v33 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *v0;
  sub_100006FC8((uint64_t *)&unk_10047D410);
  uint64_t v7 = static _SetStorage.resize(original:capacity:move:)();
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    uint64_t result = swift_release();
LABEL_35:
    uint64_t *v1 = v8;
    return result;
  }
  uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v10 = *(void *)(v6 + 56);
  uint64_t v34 = v0;
  uint64_t v35 = v6 + 56;
  if (v9 < 64) {
    uint64_t v11 = ~(-1 << v9);
  }
  else {
    uint64_t v11 = -1;
  }
  unint64_t v12 = v11 & v10;
  int64_t v36 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v37 = v3 + 16;
  uint64_t v13 = v7 + 56;
  uint64_t v38 = v3;
  unint64_t v14 = (uint64_t (**)(unint64_t, char *, uint64_t))(v3 + 32);
  uint64_t result = swift_retain();
  int64_t v16 = 0;
  while (1)
  {
    if (v12)
    {
      unint64_t v18 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v19 = v18 | (v16 << 6);
      goto LABEL_24;
    }
    int64_t v20 = v16 + 1;
    if (__OFADD__(v16, 1))
    {
LABEL_36:
      __break(1u);
      goto LABEL_37;
    }
    if (v20 >= v36) {
      goto LABEL_33;
    }
    unint64_t v21 = *(void *)(v35 + 8 * v20);
    ++v16;
    if (!v21)
    {
      int64_t v16 = v20 + 1;
      if (v20 + 1 >= v36) {
        goto LABEL_33;
      }
      unint64_t v21 = *(void *)(v35 + 8 * v16);
      if (!v21)
      {
        int64_t v16 = v20 + 2;
        if (v20 + 2 >= v36) {
          goto LABEL_33;
        }
        unint64_t v21 = *(void *)(v35 + 8 * v16);
        if (!v21) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v12 = (v21 - 1) & v21;
    unint64_t v19 = __clz(__rbit64(v21)) + (v16 << 6);
LABEL_24:
    uint64_t v23 = v6;
    uint64_t v24 = *(void *)(v6 + 48);
    uint64_t v25 = *(void *)(v38 + 72);
    (*(void (**)(char *, unint64_t, uint64_t))(v38 + 16))(v5, v24 + v25 * v19, v2);
    sub_1000179D0((unint64_t *)&qword_10047D400, (void (*)(uint64_t))&type metadata accessor for UUID);
    uint64_t result = dispatch thunk of Hashable._rawHashValue(seed:)();
    uint64_t v26 = -1 << *(unsigned char *)(v8 + 32);
    unint64_t v27 = result & ~v26;
    unint64_t v28 = v27 >> 6;
    if (((-1 << v27) & ~*(void *)(v13 + 8 * (v27 >> 6))) != 0)
    {
      unint64_t v17 = __clz(__rbit64((-1 << v27) & ~*(void *)(v13 + 8 * (v27 >> 6)))) | v27 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v29 = 0;
      unint64_t v30 = (unint64_t)(63 - v26) >> 6;
      do
      {
        if (++v28 == v30 && (v29 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }
        BOOL v31 = v28 == v30;
        if (v28 == v30) {
          unint64_t v28 = 0;
        }
        v29 |= v31;
        uint64_t v32 = *(void *)(v13 + 8 * v28);
      }
      while (v32 == -1);
      unint64_t v17 = __clz(__rbit64(~v32)) + (v28 << 6);
    }
    *(void *)(v13 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    uint64_t result = (*v14)(*(void *)(v8 + 48) + v17 * v25, v5, v2);
    ++*(void *)(v8 + 16);
    uint64_t v6 = v23;
  }
  int64_t v22 = v20 + 3;
  if (v22 >= v36)
  {
LABEL_33:
    uint64_t result = swift_release_n();
    uint64_t v1 = v34;
    goto LABEL_35;
  }
  unint64_t v21 = *(void *)(v35 + 8 * v22);
  if (v21)
  {
    int64_t v16 = v22;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v16 = v22 + 1;
    if (__OFADD__(v22, 1)) {
      break;
    }
    if (v16 >= v36) {
      goto LABEL_33;
    }
    unint64_t v21 = *(void *)(v35 + 8 * v16);
    ++v22;
    if (v21) {
      goto LABEL_23;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

uint64_t sub_10001471C()
{
  uint64_t v1 = v0;
  uint64_t v2 = *v0;
  sub_100006FC8(&qword_10047D380);
  uint64_t v3 = static _SetStorage.resize(original:capacity:move:)();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
    uint64_t result = swift_release();
LABEL_35:
    uint64_t *v1 = v4;
    return result;
  }
  uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v6 = v2 + 56;
  if (v5 < 64) {
    uint64_t v7 = ~(-1 << v5);
  }
  else {
    uint64_t v7 = -1;
  }
  unint64_t v8 = v7 & *(void *)(v2 + 56);
  int64_t v29 = (unint64_t)(v5 + 63) >> 6;
  uint64_t v9 = v3 + 56;
  uint64_t result = swift_retain();
  int64_t v11 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v14 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v15 = v14 | (v11 << 6);
      goto LABEL_24;
    }
    int64_t v16 = v11 + 1;
    if (__OFADD__(v11, 1))
    {
LABEL_36:
      __break(1u);
      goto LABEL_37;
    }
    if (v16 >= v29) {
      goto LABEL_33;
    }
    unint64_t v17 = *(void *)(v6 + 8 * v16);
    ++v11;
    if (!v17)
    {
      int64_t v11 = v16 + 1;
      if (v16 + 1 >= v29) {
        goto LABEL_33;
      }
      unint64_t v17 = *(void *)(v6 + 8 * v11);
      if (!v17)
      {
        int64_t v11 = v16 + 2;
        if (v16 + 2 >= v29) {
          goto LABEL_33;
        }
        unint64_t v17 = *(void *)(v6 + 8 * v11);
        if (!v17) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v8 = (v17 - 1) & v17;
    unint64_t v15 = __clz(__rbit64(v17)) + (v11 << 6);
LABEL_24:
    unint64_t v19 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v15);
    uint64_t v20 = *v19;
    uint64_t v21 = v19[1];
    Hasher.init(_seed:)();
    swift_bridgeObjectRetain();
    String.hash(into:)();
    uint64_t result = Hasher._finalize()();
    uint64_t v22 = -1 << *(unsigned char *)(v4 + 32);
    unint64_t v23 = result & ~v22;
    unint64_t v24 = v23 >> 6;
    if (((-1 << v23) & ~*(void *)(v9 + 8 * (v23 >> 6))) != 0)
    {
      unint64_t v12 = __clz(__rbit64((-1 << v23) & ~*(void *)(v9 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v25 = 0;
      unint64_t v26 = (unint64_t)(63 - v22) >> 6;
      do
      {
        if (++v24 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }
        BOOL v27 = v24 == v26;
        if (v24 == v26) {
          unint64_t v24 = 0;
        }
        v25 |= v27;
        uint64_t v28 = *(void *)(v9 + 8 * v24);
      }
      while (v28 == -1);
      unint64_t v12 = __clz(__rbit64(~v28)) + (v24 << 6);
    }
    *(void *)(v9 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v12;
    uint64_t v13 = (void *)(*(void *)(v4 + 48) + 16 * v12);
    *uint64_t v13 = v20;
    v13[1] = v21;
    ++*(void *)(v4 + 16);
  }
  int64_t v18 = v16 + 3;
  if (v18 >= v29)
  {
LABEL_33:
    uint64_t result = swift_release_n();
    uint64_t v1 = v0;
    goto LABEL_35;
  }
  unint64_t v17 = *(void *)(v6 + 8 * v18);
  if (v17)
  {
    int64_t v11 = v18;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v11 = v18 + 1;
    if (__OFADD__(v18, 1)) {
      break;
    }
    if (v11 >= v29) {
      goto LABEL_33;
    }
    unint64_t v17 = *(void *)(v6 + 8 * v11);
    ++v18;
    if (v17) {
      goto LABEL_23;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

uint64_t sub_1000149CC(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100014A2C(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1000149EC(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100014B9C(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100014A0C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100014D08(a1, a2, a3, (void *)*v3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100014A2C(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_32;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    sub_100006FC8(&qword_10047D3B0);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = j__malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 1;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 5);
  }
  else
  {
    uint64_t v10 = (char *)_swiftEmptyArrayStorage;
  }
  uint64_t v13 = v10 + 32;
  unint64_t v14 = a4 + 32;
  if (a1)
  {
    if (v10 != a4 || v13 >= &v14[32 * v8]) {
      memmove(v13, v14, 32 * v8);
    }
    *((void *)a4 + 2) = 0;
    goto LABEL_30;
  }
  if (v14 >= &v13[32 * v8] || v13 >= &v14[32 * v8])
  {
    swift_arrayInitWithCopy();
LABEL_30:
    swift_release();
    return (uint64_t)v10;
  }
LABEL_32:
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_100014B9C(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_32;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    sub_100006FC8(&qword_10047D398);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = j__malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 17;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 4);
  }
  else
  {
    uint64_t v10 = (char *)_swiftEmptyArrayStorage;
  }
  uint64_t v13 = v10 + 32;
  unint64_t v14 = a4 + 32;
  if (a1)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8]) {
      memmove(v13, v14, 16 * v8);
    }
    *((void *)a4 + 2) = 0;
    goto LABEL_30;
  }
  if (v14 >= &v13[16 * v8] || v13 >= &v14[16 * v8])
  {
    swift_arrayInitWithCopy();
LABEL_30:
    swift_release();
    return (uint64_t)v10;
  }
LABEL_32:
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_100014D08(char a1, int64_t a2, char a3, void *a4)
{
  if (a3)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_32;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    sub_100006FC8(&qword_10047D3E8);
    uint64_t v10 = (void *)swift_allocObject();
    int64_t v11 = j__malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 17;
    }
    v10[2] = v8;
    v10[3] = 2 * (v12 >> 4);
  }
  else
  {
    uint64_t v10 = _swiftEmptyArrayStorage;
  }
  unint64_t v13 = (unint64_t)(v10 + 4);
  unint64_t v14 = (unint64_t)(a4 + 4);
  if (a1)
  {
    if (v10 != a4 || v13 >= v14 + 16 * v8) {
      memmove(v10 + 4, a4 + 4, 16 * v8);
    }
    a4[2] = 0;
    goto LABEL_30;
  }
  if (v14 >= v13 + 16 * v8 || v13 >= v14 + 16 * v8)
  {
    sub_100006FC8(&qword_10047D3E0);
    swift_arrayInitWithCopy();
LABEL_30:
    swift_release();
    return (uint64_t)v10;
  }
LABEL_32:
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

void sub_100014E94()
{
  uint64_t v1 = *(void **)v0;
  unint64_t v2 = *(void *)(*(void *)v0 + 16);
  if (v2 < 2) {
    return;
  }
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
LABEL_20:
  }
    uint64_t v1 = sub_1000152EC(v1);
  unint64_t v3 = 0;
  uint64_t v4 = v1 + 4;
  while (1)
  {
    swift_stdlib_random();
    uint64_t v6 = (0 * (unsigned __int128)v2) >> 64;
    if (v2)
    {
      if (-(uint64_t)v2 % v2)
      {
        while (1)
          swift_stdlib_random();
      }
    }
    unint64_t v8 = v3 + v6;
    if (__OFADD__(v3, v6))
    {
      __break(1u);
LABEL_18:
      __break(1u);
LABEL_19:
      __break(1u);
      goto LABEL_20;
    }
    if (v3 != v8) {
      break;
    }
LABEL_5:
    ++v3;
    if ((uint64_t)v2-- <= 2) {
      goto LABEL_15;
    }
  }
  unint64_t v9 = v1[2];
  if (v3 >= v9) {
    goto LABEL_18;
  }
  if (v8 >= v9) {
    goto LABEL_19;
  }
  uint64_t v10 = &v4[2 * v3];
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  unint64_t v13 = &v4[2 * v8];
  uint64_t v14 = v13[1];
  uint64_t *v10 = *v13;
  v10[1] = v14;
  unint64_t v15 = v1[2];
  swift_bridgeObjectRetain();
  if (v8 < v15)
  {
    *unint64_t v13 = v11;
    v13[1] = v12;
    swift_bridgeObjectRelease();
    goto LABEL_5;
  }
  __break(1u);
LABEL_15:
  *(void *)uint64_t v0 = v1;
}

void sub_100014FE8()
{
  uint64_t v1 = (void *)*v0;
  unint64_t v2 = *(void *)(*v0 + 16);
  if (v2 < 2) {
    return;
  }
  int64_t v16 = v0;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
LABEL_20:
  }
    uint64_t v1 = sub_100015300(v1);
  unint64_t v3 = 0;
  unint64_t v17 = v1 + 4;
  while (1)
  {
    swift_stdlib_random();
    uint64_t v5 = (0 * (unsigned __int128)v2) >> 64;
    if (v2)
    {
      if (-(uint64_t)v2 % v2)
      {
        while (1)
          swift_stdlib_random();
      }
    }
    unint64_t v7 = v3 + v5;
    if (__OFADD__(v3, v5))
    {
      __break(1u);
LABEL_18:
      __break(1u);
LABEL_19:
      __break(1u);
      goto LABEL_20;
    }
    if (v3 != v7) {
      break;
    }
LABEL_5:
    ++v3;
    if ((uint64_t)v2-- <= 2) {
      goto LABEL_15;
    }
  }
  unint64_t v8 = v1[2];
  if (v3 >= v8) {
    goto LABEL_18;
  }
  if (v7 >= v8) {
    goto LABEL_19;
  }
  unint64_t v9 = &v17[3 * v3];
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  uint64_t v12 = v9[2];
  unint64_t v13 = &v17[3 * v7];
  uint64_t v14 = v13[1];
  *unint64_t v9 = *v13;
  v9[1] = v14;
  v9[2] = v13[2];
  unint64_t v15 = v1[2];
  swift_bridgeObjectRetain();
  if (v7 < v15)
  {
    *unint64_t v13 = v10;
    v13[1] = v11;
    v13[2] = v12;
    swift_bridgeObjectRelease();
    goto LABEL_5;
  }
  __break(1u);
LABEL_15:
  void *v16 = v1;
}

uint64_t sub_100015168(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 56);
  if (v1)
  {
    uint64_t v2 = 0;
    return __clz(__rbit64(v1)) + v2;
  }
  char v5 = *(unsigned char *)(a1 + 32);
  unsigned int v6 = v5 & 0x3F;
  uint64_t v3 = 1 << v5;
  if (v6 < 7) {
    return v3;
  }
  unint64_t v1 = *(void *)(a1 + 64);
  if (v1)
  {
    uint64_t v2 = 64;
    return __clz(__rbit64(v1)) + v2;
  }
  if (v6 < 8) {
    return v3;
  }
  unint64_t v1 = *(void *)(a1 + 72);
  if (v1)
  {
    uint64_t v2 = 128;
    return __clz(__rbit64(v1)) + v2;
  }
  unint64_t v7 = (unint64_t)(v3 + 63) >> 6;
  if (v7 <= 3) {
    unint64_t v7 = 3;
  }
  unint64_t v8 = v7 - 3;
  unint64_t v9 = (unint64_t *)(a1 + 80);
  uint64_t v2 = 128;
  while (v8)
  {
    unint64_t v10 = *v9++;
    unint64_t v1 = v10;
    --v8;
    v2 += 64;
    if (v10) {
      return __clz(__rbit64(v1)) + v2;
    }
  }
  return v3;
}

int64_t sub_100015208(int64_t result, int a2, char a3, uint64_t a4)
{
  if (a3) {
    goto LABEL_20;
  }
  unint64_t v4 = result;
  if (result < 0 || (uint64_t result = 1 << *(unsigned char *)(a4 + 32), result <= (uint64_t)v4))
  {
    __break(1u);
    goto LABEL_18;
  }
  unint64_t v5 = v4 >> 6;
  uint64_t v6 = a4 + 56;
  unint64_t v7 = *(void *)(a4 + 56 + 8 * (v4 >> 6));
  if (((v7 >> v4) & 1) == 0)
  {
LABEL_18:
    __break(1u);
    goto LABEL_19;
  }
  if (*(_DWORD *)(a4 + 36) != a2)
  {
LABEL_19:
    __break(1u);
LABEL_20:
    __break(1u);
    return result;
  }
  unint64_t v8 = v7 & (-2 << (v4 & 0x3F));
  if (v8) {
    return __clz(__rbit64(v8)) | v4 & 0xFFFFFFFFFFFFFFC0;
  }
  unint64_t v9 = v5 + 1;
  unint64_t v10 = (unint64_t)(result + 63) >> 6;
  if (v5 + 1 < v10)
  {
    unint64_t v11 = *(void *)(v6 + 8 * v9);
    if (v11) {
      return __clz(__rbit64(v11)) + (v9 << 6);
    }
    unint64_t v9 = v5 + 2;
    if (v5 + 2 < v10)
    {
      unint64_t v11 = *(void *)(v6 + 8 * v9);
      if (v11) {
        return __clz(__rbit64(v11)) + (v9 << 6);
      }
      while (v10 - 3 != v5)
      {
        unint64_t v11 = *(void *)(a4 + 80 + 8 * v5++);
        if (v11)
        {
          unint64_t v9 = v5 + 2;
          return __clz(__rbit64(v11)) + (v9 << 6);
        }
      }
    }
  }
  return result;
}

void *sub_1000152EC(void *a1)
{
  return sub_10003E1B0(0, a1[2], 0, a1);
}

void *sub_100015300(void *a1)
{
  return sub_10003E2C0(0, a1[2], 0, a1);
}

uint64_t sub_100015314(uint64_t result, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = (void *)result;
  uint64_t v6 = a4 + 56;
  uint64_t v7 = -1 << *(unsigned char *)(a4 + 32);
  if (-v7 < 64) {
    uint64_t v8 = ~(-1 << -(char)v7);
  }
  else {
    uint64_t v8 = -1;
  }
  unint64_t v9 = v8 & *(void *)(a4 + 56);
  if (!a2)
  {
    int64_t v12 = 0;
    uint64_t v10 = 0;
LABEL_38:
    *unint64_t v5 = a4;
    v5[1] = v6;
    v5[2] = ~v7;
    v5[3] = v12;
    v5[4] = v9;
    return v10;
  }
  uint64_t v10 = a3;
  if (!a3)
  {
    int64_t v12 = 0;
    goto LABEL_38;
  }
  if (a3 < 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  unint64_t v11 = a2;
  int64_t v12 = 0;
  uint64_t v13 = 0;
  int64_t v14 = (unint64_t)(63 - v7) >> 6;
  if (!v9) {
    goto LABEL_9;
  }
LABEL_8:
  unint64_t v15 = __clz(__rbit64(v9));
  v9 &= v9 - 1;
  unint64_t v16 = v15 | (v12 << 6);
  while (1)
  {
    ++v13;
    uint64_t v20 = (void *)(*(void *)(a4 + 48) + 16 * v16);
    uint64_t v21 = v20[1];
    void *v11 = *v20;
    v11[1] = v21;
    if (v13 == v10)
    {
      swift_bridgeObjectRetain();
      goto LABEL_38;
    }
    v11 += 2;
    uint64_t result = swift_bridgeObjectRetain();
    if (v9) {
      goto LABEL_8;
    }
LABEL_9:
    int64_t v17 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      goto LABEL_40;
    }
    if (v17 >= v14) {
      goto LABEL_33;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    if (!v18) {
      break;
    }
LABEL_18:
    unint64_t v9 = (v18 - 1) & v18;
    unint64_t v16 = __clz(__rbit64(v18)) + (v17 << 6);
    int64_t v12 = v17;
  }
  v12 += 2;
  if (v17 + 1 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18) {
    goto LABEL_14;
  }
  int64_t v19 = v17 + 2;
  if (v17 + 2 >= v14) {
    goto LABEL_33;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18) {
    goto LABEL_17;
  }
  int64_t v12 = v17 + 3;
  if (v17 + 3 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17 + 2;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18)
  {
LABEL_14:
    int64_t v17 = v12;
    goto LABEL_18;
  }
  int64_t v19 = v17 + 4;
  if (v17 + 4 >= v14)
  {
LABEL_33:
    unint64_t v9 = 0;
LABEL_37:
    uint64_t v10 = v13;
    goto LABEL_38;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18)
  {
LABEL_17:
    int64_t v17 = v19;
    goto LABEL_18;
  }
  while (1)
  {
    int64_t v17 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      break;
    }
    if (v17 >= v14)
    {
      unint64_t v9 = 0;
      int64_t v12 = v14 - 1;
      goto LABEL_37;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    ++v19;
    if (v18) {
      goto LABEL_18;
    }
  }
LABEL_41:
  __break(1u);
  return result;
}

uint64_t sub_100015514(uint64_t result, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = (void *)result;
  uint64_t v6 = a4 + 64;
  uint64_t v7 = -1 << *(unsigned char *)(a4 + 32);
  if (-v7 < 64) {
    uint64_t v8 = ~(-1 << -(char)v7);
  }
  else {
    uint64_t v8 = -1;
  }
  unint64_t v9 = v8 & *(void *)(a4 + 64);
  if (!a2)
  {
    int64_t v12 = 0;
    uint64_t v10 = 0;
LABEL_38:
    *unint64_t v5 = a4;
    v5[1] = v6;
    v5[2] = ~v7;
    v5[3] = v12;
    v5[4] = v9;
    return v10;
  }
  uint64_t v10 = a3;
  if (!a3)
  {
    int64_t v12 = 0;
    goto LABEL_38;
  }
  if (a3 < 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  unint64_t v11 = a2;
  int64_t v12 = 0;
  uint64_t v13 = 0;
  int64_t v14 = (unint64_t)(63 - v7) >> 6;
  if (!v9) {
    goto LABEL_9;
  }
LABEL_8:
  unint64_t v15 = __clz(__rbit64(v9));
  v9 &= v9 - 1;
  unint64_t v16 = v15 | (v12 << 6);
  while (1)
  {
    ++v13;
    uint64_t v20 = (void *)(*(void *)(a4 + 48) + 16 * v16);
    uint64_t v21 = v20[1];
    void *v11 = *v20;
    v11[1] = v21;
    if (v13 == v10)
    {
      swift_bridgeObjectRetain();
      goto LABEL_38;
    }
    v11 += 2;
    uint64_t result = swift_bridgeObjectRetain();
    if (v9) {
      goto LABEL_8;
    }
LABEL_9:
    int64_t v17 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      goto LABEL_40;
    }
    if (v17 >= v14) {
      goto LABEL_33;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    if (!v18) {
      break;
    }
LABEL_18:
    unint64_t v9 = (v18 - 1) & v18;
    unint64_t v16 = __clz(__rbit64(v18)) + (v17 << 6);
    int64_t v12 = v17;
  }
  v12 += 2;
  if (v17 + 1 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18) {
    goto LABEL_14;
  }
  int64_t v19 = v17 + 2;
  if (v17 + 2 >= v14) {
    goto LABEL_33;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18) {
    goto LABEL_17;
  }
  int64_t v12 = v17 + 3;
  if (v17 + 3 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17 + 2;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18)
  {
LABEL_14:
    int64_t v17 = v12;
    goto LABEL_18;
  }
  int64_t v19 = v17 + 4;
  if (v17 + 4 >= v14)
  {
LABEL_33:
    unint64_t v9 = 0;
LABEL_37:
    uint64_t v10 = v13;
    goto LABEL_38;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18)
  {
LABEL_17:
    int64_t v17 = v19;
    goto LABEL_18;
  }
  while (1)
  {
    int64_t v17 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      break;
    }
    if (v17 >= v14)
    {
      unint64_t v9 = 0;
      int64_t v12 = v14 - 1;
      goto LABEL_37;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    ++v19;
    if (v18) {
      goto LABEL_18;
    }
  }
LABEL_41:
  __break(1u);
  return result;
}

void *sub_100015718(void *result, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = result;
  uint64_t v6 = a4 + 64;
  uint64_t v7 = -1 << *(unsigned char *)(a4 + 32);
  if (-v7 < 64) {
    uint64_t v8 = ~(-1 << -(char)v7);
  }
  else {
    uint64_t v8 = -1;
  }
  unint64_t v9 = v8 & *(void *)(a4 + 64);
  if (!a2)
  {
    int64_t v12 = 0;
    uint64_t v10 = 0;
LABEL_38:
    *unint64_t v5 = a4;
    v5[1] = v6;
    v5[2] = ~v7;
    v5[3] = v12;
    v5[4] = v9;
    return (void *)v10;
  }
  uint64_t v10 = a3;
  if (!a3)
  {
    int64_t v12 = 0;
    goto LABEL_38;
  }
  if (a3 < 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  unint64_t v11 = a2;
  int64_t v12 = 0;
  uint64_t v13 = 0;
  int64_t v14 = (unint64_t)(63 - v7) >> 6;
  if (!v9) {
    goto LABEL_9;
  }
LABEL_8:
  unint64_t v15 = __clz(__rbit64(v9));
  v9 &= v9 - 1;
  unint64_t v16 = v15 | (v12 << 6);
  while (1)
  {
    ++v13;
    uint64_t v20 = *(void **)(*(void *)(a4 + 56) + 8 * v16);
    void *v11 = v20;
    if (v13 == v10)
    {
      id v21 = v20;
      goto LABEL_38;
    }
    ++v11;
    uint64_t result = v20;
    if (v9) {
      goto LABEL_8;
    }
LABEL_9:
    int64_t v17 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      goto LABEL_40;
    }
    if (v17 >= v14) {
      goto LABEL_33;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    if (!v18) {
      break;
    }
LABEL_18:
    unint64_t v9 = (v18 - 1) & v18;
    unint64_t v16 = __clz(__rbit64(v18)) + (v17 << 6);
    int64_t v12 = v17;
  }
  v12 += 2;
  if (v17 + 1 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18) {
    goto LABEL_14;
  }
  int64_t v19 = v17 + 2;
  if (v17 + 2 >= v14) {
    goto LABEL_33;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18) {
    goto LABEL_17;
  }
  int64_t v12 = v17 + 3;
  if (v17 + 3 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17 + 2;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18)
  {
LABEL_14:
    int64_t v17 = v12;
    goto LABEL_18;
  }
  int64_t v19 = v17 + 4;
  if (v17 + 4 >= v14)
  {
LABEL_33:
    unint64_t v9 = 0;
LABEL_37:
    uint64_t v10 = v13;
    goto LABEL_38;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18)
  {
LABEL_17:
    int64_t v17 = v19;
    goto LABEL_18;
  }
  while (1)
  {
    int64_t v17 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      break;
    }
    if (v17 >= v14)
    {
      unint64_t v9 = 0;
      int64_t v12 = v14 - 1;
      goto LABEL_37;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    ++v19;
    if (v18) {
      goto LABEL_18;
    }
  }
LABEL_41:
  __break(1u);
  return result;
}

uint64_t sub_100015914(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = Set.init(minimumCapacity:)();
  uint64_t v8 = result;
  if (v2)
  {
    unint64_t v4 = (Swift::Int *)(a1 + 40);
    do
    {
      Swift::Int v5 = *(v4 - 1);
      Swift::Int v6 = *v4;
      swift_bridgeObjectRetain();
      sub_10001324C(&v7, v5, v6);
      swift_bridgeObjectRelease();
      v4 += 2;
      --v2;
    }
    while (v2);
    return v8;
  }
  return result;
}

id sub_1000159AC(void *a1)
{
  return sub_1000106D8(a1, *(void *)(v1 + 16));
}

void sub_1000159C8(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1000159E0@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  return sub_100016BD4(a1, a2, a3);
}

id sub_1000159FC(void *a1)
{
  return sub_100016B08(a1);
}

id sub_100015A14(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine;
  sub_100006FC8(&qword_10047E260);
  uint64_t v12 = swift_allocObject();
  type metadata accessor for MBUnfairLock();
  uint64_t v13 = swift_allocObject();
  int64_t v14 = v5;
  unint64_t v15 = (_DWORD *)swift_slowAlloc();
  *(void *)(v13 + 16) = v15;
  *unint64_t v15 = 0;
  *(void *)(v12 + 16) = v13;
  *(void *)(v12 + 24) = 0;
  *(void *)&v5[v11] = v12;
  *(void *)&v14[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__context] = a1;
  *(void *)&v14[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__restorePath] = a2;
  *(void *)&v14[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__domain] = a3;
  unint64_t v16 = &v14[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engineCreationBlock];
  *(void *)unint64_t v16 = a4;
  *((void *)v16 + 1) = a5;
  swift_retain();
  id v17 = a3;
  swift_retain();
  id v18 = a1;

  v20.receiver = v14;
  v20.super_class = (Class)type metadata accessor for _DryRestoreDomainOperation();
  return objc_msgSendSuper2(&v20, "init");
}

void *sub_100015B38(uint64_t a1, unsigned char *a2, void *a3, char a4, uint64_t (*a5)(void *))
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t result = _swiftEmptyArrayStorage;
  if (v7)
  {
    unint64_t v24 = _swiftEmptyArrayStorage;
    specialized ContiguousArray.reserveCapacity(_:)();
    uint64_t result = (void *)sub_100015168(a1);
    int64_t v10 = (int64_t)result;
    int v12 = v11;
    char v14 = v13 & 1;
    while ((v10 & 0x8000000000000000) == 0 && v10 < 1 << *(unsigned char *)(a1 + 32))
    {
      if (((*(void *)(a1 + 56 + (((unint64_t)v10 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v10) & 1) == 0) {
        goto LABEL_13;
      }
      if (*(_DWORD *)(a1 + 36) != v12) {
        goto LABEL_14;
      }
      unint64_t v15 = (uint64_t *)(*(void *)(a1 + 48) + 16 * v10);
      uint64_t v16 = v15[1];
      v22[1] = *v15;
      void v22[2] = v16;
      swift_bridgeObjectRetain();
      sub_100011140(a2, a3, a4 & 1, a5, v22, &v23);
      swift_bridgeObjectRelease();
      if (v5) {
        return (void *)swift_release();
      }
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
      specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
      specialized ContiguousArray._endMutation()();
      uint64_t result = (void *)sub_100015208(v10, v12, v14 & 1, a1);
      int64_t v10 = (int64_t)result;
      int v12 = v17;
      char v14 = v18 & 1;
      if (!--v7)
      {
        sub_100016A9C((uint64_t)result, v17, v18 & 1);
        return v24;
      }
    }
    __break(1u);
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
  }
  return result;
}

void *sub_100015CE0(unint64_t a1, void *a2, void *a3, char *a4)
{
  unint64_t v4 = a4;
  unint64_t v5 = a1;
  if (a1 >> 62) {
    goto LABEL_13;
  }
  uint64_t v6 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  uint64_t v7 = a4;
  if (v6)
  {
    while (1)
    {
      id v44 = _swiftEmptyArrayStorage;
      uint64_t result = (void *)specialized ContiguousArray.reserveCapacity(_:)();
      if (v6 < 0) {
        break;
      }
      uint64_t v9 = 0;
      uint64_t v36 = *(void *)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context];
      unint64_t v37 = v5 & 0xC000000000000001;
      uint64_t v34 = v4;
      uint64_t v35 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath;
      uint64_t v32 = v6;
      unint64_t v33 = v5;
      while (v6 != v9)
      {
        if (v37)
        {
          int64_t v10 = (void *)specialized _ArrayBuffer._getElementSlowPath(_:)();
        }
        else
        {
          int64_t v10 = *(void **)(v5 + 8 * v9 + 32);
          swift_unknownObjectRetain();
        }
        uint64_t v42 = v4;
        id v11 = [v10 domain];
        unint64_t v12 = *(void *)(v36 + v35);
        swift_retain();
        unint64_t v13 = sub_10002D538(0x756F726765726F46, 0xEA0000000000646ELL, v12);
        swift_release();
        uint64_t result = [v11 rootPath];
        if (!result) {
          goto LABEL_17;
        }
        char v14 = result;
        uint64_t v15 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v17 = v16;

        unint64_t v18 = sub_10002D538(v15, v17, v13);
        swift_bridgeObjectRelease();
        swift_release();
        int64_t v19 = (id (*)(void *))swift_allocObject();
        *((void *)v19 + 2) = a2;
        *((void *)v19 + 3) = a3;
        *((void *)v19 + 4) = v18;
        *((void *)v19 + 5) = v10;
        id v41 = (objc_class *)type metadata accessor for _DryRestoreDomainOperation();
        objc_super v20 = (char *)objc_allocWithZone(v41);
        uint64_t v40 = OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine;
        sub_100006FC8(&qword_10047E260);
        uint64_t v21 = swift_allocObject();
        type metadata accessor for MBUnfairLock();
        uint64_t v22 = swift_allocObject();
        swift_retain();
        swift_unknownObjectRetain();
        uint64_t v23 = v20;
        id v24 = a2;
        id v31 = a3;
        char v25 = (_DWORD *)swift_slowAlloc();
        *(void *)(v22 + 16) = v25;
        *char v25 = 0;
        *(void *)(v21 + 16) = v22;
        *(void *)(v21 + 24) = 0;
        *(void *)&v20[v40] = v21;
        *(void *)&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__context] = v24;
        *(void *)&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__restorePath] = v18;
        *(void *)&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__domain] = v11;
        unint64_t v26 = (id (**)(void *))&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engineCreationBlock];
        char *v26 = sub_100017A40;
        v26[1] = v19;
        id v27 = v24;
        swift_retain();
        id v28 = v11;
        swift_retain();

        v43.receiver = v23;
        v43.super_class = v41;
        objc_msgSendSuper2(&v43, "init");
        swift_unknownObjectRelease();

        ++v9;
        swift_release();

        swift_release();
        specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
        specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
        specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
        specialized ContiguousArray._endMutation()();
        uint64_t v6 = v32;
        unint64_t v5 = v33;
        unint64_t v4 = v34;
        if (v32 == v9)
        {
          int64_t v29 = v44;

          return v29;
        }
      }
      __break(1u);
LABEL_13:
      unint64_t v30 = v4;
      swift_bridgeObjectRetain();
      uint64_t v6 = _CocoaArrayWrapper.endIndex.getter();
      swift_bridgeObjectRelease();
      if (!v6) {
        goto LABEL_14;
      }
    }
    __break(1u);
LABEL_17:
    __break(1u);
  }
  else
  {
LABEL_14:

    return _swiftEmptyArrayStorage;
  }
  return result;
}

void *sub_1000160C8(unint64_t a1, void *a2, void *a3, char *a4)
{
  unint64_t v4 = a4;
  unint64_t v5 = a1;
  if (a1 >> 62) {
    goto LABEL_12;
  }
  uint64_t v6 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  uint64_t v7 = a4;
  if (v6)
  {
    while (1)
    {
      objc_super v43 = _swiftEmptyArrayStorage;
      uint64_t result = (void *)specialized ContiguousArray.reserveCapacity(_:)();
      if (v6 < 0) {
        break;
      }
      uint64_t v9 = 0;
      uint64_t v31 = *(void *)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context];
      unint64_t v32 = v5 & 0xC000000000000001;
      int64_t v29 = v4;
      uint64_t v30 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath;
      uint64_t v33 = v6;
      unint64_t v34 = v5;
      while (v6 != v9)
      {
        if (v32)
        {
          int64_t v10 = (void *)specialized _ArrayBuffer._getElementSlowPath(_:)();
        }
        else
        {
          int64_t v10 = *(void **)(v5 + 8 * v9 + 32);
          swift_unknownObjectRetain();
        }
        uint64_t v41 = v9 + 1;
        id v40 = v29;
        id v39 = [v10 domain];
        unint64_t v11 = *(void *)(v31 + v30);
        swift_retain();
        id v12 = [v39 name];
        uint64_t v13 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v15 = v14;

        unint64_t v16 = sub_10002D538(v13, v15, v11);
        swift_release();
        swift_bridgeObjectRelease();
        uint64_t v17 = (id (*)(void *))swift_allocObject();
        *((void *)v17 + 2) = a2;
        *((void *)v17 + 3) = a3;
        *((void *)v17 + 4) = v16;
        *((void *)v17 + 5) = v10;
        uint64_t v38 = (objc_class *)type metadata accessor for _DryRestoreDomainOperation();
        unint64_t v18 = (char *)objc_allocWithZone(v38);
        uint64_t v37 = OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine;
        sub_100006FC8(&qword_10047E260);
        uint64_t v19 = swift_allocObject();
        type metadata accessor for MBUnfairLock();
        uint64_t v20 = swift_allocObject();
        swift_retain();
        swift_unknownObjectRetain();
        uint64_t v21 = v18;
        id v22 = a2;
        id v23 = a3;
        id v24 = (_DWORD *)swift_slowAlloc();
        *(void *)(v20 + 16) = v24;
        *id v24 = 0;
        *(void *)(v19 + 16) = v20;
        *(void *)(v19 + 24) = 0;
        *(void *)&v18[v37] = v19;
        *(void *)&v21[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__context] = v22;
        *(void *)&v21[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__restorePath] = v16;
        *(void *)&v21[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__domain] = v39;
        char v25 = (id (**)(void *))&v21[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engineCreationBlock];
        *char v25 = sub_100017A40;
        v25[1] = v17;
        unint64_t v4 = (char *)v22;
        swift_retain();
        id v26 = v39;
        swift_retain();

        v42.receiver = v21;
        v42.super_class = v38;
        objc_msgSendSuper2(&v42, "init");
        swift_unknownObjectRelease();

        swift_release();
        swift_release();
        specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
        specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
        specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
        specialized ContiguousArray._endMutation()();
        uint64_t v9 = v41;
        uint64_t v6 = v33;
        unint64_t v5 = v34;
        if (v33 == v41)
        {
          id v27 = v43;

          return v27;
        }
      }
      __break(1u);
LABEL_12:
      id v28 = v4;
      swift_bridgeObjectRetain();
      uint64_t v6 = _CocoaArrayWrapper.endIndex.getter();
      swift_bridgeObjectRelease();
      if (!v6) {
        goto LABEL_13;
      }
    }
    __break(1u);
  }
  else
  {
LABEL_13:

    return _swiftEmptyArrayStorage;
  }
  return result;
}

void *sub_100016480(unint64_t a1, void *a2, void *a3, char *a4)
{
  unint64_t v4 = a4;
  unint64_t v5 = a1;
  if (a1 >> 62) {
    goto LABEL_12;
  }
  uint64_t v6 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  uint64_t v7 = a4;
  if (v6)
  {
    while (1)
    {
      id v45 = _swiftEmptyArrayStorage;
      uint64_t result = (void *)specialized ContiguousArray.reserveCapacity(_:)();
      if (v6 < 0) {
        break;
      }
      uint64_t v9 = 0;
      uint64_t v33 = *(void *)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context];
      unint64_t v34 = v5 & 0xC000000000000001;
      uint64_t v31 = v4;
      uint64_t v32 = OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath;
      uint64_t v35 = v6;
      unint64_t v36 = v5;
      while (v6 != v9)
      {
        if (v34)
        {
          int64_t v10 = (void *)specialized _ArrayBuffer._getElementSlowPath(_:)();
        }
        else
        {
          int64_t v10 = *(void **)(v5 + 8 * v9 + 32);
          swift_unknownObjectRetain();
        }
        uint64_t v43 = v9 + 1;
        id v42 = v31;
        id v41 = [v10 domain];
        unint64_t v11 = *(void *)(v33 + v32);
        id v12 = v10;
        swift_retain();
        unint64_t v13 = sub_10002D538(4412481, 0xE300000000000000, v11);
        swift_release();
        id v14 = [v41 name];
        uint64_t v15 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v17 = v16;

        unint64_t v18 = sub_10002D538(v15, v17, v13);
        swift_bridgeObjectRelease();
        swift_release();
        uint64_t v19 = (id (*)(void *))swift_allocObject();
        *((void *)v19 + 2) = a2;
        *((void *)v19 + 3) = a3;
        *((void *)v19 + 4) = v18;
        *((void *)v19 + 5) = v12;
        id v40 = (objc_class *)type metadata accessor for _DryRestoreDomainOperation();
        uint64_t v20 = (char *)objc_allocWithZone(v40);
        uint64_t v39 = OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine;
        sub_100006FC8(&qword_10047E260);
        uint64_t v21 = swift_allocObject();
        type metadata accessor for MBUnfairLock();
        uint64_t v22 = swift_allocObject();
        swift_retain();
        swift_unknownObjectRetain();
        id v23 = v20;
        id v24 = a2;
        id v25 = a3;
        id v26 = (_DWORD *)swift_slowAlloc();
        *(void *)(v22 + 16) = v26;
        _DWORD *v26 = 0;
        *(void *)(v21 + 16) = v22;
        *(void *)(v21 + 24) = 0;
        *(void *)&v20[v39] = v21;
        *(void *)&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__context] = v24;
        *(void *)&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__restorePath] = v18;
        *(void *)&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__domain] = v41;
        id v27 = (id (**)(void *))&v23[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engineCreationBlock];
        *id v27 = sub_100016BB0;
        v27[1] = v19;
        unint64_t v4 = (char *)v24;
        swift_retain();
        id v28 = v41;
        swift_retain();

        v44.receiver = v23;
        v44.super_class = v40;
        objc_msgSendSuper2(&v44, "init");
        swift_unknownObjectRelease();

        swift_release();
        swift_release();
        specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
        specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
        specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
        specialized ContiguousArray._endMutation()();
        uint64_t v9 = v43;
        uint64_t v6 = v35;
        unint64_t v5 = v36;
        if (v35 == v43)
        {
          int64_t v29 = v45;

          return v29;
        }
      }
      __break(1u);
LABEL_12:
      uint64_t v30 = v4;
      swift_bridgeObjectRetain();
      uint64_t v6 = _CocoaArrayWrapper.endIndex.getter();
      swift_bridgeObjectRelease();
      if (!v6) {
        goto LABEL_13;
      }
    }
    __break(1u);
  }
  else
  {
LABEL_13:

    return _swiftEmptyArrayStorage;
  }
  return result;
}

void sub_100016854(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    specialized ContiguousArray.reserveCapacity(_:)();
    unint64_t v5 = *(void **)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__domainManager);
    uint64_t v6 = a1 + 40;
    while (1)
    {
      swift_bridgeObjectRetain();
      NSString v7 = String._bridgeToObjectiveC()();
      id v8 = [v5 domainForName:v7];

      if (!v8) {
        break;
      }
      v6 += 16;
      swift_bridgeObjectRelease();
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
      specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
      specialized ContiguousArray._endMutation()();
      if (!--v3) {
        return;
      }
    }
    __break(1u);
  }
}

id sub_100016964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  NSString v15 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v21 = 0;
  id v16 = [v9 initWithRootPath:v15 policy:a3 depot:a4 fetcher:a5 plan:a6 progress:a7 verifier:a8 logger:a9 error:&v21];

  if (v16)
  {
    id v17 = v21;
  }
  else
  {
    id v18 = v21;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
  return v16;
}

unint64_t sub_100016A80(void *a1)
{
  return sub_100010B1C(a1, *(void *)(v1 + 16));
}

uint64_t sub_100016A9C(uint64_t a1, uint64_t a2, char a3)
{
  if (a3) {
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_100016AAC()
{
  swift_release();
  swift_unknownObjectRelease();

  return _swift_deallocObject(v0, 56, 7);
}

id sub_100016B08(void *a1)
{
  return sub_1000116E4(a1, *(void *)(v1 + 16), *(void *)(v1 + 24), *(void **)(v1 + 32), *(void *)(v1 + 40), *(void **)(v1 + 48));
}

unint64_t sub_100016B2C()
{
  unint64_t result = qword_10047D388;
  if (!qword_10047D388)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_10047D388);
  }
  return result;
}

void sub_100016B6C(uint64_t a1, uint64_t a2)
{
  sub_100011E98(a1, a2, *(void *)(v2 + 16));
}

uint64_t sub_100016B74()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100016B84()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

id sub_100016BB0(void *a1)
{
  return sub_100011F54(a1, *(unsigned char **)(v1 + 16), *(void **)(v1 + 24), *(void *)(v1 + 32), *(void **)(v1 + 40));
}

uint64_t sub_100016BD4@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  return sub_100010F60(a1, *(uint64_t (**)(void))(v3 + 16), *(void **)(v3 + 32), *(void **)(v3 + 40), *(void **)(v3 + 48), *(void **)(v3 + 56), a2, a3);
}

uint64_t sub_100016BFC()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100016C10()
{
  swift_release();
  return _swift_deallocObject(v0, 48, 7);
}

id sub_100016C64()
{
  return sub_100010DE0(*(void **)(v0 + 16), *(void *)(v0 + 24), *(void *)(v0 + 32), *(void *)(v0 + 40));
}

uint64_t sub_100016C70()
{
  return swift_release();
}

_OWORD *sub_100016C78(_OWORD *a1, _OWORD *a2)
{
  long long v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

uint64_t sub_100016C88()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100016C9C()
{
  swift_release();
  swift_unknownObjectRelease();
  return _swift_deallocObject(v0, 48, 7);
}

unint64_t sub_100016CF0()
{
  unint64_t result = qword_10047D3D0;
  if (!qword_10047D3D0)
  {
    sub_10000BAC4(&qword_10047D3C8);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D3D0);
  }
  return result;
}

id sub_100016D4C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for FilePath();
  uint64_t v80 = *(void *)(v8 - 8);
  uint64_t v81 = v8;
  uint64_t v9 = __chkstk_darwin(v8);
  unint64_t v11 = (char *)&v77 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = __chkstk_darwin(v9);
  id v14 = (char *)&v77 - v13;
  uint64_t v15 = __chkstk_darwin(v12);
  id v78 = (char *)&v77 - v16;
  uint64_t v17 = __chkstk_darwin(v15);
  unint64_t v82 = (char *)&v77 - v18;
  __chkstk_darwin(v17);
  v79 = (char *)&v77 - v19;
  uint64_t v77 = v4;
  uint64_t v20 = *(void **)(v4 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona);
  NSString v21 = [v20 volumeMountPoint];
  if (v21)
  {
    if (a4) {
      goto LABEL_3;
    }
LABEL_9:
    if (a1 == 0xD000000000000012 && a2 == (void *)0x80000001003049F0
      || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
    {
      sub_100045F18(0xD00000000000001DLL, 0x8000000100304A10, 0xD000000000000016, 0x80000001003047B0);
      id v39 = [v20 skippedFileRecordsPlistPath];
      static String._unconditionallyBridgeFromObjectiveC(_:)();

      id v40 = v82;
      FilePath.init(_:)();
      uint64_t v42 = v80;
      uint64_t v41 = v81;
      (*(void (**)(char *, char *, uint64_t))(v80 + 16))(v11, v40, v81);
      FilePath.removingLastComponent()();
      uint64_t v43 = self;
      FilePath.string.getter();
      NSString v44 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v36 = [v43 skippedFilesDomainWithVolumeMountPoint:v21 rootPath:v44];

      Class isa = Set._bridgeToObjectiveC()().super.isa;
      [v36 setRelativePathsToBackupAndRestore:isa];

      sub_100015914((uint64_t)&off_10040F0C0);
      swift_arrayDestroy();
      Class v46 = Set._bridgeToObjectiveC()().super.isa;
      swift_bridgeObjectRelease();
      [v36 setRelativePathsToRestoreOnly:v46];

      uint64_t v47 = *(void (**)(char *, uint64_t))(v42 + 8);
      v47(v14, v41);
      v47(v82, v41);
      return v36;
    }

    return 0;
  }
  static String._unconditionallyBridgeFromObjectiveC(_:)();
  NSString v21 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  if (!a4) {
    goto LABEL_9;
  }
LABEL_3:

  uint64_t v22 = self;
  NSString v23 = String._bridgeToObjectiveC()();
  unsigned __int8 v24 = [v22 isAppPlaceholderName:v23];

  if (v24) {
    return 0;
  }
  NSString v25 = String._bridgeToObjectiveC()();
  unsigned int v26 = [v22 isSystemContainerName:v25];

  if (v26)
  {
    id v27 = [v20 systemDataContainerRestoreDirectory];
    static String._unconditionallyBridgeFromObjectiveC(_:)();

    FilePath.init(_:)();
    swift_bridgeObjectRetain();
    id v28 = v79;
    FilePath.appending(_:)();
    uint64_t v83 = 0;
    unint64_t v84 = 0xE000000000000000;
    _StringGuts.grow(_:)(45);
    swift_bridgeObjectRelease();
    uint64_t v83 = 0xD000000000000025;
    unint64_t v84 = 0x8000000100304AC0;
    v29._countAndFlagsBits = a1;
    v29._object = a2;
    String.append(_:)(v29);
    v30._countAndFlagsBits = 544497952;
    v30._object = (void *)0xE400000000000000;
    String.append(_:)(v30);
    sub_1000179D0((unint64_t *)&qword_10047D3F0, (void (*)(uint64_t))&type metadata accessor for FilePath);
    uint64_t v31 = v81;
    v32._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v32);
    swift_bridgeObjectRelease();
    sub_100045F18(v83, v84, 0xD000000000000016, 0x80000001003047B0);
    swift_bridgeObjectRelease();
    NSString v33 = String._bridgeToObjectiveC()();
    NSString v34 = [v20 systemContainersVolumeMountPoint];
    if (!v34)
    {
      static String._unconditionallyBridgeFromObjectiveC(_:)();
      NSString v34 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
    }
    FilePath.string.getter();
    NSString v35 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v36 = [v22 systemContainerDomainWithIdentifier:v33 volumeMountPoint:v34 rootPath:v35];

    Class v37 = Set._bridgeToObjectiveC()().super.isa;
    [v36 setRelativePathsToBackupAndRestore:v37];

    sub_100015914((uint64_t)&off_10040F030);
    swift_arrayDestroy();
    v38.super.Class isa = Set._bridgeToObjectiveC()().super.isa;
LABEL_17:
    swift_bridgeObjectRelease();
    [v36 setRelativePathsToRestoreOnly:v38.super.isa];

    (*(void (**)(char *, uint64_t))(v80 + 8))(v28, v31);
    return v36;
  }
  NSString v48 = String._bridgeToObjectiveC()();
  unsigned int v49 = [v22 isSystemSharedContainerName:v48];

  if (v49)
  {
    uint64_t v50 = v22;
    id v51 = [v20 systemSharedDataContainerRestoreDirectory];
    static String._unconditionallyBridgeFromObjectiveC(_:)();

    FilePath.init(_:)();
    swift_bridgeObjectRetain();
    id v28 = v78;
    FilePath.appending(_:)();
    uint64_t v83 = 0;
    unint64_t v84 = 0xE000000000000000;
    _StringGuts.grow(_:)(52);
    v52._countAndFlagsBits = 0xD00000000000002CLL;
    v52._object = (void *)0x8000000100304A90;
    String.append(_:)(v52);
    v53._countAndFlagsBits = a1;
    v53._object = a2;
    String.append(_:)(v53);
    v54._countAndFlagsBits = 544497952;
    v54._object = (void *)0xE400000000000000;
    String.append(_:)(v54);
    sub_1000179D0((unint64_t *)&qword_10047D3F0, (void (*)(uint64_t))&type metadata accessor for FilePath);
    uint64_t v31 = v81;
    v55._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v55);
    swift_bridgeObjectRelease();
    sub_100045F18(v83, v84, 0xD000000000000016, 0x80000001003047B0);
    swift_bridgeObjectRelease();
    NSString v56 = String._bridgeToObjectiveC()();
    NSString v57 = [v20 systemContainersVolumeMountPoint];
    if (!v57)
    {
      static String._unconditionallyBridgeFromObjectiveC(_:)();
      NSString v57 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
    }
    FilePath.string.getter();
    NSString v58 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v36 = [v50 systemSharedContainerDomainWithIdentifier:v56 volumeMountPoint:v57 rootPath:v58];

    Class v59 = Set._bridgeToObjectiveC()().super.isa;
    [v36 setRelativePathsToBackupAndRestore:v59];

    sub_100015914((uint64_t)&off_10040F060);
    swift_arrayDestroy();
    v38.super.Class isa = Set._bridgeToObjectiveC()().super.isa;
    goto LABEL_17;
  }
  uint64_t v61 = v77;
  Class v62 = *(void **)(v77 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext__appManager);
  NSString v63 = String._bridgeToObjectiveC()();
  Class v64 = (Class)[v62 containerWithIdentifier:v63];

  if (v64)
  {
    uint64_t v83 = 0;
    unint64_t v84 = 0xE000000000000000;
    _StringGuts.grow(_:)(32);
    swift_bridgeObjectRelease();
    uint64_t v83 = 0xD00000000000001ELL;
    unint64_t v84 = 0x8000000100304A70;
    v65._countAndFlagsBits = a1;
    v65._object = a2;
    String.append(_:)(v65);
    sub_100045F18(v83, v84, 0xD000000000000016, 0x80000001003047B0);
    swift_bridgeObjectRelease();
    id v36 = [(objc_class *)v64 domain];
  }
  else
  {
    unint64_t v66 = *(void *)(v61 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath);
    unint64_t v67 = sub_10002D538(a1, (uint64_t)a2, v66);
    sub_10002D270(v67);
    id v68 = v22;
    swift_release();
    uint64_t v83 = 0;
    unint64_t v84 = 0xE000000000000000;
    _StringGuts.grow(_:)(71);
    v69._countAndFlagsBits = 0xD00000000000003FLL;
    v69._object = (void *)0x8000000100304A30;
    String.append(_:)(v69);
    v70._countAndFlagsBits = a1;
    v70._object = a2;
    String.append(_:)(v70);
    v71._countAndFlagsBits = 544497952;
    v71._object = (void *)0xE400000000000000;
    String.append(_:)(v71);
    swift_retain();
    v72._countAndFlagsBits = sub_10002D874(v66);
    String.append(_:)(v72);
    swift_release();
    swift_bridgeObjectRelease();
    sub_100045F18(v83, v84, 0xD000000000000016, 0x80000001003047B0);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    NSString v73 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    NSString v74 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    NSString v75 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v36 = [v68 domainForTestingWithName:v73 volumeMountPoint:v74 rootPath:v75];

    Class v76 = Set._bridgeToObjectiveC()().super.isa;
    [v36 setRelativePathsToBackupAndRestore:v76];

    sub_100015914((uint64_t)&off_10040F090);
    swift_arrayDestroy();
    Class v64 = Set._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    [v36 setRelativePathsToRestoreOnly:v64];
  }

  return v36;
}

uint64_t sub_1000179D0(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

id sub_100017A40(void *a1)
{
  return sub_100016BB0(a1);
}

uint64_t sub_100017A6C@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = type metadata accessor for FilePath();
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = __chkstk_darwin(v6);
  uint64_t v10 = &v35[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v11 = __chkstk_darwin(v8);
  uint64_t v13 = &v35[-v12];
  __chkstk_darwin(v11);
  uint64_t v15 = &v35[-v14];
  if (!(a1 >> 62))
  {
    uint64_t v20 = swift_projectBox();
    NSString v21 = *(void (**)(unsigned char *, uint64_t, uint64_t))(v7 + 16);
    v21(v15, v20, v6);
    v21(v13, (uint64_t)v15, v6);
    sub_1000180FC((uint64_t)v13, (uint64_t)v44);
    if (v2)
    {
      (*(void (**)(unsigned char *, uint64_t))(v7 + 8))(v15, v6);
      return swift_release();
    }
    uint64_t v24 = v44[0];
    uint64_t v25 = v44[1];
    uint64_t v43 = v44[2];
    uint64_t v62 = v44[3];
    uint64_t v40 = v44[4];
    uint64_t v41 = v44[5];
    uint64_t v42 = v44[6];
    int v38 = v45;
    uint64_t v39 = v46;
    __int16 v26 = v47;
    char v32 = v48;
    char v31 = v49;
    (*(void (**)(unsigned char *, uint64_t))(v7 + 8))(v15, v6);
    char v29 = v32;
    uint64_t v30 = v40;
    uint64_t v28 = v39;
    int v27 = v38;
    goto LABEL_12;
  }
  if (a1 >> 62 != 1)
  {
    uint64_t v22 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
    swift_retain();
    sub_100017A6C(v56, v22);
    if (v3) {
      return swift_release();
    }
    uint64_t v24 = v56[0];
    uint64_t v25 = v56[1];
    uint64_t v43 = v56[2];
    uint64_t v30 = v56[4];
    uint64_t v62 = v56[3];
    uint64_t v41 = v56[5];
    uint64_t v42 = v56[6];
    int v27 = v57;
    uint64_t v28 = v58;
    __int16 v26 = v59;
    char v29 = v60;
    char v31 = v61;
LABEL_12:
    uint64_t result = swift_release();
    goto LABEL_13;
  }
  uint64_t v16 = sub_100006FC8(&qword_10047CFF0);
  uint64_t v17 = (void **)swift_projectBox();
  uint64_t v18 = *v17;
  (*(void (**)(unsigned char *, char *, uint64_t))(v7 + 16))(v10, (char *)v17 + *(int *)(v16 + 64), v6);
  id v19 = v18;
  FilePath.string.getter();
  sub_100018270(v19, (uint64_t)v50);
  if (v2)
  {

    swift_bridgeObjectRelease();
    (*(void (**)(unsigned char *, uint64_t))(v7 + 8))(v10, v6);
    return swift_release();
  }
  uint64_t v24 = v50[0];
  uint64_t v25 = v50[1];
  uint64_t v43 = v50[2];
  uint64_t v62 = v50[3];
  uint64_t v40 = v50[4];
  uint64_t v41 = v50[5];
  uint64_t v42 = v50[6];
  int v38 = v51;
  uint64_t v39 = v52;
  __int16 v26 = v53;
  int v36 = v54;
  int v37 = v55;

  int v27 = v38;
  swift_bridgeObjectRelease();
  uint64_t v28 = v39;
  (*(void (**)(unsigned char *, uint64_t))(v7 + 8))(v10, v6);
  char v29 = v36;
  uint64_t v30 = v40;
  uint64_t result = swift_release();
  char v31 = v37;
LABEL_13:
  *(void *)a2 = v24;
  *(void *)(a2 + 8) = v25;
  uint64_t v33 = v62;
  *(void *)(a2 + 16) = v43;
  *(void *)(a2 + 24) = v33;
  uint64_t v34 = v41;
  *(void *)(a2 + 32) = v30;
  *(void *)(a2 + 40) = v34;
  *(void *)(a2 + 48) = v42;
  *(_DWORD *)(a2 + 56) = v27;
  *(void *)(a2 + 60) = v28;
  *(_WORD *)(a2 + 68) = v26;
  *(unsigned char *)(a2 + 70) = v29;
  *(unsigned char *)(a2 + 71) = v31;
  return result;
}

uint64_t MBNode.description.getter()
{
  long long v1 = *(_OWORD *)(v0 + 48);
  v6[2] = *(_OWORD *)(v0 + 32);
  v6[3] = v1;
  uint64_t v7 = *(void *)(v0 + 64);
  long long v2 = *(_OWORD *)(v0 + 16);
  v6[0] = *(_OWORD *)v0;
  v6[1] = v2;
  uint64_t v3 = MBNodeAsString((unsigned int *)v6);
  uint64_t v4 = static String._unconditionallyBridgeFromObjectiveC(_:)();

  return v4;
}

uint64_t sub_100017FA0()
{
  uint64_t v1 = *(void *)(v0 + 48);
  int v2 = *(_DWORD *)(v0 + 56);
  uint64_t v3 = *(void *)(v0 + 60);
  int v4 = *(_DWORD *)(v0 + 68);
  long long v5 = *(_OWORD *)(v0 + 16);
  v9[0] = *(_OWORD *)v0;
  v9[1] = v5;
  v9[2] = *(_OWORD *)(v0 + 32);
  uint64_t v10 = v1;
  int v11 = v2;
  uint64_t v12 = v3;
  int v13 = v4;
  uint64_t v6 = MBNodeAsString((unsigned int *)v9);
  uint64_t v7 = static String._unconditionallyBridgeFromObjectiveC(_:)();

  return v7;
}

__n128 sub_100018054@<Q0>(uint64_t a1@<X8>)
{
  __n128 v11 = 0u;
  memset(v12, 0, sizeof(v12));
  long long v9 = 0u;
  long long v10 = 0u;
  [v1 getNode:&v9];
  uint64_t v3 = *(void *)v12;
  int v4 = *(_DWORD *)&v12[8];
  uint64_t v5 = *(void *)&v12[12];
  int v6 = *(_DWORD *)&v12[20];
  long long v8 = v10;
  __n128 result = v11;
  *(_OWORD *)a1 = v9;
  *(_OWORD *)(a1 + 16) = v8;
  *(__n128 *)(a1 + 32) = result;
  *(void *)(a1 + 48) = v3;
  *(_DWORD *)(a1 + 56) = v4;
  *(void *)(a1 + 60) = v5;
  *(_DWORD *)(a1 + 68) = v6;
  return result;
}

uint64_t sub_1000180FC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  long long v16 = 0u;
  long long v17 = 0u;
  FilePath.string.getter();
  NSString v4 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v15 = 0;
  char v5 = MBNodeForPath(v4, (uint64_t)&v16, &v15);

  if (!v15 || (v5 & 1) != 0)
  {
    uint64_t v8 = type metadata accessor for FilePath();
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8))(a1, v8);
    uint64_t v9 = *(void *)v19;
    int v10 = *(_DWORD *)&v19[8];
    uint64_t v11 = *(void *)&v19[12];
    int v12 = *(_DWORD *)&v19[20];
    long long v14 = v17;
    long long v13 = v18;
    *(_OWORD *)a2 = v16;
    *(_OWORD *)(a2 + 16) = v14;
    *(_OWORD *)(a2 + 32) = v13;
    *(void *)(a2 + 48) = v9;
    *(_DWORD *)(a2 + 56) = v10;
    *(void *)(a2 + 60) = v11;
    *(_DWORD *)(a2 + 68) = v12;
  }
  else
  {
    v15;
    swift_willThrow();
    uint64_t v6 = type metadata accessor for FilePath();
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
  }
  return result;
}

void sub_100018270(void *a1@<X0>, uint64_t a2@<X8>)
{
  long long v15 = 0u;
  memset(v16, 0, sizeof(v16));
  long long v13 = 0u;
  long long v14 = 0u;
  int v3 = [a1 fileDescriptor];
  NSString v4 = String._bridgeToObjectiveC()();
  id v12 = 0;
  char v5 = MBNodeForRelativePathAt(v3, v4, (uint64_t)&v13, &v12);

  if (!v12 || (v5 & 1) != 0)
  {
    uint64_t v6 = *(void *)v16;
    int v7 = *(_DWORD *)&v16[8];
    uint64_t v8 = *(void *)&v16[12];
    int v9 = *(_DWORD *)&v16[20];
    long long v11 = v14;
    long long v10 = v15;
    *(_OWORD *)a2 = v13;
    *(_OWORD *)(a2 + 16) = v11;
    *(_OWORD *)(a2 + 32) = v10;
    *(void *)(a2 + 48) = v6;
    *(_DWORD *)(a2 + 56) = v7;
    *(void *)(a2 + 60) = v8;
    *(_DWORD *)(a2 + 68) = v9;
  }
  else
  {
    v12;
    swift_willThrow();
  }
}

uint64_t sub_100018384(uint64_t a1, void *a2)
{
  NSString v5 = String._bridgeToObjectiveC()();
  sub_100018544();
  id v6 = [v2 copyPreferencesValueForKey:v5 class:swift_getObjCClassFromMetadata()];

  if (!v6) {
    return 0;
  }
  _bridgeAnyObjectToAny(_:)();
  swift_unknownObjectRelease();
  sub_100016C78(v13, &v14);
  sub_100018584((uint64_t)&v14, (uint64_t)v13);
  sub_100006FC8(&qword_10047D4E8);
  if (!swift_dynamicCast())
  {
    *(void *)&v13[0] = 0;
    *((void *)&v13[0] + 1) = 0xE000000000000000;
    _StringGuts.grow(_:)(46);
    swift_bridgeObjectRelease();
    *(void *)&v13[0] = 0x7463657078656E55;
    *((void *)&v13[0] + 1) = 0xEB00000000206465;
    sub_10000700C(&v14, v15);
    swift_getDynamicType();
    v8._countAndFlagsBits = _typeName(_:qualified:)();
    String.append(_:)(v8);
    swift_bridgeObjectRelease();
    v9._countAndFlagsBits = 0xD00000000000001FLL;
    v9._object = (void *)0x8000000100304BF0;
    String.append(_:)(v9);
    v10._countAndFlagsBits = a1;
    v10._object = a2;
    String.append(_:)(v10);
    sub_1000465BC(*(uint64_t *)&v13[0], *((unint64_t *)&v13[0] + 1), 0xD000000000000014, 0x8000000100304BD0);
    swift_bridgeObjectRelease();
    sub_1000070A4((uint64_t)&v14);
    return 0;
  }
  uint64_t v7 = v12;
  sub_1000070A4((uint64_t)&v14);
  return v7;
}

unint64_t sub_100018544()
{
  unint64_t result = qword_10047D4E0;
  if (!qword_10047D4E0)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_10047D4E0);
  }
  return result;
}

uint64_t sub_100018584(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

BOOL sub_1000185E0(uint64_t a1, void *a2)
{
  uint64_t v5 = *(void *)(v2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession__operationQueue);
  uint64_t v6 = *(void *)(v5 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v6 + 16));
  swift_beginAccess();
  uint64_t v7 = *(void **)(v5 + 24);
  Swift::String v8 = *(os_unfair_lock_s **)(v6 + 16);
  id v9 = v7;
  os_unfair_lock_unlock(v8);
  if (v7)
  {
    sub_100045F18(a1, (unint64_t)a2, 0xD000000000000016, 0x8000000100304D10);
    sub_10001C0F4(0, &qword_10047D548);
    Class isa = Array._bridgeToObjectiveC()().super.isa;
    [v9 addOperations:isa waitUntilFinished:1];
  }
  else
  {
    _StringGuts.grow(_:)(31);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    v11._countAndFlagsBits = a1;
    v11._object = a2;
    String.append(_:)(v11);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD00000000000001DLL, 0x8000000100304D80, 0xD000000000000016, 0x8000000100304D10);
    swift_bridgeObjectRelease();
  }
  return v7 != 0;
}

id sub_100018770(void *a1, uint64_t a2, double a3)
{
  id result = [a1 serviceDelegate];
  if (result)
  {
    *(float *)&double v7 = a3;
    [result manager:a1 didUpdateProgress:-1 estimatedTimeRemaining:a2 context:v7];
    return (id)swift_unknownObjectRelease();
  }
  return result;
}

uint64_t sub_100018808(uint64_t a1, double a2)
{
  uint64_t v3 = *(void (**)(uint64_t, double))(a1 + 32);
  uint64_t v4 = swift_retain();
  v3(v4, a2);
  return swift_release();
}

id sub_10001885C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, NSString a6, uint64_t a7)
{
  NSString v11 = String._bridgeToObjectiveC()();
  if (a6) {
    a6 = String._bridgeToObjectiveC()();
  }
  id v15 = 0;
  unsigned int v12 = [a1 releaseLockWithBackupUDID:v11 account:a4 owner:a6 connection:a7 error:&v15];

  if (v12) {
    return v15;
  }
  id v14 = v15;
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

uint64_t sub_100018968(Swift::Int a1, Swift::Int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void **a10, uint64_t a11)
{
  NSString v13 = String._bridgeToObjectiveC()();
  NSString v14 = String._bridgeToObjectiveC()();
  NSString v15 = String._bridgeToObjectiveC()();
  id v16 = MBFileListDBPath(v13, (uint64_t)v14, v15);

  static String._unconditionallyBridgeFromObjectiveC(_:)();
  sub_100006FC8((uint64_t *)&unk_10047D910);
  swift_allocBox();
  FilePath.init(_:)();
  unint64_t v17 = swift_retain();
  uint64_t result = sub_100017A6C(v17, (uint64_t)v27);
  if (__OFADD__(*a9, v28))
  {
    __break(1u);
  }
  else
  {
    *a9 += v28;
    if (a1 == 0xD000000000000038 && a2 == 0x8000000100305050
      || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0
      || (uint64_t v19 = self,
          NSString v20 = String._bridgeToObjectiveC()(),
          LOBYTE(v19) = [(id)v19 isContainerizedName:v20],
          v20,
          (v19 & 1) == 0)
      || (sub_10004D340(a1, a2, a11) & 1) != 0)
    {
      NSString v21 = *a10;
      swift_bridgeObjectRetain();
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      *a10 = v21;
      if ((isUniquelyReferenced_nonNull_native & 1) == 0)
      {
        NSString v21 = sub_10003E1B0(0, v21[2] + 1, 1, v21);
        *a10 = v21;
      }
      unint64_t v24 = v21[2];
      unint64_t v23 = v21[3];
      if (v24 >= v23 >> 1)
      {
        NSString v21 = sub_10003E1B0((void *)(v23 > 1), v24 + 1, 1, v21);
        *a10 = v21;
      }
      v21[2] = v24 + 1;
      uint64_t v25 = &v21[2 * v24];
      v25[4] = a1;
      v25[5] = a2;
      return swift_release();
    }
    else
    {
      swift_bridgeObjectRetain();
      sub_10001324C(&v26, a1, a2);
      swift_release();
      return swift_bridgeObjectRelease();
    }
  }
  return result;
}

void sub_100018C9C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = *(void (**)(uint64_t, uint64_t, id, uint64_t))(a1 + 32);
  uint64_t v7 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v9 = v8;
  id v10 = a3;
  v6(v7, v9, v10, a4);
  swift_bridgeObjectRelease();
}

uint64_t sub_100018D90()
{
  _StringGuts.grow(_:)(22);
  v1._countAndFlagsBits = 60;
  v1._object = (void *)0xE100000000000000;
  String.append(_:)(v1);
  swift_getObjectType();
  v2._countAndFlagsBits = _typeName(_:qualified:)();
  String.append(_:)(v2);
  swift_bridgeObjectRelease();
  v3._countAndFlagsBits = 7876640;
  v3._object = (void *)0xE300000000000000;
  String.append(_:)(v3);
  _print_unlocked<A, B>(_:_:)();
  v4._countAndFlagsBits = 0x687370616E73203ALL;
  v4._object = (void *)0xEB000000003A746FLL;
  String.append(_:)(v4);
  uint64_t v5 = (uint64_t *)(*(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context)
                 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_snapshotUUID);
  uint64_t v6 = *v5;
  uint64_t v7 = (void *)v5[1];
  swift_bridgeObjectRetain();
  v8._countAndFlagsBits = v6;
  v8._object = v7;
  String.append(_:)(v8);
  swift_bridgeObjectRelease();
  v9._countAndFlagsBits = 62;
  v9._object = (void *)0xE100000000000000;
  String.append(_:)(v9);
  return 0;
}

id sub_100018EC4()
{
  uint64_t v2 = v0;
  Swift::String v3 = (void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession__selection);
  swift_beginAccess();
  sub_100022C84(v3);
  id result = (id)swift_endAccess();
  if (!v1)
  {
    uint64_t v5 = *(void *)(v2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
    v12[0] = *(id *)(v5 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_foregroundDomainNames);
    swift_bridgeObjectRetain();
    uint64_t v6 = swift_bridgeObjectRetain();
    sub_100011968(v6);
    sub_100015914((uint64_t)v12[0]);
    swift_bridgeObjectRelease();
    uint64_t v7 = *(void **)(v2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
    id v8 = *(id *)(v5 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress);
    Class isa = Set._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    v12[0] = 0;
    unsigned int v10 = [v7 addRemainingProgress:v8 forDomainNames:isa error:v12];

    if (v10)
    {
      return v12[0];
    }
    else
    {
      id v11 = v12[0];
      _convertNSErrorToError(_:)();

      return (id)swift_willThrow();
    }
  }
  return result;
}

id sub_100019070(char a1)
{
  sub_1000191CC(0xD000000000000014, 0x8000000100304DA0, *(void (**)(void))&v1[OBJC_IVAR____TtC7backupd19MBDryRestoreSession__releaseRestoreLock]);
  Swift::String v3 = v1;
  sub_10001BBE8(0xD000000000000015, 0x8000000100304DC0, (uint64_t)v3, (uint64_t)v3);

  Swift::String v4 = v3;
  sub_10001BD04(0xD000000000000015, 0x8000000100304DE0, (uint64_t)v4, (uint64_t)v4, a1);

  uint64_t v5 = v4;
  if (a1)
  {
    uint64_t v6 = 0xD000000000000019;
    unint64_t v7 = 0x8000000100304E20;
    id v8 = (void (*)(uint64_t))sub_1000083B8;
  }
  else
  {
    uint64_t v6 = 0xD00000000000001FLL;
    unint64_t v7 = 0x8000000100304E00;
    id v8 = (void (*)(uint64_t))sub_100008700;
  }
  sub_10001BE54(v6, v7, (uint64_t)v5, (uint64_t)v5, v8);

  Swift::String v9 = *(void **)(*(void *)&v5[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context]
                + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress);
  return [v9 ended];
}

void sub_1000191CC(uint64_t a1, unint64_t a2, void (*a3)(void))
{
  a3();
  sub_100045F18(a1, a2, 0xD000000000000016, 0x8000000100304D10);
}

id sub_1000192EC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
  id v4 = 0;
  if ([v1 close:&v4]) {
    return v4;
  }
  id v3 = v4;
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

uint64_t sub_10001939C(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession__depot);
  if ((a2 & 1) == 0) {
    goto LABEL_5;
  }
  unint64_t v4 = *(void *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
  if ((~v4 & 0xF000000000000007) == 0)
  {
    sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
    return swift_willThrow();
  }
  sub_10001BFFC(*(void *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath));
  sub_100033DB8(v4);
  uint64_t result = sub_10001BFE4(v4);
  if (!v2)
  {
LABEL_5:
    uint64_t v6 = *(void *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
    *(void *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath) = 0xF000000000000007;
    return sub_10001BFE4(v6);
  }
  return result;
}

void sub_10001946C()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession__operationQueue);
  uint64_t v2 = *(void *)(v1 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v2 + 16));
  swift_beginAccess();
  uint64_t v3 = *(void **)(v1 + 24);
  *(void *)(v1 + 24) = 0;
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v2 + 16));
  if (v3)
  {
    sub_100045F18(0xD00000000000001ELL, 0x8000000100304D60, 0xD000000000000016, 0x8000000100304D10);
    [v3 cancelAllOperations];
  }
  else
  {
    sub_100045F18(0xD000000000000025, 0x8000000100304D30, 0xD000000000000016, 0x8000000100304D10);
  }
}

uint64_t type metadata accessor for MBDryRestoreSession()
{
  return self;
}

void *sub_10001962C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return _swiftEmptyArrayStorage;
  }
  sub_100006FC8(&qword_10047D398);
  uint64_t v3 = (void *)swift_allocObject();
  int64_t v4 = j__malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 17;
  }
  v3[2] = v1;
  v3[3] = 2 * (v5 >> 4);
  uint64_t v6 = sub_100015314((uint64_t)&v8, v3 + 4, v1, a1);
  swift_bridgeObjectRetain();
  sub_100016C70();
  if (v6 != v1)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }
  return v3;
}

void *sub_100019714(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return &_swiftEmptyArrayStorage;
  }
  sub_100006FC8(&qword_10047D398);
  uint64_t v3 = (void *)swift_allocObject();
  int64_t v4 = j__malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 17;
  }
  v3[2] = v1;
  v3[3] = 2 * (v5 >> 4);
  uint64_t v6 = sub_100015514((uint64_t)&v8, v3 + 4, v1, a1);
  swift_bridgeObjectRetain();
  sub_100016C70();
  if (v6 != v1)
  {
    __break(1u);
    return &_swiftEmptyArrayStorage;
  }
  return v3;
}

void *sub_1000197FC(uint64_t a1)
{
  return sub_100019814(a1, (uint64_t (*)(uint64_t *, void *, uint64_t, uint64_t))sub_100015714);
}

void *sub_100019814(uint64_t a1, uint64_t (*a2)(uint64_t *, void *, uint64_t, uint64_t))
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    return _swiftEmptyArrayStorage;
  }
  sub_100006FC8((uint64_t *)&unk_10047D3A0);
  uint64_t v5 = (void *)swift_allocObject();
  int64_t v6 = j__malloc_size(v5);
  uint64_t v7 = v6 - 32;
  if (v6 < 32) {
    uint64_t v7 = v6 - 25;
  }
  v5[2] = v2;
  v5[3] = (2 * (v7 >> 3)) | 1;
  uint64_t v8 = a2(&v10, v5 + 4, v2, a1);
  swift_bridgeObjectRetain();
  sub_100016C70();
  if (v8 != v2)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }
  return v5;
}

Swift::Int sub_100019908(uint64_t *a1, uint64_t (*a2)(uint64_t))
{
  uint64_t v4 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v4 = a2(v4);
  }
  uint64_t v5 = *(void *)(v4 + 16);
  v7[0] = v4 + 32;
  v7[1] = v5;
  Swift::Int result = sub_10001997C(v7);
  *a1 = v4;
  return result;
}

Swift::Int sub_10001997C(uint64_t *a1)
{
  Swift::Int v3 = a1[1];
  Swift::Int result = _minimumMergeRunLength(_:)(v3);
  if (result >= v3)
  {
    if (v3 < 0) {
      goto LABEL_152;
    }
    if (v3) {
      return sub_10001A068(0, v3, 1, a1);
    }
    return result;
  }
  if (v3 >= 0) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = v3 + 1;
  }
  if (v3 < -1) {
    goto LABEL_160;
  }
  Swift::Int v105 = result;
  v102 = a1;
  if (v3 < 2)
  {
    uint64_t v8 = &_swiftEmptyArrayStorage;
    __dst = (char *)&_swiftEmptyArrayStorage + 32;
    if (v3 != 1)
    {
      unint64_t v12 = *((void *)&_swiftEmptyArrayStorage + 2);
      id v11 = (char *)&_swiftEmptyArrayStorage;
LABEL_118:
      Swift::String v94 = v11;
      uint64_t v104 = v8;
      if (v12 >= 2)
      {
        uint64_t v95 = *v102;
        do
        {
          unint64_t v96 = v12 - 2;
          if (v12 < 2) {
            goto LABEL_147;
          }
          if (!v95) {
            goto LABEL_159;
          }
          v97 = v94;
          uint64_t v98 = *(void *)&v94[16 * v96 + 32];
          uint64_t v99 = *(void *)&v94[16 * v12 + 24];
          sub_10001A138((char *)(v95 + 16 * v98), (char *)(v95 + 16 * *(void *)&v94[16 * v12 + 16]), v95 + 16 * v99, __dst);
          if (v1) {
            break;
          }
          if (v99 < v98) {
            goto LABEL_148;
          }
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
            v97 = sub_10001A58C((uint64_t)v97);
          }
          if (v96 >= *((void *)v97 + 2)) {
            goto LABEL_149;
          }
          int64_t v100 = &v97[16 * v96 + 32];
          *(void *)int64_t v100 = v98;
          *((void *)v100 + 1) = v99;
          unint64_t v101 = *((void *)v97 + 2);
          if (v12 > v101) {
            goto LABEL_150;
          }
          memmove(&v97[16 * v12 + 16], &v97[16 * v12 + 32], 16 * (v101 - v12));
          Swift::String v94 = v97;
          *((void *)v97 + 2) = v101 - 1;
          unint64_t v12 = v101 - 1;
        }
        while (v101 > 2);
      }
LABEL_115:
      swift_bridgeObjectRelease();
      v104[2] = 0;
      return swift_bridgeObjectRelease();
    }
    uint64_t v104 = &_swiftEmptyArrayStorage;
  }
  else
  {
    uint64_t v6 = v5 >> 1;
    uint64_t v7 = static Array._allocateBufferUninitialized(minimumCapacity:)();
    *(void *)(v7 + 16) = v6;
    uint64_t v104 = (void *)v7;
    __dst = (char *)(v7 + 32);
  }
  Swift::Int v9 = 0;
  uint64_t v10 = *a1;
  uint64_t v103 = v10 + 8;
  id v11 = (char *)&_swiftEmptyArrayStorage;
  Swift::Int v106 = v3;
  while (1)
  {
    Swift::Int v13 = v9++;
    if (v9 >= v3) {
      goto LABEL_46;
    }
    NSString v14 = (uint64_t *)(v10 + 16 * v9);
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1];
    unint64_t v17 = (void *)(v10 + 16 * v13);
    if (v15 == *v17 && v16 == v17[1])
    {
      Swift::Int v20 = v13 + 2;
      if (v13 + 2 >= v3) {
        goto LABEL_45;
      }
      int v19 = 0;
    }
    else
    {
      int v19 = _stringCompareWithSmolCheck(_:_:expecting:)();
      Swift::Int v20 = v13 + 2;
      if (v13 + 2 >= v3) {
        goto LABEL_36;
      }
    }
    NSString v21 = (void *)(v103 + 16 * v20);
    do
    {
      unint64_t v23 = (void *)(v10 + 16 * v9);
      if (*(v21 - 1) == *v23 && *v21 == v23[1])
      {
        if (v19) {
          goto LABEL_37;
        }
      }
      else if ((v19 ^ _stringCompareWithSmolCheck(_:_:expecting:)()))
      {
        goto LABEL_36;
      }
      v21 += 2;
      Swift::Int v22 = v20 + 1;
      Swift::Int v9 = v20;
      Swift::Int v20 = v22;
    }
    while (v22 < v3);
    Swift::Int v20 = v22;
LABEL_36:
    Swift::Int v9 = v20;
    if (v19)
    {
LABEL_37:
      if (v20 < v13) {
        goto LABEL_155;
      }
      if (v13 < v20)
      {
        uint64_t v25 = 16 * v20;
        uint64_t v26 = 16 * v13;
        Swift::Int v27 = v20;
        Swift::Int v28 = v13;
        do
        {
          if (v28 != --v27)
          {
            if (!v10) {
              goto LABEL_158;
            }
            uint64_t v29 = v10 + v25;
            uint64_t v30 = *(void *)(v10 + v26);
            uint64_t v31 = *(void *)(v10 + v26 + 8);
            *(_OWORD *)(v10 + v26) = *(_OWORD *)(v10 + v25 - 16);
            *(void *)(v29 - 16) = v30;
            *(void *)(v29 - 8) = v31;
          }
          ++v28;
          v25 -= 16;
          v26 += 16;
        }
        while (v28 < v27);
      }
LABEL_45:
      Swift::Int v9 = v20;
    }
LABEL_46:
    if (v9 < v3)
    {
      if (__OFSUB__(v9, v13)) {
        goto LABEL_151;
      }
      if (v9 - v13 < v105) {
        break;
      }
    }
LABEL_67:
    if (v9 < v13) {
      goto LABEL_146;
    }
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      id v11 = sub_10001A3D4(0, *((void *)v11 + 2) + 1, 1, v11);
    }
    unint64_t v41 = *((void *)v11 + 2);
    unint64_t v40 = *((void *)v11 + 3);
    unint64_t v12 = v41 + 1;
    if (v41 >= v40 >> 1) {
      id v11 = sub_10001A3D4((char *)(v40 > 1), v41 + 1, 1, v11);
    }
    *((void *)v11 + 2) = v12;
    uint64_t v42 = v11 + 32;
    uint64_t v43 = &v11[16 * v41 + 32];
    *(void *)uint64_t v43 = v13;
    *((void *)v43 + 1) = v9;
    if (v41)
    {
      Swift::Int v107 = v9;
      while (1)
      {
        unint64_t v44 = v12 - 1;
        if (v12 >= 4)
        {
          char v49 = &v42[16 * v12];
          uint64_t v50 = *((void *)v49 - 8);
          uint64_t v51 = *((void *)v49 - 7);
          BOOL v55 = __OFSUB__(v51, v50);
          uint64_t v52 = v51 - v50;
          if (v55) {
            goto LABEL_135;
          }
          uint64_t v54 = *((void *)v49 - 6);
          uint64_t v53 = *((void *)v49 - 5);
          BOOL v55 = __OFSUB__(v53, v54);
          uint64_t v47 = v53 - v54;
          char v48 = v55;
          if (v55) {
            goto LABEL_136;
          }
          unint64_t v56 = v12 - 2;
          int v57 = &v42[16 * v12 - 32];
          uint64_t v59 = *(void *)v57;
          uint64_t v58 = *((void *)v57 + 1);
          BOOL v55 = __OFSUB__(v58, v59);
          uint64_t v60 = v58 - v59;
          if (v55) {
            goto LABEL_138;
          }
          BOOL v55 = __OFADD__(v47, v60);
          uint64_t v61 = v47 + v60;
          if (v55) {
            goto LABEL_141;
          }
          if (v61 >= v52)
          {
            v79 = &v42[16 * v44];
            uint64_t v81 = *(void *)v79;
            uint64_t v80 = *((void *)v79 + 1);
            BOOL v55 = __OFSUB__(v80, v81);
            uint64_t v82 = v80 - v81;
            if (v55) {
              goto LABEL_145;
            }
            BOOL v72 = v47 < v82;
            goto LABEL_105;
          }
        }
        else
        {
          if (v12 != 3)
          {
            uint64_t v73 = *((void *)v11 + 4);
            uint64_t v74 = *((void *)v11 + 5);
            BOOL v55 = __OFSUB__(v74, v73);
            uint64_t v66 = v74 - v73;
            char v67 = v55;
            goto LABEL_99;
          }
          uint64_t v46 = *((void *)v11 + 4);
          uint64_t v45 = *((void *)v11 + 5);
          BOOL v55 = __OFSUB__(v45, v46);
          uint64_t v47 = v45 - v46;
          char v48 = v55;
        }
        if (v48) {
          goto LABEL_137;
        }
        unint64_t v56 = v12 - 2;
        uint64_t v62 = &v42[16 * v12 - 32];
        uint64_t v64 = *(void *)v62;
        uint64_t v63 = *((void *)v62 + 1);
        BOOL v65 = __OFSUB__(v63, v64);
        uint64_t v66 = v63 - v64;
        char v67 = v65;
        if (v65) {
          goto LABEL_140;
        }
        id v68 = &v42[16 * v44];
        uint64_t v70 = *(void *)v68;
        uint64_t v69 = *((void *)v68 + 1);
        BOOL v55 = __OFSUB__(v69, v70);
        uint64_t v71 = v69 - v70;
        if (v55) {
          goto LABEL_143;
        }
        if (__OFADD__(v66, v71)) {
          goto LABEL_144;
        }
        if (v66 + v71 >= v47)
        {
          BOOL v72 = v47 < v71;
LABEL_105:
          if (v72) {
            unint64_t v44 = v56;
          }
          goto LABEL_107;
        }
LABEL_99:
        if (v67) {
          goto LABEL_139;
        }
        NSString v75 = &v42[16 * v44];
        uint64_t v77 = *(void *)v75;
        uint64_t v76 = *((void *)v75 + 1);
        BOOL v55 = __OFSUB__(v76, v77);
        uint64_t v78 = v76 - v77;
        if (v55) {
          goto LABEL_142;
        }
        if (v78 < v66) {
          goto LABEL_15;
        }
LABEL_107:
        unint64_t v83 = v44 - 1;
        if (v44 - 1 >= v12)
        {
          __break(1u);
LABEL_132:
          __break(1u);
LABEL_133:
          __break(1u);
LABEL_134:
          __break(1u);
LABEL_135:
          __break(1u);
LABEL_136:
          __break(1u);
LABEL_137:
          __break(1u);
LABEL_138:
          __break(1u);
LABEL_139:
          __break(1u);
LABEL_140:
          __break(1u);
LABEL_141:
          __break(1u);
LABEL_142:
          __break(1u);
LABEL_143:
          __break(1u);
LABEL_144:
          __break(1u);
LABEL_145:
          __break(1u);
LABEL_146:
          __break(1u);
LABEL_147:
          __break(1u);
LABEL_148:
          __break(1u);
LABEL_149:
          __break(1u);
LABEL_150:
          __break(1u);
LABEL_151:
          __break(1u);
LABEL_152:
          __break(1u);
LABEL_153:
          __break(1u);
          goto LABEL_154;
        }
        uint64_t v84 = v10;
        if (!v10) {
          goto LABEL_157;
        }
        id v85 = v11;
        v86 = &v42[16 * v83];
        uint64_t v87 = *(void *)v86;
        char v88 = v42;
        unint64_t v89 = v44;
        id v90 = &v42[16 * v44];
        uint64_t v91 = *((void *)v90 + 1);
        uint64_t v92 = v84;
        sub_10001A138((char *)(v84 + 16 * *(void *)v86), (char *)(v84 + 16 * *(void *)v90), v84 + 16 * v91, __dst);
        if (v1) {
          goto LABEL_115;
        }
        if (v91 < v87) {
          goto LABEL_132;
        }
        if (v89 > *((void *)v85 + 2)) {
          goto LABEL_133;
        }
        *(void *)v86 = v87;
        *(void *)&v88[16 * v83 + 8] = v91;
        unint64_t v93 = *((void *)v85 + 2);
        if (v89 >= v93) {
          goto LABEL_134;
        }
        id v11 = v85;
        unint64_t v12 = v93 - 1;
        memmove(v90, v90 + 16, 16 * (v93 - 1 - v89));
        uint64_t v42 = v88;
        *((void *)v85 + 2) = v93 - 1;
        uint64_t v10 = v92;
        Swift::Int v9 = v107;
        if (v93 <= 2) {
          goto LABEL_15;
        }
      }
    }
    unint64_t v12 = 1;
LABEL_15:
    Swift::Int v3 = v106;
    if (v9 >= v106)
    {
      uint64_t v8 = v104;
      goto LABEL_118;
    }
  }
  if (__OFADD__(v13, v105)) {
    goto LABEL_153;
  }
  if (v13 + v105 >= v3) {
    Swift::Int v32 = v3;
  }
  else {
    Swift::Int v32 = v13 + v105;
  }
  if (v32 >= v13)
  {
    if (v9 != v32)
    {
      uint64_t v33 = (void *)(v10 + 16 * v9);
      do
      {
        uint64_t v34 = (uint64_t *)(v10 + 16 * v9);
        uint64_t v35 = *v34;
        uint64_t v36 = v34[1];
        Swift::Int v37 = v13;
        int v38 = v33;
        do
        {
          BOOL v39 = v35 == *(v38 - 2) && v36 == *(v38 - 1);
          if (v39 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0) {
            break;
          }
          if (!v10) {
            goto LABEL_156;
          }
          uint64_t v35 = *v38;
          uint64_t v36 = v38[1];
          *(_OWORD *)int v38 = *((_OWORD *)v38 - 1);
          *(v38 - 1) = v36;
          *(v38 - 2) = v35;
          v38 -= 2;
          ++v37;
        }
        while (v9 != v37);
        ++v9;
        v33 += 2;
      }
      while (v9 != v32);
      Swift::Int v9 = v32;
    }
    goto LABEL_67;
  }
LABEL_154:
  __break(1u);
LABEL_155:
  __break(1u);
LABEL_156:
  __break(1u);
LABEL_157:
  __break(1u);
LABEL_158:
  __break(1u);
LABEL_159:
  __break(1u);
LABEL_160:
  Swift::Int result = _assertionFailure(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_10001A068(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a3 != a2)
  {
    uint64_t v4 = a3;
    uint64_t v6 = result;
    uint64_t v7 = *a4;
    uint64_t v8 = *a4 + 16 * a3;
LABEL_5:
    Swift::Int v9 = (uint64_t *)(v7 + 16 * v4);
    Swift::Int result = *v9;
    uint64_t v10 = v9[1];
    uint64_t v11 = v6;
    unint64_t v12 = (uint64_t *)v8;
    while (1)
    {
      BOOL v13 = result == *(v12 - 2) && v10 == *(v12 - 1);
      if (v13 || (Swift::Int result = _stringCompareWithSmolCheck(_:_:expecting:)(), (result & 1) == 0))
      {
LABEL_4:
        ++v4;
        v8 += 16;
        if (v4 == a2) {
          return result;
        }
        goto LABEL_5;
      }
      if (!v7) {
        break;
      }
      Swift::Int result = *v12;
      uint64_t v10 = v12[1];
      *(_OWORD *)unint64_t v12 = *((_OWORD *)v12 - 1);
      *(v12 - 1) = v10;
      *(v12 - 2) = result;
      v12 -= 2;
      if (v4 == ++v11) {
        goto LABEL_4;
      }
    }
    __break(1u);
  }
  return result;
}

uint64_t sub_10001A138(char *__src, char *a2, unint64_t a3, char *__dst)
{
  uint64_t v4 = __dst;
  uint64_t v6 = a2;
  uint64_t v7 = __src;
  int64_t v8 = a2 - __src;
  int64_t v9 = a2 - __src + 15;
  if (a2 - __src >= 0) {
    int64_t v9 = a2 - __src;
  }
  uint64_t v10 = v9 >> 4;
  uint64_t v11 = a3 - (void)a2;
  uint64_t v12 = a3 - (void)a2 + 15;
  if ((uint64_t)(a3 - (void)a2) >= 0) {
    uint64_t v12 = a3 - (void)a2;
  }
  uint64_t v13 = v12 >> 4;
  Swift::Int v27 = __src;
  uint64_t v26 = __dst;
  if (v10 >= v12 >> 4)
  {
    if (v11 >= -15)
    {
      if (__dst != a2 || &a2[16 * v13] <= __dst) {
        memmove(__dst, a2, 16 * v13);
      }
      unint64_t v17 = &v4[16 * v13];
      uint64_t v25 = v17;
      Swift::Int v27 = v6;
      if (v7 < v6 && v11 >= 16)
      {
        long long v18 = (char *)(a3 - 16);
        int v19 = v6;
        while (1)
        {
          Swift::Int v20 = v18 + 16;
          uint64_t v21 = *((void *)v19 - 2);
          uint64_t v22 = *((void *)v19 - 1);
          v19 -= 16;
          BOOL v23 = *((void *)v17 - 2) == v21 && *((void *)v17 - 1) == v22;
          if (v23 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
          {
            uint64_t v25 = v17 - 16;
            if (v20 < v17 || v18 >= v17 || v20 != v17) {
              *(_OWORD *)long long v18 = *((_OWORD *)v17 - 1);
            }
            int v19 = v6;
            v17 -= 16;
            if (v6 <= v7) {
              goto LABEL_50;
            }
          }
          else
          {
            if (v20 != v6 || v18 >= v6) {
              *(_OWORD *)long long v18 = *(_OWORD *)v19;
            }
            Swift::Int v27 = v19;
            if (v19 <= v7) {
              goto LABEL_50;
            }
          }
          v18 -= 16;
          uint64_t v6 = v19;
          if (v17 <= v4) {
            goto LABEL_50;
          }
        }
      }
      goto LABEL_50;
    }
  }
  else if (v8 >= -15)
  {
    if (__dst != __src || &__src[16 * v10] <= __dst) {
      memmove(__dst, __src, 16 * v10);
    }
    NSString v14 = &v4[16 * v10];
    uint64_t v25 = v14;
    if ((unint64_t)v6 < a3 && v8 >= 16)
    {
      do
      {
        BOOL v15 = *(void *)v6 == *(void *)v4 && *((void *)v6 + 1) == *((void *)v4 + 1);
        if (v15 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
        {
          if (v7 != v4) {
            *(_OWORD *)uint64_t v7 = *(_OWORD *)v4;
          }
          v4 += 16;
          uint64_t v26 = v4;
          uint64_t v16 = v6;
        }
        else
        {
          uint64_t v16 = v6 + 16;
          if (v7 < v6 || v7 >= v16 || v7 != v6) {
            *(_OWORD *)uint64_t v7 = *(_OWORD *)v6;
          }
        }
        v7 += 16;
        if (v4 >= v14) {
          break;
        }
        uint64_t v6 = v16;
      }
      while ((unint64_t)v16 < a3);
      Swift::Int v27 = v7;
    }
LABEL_50:
    sub_10001A4D0((void **)&v27, (const void **)&v26, &v25);
    return 1;
  }
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

char *sub_10001A3D4(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    sub_100006FC8(&qword_10047D570);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = j__malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 17;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 4);
  }
  else
  {
    uint64_t v10 = (char *)&_swiftEmptyArrayStorage;
  }
  uint64_t v13 = v10 + 32;
  NSString v14 = a4 + 32;
  if (v5)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8]) {
      memmove(v13, v14, 16 * v8);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    memcpy(v13, v14, 16 * v8);
  }
  swift_bridgeObjectRelease();
  return v10;
}

char *sub_10001A4D0(void **a1, const void **a2, void *a3)
{
  Swift::Int v3 = (char *)*a2;
  uint64_t v4 = *a3 - (void)v3;
  uint64_t v5 = v4 + 15;
  if (v4 >= 0) {
    uint64_t v5 = *a3 - (void)v3;
  }
  if (v4 <= -16)
  {
    uint64_t result = (char *)_fatalErrorMessage(_:_:file:line:flags:)();
    __break(1u);
  }
  else
  {
    uint64_t result = (char *)*a1;
    uint64_t v7 = v5 >> 4;
    if (result != v3 || result >= &v3[16 * v7])
    {
      return (char *)memmove(result, v3, 16 * v7);
    }
  }
  return result;
}

char *sub_10001A58C(uint64_t a1)
{
  return sub_10001A3D4(0, *(void *)(a1 + 16), 0, (char *)a1);
}

uint64_t sub_10001A5A0(uint64_t a1)
{
  return sub_100014B9C(0, *(void *)(a1 + 16), 0, (char *)a1);
}

id sub_10001A5B4(void *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, void *a6, void *a7, uint64_t a8, uint64_t a9)
{
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  *(void *)&v9[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context] = a1;
  *(void *)&v9[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB] = a6;
  long long v18 = &v9[OBJC_IVAR____TtC7backupd19MBDryRestoreSession__selection];
  *(void *)long long v18 = a2;
  *((void *)v18 + 1) = a3;
  v18[16] = a4 & 1;
  *((void *)v18 + 3) = a5;
  *((_OWORD *)v18 + 2) = 0u;
  *((_OWORD *)v18 + 3) = 0u;
  *((_OWORD *)v18 + 4) = 0u;
  *((_OWORD *)v18 + 5) = 0u;
  *((_OWORD *)v18 + 6) = 0u;
  *((void *)v18 + 14) = 0;
  *(void *)&v9[OBJC_IVAR____TtC7backupd19MBDryRestoreSession__depot] = a7;
  int v19 = &v9[OBJC_IVAR____TtC7backupd19MBDryRestoreSession__releaseRestoreLock];
  *(void *)int v19 = a8;
  *((void *)v19 + 1) = a9;
  id v20 = objc_allocWithZone((Class)NSOperationQueue);
  uint64_t v21 = v9;
  id v22 = a1;
  id v23 = a6;
  id v24 = a7;
  swift_retain();
  id v25 = [v20 init];
  id v26 = [self sharedOptions];
  signed int v27 = [v26 maxConcurrentRestoreDomainOperations];

  [v25 setMaxConcurrentOperationCount:v27];
  sub_100006FC8(&qword_10047D568);
  uint64_t v28 = swift_allocObject();
  type metadata accessor for MBUnfairLock();
  uint64_t v29 = swift_allocObject();
  id v30 = v25;
  uint64_t v31 = (_DWORD *)swift_slowAlloc();
  *(void *)(v29 + 16) = v31;
  *uint64_t v31 = 0;
  *(void *)(v28 + 16) = v29;
  *(void *)(v28 + 24) = v25;

  *(void *)&v21[OBJC_IVAR____TtC7backupd19MBDryRestoreSession__operationQueue] = v28;
  v34.receiver = v21;
  v34.super_class = ObjectType;
  return objc_msgSendSuper2(&v34, "init");
}

uint64_t sub_10001A794(unint64_t a1, unint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, char a7, void *a8, Swift::String *a9, uint64_t a10, char a11)
{
  v142._countAndFlagsBits = a3;
  v142._object = a4;
  id v14 = [self sharedInstance];
  if (!v14)
  {
    __break(1u);
    goto LABEL_59;
  }
  BOOL v15 = v14;
  uint64_t v148 = a5;
  uint64_t v16 = a9;
  id v17 = [a8 persona];
  id v18 = [objc_allocWithZone((Class)MBProgressModel) init];
  uint64_t v19 = swift_allocObject();
  *(void *)(v19 + 16) = v15;
  *(void *)(v19 + 24) = a9;
  v163 = sub_10001C054;
  uint64_t v164 = v19;
  *(void *)&long long aBlock = _NSConcreteStackBlock;
  *((void *)&aBlock + 1) = 1107296256;
  v161 = sub_100018808;
  v162 = &unk_10040FA98;
  id v20 = _Block_copy(&aBlock);
  uint64_t v21 = a9;
  id v22 = v15;
  swift_release();
  v152 = v18;
  [v18 setBlock:v20];
  _Block_release(v20);
  id v23 = [v22 serviceDelegate];
  if (v23)
  {
    id v24 = v23;
    id v25 = v22;
    [v24 manager:v25 didUpdateProgress:-1 estimatedTimeRemaining:v21 context:0.0];

    swift_unknownObjectRelease();
  }
  v153 = v21;
  id v26 = [self expensiveCellularPolicy];
  [v26 setQualityOfService:25];
  NSString v27 = String._bridgeToObjectiveC()();
  char v141 = a7;
  if (a9)
  {
    NSString v28 = [(Swift::String *)v153 processName];
    if (v28)
    {
      static String._unconditionallyBridgeFromObjectiveC(_:)();

      NSString v28 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    NSString v28 = 0;
  }
  id v29 = [v26 operationGroupWithName:v27 processName:v28];

  id v30 = v22;
  id v31 = a8;
  id v32 = v26;
  uint64_t v33 = (Swift::String *)v29;
  id v34 = [v30 databaseManager];
  if (!v34) {
LABEL_59:
  }
    __break(1u);
  uint64_t v35 = v34;
  *(void *)&long long aBlock = 0;
  uint64_t v36 = self;
  id v37 = v31;
  id v38 = [v36 operationTrackerWithAccount:v37 databaseManager:v35 policy:v32 group:v33 error:&aBlock];

  if ((void)aBlock)
  {
    uint64_t v16 = v33;
    id v39 = (id)aBlock;
    swift_willThrow();

    return (uint64_t)v16;
  }
  uint64_t v139 = v38;
  if (!v38) {
    goto LABEL_61;
  }

  unint64_t v134 = v33;
  sub_100045F18(0xD000000000000016, 0x8000000100304E80, 0xD000000000000016, 0x8000000100304D10);
  id v40 = (id)MBDeviceUUID();
  uint64_t v138 = v17;
  if (v40)
  {
    id v131 = (id)static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v136 = v41;
  }
  else
  {
    id v131 = 0;
    uint64_t v136 = 0;
  }
  uint64_t v135 = v32;
  NSString v42 = String._bridgeToObjectiveC()();
  *(void *)&long long aBlock = 0;
  unint64_t v43 = (unint64_t)v153;
  unsigned int v44 = [v30 acquireLockWithBackupUDID:v42 account:v37 owner:v40 timeout:v153 connection:&aBlock error:7200.0];

  uint64_t v45 = (void *)aBlock;
  if (!v44)
  {
    id v76 = (id)aBlock;
    swift_bridgeObjectRelease();
    _convertNSErrorToError(_:)();

    swift_willThrow();
LABEL_41:

    goto LABEL_42;
  }
  uint64_t v46 = (void *)swift_allocObject();
  v46[2] = v30;
  v46[3] = v148;
  v46[4] = a6;
  v46[5] = v37;
  v46[6] = v131;
  v46[7] = v136;
  v46[8] = a9;
  uint64_t v47 = self;
  id v48 = v30;
  char v49 = v153;
  id v50 = v37;
  swift_bridgeObjectRetain();
  id v51 = v45;
  NSString v52 = String._bridgeToObjectiveC()();
  *(void *)&long long aBlock = 0;
  id v53 = [v47 fetchDeviceRecordAndSnapshots:v52 account:v50 manager:v48 tracker:v139 error:&aBlock];

  if (!v53)
  {
    uint64_t v16 = (Swift::String *)(id)aBlock;
    _convertNSErrorToError(_:)();

    swift_willThrow();
    swift_release();

LABEL_42:
    return (uint64_t)v16;
  }
  uint64_t v130 = v50;
  id v54 = (id)aBlock;
  sub_100045F18(0xD000000000000018, 0x8000000100304EA0, 0xD000000000000016, 0x8000000100304D10);
  BOOL v55 = (Swift::String *)[objc_allocWithZone((Class)MBSettingsContext) init];
  id v56 = [self appManagerWithSettingsContext:v55];
  if (!v56) {
    goto LABEL_62;
  }
  int v57 = v56;
  *(void *)&long long aBlock = 0;
  if (![v56 loadAppsWithPersona:v138 safeHarbors:0 error:&aBlock])
  {
    uint64_t v16 = (Swift::String *)(id)aBlock;
    _convertNSErrorToError(_:)();

    swift_willThrow();
    swift_release();

    goto LABEL_41;
  }
  v159 = _swiftEmptyArrayStorage;
  v158 = &_swiftEmptySetSingleton;
  id v58 = (id)aBlock;
  sub_100045F18(0xD00000000000001BLL, 0x8000000100304EC0, 0xD000000000000016, 0x8000000100304D10);
  id v59 = [v57 allContainers];
  if (!v59) {
    goto LABEL_63;
  }
  uint64_t v60 = v59;
  sub_10001C0F4(0, &qword_10047D550);
  unint64_t v61 = static Array._unconditionallyBridgeFromObjectiveC(_:)();

  if (v61 >> 62)
  {
    swift_bridgeObjectRetain();
    uint64_t v62 = _CocoaArrayWrapper.endIndex.getter();
  }
  else
  {
    uint64_t v62 = *(void *)((v61 & 0xFFFFFFFFFFFFFF8) + 0x10);
    swift_bridgeObjectRetain();
  }
  v149 = v57;
  id v132 = v53;
  v137 = v48;
  uint64_t v151 = (uint64_t)v46;
  v129 = v55;
  uint64_t v63 = _swiftEmptyArrayStorage;
  if (!v62)
  {
LABEL_44:
    swift_bridgeObjectRelease_n();
    uint64_t v78 = sub_100015914((uint64_t)v63);
    swift_bridgeObjectRelease();
    *(void *)&long long aBlock = 0x676E697461657243;
    *((void *)&aBlock + 1) = 0xE900000000000020;
    v79._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v79);
    swift_bridgeObjectRelease();
    uint64_t v16 = (Swift::String *)*((void *)&aBlock + 1);
    sub_100045F18(aBlock, *((unint64_t *)&aBlock + 1), 0xD000000000000016, 0x8000000100304D10);
    swift_bridgeObjectRelease();
    sub_100007F74(448, a1);
    if (v144)
    {
      swift_bridgeObjectRelease();

      swift_release();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    else
    {
      *(void *)&long long aBlock = 0x676E697461657243;
      *((void *)&aBlock + 1) = 0xE900000000000020;
      v80._countAndFlagsBits = sub_10002D874(a2);
      String.append(_:)(v80);
      swift_bridgeObjectRelease();
      sub_100045F18(aBlock, *((unint64_t *)&aBlock + 1), 0xD000000000000016, 0x8000000100304D10);
      swift_bridgeObjectRelease();
      sub_100007F74(448, a2);
      unint64_t v81 = sub_10002D538(0x746F687370616E73, 0xE900000000000073, a2);
      *(void *)&long long aBlock = 0;
      *((void *)&aBlock + 1) = 0xE000000000000000;
      _StringGuts.grow(_:)(37);
      swift_bridgeObjectRelease();
      *(void *)&long long aBlock = 0xD00000000000001DLL;
      *((void *)&aBlock + 1) = 0x8000000100304EE0;
      String.append(_:)(v142);
      v82._countAndFlagsBits = 544497952;
      v82._object = (void *)0xE400000000000000;
      String.append(_:)(v82);
      v83._countAndFlagsBits = sub_10002D874(v81);
      String.append(_:)(v83);
      swift_bridgeObjectRelease();
      sub_100045F18(aBlock, *((unint64_t *)&aBlock + 1), 0xD000000000000016, 0x8000000100304D10);
      swift_bridgeObjectRelease();
      uint64_t v157 = 0;
      uint64_t v154 = v81;
      uint64_t v84 = sub_10002D270(v81);
      v86 = v85;
      id v87 = v139;
      NSString v145 = String._bridgeToObjectiveC()();
      NSString v88 = String._bridgeToObjectiveC()();
      uint64_t v16 = (Swift::String *)swift_allocObject();
      v16[1]._countAndFlagsBits = v84;
      v16[1]._object = v86;
      v16[2] = v142;
      v16[3]._countAndFlagsBits = (uint64_t)&v157;
      v16[3]._object = &v159;
      v16[4]._countAndFlagsBits = v78;
      v16[4]._object = &v158;
      uint64_t v89 = swift_allocObject();
      *(void *)(v89 + 16) = sub_10001C178;
      *(void *)(v89 + 24) = v16;
      v163 = sub_10001C1C0;
      uint64_t v164 = v89;
      *(void *)&long long aBlock = _NSConcreteStackBlock;
      *((void *)&aBlock + 1) = 1107296256;
      v161 = sub_100018C9C;
      v162 = &unk_10040FB38;
      id v90 = _Block_copy(&aBlock);
      swift_bridgeObjectRetain();
      swift_release();
      *(void *)&long long aBlock = 0;
      LODWORD(v84) = [v132 synchronizeFileListsWithOperationTracker:v87 snapshotDirectory:v145 snapshotUUID:v88 error:&aBlock fetchedFileListBlock:v90];
      _Block_release(v90);

      id v91 = (id)aBlock;
      if (v84)
      {
        v140 = v87;
        sub_100019908((uint64_t *)&v159, (uint64_t (*)(uint64_t))sub_1000152EC);
        strcpy((char *)&aBlock, "FG domains: ");
        BYTE13(aBlock) = 0;
        HIWORD(aBlock) = -5120;
        swift_bridgeObjectRetain();
        sub_100006FC8(&qword_10047D558);
        sub_10001C1E8();
        uint64_t v92 = BidirectionalCollection<>.joined(separator:)();
        Swift::String v94 = v93;
        swift_bridgeObjectRelease();
        v95._countAndFlagsBits = v92;
        v95._object = v94;
        String.append(_:)(v95);
        swift_bridgeObjectRelease();
        sub_100045F18(aBlock, *((unint64_t *)&aBlock + 1), 0xD000000000000016, 0x8000000100304D10);
        swift_bridgeObjectRelease();
        strcpy((char *)&aBlock, "BG domains: ");
        BYTE13(aBlock) = 0;
        HIWORD(aBlock) = -5120;
        uint64_t v96 = (uint64_t)v158;
        swift_bridgeObjectRetain_n();
        v97 = sub_10001962C(v96);
        swift_bridgeObjectRelease();
        v155 = v97;
        sub_100019908((uint64_t *)&v155, sub_10001A5A0);
        swift_bridgeObjectRelease();
        uint64_t v98 = BidirectionalCollection<>.joined(separator:)();
        int64_t v100 = v99;
        swift_release();
        v101._countAndFlagsBits = v98;
        v101._object = v100;
        String.append(_:)(v101);
        swift_bridgeObjectRelease();
        sub_100045F18(aBlock, *((unint64_t *)&aBlock + 1), 0xD000000000000016, 0x8000000100304D10);
        swift_bridgeObjectRelease();
        unint64_t v102 = sub_10002D538(0x5F65726F74736572, 0xED0000746F706564, a1);
        *(void *)&long long aBlock = 0;
        *((void *)&aBlock + 1) = 0xE000000000000000;
        _StringGuts.grow(_:)(44);
        swift_bridgeObjectRelease();
        *(void *)&long long aBlock = 0xD00000000000002ALL;
        *((void *)&aBlock + 1) = 0x8000000100304F40;
        v103._countAndFlagsBits = sub_10002D874(v102);
        String.append(_:)(v103);
        swift_bridgeObjectRelease();
        sub_100045F18(aBlock, *((unint64_t *)&aBlock + 1), 0xD000000000000016, 0x8000000100304D10);
        swift_bridgeObjectRelease();
        uint64_t v104 = sub_10002D270(a1);
        uint64_t v106 = v105;
        unint64_t v43 = 0;
        uint64_t v107 = sub_10002D270(v102);
        v128 = sub_100033A38(v138, v104, v106, v107, v108);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        uint64_t v110 = sub_10003DEC4(v157, a10, a11 & 1);
        uint64_t v112 = v111;
        unint64_t v114 = v113;
        LOBYTE(v102) = v115 & 1;
        v155 = 0;
        unint64_t v156 = 0xE000000000000000;
        v116._countAndFlagsBits = 0x203A746567647542;
        v116._object = (void *)0xE800000000000000;
        String.append(_:)(v116);
        uint64_t v126 = v112;
        uint64_t v127 = v110;
        *(void *)&long long aBlock = v110;
        *((void *)&aBlock + 1) = v112;
        char v124 = v102;
        LOBYTE(v161) = v102;
        uint64_t v125 = (uint64_t)v114;
        v162 = v114;
        _print_unlocked<A, B>(_:_:)();
        sub_100045F18((uint64_t)v155, v156, 0xD000000000000015, 0x8000000100304F70);
        swift_bridgeObjectRelease();
        uint64_t v117 = (uint64_t)v158;
        uint64_t v118 = (uint64_t)v159;
        objc_allocWithZone((Class)type metadata accessor for MBDryRestoreContext());
        swift_retain();
        id v119 = v149;
        id v120 = v132;
        uint64_t v64 = v128;
        BOOL v55 = v152;
        id v133 = v130;
        id v65 = v140;
        swift_bridgeObjectRetain();
        swift_retain();
        swift_retain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        v149 = v120;
        v152 = v119;
        id v66 = sub_10000D84C(a1, a2, v118, v117, v154, v142._countAndFlagsBits, (uint64_t)v142._object, v133, v119, v65, v120, (void *)v64, v55);
LABEL_50:
        v121 = v66;
        if (v141) {
          id v122 = sub_10000E638();
        }
        else {
          id v122 = sub_10000E6A8();
        }
        uint64_t v16 = v129;
        if (!v43)
        {
          v147 = v122;
          id v123 = objc_allocWithZone((Class)type metadata accessor for MBDryRestoreSession());
          uint64_t v16 = (Swift::String *)sub_10001A5B4(v121, v127, v126, v124, v125, v147, (void *)v64, (uint64_t)sub_10001C0CC, v151);

          swift_release();
          swift_release();
          swift_release();
          swift_bridgeObjectRelease();
          swift_release();
          swift_bridgeObjectRelease();
          return (uint64_t)v16;
        }

        swift_release();
        swift_release();

        swift_release();
        swift_bridgeObjectRelease();
      }
      else
      {
        id v109 = v91;
        _convertNSErrorToError(_:)();

        swift_willThrow();
        swift_release();

        swift_release();
        swift_bridgeObjectRelease();
      }
      swift_release();
      swift_bridgeObjectRelease();
    }
    return (uint64_t)v16;
  }
  uint64_t v64 = 4;
  while (1)
  {
    id v65 = (id)(v64 - 4);
    if ((v61 & 0xC000000000000001) != 0) {
      id v66 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
    }
    else {
      id v66 = *(id *)(v61 + 8 * v64);
    }
    char v67 = v66;
    uint64_t v68 = v64 - 3;
    if (__OFADD__(v65, 1))
    {
      __break(1u);
      goto LABEL_50;
    }
    if (([v66 isSystemContainer] & 1) != 0
      || [v67 isSystemSharedContainer])
    {
      break;
    }

LABEL_25:
    ++v64;
    if (v68 == v62) {
      goto LABEL_44;
    }
  }
  id v69 = [v67 domain];
  if (v69)
  {
    uint64_t v70 = v69;
    id v71 = [v69 name];

    uint64_t v72 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    BOOL v55 = v73;

    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      uint64_t v63 = sub_10003E1B0(0, v63[2] + 1, 1, v63);
    }
    unint64_t v43 = v63[2];
    unint64_t v74 = v63[3];
    if (v43 >= v74 >> 1) {
      uint64_t v63 = sub_10003E1B0((void *)(v74 > 1), v43 + 1, 1, v63);
    }
    v63[2] = v43 + 1;
    NSString v75 = &v63[2 * v43];
    v75[4] = v72;
    v75[5] = v55;
    goto LABEL_25;
  }
  __break(1u);
LABEL_61:
  __break(1u);
LABEL_62:
  __break(1u);
LABEL_63:
  __break(1u);
  uint64_t result = swift_release();
  __break(1u);
  return result;
}

void sub_10001BBE8(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1000192EC(a4);
  sub_100045F18(a1, a2, 0xD000000000000016, 0x8000000100304D10);
}

void sub_10001BD04(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  sub_10001939C(a4, a5);
  sub_100045F18(a1, a2, 0xD000000000000016, 0x8000000100304D10);
}

void sub_10001BE24(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_10001BE3C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_10001BE54(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t))
{
  uint64_t v8 = *(void *)(a4 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
  uint64_t v9 = *(void *)(v8 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_metadataPath);
  swift_retain();
  a5(v9);
  swift_release();
  uint64_t v10 = *(void *)(v8 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath);
  swift_retain();
  a5(v10);
  swift_release();
  sub_100045F18(a1, a2, 0xD000000000000016, 0x8000000100304D10);
}

uint64_t sub_10001BFE4(uint64_t result)
{
  if ((~result & 0xF000000000000007) != 0) {
    return swift_release();
  }
  return result;
}

uint64_t sub_10001BFFC(uint64_t result)
{
  if ((~result & 0xF000000000000007) != 0) {
    return swift_retain();
  }
  return result;
}

uint64_t sub_10001C014()
{
  return _swift_deallocObject(v0, 32, 7);
}

id sub_10001C054(double a1)
{
  return sub_100018770(*(void **)(v1 + 16), *(void *)(v1 + 24), a1);
}

uint64_t sub_10001C05C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_10001C06C()
{
  return swift_release();
}

uint64_t sub_10001C074()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return _swift_deallocObject(v0, 72, 7);
}

id sub_10001C0CC()
{
  return sub_10001885C(*(void **)(v0 + 16), *(void *)(v0 + 24), *(void *)(v0 + 32), *(void *)(v0 + 40), *(void *)(v0 + 48), *(NSString *)(v0 + 56), *(void *)(v0 + 64));
}

uint64_t sub_10001C0F4(uint64_t a1, unint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2)
  {
    self;
    uint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, a2);
  }
  return result;
}

uint64_t sub_10001C130()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return _swift_deallocObject(v0, 80, 7);
}

uint64_t sub_10001C178(Swift::Int a1, Swift::Int a2, uint64_t a3, uint64_t a4)
{
  return sub_100018968(a1, a2, a3, a4, *(void *)(v4 + 16), *(void *)(v4 + 24), *(void *)(v4 + 32), *(void *)(v4 + 40), *(void **)(v4 + 48), *(void ***)(v4 + 56), *(void *)(v4 + 64));
}

uint64_t sub_10001C1B0()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_10001C1C0()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

unint64_t sub_10001C1E8()
{
  unint64_t result = qword_10047D560;
  if (!qword_10047D560)
  {
    sub_10000BAC4(&qword_10047D558);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D560);
  }
  return result;
}

char *sub_10001C24C(void *a1, uint64_t a2)
{
  uint64_t v111 = a2;
  uint64_t v116 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  unint64_t v109 = *(void *)(v116 - 8);
  __chkstk_darwin(v116);
  uint64_t v118 = (uint64_t)&v106 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = sub_100006FC8(&qword_10047D700);
  __chkstk_darwin(v4 - 8);
  uint64_t v117 = (char *)&v106 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = sub_100006FC8(&qword_10047D708);
  uint64_t v7 = __chkstk_darwin(v6 - 8);
  Swift::String v113 = (unsigned int (**)(uint64_t, uint64_t, uint64_t))((char *)&v106 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v106 - v9;
  uint64_t v11 = type metadata accessor for Date();
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = __chkstk_darwin(v11);
  BOOL v15 = (char *)&v106 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = __chkstk_darwin(v13);
  id v18 = (char *)&v106 - v17;
  __chkstk_darwin(v16);
  id v20 = (char *)&v106 - v19;
  unint64_t v114 = a1;
  id v21 = [a1 start];
  uint64_t v115 = v11;
  uint64_t v108 = v12;
  if (!v21)
  {
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 56))(v10, 1, 1, v11);
    goto LABEL_7;
  }
  id v22 = v21;
  uint64_t v112 = v15;
  static Date._unconditionallyBridgeFromObjectiveC(_:)();

  id v23 = *(void (**)(char *, char *, uint64_t))(v12 + 32);
  v23(v10, v18, v11);
  id v24 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 56);
  v24(v10, 0, 1, v11);
  id v25 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v12 + 48);
  if (v25(v10, 1, v11) == 1)
  {
LABEL_7:
    sub_10001E2A0((uint64_t)v10, &qword_10047D708);
    uint64_t v35 = v110;
    uint64_t v31 = (uint64_t)v117;
    uint64_t v38 = v108;
    goto LABEL_10;
  }
  uint64_t v107 = v20;
  uint64_t v26 = v115;
  ((void (*)(char *, char *))v23)(v20, v10);
  id v27 = [v114 end];
  if (v27)
  {
    NSString v28 = v27;
    static Date._unconditionallyBridgeFromObjectiveC(_:)();

    uint64_t v29 = (uint64_t)v113;
    v23((char *)v113, v18, v26);
    v24((char *)v29, 0, 1, v26);
    unsigned int v30 = v25((char *)v29, 1, v26);
    uint64_t v31 = (uint64_t)v117;
    if (v30 != 1)
    {
      id v32 = v112;
      uint64_t v33 = v26;
      v23(v112, (char *)v29, v26);
      id v34 = v107;
      uint64_t v35 = v110;
      uint64_t v36 = (char *)v110 + OBJC_IVAR____TtC7backupd19MBRestoreSummarizer__assetFetchDuration;
      swift_beginAccess();
      id v37 = &v36[*(int *)(type metadata accessor for _MillisecondSegmentedDuration(0) + 24)];
      *(void *)id v37 = 0;
      v37[8] = 1;
      sub_10001E1A0();
      IndexSet.insert(integersIn:)();
      swift_endAccess();
      uint64_t v38 = v108;
      id v39 = *(void (**)(char *, uint64_t))(v108 + 8);
      v39(v32, v33);
      v39(v34, v33);
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v29 = (uint64_t)v113;
    v24((char *)v113, 1, 1, v26);
    uint64_t v31 = (uint64_t)v117;
  }
  uint64_t v38 = v108;
  (*(void (**)(char *, uint64_t))(v108 + 8))(v107, v26);
  sub_10001E2A0(v29, &qword_10047D708);
  uint64_t v35 = v110;
LABEL_10:
  id v40 = v114;
  unint64_t result = (char *)[v114 fetchedAssetBytes];
  uint64_t v42 = v35[3];
  BOOL v43 = __CFADD__(v42, result);
  unsigned int v44 = &result[v42];
  if (v43)
  {
LABEL_48:
    __break(1u);
    goto LABEL_49;
  }
  v35[3] = v44;
  unint64_t result = (char *)[v40 fetchedAssetCount];
  uint64_t v45 = v35[4];
  BOOL v43 = __CFADD__(v45, result);
  uint64_t v46 = &result[v45];
  if (v43)
  {
LABEL_49:
    __break(1u);
LABEL_50:
    __break(1u);
    goto LABEL_51;
  }
  v35[4] = v46;
  uint64_t v47 = (char **)(v111 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_durations);
  swift_beginAccess();
  id v48 = *v47;
  uint64_t v49 = *((void *)*v47 + 2);
  uint64_t v107 = *v47;
  if (v49)
  {
    uint64_t v50 = (uint64_t)v35 + OBJC_IVAR____TtC7backupd19MBRestoreSummarizer__restorablePlacementDuration;
    uint64_t v51 = (uint64_t)&v48[(*(unsigned __int8 *)(v109 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v109 + 80)];
    unint64_t v52 = v109 + 56;
    uint64_t v112 = *(char **)(v109 + 72);
    Swift::String v113 = (unsigned int (**)(uint64_t, uint64_t, uint64_t))(v109 + 48);
    id v53 = (void (**)(uint64_t, uint64_t, uint64_t))(v38 + 32);
    swift_bridgeObjectRetain();
    unint64_t v114 = (void *)v52;
    unint64_t v109 = v52 & 0xFFFFFFFFFFFFLL | 0xA0D1000000000000;
    uint64_t v54 = v116;
    while (1)
    {
      sub_10001E138(v51, v31);
      BOOL v55 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t))*v114;
      ((void (*)(uint64_t, void, uint64_t, uint64_t))*v114)(v31, 0, 1, v54);
      if ((*v113)(v31, 1, v54) == 1) {
        break;
      }
      uint64_t v56 = *(int *)(v54 + 48);
      uint64_t v57 = v31 + v56;
      uint64_t v58 = v118 + v56;
      uint64_t v59 = v31;
      uint64_t v60 = *v53;
      uint64_t v61 = v115;
      (*v53)(v118, v59, v115);
      v60(v58, v57, v61);
      swift_beginAccess();
      uint64_t v62 = v50 + *(int *)(type metadata accessor for _MillisecondSegmentedDuration(0) + 24);
      *(void *)uint64_t v62 = 0;
      *(unsigned char *)(v62 + 8) = 1;
      unint64_t result = (char *)Date.timeIntervalSince(_:)();
      double v64 = v63 * 1000.0;
      if ((~COERCE__INT64(v63 * 1000.0) & 0x7FF0000000000000) == 0)
      {
        __break(1u);
LABEL_42:
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        __break(1u);
        goto LABEL_48;
      }
      if (v64 <= -9.22337204e18) {
        goto LABEL_42;
      }
      if (v64 >= 9.22337204e18) {
        goto LABEL_43;
      }
      unint64_t result = (char *)Date.timeIntervalSince(_:)();
      double v66 = v65 * 1000.0;
      if ((~*(void *)&v66 & 0x7FF0000000000000) == 0) {
        goto LABEL_44;
      }
      if (v66 <= -9.22337204e18) {
        goto LABEL_45;
      }
      if (v66 >= 9.22337204e18) {
        goto LABEL_46;
      }
      unint64_t result = (char *)(uint64_t)v64;
      if ((uint64_t)v66 < (uint64_t)v64) {
        goto LABEL_47;
      }
      IndexSet.insert(integersIn:)();
      swift_endAccess();
      sub_10001E2A0(v118, (uint64_t *)&unk_10047DE50);
      v51 += (uint64_t)v112;
      --v49;
      uint64_t v54 = v116;
      uint64_t v31 = (uint64_t)v117;
      if (!v49) {
        goto LABEL_25;
      }
    }
  }
  else
  {
    BOOL v55 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v109 + 56);
    swift_bridgeObjectRetain();
    uint64_t v54 = v116;
LABEL_25:
    v55(v31, 1, 1, v54);
  }
  unint64_t result = (char *)swift_bridgeObjectRelease();
  uint64_t v67 = OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_zeroByteFiles;
  uint64_t v68 = v111;
  uint64_t v69 = *(void *)(v111 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_zeroByteFiles);
  uint64_t v70 = *(void *)(v111 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_assetFiles);
  uint64_t v71 = v69 + v70;
  if (__CFADD__(v69, v70)) {
    goto LABEL_50;
  }
  uint64_t v72 = *(void *)(v111 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_directories);
  uint64_t v73 = v71 + v72;
  if (__CFADD__(v71, v72))
  {
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }
  uint64_t v74 = *(void *)(v111 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_symlinks);
  BOOL v43 = __CFADD__(v73, v74);
  uint64_t v75 = v73 + v74;
  if (v43)
  {
LABEL_52:
    __break(1u);
    goto LABEL_53;
  }
  id v76 = v110;
  uint64_t v77 = v110[6];
  BOOL v43 = __CFADD__(v77, v75);
  uint64_t v78 = v77 + v75;
  if (v43)
  {
LABEL_53:
    __break(1u);
    goto LABEL_54;
  }
  v110[6] = v78;
  uint64_t v79 = v76[7];
  BOOL v43 = __CFADD__(v79, v72);
  uint64_t v80 = v79 + v72;
  if (v43)
  {
LABEL_54:
    __break(1u);
    goto LABEL_55;
  }
  v76[7] = v80;
  uint64_t v81 = v76[8];
  BOOL v43 = __CFADD__(v81, v74);
  uint64_t v82 = v81 + v74;
  if (v43)
  {
LABEL_55:
    __break(1u);
    goto LABEL_56;
  }
  v76[8] = v82;
  uint64_t v83 = *(void *)(v68 + v67);
  uint64_t v84 = v76[9];
  BOOL v43 = __CFADD__(v84, v83);
  uint64_t v85 = v84 + v83;
  if (v43)
  {
LABEL_56:
    __break(1u);
    goto LABEL_57;
  }
  v76[9] = v85;
  uint64_t v86 = v76[10];
  BOOL v43 = __CFADD__(v86, v70);
  uint64_t v87 = v86 + v70;
  if (v43)
  {
LABEL_57:
    __break(1u);
    goto LABEL_58;
  }
  v76[10] = v87;
  uint64_t v88 = *(void *)(v68 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks);
  uint64_t v89 = v76[11];
  BOOL v43 = __CFADD__(v89, v88);
  uint64_t v90 = v89 + v88;
  if (v43)
  {
LABEL_58:
    __break(1u);
    goto LABEL_59;
  }
  v76[11] = v90;
  uint64_t v91 = *(void *)(v68 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classAFiles);
  uint64_t v92 = v76[12];
  BOOL v43 = __CFADD__(v92, v91);
  uint64_t v93 = v92 + v91;
  if (v43)
  {
LABEL_59:
    __break(1u);
    goto LABEL_60;
  }
  v76[12] = v93;
  uint64_t v94 = *(void *)(v68 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classBFiles);
  uint64_t v95 = v76[13];
  BOOL v43 = __CFADD__(v95, v94);
  uint64_t v96 = v95 + v94;
  if (v43)
  {
LABEL_60:
    __break(1u);
    goto LABEL_61;
  }
  v76[13] = v96;
  uint64_t v97 = *(void *)(v68 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCFiles);
  uint64_t v98 = v76[14];
  BOOL v43 = __CFADD__(v98, v97);
  uint64_t v99 = v98 + v97;
  if (v43)
  {
LABEL_61:
    __break(1u);
    goto LABEL_62;
  }
  v76[14] = v99;
  uint64_t v100 = *(void *)(v68 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classDFiles);
  uint64_t v101 = v76[15];
  BOOL v43 = __CFADD__(v101, v100);
  uint64_t v102 = v101 + v100;
  if (v43)
  {
LABEL_62:
    __break(1u);
    goto LABEL_63;
  }
  v76[15] = v102;
  uint64_t v103 = *(void *)(v68 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCxFiles);
  uint64_t v104 = v76[16];
  BOOL v43 = __CFADD__(v104, v103);
  uint64_t v105 = v104 + v103;
  if (!v43)
  {
    v76[16] = v105;
    return result;
  }
LABEL_63:
  __break(1u);
  return result;
}

uint64_t sub_10001CBB4()
{
  uint64_t v1 = type metadata accessor for IndexSet.RangeView();
  uint64_t v2 = *(void *)(v1 - 8);
  __chkstk_darwin(v1);
  uint64_t v4 = (char *)&v20 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = sub_100006FC8(&qword_10047D6F0);
  __chkstk_darwin(v5);
  uint64_t v7 = (char *)&v20 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t result = type metadata accessor for _MillisecondSegmentedDuration(0);
  if (*(unsigned char *)(v0 + *(int *)(result + 24) + 8))
  {
    id v21 = (double *)(v0 + *(int *)(result + 24));
    IndexSet.rangeView.getter();
    IndexSet.RangeView.makeIterator()();
    id v22 = *(void (**)(char *, uint64_t))(v2 + 8);
    v22(v4, v1);
    uint64_t v9 = &v7[*(int *)(v5 + 36)];
    sub_10001E084();
    uint64_t v10 = 0;
    uint64_t v23 = v2 + 8;
    uint64_t v11 = (void (**)(char *, char *, uint64_t))(v2 + 16);
    while (1)
    {
      uint64_t v12 = *(void *)v9;
      dispatch thunk of Collection.endIndex.getter();
      if (v12 == v24[0])
      {
        uint64_t result = sub_10001E2A0((uint64_t)v7, &qword_10047D6F0);
        uint64_t v19 = v21;
        double *v21 = (double)v10 / 1000.0;
        *((unsigned char *)v19 + 8) = 0;
        return result;
      }
      uint64_t v13 = (void (*)(uint64_t *, void))dispatch thunk of Collection.subscript.read();
      uint64_t v15 = *v14;
      uint64_t v16 = v14[1];
      v13(v24, 0);
      (*v11)(v4, v7, v1);
      dispatch thunk of Collection.formIndex(after:)();
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v22)(v4, v1);
      uint64_t v17 = v16 - v15;
      if (__OFSUB__(v16, v15)) {
        break;
      }
      BOOL v18 = __OFADD__(v10, v17);
      v10 += v17;
      if (v18)
      {
        __break(1u);
        return result;
      }
    }
    __break(1u);
  }
  return result;
}

uint64_t sub_10001CE24()
{
  sub_10001E0DC(v0 + OBJC_IVAR____TtC7backupd19MBRestoreSummarizer__assetFetchDuration);
  sub_10001E0DC(v0 + OBJC_IVAR____TtC7backupd19MBRestoreSummarizer__restorablePlacementDuration);
  return swift_deallocClassInstance();
}

uint64_t sub_10001CE98()
{
  return type metadata accessor for MBRestoreSummarizer(0);
}

uint64_t type metadata accessor for MBRestoreSummarizer(uint64_t a1)
{
  return sub_10001CF7C(a1, qword_10047D5B0);
}

uint64_t sub_10001CEC0()
{
  uint64_t result = type metadata accessor for _MillisecondSegmentedDuration(319);
  if (v1 <= 0x3F)
  {
    uint64_t result = swift_updateClassMetadata2();
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t type metadata accessor for _MillisecondSegmentedDuration(uint64_t a1)
{
  return sub_10001CF7C(a1, qword_10047D6A0);
}

uint64_t sub_10001CF7C(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata();
  }
  return result;
}

__n128 initializeWithCopy for MBRestoreSummary(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __n128 result = (__n128)a2[4];
  long long v6 = a2[5];
  long long v7 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(_OWORD *)(a1 + 80) = v6;
  *(_OWORD *)(a1 + 96) = v7;
  *(__n128 *)(a1 + 64) = result;
  return result;
}

uint64_t getEnumTagSinglePayload for MBRestoreSummary(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 120)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for MBRestoreSummary(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 120) = v3;
  return result;
}

ValueMetadata *type metadata accessor for MBRestoreSummary()
{
  return &type metadata for MBRestoreSummary;
}

uint64_t *sub_10001D058(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v15 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v15 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    uint64_t v7 = type metadata accessor for Date();
    (*(void (**)(uint64_t *, uint64_t *, uint64_t))(*(void *)(v7 - 8) + 16))(a1, a2, v7);
    uint64_t v8 = *(int *)(a3 + 20);
    uint64_t v9 = (char *)a1 + v8;
    uint64_t v10 = (char *)a2 + v8;
    uint64_t v11 = type metadata accessor for IndexSet();
    (*(void (**)(char *, char *, uint64_t))(*(void *)(v11 - 8) + 16))(v9, v10, v11);
    uint64_t v12 = *(int *)(a3 + 24);
    uint64_t v13 = (char *)a1 + v12;
    uint64_t v14 = (char *)a2 + v12;
    *(void *)uint64_t v13 = *(void *)v14;
    v13[8] = v14[8];
  }
  return a1;
}

uint64_t sub_10001D184(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for Date();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(a1, v4);
  uint64_t v5 = a1 + *(int *)(a2 + 20);
  uint64_t v6 = type metadata accessor for IndexSet();
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8);
  return v7(v5, v6);
}

uint64_t sub_10001D22C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for Date();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16))(a1, a2, v6);
  uint64_t v7 = *(int *)(a3 + 20);
  uint64_t v8 = a1 + v7;
  uint64_t v9 = a2 + v7;
  uint64_t v10 = type metadata accessor for IndexSet();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 16))(v8, v9, v10);
  uint64_t v11 = *(int *)(a3 + 24);
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  *(void *)uint64_t v12 = *(void *)v13;
  *(unsigned char *)(v12 + 8) = *(unsigned char *)(v13 + 8);
  return a1;
}

uint64_t sub_10001D308(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for Date();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 24))(a1, a2, v6);
  uint64_t v7 = *(int *)(a3 + 20);
  uint64_t v8 = a1 + v7;
  uint64_t v9 = a2 + v7;
  uint64_t v10 = type metadata accessor for IndexSet();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 24))(v8, v9, v10);
  uint64_t v11 = *(int *)(a3 + 24);
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  char v14 = *(unsigned char *)(v13 + 8);
  *(void *)uint64_t v12 = *(void *)v13;
  *(unsigned char *)(v12 + 8) = v14;
  return a1;
}

uint64_t sub_10001D3E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for Date();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 32))(a1, a2, v6);
  uint64_t v7 = *(int *)(a3 + 20);
  uint64_t v8 = a1 + v7;
  uint64_t v9 = a2 + v7;
  uint64_t v10 = type metadata accessor for IndexSet();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 32))(v8, v9, v10);
  uint64_t v11 = *(int *)(a3 + 24);
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  *(void *)uint64_t v12 = *(void *)v13;
  *(unsigned char *)(v12 + 8) = *(unsigned char *)(v13 + 8);
  return a1;
}

uint64_t sub_10001D4C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for Date();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 40))(a1, a2, v6);
  uint64_t v7 = *(int *)(a3 + 20);
  uint64_t v8 = a1 + v7;
  uint64_t v9 = a2 + v7;
  uint64_t v10 = type metadata accessor for IndexSet();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 40))(v8, v9, v10);
  uint64_t v11 = *(int *)(a3 + 24);
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  *(void *)uint64_t v12 = *(void *)v13;
  *(unsigned char *)(v12 + 8) = *(unsigned char *)(v13 + 8);
  return a1;
}

uint64_t sub_10001D59C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_10001D5B0);
}

uint64_t sub_10001D5B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for Date();
  uint64_t v7 = *(void *)(v6 - 8);
  if (*(_DWORD *)(v7 + 84) == a2)
  {
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    return v8(a1, a2, v6);
  }
  else
  {
    uint64_t v10 = type metadata accessor for IndexSet();
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 48);
    uint64_t v12 = v10;
    uint64_t v13 = a1 + *(int *)(a3 + 20);
    return v11(v13, a2, v12);
  }
}

uint64_t sub_10001D6A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_10001D6BC);
}

uint64_t sub_10001D6BC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Date();
  uint64_t v9 = *(void *)(v8 - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
    return v10(a1, a2, a2, v8);
  }
  else
  {
    uint64_t v12 = type metadata accessor for IndexSet();
    uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56);
    uint64_t v14 = v12;
    uint64_t v15 = a1 + *(int *)(a4 + 20);
    return v13(v15, a2, a2, v14);
  }
}

uint64_t sub_10001D7C0()
{
  uint64_t result = type metadata accessor for Date();
  if (v1 <= 0x3F)
  {
    uint64_t result = type metadata accessor for IndexSet();
    if (v2 <= 0x3F)
    {
      swift_initStructMetadata();
      return 0;
    }
  }
  return result;
}

uint64_t sub_10001D890()
{
  uint64_t v1 = v0;
  _StringGuts.grow(_:)(44);
  sub_100006FC8((uint64_t *)&unk_10047D8F0);
  uint64_t v2 = swift_allocObject();
  *(_OWORD *)(v2 + 16) = xmmword_1003B1EF0;
  double v3 = *(double *)v0;
  double v4 = (double)*(unint64_t *)(v1 + 8) / *(double *)v1 * 0.000000953674316;
  *(void *)(v2 + 56) = &type metadata for Double;
  *(void *)(v2 + 64) = &protocol witness table for Double;
  *(double *)(v2 + 32) = v4;
  uint64_t v5 = String.init(format:_:)();
  swift_bridgeObjectRelease();
  v6._countAndFlagsBits = 0x2C6365732F424D20;
  v6._object = (void *)0xE900000000000020;
  String.append(_:)(v6);
  uint64_t v7 = swift_allocObject();
  *(_OWORD *)(v7 + 16) = xmmword_1003B1EF0;
  double v8 = (double)*(unint64_t *)(v0 + 16) / v3;
  *(void *)(v7 + 56) = &type metadata for Double;
  *(void *)(v7 + 64) = &protocol witness table for Double;
  *(double *)(v7 + 32) = v8;
  v9._countAndFlagsBits = String.init(format:_:)();
  String.append(_:)(v9);
  swift_bridgeObjectRelease();
  v10._countAndFlagsBits = 0x2F73746573736120;
  v10._object = (void *)0xED0000202C636573;
  String.append(_:)(v10);
  uint64_t v11 = swift_allocObject();
  *(_OWORD *)(v11 + 16) = xmmword_1003B1EF0;
  double v12 = (double)*(unint64_t *)(v1 + 32) / *(double *)(v1 + 24);
  *(void *)(v11 + 56) = &type metadata for Double;
  *(void *)(v11 + 64) = &protocol witness table for Double;
  *(double *)(v11 + 32) = v12;
  v13._countAndFlagsBits = String.init(format:_:)();
  String.append(_:)(v13);
  swift_bridgeObjectRelease();
  v14._object = (void *)0x8000000100305130;
  v14._countAndFlagsBits = 0xD000000000000010;
  String.append(_:)(v14);
  return v5;
}

unint64_t sub_10001DA94(char a1)
{
  unint64_t result = 0xD000000000000017;
  switch(a1)
  {
    case 1:
      unint64_t result = 0xD000000000000011;
      break;
    case 2:
      unint64_t result = 0xD000000000000012;
      break;
    case 3:
      unint64_t result = 0xD000000000000020;
      break;
    case 4:
      unint64_t result = 0xD000000000000016;
      break;
    case 5:
      unint64_t result = 0xD000000000000016;
      break;
    case 6:
      unint64_t result = 0xD000000000000013;
      break;
    case 7:
      unint64_t result = 0xD000000000000018;
      break;
    case 8:
      unint64_t result = 0xD000000000000011;
      break;
    case 9:
      unint64_t result = 0xD000000000000014;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
      unint64_t result = 0xD000000000000010;
      break;
    case 14:
      unint64_t result = 0xD000000000000011;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_10001DBFC(void *a1)
{
  uint64_t v3 = sub_100006FC8(&qword_10047D6E0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  Swift::String v6 = &v8[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_10000700C(a1, a1[3]);
  sub_10001E030();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v8[15] = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v1)
  {
    v8[14] = 1;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[13] = 2;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[12] = 3;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[11] = 4;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[10] = 5;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[9] = 6;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[8] = 7;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[7] = 8;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[6] = 9;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[5] = 10;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[4] = 11;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[3] = 12;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[2] = 13;
    KeyedEncodingContainer.encode(_:forKey:)();
    v8[1] = 14;
    KeyedEncodingContainer.encode(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v4 + 8))(v6, v3);
}

unint64_t sub_10001DF64()
{
  return sub_10001DA94(*v0);
}

uint64_t sub_10001DF6C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = sub_10001E598(a1, a2);
  *a3 = result;
  return result;
}

void sub_10001DF94(unsigned char *a1@<X8>)
{
  *a1 = 15;
}

uint64_t sub_10001DFA0(uint64_t a1)
{
  unint64_t v2 = sub_10001E030();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_10001DFDC(uint64_t a1)
{
  unint64_t v2 = sub_10001E030();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_10001E018(void *a1)
{
  return sub_10001DBFC(a1);
}

unint64_t sub_10001E030()
{
  unint64_t result = qword_10047D6E8;
  if (!qword_10047D6E8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D6E8);
  }
  return result;
}

unint64_t sub_10001E084()
{
  unint64_t result = qword_10047D6F8;
  if (!qword_10047D6F8)
  {
    type metadata accessor for IndexSet.RangeView();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D6F8);
  }
  return result;
}

uint64_t sub_10001E0DC(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for _MillisecondSegmentedDuration(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_10001E138(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_10001E1A0()
{
  uint64_t result = Date.timeIntervalSince(_:)();
  double v2 = v1 * 1000.0;
  if ((~COERCE__INT64(v1 * 1000.0) & 0x7FF0000000000000) == 0)
  {
    __break(1u);
    goto LABEL_10;
  }
  if (v2 <= -9.22337204e18)
  {
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }
  if (v2 >= 9.22337204e18)
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }
  uint64_t result = Date.timeIntervalSince(_:)();
  double v4 = v3 * 1000.0;
  if ((~*(void *)&v4 & 0x7FF0000000000000) == 0)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }
  if (v4 <= -9.22337204e18)
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }
  if (v4 >= 9.22337204e18)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  uint64_t result = (uint64_t)v2;
  if ((uint64_t)v4 < (uint64_t)v2) {
LABEL_15:
  }
    __break(1u);
  return result;
}

uint64_t sub_10001E2A0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = sub_100006FC8(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t getEnumTagSinglePayload for MBRestoreSummary.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xF2) {
    goto LABEL_17;
  }
  if (a2 + 14 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 14) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 14;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 14;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 14;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0xF;
  int v8 = v6 - 15;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBRestoreSummary.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 14 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 14) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF2) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF1)
  {
    unsigned int v6 = ((a2 - 242) >> 8) + 1;
    *uint64_t result = a2 + 14;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x10001E458);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 14;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBRestoreSummary.CodingKeys()
{
  return &type metadata for MBRestoreSummary.CodingKeys;
}

unint64_t sub_10001E494()
{
  unint64_t result = qword_10047D710;
  if (!qword_10047D710)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D710);
  }
  return result;
}

unint64_t sub_10001E4EC()
{
  unint64_t result = qword_10047D718;
  if (!qword_10047D718)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D718);
  }
  return result;
}

unint64_t sub_10001E544()
{
  unint64_t result = qword_10047D720;
  if (!qword_10047D720)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D720);
  }
  return result;
}

uint64_t sub_10001E598(uint64_t a1, uint64_t a2)
{
  if (a1 == 0xD000000000000017 && a2 == 0x8000000100305150
    || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x8000000100305170 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x8000000100305190 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0xD000000000000020 && a2 == 0x80000001003051B0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 0xD000000000000016 && a2 == 0x80000001003051E0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else if (a1 == 0xD000000000000016 && a2 == 0x8000000100305200 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 5;
  }
  else if (a1 == 0xD000000000000013 && a2 == 0x8000000100305220 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 6;
  }
  else if (a1 == 0xD000000000000018 && a2 == 0x8000000100305240 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 7;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x8000000100305260 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 8;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x8000000100305280 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 9;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x80000001003052A0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 10;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x80000001003052C0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 11;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x80000001003052E0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 12;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x8000000100305300 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 13;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x8000000100305320)
  {
    swift_bridgeObjectRelease();
    return 14;
  }
  else
  {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v5) {
      return 14;
    }
    else {
      return 15;
    }
  }
}

uint64_t sub_10001EAD8(uint64_t a1, uint64_t a2)
{
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v8 = a2;
  sub_100021B28(a1, (uint64_t)sub_100021AD4, 0, isUniquelyReferenced_nonNull_native, (uint64_t)&v8);
  uint64_t v6 = v8;
  swift_bridgeObjectRelease();
  if (v2) {
    swift_bridgeObjectRelease();
  }
  return v6;
}

id sub_10001EB64()
{
  id result = [objc_allocWithZone((Class)type metadata accessor for MBActivityScheduler()) init];
  qword_10047D728 = (uint64_t)result;
  return result;
}

id sub_10001EBF0()
{
  uint64_t ObjectType = swift_getObjectType();
  uint64_t v2 = type metadata accessor for OS_dispatch_queue.Attributes();
  __chkstk_darwin(v2);
  unsigned int v4 = (char *)&v46 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = type metadata accessor for DispatchQoS();
  __chkstk_darwin(v5 - 8);
  uint64_t v6 = type metadata accessor for OS_dispatch_queue.AutoreleaseFrequency();
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  Swift::String v9 = (char *)&v46 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  Swift::String v10 = self;
  uint64_t v11 = v0;
  id result = [v10 sharedInstance];
  if (!result) {
    goto LABEL_23;
  }
  Swift::String v13 = result;
  id v14 = [result dryRestoreManager];

  id v55 = v4;
  uint64_t v56 = (char *)v2;
  uint64_t v15 = (objc_class *)ObjectType;
  if (v14)
  {
    uint64_t v16 = sub_1000551D8();
  }
  else
  {
    uint64_t v16 = 0;
  }
  *(void *)&v11[OBJC_IVAR____TtC7backupd19MBActivityScheduler__dryRestoreActivity] = v16;
  uint64_t v17 = OBJC_IVAR____TtC7backupd19MBActivityScheduler__activitiesByIdentifier;
  *(void *)&v11[v17] = sub_100049254((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v54 = OBJC_IVAR____TtC7backupd19MBActivityScheduler__workQueue;
  sub_1000224B0();
  id v18 = [(id)swift_getObjCClassFromMetadata() description];
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  (*(void (**)(char *, void, uint64_t))(v7 + 104))(v9, enum case for OS_dispatch_queue.AutoreleaseFrequency.workItem(_:), v6);
  static DispatchQoS.unspecified.getter();
  long long aBlock = (void **)&_swiftEmptyArrayStorage;
  sub_1000224F0();
  sub_100006FC8(&qword_10047D7A8);
  sub_100022548();
  dispatch thunk of SetAlgebra.init<A>(_:)();
  *(void *)&v11[v54] = OS_dispatch_queue.init(label:qos:attributes:autoreleaseFrequency:target:)();

  v62.receiver = v11;
  v62.super_class = v15;
  uint64_t v19 = (char *)objc_msgSendSuper2(&v62, "init");
  uint64_t v20 = v19;
  unint64_t v61 = (unint64_t)&_swiftEmptyArrayStorage;
  if (*(void *)&v19[OBJC_IVAR____TtC7backupd19MBActivityScheduler__dryRestoreActivity])
  {
    swift_retain_n();
    id v21 = v20;
    specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
    if (*(void *)((v61 & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((v61 & 0xFFFFFFFFFFFFFF8) + 0x18) >> 1) {
      specialized Array._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    }
    specialized Array._appendElementAssumeUniqueAndCapacity(_:newElement:)();
    specialized Array._endMutation()();
    swift_release();
    unint64_t v22 = v61;
  }
  else
  {
    uint64_t v23 = v19;
    unint64_t v22 = (unint64_t)&_swiftEmptyArrayStorage;
  }
  uint64_t v56 = v20;
  if (v22 >> 62)
  {
    swift_bridgeObjectRetain();
    uint64_t v24 = _CocoaArrayWrapper.endIndex.getter();
    swift_bridgeObjectRelease();
    if (v24) {
      goto LABEL_12;
    }
LABEL_21:
    swift_bridgeObjectRelease();
    uint64_t v42 = v56;
    sub_10001FBD4();
    sub_100006FC8(&qword_10047D4E8);
    uint64_t v43 = Dictionary.description.getter();
    unint64_t v45 = v44;
    swift_bridgeObjectRelease();
    sub_100045F18(v43, v45, 0xD000000000000011, 0x8000000100305450);
    swift_bridgeObjectRelease();

    return v42;
  }
  uint64_t v24 = *(void *)((v22 & 0xFFFFFFFFFFFFFF8) + 0x10);
  if (!v24) {
    goto LABEL_21;
  }
LABEL_12:
  id result = self;
  id v55 = result;
  if (v24 >= 1)
  {
    uint64_t v25 = 0;
    uint64_t v49 = &v56[OBJC_IVAR____TtC7backupd19MBActivityScheduler__activitiesByIdentifier];
    unint64_t v51 = v22 & 0xC000000000000001;
    uint64_t v52 = OBJC_IVAR____TtC7backupd19MBActivityScheduler__workQueue;
    uint64_t v50 = v60;
    unint64_t v48 = 0x80000001003055E0;
    unint64_t v47 = 0x8000000100305450;
    uint64_t v53 = v24;
    uint64_t v54 = v22;
    uint64_t v26 = v56;
    do
    {
      if (v51)
      {
        uint64_t v29 = (void *)specialized _ArrayBuffer._getElementSlowPath(_:)();
      }
      else
      {
        uint64_t v29 = *(void **)(v22 + 8 * v25 + 32);
        swift_unknownObjectRetain();
      }
      id v30 = [v29 identifier];
      uint64_t v31 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      uint64_t v33 = v32;

      swift_unknownObjectRetain();
      id v34 = [v55 sharedScheduler];
      NSString v35 = String._bridgeToObjectiveC()();
      uint64_t v36 = *(void *)&v26[v52];
      uint64_t v37 = swift_allocObject();
      *(void *)(v37 + 16) = v26;
      *(void *)(v37 + 24) = v29;
      v60[2] = sub_1000225A8;
      v60[3] = v37;
      long long aBlock = _NSConcreteStackBlock;
      unint64_t v59 = 1107296256;
      v60[0] = sub_10002064C;
      v60[1] = &unk_10040FE60;
      uint64_t v38 = _Block_copy(&aBlock);
      id v39 = v26;
      swift_unknownObjectRetain();
      swift_release();
      unsigned __int8 v40 = [v34 registerForTaskWithIdentifier:v35 usingQueue:v36 launchHandler:v38];
      _Block_release(v38);

      if ((v40 & 1) == 0)
      {
        long long aBlock = 0;
        unint64_t v59 = 0xE000000000000000;
        _StringGuts.grow(_:)(26);
        swift_bridgeObjectRelease();
        long long aBlock = (void **)0xD000000000000018;
        unint64_t v59 = v48;
        v41._countAndFlagsBits = v31;
        v41._object = v33;
        String.append(_:)(v41);
        sub_1000467F0(1, (uint64_t)aBlock, v59, 0xD000000000000011, v47);
        swift_bridgeObjectRelease();
        swift_errorRelease();
      }
      ++v25;
      id v27 = v49;
      swift_beginAccess();
      swift_unknownObjectRetain();
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v57 = *(void *)v27;
      *(void *)id v27 = 0x8000000000000000;
      sub_100032CBC((uint64_t)v29, v31, (uint64_t)v33, isUniquelyReferenced_nonNull_native);
      *(void *)id v27 = v57;
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_endAccess();
      sub_10001F338(v29);
      swift_unknownObjectRelease_n();
      unint64_t v22 = v54;
    }
    while (v53 != v25);
    goto LABEL_21;
  }
  __break(1u);
LABEL_23:
  __break(1u);
  return result;
}

void sub_10001F338(void *a1)
{
  id v1 = [a1 identifier];
  uint64_t v2 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  unsigned int v4 = v3;
  uint64_t v5 = self;
  id v6 = v1;
  id v7 = [v5 sharedScheduler];
  strcpy((char *)v46, "Rescheduling ");
  HIWORD(v46[1]) = -4864;
  v8._countAndFlagsBits = v2;
  v8._object = v4;
  String.append(_:)(v8);
  sub_100045F18((uint64_t)v46[0], (unint64_t)v46[1], 0xD000000000000011, 0x8000000100305450);
  swift_bridgeObjectRelease();
  id v9 = [v7 taskRequestForIdentifier:v6];
  uint64_t v43 = v6;

  if (v9)
  {
    id v41 = v9;
    _StringGuts.grow(_:)(34);
    swift_bridgeObjectRelease();
    v46[0] = (id)0x786520646E756F46;
    v10._countAndFlagsBits = v2;
    v10._object = v4;
    String.append(_:)(v10);
    v11._countAndFlagsBits = 0x6572206B73617420;
    v11._object = (void *)0xEF203A7473657571;
    String.append(_:)(v11);
    id v12 = [v41 propertyListRepresentation];
    static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v40 = 0x8000000100305450;

    v13._countAndFlagsBits = Dictionary.description.getter();
    String.append(_:)(v13);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_100045F18(0x786520646E756F46, 0xEF20676E69747369, 0xD000000000000011, 0x8000000100305450);

    swift_bridgeObjectRelease();
  }
  id v14 = objc_msgSend(a1, "workQueue", v40);
  __chkstk_darwin(v14);
  sub_100006FC8(&qword_10047D788);
  OS_dispatch_queue.sync<A>(execute:)();

  id v15 = v46[0];
  if (v46[0])
  {
    if (!v9 || v9 != v46[0])
    {
      if (!v9)
      {
        uint64_t v45 = v2;

        goto LABEL_11;
      }
LABEL_9:
      uint64_t v16 = v2;
      id v17 = v9;
      _StringGuts.grow(_:)(39);
      swift_bridgeObjectRelease();
      v46[1] = (id)0x8000000100305500;
      uint64_t v45 = v16;
      v18._countAndFlagsBits = v16;
      uint64_t v42 = v4;
      v18._object = v4;
      String.append(_:)(v18);
      v19._countAndFlagsBits = 0x6572206B73617420;
      v19._object = (void *)0xEF203A7473657571;
      String.append(_:)(v19);
      id v20 = [v17 propertyListRepresentation];
      static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();

      v21._countAndFlagsBits = Dictionary.description.getter();
      String.append(_:)(v21);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      sub_100045F18(0xD000000000000014, 0x8000000100305500, 0xD000000000000011, 0x8000000100305450);
      swift_bridgeObjectRelease();
      v46[0] = 0;
      LOBYTE(v20) = [v7 cancelTaskRequestWithIdentifier:v43 error:v46];

      id v22 = v46[0];
      if ((v20 & 1) == 0)
      {
LABEL_15:
        id v33 = v22;
        uint64_t v34 = _convertNSErrorToError(_:)();

        swift_willThrow();
        v46[0] = 0;
        v46[1] = (id)0xE000000000000000;
        _StringGuts.grow(_:)(35);
        swift_bridgeObjectRelease();
        v46[0] = (id)0xD000000000000011;
        v46[1] = (id)0x80000001003054E0;
        v35._countAndFlagsBits = v45;
        v35._object = v42;
        String.append(_:)(v35);
        swift_bridgeObjectRelease();
        v36._countAndFlagsBits = 0x6572206B73617420;
        v36._object = (void *)0xEE00207473657571;
        String.append(_:)(v36);
        if (v15)
        {
          id v37 = [v15 propertyListRepresentation];
          static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();
        }
        sub_100006FC8(&qword_10047D790);
        v39._countAndFlagsBits = String.init<A>(describing:)();
        String.append(_:)(v39);
        swift_bridgeObjectRelease();
        sub_1000462C4(v34, (uint64_t)v46[0], (unint64_t)v46[1], 0xD000000000000011, 0x8000000100305450);
        swift_bridgeObjectRelease();

        swift_errorRelease();
        return;
      }
      id v23 = v46[0];

      if (!v15)
      {
        swift_bridgeObjectRelease();

        return;
      }
LABEL_11:
      uint64_t v42 = v4;
      v46[0] = 0;
      v46[1] = (id)0xE000000000000000;
      id v17 = v15;
      _StringGuts.grow(_:)(34);
      swift_bridgeObjectRelease();
      v46[0] = (id)0x697474696D627553;
      v46[1] = (id)0xEF2077656E20676ELL;
      v24._countAndFlagsBits = v45;
      v24._object = v4;
      String.append(_:)(v24);
      v25._countAndFlagsBits = 0x6572206B73617420;
      v25._object = (void *)0xEF203A7473657571;
      String.append(_:)(v25);
      id v26 = [v17 propertyListRepresentation];
      static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();

      v27._countAndFlagsBits = Dictionary.description.getter();
      String.append(_:)(v27);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      sub_100045F18((uint64_t)v46[0], (unint64_t)v46[1], 0xD000000000000011, 0x8000000100305450);
      swift_bridgeObjectRelease();
      v46[0] = 0;
      unsigned __int8 v28 = [v7 submitTaskRequest:v17 error:v46];
      id v22 = v46[0];
      if (v28)
      {
        id v29 = v46[0];
        swift_bridgeObjectRelease();

        return;
      }
      goto LABEL_15;
    }
  }
  else if (v9)
  {
    goto LABEL_9;
  }

  _StringGuts.grow(_:)(36);
  swift_bridgeObjectRelease();
  v46[0] = (id)0xD000000000000011;
  v46[1] = (id)0x8000000100305520;
  v30._countAndFlagsBits = v2;
  v30._object = v4;
  String.append(_:)(v30);
  swift_bridgeObjectRelease();
  v31._countAndFlagsBits = 0x6572206B73617420;
  v31._object = (void *)0xEF203A7473657571;
  String.append(_:)(v31);
  if (v15)
  {
    id v32 = [v15 propertyListRepresentation];
    static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();
  }
  sub_100006FC8(&qword_10047D790);
  v38._countAndFlagsBits = String.init<A>(describing:)();
  String.append(_:)(v38);
  swift_bridgeObjectRelease();
  sub_100045F18((uint64_t)v46[0], (unint64_t)v46[1], 0xD000000000000011, 0x8000000100305450);

  swift_bridgeObjectRelease();
}

uint64_t sub_10001FBD4()
{
  id v1 = [self sharedScheduler];
  unint64_t v40 = sub_100049138((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v2 = (uint64_t *)(v0 + OBJC_IVAR____TtC7backupd19MBActivityScheduler__activitiesByIdentifier);
  swift_beginAccess();
  uint64_t v3 = *v2;
  uint64_t v4 = *v2 + 64;
  uint64_t v5 = 1 << *(unsigned char *)(*v2 + 32);
  uint64_t v6 = -1;
  if (v5 < 64) {
    uint64_t v6 = ~(-1 << v5);
  }
  unint64_t v7 = v6 & *(void *)(*v2 + 64);
  int64_t v8 = (unint64_t)(v5 + 63) >> 6;
  swift_bridgeObjectRetain();
  int64_t v9 = 0;
  uint64_t v38 = v4;
  int64_t v37 = v8;
  if (!v7) {
    goto LABEL_7;
  }
LABEL_4:
  unint64_t v10 = __clz(__rbit64(v7));
  v7 &= v7 - 1;
  for (unint64_t i = v10 | (v9 << 6); ; unint64_t i = __clz(__rbit64(v18)) + (v9 << 6))
  {
    id v12 = (uint64_t *)(*(void *)(v3 + 48) + 16 * i);
    uint64_t v14 = *v12;
    uint64_t v13 = v12[1];
    swift_bridgeObjectRetain();
    NSString v15 = String._bridgeToObjectiveC()();
    id v16 = [v1 taskRequestForIdentifier:v15];

    if (v16)
    {
      id v20 = [v16 propertyListRepresentation];
      uint64_t v39 = static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();

      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v42 = (void *)v40;
      unint64_t v23 = sub_100031554(v14, v13);
      uint64_t v24 = *(void *)(v40 + 16);
      BOOL v25 = (v22 & 1) == 0;
      uint64_t v26 = v24 + v25;
      if (__OFADD__(v24, v25)) {
        goto LABEL_36;
      }
      if (*(void *)(v40 + 24) >= v26)
      {
        if ((isUniquelyReferenced_nonNull_native & 1) == 0)
        {
          char v35 = v22;
          sub_100033328();
          char v22 = v35;
        }
      }
      else
      {
        char v41 = v22;
        sub_100031ED8(v26, isUniquelyReferenced_nonNull_native);
        unint64_t v27 = sub_100031554(v14, v13);
        int v29 = v28 & 1;
        char v22 = v41;
        if ((v41 & 1) != v29) {
          goto LABEL_38;
        }
        unint64_t v23 = v27;
      }
      unint64_t v40 = (unint64_t)v42;
      if (v22)
      {
        uint64_t v30 = v42[7];
        swift_bridgeObjectRelease();
        *(void *)(v30 + 8 * v23) = v39;
      }
      else
      {
        v42[(v23 >> 6) + 8] |= 1 << v23;
        Swift::String v31 = (uint64_t *)(v42[6] + 16 * v23);
        *Swift::String v31 = v14;
        v31[1] = v13;
        *(void *)(v42[7] + 8 * v23) = v39;
        uint64_t v32 = v42[2];
        BOOL v33 = __OFADD__(v32, 1);
        uint64_t v34 = v32 + 1;
        if (v33) {
          goto LABEL_37;
        }
        v42[2] = v34;
        swift_bridgeObjectRetain();
      }

      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      int64_t v8 = v37;
      uint64_t v4 = v38;
      if (v7) {
        goto LABEL_4;
      }
    }
    else
    {
      swift_bridgeObjectRelease();
      if (v7) {
        goto LABEL_4;
      }
    }
LABEL_7:
    int64_t v17 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_35;
    }
    if (v17 >= v8) {
      goto LABEL_33;
    }
    unint64_t v18 = *(void *)(v4 + 8 * v17);
    ++v9;
    if (!v18)
    {
      int64_t v9 = v17 + 1;
      if (v17 + 1 >= v8) {
        goto LABEL_33;
      }
      unint64_t v18 = *(void *)(v4 + 8 * v9);
      if (!v18)
      {
        int64_t v9 = v17 + 2;
        if (v17 + 2 >= v8) {
          goto LABEL_33;
        }
        unint64_t v18 = *(void *)(v4 + 8 * v9);
        if (!v18) {
          break;
        }
      }
    }
LABEL_20:
    unint64_t v7 = (v18 - 1) & v18;
  }
  int64_t v19 = v17 + 3;
  if (v19 >= v8)
  {
LABEL_33:

    swift_release();
    return v40;
  }
  unint64_t v18 = *(void *)(v4 + 8 * v19);
  if (v18)
  {
    int64_t v9 = v19;
    goto LABEL_20;
  }
  while (1)
  {
    int64_t v9 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      break;
    }
    if (v9 >= v8) {
      goto LABEL_33;
    }
    unint64_t v18 = *(void *)(v4 + 8 * v9);
    ++v19;
    if (v18) {
      goto LABEL_20;
    }
  }
LABEL_35:
  __break(1u);
LABEL_36:
  __break(1u);
LABEL_37:
  __break(1u);
LABEL_38:
  uint64_t result = KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
  __break(1u);
  return result;
}

uint64_t sub_10001FF80(void *a1, char *a2, void *a3)
{
  uint64_t v6 = type metadata accessor for DispatchPredicate();
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  int64_t v9 = (void *)((char *)aBlock - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  unint64_t v10 = *(void **)&a2[OBJC_IVAR____TtC7backupd19MBActivityScheduler__workQueue];
  *int64_t v9 = v10;
  (*(void (**)(void *, void, uint64_t))(v7 + 104))(v9, enum case for DispatchPredicate.onQueue(_:), v6);
  id v11 = v10;
  LOBYTE(v10) = _dispatchPreconditionTest(_:)();
  uint64_t result = (*(uint64_t (**)(void *, uint64_t))(v7 + 8))(v9, v6);
  if (v10)
  {
    uint64_t v13 = swift_allocObject();
    *(void *)(v13 + 16) = a2;
    *(void *)(v13 + 24) = a3;
    aBlock[4] = sub_1000225F4;
    aBlock[5] = v13;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1107296256;
    aBlock[2] = sub_1000203E4;
    aBlock[3] = &unk_10040FEB0;
    uint64_t v14 = _Block_copy(aBlock);
    NSString v15 = a2;
    swift_unknownObjectRetain();
    swift_release();
    [a1 setExpirationHandlerWithReason:v14];
    _Block_release(v14);
    return sub_100020438(a1, a3);
  }
  else
  {
    __break(1u);
  }
  return result;
}

id sub_100020164(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = type metadata accessor for DispatchPredicate();
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  int64_t v9 = (uint64_t *)((char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  unint64_t v10 = *(void **)(a2 + OBJC_IVAR____TtC7backupd19MBActivityScheduler__workQueue);
  *int64_t v9 = v10;
  (*(void (**)(void *, void, uint64_t))(v7 + 104))(v9, enum case for DispatchPredicate.notOnQueue(_:), v6);
  id v11 = v10;
  LOBYTE(v10) = _dispatchPreconditionTest(_:)();
  id result = (id)(*(uint64_t (**)(void *, uint64_t))(v7 + 8))(v9, v6);
  if (v10) {
    return sub_10002028C(a1, a3);
  }
  __break(1u);
  return result;
}

id sub_10002028C(uint64_t a1, void *a2)
{
  _StringGuts.grow(_:)(31);
  v4._countAndFlagsBits = 0x7075727265746E49;
  v4._object = (void *)0xED000020676E6974;
  String.append(_:)(v4);
  id v5 = [a2 identifier];
  uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v8 = v7;

  v9._countAndFlagsBits = v6;
  v9._object = v8;
  String.append(_:)(v9);
  swift_bridgeObjectRelease();
  v10._countAndFlagsBits = 0x6572206874697720;
  v10._object = (void *)0xEE00203A6E6F7361;
  String.append(_:)(v10);
  type metadata accessor for BGSystemTaskExpirationReason(0);
  _print_unlocked<A, B>(_:_:)();
  sub_100045F18(0, 0xE000000000000000, 0xD000000000000011, 0x8000000100305450);
  swift_bridgeObjectRelease();
  return [a2 interruptWithReason:a1];
}

uint64_t sub_1000203E4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void (**)(uint64_t))(a1 + 32);
  swift_retain();
  v3(a2);
  return swift_release();
}

uint64_t sub_100020438(void *a1, id a2)
{
  id v4 = [a2 identifier];
  v5._countAndFlagsBits = static String._unconditionallyBridgeFromObjectiveC(_:)();
  String.append(_:)(v5);
  swift_bridgeObjectRelease();
  sub_100045F18(0x676E696B6F766E49, 0xE900000000000020, 0xD000000000000011, 0x8000000100305450);
  swift_bridgeObjectRelease();
  id v6 = [self sharedDaemon];
  uint64_t v7 = swift_allocObject();
  *(void *)(v7 + 16) = a2;
  *(void *)(v7 + 24) = a1;
  uint64_t v8 = swift_allocObject();
  *(void *)(v8 + 16) = sub_100022600;
  *(void *)(v8 + 24) = v7;
  v12[4] = sub_1000225FC;
  v12[5] = v8;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1107296256;
  v12[2] = sub_1000215D4;
  id v12[3] = &unk_10040FE10;
  Swift::String v9 = _Block_copy(v12);
  id v10 = a1;
  swift_retain();
  swift_unknownObjectRetain();
  swift_release();
  [v6 holdingWorkAssertionWithDescription:v4 forScope:v9];

  _Block_release(v9);
  LOBYTE(v4) = swift_isEscapingClosureAtFileLocation();
  swift_release();
  uint64_t result = swift_release();
  if (v4) {
    __break(1u);
  }
  return result;
}

void sub_10002064C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void (**)(void))(a1 + 32);
  swift_retain();
  id v4 = a2;
  v3();
  swift_release();
}

void sub_1000206B4(void *a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = (uint64_t)a1;
  uint64_t v5 = a1[2];
  if (v5 == 1)
  {
    uint64_t v7 = a1[4];
    id v6 = (void *)a1[5];
    uint64_t v8 = (uint64_t *)&v1[OBJC_IVAR____TtC7backupd19MBActivityScheduler__activitiesByIdentifier];
    swift_beginAccess();
    uint64_t v9 = *v8;
    swift_bridgeObjectRetain_n();
    swift_bridgeObjectRetain();
    id v10 = sub_100019714(v9);
    swift_bridgeObjectRelease();
    uint64_t aBlock = (uint64_t)v10;
    sub_100021E80(&aBlock);
    if (v2) {
      goto LABEL_64;
    }
    uint64_t v3 = 0;
    swift_bridgeObjectRelease();
    uint64_t v4 = aBlock;
  }
  else
  {
    if (!v5)
    {
      sub_10001FBD4();
      return;
    }
    uint64_t v7 = a1[6];
    id v6 = (void *)a1[7];
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  BOOL v11 = v7 == 0x7075727265746E69 && v6 == (void *)0xE900000000000074;
  char v12 = v11;
  if (!v11
    && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0
    && (v7 != 0x656B6F766E69 || v6 != (void *)0xE600000000000000)
    && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0
    && (v7 != 0x7564656863736572 || v6 != (void *)0xEA0000000000656CLL))
  {
    char v35 = _stringCompareWithSmolCheck(_:_:expecting:)();
    BOOL v36 = v7 == 0x7564656863736E75 && v6 == (void *)0xEA0000000000656CLL;
    BOOL v37 = v36;
    if ((v35 & 1) == 0 && !v37 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      swift_bridgeObjectRelease();
      uint64_t aBlock = 0;
      unint64_t v50 = 0xE000000000000000;
      _StringGuts.grow(_:)(101);
      v38._countAndFlagsBits = 0xD00000000000001FLL;
      v38._object = (void *)0x8000000100305470;
      String.append(_:)(v38);
      v39._countAndFlagsBits = v7;
      v39._object = v6;
      String.append(_:)(v39);
      swift_bridgeObjectRelease();
      v40._countAndFlagsBits = 0xD000000000000044;
      v40._object = (void *)0x8000000100305490;
      String.append(_:)(v40);
      sub_1000467F0(1, aBlock, v50, 0xD000000000000011, 0x8000000100305450);
LABEL_47:
      swift_bridgeObjectRelease();
      swift_willThrow();
      return;
    }
  }
  uint64_t v13 = v1;
  uint64_t v14 = v3;
  NSString v15 = sub_100022190(v4, (uint64_t)v13);
  swift_bridgeObjectRelease();
  if (v14)
  {
    swift_bridgeObjectRelease();

    return;
  }

  if (v12 & 1) != 0 || (_stringCompareWithSmolCheck(_:_:expecting:)())
  {
    swift_bridgeObjectRelease();
    uint64_t v16 = v15[2];
    if (v16)
    {
      int64_t v17 = (void **)(v15 + 4);
      swift_bridgeObjectRetain();
      do
      {
        unint64_t v18 = *v17++;
        uint64_t aBlock = 0;
        unint64_t v50 = 0xE000000000000000;
        swift_unknownObjectRetain();
        _StringGuts.grow(_:)(31);
        v19._countAndFlagsBits = 0x7075727265746E49;
        v19._object = (void *)0xED000020676E6974;
        String.append(_:)(v19);
        id v20 = [v18 identifier];
        uint64_t v21 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        unint64_t v23 = v22;

        v24._countAndFlagsBits = v21;
        v24._object = v23;
        String.append(_:)(v24);
        swift_bridgeObjectRelease();
        v25._countAndFlagsBits = 0x6572206874697720;
        v25._object = (void *)0xEE00203A6E6F7361;
        String.append(_:)(v25);
        type metadata accessor for BGSystemTaskExpirationReason(0);
        _print_unlocked<A, B>(_:_:)();
        sub_100045F18(aBlock, v50, 0xD000000000000011, 0x8000000100305450);
        swift_bridgeObjectRelease();
        [v18 interruptWithReason:0];
        swift_unknownObjectRelease();
        --v16;
      }
      while (v16);
LABEL_27:
      swift_bridgeObjectRelease();
      goto LABEL_28;
    }
    goto LABEL_28;
  }
  if ((v7 != 0x656B6F766E69 || v6 != (void *)0xE600000000000000)
    && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
  {
    if (v7 == 0x7564656863736572 && v6 == (void *)0xEA0000000000656CLL
      || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
    {
      swift_bridgeObjectRelease();
      uint64_t v41 = v15[2];
      if (!v41) {
        goto LABEL_28;
      }
      uint64_t v42 = v15 + 4;
      swift_bridgeObjectRetain();
      do
      {
        ++v42;
        uint64_t v43 = (void *)swift_unknownObjectRetain();
        sub_10001F338(v43);
        swift_unknownObjectRelease();
        --v41;
      }
      while (v41);
      goto LABEL_27;
    }
    if ((v7 != 0x7564656863736E75 || v6 != (void *)0xEA0000000000656CLL)
      && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      swift_bridgeObjectRelease();
      uint64_t aBlock = 0;
      unint64_t v50 = 0xE000000000000000;
      _StringGuts.grow(_:)(33);
      swift_bridgeObjectRelease();
      uint64_t aBlock = 0xD00000000000001FLL;
      unint64_t v50 = 0x8000000100305470;
      v47._countAndFlagsBits = v7;
      v47._object = v6;
      String.append(_:)(v47);
      swift_bridgeObjectRelease();
      sub_1000467F0(1, aBlock, v50, 0xD000000000000011, 0x8000000100305450);
      goto LABEL_47;
    }
    swift_bridgeObjectRelease();
    uint64_t v44 = v15[2];
    if (v44)
    {
      uint64_t v45 = v15 + 4;
      swift_bridgeObjectRetain();
      do
      {
        ++v45;
        uint64_t v46 = (void *)swift_unknownObjectRetain();
        sub_100020FD0(v46);
        swift_unknownObjectRelease();
        --v44;
      }
      while (v44);
      goto LABEL_27;
    }
LABEL_28:
    swift_bridgeObjectRelease();
    sub_10001FBD4();
    return;
  }
  swift_bridgeObjectRelease();
  uint64_t v26 = v15[2];
  if (!v26) {
    goto LABEL_28;
  }
  unint64_t v27 = v15 + 4;
  swift_bridgeObjectRetain();
  id v48 = self;
  while (1)
  {
    uint64_t v28 = *v27;
    id v29 = [(id)swift_unknownObjectRetain() identifier];
    v30._countAndFlagsBits = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t aBlock = 0x676E696B6F766E49;
    unint64_t v50 = 0xE900000000000020;
    String.append(_:)(v30);
    swift_bridgeObjectRelease();
    sub_100045F18(aBlock, v50, 0xD000000000000011, 0x8000000100305450);
    swift_bridgeObjectRelease();
    id v31 = [v48 sharedDaemon];
    uint64_t v32 = swift_allocObject();
    *(void *)(v32 + 16) = v28;
    *(void *)(v32 + 24) = 0;
    uint64_t v33 = swift_allocObject();
    *(void *)(v33 + 16) = sub_100022368;
    *(void *)(v33 + 24) = v32;
    uint64_t v53 = sub_100022380;
    uint64_t v54 = v33;
    uint64_t aBlock = (uint64_t)_NSConcreteStackBlock;
    unint64_t v50 = 1107296256;
    unint64_t v51 = sub_1000215D4;
    uint64_t v52 = &unk_10040FD20;
    uint64_t v34 = _Block_copy(&aBlock);
    swift_unknownObjectRetain();
    swift_retain();
    swift_release();
    [v31 holdingWorkAssertionWithDescription:v29 forScope:v34];

    _Block_release(v34);
    LOBYTE(v34) = swift_isEscapingClosureAtFileLocation();
    swift_unknownObjectRelease();
    swift_release();
    swift_release();
    if (v34) {
      break;
    }
    ++v27;
    if (!--v26) {
      goto LABEL_27;
    }
  }
  __break(1u);
LABEL_64:
  swift_release();
  __break(1u);
}

void sub_100020FD0(void *a1)
{
  id v1 = [a1 identifier];
  uint64_t v2 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v4 = v3;
  strcpy((char *)v14, "Unscheduling ");
  HIWORD(v14[1]) = -4864;
  id v5 = v1;
  v6._countAndFlagsBits = v2;
  v6._object = v4;
  String.append(_:)(v6);
  sub_100045F18((uint64_t)v14[0], (unint64_t)v14[1], 0xD000000000000011, 0x8000000100305450);
  swift_bridgeObjectRelease();
  id v7 = [self sharedScheduler];
  id v8 = [v7 taskRequestForIdentifier:v5];

  if (v8)
  {
    swift_bridgeObjectRelease();
    v14[0] = 0;
    unsigned int v9 = [v7 cancelTaskRequestWithIdentifier:v5 error:v14];

    if (v9)
    {
      id v10 = v14[0];
    }
    else
    {
      id v12 = v14[0];
      _convertNSErrorToError(_:)();

      swift_willThrow();
      v14[0] = 0;
      v14[1] = (id)0xE000000000000000;
      _StringGuts.grow(_:)(35);
      v13._countAndFlagsBits = 0xD000000000000021;
      v13._object = (void *)0x8000000100305540;
      String.append(_:)(v13);
      sub_100006FC8(&qword_10047D0A0);
      _print_unlocked<A, B>(_:_:)();
      sub_1000465BC((uint64_t)v14[0], (unint64_t)v14[1], 0xD000000000000011, 0x8000000100305450);
      swift_bridgeObjectRelease();

      swift_errorRelease();
    }
  }
  else
  {

    _StringGuts.grow(_:)(32);
    swift_bridgeObjectRelease();
    v11._countAndFlagsBits = v2;
    v11._object = v4;
    String.append(_:)(v11);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD00000000000001ELL, 0x8000000100305570, 0xD000000000000011, 0x8000000100305450);

    swift_bridgeObjectRelease();
  }
}

uint64_t type metadata accessor for MBActivityScheduler()
{
  return self;
}

uint64_t sub_100021444(void *a1, void *a2)
{
  uint64_t v4 = [a1 workQueue];
  uint64_t v5 = swift_allocObject();
  *(void *)(v5 + 16) = a1;
  uint64_t v6 = swift_allocObject();
  *(void *)(v6 + 16) = sub_1000223F8;
  *(void *)(v6 + 24) = v5;
  v9[4] = sub_1000225FC;
  v9[5] = v6;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1107296256;
  v9[2] = sub_1000215D4;
  _OWORD v9[3] = &unk_10040FD98;
  id v7 = _Block_copy(v9);
  swift_unknownObjectRetain();
  swift_retain();
  swift_release();
  dispatch_sync(v4, v7);

  _Block_release(v7);
  LOBYTE(v4) = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if (v4)
  {
    __break(1u);
  }
  else
  {
    [a2 setTaskCompleted];
    sub_10001F338(a1);
    return swift_release();
  }
  return result;
}

uint64_t sub_1000215D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t sub_100021680()
{
  v20.super_class = (Class)BGNonRepeatingSystemTaskRequest;
  id v1 = objc_msgSendSuper2(&v20, "propertyListRepresentation");
  uint64_t v19 = static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();

  sub_100006FC8(&qword_10047D770);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1003B21D0;
  strcpy((char *)(inited + 32), "scheduleAfter");
  *(_WORD *)(inited + 46) = -4864;
  [v0 scheduleAfter];
  double v4 = v3;
  id v5 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
  [v5 setUnitsStyle:0];
  id v6 = [v5 localizedStringFromTimeInterval:v4];

  uint64_t v7 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v9 = v8;

  *(void *)(inited + 48) = v7;
  *(void *)(inited + 56) = v9;
  *(void *)(inited + 72) = &type metadata for String;
  *(void *)(inited + 80) = 0xD000000000000013;
  *(void *)(inited + 88) = 0x8000000100305430;
  [v0 trySchedulingBefore];
  double v11 = v10;
  id v12 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
  [v12 setUnitsStyle:0];
  id v13 = [v12 localizedStringFromTimeInterval:v11];

  uint64_t v14 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v16 = v15;

  *(void *)(inited + 120) = &type metadata for String;
  *(void *)(inited + 96) = v14;
  *(void *)(inited + 104) = v16;
  unint64_t v17 = sub_100049370(inited);
  return sub_10001EAD8(v17, v19);
}

Class sub_1000218A4(void *a1, uint64_t a2, void (*a3)(void))
{
  id v4 = a1;
  a3();

  v5.super.Class isa = Dictionary._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  return v5.super.isa;
}

ValueMetadata *type metadata accessor for _ScheduledActivity()
{
  return &type metadata for _ScheduledActivity;
}

unint64_t sub_100021930()
{
  sub_100006FC8(&qword_10047D770);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1003B21D0;
  *(void *)(inited + 32) = 0x6C61767265746E69;
  *(void *)(inited + 40) = 0xE800000000000000;
  [v0 interval];
  double v3 = v2;
  id v4 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
  [v4 setUnitsStyle:0];
  id v5 = [v4 localizedStringFromTimeInterval:v3];

  uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v8 = v7;

  *(void *)(inited + 48) = v6;
  *(void *)(inited + 56) = v8;
  *(void *)(inited + 72) = &type metadata for String;
  *(void *)(inited + 80) = 0xD00000000000001BLL;
  *(void *)(inited + 88) = 0x8000000100305410;
  [v0 minDurationBetweenInstances];
  double v10 = v9;
  id v11 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
  [v11 setUnitsStyle:0];
  id v12 = [v11 localizedStringFromTimeInterval:v10];

  uint64_t v13 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v15 = v14;

  *(void *)(inited + 120) = &type metadata for String;
  *(void *)(inited + 96) = v13;
  *(void *)(inited + 104) = v15;
  return sub_100049370(inited);
}

uint64_t sub_100021AD4@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  sub_100018584((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  *a2 = v4;
  a2[1] = v3;
  return swift_bridgeObjectRetain();
}

uint64_t sub_100021B28(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v7 = -1 << *(unsigned char *)(a1 + 32);
  uint64_t v8 = ~v7;
  uint64_t v9 = *(void *)(a1 + 64);
  uint64_t v10 = -v7;
  uint64_t v50 = a1;
  uint64_t v51 = a1 + 64;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  else {
    uint64_t v11 = -1;
  }
  uint64_t v52 = v8;
  uint64_t v53 = 0;
  uint64_t v54 = v11 & v9;
  uint64_t v55 = a2;
  uint64_t v56 = a3;
  swift_bridgeObjectRetain();
  swift_retain();
  sub_100021EEC(&v48);
  uint64_t v12 = *((void *)&v48 + 1);
  if (!*((void *)&v48 + 1)) {
    goto LABEL_27;
  }
  uint64_t v13 = v48;
  sub_100016C78(v49, v47);
  uint64_t v14 = *(void **)a5;
  unint64_t v16 = sub_100031554(v13, v12);
  uint64_t v17 = v14[2];
  BOOL v18 = (v15 & 1) == 0;
  uint64_t v19 = v17 + v18;
  if (__OFADD__(v17, v18))
  {
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }
  char v20 = v15;
  if (v14[3] >= v19)
  {
    if (a4)
    {
      if (v15) {
        goto LABEL_12;
      }
    }
    else
    {
      sub_100033698();
      if (v20) {
        goto LABEL_12;
      }
    }
LABEL_14:
    Swift::String v24 = *(void **)a5;
    *(void *)(*(void *)a5 + 8 * (v16 >> 6) + 64) |= 1 << v16;
    Swift::String v25 = (uint64_t *)(v24[6] + 16 * v16);
    *Swift::String v25 = v13;
    v25[1] = v12;
    sub_100016C78(v47, (_OWORD *)(v24[7] + 32 * v16));
    uint64_t v26 = v24[2];
    BOOL v27 = __OFADD__(v26, 1);
    uint64_t v28 = v26 + 1;
    if (v27)
    {
LABEL_29:
      __break(1u);
      goto LABEL_30;
    }
    v24[2] = v28;
LABEL_16:
    sub_100021EEC(&v48);
    for (uint64_t i = *((void *)&v48 + 1); *((void *)&v48 + 1); uint64_t i = *((void *)&v48 + 1))
    {
      uint64_t v31 = v48;
      sub_100016C78(v49, v47);
      uint64_t v32 = *(void **)a5;
      unint64_t v34 = sub_100031554(v31, i);
      uint64_t v35 = v32[2];
      BOOL v36 = (v33 & 1) == 0;
      uint64_t v37 = v35 + v36;
      if (__OFADD__(v35, v36)) {
        goto LABEL_28;
      }
      char v38 = v33;
      if (v32[3] < v37)
      {
        sub_100032508(v37, 1);
        unint64_t v39 = sub_100031554(v31, i);
        if ((v38 & 1) != (v40 & 1)) {
          goto LABEL_30;
        }
        unint64_t v34 = v39;
      }
      if (v38)
      {
        sub_100018584((uint64_t)v47, (uint64_t)v46);
        sub_1000070A4((uint64_t)v47);
        swift_bridgeObjectRelease();
        Swift::String v30 = (_OWORD *)(*(void *)(*(void *)a5 + 56) + 32 * v34);
        sub_1000070A4((uint64_t)v30);
        sub_100016C78(v46, v30);
      }
      else
      {
        uint64_t v41 = *(void **)a5;
        *(void *)(*(void *)a5 + 8 * (v34 >> 6) + 64) |= 1 << v34;
        uint64_t v42 = (uint64_t *)(v41[6] + 16 * v34);
        *uint64_t v42 = v31;
        v42[1] = i;
        sub_100016C78(v47, (_OWORD *)(v41[7] + 32 * v34));
        uint64_t v43 = v41[2];
        BOOL v27 = __OFADD__(v43, 1);
        uint64_t v44 = v43 + 1;
        if (v27) {
          goto LABEL_29;
        }
        v41[2] = v44;
      }
      sub_100021EEC(&v48);
    }
LABEL_27:
    swift_release();
    swift_bridgeObjectRelease();
    sub_100016C70();
    return swift_release();
  }
  sub_100032508(v19, a4 & 1);
  unint64_t v21 = sub_100031554(v13, v12);
  if ((v20 & 1) == (v22 & 1))
  {
    unint64_t v16 = v21;
    if ((v20 & 1) == 0) {
      goto LABEL_14;
    }
LABEL_12:
    sub_100018584((uint64_t)v47, (uint64_t)v46);
    sub_1000070A4((uint64_t)v47);
    swift_bridgeObjectRelease();
    unint64_t v23 = (_OWORD *)(*(void *)(*(void *)a5 + 56) + 32 * v16);
    sub_1000070A4((uint64_t)v23);
    sub_100016C78(v46, v23);
    goto LABEL_16;
  }
LABEL_30:
  uint64_t result = KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
  __break(1u);
  return result;
}

Swift::Int sub_100021E80(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v2 = sub_10001A5A0(v2);
  }
  uint64_t v3 = *(void *)(v2 + 16);
  v5[0] = v2 + 32;
  v5[1] = v3;
  Swift::Int result = sub_10001997C(v5);
  *a1 = v2;
  return result;
}

uint64_t sub_100021EEC@<X0>(_OWORD *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  uint64_t v6 = v1[2];
  int64_t v5 = v1[3];
  int64_t v7 = v5;
  unint64_t v8 = v1[4];
  if (v8)
  {
    uint64_t v9 = (v8 - 1) & v8;
    unint64_t v10 = __clz(__rbit64(v8)) | (v5 << 6);
LABEL_3:
    uint64_t v11 = (uint64_t *)(*(void *)(v3 + 48) + 16 * v10);
    uint64_t v13 = *v11;
    uint64_t v12 = v11[1];
    sub_100018584(*(void *)(v3 + 56) + 32 * v10, (uint64_t)v24);
    *(void *)&long long v23 = v13;
    *((void *)&v23 + 1) = v12;
    swift_bridgeObjectRetain();
    goto LABEL_23;
  }
  int64_t v14 = v5 + 1;
  if (__OFADD__(v5, 1))
  {
    __break(1u);
    return result;
  }
  int64_t v15 = (unint64_t)(v6 + 64) >> 6;
  if (v14 < v15)
  {
    unint64_t v16 = *(void *)(v4 + 8 * v14);
    if (v16)
    {
LABEL_7:
      uint64_t v9 = (v16 - 1) & v16;
      unint64_t v10 = __clz(__rbit64(v16)) + (v14 << 6);
      int64_t v7 = v14;
      goto LABEL_3;
    }
    int64_t v17 = v5 + 2;
    int64_t v7 = v5 + 1;
    if (v5 + 2 < v15)
    {
      unint64_t v16 = *(void *)(v4 + 8 * v17);
      if (v16)
      {
LABEL_10:
        int64_t v14 = v17;
        goto LABEL_7;
      }
      int64_t v7 = v5 + 2;
      if (v5 + 3 < v15)
      {
        unint64_t v16 = *(void *)(v4 + 8 * (v5 + 3));
        if (v16)
        {
          int64_t v14 = v5 + 3;
          goto LABEL_7;
        }
        int64_t v17 = v5 + 4;
        int64_t v7 = v5 + 3;
        if (v5 + 4 < v15)
        {
          unint64_t v16 = *(void *)(v4 + 8 * v17);
          if (v16) {
            goto LABEL_10;
          }
          int64_t v14 = v5 + 5;
          int64_t v7 = v5 + 4;
          if (v5 + 5 < v15)
          {
            unint64_t v16 = *(void *)(v4 + 8 * v14);
            if (v16) {
              goto LABEL_7;
            }
            int64_t v7 = v15 - 1;
            int64_t v18 = v5 + 6;
            while (v15 != v18)
            {
              unint64_t v16 = *(void *)(v4 + 8 * v18++);
              if (v16)
              {
                int64_t v14 = v18 - 1;
                goto LABEL_7;
              }
            }
          }
        }
      }
    }
  }
  uint64_t v9 = 0;
  memset(v24, 0, sizeof(v24));
  long long v23 = 0u;
LABEL_23:
  uint64_t *v1 = v3;
  v1[1] = v4;
  v1[2] = v6;
  v1[3] = v7;
  v1[4] = v9;
  uint64_t v19 = (void (*)(_OWORD *))v1[5];
  uint64_t result = sub_1000220C8((uint64_t)&v23, (uint64_t)v22);
  if (*((void *)&v22[0] + 1))
  {
    v21[0] = v22[0];
    v21[1] = v22[1];
    v21[2] = v22[2];
    v19(v21);
    return sub_100022130((uint64_t)v21);
  }
  else
  {
    a1[1] = 0u;
    a1[2] = 0u;
    *a1 = 0u;
  }
  return result;
}

uint64_t sub_1000220C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100006FC8(&qword_10047D778);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t sub_100022130(uint64_t a1)
{
  uint64_t v2 = sub_100006FC8(&qword_10047D780);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

void *sub_100022190(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t result = _swiftEmptyArrayStorage;
  if (v3)
  {
    specialized ContiguousArray.reserveCapacity(_:)();
    uint64_t v6 = a2 + OBJC_IVAR____TtC7backupd19MBActivityScheduler__activitiesByIdentifier;
    int64_t v7 = (void **)(a1 + 40);
    while (1)
    {
      uint64_t v9 = (uint64_t)*(v7 - 1);
      unint64_t v8 = *v7;
      swift_beginAccess();
      uint64_t v10 = *(void *)(*(void *)v6 + 16);
      swift_bridgeObjectRetain();
      if (!v10) {
        break;
      }
      swift_bridgeObjectRetain();
      sub_100031554(v9, (uint64_t)v8);
      if ((v11 & 1) == 0)
      {
        swift_bridgeObjectRelease();
        break;
      }
      v7 += 2;
      swift_endAccess();
      swift_unknownObjectRetain();
      swift_bridgeObjectRelease_n();
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
      specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
      specialized ContiguousArray._endMutation()();
      if (!--v3) {
        return _swiftEmptyArrayStorage;
      }
    }
    swift_endAccess();
    _StringGuts.grow(_:)(37);
    swift_bridgeObjectRelease();
    v12._countAndFlagsBits = v9;
    v12._object = v8;
    String.append(_:)(v12);
    sub_1000467F0(1, 0xD000000000000023, 0x8000000100305590, 0xD000000000000011, 0x8000000100305450);
    swift_bridgeObjectRelease();
    swift_willThrow();
    swift_bridgeObjectRelease();
    return (void *)swift_release();
  }
  return result;
}

uint64_t sub_100022368()
{
  return sub_100021444(*(void **)(v0 + 16), *(void **)(v0 + 24));
}

uint64_t sub_100022370()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100022380()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_1000223A8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1000223B8()
{
  return swift_release();
}

uint64_t sub_1000223C0()
{
  swift_unknownObjectRelease();
  return _swift_deallocObject(v0, 24, 7);
}

id sub_1000223F8()
{
  return [*(id *)(v0 + 16) invoke];
}

uint64_t sub_100022408()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_10002241C()
{
  swift_unknownObjectRelease();

  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_10002245C()
{
  return _swift_deallocObject(v0, 32, 7);
}

id sub_10002246C@<X0>(void *a1@<X8>)
{
  id result = [*(id *)(v1 + 16) nextTaskRequestWithCurrentTaskRequest:*(void *)(v1 + 24)];
  *a1 = result;
  return result;
}

unint64_t sub_1000224B0()
{
  unint64_t result = qword_10047D798;
  if (!qword_10047D798)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_10047D798);
  }
  return result;
}

unint64_t sub_1000224F0()
{
  unint64_t result = qword_10047D7A0;
  if (!qword_10047D7A0)
  {
    type metadata accessor for OS_dispatch_queue.Attributes();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7A0);
  }
  return result;
}

unint64_t sub_100022548()
{
  unint64_t result = qword_10047D7B0;
  if (!qword_10047D7B0)
  {
    sub_10000BAC4(&qword_10047D7A8);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7B0);
  }
  return result;
}

uint64_t sub_1000225A8(void *a1)
{
  return sub_10001FF80(a1, *(char **)(v1 + 16), *(void **)(v1 + 24));
}

uint64_t sub_1000225B4()
{
  swift_unknownObjectRelease();
  return _swift_deallocObject(v0, 32, 7);
}

id sub_1000225F4(uint64_t a1)
{
  return sub_100020164(a1, *(void *)(v1 + 16), *(void **)(v1 + 24));
}

void *Enumerator.Options.includeDirectoriesPostOrder.unsafeMutableAddressor()
{
  return &static Enumerator.Options.includeDirectoriesPostOrder;
}

uint64_t URL.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for URL();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
}

uint64_t sub_1000226A0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32))(a3, a1);
}

uint64_t static Enumerator.Options.default.getter()
{
  return 3;
}

void *Enumerator.Options.descendRecursively.unsafeMutableAddressor()
{
  return &static Enumerator.Options.descendRecursively;
}

void *Enumerator.Options.includeDirectoriesPreOrder.unsafeMutableAddressor()
{
  return &static Enumerator.Options.includeDirectoriesPreOrder;
}

uint64_t URL.enumerationRoot.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = type metadata accessor for URL();
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 - 8) + 16);
  return v4(a1, v1, v3);
}

uint64_t sub_100022780@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16))(a2, v2, a1);
}

uint64_t static Enumerator.Options.includeDirectoriesPreOrder.getter()
{
  return 2;
}

uint64_t static Enumerator.Options.includeDirectoriesPostOrder.getter()
{
  return 4;
}

void *sub_1000227C4@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void sub_1000227D0(void *a1@<X8>)
{
  *a1 = 0;
}

void *sub_1000227D8@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

void *sub_1000227EC@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

void *sub_100022800@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_100022814(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *v2 & *a2;
  if (v4 != *a2) {
    *v2 |= v3;
  }
  *a1 = v3;
  return v4 != v3;
}

void *sub_100022844@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *v2 & *result;
  if (v3) {
    *v2 &= ~*result;
  }
  *(void *)a2 = v3;
  *(unsigned char *)(a2 + 8) = v3 == 0;
  return result;
}

uint64_t *sub_100022870@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *v2;
  *v2 |= *result;
  uint64_t v5 = v4 & v3;
  *(void *)a2 = v5;
  *(unsigned char *)(a2 + 8) = v5 == 0;
  return result;
}

void *sub_100022894(void *result)
{
  *v1 |= *result;
  return result;
}

void *sub_1000228A8(void *result)
{
  *v1 &= *result;
  return result;
}

unint64_t sub_1000228C0()
{
  unint64_t result = qword_10047D7B8;
  if (!qword_10047D7B8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7B8);
  }
  return result;
}

unint64_t sub_100022918()
{
  unint64_t result = qword_10047D7C0;
  if (!qword_10047D7C0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7C0);
  }
  return result;
}

unint64_t sub_100022970()
{
  unint64_t result = qword_10047D7C8;
  if (!qword_10047D7C8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7C8);
  }
  return result;
}

unint64_t sub_1000229C8()
{
  unint64_t result = qword_10047D7D0;
  if (!qword_10047D7D0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7D0);
  }
  return result;
}

void *sub_100022A1C(void *result)
{
  *v1 ^= *result;
  return result;
}

void *sub_100022A30@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_100022A44(void *a1)
{
  return (*v1 & ~*a1) == 0;
}

BOOL sub_100022A58(void *a1)
{
  return (*v1 & *a1) == 0;
}

BOOL sub_100022A6C(void *a1)
{
  return (*a1 & ~*v1) == 0;
}

BOOL sub_100022A80()
{
  return *v0 == 0;
}

uint64_t sub_100022A90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return SetAlgebra.init<A>(_:)(a1, a4, a2, a5, a3);
}

void *sub_100022AA8(void *result)
{
  *v1 &= ~*result;
  return result;
}

uint64_t sub_100022ABC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = sub_100022B94(a1);
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v3;
  return result;
}

ValueMetadata *type metadata accessor for Enumerator()
{
  return &type metadata for Enumerator;
}

ValueMetadata *type metadata accessor for Enumerator.Options()
{
  return &type metadata for Enumerator.Options;
}

void *initializeWithTake for MBPath(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for Enumerator.Error(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Enumerator.Error(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)uint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 8) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Enumerator.Error()
{
  return &type metadata for Enumerator.Error;
}

uint64_t sub_100022B94(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = (uint64_t *)(a1 + 32);
  do
  {
    uint64_t v6 = *v4++;
    uint64_t v5 = v6;
    if ((v6 & ~result) == 0) {
      uint64_t v5 = 0;
    }
    result |= v5;
    --v1;
  }
  while (v1);
  return result;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreDomainSelectionSummary(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFF && *(unsigned char *)(a1 + 120)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  BOOL v4 = v3 >= 2;
  int v5 = v3 - 2;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for MBDryRestoreDomainSelectionSummary(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)uint64_t result = a2 - 255;
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 120) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 120) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 16) = a2 + 1;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreDomainSelectionSummary()
{
  return &type metadata for MBDryRestoreDomainSelectionSummary;
}

uint64_t sub_100022C84(void *a1)
{
  uint64_t v3 = a1[3];
  uint64_t v95 = _swiftEmptyArrayStorage;
  uint64_t v96 = _swiftEmptyArrayStorage;
  BOOL v4 = *(void **)(v1 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
  int v5 = (void *)swift_allocObject();
  uint64_t v5[2] = a1;
  v5[3] = v3;
  v5[4] = &v96;
  v5[5] = &v95;
  uint64_t v6 = swift_allocObject();
  *(void *)(v6 + 16) = sub_100023DA4;
  *(void *)(v6 + 24) = v5;
  uint64_t v93 = sub_100023DC0;
  uint64_t v94 = v6;
  uint64_t aBlock = (uint64_t)_NSConcreteStackBlock;
  unint64_t v90 = 1107296256;
  uint64_t v91 = sub_100023DEC;
  uint64_t v92 = &unk_1004100D8;
  int64_t v7 = _Block_copy(&aBlock);
  swift_retain();
  swift_release();
  uint64_t aBlock = 0;
  id v88 = v4;
  unsigned int v8 = [v4 enumerateDomainNamesByTotalAssetSize:&aBlock enumerator:v7];
  _Block_release(v7);
  id v9 = (id)aBlock;
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (isEscapingClosureAtFileLocation) {
    goto LABEL_43;
  }
  if (!v8)
  {
    _convertNSErrorToError(_:)();

LABEL_28:
    swift_willThrow();
    swift_bridgeObjectRelease();
    swift_release();
    return swift_bridgeObjectRelease();
  }
  uint64_t v11 = v95[2];
  if (v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = v95 + 6;
    while (1)
    {
      uint64_t v14 = *v13;
      v13 += 3;
      BOOL v15 = __OFADD__(v12, v14);
      v12 += v14;
      if (v15) {
        break;
      }
      if (!--v11)
      {
        a1[10] = v12;
        if (v12 >= v3) {
          goto LABEL_8;
        }
LABEL_33:
        sub_100045F18(0xD000000000000034, 0x80000001003056A0, 0xD000000000000017, 0x8000000100305630);
        goto LABEL_34;
      }
    }
    __break(1u);
LABEL_37:
    __break(1u);
LABEL_38:
    __break(1u);
LABEL_39:
    __break(1u);
LABEL_40:
    __break(1u);
LABEL_41:
    __break(1u);
LABEL_42:
    __break(1u);
LABEL_43:
    __break(1u);
  }
  a1[10] = 0;
  if (v3 > 0) {
    goto LABEL_33;
  }
LABEL_8:
  sub_100014FE8();
  a1[4] = v3;
  for (uint64_t i = v95; v95[2]; uint64_t i = v95)
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v95 = i;
    if (isUniquelyReferenced_nonNull_native)
    {
      uint64_t v19 = i[2];
      if (!v19) {
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t i = sub_100015300(i);
      uint64_t v19 = i[2];
      if (!v19) {
        goto LABEL_37;
      }
    }
    uint64_t v20 = v19 - 1;
    unint64_t v21 = &i[3 * v20];
    uint64_t v23 = v21[4];
    uint64_t v22 = v21[5];
    uint64_t v24 = v21[6];
    i[2] = v20;
    uint64_t v95 = i;
    if (a1[4] >= v24)
    {
      swift_bridgeObjectRelease();
      uint64_t v34 = a1[11];
      BOOL v26 = __CFADD__(v34, 1);
      uint64_t v35 = v34 + 1;
      if (v26) {
        goto LABEL_39;
      }
      a1[11] = v35;
      uint64_t v36 = a1[12];
      BOOL v15 = __OFADD__(v36, v24);
      uint64_t v37 = v36 + v24;
      if (v15) {
        goto LABEL_41;
      }
      a1[12] = v37;
      uint64_t v38 = a1[4];
      BOOL v15 = __OFSUB__(v38, v24);
      uint64_t v39 = v38 - v24;
      if (v15) {
        goto LABEL_42;
      }
      a1[4] = v39;
    }
    else
    {
      uint64_t v25 = a1[13];
      BOOL v26 = __CFADD__(v25, 1);
      uint64_t v27 = v25 + 1;
      if (v26) {
        goto LABEL_38;
      }
      a1[13] = v27;
      uint64_t v28 = a1[14];
      BOOL v15 = __OFADD__(v28, v24);
      uint64_t v29 = v28 + v24;
      if (v15) {
        goto LABEL_40;
      }
      a1[14] = v29;
      Swift::String v30 = v96;
      char v31 = swift_isUniquelyReferenced_nonNull_native();
      uint64_t v96 = v30;
      if ((v31 & 1) == 0)
      {
        Swift::String v30 = sub_10003E1B0(0, v30[2] + 1, 1, v30);
        uint64_t v96 = v30;
      }
      unint64_t v33 = v30[2];
      unint64_t v32 = v30[3];
      if (v33 >= v32 >> 1)
      {
        Swift::String v30 = sub_10003E1B0((void *)(v32 > 1), v33 + 1, 1, v30);
        uint64_t v96 = v30;
      }
      v30[2] = v33 + 1;
      int64_t v17 = &v30[2 * v33];
      v17[4] = v23;
      v17[5] = v22;
    }
  }
  uint64_t aBlock = 0;
  unint64_t v90 = 0xE000000000000000;
  _StringGuts.grow(_:)(41);
  swift_bridgeObjectRelease();
  uint64_t aBlock = 0x6E69726F74736552;
  unint64_t v90 = 0xEA00000000002067;
  v41._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
  String.append(_:)(v41);
  swift_bridgeObjectRelease();
  v42._countAndFlagsBits = 10272;
  v42._object = (void *)0xE200000000000000;
  String.append(_:)(v42);
  uint64_t v43 = a1[12];
  uint64_t v44 = self;
  id v45 = [v44 stringFromByteCount:v43 countStyle:3];
  uint64_t v46 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  long long v48 = v47;

  v49._countAndFlagsBits = v46;
  v49._object = v48;
  String.append(_:)(v49);
  swift_bridgeObjectRelease();
  v50._countAndFlagsBits = 0x6E69616D6F642029;
  v50._object = (void *)0xEB00000000282073;
  String.append(_:)(v50);
  v51._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
  String.append(_:)(v51);
  swift_bridgeObjectRelease();
  v52._countAndFlagsBits = 0x6973206F72657A20;
  v52._object = (void *)0xEC0000002964657ALL;
  String.append(_:)(v52);
  sub_100045F18(aBlock, v90, 0xD000000000000017, 0x8000000100305630);
  swift_bridgeObjectRelease();
  if (v96[2])
  {
    uint64_t aBlock = 0;
    unint64_t v90 = 0xE000000000000000;
    _StringGuts.grow(_:)(96);
    v53._countAndFlagsBits = 0x676E697070696B53;
    v53._object = (void *)0xE900000000000020;
    String.append(_:)(v53);
    v54._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v54);
    swift_bridgeObjectRelease();
    v55._countAndFlagsBits = 10272;
    v55._object = (void *)0xE200000000000000;
    String.append(_:)(v55);
    id v56 = [v44 stringFromByteCount:a1[8] countStyle:3];
    uint64_t v57 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v59 = v58;

    v60._countAndFlagsBits = v57;
    v60._object = v59;
    String.append(_:)(v60);
    swift_bridgeObjectRelease();
    v61._countAndFlagsBits = 0xD000000000000010;
    v61._object = (void *)0x8000000100305650;
    String.append(_:)(v61);
    v62._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v62);
    swift_bridgeObjectRelease();
    v63._countAndFlagsBits = 10272;
    v63._object = (void *)0xE200000000000000;
    String.append(_:)(v63);
    id v64 = [v44 stringFromByteCount:a1[14] countStyle:3];
    uint64_t v65 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v67 = v66;

    v68._countAndFlagsBits = v65;
    v68._object = v67;
    String.append(_:)(v68);
    swift_bridgeObjectRelease();
    v69._countAndFlagsBits = 0x20666F2029;
    v69._object = (void *)0xE500000000000000;
    String.append(_:)(v69);
    v70._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v70);
    swift_bridgeObjectRelease();
    v71._countAndFlagsBits = 10272;
    v71._object = (void *)0xE200000000000000;
    String.append(_:)(v71);
    id v72 = [v44 stringFromByteCount:a1[10] countStyle:3];
    uint64_t v73 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v75 = v74;

    v76._countAndFlagsBits = v73;
    v76._object = v75;
    String.append(_:)(v76);
    swift_bridgeObjectRelease();
    v77._countAndFlagsBits = 0xD000000000000020;
    v77._object = (void *)0x8000000100305670;
    String.append(_:)(v77);
    id v78 = [v44 stringFromByteCount:v3 countStyle:3];
    uint64_t v79 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v81 = v80;

    v82._countAndFlagsBits = v79;
    v82._object = v81;
    String.append(_:)(v82);
    swift_bridgeObjectRelease();
    v83._countAndFlagsBits = 0x6E61776F6C6C6120;
    v83._object = (void *)0xEC0000000A3A6563;
    String.append(_:)(v83);
    swift_bridgeObjectRetain();
    v84._countAndFlagsBits = Array.description.getter();
    String.append(_:)(v84);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_100045F18(aBlock, v90, 0xD000000000000017, 0x8000000100305630);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    Class isa = Array._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    uint64_t aBlock = 0;
    LODWORD(v81) = [v88 skipDomains:isa error:&aBlock];

    if (v81)
    {
      id v86 = (id)aBlock;
      goto LABEL_34;
    }
    id v87 = (id)aBlock;
    _convertNSErrorToError(_:)();

    goto LABEL_28;
  }
LABEL_34:
  swift_bridgeObjectRelease();
  swift_release();
  return swift_bridgeObjectRelease();
}

unint64_t sub_1000235A8(char a1)
{
  unint64_t result = 0x746567647562;
  switch(a1)
  {
    case 1:
    case 10:
      unint64_t result = 0xD000000000000012;
      break;
    case 2:
      unint64_t result = 0xD000000000000010;
      break;
    case 3:
      unint64_t result = 0xD000000000000013;
      break;
    case 4:
      unint64_t result = 0xD000000000000014;
      break;
    case 5:
      unint64_t result = 0xD000000000000018;
      break;
    case 6:
      unint64_t result = 0xD000000000000017;
      break;
    case 7:
      unint64_t result = 0xD00000000000001BLL;
      break;
    case 8:
      unint64_t result = 0xD000000000000013;
      break;
    case 9:
      unint64_t result = 0xD000000000000017;
      break;
    case 11:
      unint64_t result = 0xD000000000000016;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_100023724(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v5 = sub_100006FC8(&qword_10047D7D8);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  unsigned int v8 = &v11[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_10000700C(a1, a1[3]);
  sub_100023AF8();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  long long v9 = v3[1];
  long long v12 = *v3;
  long long v13 = v9;
  v11[15] = 0;
  sub_100023B4C();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v2)
  {
    LOBYTE(v12) = 1;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 2;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 3;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 4;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 5;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 6;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 7;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 8;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 9;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 10;
    KeyedEncodingContainer.encode(_:forKey:)();
    LOBYTE(v12) = 11;
    KeyedEncodingContainer.encode(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v6 + 8))(v8, v5);
}

unint64_t sub_100023A2C()
{
  return sub_1000235A8(*v0);
}

uint64_t sub_100023A34@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = sub_100024104(a1, a2);
  *a3 = result;
  return result;
}

void sub_100023A5C(unsigned char *a1@<X8>)
{
  *a1 = 12;
}

uint64_t sub_100023A68(uint64_t a1)
{
  unint64_t v2 = sub_100023AF8();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_100023AA4(uint64_t a1)
{
  unint64_t v2 = sub_100023AF8();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_100023AE0(void *a1)
{
  return sub_100023724(a1);
}

unint64_t sub_100023AF8()
{
  unint64_t result = qword_10047D7E0;
  if (!qword_10047D7E0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7E0);
  }
  return result;
}

unint64_t sub_100023B4C()
{
  unint64_t result = qword_10047D7E8;
  if (!qword_10047D7E8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7E8);
  }
  return result;
}

uint64_t sub_100023BA0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, void **a7, void **a8)
{
  uint64_t v13 = a5[5];
  BOOL v14 = __CFADD__(v13, 1);
  uint64_t v15 = v13 + 1;
  if (v14)
  {
    __break(1u);
    goto LABEL_21;
  }
  uint64_t v10 = a3;
  a5[5] = v15;
  if (!a3)
  {
    uint64_t v25 = a5[6];
    BOOL v14 = __CFADD__(v25, 1);
    uint64_t v26 = v25 + 1;
    if (!v14)
    {
      a5[6] = v26;
      uint64_t v27 = a5[11];
      BOOL v14 = __CFADD__(v27, 1);
      uint64_t v28 = v27 + 1;
      if (!v14)
      {
        a5[11] = v28;
        return 1;
      }
      goto LABEL_22;
    }
LABEL_21:
    __break(1u);
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  uint64_t v8 = a2;
  uint64_t v9 = a1;
  if (a6 < (uint64_t)a3)
  {
    uint64_t v16 = a5[7];
    BOOL v14 = __CFADD__(v16, 1);
    uint64_t v17 = v16 + 1;
    if (!v14)
    {
      a5[7] = v17;
      uint64_t v18 = a5[8];
      BOOL v19 = __OFADD__(v18, a3);
      uint64_t v20 = (char *)a3 + v18;
      if (!v19)
      {
        long long v12 = a7;
        a5[8] = v20;
        uint64_t v10 = *a7;
        swift_bridgeObjectRetain();
        char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
        *long long v12 = v10;
        if (isUniquelyReferenced_nonNull_native)
        {
LABEL_7:
          unint64_t v23 = v10[2];
          unint64_t v22 = v10[3];
          if (v23 >= v22 >> 1)
          {
            uint64_t v10 = sub_10003E1B0((void *)(v22 > 1), v23 + 1, 1, v10);
            *long long v12 = v10;
          }
          v10[2] = v23 + 1;
          uint64_t v24 = &v10[2 * v23];
          uint64_t v24[4] = v9;
          v24[5] = v8;
          return 1;
        }
LABEL_25:
        uint64_t v10 = sub_10003E1B0(0, v10[2] + 1, 1, v10);
        *long long v12 = v10;
        goto LABEL_7;
      }
LABEL_24:
      __break(1u);
      goto LABEL_25;
    }
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }
  uint64_t v29 = a5[9];
  BOOL v14 = __CFADD__(v29, 1);
  uint64_t v30 = v29 + 1;
  if (v14)
  {
    __break(1u);
    goto LABEL_27;
  }
  a5[9] = v30;
  uint64_t v31 = a5[10];
  BOOL v19 = __OFADD__(v31, a3);
  unint64_t v32 = (char *)a3 + v31;
  if (v19)
  {
LABEL_27:
    __break(1u);
    goto LABEL_28;
  }
  uint64_t v11 = a8;
  a5[10] = v32;
  long long v12 = *a8;
  swift_bridgeObjectRetain();
  char v33 = swift_isUniquelyReferenced_nonNull_native();
  void *v11 = v12;
  if ((v33 & 1) == 0)
  {
LABEL_28:
    long long v12 = sub_10003E2C0(0, v12[2] + 1, 1, v12);
    void *v11 = v12;
  }
  unint64_t v35 = v12[2];
  unint64_t v34 = v12[3];
  if (v35 >= v34 >> 1)
  {
    long long v12 = sub_10003E2C0((void *)(v34 > 1), v35 + 1, 1, v12);
    void *v11 = v12;
  }
  v12[2] = v35 + 1;
  uint64_t v36 = &v12[3 * v35];
  v36[4] = v9;
  v36[5] = v8;
  v36[6] = v10;
  return 1;
}

uint64_t sub_100023D94()
{
  return _swift_deallocObject(v0, 48, 7);
}

uint64_t sub_100023DA4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return sub_100023BA0(a1, a2, a3, a4, *(void **)(v4 + 16), *(void *)(v4 + 24), *(void ***)(v4 + 32), *(void ***)(v4 + 40));
}

uint64_t sub_100023DB0()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100023DC0()
{
  return (*(uint64_t (**)(void))(v0 + 16))() & 1;
}

uint64_t sub_100023DEC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t))(a1 + 32);
  uint64_t v2 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  char v3 = v1(v2);
  swift_bridgeObjectRelease();
  return v3 & 1;
}

uint64_t sub_100023E50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_100023E60()
{
  return swift_release();
}

uint64_t getEnumTagSinglePayload for MBDryRestoreDomainSelectionSummary.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xF5) {
    goto LABEL_17;
  }
  if (a2 + 11 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 11) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 11;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 11;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 11;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0xC;
  int v8 = v6 - 12;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBDryRestoreDomainSelectionSummary.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 11 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 11) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF5) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF4)
  {
    unsigned int v6 = ((a2 - 245) >> 8) + 1;
    *unint64_t result = a2 + 11;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x100023FC4);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 11;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreDomainSelectionSummary.CodingKeys()
{
  return &type metadata for MBDryRestoreDomainSelectionSummary.CodingKeys;
}

unint64_t sub_100024000()
{
  unint64_t result = qword_10047D7F0;
  if (!qword_10047D7F0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7F0);
  }
  return result;
}

unint64_t sub_100024058()
{
  unint64_t result = qword_10047D7F8;
  if (!qword_10047D7F8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D7F8);
  }
  return result;
}

unint64_t sub_1000240B0()
{
  unint64_t result = qword_10047D800;
  if (!qword_10047D800)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D800);
  }
  return result;
}

uint64_t sub_100024104(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x746567647562 && a2 == 0xE600000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x80000001003056E0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x8000000100305700 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0xD000000000000013 && a2 == 0x8000000100305720 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x8000000100305740 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else if (a1 == 0xD000000000000018 && a2 == 0x8000000100305760 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 5;
  }
  else if (a1 == 0xD000000000000017 && a2 == 0x8000000100305780 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 6;
  }
  else if (a1 == 0xD00000000000001BLL && a2 == 0x80000001003057A0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 7;
  }
  else if (a1 == 0xD000000000000013 && a2 == 0x80000001003057C0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 8;
  }
  else if (a1 == 0xD000000000000017 && a2 == 0x80000001003057E0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 9;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x8000000100305800 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 10;
  }
  else if (a1 == 0xD000000000000016 && a2 == 0x8000000100305820)
  {
    swift_bridgeObjectRelease();
    return 11;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 11;
    }
    else {
      return 12;
    }
  }
}

id sub_100024554(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9)
{
  v55[4] = a5;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v15 = v9;
  id v16 = [a6 domain];
  id v17 = [v16 name];

  uint64_t v44 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  BOOL v19 = v18;

  uint64_t v20 = (uint64_t *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__restoreRootPath];
  *uint64_t v20 = a1;
  v20[1] = a2;
  uint64_t v46 = a2;
  uint64_t v38 = OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__policy;
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__policy] = a3;
  uint64_t v39 = OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__depot;
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__depot] = a4;
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__fetcher] = a5;
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan] = a6;
  uint64_t v40 = OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress;
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress] = a7;
  uint64_t v41 = OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__verifier;
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__verifier] = a8;
  uint64_t v42 = OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__logger;
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__logger] = a9;
  swift_bridgeObjectRetain();
  v21._countAndFlagsBits = 32;
  v21._object = (void *)0xE100000000000000;
  String.append(_:)(v21);
  strcpy((char *)v55, "=atc-engine= ");
  HIWORD(v55[1]) = -4864;
  id v45 = a9;
  swift_bridgeObjectRetain();
  id v22 = a3;
  id v23 = a4;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  id v24 = a7;
  id v53 = a8;
  v25._countAndFlagsBits = v44;
  v25._object = v19;
  String.append(_:)(v25);
  swift_bridgeObjectRelease();
  uint64_t v26 = v55[1];
  uint64_t v27 = &v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
  *(void *)uint64_t v27 = v55[0];
  *((void *)v27 + 1) = v26;
  v55[0] = v44;
  v55[1] = v19;
  swift_bridgeObjectRetain();
  v28._countAndFlagsBits = 1129595181;
  v28._object = (void *)0xE400000000000000;
  String.append(_:)(v28);
  swift_bridgeObjectRelease();
  uint64_t v29 = v19;
  id v30 = objc_allocWithZone((Class)type metadata accessor for MBRestorePerformer());
  id v31 = v22;
  id v32 = v23;
  id v33 = v24;
  id v34 = v45;
  id v35 = sub_100037B80(v44, v29, a1, v46, v31, v32, a7, a9);
  if (v48)
  {

    swift_unknownObjectRelease();
    swift_unknownObjectRelease();

    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();

    id v36 = (id)*((void *)v27 + 1);
    swift_bridgeObjectRelease();
    swift_deallocPartialClassInstance();
    return v36;
  }
  *(void *)&v15[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__performer] = v35;

  v54.receiver = v15;
  v54.super_class = ObjectType;
  id result = objc_msgSendSuper2(&v54, "initWithSettingsContext:debugContext:domainManager:", 0, 0, 0);
  if (result)
  {
    id v36 = result;
    [(id)swift_unknownObjectRetain() setDelegate:v36];
    swift_unknownObjectRelease();

    swift_unknownObjectRelease();
    swift_unknownObjectRelease();

    return v36;
  }
  __break(1u);
  return result;
}

uint64_t sub_100024B44()
{
  double Current = CFAbsoluteTimeGetCurrent();
  id v32 = v0;
  id v3 = sub_10002546C(0x7075746553, (void *)0xE500000000000000, (uint64_t)sub_100028EEC, (uint64_t)v31);
  if (v1)
  {
    swift_errorRetain();
    sub_1000272E0(v1);
    swift_errorRelease();
    swift_errorRelease();
  }
  else
  {
    __chkstk_darwin(v3);
    id v30 = v0;
    id v4 = sub_10002546C(0x64616F6C6E776F44, (void *)0xE800000000000000, (uint64_t)sub_100028F10, (uint64_t)v29);
    __chkstk_darwin(v4);
    id v30 = v0;
    id v5 = sub_10002546C(0xD000000000000011, (void *)0x8000000100305B70, (uint64_t)sub_100028F34, (uint64_t)v29);
    __chkstk_darwin(v5);
    id v30 = v0;
    id v6 = sub_10002546C(0xD000000000000015, (void *)0x8000000100305B90, (uint64_t)sub_100028F58, (uint64_t)v29);
    __chkstk_darwin(v6);
    id v30 = v0;
    id v7 = sub_10002546C(0x7953206563616C50, (void *)0xEE00736B6E696C6DLL, (uint64_t)sub_100028F7C, (uint64_t)v29);
    __chkstk_darwin(v7);
    id v30 = v0;
    id v8 = sub_10002546C(0x7341206563616C50, (void *)0xEC00000073746573, (uint64_t)sub_100028FA0, (uint64_t)v29);
    __chkstk_darwin(v8);
    id v30 = v0;
    id v9 = sub_10002546C(0xD00000000000001BLL, (void *)0x8000000100305BB0, (uint64_t)sub_100028FC4, (uint64_t)v29);
    __chkstk_darwin(v9);
    id v30 = v0;
    sub_10002546C(0x796669726556, (void *)0xE600000000000000, (uint64_t)Enumerator.Options.rawValue.getter, (uint64_t)v29);
    sub_1000272E0(0);
  }
  [*(id *)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__logger] flush];
  swift_getObjectType();
  id v10 = sub_1000275C0();
  long long v12 = v11;
  double v13 = CFAbsoluteTimeGetCurrent() - Current;
  id v14 = [v0 engineError];
  uint64_t v15 = *(void *)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
  unint64_t v16 = *(void *)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8];
  if (v14)
  {
    uint64_t v17 = (uint64_t)v14;
    uint64_t v34 = 0;
    unint64_t v35 = 0xE000000000000000;
    _StringGuts.grow(_:)(26);
    swift_bridgeObjectRelease();
    uint64_t v34 = 0xD000000000000014;
    unint64_t v35 = 0x8000000100305B50;
    sub_100006FC8((uint64_t *)&unk_10047D8F0);
    uint64_t v18 = swift_allocObject();
    *(_OWORD *)(v18 + 16) = xmmword_1003B1EF0;
    *(void *)(v18 + 56) = &type metadata for Double;
    *(void *)(v18 + 64) = &protocol witness table for Double;
    *(double *)(v18 + 32) = v13;
    v33._countAndFlagsBits = String.init(format:_:)();
    v33._object = v19;
    swift_bridgeObjectRetain();
    v20._countAndFlagsBits = 115;
    v20._object = (void *)0xE100000000000000;
    String.append(_:)(v20);
    swift_bridgeObjectRelease();
    String.append(_:)(v33);
    swift_bridgeObjectRelease();
    v21._countAndFlagsBits = 8250;
    v21._object = (void *)0xE200000000000000;
    String.append(_:)(v21);
    v22._countAndFlagsBits = (uint64_t)v10;
    v22._object = v12;
    String.append(_:)(v22);
    swift_bridgeObjectRelease();
    sub_1000462C4(v17, v34, v35, v15, v16);
    swift_bridgeObjectRelease();
    return swift_willThrow();
  }
  else
  {
    uint64_t v34 = 0;
    unint64_t v35 = 0xE000000000000000;
    _StringGuts.grow(_:)(31);
    swift_bridgeObjectRelease();
    uint64_t v34 = 0xD000000000000019;
    unint64_t v35 = 0x8000000100305B30;
    sub_100006FC8((uint64_t *)&unk_10047D8F0);
    uint64_t v24 = swift_allocObject();
    *(_OWORD *)(v24 + 16) = xmmword_1003B1EF0;
    *(void *)(v24 + 56) = &type metadata for Double;
    *(void *)(v24 + 64) = &protocol witness table for Double;
    *(double *)(v24 + 32) = v13;
    v33._countAndFlagsBits = String.init(format:_:)();
    v33._object = v25;
    swift_bridgeObjectRetain();
    v26._countAndFlagsBits = 115;
    v26._object = (void *)0xE100000000000000;
    String.append(_:)(v26);
    swift_bridgeObjectRelease();
    String.append(_:)(v33);
    swift_bridgeObjectRelease();
    v27._countAndFlagsBits = 8250;
    v27._object = (void *)0xE200000000000000;
    String.append(_:)(v27);
    v28._countAndFlagsBits = (uint64_t)v10;
    v28._object = v12;
    String.append(_:)(v28);
    swift_bridgeObjectRelease();
    sub_100045F18(v34, v35, v15, v16);
    return swift_bridgeObjectRelease();
  }
}

uint64_t sub_1000251B0()
{
  BOOL v2 = v0;
  id v24 = 0;
  v26.receiver = v0;
  v26.super_class = (Class)swift_getObjectType();
  unsigned int v3 = objc_msgSendSuper2(&v26, "setUpWithError:", &v24);
  id v4 = v24;
  if (!v3)
  {
    id v11 = v24;
    _convertNSErrorToError(_:)();

    return swift_willThrow();
  }
  uint64_t v6 = *(void *)&v2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__restoreRootPath];
  id v5 = *(void **)&v2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__restoreRootPath + 8];
  sub_100006FC8((uint64_t *)&unk_10047D910);
  unint64_t v7 = swift_allocBox();
  id v8 = v4;
  swift_bridgeObjectRetain();
  FilePath.init(_:)();
  char v9 = sub_100008804(v7);
  if (v1) {
    return swift_release();
  }
  char v12 = v9;
  swift_release();
  if ((v12 & 1) == 0)
  {
    id v24 = 0;
    unint64_t v25 = 0xE000000000000000;
    _StringGuts.grow(_:)(34);
    swift_bridgeObjectRelease();
    id v24 = (id)0xD000000000000011;
    unint64_t v25 = 0x8000000100305D40;
    swift_bridgeObjectRetain();
    v20._countAndFlagsBits = v6;
    v20._object = v5;
    String.append(_:)(v20);
    swift_bridgeObjectRelease();
    v21._countAndFlagsBits = 0x6F6E2073656F6420;
    v21._object = (void *)0xEF74736978652074;
    String.append(_:)(v21);
    Swift::String v22 = self;
    NSString v23 = String._bridgeToObjectiveC()();
    [v22 errorWithCode:1 description:v23];
    swift_bridgeObjectRelease();

    return swift_willThrow();
  }
  swift_getObjectType();
  id v13 = sub_1000275C0();
  uint64_t v15 = v14;
  unint64_t v16 = &v2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
  uint64_t v17 = *(void *)&v2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
  unint64_t v18 = *((void *)v16 + 1);
  id v24 = 0;
  unint64_t v25 = 0xE000000000000000;
  _StringGuts.grow(_:)(24);
  swift_bridgeObjectRelease();
  id v24 = (id)0xD000000000000016;
  unint64_t v25 = 0x8000000100305D60;
  v19._countAndFlagsBits = (uint64_t)v13;
  v19._object = v15;
  String.append(_:)(v19);
  swift_bridgeObjectRelease();
  sub_100045F18((uint64_t)v24, v25, v17, v18);
  return swift_bridgeObjectRelease();
}

id sub_10002546C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = v4;
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v12 = swift_allocObject();
  *(void *)(v12 + 16) = a3;
  *(void *)(v12 + 24) = a4;
  uint64_t v13 = swift_allocObject();
  *(void *)(v13 + 16) = sub_10002932C;
  *(void *)(v13 + 24) = v12;
  id v36 = sub_100029344;
  uint64_t v37 = v13;
  uint64_t aBlock = (uint64_t)_NSConcreteStackBlock;
  unint64_t v33 = 1107296256;
  uint64_t v34 = sub_10002809C;
  unint64_t v35 = &unk_1004104B0;
  id v14 = _Block_copy(&aBlock);
  swift_retain();
  swift_release();
  [v5 performRetryablePhase:v14];
  _Block_release(v14);
  LOBYTE(v14) = swift_isEscapingClosureAtFileLocation();
  swift_release();
  id result = (id)swift_release();
  if (v14)
  {
    __break(1u);
  }
  else
  {
    double v16 = CFAbsoluteTimeGetCurrent() - Current;
    uint64_t v17 = *(void *)&v5[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
    unint64_t v18 = *(void *)&v5[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8];
    uint64_t aBlock = 0;
    unint64_t v33 = 0xE000000000000000;
    _StringGuts.grow(_:)(22);
    swift_bridgeObjectRelease();
    uint64_t aBlock = 541283393;
    unint64_t v33 = 0xE400000000000000;
    v19._countAndFlagsBits = a1;
    v19._object = a2;
    String.append(_:)(v19);
    v20._countAndFlagsBits = 0x74656C706D6F6320;
    v20._object = (void *)0xEE00206E69206465;
    String.append(_:)(v20);
    sub_100006FC8((uint64_t *)&unk_10047D8F0);
    uint64_t v21 = swift_allocObject();
    *(_OWORD *)(v21 + 16) = xmmword_1003B1EF0;
    *(void *)(v21 + 56) = &type metadata for Double;
    *(void *)(v21 + 64) = &protocol witness table for Double;
    *(double *)(v21 + 32) = v16;
    v30._countAndFlagsBits = String.init(format:_:)();
    v30._object = v22;
    swift_bridgeObjectRetain();
    v23._countAndFlagsBits = 115;
    v23._object = (void *)0xE100000000000000;
    String.append(_:)(v23);
    swift_bridgeObjectRelease();
    String.append(_:)(v30);
    swift_bridgeObjectRelease();
    sub_100045F18(aBlock, v33, v17, v18);
    swift_bridgeObjectRelease();
    id result = [v5 engineError];
    if (result)
    {
      uint64_t v24 = (uint64_t)result;
      uint64_t aBlock = 0;
      unint64_t v33 = 0xE000000000000000;
      _StringGuts.grow(_:)(19);
      swift_bridgeObjectRelease();
      uint64_t aBlock = 0x412064656C696146;
      unint64_t v33 = 0xEB00000000204354;
      v25._countAndFlagsBits = a1;
      v25._object = a2;
      String.append(_:)(v25);
      v26._countAndFlagsBits = 544106784;
      v26._object = (void *)0xE400000000000000;
      String.append(_:)(v26);
      uint64_t v27 = swift_allocObject();
      *(_OWORD *)(v27 + 16) = xmmword_1003B1EF0;
      *(void *)(v27 + 56) = &type metadata for Double;
      *(void *)(v27 + 64) = &protocol witness table for Double;
      *(double *)(v27 + 32) = v16;
      v31._countAndFlagsBits = String.init(format:_:)();
      v31._object = v28;
      swift_bridgeObjectRetain();
      v29._countAndFlagsBits = 115;
      v29._object = (void *)0xE100000000000000;
      String.append(_:)(v29);
      swift_bridgeObjectRelease();
      String.append(_:)(v31);
      swift_bridgeObjectRelease();
      sub_1000462C4(v24, aBlock, v33, v17, v18);
      swift_bridgeObjectRelease();
      return (id)swift_willThrow();
    }
  }
  return result;
}

uint64_t sub_100025874()
{
  uint64_t v1 = *(void **)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__fetcher];
  [v1 begin];
  BOOL v2 = *(void **)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan];
  uint64_t v3 = swift_allocObject();
  *(void *)(v3 + 16) = v0;
  uint64_t v4 = swift_allocObject();
  *(void *)(v4 + 16) = sub_100029240;
  *(void *)(v4 + 24) = v3;
  id v32 = sub_100029258;
  uint64_t v33 = v4;
  uint64_t aBlock = _NSConcreteStackBlock;
  unint64_t v29 = 1107296256;
  Swift::String v30 = sub_100027E00;
  Swift::String v31 = &unk_100410438;
  id v5 = _Block_copy(&aBlock);
  uint64_t v6 = v0;
  swift_retain();
  swift_release();
  uint64_t aBlock = 0;
  unsigned int v7 = [v2 enumerateAssetsToDownload:&aBlock enumerator:v5];
  _Block_release(v5);
  id v8 = aBlock;
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (isEscapingClosureAtFileLocation) {
    __break(1u);
  }
  if (v7)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = _convertNSErrorToError(_:)();

    swift_willThrow();
    sub_1000462C4(v10, 0xD00000000000001CLL, 0x8000000100305C90, *(void *)&v6[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log], *(void *)&v6[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8]);
  }
  uint64_t aBlock = 0;
  if (![v1 finishWithError:&aBlock])
  {
    uint64_t v12 = aBlock;
    uint64_t v13 = _convertNSErrorToError(_:)();

    swift_willThrow();
    uint64_t v14 = *(void *)&v6[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
    unint64_t v15 = *(void *)&v6[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8];
    uint64_t aBlock = 0;
    unint64_t v29 = 0xE000000000000000;
    _StringGuts.grow(_:)(40);
    v16._countAndFlagsBits = 0xD000000000000026;
    v16._object = (void *)0x8000000100305CB0;
    String.append(_:)(v16);
    sub_100006FC8(&qword_10047D8E8);
    _print_unlocked<A, B>(_:_:)();
    sub_1000462C4(v13, (uint64_t)aBlock, v29, v14, v15);
    swift_bridgeObjectRelease();
    swift_willThrow();
    swift_errorRelease();
    return swift_release();
  }
  if (v10)
  {
    id v11 = aBlock;
    swift_willThrow();
    return swift_release();
  }
  unint64_t v18 = aBlock;
  id v19 = [v1 fetchSummary];
  uint64_t v20 = *(void *)&v6[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
  unint64_t v21 = *(void *)&v6[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8];
  uint64_t aBlock = 0;
  unint64_t v29 = 0xE000000000000000;
  _StringGuts.grow(_:)(42);
  swift_bridgeObjectRelease();
  uint64_t aBlock = (void **)0xD000000000000021;
  unint64_t v29 = 0x8000000100305CE0;
  id v22 = [v19 description];
  uint64_t v23 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  Swift::String v25 = v24;

  v26._countAndFlagsBits = v23;
  v26._object = v25;
  String.append(_:)(v26);
  swift_bridgeObjectRelease();
  v27._countAndFlagsBits = 0x73746573736120;
  v27._object = (void *)0xE700000000000000;
  String.append(_:)(v27);
  sub_100045F18((uint64_t)aBlock, v29, v20, v21);
  swift_release();

  return swift_bridgeObjectRelease();
}

uint64_t sub_100025C9C()
{
  uint64_t v29 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  uint64_t v28 = *(void *)(v29 - 8);
  __chkstk_darwin(v29);
  uint64_t v32 = (uint64_t)&v27 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v2 = type metadata accessor for Date();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  Swift::String v31 = (char *)&v27 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v4);
  unsigned int v7 = (char *)&v27 - v6;
  static Date.now.getter();
  id v8 = *(void **)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan];
  uint64_t v9 = swift_allocObject();
  *(void *)(v9 + 16) = v0;
  uint64_t v10 = (void *)swift_allocObject();
  v10[2] = sub_100029200;
  v10[3] = v9;
  uint64_t v30 = v9;
  aBlock[4] = sub_1000293B4;
  aBlock[5] = v10;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = (id)1107296256;
  aBlock[2] = sub_100010C14;
  aBlock[3] = &unk_1004103C0;
  id v11 = _Block_copy(aBlock);
  uint64_t v12 = v0;
  swift_retain();
  swift_release();
  aBlock[0] = 0;
  unsigned int v13 = [v8 enumerateAndMarkNotStartedDirectoriesTopDown:aBlock enumerator:v11];
  _Block_release(v11);
  uint64_t v14 = (id *)aBlock[0];
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (isEscapingClosureAtFileLocation)
  {
    __break(1u);
LABEL_10:
    uint64_t v12 = (char *)sub_10003E3E8(0, *((void *)v12 + 2) + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
    goto LABEL_4;
  }
  if (!v13)
  {
    _convertNSErrorToError(_:)();

    swift_willThrow();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v7, v2);
    return swift_release();
  }
  uint64_t v16 = *(void *)&v12[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__performer];
  uint64_t v17 = v31;
  static Date.now.getter();
  uint64_t v18 = *(void *)(v16 + OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary);
  uint64_t v19 = v32 + *(int *)(v29 + 48);
  uint64_t v20 = *(void (**)(void))(v3 + 16);
  v20();
  ((void (*)(uint64_t, char *, uint64_t))v20)(v19, v17, v2);
  uint64_t v14 = (id *)(v18 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_durations);
  swift_beginAccess();
  uint64_t v12 = (char *)*v14;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *uint64_t v14 = v12;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v22 = v28;
  unint64_t v24 = *((void *)v12 + 2);
  unint64_t v23 = *((void *)v12 + 3);
  if (v24 >= v23 >> 1)
  {
    uint64_t v12 = (char *)sub_10003E3E8(v23 > 1, v24 + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
  }
  *((void *)v12 + 2) = v24 + 1;
  sub_100029080(v32, (uint64_t)&v12[((*(unsigned __int8 *)(v22 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80))+ *(void *)(v22 + 72) * v24]);
  swift_endAccess();
  Swift::String v25 = *(void (**)(char *, uint64_t))(v3 + 8);
  v25(v31, v2);
  v25(v7, v2);
  return swift_release();
}

uint64_t sub_100026110()
{
  uint64_t v29 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  uint64_t v28 = *(void *)(v29 - 8);
  __chkstk_darwin(v29);
  uint64_t v32 = (uint64_t)&v27 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v2 = type metadata accessor for Date();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  Swift::String v31 = (char *)&v27 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v4);
  unsigned int v7 = (char *)&v27 - v6;
  static Date.now.getter();
  id v8 = *(void **)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan];
  uint64_t v9 = swift_allocObject();
  *(void *)(v9 + 16) = v0;
  uint64_t v10 = (void *)swift_allocObject();
  v10[2] = sub_1000291C0;
  v10[3] = v9;
  uint64_t v30 = v9;
  aBlock[4] = sub_1000291D8;
  aBlock[5] = v10;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = (id)1107296256;
  aBlock[2] = sub_100027840;
  aBlock[3] = &unk_100410348;
  id v11 = _Block_copy(aBlock);
  uint64_t v12 = v0;
  swift_retain();
  swift_release();
  aBlock[0] = 0;
  unsigned int v13 = [v8 enumerateAndMarkUnfinishedZeroByteFiles:aBlock enumerator:v11];
  _Block_release(v11);
  uint64_t v14 = (id *)aBlock[0];
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (isEscapingClosureAtFileLocation)
  {
    __break(1u);
LABEL_10:
    uint64_t v12 = (char *)sub_10003E3E8(0, *((void *)v12 + 2) + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
    goto LABEL_4;
  }
  if (!v13)
  {
    _convertNSErrorToError(_:)();

    swift_willThrow();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v7, v2);
    return swift_release();
  }
  uint64_t v16 = *(void *)&v12[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__performer];
  uint64_t v17 = v31;
  static Date.now.getter();
  uint64_t v18 = *(void *)(v16 + OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary);
  uint64_t v19 = v32 + *(int *)(v29 + 48);
  uint64_t v20 = *(void (**)(void))(v3 + 16);
  v20();
  ((void (*)(uint64_t, char *, uint64_t))v20)(v19, v17, v2);
  uint64_t v14 = (id *)(v18 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_durations);
  swift_beginAccess();
  uint64_t v12 = (char *)*v14;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *uint64_t v14 = v12;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v22 = v28;
  unint64_t v24 = *((void *)v12 + 2);
  unint64_t v23 = *((void *)v12 + 3);
  if (v24 >= v23 >> 1)
  {
    uint64_t v12 = (char *)sub_10003E3E8(v23 > 1, v24 + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
  }
  *((void *)v12 + 2) = v24 + 1;
  sub_100029080(v32, (uint64_t)&v12[((*(unsigned __int8 *)(v22 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80))+ *(void *)(v22 + 72) * v24]);
  swift_endAccess();
  Swift::String v25 = *(void (**)(char *, uint64_t))(v3 + 8);
  v25(v31, v2);
  v25(v7, v2);
  return swift_release();
}

uint64_t sub_100026584()
{
  uint64_t v29 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  uint64_t v28 = *(void *)(v29 - 8);
  __chkstk_darwin(v29);
  uint64_t v32 = (uint64_t)&v27 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v2 = type metadata accessor for Date();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  Swift::String v31 = (char *)&v27 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v4);
  unsigned int v7 = (char *)&v27 - v6;
  static Date.now.getter();
  id v8 = *(void **)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan];
  uint64_t v9 = swift_allocObject();
  *(void *)(v9 + 16) = v0;
  uint64_t v10 = (void *)swift_allocObject();
  v10[2] = sub_100029180;
  v10[3] = v9;
  uint64_t v30 = v9;
  aBlock[4] = sub_100029198;
  aBlock[5] = v10;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = (id)1107296256;
  aBlock[2] = sub_10002793C;
  aBlock[3] = &unk_1004102D0;
  id v11 = _Block_copy(aBlock);
  uint64_t v12 = v0;
  swift_retain();
  swift_release();
  aBlock[0] = 0;
  unsigned int v13 = [v8 enumerateAndMarkUnfinishedSymlinks:aBlock enumerator:v11];
  _Block_release(v11);
  uint64_t v14 = (id *)aBlock[0];
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (isEscapingClosureAtFileLocation)
  {
    __break(1u);
LABEL_10:
    uint64_t v12 = (char *)sub_10003E3E8(0, *((void *)v12 + 2) + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
    goto LABEL_4;
  }
  if (!v13)
  {
    _convertNSErrorToError(_:)();

    swift_willThrow();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v7, v2);
    return swift_release();
  }
  uint64_t v16 = *(void *)&v12[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__performer];
  uint64_t v17 = v31;
  static Date.now.getter();
  uint64_t v18 = *(void *)(v16 + OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary);
  uint64_t v19 = v32 + *(int *)(v29 + 48);
  uint64_t v20 = *(void (**)(void))(v3 + 16);
  v20();
  ((void (*)(uint64_t, char *, uint64_t))v20)(v19, v17, v2);
  uint64_t v14 = (id *)(v18 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_durations);
  swift_beginAccess();
  uint64_t v12 = (char *)*v14;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *uint64_t v14 = v12;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v22 = v28;
  unint64_t v24 = *((void *)v12 + 2);
  unint64_t v23 = *((void *)v12 + 3);
  if (v24 >= v23 >> 1)
  {
    uint64_t v12 = (char *)sub_10003E3E8(v23 > 1, v24 + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
  }
  *((void *)v12 + 2) = v24 + 1;
  sub_100029080(v32, (uint64_t)&v12[((*(unsigned __int8 *)(v22 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80))+ *(void *)(v22 + 72) * v24]);
  swift_endAccess();
  Swift::String v25 = *(void (**)(char *, uint64_t))(v3 + 8);
  v25(v31, v2);
  v25(v7, v2);
  return swift_release();
}

uint64_t sub_1000269F8()
{
  uint64_t v29 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  uint64_t v28 = *(void *)(v29 - 8);
  __chkstk_darwin(v29);
  uint64_t v32 = (uint64_t)&v27 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v2 = type metadata accessor for Date();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  Swift::String v31 = (char *)&v27 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v4);
  unsigned int v7 = (char *)&v27 - v6;
  static Date.now.getter();
  id v8 = *(void **)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan];
  uint64_t v9 = swift_allocObject();
  *(void *)(v9 + 16) = v0;
  uint64_t v10 = (void *)swift_allocObject();
  v10[2] = sub_1000290E8;
  v10[3] = v9;
  uint64_t v30 = v9;
  aBlock[4] = sub_100029100;
  aBlock[5] = v10;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = (id)1107296256;
  aBlock[2] = sub_100027F08;
  aBlock[3] = &unk_100410258;
  id v11 = _Block_copy(aBlock);
  uint64_t v12 = v0;
  swift_retain();
  swift_release();
  aBlock[0] = 0;
  unsigned int v13 = [v8 enumerateAndMarkUnfinishedAssets:aBlock enumerator:v11];
  _Block_release(v11);
  uint64_t v14 = (id *)aBlock[0];
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (isEscapingClosureAtFileLocation)
  {
    __break(1u);
LABEL_10:
    uint64_t v12 = (char *)sub_10003E3E8(0, *((void *)v12 + 2) + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
    goto LABEL_4;
  }
  if (!v13)
  {
    _convertNSErrorToError(_:)();

    swift_willThrow();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v7, v2);
    return swift_release();
  }
  uint64_t v16 = *(void *)&v12[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__performer];
  uint64_t v17 = v31;
  static Date.now.getter();
  uint64_t v18 = *(void *)(v16 + OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary);
  uint64_t v19 = v32 + *(int *)(v29 + 48);
  uint64_t v20 = *(void (**)(void))(v3 + 16);
  v20();
  ((void (*)(uint64_t, char *, uint64_t))v20)(v19, v17, v2);
  uint64_t v14 = (id *)(v18 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_durations);
  swift_beginAccess();
  uint64_t v12 = (char *)*v14;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *uint64_t v14 = v12;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v22 = v28;
  unint64_t v24 = *((void *)v12 + 2);
  unint64_t v23 = *((void *)v12 + 3);
  if (v24 >= v23 >> 1)
  {
    uint64_t v12 = (char *)sub_10003E3E8(v23 > 1, v24 + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
  }
  *((void *)v12 + 2) = v24 + 1;
  sub_100029080(v32, (uint64_t)&v12[((*(unsigned __int8 *)(v22 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80))+ *(void *)(v22 + 72) * v24]);
  swift_endAccess();
  Swift::String v25 = *(void (**)(char *, uint64_t))(v3 + 8);
  v25(v31, v2);
  v25(v7, v2);
  return swift_release();
}

uint64_t sub_100026E6C()
{
  uint64_t v29 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  uint64_t v28 = *(void *)(v29 - 8);
  __chkstk_darwin(v29);
  uint64_t v32 = (uint64_t)&v27 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v2 = type metadata accessor for Date();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  Swift::String v31 = (char *)&v27 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v4);
  unsigned int v7 = (char *)&v27 - v6;
  static Date.now.getter();
  id v8 = *(void **)&v0[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan];
  uint64_t v9 = swift_allocObject();
  *(void *)(v9 + 16) = v0;
  uint64_t v10 = (void *)swift_allocObject();
  v10[2] = sub_100029020;
  v10[3] = v9;
  uint64_t v30 = v9;
  aBlock[4] = sub_100029060;
  aBlock[5] = v10;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = (id)1107296256;
  aBlock[2] = sub_100010C14;
  aBlock[3] = &unk_1004101E0;
  id v11 = _Block_copy(aBlock);
  uint64_t v12 = v0;
  swift_retain();
  swift_release();
  aBlock[0] = 0;
  unsigned int v13 = [v8 enumerateAndMarkPlacedDirectoriesBottomUp:aBlock enumerator:v11];
  _Block_release(v11);
  uint64_t v14 = (id *)aBlock[0];
  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if (isEscapingClosureAtFileLocation)
  {
    __break(1u);
LABEL_10:
    uint64_t v12 = (char *)sub_10003E3E8(0, *((void *)v12 + 2) + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
    goto LABEL_4;
  }
  if (!v13)
  {
    _convertNSErrorToError(_:)();

    swift_willThrow();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v7, v2);
    return swift_release();
  }
  uint64_t v16 = *(void *)&v12[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__performer];
  uint64_t v17 = v31;
  static Date.now.getter();
  uint64_t v18 = *(void *)(v16 + OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary);
  uint64_t v19 = v32 + *(int *)(v29 + 48);
  uint64_t v20 = *(void (**)(void))(v3 + 16);
  v20();
  ((void (*)(uint64_t, char *, uint64_t))v20)(v19, v17, v2);
  uint64_t v14 = (id *)(v18 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_durations);
  swift_beginAccess();
  uint64_t v12 = (char *)*v14;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *uint64_t v14 = v12;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v22 = v28;
  unint64_t v24 = *((void *)v12 + 2);
  unint64_t v23 = *((void *)v12 + 3);
  if (v24 >= v23 >> 1)
  {
    uint64_t v12 = (char *)sub_10003E3E8(v23 > 1, v24 + 1, 1, (unint64_t)v12);
    *uint64_t v14 = v12;
  }
  *((void *)v12 + 2) = v24 + 1;
  sub_100029080(v32, (uint64_t)&v12[((*(unsigned __int8 *)(v22 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80))+ *(void *)(v22 + 72) * v24]);
  swift_endAccess();
  Swift::String v25 = *(void (**)(char *, uint64_t))(v3 + 8);
  v25(v31, v2);
  v25(v7, v2);
  return swift_release();
}

void sub_1000272E0(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v5 = *(void **)&v1[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__fetcher];
  id v31 = 0;
  if ([v5 disposeWithError:&v31])
  {
    id v6 = v31;
  }
  else
  {
    id v7 = v31;
    uint64_t v8 = _convertNSErrorToError(_:)();

    swift_willThrow();
    uint64_t v9 = *(void *)&v1[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
    unint64_t v10 = *(void *)&v1[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8];
    id v31 = 0;
    unint64_t v32 = 0xE000000000000000;
    _StringGuts.grow(_:)(32);
    v11._object = (void *)0x8000000100305AF0;
    v11._countAndFlagsBits = 0xD00000000000001ELL;
    String.append(_:)(v11);
    uint64_t v30 = v5;
    sub_100006FC8(&qword_10047D8E8);
    _print_unlocked<A, B>(_:_:)();
    sub_1000462C4(v8, (uint64_t)v31, v32, v9, v10);
    swift_bridgeObjectRelease();
    swift_errorRelease();
  }
  uint64_t v12 = *(char **)&v1[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__performer];
  unsigned int v13 = *(void **)&v12[OBJC_IVAR____TtC7backupd18MBRestorePerformer__stage];
  id v31 = 0;
  unsigned int v14 = [v13 disposeWithError:&v31];
  id v15 = v31;
  if (!v14)
  {
    id v19 = v31;
    uint64_t v20 = _convertNSErrorToError(_:)();

    swift_willThrow();
    uint64_t v21 = *(void *)&v2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
    unint64_t v22 = *(void *)&v2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8];
    id v31 = 0;
    unint64_t v32 = 0xE000000000000000;
    _StringGuts.grow(_:)(33);
    swift_bridgeObjectRelease();
    id v31 = (id)0xD00000000000001FLL;
    unint64_t v32 = 0x8000000100305B10;
    unint64_t v23 = v12;
    id v24 = [v23 description];
    uint64_t v25 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v27 = v26;

    v28._countAndFlagsBits = v25;
    v28._object = v27;
    String.append(_:)(v28);

    swift_bridgeObjectRelease();
    sub_1000462C4(v20, (uint64_t)v31, v32, v21, v22);
    swift_bridgeObjectRelease();
    swift_errorRelease();
    if (a1) {
      goto LABEL_6;
    }
LABEL_8:
    uint64_t v18 = 0;
    goto LABEL_9;
  }
  uint64_t v16 = *(void *)&v12[OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath];
  *(void *)&v12[OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath] = 0xF000000000000007;
  id v17 = v15;
  sub_10001BFE4(v16);
  if (!a1) {
    goto LABEL_8;
  }
LABEL_6:
  uint64_t v18 = (void *)_convertErrorToNSError(_:)();
LABEL_9:
  v29.receiver = v2;
  v29.super_class = ObjectType;
  objc_msgSendSuper2(&v29, "cleanUpAfterError:", v18);
}

id sub_1000275C0()
{
  id v9 = 0;
  id v1 = [v0 countsOfRestorablesByState:&v9];
  id v2 = v9;
  if (v1)
  {
    uint64_t v3 = v1;
    sub_100029284();
    sub_1000292C4();
    static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();
    id v4 = v2;

    Class isa = Dictionary._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    id v6 = MBDescriptionForStateSummaryDictionary(isa);

    id v2 = (id)static String._unconditionallyBridgeFromObjectiveC(_:)();
  }
  else
  {
    id v7 = v9;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
  return v2;
}

uint64_t sub_1000277D4(void *a1, char a2, void *a3, void *a4)
{
  id v7 = a4;
  swift_unknownObjectRetain();
  uint64_t v8 = sub_100028360(a3, v7, (uint64_t)v7, a1, a2);

  swift_unknownObjectRelease();
  return v8;
}

uint64_t sub_100027840(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 32);
  swift_unknownObjectRetain();
  uint64_t v8 = v7(a2, a3, a4);
  swift_unknownObjectRelease();
  return v8;
}

uint64_t sub_1000278A8(void *a1, char a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  Swift::String v11 = a6;
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  uint64_t v12 = sub_100028474(a5, v11, (uint64_t)v11, a1, a3, a4, a2);

  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  return v12;
}

uint64_t sub_10002793C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 32);
  uint64_t v8 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v10 = v9;
  uint64_t v11 = swift_unknownObjectRetain();
  uint64_t v12 = v7(v11, a3, v8, v10, a5);
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  return v12;
}

uint64_t sub_1000279C8(char *a1)
{
  return 1;
}

id sub_100027A30(char *a1)
{
  uint64_t v3 = v1;
  if ([v1 isCanceled]
    && [v1 cancelError])
  {
    return (id)swift_willThrow();
  }
  id v6 = *(char **)&v1[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__depot];
  id result = (id)sub_10002FF2C();
  if (!v2)
  {
    uint64_t v8 = (uint64_t)result;
    uint64_t v9 = v7;
    swift_bridgeObjectRelease();
    unint64_t v10 = *(void *)&v6[OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath];
    if ((~v10 & 0xF000000000000007) != 0)
    {
      swift_retain();
      unint64_t v11 = sub_10002D538(v8, v9, v10);
      swift_bridgeObjectRelease();
      sub_10001BFE4(v10);
      char v12 = sub_100008804(v11);
      swift_release();
      uint64_t v13 = *(void *)&v3[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log];
      unint64_t v14 = *(void *)&v3[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8];
      if (v12)
      {
        _StringGuts.grow(_:)(40);
        swift_bridgeObjectRelease();
        uint64_t v35 = 0x207465737341;
        unint64_t v36 = 0xE600000000000000;
        id v15 = [a1 description];
        uint64_t v16 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v18 = v17;

        v19._countAndFlagsBits = v16;
        v19._object = v18;
        String.append(_:)(v19);
        swift_bridgeObjectRelease();
        v20._countAndFlagsBits = 0xD00000000000001ELL;
        v20._object = (void *)0x8000000100305D10;
        String.append(_:)(v20);
        uint64_t v21 = v6;
        id v22 = [v21 description];
        uint64_t v23 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v25 = v24;

        v26._countAndFlagsBits = v23;
        v26._object = v25;
        String.append(_:)(v26);

        swift_bridgeObjectRelease();
        sub_100045F18(0x207465737341, 0xE600000000000000, v13, v14);
        id result = (id)swift_bridgeObjectRelease();
        uint64_t v27 = *(void **)&v3[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress];
        if (v27) {
          return objc_msgSend(v27, "updatingProgress:previousProgress:size:", objc_msgSend(*(id *)&a1[OBJC_IVAR____TtC7backupd14MBFetchedAsset_metadata], "assetSize"), 1.0, 0.0);
        }
      }
      else
      {
        uint64_t v35 = 0x6974736575716552;
        unint64_t v36 = 0xEB0000000020676ELL;
        id v28 = [a1 description];
        uint64_t v29 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        id v31 = v30;

        v32._countAndFlagsBits = v29;
        v32._object = v31;
        String.append(_:)(v32);
        swift_bridgeObjectRelease();
        sub_100045F18(0x6974736575716552, 0xEB0000000020676ELL, v13, v14);
        swift_bridgeObjectRelease();
        uint64_t v33 = *(void **)&v3[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__fetcher];
        uint64_t v35 = 0;
        if (![v33 requestAsset:a1 error:&v35])
        {
          id v34 = (id)v35;
          _convertNSErrorToError(_:)();

          return (id)swift_willThrow();
        }
        return (id)v35;
      }
    }
    else
    {
      sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
      swift_willThrow();
      return (id)swift_bridgeObjectRelease();
    }
  }
  return result;
}

uint64_t sub_100027E00(uint64_t a1, void *a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(a1 + 32);
  id v3 = a2;
  char v4 = v2();

  return v4 & 1;
}

uint64_t sub_100027E4C(void *a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6, void *a7, void *a8)
{
  id v15 = a8;
  swift_unknownObjectRetain();
  sub_100029128(a4, a5);
  uint64_t v16 = sub_1000285A0(a7, v15, (int)v15, a1, a2, a3, a4, a5, a6);
  sub_10000C6C0(a4, a5);

  swift_unknownObjectRelease();
  return v16;
}

uint64_t sub_100027F08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 32);
  swift_unknownObjectRetain();
  id v14 = a5;
  uint64_t v15 = static Data._unconditionallyBridgeFromObjectiveC(_:)();
  unint64_t v17 = v16;

  uint64_t v18 = v13(a2, a3, a4, v15, v17, a6, a7);
  sub_10000C6C0(v15, v17);
  swift_unknownObjectRelease();
  return v18;
}

uint64_t sub_100027FC4(uint64_t a1, void *a2, void *a3, void (*a4)(uint64_t))
{
  uint64_t v7 = a3;
  swift_unknownObjectRetain();
  uint64_t v8 = sub_1000286F4(a2, v7, (uint64_t)v7, a1, a4);

  swift_unknownObjectRelease();
  return v8;
}

uint64_t sub_100028030(uint64_t a1, void (*a2)(void))
{
  return 1;
}

uint64_t sub_10002809C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 32))(a2) & 1;
}

uint64_t type metadata accessor for MBRestoreATCEngine()
{
  return self;
}

uint64_t sub_100028360(void *a1, char *a2, uint64_t a3, void *a4, char a5)
{
  if ([a2 isCanceled])
  {
    id v9 = [a2 cancelError];
    if (v9)
    {
      unint64_t v10 = v9;
      if (a1)
      {
        unint64_t v11 = (void *)_convertErrorToNSError(_:)();
        id v12 = v11;
        *a1 = v11;
      }
    }
    return 1;
  }
  else
  {
    sub_100037278(a4, a5 & 1);
    id v14 = *(void **)&a2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress];
    if (v14) {
      [v14 updatingProgress:1 previousProgress:1.0 size:0.0];
    }
    return 5;
  }
}

uint64_t sub_100028474(void *a1, char *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, char a7)
{
  if ([a2 isCanceled])
  {
    id v13 = [a2 cancelError];
    if (v13)
    {
      id v14 = v13;
      if (a1)
      {
        uint64_t v15 = (void *)_convertErrorToNSError(_:)();
        id v16 = v15;
        *a1 = v15;
      }
    }
    return 1;
  }
  else
  {
    sub_1000374C4(a4, a5, a6, a7 & 1);
    uint64_t v18 = *(void **)&a2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress];
    if (v18) {
      [v18 updatingProgress:1 previousProgress:1.0 size:0.0];
    }
    return 5;
  }
}

uint64_t sub_1000285A0(void *a1, char *a2, int a3, void *a4, uint64_t a5, char a6, int a7, int a8, char a9)
{
  if ([a2 isCanceled])
  {
    id v14 = [a2 cancelError];
    if (v14)
    {
      uint64_t v15 = v14;
      if (a1)
      {
        id v16 = (void *)_convertErrorToNSError(_:)();
        id v17 = v16;
        *a1 = v16;
      }
    }
    return 1;
  }
  else
  {
    Class isa = Data._bridgeToObjectiveC()().super.isa;
    sub_100037728(a4, a5, a6, isa, a9 & 1);

    Swift::String v20 = *(void **)&a2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress];
    if (v20) {
      [v20 updatingProgress:1 previousProgress:1.0 size:0.0];
    }
    return 5;
  }
}

uint64_t sub_1000286F4(void *a1, char *a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t))
{
  if ([a2 isCanceled])
  {
    id v9 = [a2 cancelError];
    if (v9)
    {
      unint64_t v10 = v9;
      if (a1)
      {
        unint64_t v11 = (void *)_convertErrorToNSError(_:)();
        id v12 = v11;
        *a1 = v11;
      }
    }
    return 1;
  }
  else
  {
    a5(a4);
    id v14 = *(void **)&a2[OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress];
    if (v14) {
      [v14 updatingProgress:1 previousProgress:1.0 size:0.0];
    }
    return 5;
  }
}

uint64_t sub_100028808(char *a1, void *a2)
{
  uint64_t v3 = v2;
  sub_10002DF30(a1, a2);
  uint64_t v5 = *(void **)(v2 + OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan);
  id v21 = 0;
  unsigned int v6 = [v5 setAssetState:2 asset:a1 withFailure:0 error:&v21];

  if (v6)
  {
    id v7 = v21;
  }
  else
  {
    id v8 = v21;
    uint64_t v9 = _convertNSErrorToError(_:)();

    swift_willThrow();
    uint64_t v10 = *(void *)(v3 + OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log);
    unint64_t v11 = *(void *)(v3 + OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8);
    id v21 = 0;
    unint64_t v22 = 0xE000000000000000;
    _StringGuts.grow(_:)(32);
    v12._object = (void *)0x8000000100305AB0;
    v12._countAndFlagsBits = 0xD000000000000015;
    String.append(_:)(v12);
    id v13 = [a1 description];
    uint64_t v14 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    id v16 = v15;

    v17._countAndFlagsBits = v14;
    v17._object = v16;
    String.append(_:)(v17);
    swift_bridgeObjectRelease();
    v18._countAndFlagsBits = 0x20657461747320;
    v18._object = (void *)0xE700000000000000;
    String.append(_:)(v18);
    type metadata accessor for MBRestoreAssetState(0);
    _print_unlocked<A, B>(_:_:)();
    sub_1000462C4(v9, (uint64_t)v21, v22, v10, v11);
    swift_bridgeObjectRelease();
    swift_errorRelease();
  }
  Swift::String v19 = *(void **)(v3 + OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__progress);
  if (v19) {
    objc_msgSend(v19, "updatingProgress:previousProgress:size:", objc_msgSend(*(id *)&a1[OBJC_IVAR____TtC7backupd14MBFetchedAsset_metadata], "assetSize"), 1.0, 0.0);
  }
  return swift_errorRelease();
}

id sub_100028BF0(void *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(v2 + OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log);
  unint64_t v7 = *(void *)(v2 + OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__log + 8);
  id v27 = 0;
  unint64_t v28 = 0xE000000000000000;
  _StringGuts.grow(_:)(29);
  v8._countAndFlagsBits = 0x2072656863746546;
  v8._object = (void *)0xE800000000000000;
  String.append(_:)(v8);
  sub_100006FC8(&qword_10047D8E8);
  _print_unlocked<A, B>(_:_:)();
  v9._object = (void *)0x8000000100305A90;
  v9._countAndFlagsBits = 0xD000000000000011;
  String.append(_:)(v9);
  id v10 = [a1 description];
  uint64_t v11 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  id v13 = v12;

  v14._countAndFlagsBits = v11;
  v14._object = v13;
  String.append(_:)(v14);
  swift_bridgeObjectRelease();
  sub_1000462C4(a2, 0, 0xE000000000000000, v6, v7);
  swift_bridgeObjectRelease();
  uint64_t v15 = *(void **)(v3 + OBJC_IVAR____TtC7backupd18MBRestoreATCEngine__plan);
  id v16 = (void *)_convertErrorToNSError(_:)();
  id v27 = 0;
  LODWORD(v15) = [v15 setAssetState:3 asset:a1 withFailure:v16 error:&v27];

  id v17 = v27;
  if (v15)
  {
    return v17;
  }
  else
  {
    id v19 = v27;
    uint64_t v20 = _convertNSErrorToError(_:)();

    swift_willThrow();
    id v27 = 0;
    unint64_t v28 = 0xE000000000000000;
    _StringGuts.grow(_:)(33);
    swift_bridgeObjectRelease();
    id v27 = (id)0xD000000000000015;
    unint64_t v28 = 0x8000000100305AB0;
    id v21 = [a1 description];
    uint64_t v22 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    id v24 = v23;

    v25._countAndFlagsBits = v22;
    v25._object = v24;
    String.append(_:)(v25);
    swift_bridgeObjectRelease();
    v26._countAndFlagsBits = 0x6C69616620736120;
    v26._object = (void *)0xEA00000000006465;
    String.append(_:)(v26);
    sub_1000462C4(v20, (uint64_t)v27, v28, v6, v7);
    swift_bridgeObjectRelease();
    return (id)swift_errorRelease();
  }
}

uint64_t sub_100028EEC()
{
  return sub_1000251B0();
}

uint64_t sub_100028F10()
{
  return sub_100025874();
}

uint64_t sub_100028F34()
{
  return sub_100025C9C();
}

uint64_t sub_100028F58()
{
  return sub_100026110();
}

uint64_t sub_100028F7C()
{
  return sub_100026584();
}

uint64_t sub_100028FA0()
{
  return sub_1000269F8();
}

uint64_t sub_100028FC4()
{
  return sub_100026E6C();
}

uint64_t sub_100028FE8()
{
  return _swift_deallocObject(v0, 24, 7);
}

uint64_t sub_100029020(uint64_t a1, void *a2)
{
  return sub_100027FC4(a1, a2, *(void **)(v2 + 16), (void (*)(uint64_t))sub_10003792C);
}

uint64_t sub_100029050()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100029060(uint64_t a1, uint64_t a2)
{
  return sub_100010BEC(a1, a2, *(uint64_t (**)(void))(v2 + 16));
}

uint64_t sub_100029068(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_100029078()
{
  return swift_release();
}

uint64_t sub_100029080(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100006FC8((uint64_t *)&unk_10047DE50);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t sub_1000290E8(void *a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5, char a6, void *a7)
{
  return sub_100027E4C(a1, a2, a3, a4, a5, a6, a7, *(void **)(v7 + 16));
}

uint64_t sub_1000290F0()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100029100()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_100029128(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_retain();
  }
  return swift_retain();
}

uint64_t sub_100029180(void *a1, char a2, uint64_t a3, uint64_t a4, void *a5)
{
  return sub_1000278A8(a1, a2, a3, a4, a5, *(void **)(v5 + 16));
}

uint64_t sub_100029188()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100029198()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_1000291C0(void *a1, char a2, void *a3)
{
  return sub_1000277D4(a1, a2, a3, *(void **)(v3 + 16));
}

uint64_t sub_1000291C8()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_1000291D8()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_100029200(uint64_t a1, void *a2)
{
  return sub_100027FC4(a1, a2, *(void **)(v2 + 16), (void (*)(uint64_t))sub_1000370B4);
}

uint64_t sub_100029230()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100029240(char *a1)
{
  return sub_1000279C8(a1);
}

uint64_t sub_100029248()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100029258()
{
  return (*(uint64_t (**)(void))(v0 + 16))() & 1;
}

unint64_t sub_100029284()
{
  unint64_t result = qword_10047D900;
  if (!qword_10047D900)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_10047D900);
  }
  return result;
}

unint64_t sub_1000292C4()
{
  unint64_t result = qword_10047DFD0;
  if (!qword_10047DFD0)
  {
    sub_100029284();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DFD0);
  }
  return result;
}

uint64_t sub_10002931C()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_10002932C(uint64_t a1)
{
  return sub_100028030(a1, *(void (**)(void))(v1 + 16));
}

uint64_t sub_100029334()
{
  return _swift_deallocObject(v0, 32, 7);
}

uint64_t sub_100029344()
{
  return (*(uint64_t (**)(void))(v0 + 16))() & 1;
}

uint64_t sub_1000293B8()
{
  uint64_t v0 = self;
  Class isa = Dictionary._bridgeToObjectiveC()().super.isa;
  id v9 = 0;
  id v2 = [v0 dataWithPropertyList:isa format:200 options:0 error:&v9];

  id v3 = v9;
  if (v2)
  {
    uint64_t v4 = static Data._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v6 = v5;

    type metadata accessor for PropertyListDecoder();
    swift_allocObject();
    PropertyListDecoder.init()();
    type metadata accessor for MBDryRestoreState();
    sub_10002C790(&qword_10047D920, (void (*)(uint64_t))type metadata accessor for MBDryRestoreState);
    dispatch thunk of PropertyListDecoder.decode<A>(_:from:)();
    swift_release();
    return sub_10000C6C0(v4, v6);
  }
  else
  {
    Swift::String v8 = v3;
    _convertNSErrorToError(_:)();

    return swift_willThrow();
  }
}

unint64_t sub_100029568(char a1)
{
  unint64_t result = 0x746E756F636361;
  switch(a1)
  {
    case 1:
      unint64_t result = 0x746F687370616E73;
      break;
    case 2:
      unint64_t result = 0x7274656D656C6574;
      break;
    case 3:
      unint64_t result = 0x4374706D65747461;
      break;
    case 4:
      unint64_t result = 0x6C617461466E6F6ELL;
      break;
    case 5:
      unint64_t result = 0xD000000000000017;
      break;
    case 6:
      unint64_t result = 0xD000000000000017;
      break;
    case 7:
      unint64_t result = 0xD000000000000019;
      break;
    case 8:
      unint64_t result = 0xD000000000000013;
      break;
    case 9:
      unint64_t result = 0xD00000000000001CLL;
      break;
    case 10:
      unint64_t result = 0xD000000000000018;
      break;
    case 11:
    case 12:
    case 13:
      unint64_t result = 0xD000000000000010;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_100029728(void *a1)
{
  uint64_t v3 = sub_100006FC8(&qword_10047D9F0);
  uint64_t v4 = *(void *)(v3 - 8);
  __chkstk_darwin(v3);
  unint64_t v6 = &v8[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_10000700C(a1, a1[3]);
  sub_10002C6E0();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v8[31] = 0;
  KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
  if (!v1)
  {
    v8[30] = 1;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[29] = 2;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[28] = 3;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[27] = 4;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    type metadata accessor for MBDryRestoreState();
    v8[26] = 5;
    type metadata accessor for Date();
    sub_10002C790(&qword_10047CD58, (void (*)(uint64_t))&type metadata accessor for Date);
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    v8[25] = 6;
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    v8[24] = 7;
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    v8[15] = 8;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[14] = 9;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[13] = 10;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[12] = 11;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[11] = 12;
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    v8[10] = 13;
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t sub_100029B38@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v66 = a2;
  uint64_t v3 = sub_100006FC8(&qword_10047D708);
  uint64_t v4 = __chkstk_darwin(v3 - 8);
  uint64_t v67 = (uint64_t)v62 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = __chkstk_darwin(v4);
  uint64_t v68 = (uint64_t)v62 - v7;
  uint64_t v8 = __chkstk_darwin(v6);
  uint64_t v73 = (char *)v62 - v9;
  uint64_t v10 = __chkstk_darwin(v8);
  uint64_t v74 = (char *)v62 - v11;
  __chkstk_darwin(v10);
  Swift::String v77 = (char *)v62 - v12;
  uint64_t v78 = sub_100006FC8(&qword_10047DA00);
  uint64_t v76 = *(void *)(v78 - 8);
  __chkstk_darwin(v78);
  Swift::String v82 = (char *)v62 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = type metadata accessor for MBDryRestoreState();
  uint64_t v15 = (int *)(v14 - 8);
  __chkstk_darwin(v14);
  id v17 = (char *)v62 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  *((void *)v17 + 4) = 0;
  *(_OWORD *)id v17 = 0u;
  *((_OWORD *)v17 + 1) = 0u;
  v17[40] = 1;
  *((void *)v17 + 6) = 0;
  v17[56] = 1;
  *((void *)v17 + 8) = 0;
  v17[72] = 1;
  Swift::String v18 = &v17[v15[11]];
  uint64_t v19 = type metadata accessor for Date();
  uint64_t v20 = *(void (**)(void))(*(void *)(v19 - 8) + 56);
  uint64_t v75 = (uint64_t)v18;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t))v20)(v18, 1, 1, v19);
  id v72 = &v17[v15[12]];
  v20();
  Swift::String v71 = &v17[v15[13]];
  v20();
  id v21 = &v17[v15[14]];
  *(void *)id v21 = 0;
  Swift::String v70 = (uint64_t *)v21;
  v21[8] = 1;
  uint64_t v22 = &v17[v15[15]];
  *(void *)uint64_t v22 = 0;
  Swift::String v69 = (uint64_t *)v22;
  v22[8] = 1;
  uint64_t v23 = &v17[v15[16]];
  *(void *)uint64_t v23 = 0;
  v23[8] = 1;
  id v24 = &v17[v15[17]];
  *(void *)id v24 = 0;
  *((void *)v24 + 1) = 0;
  uint64_t v25 = (uint64_t)&v17[v15[18]];
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v20)(v25, 1, 1, v19);
  uint64_t v26 = v15[19];
  uint64_t v81 = (uint64_t *)v17;
  uint64_t v27 = (uint64_t)&v17[v26];
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v20)(v27, 1, 1, v19);
  uint64_t v28 = a1[3];
  uint64_t v79 = a1;
  sub_10000700C(a1, v28);
  sub_10002C6E0();
  uint64_t v29 = v80;
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (v29)
  {
    uint64_t v60 = (uint64_t)v79;
    uint64_t v61 = (uint64_t)v81;
  }
  else
  {
    uint64_t v80 = (uint64_t *)v23;
    uint64_t v64 = v25;
    uint64_t v65 = v24;
    uint64_t v63 = v27;
    uint64_t v30 = v75;
    uint64_t v31 = v76;
    char v96 = 0;
    uint64_t v32 = (uint64_t)v77;
    uint64_t v33 = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    uint64_t v35 = v81;
    uint64_t *v81 = v33;
    v35[1] = v36;
    char v95 = 1;
    v35[2] = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    v35[3] = v37;
    char v94 = 2;
    v35[4] = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    *((unsigned char *)v35 + 40) = v38 & 1;
    char v93 = 3;
    v35[6] = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    *((unsigned char *)v35 + 56) = v39 & 1;
    char v92 = 4;
    v35[8] = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    *((unsigned char *)v35 + 72) = v40 & 1;
    char v91 = 5;
    uint64_t v41 = sub_10002C790(&qword_10047CD40, (void (*)(uint64_t))&type metadata accessor for Date);
    v62[1] = v19;
    v62[0] = v41;
    KeyedDecodingContainer.decodeIfPresent<A>(_:forKey:)();
    sub_10002C7D8(v32, v30);
    char v90 = 6;
    uint64_t v42 = (uint64_t)v74;
    KeyedDecodingContainer.decodeIfPresent<A>(_:forKey:)();
    sub_10002C7D8(v42, (uint64_t)v72);
    char v89 = 7;
    uint64_t v43 = (uint64_t)v73;
    KeyedDecodingContainer.decodeIfPresent<A>(_:forKey:)();
    sub_10002C7D8(v43, (uint64_t)v71);
    char v88 = 8;
    uint64_t v44 = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    uint64_t v45 = (uint64_t)v79;
    uint64_t v46 = v70;
    *Swift::String v70 = v44;
    *((unsigned char *)v46 + 8) = v47 & 1;
    char v87 = 9;
    uint64_t v48 = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    Swift::String v49 = v69;
    uint64_t *v69 = v48;
    *((unsigned char *)v49 + 8) = v50 & 1;
    char v86 = 10;
    uint64_t v51 = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    Swift::String v52 = v80;
    *uint64_t v80 = v51;
    *((unsigned char *)v52 + 8) = v53 & 1;
    char v85 = 11;
    uint64_t v54 = KeyedDecodingContainer.decodeIfPresent(_:forKey:)();
    uint64_t v56 = v55;
    uint64_t v57 = (uint64_t *)v65;
    swift_bridgeObjectRelease();
    *uint64_t v57 = v54;
    v57[1] = v56;
    char v84 = 12;
    KeyedDecodingContainer.decodeIfPresent<A>(_:forKey:)();
    sub_10002C7D8(v68, v64);
    char v83 = 13;
    uint64_t v58 = v78;
    unint64_t v59 = v82;
    KeyedDecodingContainer.decodeIfPresent<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v31 + 8))(v59, v58);
    uint64_t v60 = v45;
    uint64_t v61 = (uint64_t)v81;
    sub_10002C7D8(v67, v63);
    sub_10002C840(v61, v66);
  }
  sub_1000070A4(v60);
  return sub_10002C734(v61);
}

unint64_t sub_10002A2D4()
{
  return sub_100029568(*v0);
}

uint64_t sub_10002A2DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = sub_10002CB40(a1, a2);
  *a3 = result;
  return result;
}

void sub_10002A304(unsigned char *a1@<X8>)
{
  *a1 = 14;
}

uint64_t sub_10002A310(uint64_t a1)
{
  unint64_t v2 = sub_10002C6E0();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_10002A34C(uint64_t a1)
{
  unint64_t v2 = sub_10002C6E0();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_10002A388@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_100029B38(a1, a2);
}

uint64_t sub_10002A3A0(void *a1)
{
  return sub_100029728(a1);
}

uint64_t sub_10002A3B8@<X0>(uint64_t a1@<X8>)
{
  id v10 = 0;
  id v2 = [self personalPersonaWithError:&v10];
  if (v2)
  {
    uint64_t v3 = v2;
    id v4 = v10;
    if (sub_100018384(0x6F74736552797244, (void *)0xEF65746174536572))
    {
      sub_1000293B8();
      uint64_t v8 = type metadata accessor for MBDryRestoreState();
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56))(a1, 0, 1, v8);

      return swift_bridgeObjectRelease();
    }
    sub_100045F18(0xD00000000000001DLL, 0x8000000100305E00, 0xD000000000000014, 0x8000000100305D80);
  }
  else
  {
    id v5 = v10;
    uint64_t v6 = _convertNSErrorToError(_:)();

    swift_willThrow();
    sub_1000462C4(v6, 0xD000000000000020, 0x8000000100305DD0, 0xD000000000000014, 0x8000000100305D80);
    swift_errorRelease();
  }
  uint64_t v7 = type metadata accessor for MBDryRestoreState();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56))(a1, 1, 1, v7);
}

void sub_10002A6C8()
{
  id v7 = 0;
  id v0 = [self personalPersonaWithError:&v7];
  if (v0)
  {
    uint64_t v1 = v0;
    id v2 = v7;
    sub_100049814();
    Class isa = Dictionary._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    NSString v6 = String._bridgeToObjectiveC()();
    [v1 setPreferencesValue:isa forKey:v6];
  }
  else
  {
    id v3 = v7;
    uint64_t v4 = _convertNSErrorToError(_:)();

    swift_willThrow();
    sub_1000462C4(v4, 0xD000000000000020, 0x8000000100305DA0, 0xD000000000000014, 0x8000000100305D80);
    swift_errorRelease();
  }
}

uint64_t type metadata accessor for MBDryRestoreState()
{
  uint64_t result = qword_10047D980;
  if (!qword_10047D980) {
    return swift_getSingletonMetadata();
  }
  return result;
}

void *sub_10002A8A0(uint64_t a1, uint64_t *a2, int *a3)
{
  uint64_t v4 = (void *)a1;
  int v5 = *(_DWORD *)(*((void *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v18 = *a2;
    *uint64_t v4 = *a2;
    uint64_t v4 = (void *)(v18 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    uint64_t v7 = a2[1];
    *(void *)a1 = *a2;
    *(void *)(a1 + 8) = v7;
    uint64_t v8 = a2[2];
    uint64_t v9 = a2[4];
    *(void *)(a1 + 24) = a2[3];
    *(void *)(a1 + 32) = v9;
    *(unsigned char *)(a1 + 40) = *((unsigned char *)a2 + 40);
    *(void *)(a1 + 48) = a2[6];
    *(unsigned char *)(a1 + 56) = *((unsigned char *)a2 + 56);
    uint64_t v10 = a2[8];
    *(unsigned char *)(a1 + 72) = *((unsigned char *)a2 + 72);
    *(void *)(a1 + 64) = v10;
    uint64_t v11 = a3[9];
    uint64_t v12 = (void *)(a1 + v11);
    uint64_t v13 = (char *)a2 + v11;
    *(void *)(a1 + 16) = v8;
    uint64_t v14 = type metadata accessor for Date();
    uint64_t v15 = *(void *)(v14 - 8);
    uint64_t v16 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v15 + 48);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    if (v16(v13, 1, v14))
    {
      uint64_t v17 = sub_100006FC8(&qword_10047D708);
      memcpy(v12, v13, *(void *)(*(void *)(v17 - 8) + 64));
    }
    else
    {
      (*(void (**)(void *, char *, uint64_t))(v15 + 16))(v12, v13, v14);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v15 + 56))(v12, 0, 1, v14);
    }
    uint64_t v19 = a3[10];
    uint64_t v20 = (char *)v4 + v19;
    id v21 = (char *)a2 + v19;
    if (v16((char *)a2 + v19, 1, v14))
    {
      uint64_t v22 = sub_100006FC8(&qword_10047D708);
      memcpy(v20, v21, *(void *)(*(void *)(v22 - 8) + 64));
    }
    else
    {
      (*(void (**)(char *, char *, uint64_t))(v15 + 16))(v20, v21, v14);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(v20, 0, 1, v14);
    }
    uint64_t v23 = a3[11];
    id v24 = (char *)v4 + v23;
    uint64_t v25 = (char *)a2 + v23;
    if (v16((char *)a2 + v23, 1, v14))
    {
      uint64_t v26 = sub_100006FC8(&qword_10047D708);
      memcpy(v24, v25, *(void *)(*(void *)(v26 - 8) + 64));
    }
    else
    {
      (*(void (**)(char *, char *, uint64_t))(v15 + 16))(v24, v25, v14);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(v24, 0, 1, v14);
    }
    uint64_t v27 = a3[12];
    uint64_t v28 = a3[13];
    uint64_t v29 = (char *)v4 + v27;
    uint64_t v30 = (uint64_t)a2 + v27;
    *(void *)uint64_t v29 = *(void *)v30;
    v29[8] = *(unsigned char *)(v30 + 8);
    uint64_t v31 = (char *)v4 + v28;
    uint64_t v32 = (uint64_t)a2 + v28;
    *(void *)uint64_t v31 = *(void *)v32;
    v31[8] = *(unsigned char *)(v32 + 8);
    uint64_t v33 = a3[14];
    uint64_t v34 = a3[15];
    uint64_t v35 = (char *)v4 + v33;
    uint64_t v36 = (uint64_t)a2 + v33;
    *(void *)uint64_t v35 = *(void *)v36;
    v35[8] = *(unsigned char *)(v36 + 8);
    uint64_t v37 = (void *)((char *)v4 + v34);
    char v38 = (uint64_t *)((char *)a2 + v34);
    uint64_t v39 = v38[1];
    *uint64_t v37 = *v38;
    v37[1] = v39;
    uint64_t v40 = a3[16];
    uint64_t v41 = (char *)v4 + v40;
    uint64_t v42 = (char *)a2 + v40;
    swift_bridgeObjectRetain();
    if (v16(v42, 1, v14))
    {
      uint64_t v43 = sub_100006FC8(&qword_10047D708);
      memcpy(v41, v42, *(void *)(*(void *)(v43 - 8) + 64));
    }
    else
    {
      (*(void (**)(char *, char *, uint64_t))(v15 + 16))(v41, v42, v14);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(v41, 0, 1, v14);
    }
    uint64_t v44 = a3[17];
    uint64_t v45 = (char *)v4 + v44;
    uint64_t v46 = (char *)a2 + v44;
    if (v16(v46, 1, v14))
    {
      uint64_t v47 = sub_100006FC8(&qword_10047D708);
      memcpy(v45, v46, *(void *)(*(void *)(v47 - 8) + 64));
    }
    else
    {
      (*(void (**)(char *, char *, uint64_t))(v15 + 16))(v45, v46, v14);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v15 + 56))(v45, 0, 1, v14);
    }
  }
  return v4;
}

uint64_t sub_10002AD3C(uint64_t a1, int *a2)
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v4 = a1 + a2[9];
  uint64_t v5 = type metadata accessor for Date();
  uint64_t v13 = *(void *)(v5 - 8);
  NSString v6 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v13 + 48);
  if (!v6(v4, 1, v5)) {
    (*(void (**)(uint64_t, uint64_t))(v13 + 8))(v4, v5);
  }
  uint64_t v7 = a1 + a2[10];
  if (!v6(v7, 1, v5)) {
    (*(void (**)(uint64_t, uint64_t))(v13 + 8))(v7, v5);
  }
  uint64_t v8 = a1 + a2[11];
  if (!v6(v8, 1, v5)) {
    (*(void (**)(uint64_t, uint64_t))(v13 + 8))(v8, v5);
  }
  swift_bridgeObjectRelease();
  uint64_t v9 = a1 + a2[16];
  if (!v6(v9, 1, v5)) {
    (*(void (**)(uint64_t, uint64_t))(v13 + 8))(v9, v5);
  }
  uint64_t v10 = a1 + a2[17];
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v6)(v10, 1, v5);
  if (!result)
  {
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t))(v13 + 8);
    return v12(v10, v5);
  }
  return result;
}

uint64_t sub_10002AF3C(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v6;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v8;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v9 = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(void *)(a1 + 64) = v9;
  uint64_t v10 = a3[9];
  uint64_t v11 = (void *)(a1 + v10);
  uint64_t v12 = (const void *)(a2 + v10);
  *(void *)(a1 + 16) = v7;
  uint64_t v13 = type metadata accessor for Date();
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = *(unsigned int (**)(const void *, uint64_t, uint64_t))(v14 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  if (v15(v12, 1, v13))
  {
    uint64_t v16 = sub_100006FC8(&qword_10047D708);
    memcpy(v11, v12, *(void *)(*(void *)(v16 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v14 + 16))(v11, v12, v13);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v14 + 56))(v11, 0, 1, v13);
  }
  uint64_t v17 = a3[10];
  uint64_t v18 = (void *)(a1 + v17);
  uint64_t v19 = (const void *)(a2 + v17);
  if (v15((const void *)(a2 + v17), 1, v13))
  {
    uint64_t v20 = sub_100006FC8(&qword_10047D708);
    memcpy(v18, v19, *(void *)(*(void *)(v20 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v14 + 16))(v18, v19, v13);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v14 + 56))(v18, 0, 1, v13);
  }
  uint64_t v21 = a3[11];
  uint64_t v22 = (void *)(a1 + v21);
  uint64_t v23 = (const void *)(a2 + v21);
  if (v15((const void *)(a2 + v21), 1, v13))
  {
    uint64_t v24 = sub_100006FC8(&qword_10047D708);
    memcpy(v22, v23, *(void *)(*(void *)(v24 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v14 + 16))(v22, v23, v13);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v14 + 56))(v22, 0, 1, v13);
  }
  uint64_t v25 = a3[12];
  uint64_t v26 = a3[13];
  uint64_t v27 = a1 + v25;
  uint64_t v28 = a2 + v25;
  *(void *)uint64_t v27 = *(void *)v28;
  *(unsigned char *)(v27 + 8) = *(unsigned char *)(v28 + 8);
  uint64_t v29 = a1 + v26;
  uint64_t v30 = a2 + v26;
  *(void *)uint64_t v29 = *(void *)v30;
  *(unsigned char *)(v29 + 8) = *(unsigned char *)(v30 + 8);
  uint64_t v31 = a3[14];
  uint64_t v32 = a3[15];
  uint64_t v33 = a1 + v31;
  uint64_t v34 = a2 + v31;
  *(void *)uint64_t v33 = *(void *)v34;
  *(unsigned char *)(v33 + 8) = *(unsigned char *)(v34 + 8);
  uint64_t v35 = (void *)(a1 + v32);
  uint64_t v36 = (void *)(a2 + v32);
  uint64_t v37 = v36[1];
  *uint64_t v35 = *v36;
  v35[1] = v37;
  uint64_t v38 = a3[16];
  uint64_t v39 = (void *)(a1 + v38);
  uint64_t v40 = (const void *)(a2 + v38);
  swift_bridgeObjectRetain();
  if (v15(v40, 1, v13))
  {
    uint64_t v41 = sub_100006FC8(&qword_10047D708);
    memcpy(v39, v40, *(void *)(*(void *)(v41 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v14 + 16))(v39, v40, v13);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v14 + 56))(v39, 0, 1, v13);
  }
  uint64_t v42 = a3[17];
  uint64_t v43 = (void *)(a1 + v42);
  uint64_t v44 = (const void *)(a2 + v42);
  if (v15(v44, 1, v13))
  {
    uint64_t v45 = sub_100006FC8(&qword_10047D708);
    memcpy(v43, v44, *(void *)(*(void *)(v45 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v14 + 16))(v43, v44, v13);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v14 + 56))(v43, 0, 1, v13);
  }
  return a1;
}

uint64_t sub_10002B388(uint64_t a1, uint64_t a2, int *a3)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v6 = *(void *)(a2 + 32);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 32) = v6;
  uint64_t v7 = *(void *)(a2 + 48);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(a1 + 48) = v7;
  uint64_t v8 = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(void *)(a1 + 64) = v8;
  uint64_t v9 = a3[9];
  uint64_t v10 = (void *)(a1 + v9);
  uint64_t v11 = (void *)(a2 + v9);
  uint64_t v12 = type metadata accessor for Date();
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v13 + 48);
  int v15 = v14(v10, 1, v12);
  int v16 = v14(v11, 1, v12);
  if (v15)
  {
    if (!v16)
    {
      (*(void (**)(void *, void *, uint64_t))(v13 + 16))(v10, v11, v12);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v13 + 56))(v10, 0, 1, v12);
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (v16)
  {
    (*(void (**)(void *, uint64_t))(v13 + 8))(v10, v12);
LABEL_6:
    uint64_t v17 = sub_100006FC8(&qword_10047D708);
    memcpy(v10, v11, *(void *)(*(void *)(v17 - 8) + 64));
    goto LABEL_7;
  }
  (*(void (**)(void *, void *, uint64_t))(v13 + 24))(v10, v11, v12);
LABEL_7:
  uint64_t v18 = a3[10];
  uint64_t v19 = (void *)(a1 + v18);
  uint64_t v20 = (void *)(a2 + v18);
  int v21 = v14((void *)(a1 + v18), 1, v12);
  int v22 = v14(v20, 1, v12);
  if (v21)
  {
    if (!v22)
    {
      (*(void (**)(void *, void *, uint64_t))(v13 + 16))(v19, v20, v12);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v13 + 56))(v19, 0, 1, v12);
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (v22)
  {
    (*(void (**)(void *, uint64_t))(v13 + 8))(v19, v12);
LABEL_12:
    uint64_t v23 = sub_100006FC8(&qword_10047D708);
    memcpy(v19, v20, *(void *)(*(void *)(v23 - 8) + 64));
    goto LABEL_13;
  }
  (*(void (**)(void *, void *, uint64_t))(v13 + 24))(v19, v20, v12);
LABEL_13:
  uint64_t v24 = a3[11];
  uint64_t v25 = (void *)(a1 + v24);
  uint64_t v26 = (void *)(a2 + v24);
  int v27 = v14((void *)(a1 + v24), 1, v12);
  int v28 = v14(v26, 1, v12);
  if (v27)
  {
    if (!v28)
    {
      (*(void (**)(void *, void *, uint64_t))(v13 + 16))(v25, v26, v12);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v13 + 56))(v25, 0, 1, v12);
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (v28)
  {
    (*(void (**)(void *, uint64_t))(v13 + 8))(v25, v12);
LABEL_18:
    uint64_t v29 = sub_100006FC8(&qword_10047D708);
    memcpy(v25, v26, *(void *)(*(void *)(v29 - 8) + 64));
    goto LABEL_19;
  }
  (*(void (**)(void *, void *, uint64_t))(v13 + 24))(v25, v26, v12);
LABEL_19:
  uint64_t v30 = a3[12];
  uint64_t v31 = a1 + v30;
  uint64_t v32 = (uint64_t *)(a2 + v30);
  uint64_t v33 = *v32;
  *(unsigned char *)(v31 + 8) = *((unsigned char *)v32 + 8);
  *(void *)uint64_t v31 = v33;
  uint64_t v34 = a3[13];
  uint64_t v35 = a1 + v34;
  uint64_t v36 = (uint64_t *)(a2 + v34);
  uint64_t v37 = *v36;
  *(unsigned char *)(v35 + 8) = *((unsigned char *)v36 + 8);
  *(void *)uint64_t v35 = v37;
  uint64_t v38 = a3[14];
  uint64_t v39 = a1 + v38;
  uint64_t v40 = (uint64_t *)(a2 + v38);
  uint64_t v41 = *v40;
  *(unsigned char *)(v39 + 8) = *((unsigned char *)v40 + 8);
  *(void *)uint64_t v39 = v41;
  uint64_t v42 = a3[15];
  uint64_t v43 = (void *)(a1 + v42);
  uint64_t v44 = (void *)(a2 + v42);
  *uint64_t v43 = *v44;
  v43[1] = v44[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v45 = a3[16];
  uint64_t v46 = (void *)(a1 + v45);
  uint64_t v47 = (void *)(a2 + v45);
  int v48 = v14((void *)(a1 + v45), 1, v12);
  int v49 = v14(v47, 1, v12);
  if (v48)
  {
    if (!v49)
    {
      (*(void (**)(void *, void *, uint64_t))(v13 + 16))(v46, v47, v12);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v13 + 56))(v46, 0, 1, v12);
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (v49)
  {
    (*(void (**)(void *, uint64_t))(v13 + 8))(v46, v12);
LABEL_24:
    uint64_t v50 = sub_100006FC8(&qword_10047D708);
    memcpy(v46, v47, *(void *)(*(void *)(v50 - 8) + 64));
    goto LABEL_25;
  }
  (*(void (**)(void *, void *, uint64_t))(v13 + 24))(v46, v47, v12);
LABEL_25:
  uint64_t v51 = a3[17];
  Swift::String v52 = (void *)(a1 + v51);
  char v53 = (void *)(a2 + v51);
  int v54 = v14((void *)(a1 + v51), 1, v12);
  int v55 = v14(v53, 1, v12);
  if (!v54)
  {
    if (!v55)
    {
      (*(void (**)(void *, void *, uint64_t))(v13 + 24))(v52, v53, v12);
      return a1;
    }
    (*(void (**)(void *, uint64_t))(v13 + 8))(v52, v12);
    goto LABEL_30;
  }
  if (v55)
  {
LABEL_30:
    uint64_t v56 = sub_100006FC8(&qword_10047D708);
    memcpy(v52, v53, *(void *)(*(void *)(v56 - 8) + 64));
    return a1;
  }
  (*(void (**)(void *, void *, uint64_t))(v13 + 16))(v52, v53, v12);
  (*(void (**)(void *, void, uint64_t, uint64_t))(v13 + 56))(v52, 0, 1, v12);
  return a1;
}

uint64_t sub_10002B9E8(uint64_t a1, long long *a2, int *a3)
{
  long long v6 = *a2;
  long long v7 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(unsigned char *)(a1 + 40) = *((unsigned char *)a2 + 40);
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(unsigned char *)(a1 + 56) = *((unsigned char *)a2 + 56);
  *(unsigned char *)(a1 + 72) = *((unsigned char *)a2 + 72);
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  uint64_t v8 = a3[9];
  uint64_t v9 = (void *)(a1 + v8);
  uint64_t v10 = (char *)a2 + v8;
  *(_OWORD *)a1 = v6;
  *(_OWORD *)(a1 + 16) = v7;
  uint64_t v11 = type metadata accessor for Date();
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = *(unsigned int (**)(const void *, uint64_t, uint64_t))(v12 + 48);
  if (v13(v10, 1, v11))
  {
    uint64_t v14 = sub_100006FC8(&qword_10047D708);
    memcpy(v9, v10, *(void *)(*(void *)(v14 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, char *, uint64_t))(v12 + 32))(v9, v10, v11);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v9, 0, 1, v11);
  }
  uint64_t v15 = a3[10];
  int v16 = (void *)(a1 + v15);
  uint64_t v17 = (char *)a2 + v15;
  if (v13((char *)a2 + v15, 1, v11))
  {
    uint64_t v18 = sub_100006FC8(&qword_10047D708);
    memcpy(v16, v17, *(void *)(*(void *)(v18 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, char *, uint64_t))(v12 + 32))(v16, v17, v11);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v16, 0, 1, v11);
  }
  uint64_t v19 = a3[11];
  uint64_t v20 = (void *)(a1 + v19);
  int v21 = (char *)a2 + v19;
  if (v13((char *)a2 + v19, 1, v11))
  {
    uint64_t v22 = sub_100006FC8(&qword_10047D708);
    memcpy(v20, v21, *(void *)(*(void *)(v22 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, char *, uint64_t))(v12 + 32))(v20, v21, v11);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v20, 0, 1, v11);
  }
  uint64_t v23 = a3[12];
  uint64_t v24 = a3[13];
  uint64_t v25 = a1 + v23;
  uint64_t v26 = (uint64_t)a2 + v23;
  *(void *)uint64_t v25 = *(void *)v26;
  *(unsigned char *)(v25 + 8) = *(unsigned char *)(v26 + 8);
  uint64_t v27 = a1 + v24;
  uint64_t v28 = (uint64_t)a2 + v24;
  *(void *)uint64_t v27 = *(void *)v28;
  *(unsigned char *)(v27 + 8) = *(unsigned char *)(v28 + 8);
  uint64_t v29 = a3[14];
  uint64_t v30 = a3[15];
  uint64_t v31 = a1 + v29;
  uint64_t v32 = (uint64_t)a2 + v29;
  *(void *)uint64_t v31 = *(void *)v32;
  long long v33 = *(long long *)((char *)a2 + v30);
  *(unsigned char *)(v31 + 8) = *(unsigned char *)(v32 + 8);
  *(_OWORD *)(a1 + v30) = v33;
  uint64_t v34 = a3[16];
  uint64_t v35 = (void *)(a1 + v34);
  uint64_t v36 = (char *)a2 + v34;
  if (v13((char *)a2 + v34, 1, v11))
  {
    uint64_t v37 = sub_100006FC8(&qword_10047D708);
    memcpy(v35, v36, *(void *)(*(void *)(v37 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, char *, uint64_t))(v12 + 32))(v35, v36, v11);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v35, 0, 1, v11);
  }
  uint64_t v38 = a3[17];
  uint64_t v39 = (void *)(a1 + v38);
  uint64_t v40 = (char *)a2 + v38;
  if (v13(v40, 1, v11))
  {
    uint64_t v41 = sub_100006FC8(&qword_10047D708);
    memcpy(v39, v40, *(void *)(*(void *)(v41 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, char *, uint64_t))(v12 + 32))(v39, v40, v11);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v39, 0, 1, v11);
  }
  return a1;
}

uint64_t sub_10002BE0C(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v6;
  swift_bridgeObjectRelease();
  uint64_t v7 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v7;
  swift_bridgeObjectRelease();
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  uint64_t v8 = a3[9];
  uint64_t v9 = (void *)(a1 + v8);
  uint64_t v10 = (void *)(a2 + v8);
  uint64_t v11 = type metadata accessor for Date();
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v12 + 48);
  int v14 = v13(v9, 1, v11);
  int v15 = v13(v10, 1, v11);
  if (v14)
  {
    if (!v15)
    {
      (*(void (**)(void *, void *, uint64_t))(v12 + 32))(v9, v10, v11);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v9, 0, 1, v11);
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (v15)
  {
    (*(void (**)(void *, uint64_t))(v12 + 8))(v9, v11);
LABEL_6:
    uint64_t v16 = sub_100006FC8(&qword_10047D708);
    memcpy(v9, v10, *(void *)(*(void *)(v16 - 8) + 64));
    goto LABEL_7;
  }
  (*(void (**)(void *, void *, uint64_t))(v12 + 40))(v9, v10, v11);
LABEL_7:
  uint64_t v17 = a3[10];
  uint64_t v18 = (void *)(a1 + v17);
  uint64_t v19 = (void *)(a2 + v17);
  int v20 = v13((void *)(a1 + v17), 1, v11);
  int v21 = v13(v19, 1, v11);
  if (v20)
  {
    if (!v21)
    {
      (*(void (**)(void *, void *, uint64_t))(v12 + 32))(v18, v19, v11);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v18, 0, 1, v11);
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (v21)
  {
    (*(void (**)(void *, uint64_t))(v12 + 8))(v18, v11);
LABEL_12:
    uint64_t v22 = sub_100006FC8(&qword_10047D708);
    memcpy(v18, v19, *(void *)(*(void *)(v22 - 8) + 64));
    goto LABEL_13;
  }
  (*(void (**)(void *, void *, uint64_t))(v12 + 40))(v18, v19, v11);
LABEL_13:
  uint64_t v23 = a3[11];
  uint64_t v24 = (void *)(a1 + v23);
  uint64_t v25 = (void *)(a2 + v23);
  int v26 = v13((void *)(a1 + v23), 1, v11);
  int v27 = v13(v25, 1, v11);
  if (v26)
  {
    if (!v27)
    {
      (*(void (**)(void *, void *, uint64_t))(v12 + 32))(v24, v25, v11);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v24, 0, 1, v11);
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (v27)
  {
    (*(void (**)(void *, uint64_t))(v12 + 8))(v24, v11);
LABEL_18:
    uint64_t v28 = sub_100006FC8(&qword_10047D708);
    memcpy(v24, v25, *(void *)(*(void *)(v28 - 8) + 64));
    goto LABEL_19;
  }
  (*(void (**)(void *, void *, uint64_t))(v12 + 40))(v24, v25, v11);
LABEL_19:
  uint64_t v29 = a3[12];
  uint64_t v30 = a3[13];
  uint64_t v31 = a1 + v29;
  uint64_t v32 = a2 + v29;
  *(void *)uint64_t v31 = *(void *)v32;
  *(unsigned char *)(v31 + 8) = *(unsigned char *)(v32 + 8);
  uint64_t v33 = a1 + v30;
  uint64_t v34 = a2 + v30;
  *(void *)uint64_t v33 = *(void *)v34;
  *(unsigned char *)(v33 + 8) = *(unsigned char *)(v34 + 8);
  uint64_t v35 = a3[14];
  uint64_t v36 = a3[15];
  uint64_t v37 = a1 + v35;
  uint64_t v38 = a2 + v35;
  *(void *)uint64_t v37 = *(void *)v38;
  *(unsigned char *)(v37 + 8) = *(unsigned char *)(v38 + 8);
  uint64_t v39 = (void *)(a1 + v36);
  uint64_t v40 = (uint64_t *)(a2 + v36);
  uint64_t v42 = *v40;
  uint64_t v41 = v40[1];
  *uint64_t v39 = v42;
  v39[1] = v41;
  swift_bridgeObjectRelease();
  uint64_t v43 = a3[16];
  uint64_t v44 = (void *)(a1 + v43);
  uint64_t v45 = (void *)(a2 + v43);
  int v46 = v13((void *)(a1 + v43), 1, v11);
  int v47 = v13(v45, 1, v11);
  if (v46)
  {
    if (!v47)
    {
      (*(void (**)(void *, void *, uint64_t))(v12 + 32))(v44, v45, v11);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v44, 0, 1, v11);
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (v47)
  {
    (*(void (**)(void *, uint64_t))(v12 + 8))(v44, v11);
LABEL_24:
    uint64_t v48 = sub_100006FC8(&qword_10047D708);
    memcpy(v44, v45, *(void *)(*(void *)(v48 - 8) + 64));
    goto LABEL_25;
  }
  (*(void (**)(void *, void *, uint64_t))(v12 + 40))(v44, v45, v11);
LABEL_25:
  uint64_t v49 = a3[17];
  uint64_t v50 = (void *)(a1 + v49);
  uint64_t v51 = (void *)(a2 + v49);
  int v52 = v13((void *)(a1 + v49), 1, v11);
  int v53 = v13(v51, 1, v11);
  if (!v52)
  {
    if (!v53)
    {
      (*(void (**)(void *, void *, uint64_t))(v12 + 40))(v50, v51, v11);
      return a1;
    }
    (*(void (**)(void *, uint64_t))(v12 + 8))(v50, v11);
    goto LABEL_30;
  }
  if (v53)
  {
LABEL_30:
    uint64_t v54 = sub_100006FC8(&qword_10047D708);
    memcpy(v50, v51, *(void *)(*(void *)(v54 - 8) + 64));
    return a1;
  }
  (*(void (**)(void *, void *, uint64_t))(v12 + 32))(v50, v51, v11);
  (*(void (**)(void *, void, uint64_t, uint64_t))(v12 + 56))(v50, 0, 1, v11);
  return a1;
}

uint64_t sub_10002C434(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_10002C448);
}

uint64_t sub_10002C448(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 2147483646)
  {
    unint64_t v4 = *(void *)(a1 + 8);
    if (v4 >= 0xFFFFFFFF) {
      LODWORD(v4) = -1;
    }
    int v5 = v4 - 1;
    if (v5 < 0) {
      int v5 = -1;
    }
    return (v5 + 1);
  }
  else
  {
    uint64_t v9 = sub_100006FC8(&qword_10047D708);
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 48);
    uint64_t v11 = v9;
    uint64_t v12 = a1 + *(int *)(a3 + 36);
    return v10(v12, a2, v11);
  }
}

uint64_t sub_10002C508(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_10002C51C);
}

uint64_t sub_10002C51C(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 2147483646)
  {
    *(void *)(result + 8) = a2;
  }
  else
  {
    uint64_t v7 = sub_100006FC8(&qword_10047D708);
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56);
    uint64_t v9 = v7;
    uint64_t v10 = v5 + *(int *)(a4 + 36);
    return v8(v10, a2, a2, v9);
  }
  return result;
}

void sub_10002C5C8()
{
  sub_10002C688();
  if (v0 <= 0x3F) {
    swift_initStructMetadata();
  }
}

void sub_10002C688()
{
  if (!qword_10047D990)
  {
    type metadata accessor for Date();
    unint64_t v0 = type metadata accessor for Optional();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_10047D990);
    }
  }
}

unint64_t sub_10002C6E0()
{
  unint64_t result = qword_10047D9F8;
  if (!qword_10047D9F8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D9F8);
  }
  return result;
}

uint64_t sub_10002C734(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for MBDryRestoreState();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_10002C790(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_10002C7D8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100006FC8(&qword_10047D708);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40))(a2, a1, v4);
  return a2;
}

uint64_t sub_10002C840(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for MBDryRestoreState();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreState.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xF3) {
    goto LABEL_17;
  }
  if (a2 + 13 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 13) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 13;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 13;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 13;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0xE;
  int v8 = v6 - 14;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBDryRestoreState.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 13 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 13) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF2)
  {
    unsigned int v6 = ((a2 - 243) >> 8) + 1;
    *uint64_t result = a2 + 13;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x10002CA00);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 13;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreState.CodingKeys()
{
  return &type metadata for MBDryRestoreState.CodingKeys;
}

unint64_t sub_10002CA3C()
{
  unint64_t result = qword_10047DA08;
  if (!qword_10047DA08)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DA08);
  }
  return result;
}

unint64_t sub_10002CA94()
{
  unint64_t result = qword_10047DA10;
  if (!qword_10047DA10)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DA10);
  }
  return result;
}

unint64_t sub_10002CAEC()
{
  unint64_t result = qword_10047DA18;
  if (!qword_10047DA18)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DA18);
  }
  return result;
}

uint64_t sub_10002CB40(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x746E756F636361 && a2 == 0xE700000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x746F687370616E73 && a2 == 0xE800000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x7274656D656C6574 && a2 == 0xEB00000000444979 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x4374706D65747461 && a2 == 0xEC000000746E756FLL {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 0x6C617461466E6F6ELL && a2 == 0xEE0073726F727245 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else if (a1 == 0xD000000000000017 && a2 == 0x8000000100305E60 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 5;
  }
  else if (a1 == 0xD000000000000017 && a2 == 0x8000000100305E80 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 6;
  }
  else if (a1 == 0xD000000000000019 && a2 == 0x8000000100305EA0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 7;
  }
  else if (a1 == 0xD000000000000013 && a2 == 0x8000000100305EC0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 8;
  }
  else if (a1 == 0xD00000000000001CLL && a2 == 0x8000000100305EE0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 9;
  }
  else if (a1 == 0xD000000000000018 && a2 == 0x8000000100305F00 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 10;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x8000000100305F20 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 11;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x8000000100305F40 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 12;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x8000000100305F60)
  {
    swift_bridgeObjectRelease();
    return 13;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 13;
    }
    else {
      return 14;
    }
  }
}

void *initializeBufferWithCopyOfBuffer for MBPath(void *a1, void *a2)
{
  *a1 = *a2;
  swift_retain();
  return a1;
}

uint64_t destroy for MBPath()
{
  return swift_release();
}

void *assignWithCopy for MBPath(void *a1, void *a2)
{
  *a1 = *a2;
  swift_retain();
  swift_release();
  return a1;
}

void *assignWithTake for MBPath(void *a1, void *a2)
{
  *a1 = *a2;
  swift_release();
  return a1;
}

uint64_t getEnumTagSinglePayload for MBPath(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7E && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 126);
  }
  unsigned int v3 = (((*(void *)a1 >> 57) >> 5) | (4 * ((*(void *)a1 >> 57) & 0x18 | *(void *)a1 & 7))) ^ 0x7F;
  if (v3 >= 0x7D) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for MBPath(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7D)
  {
    *(void *)unint64_t result = a2 - 126;
    if (a3 >= 0x7E) {
      *(unsigned char *)(result + 8) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7E) {
      *(unsigned char *)(result + 8) = 0;
    }
    if (a2)
    {
      uint64_t v3 = (-a2 >> 2) & 0x1F | (32 * (-a2 & 0x7F));
      *(void *)unint64_t result = (v3 | (v3 << 57)) & 0xF000000000000007;
    }
  }
  return result;
}

uint64_t sub_10002D230(void *a1)
{
  return *a1 >> 62;
}

void *sub_10002D23C(void *result)
{
  *result &= 0x3FFFFFFFFFFFFFFFuLL;
  return result;
}

uint64_t *sub_10002D24C(uint64_t *result, uint64_t a2)
{
  *unint64_t result = *result & 0xFFFFFFFFFFFFFF8 | (a2 << 62);
  return result;
}

ValueMetadata *type metadata accessor for MBPath()
{
  return &type metadata for MBPath;
}

uint64_t sub_10002D270(unint64_t a1)
{
  uint64_t v2 = type metadata accessor for FilePath();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  char v6 = (char *)&v26 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = __chkstk_darwin(v4);
  uint64_t v8 = __chkstk_darwin(v7);
  uint64_t v10 = (char *)&v26 - v9;
  uint64_t v11 = __chkstk_darwin(v8);
  uint64_t v13 = (char *)&v26 - v12;
  __chkstk_darwin(v11);
  int v15 = (char *)&v26 - v14;
  if (!(a1 >> 62))
  {
    uint64_t v22 = swift_projectBox();
    (*(void (**)(char *, uint64_t, uint64_t))(v3 + 16))(v15, v22, v2);
    uint64_t v20 = FilePath.string.getter();
    (*(void (**)(char *, uint64_t))(v3 + 8))(v15, v2);
    return v20;
  }
  if (a1 >> 62 == 1)
  {
    uint64_t v16 = sub_100006FC8(&qword_10047CFF0);
    uint64_t v17 = swift_projectBox();
    uint64_t v18 = v17 + *(int *)(v16 + 64);
    uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(v3 + 16);
    v19(v15, v17 + *(int *)(v16 + 48), v2);
    v19(v13, v18, v2);
    v19(v6, (uint64_t)v15, v2);
    FilePath.string.getter();
    FilePath.appending(_:)();
    FilePath.lexicallyNormalized()();
    uint64_t v20 = FilePath.string.getter();
    int v21 = *(void (**)(char *, uint64_t))(v3 + 8);
    v21(v10, v2);
    v21(v13, v2);
    v21(v15, v2);
    return v20;
  }
  uint64_t v24 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
  swift_retain();
  uint64_t v25 = sub_10002D270(v24);
  swift_release();
  return v25;
}

unint64_t sub_10002D538(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = type metadata accessor for FilePath();
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = __chkstk_darwin(v6);
  uint64_t v10 = (char *)&v33 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = __chkstk_darwin(v8);
  uint64_t v13 = (char *)&v33 - v12;
  __chkstk_darwin(v11);
  int v15 = (char *)&v33 - v14;
  if (a3 >> 62)
  {
    if (a3 >> 62 == 1)
    {
      uint64_t v16 = sub_100006FC8(&qword_10047CFF0);
      uint64_t v17 = (void **)swift_projectBox();
      uint64_t v33 = *v17;
      uint64_t v18 = (char *)v17 + *(int *)(v16 + 48);
      uint64_t v19 = (char *)v17 + *(int *)(v16 + 64);
      uint64_t v35 = a1;
      uint64_t v20 = *(void (**)(char *, char *, uint64_t))(v7 + 16);
      v20(v15, v18, v6);
      v20(v13, v19, v6);
      uint64_t v34 = swift_allocBox();
      uint64_t v22 = (char *)v21 + *(int *)(v16 + 48);
      uint64_t v23 = v33;
      void *v21 = v33;
      v20(v22, v15, v6);
      v20(v10, v13, v6);
      swift_bridgeObjectRetain();
      id v24 = v23;
      FilePath.appending(_:)();
      uint64_t v25 = *(void (**)(char *, uint64_t))(v7 + 8);
      v25(v13, v6);
      v25(v15, v6);
      return v34 | 0x4000000000000000;
    }
    else
    {
      uint64_t v29 = *(void *)((a3 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
      sub_1000091FC((a3 & 0x3FFFFFFFFFFFFFFFLL) + 16, (uint64_t)v36);
      uint64_t v30 = swift_allocObject();
      sub_1000091FC((uint64_t)v36, v30 + 16);
      swift_retain();
      uint64_t v31 = sub_10002D538(a1, a2, v29);
      swift_release();
      sub_1000070A4((uint64_t)v36);
      *(void *)(v30 + 56) = v31;
      return v30 | 0x8000000000000000;
    }
  }
  else
  {
    sub_100006FC8((uint64_t *)&unk_10047D910);
    uint64_t v27 = swift_projectBox();
    uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
    v28(v15, v27, v6);
    uint64_t v26 = swift_allocBox();
    v28(v13, (uint64_t)v15, v6);
    swift_bridgeObjectRetain();
    FilePath.appending(_:)();
    (*(void (**)(char *, uint64_t))(v7 + 8))(v15, v6);
  }
  return v26;
}

uint64_t sub_10002D874(unint64_t a1)
{
  uint64_t v2 = type metadata accessor for FilePath();
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  uint64_t v6 = (char *)&v32 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v4);
  uint64_t v8 = (char *)&v32 - v7;
  if (a1 >> 62)
  {
    if (a1 >> 62 == 1)
    {
      uint64_t v9 = sub_100006FC8(&qword_10047CFF0);
      uint64_t v10 = (void **)swift_projectBox();
      uint64_t v11 = *v10;
      uint64_t v12 = (char *)v10 + *(int *)(v9 + 64);
      uint64_t v13 = *(void (**)(char *, char *, uint64_t))(v3 + 16);
      v13(v8, (char *)v10 + *(int *)(v9 + 48), v2);
      v13(v6, v12, v2);
      uint64_t v32 = 0;
      unint64_t v33 = 0xE000000000000000;
      id v14 = v11;
      _StringGuts.grow(_:)(20);
      swift_bridgeObjectRelease();
      uint64_t v32 = 0x2068746150424D3CLL;
      unint64_t v33 = 0xEB000000003A6466;
      id v15 = [v14 description];
      uint64_t v16 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      uint64_t v18 = v17;

      v19._countAndFlagsBits = v16;
      v19._object = v18;
      String.append(_:)(v19);
      swift_bridgeObjectRelease();
      v20._countAndFlagsBits = 32;
      v20._object = (void *)0xE100000000000000;
      String.append(_:)(v20);
      sub_10002DBB8();
      v21._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
      String.append(_:)(v21);
      swift_bridgeObjectRelease();
      v22._countAndFlagsBits = 47;
      v22._object = (void *)0xE100000000000000;
      String.append(_:)(v22);
      v23._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
      String.append(_:)(v23);
      swift_bridgeObjectRelease();
      v24._countAndFlagsBits = 62;
      v24._object = (void *)0xE100000000000000;
      String.append(_:)(v24);

      uint64_t v25 = v32;
      uint64_t v26 = *(void (**)(char *, uint64_t))(v3 + 8);
      v26(v6, v2);
      v26(v8, v2);
    }
    else
    {
      uint64_t v30 = *(void *)((a1 & 0x3FFFFFFFFFFFFFFFLL) + 0x38);
      swift_retain();
      uint64_t v25 = sub_10002D874(v30);
      swift_release();
    }
  }
  else
  {
    uint64_t v27 = swift_projectBox();
    (*(void (**)(char *, uint64_t, uint64_t))(v3 + 16))(v8, v27, v2);
    uint64_t v32 = 0x3A68746150424D3CLL;
    unint64_t v33 = 0xE800000000000000;
    v28._countAndFlagsBits = FilePath.string.getter();
    String.append(_:)(v28);
    swift_bridgeObjectRelease();
    v29._countAndFlagsBits = 62;
    v29._object = (void *)0xE100000000000000;
    String.append(_:)(v29);
    uint64_t v25 = v32;
    (*(void (**)(char *, uint64_t))(v3 + 8))(v8, v2);
  }
  return v25;
}

uint64_t sub_10002DBB0()
{
  return sub_10002D874(*v0);
}

unint64_t sub_10002DBB8()
{
  unint64_t result = qword_10047D3F0;
  if (!qword_10047D3F0)
  {
    type metadata accessor for FilePath();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D3F0);
  }
  return result;
}

uint64_t sub_10002DC10()
{
  sub_1000070A4(v0 + 16);
  swift_release();
  return _swift_deallocObject(v0, 64, 7);
}

id sub_10002DC58()
{
  NSString v0 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  NSString v1 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v6 = 0;
  id v2 = [(id)swift_getObjCClassFromMetadata() temporaryDirectoryOnSameVolumeAsPath:v0 identifiedBy:v1 error:&v6];

  if (v2)
  {
    id v3 = v6;
  }
  else
  {
    id v4 = v6;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
  return v2;
}

uint64_t sub_10002DD60(char a1)
{
  if ((a1 & 1) == 0) {
    goto LABEL_5;
  }
  unint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
  if ((~v3 & 0xF000000000000007) == 0)
  {
    sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
    return swift_willThrow();
  }
  sub_10001BFFC(*(void *)(v1 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath));
  sub_100033DB8(v3);
  uint64_t result = sub_10001BFE4(v3);
  if (!v2)
  {
LABEL_5:
    uint64_t v5 = *(void *)(v1 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
    *(void *)(v1 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath) = 0xF000000000000007;
    return sub_10001BFE4(v5);
  }
  return result;
}

unint64_t sub_10002DE24(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = v2;
  unint64_t result = sub_10002FF2C();
  if (!v3)
  {
    uint64_t v8 = result;
    uint64_t v9 = v7;
    swift_bridgeObjectRelease();
    unint64_t v10 = *(void *)(v4 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
    if ((~v10 & 0xF000000000000007) != 0)
    {
      swift_retain();
      unint64_t v11 = sub_10002D538(v8, v9, v10);
      swift_bridgeObjectRelease();
      sub_10001BFE4(v10);
      *a2 = sub_100008804(v11) & 1;
      return swift_release();
    }
    else
    {
      sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
      swift_willThrow();
      return swift_bridgeObjectRelease();
    }
  }
  return result;
}

uint64_t sub_10002DF30(void *a1, void *a2)
{
  sub_100006FC8((uint64_t *)&unk_10047D910);
  unint64_t v6 = swift_allocBox();
  swift_bridgeObjectRetain();
  FilePath.init(_:)();
  unint64_t v7 = *(void *)(v2 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
  if ((~v7 & 0xF000000000000007) != 0)
  {
    swift_retain();
    unint64_t v8 = sub_10002FF2C();
    if (!v3)
    {
      uint64_t v12 = v10;
      uint64_t v13 = v11;
      unint64_t v21 = sub_10002D538(v8, v9, v7);
      swift_bridgeObjectRelease();
      unint64_t v14 = sub_10002D538(v12, v13, v7);
      swift_bridgeObjectRelease();
      sub_100007F74(448, v14);
      if (!*((unsigned char *)a1 + OBJC_IVAR____TtC7backupd14MBFetchedAsset_type))
      {
        sub_100030214(a1, v6, v21);
        goto LABEL_10;
      }
      if (*((unsigned char *)a1 + OBJC_IVAR____TtC7backupd14MBFetchedAsset_type) == 1)
      {
        sub_1000309A0((char *)a1, v6, v21);
LABEL_10:
        swift_release();
        swift_release();
        swift_release();
        return sub_10001BFE4(v7);
      }
      if (a2)
      {
        swift_unknownObjectRetain();
        sub_10003057C(a1, v6, v21, a2);
        swift_release();
        swift_release();
        swift_release();
        sub_10001BFE4(v7);
        return swift_unknownObjectRelease();
      }
      _StringGuts.grow(_:)(24);
      swift_bridgeObjectRelease();
      id v15 = [a1 description];
      uint64_t v16 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      uint64_t v18 = v17;
      swift_retain();

      v19._countAndFlagsBits = v16;
      v19._object = v18;
      String.append(_:)(v19);
      swift_bridgeObjectRelease();
      sub_100046A54(209, v6, 0xD000000000000016, 0x80000001003062E0, 0x203D746F7065643DLL, 0xE800000000000000);
      swift_release();
      swift_bridgeObjectRelease();
      swift_willThrow();
      swift_release();
      swift_release();
    }
    sub_10001BFE4(v7);
    return swift_release();
  }
  sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
  swift_willThrow();
  return swift_release();
}

_DWORD *sub_10002E33C()
{
  sub_100006FC8(&qword_10047DA78);
  uint64_t v0 = swift_allocObject();
  type metadata accessor for MBUnfairLock();
  uint64_t v1 = swift_allocObject();
  unint64_t result = (_DWORD *)swift_slowAlloc();
  *(void *)(v1 + 16) = result;
  *unint64_t result = 0;
  *(void *)(v0 + 16) = v1;
  *(void *)(v0 + 24) = &_swiftEmptyDictionarySingleton;
  off_10047DA20 = (_UNKNOWN *)v0;
  return result;
}

objc_class *sub_10002E3B4(unint64_t a1, char a2, char a3)
{
  uint64_t v5 = v3;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v10 = OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath;
  *(void *)&v5[OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath] = 0xF000000000000007;
  v5[OBJC_IVAR____TtC7backupd14MBRestoreDepot__requiresCrossVolumeCopy] = a2;
  v5[OBJC_IVAR____TtC7backupd14MBRestoreDepot__checkFileSizesForCASMatch] = a3;
  uint64_t v11 = v5;
  sub_100007F74(448, a1);
  if (v4)
  {
    swift_release();
    sub_10001BFE4(*(void *)&v5[v10]);

    swift_deallocPartialClassInstance();
  }
  else
  {
    uint64_t v12 = sub_100008C50(a1);
    uint64_t v14 = *(void *)&v5[v10];
    *(void *)&v5[v10] = v12;
    sub_10001BFE4(v14);
    unint64_t v15 = sub_10002D538(0xD000000000000010, 0x8000000100306110, a1);
    *(void *)&v11[OBJC_IVAR____TtC7backupd14MBRestoreDepot__assetProcessingRoot] = v15;
    swift_retain();
    sub_100007F74(448, v15);
    swift_release();
    unint64_t v16 = sub_10002D538(0xD000000000000015, 0x8000000100306130, a1);
    sub_100007F74(448, v16);
    unint64_t v17 = sub_10002D538(0xD00000000000001ELL, 0x8000000100306150, a1);
    sub_100007F74(448, v17);
    unint64_t v21 = v17;
    unint64_t v18 = sub_10002D538(0xD000000000000021, 0x8000000100306170, a1);
    sub_100007F74(448, v18);
    unint64_t v19 = sub_10002D538(0xD000000000000020, 0x80000001003061A0, a1);
    sub_100007F74(448, v19);

    v20.receiver = v11;
    v20.super_class = ObjectType;
    uint64_t ObjectType = (objc_class *)objc_msgSendSuper2(&v20, "init");
    swift_release();
    swift_release();
    swift_release();
    swift_release();
    swift_release();
  }
  return ObjectType;
}

uint64_t sub_10002E6E8@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, char a4@<W4>, objc_class **a5@<X8>)
{
  uint64_t v11 = *a1;
  if (*(void *)(*a1 + 16))
  {
    swift_bridgeObjectRetain();
    unint64_t v12 = sub_100031554(a2, (uint64_t)a3);
    if (v13)
    {
      uint64_t v14 = (objc_class *)*(id *)(*(void *)(v11 + 56) + 8 * v12);
      uint64_t result = swift_bridgeObjectRelease();
      *a5 = v14;
      return result;
    }
    swift_bridgeObjectRelease();
  }
  uint64_t result = sub_10002E9F0(a2, a3);
  if (!v5)
  {
    unint64_t v16 = result;
    id v17 = objc_allocWithZone((Class)type metadata accessor for MBRestoreDepot());
    swift_retain();
    unint64_t v18 = sub_10002E3B4(v16, a4 & 1, 0);
    _StringGuts.grow(_:)(38);
    swift_bridgeObjectRelease();
    id v19 = [(objc_class *)v18 description];
    uint64_t v20 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    Swift::String v29 = v18;
    Swift::String v22 = v21;

    v23._countAndFlagsBits = v20;
    v23._object = v22;
    String.append(_:)(v23);
    swift_bridgeObjectRelease();
    v24._countAndFlagsBits = 0x6C6F7620726F6620;
    v24._object = (void *)0xEC00000020656D75;
    String.append(_:)(v24);
    v25._countAndFlagsBits = a2;
    v25._object = a3;
    String.append(_:)(v25);
    sub_100045F18(0xD000000000000016, 0x80000001003060D0, 0x203D746F7065643DLL, 0xE800000000000000);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    uint64_t v26 = v29;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v28 = *a1;
    *a1 = 0x8000000000000000;
    sub_100032E38((uint64_t)v26, a2, (uint64_t)a3, isUniquelyReferenced_nonNull_native, &qword_10047DA70);
    *a1 = v28;
    swift_release();
    swift_bridgeObjectRelease();
    uint64_t result = swift_bridgeObjectRelease();
    *a5 = v26;
  }
  return result;
}

uint64_t sub_10002E9F0(uint64_t a1, void *a2)
{
  uint64_t v3 = v2;
  id v6 = [v2 restoreDepotRootsByVolume];
  uint64_t v7 = static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();

  if (!*(void *)(v7 + 16)) {
    goto LABEL_5;
  }
  swift_bridgeObjectRetain();
  sub_100031554(a1, (uint64_t)a2);
  if ((v8 & 1) == 0)
  {
    swift_bridgeObjectRelease();
LABEL_5:
    swift_bridgeObjectRelease();
    _StringGuts.grow(_:)(78);
    v10._countAndFlagsBits = 0xD000000000000036;
    v10._object = (void *)0x8000000100306200;
    String.append(_:)(v10);
    v11._countAndFlagsBits = a1;
    v11._object = a2;
    String.append(_:)(v11);
    v12._object = (void *)0x8000000100306240;
    v12._countAndFlagsBits = 0xD000000000000014;
    String.append(_:)(v12);
    id v13 = [v3 restoreDepotRootsByVolume];
    static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();

    v14._countAndFlagsBits = Dictionary.description.getter();
    String.append(_:)(v14);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v9 = 0xE000000000000000;
    sub_1000467F0(4, 0, 0xE000000000000000, 0x203D746F7065643DLL, 0xE800000000000000);
    swift_bridgeObjectRelease();
    swift_willThrow();
    return v9;
  }
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_100006FC8((uint64_t *)&unk_10047D910);
  uint64_t v9 = swift_allocBox();
  FilePath.init(_:)();
  return v9;
}

uint64_t sub_10002ED9C(void *a1)
{
  id v1 = [a1 restoreDepotRootsByVolume];
  uint64_t v2 = static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();

  if (qword_10047CB18 != -1) {
    swift_once();
  }
  uint64_t v3 = (uint64_t *)off_10047DA20;
  uint64_t v4 = *((void *)off_10047DA20 + 2);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v4 + 16));
  swift_beginAccess();
  sub_10002EE94(v3 + 3, v2);
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 16));
  return swift_bridgeObjectRelease();
}

uint64_t sub_10002EE94(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v48 = a2 + 64;
  uint64_t v4 = 1 << *(unsigned char *)(a2 + 32);
  uint64_t v5 = -1;
  if (v4 < 64) {
    uint64_t v5 = ~(-1 << v4);
  }
  unint64_t v6 = v5 & *(void *)(a2 + 64);
  int64_t v49 = (unint64_t)(v4 + 63) >> 6;
  swift_bridgeObjectRetain();
  int64_t v7 = 0;
  for (i = v2; ; uint64_t v2 = i)
  {
    while (1)
    {
      if (v6)
      {
        unint64_t v8 = __clz(__rbit64(v6));
        v6 &= v6 - 1;
        unint64_t v9 = v8 | (v7 << 6);
      }
      else
      {
        int64_t v10 = v7 + 1;
        if (__OFADD__(v7, 1))
        {
          __break(1u);
          goto LABEL_40;
        }
        if (v10 >= v49) {
          return swift_release();
        }
        unint64_t v11 = *(void *)(v48 + 8 * v10);
        ++v7;
        if (!v11)
        {
          int64_t v7 = v10 + 1;
          if (v10 + 1 >= v49) {
            return swift_release();
          }
          unint64_t v11 = *(void *)(v48 + 8 * v7);
          if (!v11)
          {
            int64_t v7 = v10 + 2;
            if (v10 + 2 >= v49) {
              return swift_release();
            }
            unint64_t v11 = *(void *)(v48 + 8 * v7);
            if (!v11)
            {
              int64_t v12 = v10 + 3;
              if (v12 >= v49) {
                return swift_release();
              }
              unint64_t v11 = *(void *)(v48 + 8 * v12);
              if (!v11)
              {
                while (1)
                {
                  int64_t v7 = v12 + 1;
                  if (__OFADD__(v12, 1)) {
                    break;
                  }
                  if (v7 >= v49) {
                    return swift_release();
                  }
                  unint64_t v11 = *(void *)(v48 + 8 * v7);
                  ++v12;
                  if (v11) {
                    goto LABEL_19;
                  }
                }
LABEL_40:
                __break(1u);
              }
              int64_t v7 = v12;
            }
          }
        }
LABEL_19:
        unint64_t v6 = (v11 - 1) & v11;
        unint64_t v9 = __clz(__rbit64(v11)) + (v7 << 6);
      }
      uint64_t v13 = 16 * v9;
      uint64_t v14 = *a1;
      if (!*(void *)(*a1 + 16))
      {
        swift_bridgeObjectRetain();
        goto LABEL_28;
      }
      unint64_t v15 = (uint64_t *)(*(void *)(v2 + 48) + v13);
      uint64_t v16 = *v15;
      uint64_t v17 = v15[1];
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain();
      unint64_t v18 = sub_100031554(v16, v17);
      if (v19) {
        break;
      }
      swift_bridgeObjectRelease_n();
      uint64_t v2 = i;
LABEL_28:
      sub_100006FC8((uint64_t *)&unk_10047D910);
      unint64_t v27 = swift_allocBox();
      FilePath.init(_:)();
      id v28 = [objc_allocWithZone((Class)NSFileManager) init];
      sub_10002D270(v27);
      NSString v29 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v50 = 0;
      unsigned int v30 = objc_msgSend(v28, "mb_moveToTmpDirThenRemoveItemAtPath:error:", v29, &v50);

      if (!v30)
      {
        id v40 = v50;
        uint64_t v41 = _convertNSErrorToError(_:)();

        swift_willThrow();
        id v50 = 0;
        unint64_t v51 = 0xE000000000000000;
        _StringGuts.grow(_:)(32);
        swift_bridgeObjectRelease();
        id v50 = (id)0xD00000000000001ELL;
        unint64_t v51 = 0x80000001003060B0;
        v42._countAndFlagsBits = sub_10002D874(v27);
        String.append(_:)(v42);
        swift_bridgeObjectRelease();
        sub_100045F30(v41, v27, (uint64_t)v50, v51, 0x203D746F7065643DLL, 0xE800000000000000);
        swift_bridgeObjectRelease();
        swift_willThrow();
        swift_errorRelease();
        swift_release();
        return swift_release();
      }
      id v31 = v50;
      swift_release();
    }
    uint64_t v20 = (char *)*(id *)(*(void *)(v14 + 56) + 8 * v18);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    unint64_t v21 = sub_100031554(v16, v17);
    char v23 = v22;
    swift_bridgeObjectRelease();
    if (v23)
    {
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      Swift::String v25 = (void *)*a1;
      id v50 = (id)*a1;
      *a1 = 0x8000000000000000;
      if ((isUniquelyReferenced_nonNull_native & 1) == 0)
      {
        sub_10003388C(&qword_10047DA70);
        Swift::String v25 = v50;
      }
      swift_bridgeObjectRelease();
      uint64_t v26 = *(void **)(v25[7] + 8 * v21);
      sub_100043A6C(v21, v25);
      *a1 = (uint64_t)v25;

      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    uint64_t v32 = OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath;
    unint64_t v33 = *(void *)&v20[OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath];
    if ((~v33 & 0xF000000000000007) == 0)
    {
      sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
      swift_willThrow();
      goto LABEL_37;
    }
    id v34 = objc_allocWithZone((Class)NSFileManager);
    swift_retain();
    id v35 = [v34 init];
    sub_10002D270(v33);
    NSString v36 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v50 = 0;
    unsigned int v37 = objc_msgSend(v35, "mb_moveToTmpDirThenRemoveItemAtPath:error:", v36, &v50);

    if (!v37) {
      break;
    }
    id v38 = v50;
    sub_10001BFE4(v33);
    uint64_t v39 = *(void *)&v20[v32];
    *(void *)&v20[v32] = 0xF000000000000007;
    sub_10001BFE4(v39);
  }
  id v43 = v50;
  uint64_t v44 = _convertNSErrorToError(_:)();

  swift_willThrow();
  id v50 = 0;
  unint64_t v51 = 0xE000000000000000;
  _StringGuts.grow(_:)(32);
  swift_bridgeObjectRelease();
  id v50 = (id)0xD00000000000001ELL;
  unint64_t v51 = 0x80000001003060B0;
  v45._countAndFlagsBits = sub_10002D874(v33);
  String.append(_:)(v45);
  swift_bridgeObjectRelease();
  sub_100045F30(v44, v33, (uint64_t)v50, v51, 0x203D746F7065643DLL, 0xE800000000000000);
  swift_bridgeObjectRelease();
  swift_willThrow();
  swift_errorRelease();
  sub_10001BFE4(v33);
LABEL_37:

  return swift_release();
}

uint64_t sub_10002F59C()
{
  _StringGuts.grow(_:)(26);
  v1._countAndFlagsBits = 60;
  v1._object = (void *)0xE100000000000000;
  String.append(_:)(v1);
  swift_getObjectType();
  v2._countAndFlagsBits = _typeName(_:qualified:)();
  String.append(_:)(v2);
  swift_bridgeObjectRelease();
  v3._countAndFlagsBits = 7876640;
  v3._object = (void *)0xE300000000000000;
  String.append(_:)(v3);
  _print_unlocked<A, B>(_:_:)();
  v4._countAndFlagsBits = 0x3A79706F63203ALL;
  v4._object = (void *)0xE700000000000000;
  String.append(_:)(v4);
  if (*(unsigned char *)(v0 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__requiresCrossVolumeCopy)) {
    uint64_t v5 = 1702195828;
  }
  else {
    uint64_t v5 = 0x65736C6166;
  }
  if (*(unsigned char *)(v0 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__requiresCrossVolumeCopy)) {
    unint64_t v6 = 0xE400000000000000;
  }
  else {
    unint64_t v6 = 0xE500000000000000;
  }
  unint64_t v7 = v6;
  String.append(_:)(*(Swift::String *)&v5);
  swift_bridgeObjectRelease();
  v8._countAndFlagsBits = 0x3A746F6F7220;
  v8._object = (void *)0xE600000000000000;
  String.append(_:)(v8);
  sub_10001BFFC(*(void *)(v0 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath));
  sub_100006FC8((uint64_t *)&unk_10047DE40);
  v9._countAndFlagsBits = String.init<A>(describing:)();
  String.append(_:)(v9);
  swift_bridgeObjectRelease();
  v10._countAndFlagsBits = 62;
  v10._object = (void *)0xE100000000000000;
  String.append(_:)(v10);
  return 0;
}

uint64_t sub_10002F728()
{
  id v1 = objc_msgSend(v0, "mb_base64EncodedFileSystemPathString");
  uint64_t v2 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  Swift::String v4 = v3;

  if (String.count.getter() <= 2)
  {
    _StringGuts.grow(_:)(60);
    v6._countAndFlagsBits = 0xD00000000000001ALL;
    v6._object = (void *)0x8000000100306260;
    String.append(_:)(v6);
    v7._countAndFlagsBits = v2;
    v7._object = v4;
    String.append(_:)(v7);
    swift_bridgeObjectRelease();
    v8._object = (void *)0x8000000100306280;
    v8._countAndFlagsBits = 0xD000000000000012;
    String.append(_:)(v8);
    v9._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v9);
    swift_bridgeObjectRelease();
    v10._countAndFlagsBits = 0x7463617261686320;
    v10._object = (void *)0xEC00000029737265;
    String.append(_:)(v10);
    unint64_t v11 = self;
    NSString v12 = String._bridgeToObjectiveC()();
    [v11 errorWithCode:1 description:v12];
    swift_bridgeObjectRelease();

    return swift_willThrow();
  }
  else
  {
    swift_bridgeObjectRetain();
    sub_100033FEC(2, v2, (unint64_t)v4);
    swift_bridgeObjectRelease();
    static String._fromSubstring(_:)();
    swift_bridgeObjectRelease();
    sub_1000340A8(2, v2, (uint64_t)v4, v5);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    String.init<A>(_:)();
    String.append<A>(contentsOf:)();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    String.init<A>(_:)();
    String.append<A>(contentsOf:)();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    String.init<A>(_:)();
    String.append<A>(contentsOf:)();
    swift_bridgeObjectRetain();
    uint64_t v14 = String.init<A>(_:)();
    sub_100034144();
    String.append<A>(contentsOf:)();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return v14;
  }
}

uint64_t sub_10002FB28(void *a1)
{
  uint64_t v2 = v1;
  swift_getObjectType();
  id v4 = objc_msgSend(a1, "domain", sub_100018054((uint64_t)v17).n128_f64[0]);
  id v5 = [v4 name];

  uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v8 = v7;

  sub_100006FC8((uint64_t *)&unk_10047D8F0);
  uint64_t v9 = swift_allocObject();
  *(_OWORD *)(v9 + 16) = xmmword_1003B21D0;
  *(void *)(v9 + 56) = &type metadata for String;
  unint64_t v10 = sub_100033F44();
  *(void *)(v9 + 32) = v6;
  *(void *)(v9 + 40) = v8;
  uint64_t v11 = v18;
  *(void *)(v9 + 96) = &type metadata for UInt64;
  *(void *)(v9 + 104) = &protocol witness table for UInt64;
  *(void *)(v9 + 64) = v10;
  *(void *)(v9 + 72) = v11;
  sub_100033F98();
  uint64_t v12 = StringProtocol.appendingFormat<A>(_:_:)();
  uint64_t v14 = v13;
  swift_bridgeObjectRelease();
  unint64_t v15 = *(void *)(v2 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
  if ((~v15 & 0xF000000000000007) != 0)
  {
    swift_retain();
    uint64_t v12 = sub_10002D538(v12, v14, v15);
    sub_10001BFE4(v15);
  }
  else
  {
    sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
    swift_willThrow();
  }
  swift_bridgeObjectRelease();
  return v12;
}

id sub_10002FD1C(uint64_t a1, void *a2)
{
  unint64_t v3 = *(void *)(v2 + OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath);
  if ((~v3 & 0xF000000000000007) != 0)
  {
    sub_10001C0F4(0, (unint64_t *)&qword_10047D070);
    swift_retain();
    sub_10002D270(v3);
    sub_10001BFE4(v3);
    _StringGuts.grow(_:)(18);
    swift_bridgeObjectRelease();
    v7._countAndFlagsBits = a1;
    v7._object = a2;
    String.append(_:)(v7);
    return sub_10002DC58();
  }
  else
  {
    sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
    return (id)swift_willThrow();
  }
}

unint64_t sub_10002FF2C()
{
  id v2 = [*(id *)&v0[OBJC_IVAR____TtC7backupd14MBFetchedAsset_metadata] assetSignature];
  if (v2)
  {
    unint64_t v3 = v2;
    uint64_t v4 = static Data._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v6 = v5;

    id v7 = objc_allocWithZone((Class)NSData);
    sub_100029128(v4, v6);
    Class isa = Data._bridgeToObjectiveC()().super.isa;
    id v9 = [v7 initWithData:isa];
    sub_10000C6C0(v4, v6);

    unint64_t v10 = (unint64_t)v9;
    uint64_t v11 = sub_10002F728();
    if (v1)
    {

      sub_10000C6C0(v4, v6);
    }
    else
    {
      unint64_t v10 = v11;
      sub_10000C6C0(v4, v6);
    }
  }
  else
  {
    _StringGuts.grow(_:)(34);
    swift_bridgeObjectRelease();
    id v12 = objc_msgSend(v0, "description", 0x656D207465737341);
    uint64_t v13 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v15 = v14;

    v16._countAndFlagsBits = v13;
    v16._object = v15;
    String.append(_:)(v16);
    swift_bridgeObjectRelease();
    v17._object = (void *)0x8000000100306460;
    v17._countAndFlagsBits = 0xD000000000000011;
    String.append(_:)(v17);
    unint64_t v10 = 0xEF20617461646174;
    uint64_t v18 = self;
    NSString v19 = String._bridgeToObjectiveC()();
    [v18 errorWithCode:1 description:v19];
    swift_bridgeObjectRelease();

    swift_willThrow();
  }
  return v10;
}

uint64_t sub_100030214(void *a1, unint64_t a2, unint64_t a3)
{
  if ((*(unsigned char *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__requiresCrossVolumeCopy) & 1) == 0) {
    return sub_100030DD0(a1, a2, a3);
  }
  uint64_t result = sub_1000311E0((uint64_t)a1, a3, a2);
  if (!v4)
  {
    if (result)
    {
      return (uint64_t)sub_10000819C(a2);
    }
    else
    {
      sub_10002D270(*(void *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__assetProcessingRoot));
      NSString v9 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v10 = (id)MBCreateTemporaryFilePathIn();

      static String._unconditionallyBridgeFromObjectiveC(_:)();
      sub_100006FC8((uint64_t *)&unk_10047D910);
      unint64_t v11 = swift_allocBox();
      FilePath.init(_:)();
      id v12 = self;
      sub_10002D270(a2);
      NSString v13 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      unint64_t v29 = v11;
      sub_10002D270(v11);
      NSString v14 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v30 = 0;
      unsigned int v15 = [v12 crossVolumeCopyFromSource:v13 toDestination:v14 shouldDeleteSource:0 error:&v30];

      if (v15)
      {
        id v16 = v30;
        sub_100030DD0(a1, v29, a3);
        sub_10000819C(a2);
      }
      else
      {
        id v17 = v30;
        uint64_t v18 = _convertNSErrorToError(_:)();

        swift_willThrow();
        id v30 = 0;
        unint64_t v31 = 0xE000000000000000;
        _StringGuts.grow(_:)(58);
        v19._object = (void *)0x8000000100306300;
        v19._countAndFlagsBits = 0xD000000000000015;
        String.append(_:)(v19);
        id v20 = [a1 description];
        uint64_t v21 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        char v23 = v22;

        v24._countAndFlagsBits = v21;
        v24._object = v23;
        String.append(_:)(v24);
        swift_bridgeObjectRelease();
        v25._countAndFlagsBits = 0x206D6F726620;
        v25._object = (void *)0xE600000000000000;
        String.append(_:)(v25);
        v26._countAndFlagsBits = sub_10002D874(a2);
        String.append(_:)(v26);
        swift_bridgeObjectRelease();
        v27._countAndFlagsBits = 0xD000000000000019;
        v27._object = (void *)0x8000000100306320;
        String.append(_:)(v27);
        v28._countAndFlagsBits = sub_10002D874(v29);
        String.append(_:)(v28);
        swift_bridgeObjectRelease();
        sub_100045F30(v18, a2, (uint64_t)v30, v31, 0x203D746F7065643DLL, 0xE800000000000000);
        swift_bridgeObjectRelease();
        swift_willThrow();
        swift_errorRelease();
      }
      return swift_release();
    }
  }
  return result;
}

uint64_t sub_10003057C(void *a1, unint64_t a2, unint64_t a3, void *a4)
{
  uint64_t result = sub_1000311E0((uint64_t)a1, a3, a2);
  if (!v5)
  {
    if (result) {
      return (uint64_t)sub_10000819C(a2);
    }
    sub_10002D270(*(void *)(v4 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__assetProcessingRoot));
    NSString v11 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v12 = (id)MBCreateTemporaryFilePathIn();

    static String._unconditionallyBridgeFromObjectiveC(_:)();
    sub_100006FC8((uint64_t *)&unk_10047D910);
    unint64_t v13 = swift_allocBox();
    FilePath.init(_:)();
    int v36 = *(unsigned __int8 *)(v4 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__requiresCrossVolumeCopy);
    if (v36 == 1)
    {
      id v34 = self;
      sub_10002D270(a2);
      NSString v14 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      unint64_t v35 = v13;
      sub_10002D270(v13);
      NSString v15 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v37 = 0;
      unsigned int v16 = [v34 crossVolumeCopyFromSource:v14 toDestination:v15 shouldDeleteSource:0 error:&v37];

      if (!v16)
      {
        id v22 = v37;
        uint64_t v23 = _convertNSErrorToError(_:)();

        swift_willThrow();
        unint64_t v18 = v35;
        id v37 = 0;
        unint64_t v38 = 0xE000000000000000;
        _StringGuts.grow(_:)(60);
        v24._countAndFlagsBits = 0xD00000000000003ALL;
        v24._object = (void *)0x80000001003063E0;
        String.append(_:)(v24);
        v25._countAndFlagsBits = sub_10002D874(v35);
        String.append(_:)(v25);
        swift_retain();
        goto LABEL_13;
      }
      id v17 = v37;
      unint64_t v18 = v35;
    }
    else
    {
      sub_1000078E4(v13, a2);
      unint64_t v18 = v13;
    }
    sub_10002D270(v18);
    NSString v19 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v37 = 0;
    unsigned int v20 = [a4 decrypt:v19 error:&v37];

    if (v20)
    {
      id v21 = v37;
      sub_100030DD0(a1, v18, a3);
      if (v36) {
        sub_10000819C(a2);
      }
      return swift_release();
    }
    id v26 = v37;
    uint64_t v23 = _convertNSErrorToError(_:)();

    swift_willThrow();
    id v37 = 0;
    unint64_t v38 = 0xE000000000000000;
    _StringGuts.grow(_:)(26);
    swift_retain();
    swift_bridgeObjectRelease();
    id v37 = (id)0xD000000000000012;
    unint64_t v38 = 0x8000000100306420;
    id v27 = [a1 description];
    uint64_t v28 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    id v30 = v29;

    v31._countAndFlagsBits = v28;
    v31._object = v30;
    String.append(_:)(v31);
    swift_bridgeObjectRelease();
    v32._countAndFlagsBits = 544497952;
    v32._object = (void *)0xE400000000000000;
    String.append(_:)(v32);
    v33._countAndFlagsBits = sub_10002D874(v18);
    String.append(_:)(v33);
LABEL_13:
    swift_bridgeObjectRelease();
    sub_100045F30(v23, v18, (uint64_t)v37, v38, 0x203D746F7065643DLL, 0xE800000000000000);
    swift_release();
    swift_bridgeObjectRelease();
    swift_willThrow();
    swift_errorRelease();
    return swift_release();
  }
  return result;
}

void sub_1000309A0(char *a1, unint64_t a2, unint64_t a3)
{
  char v8 = sub_1000311E0((uint64_t)a1, a3, a2);
  if (!v4)
  {
    if (v8)
    {
      sub_10000819C(a2);
    }
    else
    {
      sub_10002D270(*(void *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__assetProcessingRoot));
      NSString v9 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v10 = (id)MBCreateTemporaryFilePathIn();

      static String._unconditionallyBridgeFromObjectiveC(_:)();
      sub_100006FC8((uint64_t *)&unk_10047D910);
      unint64_t v21 = swift_allocBox();
      FilePath.init(_:)();
      dispatch_group_t v11 = dispatch_group_create();
      id v12 = [self decodingTaskWithEncodingMethod:1];
      if (v12)
      {
        unint64_t v13 = v12;
        sub_10002D270(a2);
        NSString v14 = String._bridgeToObjectiveC()();
        swift_bridgeObjectRelease();
        [v13 setSourcePath:v14];

        sub_10002D270(v21);
        NSString v15 = String._bridgeToObjectiveC()();
        swift_bridgeObjectRelease();
        [v13 setDestinationPath:v15];

        -[NSObject setCompressionMethod:](v13, "setCompressionMethod:", [*(id *)&a1[OBJC_IVAR____TtC7backupd14MBFetchedAsset_metadata] compressionMethod]);
        [v13 setProtectionClass:a1[OBJC_IVAR____TtC7backupd14MBFetchedAsset_protectionClass]];
        [v13 setGroup:v11];
        [v13 start];
        OS_dispatch_group.wait()();
        id v16 = [v13 error];
        if (v16)
        {
          uint64_t v17 = (uint64_t)v16;
          _StringGuts.grow(_:)(29);
          swift_bridgeObjectRelease();
          v18._countAndFlagsBits = sub_10002D874(a2);
          String.append(_:)(v18);
          swift_bridgeObjectRelease();
          v19._countAndFlagsBits = 544175136;
          v19._object = (void *)0xE400000000000000;
          String.append(_:)(v19);
          v20._countAndFlagsBits = sub_10002D874(v21);
          String.append(_:)(v20);
          swift_bridgeObjectRelease();
          sub_100045F30(v17, a2, 0xD000000000000015, 0x8000000100306440, 0x203D746F7065643DLL, 0xE800000000000000);
          swift_bridgeObjectRelease();
          swift_willThrow();
          swift_release();

          dispatch_group_t v11 = v13;
          unint64_t v13 = v17;
        }
        else
        {
          sub_100030DD0(a1, v21, a3);
          sub_10000819C(a2);
          swift_release();
        }
      }
      else
      {
        __break(1u);
      }
    }
  }
}

uint64_t sub_100030DD0(void *a1, unint64_t a2, unint64_t a3)
{
  sub_10002D270(a2);
  String.withPlatformString<A>(_:)();
  if (v3)
  {
    swift_bridgeObjectRelease();
    swift_getErrorValue();
    if (sub_100055064(v23) == 17)
    {
      if (sub_1000311E0((uint64_t)a1, a3, a2)) {
        sub_10000819C(a2);
      }
      _StringGuts.grow(_:)(31);
      swift_bridgeObjectRelease();
      id v7 = [a1 description];
      uint64_t v8 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      id v10 = v9;

      v11._countAndFlagsBits = v8;
      v11._object = v10;
      String.append(_:)(v11);
      swift_bridgeObjectRelease();
      v12._countAndFlagsBits = 0xD000000000000015;
      v12._object = (void *)0x80000001003063A0;
      String.append(_:)(v12);
      v13._countAndFlagsBits = sub_10002D874(a3);
      String.append(_:)(v13);
      swift_bridgeObjectRelease();
      sub_100045F18(0x207465737341, 0xE600000000000000, 0x203D746F7065643DLL, 0xE800000000000000);
      swift_bridgeObjectRelease();
    }
    else
    {
      _StringGuts.grow(_:)(38);
      swift_bridgeObjectRelease();
      v14._countAndFlagsBits = sub_10002D874(a2);
      String.append(_:)(v14);
      swift_bridgeObjectRelease();
      v15._object = (void *)0x8000000100306380;
      v15._countAndFlagsBits = 0xD000000000000013;
      String.append(_:)(v15);
      v16._countAndFlagsBits = sub_10002D874(a3);
      String.append(_:)(v16);
      swift_bridgeObjectRelease();
      sub_100045F30(v3, a2, 0x742064656C696146, 0xEF2065766F6D206FLL, 0x203D746F7065643DLL, 0xE800000000000000);
      swift_bridgeObjectRelease();
      swift_willThrow();
    }
    return swift_errorRelease();
  }
  else
  {
    swift_bridgeObjectRelease();
    sub_1000078E4(a3, a2);
    _StringGuts.grow(_:)(50);
    swift_bridgeObjectRelease();
    v17._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v17);
    swift_bridgeObjectRelease();
    v18._countAndFlagsBits = 0x206D6F72662029;
    v18._object = (void *)0xE700000000000000;
    String.append(_:)(v18);
    v19._countAndFlagsBits = sub_10002D874(a2);
    String.append(_:)(v19);
    swift_bridgeObjectRelease();
    v20._countAndFlagsBits = 0x6564206F746E6920;
    v20._object = (void *)0xEF20746120746F70;
    String.append(_:)(v20);
    v21._countAndFlagsBits = sub_10002D874(a3);
    String.append(_:)(v21);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD000000000000016, 0x80000001003063C0, 0x203D746F7065643DLL, 0xE800000000000000);
    return swift_bridgeObjectRelease();
  }
}

uint64_t sub_1000311E0(uint64_t a1, unint64_t a2, unint64_t a3)
{
  char v8 = sub_100008804(a2);
  char v9 = v8;
  if (!v4 && (v8 & 1) != 0 && *(unsigned char *)(v3 + OBJC_IVAR____TtC7backupd14MBRestoreDepot__checkFileSizesForCASMatch) == 1)
  {
    swift_retain();
    sub_100017A6C(a2, (uint64_t)v15);
    swift_retain();
    sub_100017A6C(a3, (uint64_t)v17);
    if (!*(unsigned char *)(a1 + OBJC_IVAR____TtC7backupd14MBFetchedAsset_type) && v16 != v18)
    {
      _StringGuts.grow(_:)(69);
      v10._countAndFlagsBits = 0x676E696D6F636E49;
      v10._object = (void *)0xEF20746573736120;
      String.append(_:)(v10);
      v11._countAndFlagsBits = sub_10002D874(a3);
      String.append(_:)(v11);
      swift_bridgeObjectRelease();
      v12._object = (void *)0x8000000100306340;
      v12._countAndFlagsBits = 0xD000000000000032;
      String.append(_:)(v12);
      v13._countAndFlagsBits = sub_10002D874(a2);
      String.append(_:)(v13);
      swift_bridgeObjectRelease();
      sub_100046A54(1, a3, 0, 0xE000000000000000, 0x203D746F7065643DLL, 0xE800000000000000);
      swift_bridgeObjectRelease();
      swift_willThrow();
    }
  }
  return v9 & 1;
}

uint64_t MBAssetType.description.getter(uint64_t a1)
{
  uint64_t v1 = (id)MBStringForAssetType(a1);
  uint64_t v2 = static String._unconditionallyBridgeFromObjectiveC(_:)();

  return v2;
}

uint64_t sub_10003145C()
{
  uint64_t v1 = (id)MBStringForAssetType(*v0);
  uint64_t v2 = static String._unconditionallyBridgeFromObjectiveC(_:)();

  return v2;
}

uint64_t type metadata accessor for MBRestoreDepot()
{
  return self;
}

unint64_t sub_1000314D0(uint64_t a1)
{
  type metadata accessor for UUID();
  sub_1000341B4((unint64_t *)&qword_10047D400);
  uint64_t v2 = dispatch thunk of Hashable._rawHashValue(seed:)();
  return sub_100031654(a1, v2);
}

unint64_t sub_100031554(uint64_t a1, uint64_t a2)
{
  Hasher.init(_seed:)();
  String.hash(into:)();
  Swift::Int v4 = Hasher._finalize()();
  return sub_100031800(a1, a2, v4);
}

unint64_t sub_1000315CC(uint64_t a1)
{
  uint64_t v2 = v1;
  Swift::Int v4 = NSObject._rawHashValue(seed:)(*(void *)(v2 + 40));
  return sub_1000318E4(a1, v4);
}

unint64_t sub_100031610(uint64_t a1)
{
  uint64_t v2 = v1;
  Swift::Int v4 = AnyHashable._rawHashValue(seed:)(*(void *)(v2 + 40));
  return sub_100031A00(a1, v4);
}

unint64_t sub_100031654(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a1;
  uint64_t v4 = type metadata accessor for UUID();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  id v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = v2;
  uint64_t v8 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t v9 = a2 & ~v8;
  uint64_t v18 = v2 + 64;
  if ((*(void *)(v2 + 64 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9))
  {
    uint64_t v10 = ~v8;
    Swift::String v13 = *(void (**)(char *, unint64_t, uint64_t))(v5 + 16);
    uint64_t v12 = v5 + 16;
    Swift::String v11 = v13;
    uint64_t v14 = *(void *)(v12 + 56);
    do
    {
      v11(v7, *(void *)(v20 + 48) + v14 * v9, v4);
      sub_1000341B4(&qword_10047D098);
      char v15 = dispatch thunk of static Equatable.== infix(_:_:)();
      (*(void (**)(char *, uint64_t))(v12 - 8))(v7, v4);
      if (v15) {
        break;
      }
      unint64_t v9 = (v9 + 1) & v10;
    }
    while (((*(void *)(v18 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) != 0);
  }
  return v9;
}

unint64_t sub_100031800(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if ((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6))
  {
    uint64_t v9 = *(void *)(v3 + 48);
    uint64_t v10 = (void *)(v9 + 16 * v6);
    BOOL v11 = *v10 == a1 && v10[1] == a2;
    if (!v11 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      uint64_t v12 = ~v5;
      do
      {
        unint64_t v6 = (v6 + 1) & v12;
        if (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) == 0) {
          break;
        }
        Swift::String v13 = (void *)(v9 + 16 * v6);
        BOOL v14 = *v13 == a1 && v13[1] == a2;
      }
      while (!v14 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0);
    }
  }
  return v6;
}

unint64_t sub_1000318E4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2 + 64;
  uint64_t v4 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t i = a2 & ~v4;
  if ((*(void *)(v2 + 64 + ((i >> 3) & 0xFFFFFFFFFFFFFF8)) >> i))
  {
    sub_10001C0F4(0, &qword_10047DAB0);
    id v6 = *(id *)(*(void *)(v2 + 48) + 8 * i);
    char v7 = static NSObject.== infix(_:_:)();

    if ((v7 & 1) == 0)
    {
      uint64_t v8 = ~v4;
      for (unint64_t i = (i + 1) & v8; ((*(void *)(v3 + ((i >> 3) & 0xFFFFFFFFFFFFFF8)) >> i) & 1) != 0; unint64_t i = (i + 1) & v8)
      {
        id v9 = *(id *)(*(void *)(v2 + 48) + 8 * i);
        char v10 = static NSObject.== infix(_:_:)();

        if (v10) {
          break;
        }
      }
    }
  }
  return i;
}

unint64_t sub_100031A00(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = -1 << *(unsigned char *)(v2 + 32);
  unint64_t v4 = a2 & ~v3;
  if ((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4))
  {
    uint64_t v5 = ~v3;
    do
    {
      sub_100033E94(*(void *)(v2 + 48) + 40 * v4, (uint64_t)v8);
      char v6 = static AnyHashable.== infix(_:_:)();
      sub_100033EF0((uint64_t)v8);
      if (v6) {
        break;
      }
      unint64_t v4 = (v4 + 1) & v5;
    }
    while (((*(void *)(v2 + 64 + ((v4 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v4) & 1) != 0);
  }
  return v4;
}

uint64_t sub_100031AC8(uint64_t a1, int a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = type metadata accessor for UUID();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *v2;
  sub_100006FC8(&qword_10047DAD0);
  int v46 = a2;
  uint64_t v10 = static _DictionaryStorage.resize(original:capacity:move:)();
  uint64_t v11 = v9;
  uint64_t v12 = v10;
  if (!*(void *)(v11 + 16)) {
    goto LABEL_41;
  }
  uint64_t v13 = 1 << *(unsigned char *)(v11 + 32);
  uint64_t v14 = *(void *)(v11 + 64);
  Swift::String v42 = (void *)(v11 + 64);
  if (v13 < 64) {
    uint64_t v15 = ~(-1 << v13);
  }
  else {
    uint64_t v15 = -1;
  }
  unint64_t v16 = v15 & v14;
  id v40 = v3;
  int64_t v41 = (unint64_t)(v13 + 63) >> 6;
  id v43 = (void (**)(char *, unint64_t, uint64_t))(v6 + 16);
  uint64_t v45 = v6;
  uint64_t v17 = (void (**)(char *, unint64_t, uint64_t))(v6 + 32);
  uint64_t v18 = v10 + 64;
  uint64_t result = swift_retain();
  int64_t v20 = 0;
  for (i = v11; ; uint64_t v11 = i)
  {
    if (v16)
    {
      unint64_t v22 = __clz(__rbit64(v16));
      v16 &= v16 - 1;
      unint64_t v23 = v22 | (v20 << 6);
      goto LABEL_22;
    }
    int64_t v24 = v20 + 1;
    if (__OFADD__(v20, 1))
    {
LABEL_42:
      __break(1u);
LABEL_43:
      __break(1u);
      return result;
    }
    if (v24 >= v41) {
      break;
    }
    Swift::String v25 = v42;
    unint64_t v26 = v42[v24];
    ++v20;
    if (!v26)
    {
      int64_t v20 = v24 + 1;
      if (v24 + 1 >= v41) {
        goto LABEL_34;
      }
      unint64_t v26 = v42[v20];
      if (!v26)
      {
        int64_t v27 = v24 + 2;
        if (v27 >= v41)
        {
LABEL_34:
          swift_release();
          uint64_t v3 = v40;
          if ((v46 & 1) == 0) {
            goto LABEL_41;
          }
          goto LABEL_37;
        }
        unint64_t v26 = v42[v27];
        if (!v26)
        {
          while (1)
          {
            int64_t v20 = v27 + 1;
            if (__OFADD__(v27, 1)) {
              goto LABEL_43;
            }
            if (v20 >= v41) {
              goto LABEL_34;
            }
            unint64_t v26 = v42[v20];
            ++v27;
            if (v26) {
              goto LABEL_21;
            }
          }
        }
        int64_t v20 = v27;
      }
    }
LABEL_21:
    unint64_t v16 = (v26 - 1) & v26;
    unint64_t v23 = __clz(__rbit64(v26)) + (v20 << 6);
LABEL_22:
    uint64_t v28 = *(void *)(v45 + 72);
    unint64_t v29 = *(void *)(v11 + 48) + v28 * v23;
    if (v46)
    {
      (*v17)(v8, v29, v5);
      id v30 = *(id *)(*(void *)(v11 + 56) + 8 * v23);
    }
    else
    {
      (*v43)(v8, v29, v5);
      id v30 = *(id *)(*(void *)(v11 + 56) + 8 * v23);
    }
    sub_1000341B4((unint64_t *)&qword_10047D400);
    uint64_t result = dispatch thunk of Hashable._rawHashValue(seed:)();
    uint64_t v31 = -1 << *(unsigned char *)(v12 + 32);
    unint64_t v32 = result & ~v31;
    unint64_t v33 = v32 >> 6;
    if (((-1 << v32) & ~*(void *)(v18 + 8 * (v32 >> 6))) != 0)
    {
      unint64_t v21 = __clz(__rbit64((-1 << v32) & ~*(void *)(v18 + 8 * (v32 >> 6)))) | v32 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v34 = 0;
      unint64_t v35 = (unint64_t)(63 - v31) >> 6;
      do
      {
        if (++v33 == v35 && (v34 & 1) != 0)
        {
          __break(1u);
          goto LABEL_42;
        }
        BOOL v36 = v33 == v35;
        if (v33 == v35) {
          unint64_t v33 = 0;
        }
        v34 |= v36;
        uint64_t v37 = *(void *)(v18 + 8 * v33);
      }
      while (v37 == -1);
      unint64_t v21 = __clz(__rbit64(~v37)) + (v33 << 6);
    }
    *(void *)(v18 + ((v21 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v21;
    uint64_t result = ((uint64_t (*)(unint64_t, char *, uint64_t))*v17)(*(void *)(v12 + 48) + v28 * v21, v8, v5);
    *(void *)(*(void *)(v12 + 56) + 8 * v21) = v30;
    ++*(void *)(v12 + 16);
  }
  swift_release();
  uint64_t v3 = v40;
  Swift::String v25 = v42;
  if ((v46 & 1) == 0) {
    goto LABEL_41;
  }
LABEL_37:
  uint64_t v38 = 1 << *(unsigned char *)(v11 + 32);
  if (v38 >= 64) {
    bzero(v25, ((unint64_t)(v38 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    *Swift::String v25 = -1 << v38;
  }
  *(void *)(v11 + 16) = 0;
LABEL_41:
  uint64_t result = swift_release();
  *uint64_t v3 = v12;
  return result;
}

uint64_t sub_100031ED8(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_100006FC8(&qword_10047DAC0);
  char v36 = a2;
  uint64_t v6 = static _DictionaryStorage.resize(original:capacity:move:)();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16)) {
    goto LABEL_40;
  }
  uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
  uint64_t v35 = v5 + 64;
  if (v8 < 64) {
    uint64_t v9 = ~(-1 << v8);
  }
  else {
    uint64_t v9 = -1;
  }
  unint64_t v10 = v9 & *(void *)(v5 + 64);
  int64_t v34 = (unint64_t)(v8 + 63) >> 6;
  uint64_t v11 = v6 + 64;
  uint64_t result = swift_retain();
  int64_t v13 = 0;
  while (1)
  {
    if (v10)
    {
      unint64_t v19 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v20 = v19 | (v13 << 6);
      goto LABEL_31;
    }
    int64_t v21 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v21 >= v34) {
      break;
    }
    unint64_t v22 = (void *)(v5 + 64);
    unint64_t v23 = *(void *)(v35 + 8 * v21);
    ++v13;
    if (!v23)
    {
      int64_t v13 = v21 + 1;
      if (v21 + 1 >= v34) {
        goto LABEL_33;
      }
      unint64_t v23 = *(void *)(v35 + 8 * v13);
      if (!v23)
      {
        int64_t v24 = v21 + 2;
        if (v24 >= v34)
        {
LABEL_33:
          swift_release();
          if ((v36 & 1) == 0) {
            goto LABEL_40;
          }
          goto LABEL_36;
        }
        unint64_t v23 = *(void *)(v35 + 8 * v24);
        if (!v23)
        {
          while (1)
          {
            int64_t v13 = v24 + 1;
            if (__OFADD__(v24, 1)) {
              goto LABEL_42;
            }
            if (v13 >= v34) {
              goto LABEL_33;
            }
            unint64_t v23 = *(void *)(v35 + 8 * v13);
            ++v24;
            if (v23) {
              goto LABEL_30;
            }
          }
        }
        int64_t v13 = v24;
      }
    }
LABEL_30:
    unint64_t v10 = (v23 - 1) & v23;
    unint64_t v20 = __clz(__rbit64(v23)) + (v13 << 6);
LABEL_31:
    unint64_t v29 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v20);
    uint64_t v31 = *v29;
    uint64_t v30 = v29[1];
    uint64_t v32 = *(void *)(*(void *)(v5 + 56) + 8 * v20);
    if ((v36 & 1) == 0)
    {
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    Hasher.init(_seed:)();
    String.hash(into:)();
    uint64_t result = Hasher._finalize()();
    uint64_t v14 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v15 = result & ~v14;
    unint64_t v16 = v15 >> 6;
    if (((-1 << v15) & ~*(void *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      unint64_t v17 = __clz(__rbit64((-1 << v15) & ~*(void *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v25 = 0;
      unint64_t v26 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        BOOL v27 = v16 == v26;
        if (v16 == v26) {
          unint64_t v16 = 0;
        }
        v25 |= v27;
        uint64_t v28 = *(void *)(v11 + 8 * v16);
      }
      while (v28 == -1);
      unint64_t v17 = __clz(__rbit64(~v28)) + (v16 << 6);
    }
    *(void *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    uint64_t v18 = (void *)(*(void *)(v7 + 48) + 16 * v17);
    *uint64_t v18 = v31;
    v18[1] = v30;
    *(void *)(*(void *)(v7 + 56) + 8 * v17) = v32;
    ++*(void *)(v7 + 16);
  }
  swift_release();
  unint64_t v22 = (void *)(v5 + 64);
  if ((v36 & 1) == 0) {
    goto LABEL_40;
  }
LABEL_36:
  uint64_t v33 = 1 << *(unsigned char *)(v5 + 32);
  if (v33 >= 64) {
    bzero(v22, ((unint64_t)(v33 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    *unint64_t v22 = -1 << v33;
  }
  *(void *)(v5 + 16) = 0;
LABEL_40:
  uint64_t result = swift_release();
  *uint64_t v3 = v7;
  return result;
}

uint64_t sub_1000321F0(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_100006FC8(&qword_10047DAC8);
  char v36 = a2;
  uint64_t v6 = static _DictionaryStorage.resize(original:capacity:move:)();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16)) {
    goto LABEL_40;
  }
  uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
  uint64_t v35 = v5 + 64;
  if (v8 < 64) {
    uint64_t v9 = ~(-1 << v8);
  }
  else {
    uint64_t v9 = -1;
  }
  unint64_t v10 = v9 & *(void *)(v5 + 64);
  int64_t v34 = (unint64_t)(v8 + 63) >> 6;
  uint64_t v11 = v6 + 64;
  uint64_t result = swift_retain();
  int64_t v13 = 0;
  while (1)
  {
    if (v10)
    {
      unint64_t v19 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v20 = v19 | (v13 << 6);
      goto LABEL_31;
    }
    int64_t v21 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v21 >= v34) {
      break;
    }
    unint64_t v22 = (void *)(v5 + 64);
    unint64_t v23 = *(void *)(v35 + 8 * v21);
    ++v13;
    if (!v23)
    {
      int64_t v13 = v21 + 1;
      if (v21 + 1 >= v34) {
        goto LABEL_33;
      }
      unint64_t v23 = *(void *)(v35 + 8 * v13);
      if (!v23)
      {
        int64_t v24 = v21 + 2;
        if (v24 >= v34)
        {
LABEL_33:
          swift_release();
          if ((v36 & 1) == 0) {
            goto LABEL_40;
          }
          goto LABEL_36;
        }
        unint64_t v23 = *(void *)(v35 + 8 * v24);
        if (!v23)
        {
          while (1)
          {
            int64_t v13 = v24 + 1;
            if (__OFADD__(v24, 1)) {
              goto LABEL_42;
            }
            if (v13 >= v34) {
              goto LABEL_33;
            }
            unint64_t v23 = *(void *)(v35 + 8 * v13);
            ++v24;
            if (v23) {
              goto LABEL_30;
            }
          }
        }
        int64_t v13 = v24;
      }
    }
LABEL_30:
    unint64_t v10 = (v23 - 1) & v23;
    unint64_t v20 = __clz(__rbit64(v23)) + (v13 << 6);
LABEL_31:
    unint64_t v29 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v20);
    uint64_t v31 = *v29;
    uint64_t v30 = v29[1];
    uint64_t v32 = *(void *)(*(void *)(v5 + 56) + 8 * v20);
    if ((v36 & 1) == 0)
    {
      swift_bridgeObjectRetain();
      swift_unknownObjectRetain();
    }
    Hasher.init(_seed:)();
    String.hash(into:)();
    uint64_t result = Hasher._finalize()();
    uint64_t v14 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v15 = result & ~v14;
    unint64_t v16 = v15 >> 6;
    if (((-1 << v15) & ~*(void *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      unint64_t v17 = __clz(__rbit64((-1 << v15) & ~*(void *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v25 = 0;
      unint64_t v26 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        BOOL v27 = v16 == v26;
        if (v16 == v26) {
          unint64_t v16 = 0;
        }
        v25 |= v27;
        uint64_t v28 = *(void *)(v11 + 8 * v16);
      }
      while (v28 == -1);
      unint64_t v17 = __clz(__rbit64(~v28)) + (v16 << 6);
    }
    *(void *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    uint64_t v18 = (void *)(*(void *)(v7 + 48) + 16 * v17);
    *uint64_t v18 = v31;
    v18[1] = v30;
    *(void *)(*(void *)(v7 + 56) + 8 * v17) = v32;
    ++*(void *)(v7 + 16);
  }
  swift_release();
  unint64_t v22 = (void *)(v5 + 64);
  if ((v36 & 1) == 0) {
    goto LABEL_40;
  }
LABEL_36:
  uint64_t v33 = 1 << *(unsigned char *)(v5 + 32);
  if (v33 >= 64) {
    bzero(v22, ((unint64_t)(v33 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    *unint64_t v22 = -1 << v33;
  }
  *(void *)(v5 + 16) = 0;
LABEL_40:
  uint64_t result = swift_release();
  *uint64_t v3 = v7;
  return result;
}

uint64_t sub_100032508(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_100006FC8(&qword_10047DAB8);
  uint64_t v6 = static _DictionaryStorage.resize(original:capacity:move:)();
  uint64_t v7 = v6;
  if (*(void *)(v5 + 16))
  {
    uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
    int64_t v34 = (void *)(v5 + 64);
    if (v8 < 64) {
      uint64_t v9 = ~(-1 << v8);
    }
    else {
      uint64_t v9 = -1;
    }
    unint64_t v10 = v9 & *(void *)(v5 + 64);
    int64_t v33 = (unint64_t)(v8 + 63) >> 6;
    uint64_t v11 = v6 + 64;
    uint64_t result = swift_retain();
    int64_t v13 = 0;
    while (1)
    {
      if (v10)
      {
        unint64_t v16 = __clz(__rbit64(v10));
        v10 &= v10 - 1;
        unint64_t v17 = v16 | (v13 << 6);
      }
      else
      {
        int64_t v18 = v13 + 1;
        if (__OFADD__(v13, 1))
        {
LABEL_40:
          __break(1u);
LABEL_41:
          __break(1u);
          return result;
        }
        if (v18 >= v33) {
          goto LABEL_34;
        }
        unint64_t v19 = v34[v18];
        ++v13;
        if (!v19)
        {
          int64_t v13 = v18 + 1;
          if (v18 + 1 >= v33) {
            goto LABEL_34;
          }
          unint64_t v19 = v34[v13];
          if (!v19)
          {
            int64_t v20 = v18 + 2;
            if (v20 >= v33)
            {
LABEL_34:
              swift_release();
              uint64_t v3 = v2;
              if (a2)
              {
                uint64_t v32 = 1 << *(unsigned char *)(v5 + 32);
                if (v32 >= 64) {
                  bzero(v34, ((unint64_t)(v32 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  void *v34 = -1 << v32;
                }
                *(void *)(v5 + 16) = 0;
              }
              break;
            }
            unint64_t v19 = v34[v20];
            if (!v19)
            {
              while (1)
              {
                int64_t v13 = v20 + 1;
                if (__OFADD__(v20, 1)) {
                  goto LABEL_41;
                }
                if (v13 >= v33) {
                  goto LABEL_34;
                }
                unint64_t v19 = v34[v13];
                ++v20;
                if (v19) {
                  goto LABEL_21;
                }
              }
            }
            int64_t v13 = v20;
          }
        }
LABEL_21:
        unint64_t v10 = (v19 - 1) & v19;
        unint64_t v17 = __clz(__rbit64(v19)) + (v13 << 6);
      }
      int64_t v21 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v17);
      uint64_t v23 = *v21;
      uint64_t v22 = v21[1];
      int64_t v24 = (_OWORD *)(*(void *)(v5 + 56) + 32 * v17);
      if (a2)
      {
        sub_100016C78(v24, v35);
      }
      else
      {
        sub_100018584((uint64_t)v24, (uint64_t)v35);
        swift_bridgeObjectRetain();
      }
      Hasher.init(_seed:)();
      String.hash(into:)();
      uint64_t result = Hasher._finalize()();
      uint64_t v25 = -1 << *(unsigned char *)(v7 + 32);
      unint64_t v26 = result & ~v25;
      unint64_t v27 = v26 >> 6;
      if (((-1 << v26) & ~*(void *)(v11 + 8 * (v26 >> 6))) != 0)
      {
        unint64_t v14 = __clz(__rbit64((-1 << v26) & ~*(void *)(v11 + 8 * (v26 >> 6)))) | v26 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v28 = 0;
        unint64_t v29 = (unint64_t)(63 - v25) >> 6;
        do
        {
          if (++v27 == v29 && (v28 & 1) != 0)
          {
            __break(1u);
            goto LABEL_40;
          }
          BOOL v30 = v27 == v29;
          if (v27 == v29) {
            unint64_t v27 = 0;
          }
          v28 |= v30;
          uint64_t v31 = *(void *)(v11 + 8 * v27);
        }
        while (v31 == -1);
        unint64_t v14 = __clz(__rbit64(~v31)) + (v27 << 6);
      }
      *(void *)(v11 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
      unint64_t v15 = (void *)(*(void *)(v7 + 48) + 16 * v14);
      *unint64_t v15 = v23;
      v15[1] = v22;
      uint64_t result = (uint64_t)sub_100016C78(v35, (_OWORD *)(*(void *)(v7 + 56) + 32 * v14));
      ++*(void *)(v7 + 16);
    }
  }
  uint64_t result = swift_release();
  *uint64_t v3 = v7;
  return result;
}

uint64_t sub_100032808(uint64_t a1, char a2, uint64_t *a3)
{
  unint64_t v4 = v3;
  uint64_t v6 = *v3;
  sub_100006FC8(a3);
  char v39 = a2;
  uint64_t v7 = static _DictionaryStorage.resize(original:capacity:move:)();
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16)) {
    goto LABEL_40;
  }
  uint64_t v9 = 1 << *(unsigned char *)(v6 + 32);
  uint64_t v38 = v6 + 64;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  else {
    uint64_t v10 = -1;
  }
  unint64_t v11 = v10 & *(void *)(v6 + 64);
  char v36 = v3;
  int64_t v37 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v12 = v7 + 64;
  uint64_t result = swift_retain();
  int64_t v14 = 0;
  while (1)
  {
    if (v11)
    {
      unint64_t v20 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v21 = v20 | (v14 << 6);
      goto LABEL_31;
    }
    int64_t v22 = v14 + 1;
    if (__OFADD__(v14, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v22 >= v37) {
      break;
    }
    uint64_t v23 = (void *)(v6 + 64);
    unint64_t v24 = *(void *)(v38 + 8 * v22);
    ++v14;
    if (!v24)
    {
      int64_t v14 = v22 + 1;
      if (v22 + 1 >= v37) {
        goto LABEL_33;
      }
      unint64_t v24 = *(void *)(v38 + 8 * v14);
      if (!v24)
      {
        int64_t v25 = v22 + 2;
        if (v25 >= v37)
        {
LABEL_33:
          swift_release();
          unint64_t v4 = v36;
          if ((v39 & 1) == 0) {
            goto LABEL_40;
          }
          goto LABEL_36;
        }
        unint64_t v24 = *(void *)(v38 + 8 * v25);
        if (!v24)
        {
          while (1)
          {
            int64_t v14 = v25 + 1;
            if (__OFADD__(v25, 1)) {
              goto LABEL_42;
            }
            if (v14 >= v37) {
              goto LABEL_33;
            }
            unint64_t v24 = *(void *)(v38 + 8 * v14);
            ++v25;
            if (v24) {
              goto LABEL_30;
            }
          }
        }
        int64_t v14 = v25;
      }
    }
LABEL_30:
    unint64_t v11 = (v24 - 1) & v24;
    unint64_t v21 = __clz(__rbit64(v24)) + (v14 << 6);
LABEL_31:
    BOOL v30 = (uint64_t *)(*(void *)(v6 + 48) + 16 * v21);
    uint64_t v32 = *v30;
    uint64_t v31 = v30[1];
    int64_t v33 = *(void **)(*(void *)(v6 + 56) + 8 * v21);
    if ((v39 & 1) == 0)
    {
      swift_bridgeObjectRetain();
      id v34 = v33;
    }
    Hasher.init(_seed:)();
    String.hash(into:)();
    uint64_t result = Hasher._finalize()();
    uint64_t v15 = -1 << *(unsigned char *)(v8 + 32);
    unint64_t v16 = result & ~v15;
    unint64_t v17 = v16 >> 6;
    if (((-1 << v16) & ~*(void *)(v12 + 8 * (v16 >> 6))) != 0)
    {
      unint64_t v18 = __clz(__rbit64((-1 << v16) & ~*(void *)(v12 + 8 * (v16 >> 6)))) | v16 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v26 = 0;
      unint64_t v27 = (unint64_t)(63 - v15) >> 6;
      do
      {
        if (++v17 == v27 && (v26 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        BOOL v28 = v17 == v27;
        if (v17 == v27) {
          unint64_t v17 = 0;
        }
        v26 |= v28;
        uint64_t v29 = *(void *)(v12 + 8 * v17);
      }
      while (v29 == -1);
      unint64_t v18 = __clz(__rbit64(~v29)) + (v17 << 6);
    }
    *(void *)(v12 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v18;
    unint64_t v19 = (void *)(*(void *)(v8 + 48) + 16 * v18);
    *unint64_t v19 = v32;
    v19[1] = v31;
    *(void *)(*(void *)(v8 + 56) + 8 * v18) = v33;
    ++*(void *)(v8 + 16);
  }
  swift_release();
  unint64_t v4 = v36;
  uint64_t v23 = (void *)(v6 + 64);
  if ((v39 & 1) == 0) {
    goto LABEL_40;
  }
LABEL_36:
  uint64_t v35 = 1 << *(unsigned char *)(v6 + 32);
  if (v35 >= 64) {
    bzero(v23, ((unint64_t)(v35 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    *uint64_t v23 = -1 << v35;
  }
  *(void *)(v6 + 16) = 0;
LABEL_40:
  uint64_t result = swift_release();
  *unint64_t v4 = v8;
  return result;
}

void sub_100032B14(uint64_t a1, uint64_t a2, char a3)
{
  unint64_t v4 = (void **)v3;
  uint64_t v8 = type metadata accessor for UUID();
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  unint64_t v11 = (char *)&v24 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = (void *)*v3;
  unint64_t v14 = sub_1000314D0(a2);
  uint64_t v15 = v12[2];
  BOOL v16 = (v13 & 1) == 0;
  uint64_t v17 = v15 + v16;
  if (__OFADD__(v15, v16))
  {
    __break(1u);
    goto LABEL_14;
  }
  char v18 = v13;
  uint64_t v19 = v12[3];
  if (v19 >= v17 && (a3 & 1) != 0)
  {
LABEL_7:
    unint64_t v20 = *v4;
    if (v18)
    {
LABEL_8:
      uint64_t v21 = v20[7];

      *(void *)(v21 + 8 * v14) = a1;
      return;
    }
    goto LABEL_11;
  }
  if (v19 >= v17 && (a3 & 1) == 0)
  {
    sub_100033090();
    goto LABEL_7;
  }
  sub_100031AC8(v17, a3 & 1);
  unint64_t v22 = sub_1000314D0(a2);
  if ((v18 & 1) != (v23 & 1))
  {
LABEL_14:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
    __break(1u);
    return;
  }
  unint64_t v14 = v22;
  unint64_t v20 = *v4;
  if (v18) {
    goto LABEL_8;
  }
LABEL_11:
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, a2, v8);
  sub_100032FD8(v14, (uint64_t)v11, a1, v20);
}

uint64_t sub_100032CBC(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  unint64_t v12 = sub_100031554(a2, a3);
  uint64_t v13 = *(void *)(v10 + 16);
  BOOL v14 = (v11 & 1) == 0;
  uint64_t v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
    goto LABEL_16;
  }
  char v16 = v11;
  uint64_t v17 = *(void *)(v10 + 24);
  if (v17 >= v15 && (a4 & 1) != 0) {
    goto LABEL_7;
  }
  if (v17 >= v15 && (a4 & 1) == 0)
  {
    sub_1000334E0();
LABEL_7:
    char v18 = (void *)*v5;
    if (v16)
    {
LABEL_8:
      uint64_t v19 = v18[7];
      uint64_t result = swift_unknownObjectRelease();
      *(void *)(v19 + 8 * v12) = a1;
      return result;
    }
    goto LABEL_11;
  }
  sub_1000321F0(v15, a4 & 1);
  unint64_t v21 = sub_100031554(a2, a3);
  if ((v16 & 1) != (v22 & 1))
  {
LABEL_17:
    uint64_t result = KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
    __break(1u);
    return result;
  }
  unint64_t v12 = v21;
  char v18 = (void *)*v5;
  if (v16) {
    goto LABEL_8;
  }
LABEL_11:
  v18[(v12 >> 6) + 8] |= 1 << v12;
  char v23 = (uint64_t *)(v18[6] + 16 * v12);
  *char v23 = a2;
  v23[1] = a3;
  *(void *)(v18[7] + 8 * v12) = a1;
  uint64_t v24 = v18[2];
  BOOL v25 = __OFADD__(v24, 1);
  uint64_t v26 = v24 + 1;
  if (v25)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  v18[2] = v26;
  return swift_bridgeObjectRetain();
}

void sub_100032E2C(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
}

void sub_100032E38(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t *a5)
{
  uint64_t v7 = v5;
  uint64_t v12 = *v5;
  unint64_t v14 = sub_100031554(a2, a3);
  uint64_t v15 = *(void *)(v12 + 16);
  BOOL v16 = (v13 & 1) == 0;
  uint64_t v17 = v15 + v16;
  if (__OFADD__(v15, v16))
  {
    __break(1u);
    goto LABEL_16;
  }
  char v18 = v13;
  uint64_t v19 = *(void *)(v12 + 24);
  if (v19 >= v17 && (a4 & 1) != 0) {
    goto LABEL_7;
  }
  if (v19 >= v17 && (a4 & 1) == 0)
  {
    sub_10003388C(a5);
LABEL_7:
    unint64_t v20 = (void *)*v7;
    if (v18)
    {
LABEL_8:
      uint64_t v21 = v20[7];

      *(void *)(v21 + 8 * v14) = a1;
      return;
    }
    goto LABEL_11;
  }
  sub_100032808(v17, a4 & 1, a5);
  unint64_t v22 = sub_100031554(a2, a3);
  if ((v18 & 1) != (v23 & 1))
  {
LABEL_17:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
    __break(1u);
    return;
  }
  unint64_t v14 = v22;
  unint64_t v20 = (void *)*v7;
  if (v18) {
    goto LABEL_8;
  }
LABEL_11:
  v20[(v14 >> 6) + 8] |= 1 << v14;
  uint64_t v24 = (uint64_t *)(v20[6] + 16 * v14);
  *uint64_t v24 = a2;
  v24[1] = a3;
  *(void *)(v20[7] + 8 * v14) = a1;
  uint64_t v25 = v20[2];
  BOOL v26 = __OFADD__(v25, 1);
  uint64_t v27 = v25 + 1;
  if (v26)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  v20[2] = v27;
  swift_bridgeObjectRetain();
}

void sub_100032FC0(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
}

void sub_100032FCC(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
}

uint64_t sub_100032FD8(unint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1 << a1;
  uint64_t v8 = a4[6];
  uint64_t v9 = type metadata accessor for UUID();
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 32))(v8 + *(void *)(*(void *)(v9 - 8) + 72) * a1, a2, v9);
  *(void *)(a4[7] + 8 * a1) = a3;
  uint64_t v11 = a4[2];
  BOOL v12 = __OFADD__(v11, 1);
  uint64_t v13 = v11 + 1;
  if (v12) {
    __break(1u);
  }
  else {
    a4[2] = v13;
  }
  return result;
}

id sub_100033090()
{
  uint64_t v1 = type metadata accessor for UUID();
  uint64_t v2 = *(void *)(v1 - 8);
  __chkstk_darwin(v1);
  unint64_t v4 = (char *)&v22 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100006FC8(&qword_10047DAD0);
  char v23 = v0;
  uint64_t v5 = *v0;
  uint64_t v6 = static _DictionaryStorage.copy(original:)();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16))
  {
LABEL_23:
    id result = (id)swift_release();
    *char v23 = v7;
    return result;
  }
  id result = (id)(v6 + 64);
  unint64_t v9 = (unint64_t)((1 << *(unsigned char *)(v7 + 32)) + 63) >> 6;
  if (v7 != v5 || (unint64_t)result >= v5 + 64 + 8 * v9) {
    id result = memmove(result, (const void *)(v5 + 64), 8 * v9);
  }
  uint64_t v24 = v5 + 64;
  int64_t v10 = 0;
  *(void *)(v7 + 16) = *(void *)(v5 + 16);
  uint64_t v11 = 1 << *(unsigned char *)(v5 + 32);
  uint64_t v12 = -1;
  if (v11 < 64) {
    uint64_t v12 = ~(-1 << v11);
  }
  unint64_t v13 = v12 & *(void *)(v5 + 64);
  uint64_t v27 = v2 + 16;
  int64_t v25 = (unint64_t)(v11 + 63) >> 6;
  uint64_t v26 = v2 + 32;
  while (1)
  {
    if (v13)
    {
      unint64_t v14 = __clz(__rbit64(v13));
      v13 &= v13 - 1;
      unint64_t v15 = v14 | (v10 << 6);
      goto LABEL_9;
    }
    int64_t v19 = v10 + 1;
    if (__OFADD__(v10, 1))
    {
      __break(1u);
      goto LABEL_25;
    }
    if (v19 >= v25) {
      goto LABEL_23;
    }
    unint64_t v20 = *(void *)(v24 + 8 * v19);
    ++v10;
    if (!v20)
    {
      int64_t v10 = v19 + 1;
      if (v19 + 1 >= v25) {
        goto LABEL_23;
      }
      unint64_t v20 = *(void *)(v24 + 8 * v10);
      if (!v20) {
        break;
      }
    }
LABEL_22:
    unint64_t v13 = (v20 - 1) & v20;
    unint64_t v15 = __clz(__rbit64(v20)) + (v10 << 6);
LABEL_9:
    unint64_t v16 = *(void *)(v2 + 72) * v15;
    (*(void (**)(char *, unint64_t, uint64_t))(v2 + 16))(v4, *(void *)(v5 + 48) + v16, v1);
    uint64_t v17 = 8 * v15;
    char v18 = *(void **)(*(void *)(v5 + 56) + v17);
    (*(void (**)(unint64_t, char *, uint64_t))(v2 + 32))(*(void *)(v7 + 48) + v16, v4, v1);
    *(void *)(*(void *)(v7 + 56) + v17) = v18;
    id result = v18;
  }
  int64_t v21 = v19 + 2;
  if (v21 >= v25) {
    goto LABEL_23;
  }
  unint64_t v20 = *(void *)(v24 + 8 * v21);
  if (v20)
  {
    int64_t v10 = v21;
    goto LABEL_22;
  }
  while (1)
  {
    int64_t v10 = v21 + 1;
    if (__OFADD__(v21, 1)) {
      break;
    }
    if (v10 >= v25) {
      goto LABEL_23;
    }
    unint64_t v20 = *(void *)(v24 + 8 * v10);
    ++v21;
    if (v20) {
      goto LABEL_22;
    }
  }
LABEL_25:
  __break(1u);
  return result;
}

void *sub_100033328()
{
  uint64_t v1 = v0;
  sub_100006FC8(&qword_10047DAC0);
  uint64_t v2 = *v0;
  uint64_t v3 = static _DictionaryStorage.copy(original:)();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    id result = (void *)swift_release();
    uint64_t *v1 = v4;
    return result;
  }
  id result = (void *)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    id result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v22 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v22 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v22);
    ++v9;
    if (!v23)
    {
      int64_t v9 = v22 + 1;
      if (v22 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v23 = *(void *)(v6 + 8 * v9);
      if (!v23) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v23 - 1) & v23;
    unint64_t v15 = __clz(__rbit64(v23)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 16 * v15;
    uint64_t v17 = (void *)(*(void *)(v2 + 48) + 16 * v15);
    uint64_t v18 = v17[1];
    uint64_t v19 = 8 * v15;
    uint64_t v20 = *(void *)(*(void *)(v2 + 56) + v19);
    int64_t v21 = (void *)(*(void *)(v4 + 48) + v16);
    void *v21 = *v17;
    v21[1] = v18;
    *(void *)(*(void *)(v4 + 56) + v19) = v20;
    swift_bridgeObjectRetain();
    id result = (void *)swift_bridgeObjectRetain();
  }
  int64_t v24 = v22 + 2;
  if (v24 >= v13) {
    goto LABEL_26;
  }
  unint64_t v23 = *(void *)(v6 + 8 * v24);
  if (v23)
  {
    int64_t v9 = v24;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v9);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

void *sub_1000334E0()
{
  uint64_t v1 = v0;
  sub_100006FC8(&qword_10047DAC8);
  uint64_t v2 = *v0;
  uint64_t v3 = static _DictionaryStorage.copy(original:)();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    id result = (void *)swift_release();
    uint64_t *v1 = v4;
    return result;
  }
  id result = (void *)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    id result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v22 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v22 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v22);
    ++v9;
    if (!v23)
    {
      int64_t v9 = v22 + 1;
      if (v22 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v23 = *(void *)(v6 + 8 * v9);
      if (!v23) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v23 - 1) & v23;
    unint64_t v15 = __clz(__rbit64(v23)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 16 * v15;
    uint64_t v17 = (void *)(*(void *)(v2 + 48) + 16 * v15);
    uint64_t v18 = v17[1];
    uint64_t v19 = 8 * v15;
    uint64_t v20 = *(void *)(*(void *)(v2 + 56) + v19);
    int64_t v21 = (void *)(*(void *)(v4 + 48) + v16);
    void *v21 = *v17;
    v21[1] = v18;
    *(void *)(*(void *)(v4 + 56) + v19) = v20;
    swift_bridgeObjectRetain();
    id result = (void *)swift_unknownObjectRetain();
  }
  int64_t v24 = v22 + 2;
  if (v24 >= v13) {
    goto LABEL_26;
  }
  unint64_t v23 = *(void *)(v6 + 8 * v24);
  if (v23)
  {
    int64_t v9 = v24;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v9);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

void *sub_100033698()
{
  uint64_t v1 = v0;
  sub_100006FC8(&qword_10047DAB8);
  uint64_t v2 = *v0;
  uint64_t v3 = static _DictionaryStorage.copy(original:)();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
    id result = (void *)swift_release();
LABEL_28:
    uint64_t *v1 = v4;
    return result;
  }
  int64_t v25 = v1;
  id result = (void *)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    id result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v22 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_30;
    }
    if (v22 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v22);
    ++v9;
    if (!v23)
    {
      int64_t v9 = v22 + 1;
      if (v22 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v23 = *(void *)(v6 + 8 * v9);
      if (!v23) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v23 - 1) & v23;
    unint64_t v15 = __clz(__rbit64(v23)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 16 * v15;
    uint64_t v17 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v15);
    uint64_t v19 = *v17;
    uint64_t v18 = v17[1];
    uint64_t v20 = 32 * v15;
    sub_100018584(*(void *)(v2 + 56) + 32 * v15, (uint64_t)v26);
    int64_t v21 = (void *)(*(void *)(v4 + 48) + v16);
    void *v21 = v19;
    v21[1] = v18;
    sub_100016C78(v26, (_OWORD *)(*(void *)(v4 + 56) + v20));
    id result = (void *)swift_bridgeObjectRetain();
  }
  int64_t v24 = v22 + 2;
  if (v24 >= v13)
  {
LABEL_26:
    id result = (void *)swift_release();
    uint64_t v1 = v25;
    goto LABEL_28;
  }
  unint64_t v23 = *(void *)(v6 + 8 * v24);
  if (v23)
  {
    int64_t v9 = v24;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v9);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }
LABEL_30:
  __break(1u);
  return result;
}

id sub_100033880()
{
  return sub_10003388C(&qword_10047DA88);
}

id sub_10003388C(uint64_t *a1)
{
  uint64_t v2 = v1;
  sub_100006FC8(a1);
  uint64_t v3 = *v1;
  uint64_t v4 = static _DictionaryStorage.copy(original:)();
  uint64_t v5 = v4;
  if (!*(void *)(v3 + 16))
  {
LABEL_26:
    id result = (id)swift_release();
    *uint64_t v2 = v5;
    return result;
  }
  id result = (id)(v4 + 64);
  uint64_t v7 = v3 + 64;
  unint64_t v8 = (unint64_t)((1 << *(unsigned char *)(v5 + 32)) + 63) >> 6;
  if (v5 != v3 || (unint64_t)result >= v3 + 64 + 8 * v8) {
    id result = memmove(result, (const void *)(v3 + 64), 8 * v8);
  }
  int64_t v10 = 0;
  *(void *)(v5 + 16) = *(void *)(v3 + 16);
  uint64_t v11 = 1 << *(unsigned char *)(v3 + 32);
  uint64_t v12 = -1;
  if (v11 < 64) {
    uint64_t v12 = ~(-1 << v11);
  }
  unint64_t v13 = v12 & *(void *)(v3 + 64);
  int64_t v14 = (unint64_t)(v11 + 63) >> 6;
  while (1)
  {
    if (v13)
    {
      unint64_t v15 = __clz(__rbit64(v13));
      v13 &= v13 - 1;
      unint64_t v16 = v15 | (v10 << 6);
      goto LABEL_12;
    }
    int64_t v23 = v10 + 1;
    if (__OFADD__(v10, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v23 >= v14) {
      goto LABEL_26;
    }
    unint64_t v24 = *(void *)(v7 + 8 * v23);
    ++v10;
    if (!v24)
    {
      int64_t v10 = v23 + 1;
      if (v23 + 1 >= v14) {
        goto LABEL_26;
      }
      unint64_t v24 = *(void *)(v7 + 8 * v10);
      if (!v24) {
        break;
      }
    }
LABEL_25:
    unint64_t v13 = (v24 - 1) & v24;
    unint64_t v16 = __clz(__rbit64(v24)) + (v10 << 6);
LABEL_12:
    uint64_t v17 = 16 * v16;
    uint64_t v18 = (void *)(*(void *)(v3 + 48) + 16 * v16);
    uint64_t v19 = v18[1];
    uint64_t v20 = 8 * v16;
    int64_t v21 = *(void **)(*(void *)(v3 + 56) + v20);
    int64_t v22 = (void *)(*(void *)(v5 + 48) + v17);
    *int64_t v22 = *v18;
    v22[1] = v19;
    *(void *)(*(void *)(v5 + 56) + v20) = v21;
    swift_bridgeObjectRetain();
    id result = v21;
  }
  int64_t v25 = v23 + 2;
  if (v25 >= v14) {
    goto LABEL_26;
  }
  unint64_t v24 = *(void *)(v7 + 8 * v25);
  if (v24)
  {
    int64_t v10 = v25;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v10 = v25 + 1;
    if (__OFADD__(v25, 1)) {
      break;
    }
    if (v10 >= v14) {
      goto LABEL_26;
    }
    unint64_t v24 = *(void *)(v7 + 8 * v10);
    ++v25;
    if (v24) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

void *sub_100033A38(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  int64_t v9 = self;
  int64_t v10 = String._bridgeToObjectiveC()();
  id v38 = 0;
  id v11 = [v9 volumeMountPointForFile:v10 error:&v38];

  id v12 = v38;
  if (!v11)
  {
    id v26 = v38;
    _convertNSErrorToError(_:)();

    swift_willThrow();
    return v10;
  }
  int64_t v10 = (void *)static String._unconditionallyBridgeFromObjectiveC(_:)();
  int64_t v14 = v13;
  id v15 = v12;

  id v16 = [a1 volumeMountPoint];
  uint64_t v17 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v19 = v18;

  if (v10 == (void *)v17 && v14 == v19)
  {
    swift_bridgeObjectRelease();
    char v22 = 0;
    if (a5)
    {
LABEL_7:
      swift_bridgeObjectRelease();
      sub_100006FC8((uint64_t *)&unk_10047D910);
      swift_allocBox();
      swift_bridgeObjectRetain();
      FilePath.init(_:)();
      id v23 = objc_allocWithZone((Class)type metadata accessor for MBRestoreDepot());
      unint64_t v24 = swift_retain();
      int64_t v25 = sub_10002E3B4(v24, v22 & 1, 0);
      if (v5)
      {
        swift_release();
      }
      else
      {
        int64_t v10 = v25;
        id v38 = 0;
        unint64_t v39 = 0xE000000000000000;
        _StringGuts.grow(_:)(46);
        swift_bridgeObjectRelease();
        id v38 = (id)0xD000000000000016;
        unint64_t v39 = 0x80000001003060D0;
        id v31 = [v10 description];
        uint64_t v32 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        id v34 = v33;

        v35._countAndFlagsBits = v32;
        v35._object = v34;
        String.append(_:)(v35);
        swift_bridgeObjectRelease();
        v36._object = (void *)0x80000001003060F0;
        v36._countAndFlagsBits = 0xD000000000000014;
        String.append(_:)(v36);
        v37._countAndFlagsBits = a4;
        v37._object = a5;
        String.append(_:)(v37);
        sub_100045F18((uint64_t)v38, v39, 0x203D746F7065643DLL, 0xE800000000000000);
        swift_release();
        swift_bridgeObjectRelease();
      }
      return v10;
    }
  }
  else
  {
    char v21 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    char v22 = v21 ^ 1;
    if (a5) {
      goto LABEL_7;
    }
  }
  if (qword_10047CB18 != -1) {
    swift_once();
  }
  uint64_t v27 = off_10047DA20;
  swift_bridgeObjectRetain();
  id v28 = a1;
  uint64_t v29 = sub_1000343F4((uint64_t)v27, (uint64_t)v10, v14, (uint64_t)v28, (objc_class *)(v22 & 1));
  if (!v5) {
    int64_t v10 = v29;
  }
  swift_bridgeObjectRelease_n();

  return v10;
}

id sub_100033DB8(unint64_t a1)
{
  id result = sub_1000083B8(a1);
  if (v1)
  {
    _StringGuts.grow(_:)(32);
    swift_bridgeObjectRelease();
    v4._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v4);
    swift_bridgeObjectRelease();
    sub_100045F30(v1, a1, 0xD00000000000001ELL, 0x80000001003060B0, 0x203D746F7065643DLL, 0xE800000000000000);
    swift_bridgeObjectRelease();
    swift_willThrow();
    return (id)swift_errorRelease();
  }
  return result;
}

uint64_t sub_100033E94(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_100033EF0(uint64_t a1)
{
  return a1;
}

unint64_t sub_100033F44()
{
  unint64_t result = qword_10047DA90;
  if (!qword_10047DA90)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DA90);
  }
  return result;
}

unint64_t sub_100033F98()
{
  unint64_t result = qword_10047DA98;
  if (!qword_10047DA98)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DA98);
  }
  return result;
}

uint64_t sub_100033FEC(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 < 0)
  {
    __break(1u);
LABEL_12:
    __break(1u);
    return String.subscript.getter();
  }
  if ((a3 & 0x2000000000000000) != 0) {
    uint64_t v3 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v4 = String.index(_:offsetBy:limitedBy:)();
  if (v5) {
    unint64_t v4 = 15;
  }
  if (4 * v3 < v4 >> 14) {
    goto LABEL_12;
  }
  return String.subscript.getter();
}

uint64_t sub_1000340A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0)
  {
    __break(1u);
  }
  else
  {
    uint64_t v4 = a3;
    uint64_t v5 = a2;
    uint64_t v6 = String.index(_:offsetBy:limitedBy:)();
    if (v7) {
      a2 = 15;
    }
    else {
      a2 = v6;
    }
    a1 = 15;
    a3 = v5;
    a4 = v4;
  }
  return String.subscript.getter(a1, a2, a3, a4);
}

unint64_t sub_100034144()
{
  unint64_t result = qword_10047DAA0;
  if (!qword_10047DAA0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DAA0);
  }
  return result;
}

uint64_t sub_100034198(uint64_t a1)
{
  return sub_1000084B4(a1, *(void *)(v1 + 16));
}

uint64_t sub_1000341B4(unint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    type metadata accessor for UUID();
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1000341F8()
{
  swift_slowDealloc();
  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for MBUnfairLock()
{
  return self;
}

uint64_t sub_100034260()
{
  uint64_t result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    uint64_t result = swift_initClassMetadata2();
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t *sub_100034304()
{
  uint64_t v1 = *v0;
  swift_release();
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v1 + 80) - 8) + 8))((uint64_t)v0 + *(void *)(*v0 + 96));
  return v0;
}

uint64_t sub_100034384()
{
  sub_100034304();
  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for MBUnfairLocked()
{
  return sub_100034578();
}

objc_class *sub_1000343F4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, objc_class *a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v10 + 16));
  swift_beginAccess();
  sub_10002E6E8((uint64_t *)(a1 + 24), a2, a3, (char)a5, &v12);
  swift_endAccess();
  if (!v5) {
    a5 = v12;
  }
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v10 + 16));
  return a5;
}

uint64_t sub_1000344B4(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v4 + 16));
  swift_beginAccess();
  uint64_t v5 = *(void *)(a1 + 24);
  if (*(unsigned char *)(a1 + 32))
  {
    sub_100034564(*(id *)(a1 + 24), *(unsigned char *)(a1 + 32));
    *(void *)(a1 + 24) = a2;
    *(unsigned char *)(a1 + 32) = 1;
    id v6 = a2;
    uint64_t v5 = 0;
  }
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 16));
  return v5;
}

void sub_100034564(id a1, char a2)
{
  if (a2 == 1) {
}
  }

uint64_t sub_100034578()
{
  return swift_getGenericMetadata();
}

void sub_100034878(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void (**)(void *))(a1 + 32);
  swift_retain();
  id v4 = a2;
  v3(a2);
  swift_release();
}

id sub_100034A60()
{
  uint64_t v1 = OBJC_IVAR____TtC7backupd14MBPersonaState____lazy_storage___encryptionManager;
  uint64_t v2 = *(void **)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState____lazy_storage___encryptionManager);
  if (v2)
  {
    id v3 = *(id *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState____lazy_storage___encryptionManager);
  }
  else
  {
    id v4 = [objc_allocWithZone((Class)MBCKEncryptionManager) init];
    uint64_t v5 = *(void **)(v0 + v1);
    *(void *)(v0 + v1) = v4;
    id v3 = v4;

    uint64_t v2 = 0;
  }
  id v6 = v2;
  return v3;
}

void sub_100035104()
{
  uint64_t v1 = *(void **)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_restoreLogger);
  *(void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_restoreLogger) = 0;

  uint64_t v2 = *(void **)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_backgroundRestoreProgressMonitor);
  *(void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_backgroundRestoreProgressMonitor) = 0;

  id v3 = *(void **)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_restoreSession);
  *(void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_restoreSession) = 0;

  *(unsigned char *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_restoreSessionOverridden) = 0;
  id v4 = *(void **)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_deviceForRestore);
  *(void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_deviceForRestore) = 0;

  uint64_t v5 = *(void **)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_lockManager);
  *(void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_lockManager) = 0;

  *(void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_restoreKeyBagsByID) = sub_1000494A8((uint64_t)_swiftEmptyArrayStorage);
  swift_bridgeObjectRelease();
  *(void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_restoreTransaction) = 0;
  swift_unknownObjectRelease();
  id v6 = (void *)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_unboostBackgroundRestoreHandler);
  char v7 = *(void (**)(void))(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState_unboostBackgroundRestoreHandler);
  if (v7)
  {
    *id v6 = 0;
    v6[1] = 0;
    swift_retain();
    sub_100036EFC((uint64_t)v7);
    v7(0);
    sub_100036EFC((uint64_t)v7);
  }
  sub_10003525C();
}

void sub_10003525C()
{
  uint64_t v1 = OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan;
  uint64_t v2 = *(void **)(v0 + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan);
  if (v2)
  {
    uint64_t v3 = v0;
    id v4 = v2;
    _StringGuts.grow(_:)(34);
    swift_bridgeObjectRelease();
    id v5 = [v4 description];
    uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v8 = v7;

    v9._countAndFlagsBits = v6;
    v9._object = v8;
    String.append(_:)(v9);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD000000000000020, 0x8000000100306D00, 0xD000000000000010, 0x8000000100306C00);
    swift_bridgeObjectRelease();
    uint64_t v10 = *(void **)(v3 + v1);
    *(void *)(v3 + v1) = 0;

    sub_100036C6C();
  }
  else
  {
    sub_100045F18(0xD000000000000019, 0x8000000100306CE0, 0xD000000000000010, 0x8000000100306C00);
  }
}

id sub_100035404()
{
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_backup] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_initialMegaBackup] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_nextBackupSize] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_restore] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_restoreSession] = 0;
  v0[OBJC_IVAR____TtC7backupd14MBPersonaState_restoreSessionOverridden] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan] = 0;
  v0[OBJC_IVAR____TtC7backupd14MBPersonaState_isHoldingWorkAssertionForBackgroundRestore] = 0;
  uint64_t v2 = &v0[OBJC_IVAR____TtC7backupd14MBPersonaState_unboostBackgroundRestoreHandler];
  *uint64_t v2 = 0;
  v2[1] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_deviceForRestore] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_lockManager] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState____lazy_storage___encryptionManager] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_backgroundRestoreProgressMonitor] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_restoreLogger] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd14MBPersonaState_restoreTransaction] = 0;
  uint64_t v3 = OBJC_IVAR____TtC7backupd14MBPersonaState_restoreQosByContext;
  id v4 = self;
  id v5 = v0;
  *(void *)&v0[v3] = [v4 weakToStrongObjectsMapTable];
  *(void *)&v5[OBJC_IVAR____TtC7backupd14MBPersonaState_restoreKeyBagsByID] = &_swiftEmptyDictionarySingleton;
  v5[OBJC_IVAR____TtC7backupd14MBPersonaState_finishedAppRestores] = 0;
  *(_DWORD *)&v5[OBJC_IVAR____TtC7backupd14MBPersonaState_serviceState] = 0;
  uint64_t v6 = OBJC_IVAR____TtC7backupd14MBPersonaState_serviceGroup;
  *(void *)&v5[v6] = dispatch_group_create();
  *(void *)&v5[OBJC_IVAR____TtC7backupd14MBPersonaState_engines] = _swiftEmptyArrayStorage;
  uint64_t v7 = OBJC_IVAR____TtC7backupd14MBPersonaState_enginesByContext;
  *(void *)&v5[v7] = [objc_allocWithZone((Class)NSMapTable) init];
  *(void *)&v5[OBJC_IVAR____TtC7backupd14MBPersonaState_delayedRestoreTimer] = 0;
  *(void *)&v5[OBJC_IVAR____TtC7backupd14MBPersonaState_restoreTTRTimer] = 0;

  v9.receiver = v5;
  v9.super_class = ObjectType;
  return objc_msgSendSuper2(&v9, "init");
}

uint64_t type metadata accessor for MBPersonaState()
{
  return self;
}

void *sub_100035790(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(v2 + OBJC_IVAR____TtC7backupd21MBPersonaStateManager_lock);
  uint64_t v6 = *(os_unfair_lock_s **)(v5 + 16);
  swift_retain();
  os_unfair_lock_lock(v6);
  sub_1000358A4(v2, a1, a2, &v11);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v5 + 16));
  swift_release();
  uint64_t v7 = v11;
  unint64_t v8 = *(void **)&v11[OBJC_IVAR____TtC7backupd14MBPersonaState_restoreSession];
  id v9 = v8;

  return v8;
}

uint64_t sub_1000358A4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = (uint64_t *)(a1 + OBJC_IVAR____TtC7backupd21MBPersonaStateManager_personaIDStateMap);
  swift_beginAccess();
  uint64_t v8 = *v7;
  if (!*(void *)(*v7 + 16)) {
    goto LABEL_5;
  }
  swift_bridgeObjectRetain();
  unint64_t v9 = sub_100031554(a2, a3);
  if ((v10 & 1) == 0)
  {
    swift_bridgeObjectRelease();
LABEL_5:
    swift_endAccess();
    id v14 = [objc_allocWithZone((Class)type metadata accessor for MBPersonaState()) init];
    swift_beginAccess();
    swift_bridgeObjectRetain();
    id v12 = v14;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v16 = *v7;
    *uint64_t v7 = 0x8000000000000000;
    sub_100032E2C((uint64_t)v12, a2, a3, isUniquelyReferenced_nonNull_native);
    *uint64_t v7 = v16;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t result = swift_endAccess();
    goto LABEL_6;
  }
  id v11 = *(void **)(*(void *)(v8 + 56) + 8 * v9);
  swift_endAccess();
  id v12 = v11;
  uint64_t result = swift_bridgeObjectRelease();
LABEL_6:
  *a4 = v12;
  return result;
}

uint64_t sub_100035A60(void *a1)
{
  id v2 = [a1 persona];
  id v3 = [v2 personaIdentifier];

  uint64_t v4 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v6 = v5;

  uint64_t v7 = *(void *)(v1 + OBJC_IVAR____TtC7backupd21MBPersonaStateManager_lock);
  uint64_t v8 = *(os_unfair_lock_s **)(v7 + 16);
  swift_retain();
  os_unfair_lock_lock(v8);
  sub_1000358A4(v1, v4, v6, &v10);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v7 + 16));
  swift_bridgeObjectRelease();
  swift_release();
  return v10;
}

void *sub_100035B90()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC7backupd21MBPersonaStateManager_lock);
  id v2 = *(os_unfair_lock_s **)(v1 + 16);
  swift_retain();
  os_unfair_lock_lock(v2);
  swift_beginAccess();
  uint64_t v3 = swift_bridgeObjectRetain();
  uint64_t v4 = sub_1000197FC(v3);
  swift_bridgeObjectRelease();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v1 + 16));
  swift_release();
  return v4;
}

uint64_t sub_100035C2C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(v2 + OBJC_IVAR____TtC7backupd21MBPersonaStateManager_lock);
  uint64_t v6 = *(os_unfair_lock_s **)(v5 + 16);
  swift_retain();
  os_unfair_lock_lock(v6);
  sub_1000358A4(v2, a1, a2, &v8);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v5 + 16));
  swift_release();
  return v8;
}

uint64_t type metadata accessor for MBPersonaStateManager()
{
  return self;
}

void sub_100035E44(void *a1, uint64_t a2)
{
  uint64_t v6 = type metadata accessor for FilePath();
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = __chkstk_darwin(v6);
  __chkstk_darwin(v8);
  uint64_t v10 = (char *)v28 - v9;
  sub_10003525C();
  if (!v3)
  {
    uint64_t v29 = v2;
    NSString v32 = [a1 restoreSnapshotsDatabaseDirectory];
    if (!v32)
    {
      static String._unconditionallyBridgeFromObjectiveC(_:)();
      NSString v32 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
    }
    uint64_t v30 = a2;
    v28[1] = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v31 = v11;
    NSString v12 = String._bridgeToObjectiveC()();
    unint64_t v13 = (char *)String._bridgeToObjectiveC()();
    id v14 = MBSnapshotDirectoryPath(v12, v13);

    static String._unconditionallyBridgeFromObjectiveC(_:)();
    FilePath.init(_:)();
    FilePath.appending(_:)();
    FilePath.string.getter();
    (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v6);
    uint64_t v15 = self;
    NSString v16 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    NSString v17 = String._bridgeToObjectiveC()();
    id v33 = 0;
    uint64_t v18 = (void *)v15;
    uint64_t v19 = v32;
    id v20 = [v18 createDatabaseAt:v16 restoreSnapshotsDir:v32 snapshotUUID:v17 error:&v33];

    id v21 = v33;
    if (v20)
    {
      char v22 = *(void **)(v29 + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan);
      *(void *)(v29 + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan) = v20;
      id v23 = v21;

      NSString v24 = String._bridgeToObjectiveC()();
      NSString v25 = String._bridgeToObjectiveC()();
      id v33 = 0;
      char v26 = MBCreateSymlinksForPendingAndLatestSnapshots(v24, 0, v25, &v33);

      if (v33)
      {
        if ((v26 & 1) == 0)
        {
          v33;
          swift_willThrow();
        }
      }
      swift_bridgeObjectRelease();
    }
    else
    {
      id v27 = v33;
      swift_bridgeObjectRelease();
      _convertNSErrorToError(_:)();

      swift_willThrow();
    }
  }
}

void *sub_1000361D0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = type metadata accessor for FilePath();
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = __chkstk_darwin(v7);
  __chkstk_darwin(v9);
  uint64_t v11 = (char *)&v31 - v10;
  NSString v12 = *(void **)(v3 + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan);
  if (v12)
  {
    if (a3)
    {
      uint64_t v31 = v4;
      NSString v32 = v12;
      id v35 = v12;
      id v13 = [a1 restoreSnapshotsDatabaseDirectory];
      static String._unconditionallyBridgeFromObjectiveC(_:)();

      NSString v14 = String._bridgeToObjectiveC()();
      uint64_t v15 = (char *)String._bridgeToObjectiveC()();
      id v16 = MBSnapshotDirectoryPath(v14, v15);

      static String._unconditionallyBridgeFromObjectiveC(_:)();
      FilePath.init(_:)();
      NSString v17 = v35;
      FilePath.appending(_:)();
      uint64_t v18 = FilePath.string.getter();
      id v20 = v19;
      (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
      swift_bridgeObjectRelease();
      id v21 = [v17 path];
      uint64_t v22 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      NSString v24 = v23;

      if (v22 == v18 && v24 == v20)
      {
        swift_bridgeObjectRelease_n();
      }
      else
      {
        if ((_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
        {
          uint64_t v33 = 0;
          unint64_t v34 = 0xE000000000000000;
          _StringGuts.grow(_:)(55);
          v26._countAndFlagsBits = 0xD000000000000011;
          v26._object = (void *)0x8000000100306C60;
          String.append(_:)(v26);
          v27._countAndFlagsBits = v18;
          v27._object = v20;
          String.append(_:)(v27);
          swift_bridgeObjectRelease();
          v28._countAndFlagsBits = 0xD000000000000022;
          v28._object = (void *)0x8000000100306C80;
          String.append(_:)(v28);
          v29._countAndFlagsBits = v22;
          v29._object = v24;
          String.append(_:)(v29);
          swift_bridgeObjectRelease();
          sub_1000467F0(1, v33, v34, 0xD000000000000010, 0x8000000100306C00);
          swift_bridgeObjectRelease();
          swift_willThrow();

          return v32;
        }
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      return v32;
    }
    else
    {
      id v25 = v12;
    }
  }
  return v12;
}

void sub_10003651C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = type metadata accessor for FilePath();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = __chkstk_darwin(v8);
  __chkstk_darwin(v10);
  NSString v12 = (char *)v27 - v11;
  sub_10003525C();
  if (!v4)
  {
    v27[0] = v3;
    NSString v28 = [a1 restoreSnapshotsDatabaseDirectory];
    if (!v28)
    {
      static String._unconditionallyBridgeFromObjectiveC(_:)();
      NSString v28 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
    }
    static String._unconditionallyBridgeFromObjectiveC(_:)();
    NSString v13 = String._bridgeToObjectiveC()();
    NSString v14 = (const char *)String._bridgeToObjectiveC()();
    v27[2] = a3;
    uint64_t v15 = (char *)v14;
    id v16 = MBSnapshotDirectoryPath(v13, v14);
    v27[1] = a2;
    id v17 = v16;

    static String._unconditionallyBridgeFromObjectiveC(_:)();
    FilePath.init(_:)();
    FilePath.appending(_:)();
    FilePath.string.getter();
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
    swift_bridgeObjectRelease();
    uint64_t v18 = self;
    NSString v19 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    NSString v20 = String._bridgeToObjectiveC()();
    id v29 = 0;
    id v21 = v28;
    id v22 = [v18 openDatabaseAt:v19 restoreSnapshotsDir:v28 snapshotUUID:v20 error:&v29];

    id v23 = v29;
    if (v22)
    {
      NSString v24 = *(void **)(v27[0] + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan);
      *(void *)(v27[0] + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan) = v22;
      id v25 = v23;
      v22;
    }
    else
    {
      id v26 = v29;
      _convertNSErrorToError(_:)();

      swift_willThrow();
    }
  }
}

void sub_1000369BC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = v3;
  uint64_t v6 = sub_1000361D0(a1, a2, a3);
  if (!v4)
  {
    uint64_t v7 = v6;
    if (v6)
    {
      _StringGuts.grow(_:)(24);
      swift_bridgeObjectRelease();
      v16[0] = (id)0xD000000000000016;
      v16[1] = (id)0x8000000100306C40;
      id v8 = [v7 description];
      uint64_t v9 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      uint64_t v11 = v10;

      v12._countAndFlagsBits = v9;
      v12._object = v11;
      String.append(_:)(v12);
      swift_bridgeObjectRelease();
      sub_100045F18(0xD000000000000016, 0x8000000100306C40, 0xD000000000000010, 0x8000000100306C00);
      swift_bridgeObjectRelease();
      NSString v13 = *(void **)(v5 + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan);
      *(void *)(v5 + OBJC_IVAR____TtC7backupd14MBPersonaState__restorePlan) = 0;

      v16[0] = 0;
      if ([v7 close:v16])
      {
        id v14 = v16[0];
      }
      else
      {
        id v15 = v16[0];
        _convertNSErrorToError(_:)();

        swift_willThrow();
      }
    }
    else
    {
      sub_1000467F0(1, 0xD00000000000001ELL, 0x8000000100306C20, 0xD000000000000010, 0x8000000100306C00);
      swift_willThrow();
    }
  }
}

uint64_t sub_100036BA0(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void (*a6)(id, uint64_t, uint64_t))
{
  uint64_t v9 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v11 = v10;
  id v12 = a3;
  id v13 = a1;
  a6(v12, v9, v11);
  swift_bridgeObjectRelease();

  return 1;
}

void sub_100036C6C()
{
  id v17 = 0;
  if ([v0 close:&v17])
  {
    id v1 = v17;
  }
  else
  {
    id v2 = v17;
    uint64_t v3 = _convertNSErrorToError(_:)();

    swift_willThrow();
    sub_1000462C4(v3, 0xD00000000000001CLL, 0x8000000100306D30, 0xD000000000000010, 0x8000000100306C00);
    swift_errorRelease();
  }
  id v4 = [self defaultManager];
  NSString v5 = [v0 restoreSnapshotsDirectoryRoot];
  if (!v5)
  {
    static String._unconditionallyBridgeFromObjectiveC(_:)();
    NSString v5 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
  }
  uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  id v8 = v7;
  id v17 = 0;
  id v9 = objc_msgSend(v4, "mb_moveAsideItemAtPath:error:", v5, &v17);

  id v10 = v17;
  if (v9
    && (id v17 = 0,
        id v11 = v10,
        unsigned __int8 v12 = objc_msgSend(v4, "mb_markAsPurgeableItemAtPath:error:", v9, &v17),
        v9,
        id v10 = v17,
        (v12 & 1) != 0))
  {
    id v13 = v17;

    swift_bridgeObjectRelease();
  }
  else
  {
    id v14 = v10;
    uint64_t v15 = _convertNSErrorToError(_:)();

    swift_willThrow();
    id v17 = 0;
    unint64_t v18 = 0xE000000000000000;
    _StringGuts.grow(_:)(45);
    swift_bridgeObjectRelease();
    id v17 = (id)0xD00000000000002BLL;
    unint64_t v18 = 0x8000000100306D50;
    v16._countAndFlagsBits = v6;
    v16._object = v8;
    String.append(_:)(v16);
    swift_bridgeObjectRelease();
    sub_1000462C4(v15, (uint64_t)v17, v18, 0xD000000000000010, 0x8000000100306C00);
    swift_bridgeObjectRelease();
    swift_willThrow();
  }
}

uint64_t sub_100036EFC(uint64_t result)
{
  if (result) {
    return swift_release();
  }
  return result;
}

uint64_t sub_100036F0C(uint64_t result)
{
  if (result) {
    return swift_retain();
  }
  return result;
}

unint64_t sub_100036F1C()
{
  unint64_t result = qword_10047DD38;
  if (!qword_10047DD38)
  {
    sub_10001C0F4(255, &qword_10047DAB0);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DD38);
  }
  return result;
}

uint64_t sub_100036F84()
{
  _Block_release(*(const void **)(v0 + 16));
  return _swift_deallocObject(v0, 24, 7);
}

uint64_t sub_100036FBC()
{
  return (*(uint64_t (**)(void))(*(void *)(v0 + 16) + 16))();
}

uint64_t sub_100036FD0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_100036FE0()
{
  return swift_release();
}

uint64_t sub_100036FE8()
{
  id v1 = *(void **)(v0 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__stage);
  id v8 = 0;
  unsigned __int8 v2 = [v1 disposeWithError:&v8];
  id v3 = v8;
  if (v2)
  {
    uint64_t v4 = *(void *)(v0 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath);
    *(void *)(v0 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath) = 0xF000000000000007;
    id v5 = v3;
    return sub_10001BFE4(v4);
  }
  else
  {
    id v7 = v8;
    _convertNSErrorToError(_:)();

    return swift_willThrow();
  }
}

uint64_t sub_1000370B4(void *a1)
{
  uint64_t result = sub_100038620(a1);
  if (!v2)
  {
    unint64_t v5 = result;
    sub_10002D270(result);
    NSString v6 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v7 = [a1 restoreDirectoryAtPath:v6 settingDataProtection:0 settingOwnershipAndFlags:0];

    if (v7)
    {
      uint64_t v8 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
      unint64_t v9 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
      _StringGuts.grow(_:)(33);
      v10._countAndFlagsBits = 0x702064656C696146;
      v10._object = (void *)0xEF20676E6963616CLL;
      String.append(_:)(v10);
      sub_100006FC8(&qword_10047DE38);
      _print_unlocked<A, B>(_:_:)();
      v11._countAndFlagsBits = 0x6F74636572696420;
      v11._object = (void *)0xEE00207461207972;
      String.append(_:)(v11);
      v12._countAndFlagsBits = sub_10002D874(v5);
      String.append(_:)(v12);
      swift_bridgeObjectRelease();
      sub_1000462C4((uint64_t)v7, 0, 0xE000000000000000, v8, v9);
      swift_bridgeObjectRelease();
      swift_willThrow();
      return swift_release();
    }
    else
    {
      uint64_t result = swift_release();
      uint64_t v13 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary);
      uint64_t v14 = *(void *)(v13 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_directories);
      BOOL v15 = __CFADD__(v14, 1);
      uint64_t v16 = v14 + 1;
      if (v15) {
        __break(1u);
      }
      else {
        *(void *)(v13 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_directories) = v16;
      }
    }
  }
  return result;
}

unint64_t sub_100037278(void *a1, char a2)
{
  unint64_t result = sub_100038620(a1);
  if (!v3)
  {
    unint64_t v7 = result;
    swift_unknownObjectRetain();
    uint64_t v8 = v2;
    sub_10003B1E8(a1, a2 & 1, v8, a1, v8);
    swift_unknownObjectRelease();

    uint64_t v9 = *(void *)&v8[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log];
    unint64_t v10 = *(void *)&v8[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8];
    _StringGuts.grow(_:)(27);
    swift_bridgeObjectRelease();
    v11._countAndFlagsBits = sub_10002D874(v7);
    String.append(_:)(v11);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD000000000000019, 0x8000000100307370, v9, v10);
    swift_bridgeObjectRelease();
    unint64_t result = swift_release();
    uint64_t v12 = *(void *)&v8[OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary];
    uint64_t v13 = *(void *)(v12 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_zeroByteFiles);
    BOOL v14 = __CFADD__(v13, 1);
    uint64_t v15 = v13 + 1;
    if (v14) {
      __break(1u);
    }
    else {
      *(void *)(v12 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_zeroByteFiles) = v15;
    }
  }
  return result;
}

unint64_t sub_1000374C4(void *a1, uint64_t a2, uint64_t a3, char a4)
{
  unint64_t result = sub_100038620(a1);
  if (!v5)
  {
    unint64_t v9 = result;
    swift_unknownObjectRetain();
    swift_bridgeObjectRetain();
    sub_10003C12C(a1, a4 & 1, v4, a1);
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v10 = *(void *)&v4[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log];
    unint64_t v11 = *(void *)&v4[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8];
    _StringGuts.grow(_:)(20);
    swift_bridgeObjectRelease();
    v12._countAndFlagsBits = sub_10002D874(v9);
    String.append(_:)(v12);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD000000000000012, 0x80000001003073E0, v10, v11);
    swift_bridgeObjectRelease();
    unint64_t result = swift_release();
    uint64_t v13 = *(void *)&v4[OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary];
    uint64_t v14 = *(void *)(v13 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_symlinks);
    BOOL v15 = __CFADD__(v14, 1);
    uint64_t v16 = v14 + 1;
    if (v15) {
      __break(1u);
    }
    else {
      *(void *)(v13 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_symlinks) = v16;
    }
  }
  return result;
}

unint64_t sub_100037728(void *a1, uint64_t a2, char a3, void *a4, char a5)
{
  unint64_t result = sub_100038620(a1);
  if (!v6)
  {
    if (a3) {
      unsigned int v13 = 1;
    }
    else {
      unsigned int v13 = 2 * (a2 == 2);
    }
    uint64_t v14 = v5;
    id v15 = a4;
    uint64_t v16 = (void *)swift_unknownObjectRetain();
    sub_10003D0CC(v16, a5 & 1, v14, v14, v13, v15, a1);

    swift_unknownObjectRelease();
    unint64_t result = swift_release();
    uint64_t v17 = *(void *)&v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary];
    uint64_t v18 = *(void *)(v17 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_assetFiles);
    BOOL v19 = __CFADD__(v18, 1);
    uint64_t v20 = v18 + 1;
    if (v19) {
      __break(1u);
    }
    else {
      *(void *)(v17 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_assetFiles) = v20;
    }
  }
  return result;
}

unint64_t sub_10003792C(void *a1)
{
  unint64_t result = sub_100038620(a1);
  if (!v2)
  {
    unint64_t v5 = result;
    sub_10002D270(result);
    NSString v6 = String._bridgeToObjectiveC()();
    uint64_t v7 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger);
    id v20 = 0;
    unsigned int v8 = [a1 restoreProtectionClassToDestination:v6 unspecifiedDirectoryProtectionClass:4 logger:v7 error:&v20];

    id v9 = v20;
    if (v8)
    {
      NSString v10 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v20 = 0;
      unsigned __int8 v11 = [a1 restoreAttributesToDestination:v10 error:&v20];

      if (v11)
      {
        id v12 = v20;
        return swift_release();
      }
      id v13 = v20;
    }
    else
    {
      id v13 = v9;
      swift_bridgeObjectRelease();
    }
    uint64_t v14 = _convertNSErrorToError(_:)();

    swift_willThrow();
    uint64_t v15 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
    unint64_t v16 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
    id v20 = 0;
    unint64_t v21 = 0xE000000000000000;
    _StringGuts.grow(_:)(46);
    v17._object = (void *)0x8000000100307400;
    v17._countAndFlagsBits = 0xD000000000000011;
    String.append(_:)(v17);
    sub_100006FC8(&qword_10047DE38);
    _print_unlocked<A, B>(_:_:)();
    v18._countAndFlagsBits = 0xD000000000000019;
    v18._object = (void *)0x8000000100307420;
    String.append(_:)(v18);
    v19._countAndFlagsBits = sub_10002D874(v5);
    String.append(_:)(v19);
    swift_bridgeObjectRelease();
    sub_1000462C4(v14, (uint64_t)v20, v21, v15, v16);
    swift_bridgeObjectRelease();
    swift_willThrow();
    return swift_release();
  }
  return result;
}

id sub_100037B80(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  id v9 = v8;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v44 = OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath;
  *(void *)&v8[OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath] = 0xF000000000000007;
  uint64_t v12 = OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary;
  id v13 = objc_allocWithZone((Class)type metadata accessor for MBRestorablePlacementSummary());
  uint64_t v14 = v9;
  uint64_t v35 = v12;
  *(void *)&v9[v12] = [v13 init];
  swift_bridgeObjectRetain();
  v15._countAndFlagsBits = 32;
  v15._object = (void *)0xE100000000000000;
  String.append(_:)(v15);
  v16._countAndFlagsBits = a1;
  strcpy((char *)v43, "=performer= ");
  BYTE5(v43[1]) = 0;
  HIWORD(v43[1]) = -5120;
  v16._object = a2;
  String.append(_:)(v16);
  swift_bridgeObjectRelease();
  uint64_t v17 = v43[1];
  Swift::String v18 = &v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log];
  *(void *)Swift::String v18 = v43[0];
  *((void *)v18 + 1) = v17;
  Swift::String v19 = (uint64_t *)&v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer__identifier];
  *Swift::String v19 = a1;
  v19[1] = (uint64_t)a2;
  sub_100006FC8((uint64_t *)&unk_10047D910);
  unint64_t v20 = swift_allocBox();
  swift_bridgeObjectRetain();
  FilePath.init(_:)();
  uint64_t v21 = sub_100008C50(v20);
  id v22 = v40;
  if (v40)
  {
    swift_release();
    swift_bridgeObjectRelease();

    swift_bridgeObjectRelease();
    sub_10001BFE4(*(void *)&v9[v44]);
    swift_bridgeObjectRelease();
    id v26 = *(void **)&v9[v35];

    swift_deallocPartialClassInstance();
  }
  else
  {
    uint64_t v23 = v21;
    swift_release();
    uint64_t v24 = *(void *)&v9[v44];
    *(void *)&v9[v44] = v23;
    sub_10001BFE4(v24);
    *(void *)&v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer__policy] = a5;
    *(void *)&v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer__depot] = a6;
    id v34 = a5;
    id v25 = a6;
    id v33 = sub_10002FD1C(a1, a2);
    swift_bridgeObjectRelease();
    *(void *)&v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer__stage] = v33;
    *(void *)&v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger] = a8;
    NSString v28 = self;
    id v29 = a8;
    id v30 = [v28 sharedOptions];
    NSString v31 = [v30 restorePathsToFailPlacingRegex];

    if (v31)
    {
      static String._unconditionallyBridgeFromObjectiveC(_:)();

      NSString v31 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
    }
    id v32 = [self errorInjectorForRegex:v31];

    *(void *)&v14[OBJC_IVAR____TtC7backupd18MBRestorePerformer__errorInjector] = v32;
    v42.receiver = v14;
    v42.super_class = ObjectType;
    id v22 = objc_msgSendSuper2(&v42, "init");
  }
  return v22;
}

uint64_t sub_10003810C()
{
  uint64_t v1 = v0;
  _StringGuts.grow(_:)(42);
  v2._countAndFlagsBits = 60;
  v2._object = (void *)0xE100000000000000;
  String.append(_:)(v2);
  swift_getObjectType();
  v3._countAndFlagsBits = _typeName(_:qualified:)();
  String.append(_:)(v3);
  swift_bridgeObjectRelease();
  v4._countAndFlagsBits = 7876640;
  v4._object = (void *)0xE300000000000000;
  String.append(_:)(v4);
  _print_unlocked<A, B>(_:_:)();
  v5._countAndFlagsBits = 0x3A6469203ALL;
  v5._object = (void *)0xE500000000000000;
  String.append(_:)(v5);
  uint64_t v6 = *(void *)(v0 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__identifier);
  uint64_t v7 = *(void **)(v0 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__identifier + 8);
  swift_bridgeObjectRetain();
  v8._countAndFlagsBits = v6;
  v8._object = v7;
  String.append(_:)(v8);
  swift_bridgeObjectRelease();
  v9._countAndFlagsBits = 0x3A6874617020;
  v9._object = (void *)0xE600000000000000;
  String.append(_:)(v9);
  sub_10001BFFC(*(void *)(v0 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath));
  sub_100006FC8((uint64_t *)&unk_10047DE40);
  v10._countAndFlagsBits = String.init<A>(describing:)();
  String.append(_:)(v10);
  swift_bridgeObjectRelease();
  v11._countAndFlagsBits = 0x3A746F70656420;
  v11._object = (void *)0xE700000000000000;
  String.append(_:)(v11);
  id v12 = *(id *)(v0 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__depot);
  id v13 = [v12 description];
  uint64_t v14 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  Swift::String v16 = v15;

  v17._countAndFlagsBits = v14;
  v17._object = v16;
  String.append(_:)(v17);

  swift_bridgeObjectRelease();
  v18._countAndFlagsBits = 0x3A656761747320;
  v18._object = (void *)0xE700000000000000;
  String.append(_:)(v18);
  id v19 = *(id *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__stage);
  id v20 = [v19 description];
  uint64_t v21 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v23 = v22;

  v24._countAndFlagsBits = v21;
  v24._object = v23;
  String.append(_:)(v24);

  swift_bridgeObjectRelease();
  v25._countAndFlagsBits = 62;
  v25._object = (void *)0xE100000000000000;
  String.append(_:)(v25);
  return 0;
}

unint64_t sub_100038620(void *a1)
{
  unint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath);
  if ((~v3 & 0xF000000000000007) != 0)
  {
    swift_retain();
    id v5 = [a1 relativePath];
    uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v8 = v7;

    unint64_t v2 = sub_10002D538(v6, v8, v3);
    swift_bridgeObjectRelease();
    sub_10001BFE4(v3);
    Swift::String v9 = *(void **)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger);
    if (v9)
    {
      uint64_t v10 = swift_allocObject();
      *(void *)(v10 + 40) = &type metadata for MBRestorableOperationLogger;
      *(void *)(v10 + 48) = &off_10040F740;
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = a1;
      *(void *)(v10 + 56) = v2;
      unint64_t v2 = v10 | 0x8000000000000000;
      swift_unknownObjectRetain();
    }
    id v11 = v9;
  }
  else
  {
    sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log), *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8));
    swift_willThrow();
  }
  return v2;
}

uint64_t sub_100038794(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t))
{
  swift_unknownObjectRetain();
  id v8 = a1;
  a5(a3);

  swift_unknownObjectRelease();
  return 1;
}

id sub_10003883C(unint64_t a1, void *a2)
{
  sub_10002D270(a1);
  NSString v3 = String._bridgeToObjectiveC()();
  NSString v4 = String._bridgeToObjectiveC()();
  id v5 = [a2 restoreSymbolicLinkAtPath:v3 withTarget:v4 settingOwnershipAndFlags:0];

  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    NSString v6 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v10 = 0;
    unsigned int v7 = [a2 restoreAttributesToDestination:v6 error:&v10];

    if (v7) {
      return v10;
    }
    id v9 = v10;
    _convertNSErrorToError(_:)();
  }
  return (id)swift_willThrow();
}

void sub_100038A78(unint64_t a1, void *a2, uint64_t a3)
{
  sub_10002D270(a1);
  swift_getObjectType();
  NSString v7 = String._bridgeToObjectiveC()();
  id v8 = [a2 restoreEmptyRegularFileAtPath:v7 settingAttributes:0];

  if (v8)
  {
    uint64_t v27 = a3;
    uint64_t v9 = self;
    id v10 = (void *)_convertErrorToNSError(_:)();
    LOBYTE(v9) = [(id)v9 isError:v10 withCode:208];

    if ((v9 & 1) == 0) {
      goto LABEL_13;
    }
    sub_100018054((uint64_t)&v29);
    if (v31 - 1 >= 2) {
      goto LABEL_13;
    }
    id v11 = self;
    NSString v12 = String._bridgeToObjectiveC()();
    id v29 = 0;
    unsigned int v13 = [v11 setWithPath:v12 value:2 error:&v29];

    id v14 = v29;
    if (!v13)
    {
      id v16 = v29;
      swift_bridgeObjectRelease();
      _convertNSErrorToError(_:)();

      swift_willThrow();
      goto LABEL_8;
    }
    swift_retain();
    id v15 = v14;
    sub_100017A6C(a1, (uint64_t)v28);
    if (v3)
    {
      swift_bridgeObjectRelease();
LABEL_8:

      return;
    }
    if (v28[70] != 2)
    {
LABEL_13:
      swift_bridgeObjectRelease();
      swift_willThrow();
      return;
    }
    uint64_t v17 = *(void *)(v27 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
    unint64_t v18 = *(void *)(v27 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
    id v29 = 0;
    unint64_t v30 = 0xE000000000000000;
    _StringGuts.grow(_:)(61);
    v19._object = (void *)0x8000000100307390;
    v19._countAndFlagsBits = 0xD000000000000013;
    String.append(_:)(v19);
    sub_100006FC8(&qword_10047DE38);
    _print_unlocked<A, B>(_:_:)();
    v20._countAndFlagsBits = 544497952;
    v20._object = (void *)0xE400000000000000;
    String.append(_:)(v20);
    v21._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v21);
    swift_bridgeObjectRelease();
    v22._countAndFlagsBits = 0xD000000000000022;
    v22._object = (void *)0x80000001003073B0;
    String.append(_:)(v22);
    sub_100045F18((uint64_t)v29, v30, v17, v18);

    swift_bridgeObjectRelease();
  }
  NSString v23 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v29 = 0;
  unsigned __int8 v24 = [a2 restoreAttributesToDestination:v23 error:&v29];

  if (v24)
  {
    id v25 = v29;
  }
  else
  {
    id v26 = v29;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
}

void sub_100038E94(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v9 = *(char **)(a2 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__depot);
  uint64_t v10 = sub_10002F728();
  id v12 = v5;
  if (v5) {
    goto LABEL_8;
  }
  uint64_t v13 = v10;
  uint64_t v14 = v11;
  swift_bridgeObjectRelease();
  unint64_t v15 = *(void *)&v9[OBJC_IVAR____TtC7backupd14MBRestoreDepot___depotRootPath];
  if ((~v15 & 0xF000000000000007) == 0)
  {
    id v12 = sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, 0x203D746F7065643DLL, 0xE800000000000000);
    swift_willThrow();
    swift_bridgeObjectRelease();
LABEL_8:
    uint64_t v21 = *(void *)(a2 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
    unint64_t v22 = *(void *)(a2 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
    _StringGuts.grow(_:)(53);
    v23._countAndFlagsBits = 0xD00000000000001ALL;
    v23._object = (void *)0x80000001003072A0;
    String.append(_:)(v23);
    unsigned __int8 v24 = v9;
    id v25 = [v24 description];
    uint64_t v26 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    NSString v28 = v27;

    v29._countAndFlagsBits = v26;
    v29._object = v28;
    String.append(_:)(v29);

    swift_bridgeObjectRelease();
    v30._countAndFlagsBits = 0xD000000000000017;
    v30._object = (void *)0x80000001003072C0;
    String.append(_:)(v30);
    v31._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v31);
    swift_bridgeObjectRelease();
    sub_100045F30((uint64_t)v12, a1, 0, 0xE000000000000000, v21, v22);
    swift_bridgeObjectRelease();
    swift_willThrow();
    swift_errorRelease();
    return;
  }
  swift_retain();
  unint64_t v16 = sub_10002D538(v13, v14, v15);
  sub_10001BFE4(v15);
  swift_bridgeObjectRelease();
  uint64_t v17 = *(void **)(a2 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger);
  if (v17)
  {
    uint64_t v18 = swift_allocObject();
    *(void *)(v18 + 40) = &type metadata for MBRestorableOperationLogger;
    *(void *)(v18 + 48) = &off_10040F740;
    *(void *)(v18 + 16) = v17;
    *(void *)(v18 + 24) = a5;
    *(void *)(v18 + 56) = v16;
    unint64_t v19 = v18 | 0x8000000000000000;
    swift_unknownObjectRetain();
  }
  else
  {
    unint64_t v19 = v16;
  }
  swift_retain();
  id v20 = v17;
  sub_100007BF0(a1, v19);
  uint64_t v33 = *(void *)(a2 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
  unint64_t v32 = *(void *)(a2 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
  id v57 = 0;
  unint64_t v58 = 0xE000000000000000;
  _StringGuts.grow(_:)(33);
  v34._countAndFlagsBits = 0xD000000000000012;
  v34._object = (void *)0x80000001003072E0;
  String.append(_:)(v34);
  v35._countAndFlagsBits = sub_10002D874(v19);
  String.append(_:)(v35);
  swift_bridgeObjectRelease();
  v36._countAndFlagsBits = 544175136;
  v36._object = (void *)0xE400000000000000;
  String.append(_:)(v36);
  v37._countAndFlagsBits = sub_10002D874(a1);
  String.append(_:)(v37);
  swift_bridgeObjectRelease();
  v38._countAndFlagsBits = 0x20726F6620;
  v38._object = (void *)0xE500000000000000;
  String.append(_:)(v38);
  sub_100006FC8(&qword_10047DE38);
  _print_unlocked<A, B>(_:_:)();
  unint64_t v55 = v32;
  sub_100045F18(0, 0xE000000000000000, v33, v32);
  swift_release();
  swift_bridgeObjectRelease();
  swift_release();
  sub_10002D270(a1);
  swift_getObjectType();
  NSString v39 = String._bridgeToObjectiveC()();
  id v40 = [a5 restoreRegularFileAtPath:v39 settingAttributes:0];

  if (v40)
  {
    int64_t v41 = self;
    objc_super v42 = (void *)_convertErrorToNSError(_:)();
    unsigned __int8 v43 = [v41 isError:v42 withCode:208];

    if ((v43 & 1) == 0
      && (uint64_t v44 = (void *)_convertErrorToNSError(_:)(),
          unsigned __int8 v45 = [v41 isError:v44 withCode:14],
          v44,
          (v45 & 1) == 0)
      || (sub_100018054((uint64_t)&v57), v59 - 1 >= 2)
      || (swift_retain(), sub_100017A6C(a1, (uint64_t)v56), v56[70] != 2))
    {
      swift_bridgeObjectRelease();
      swift_willThrow();
      return;
    }
    id v57 = 0;
    unint64_t v58 = 0xE000000000000000;
    _StringGuts.grow(_:)(73);
    v46._object = (void *)0x8000000100307300;
    v46._countAndFlagsBits = 0xD000000000000011;
    String.append(_:)(v46);
    _print_unlocked<A, B>(_:_:)();
    v47._countAndFlagsBits = 544497952;
    v47._object = (void *)0xE400000000000000;
    String.append(_:)(v47);
    v48._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v48);
    swift_bridgeObjectRelease();
    v49._countAndFlagsBits = 0xD00000000000002DLL;
    v49._object = (void *)0x8000000100307320;
    String.append(_:)(v49);
    sub_100006FC8(&qword_10047D0A0);
    _print_unlocked<A, B>(_:_:)();
    v50._countAndFlagsBits = 41;
    v50._object = (void *)0xE100000000000000;
    String.append(_:)(v50);
    sub_100045F18((uint64_t)v57, v58, v33, v55);

    swift_bridgeObjectRelease();
  }
  NSString v51 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v57 = 0;
  unsigned __int8 v52 = [a5 restoreAttributesToDestination:v51 error:&v57];

  if (v52)
  {
    id v53 = v57;
  }
  else
  {
    id v54 = v57;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
}

unint64_t sub_100039640(uint64_t a1)
{
  id v3 = [*(id *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__stage) makeTemporaryFilePath];
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  sub_100006FC8((uint64_t *)&unk_10047D910);
  unint64_t v4 = swift_allocBox();
  FilePath.init(_:)();
  id v5 = *(void **)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger);
  if (v5)
  {
    uint64_t v6 = swift_allocObject();
    *(void *)(v6 + 40) = &type metadata for MBRestorableOperationLogger;
    *(void *)(v6 + 48) = &off_10040F740;
    *(void *)(v6 + 16) = v5;
    *(void *)(v6 + 24) = a1;
    *(void *)(v6 + 56) = v4;
    unint64_t v4 = v6 | 0x8000000000000000;
    swift_unknownObjectRetain();
  }
  id v7 = v5;
  return v4;
}

uint64_t sub_10003971C(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t (*a4)(unint64_t, unint64_t), unint64_t a5)
{
  uint64_t result = a4(a2, a1);
  if (!v5)
  {
    uint64_t v11 = *(void *)(a3 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
    unint64_t v12 = *(void *)(a3 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
    _StringGuts.grow(_:)(31);
    swift_bridgeObjectRelease();
    v13._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v13);
    swift_bridgeObjectRelease();
    v14._countAndFlagsBits = 544175136;
    v14._object = (void *)0xE400000000000000;
    String.append(_:)(v14);
    v15._countAndFlagsBits = sub_10002D874(a2);
    String.append(_:)(v15);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD000000000000017, a5, v11, v12);
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_100039824(unint64_t a1, unint64_t a2, void *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  sub_100007C60(a7, a6);
  if (!v7)
  {
    swift_release();
    return swift_release();
  }
  swift_getErrorValue();
  unsigned int v15 = sub_100055064((uint64_t)v35[3]);
  if (v15 != 2)
  {
    if (v15 == 17)
    {
      if ([*(id *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__policy) shouldRemoveAndRetryPlacingAssetsForRestorable:a3])
      {
        sub_100039DA8(a1);
        sub_100007C60(a7, a6);
        swift_errorRelease();
        swift_release();
        return swift_release();
      }
      swift_retain();
      sub_100017A6C(a1, (uint64_t)v36);
      uint64_t v34 = v37;
      sub_10002D270(a2);
      NSString v29 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      sub_10002D270(a1);
      NSString v30 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      v35[0] = 0;
      id v31 = [a3 moveFileFromSource:v29 destination:v30 destinationSize:v34 conflictResolution:a4 error:v35];

      if (v31)
      {
        id v32 = v35[0];

LABEL_16:
        swift_errorRelease();
        swift_release();
        return swift_release();
      }
      id v33 = v35[0];
      _convertNSErrorToError(_:)();

      goto LABEL_12;
    }
LABEL_11:
    uint64_t v18 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
    unint64_t v19 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
    v35[0] = 0;
    v35[1] = (id)0xE000000000000000;
    _StringGuts.grow(_:)(43);
    v20._countAndFlagsBits = 0xD000000000000014;
    v20._object = (void *)0x8000000100307190;
    String.append(_:)(v20);
    uint64_t v38 = (uint64_t)a3;
    sub_100006FC8(&qword_10047DE38);
    _print_unlocked<A, B>(_:_:)();
    v21._object = (void *)0x80000001003071B0;
    v21._countAndFlagsBits = 0xD000000000000010;
    String.append(_:)(v21);
    uint64_t v38 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath);
    sub_10001BFFC(v38);
    sub_100006FC8((uint64_t *)&unk_10047DE40);
    v22._countAndFlagsBits = String.init<A>(describing:)();
    String.append(_:)(v22);
    swift_bridgeObjectRelease();
    v23._countAndFlagsBits = 47;
    v23._object = (void *)0xE100000000000000;
    String.append(_:)(v23);
    id v24 = [a3 relativePath];
    uint64_t v25 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v27 = v26;

    v28._countAndFlagsBits = v25;
    v28._object = v27;
    String.append(_:)(v28);
    swift_bridgeObjectRelease();
    sub_100045F30(v7, 0xF000000000000007, 0, 0xE000000000000000, v18, v19);
    swift_bridgeObjectRelease();
    goto LABEL_12;
  }
  if (![*(id *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__policy) shouldCreateMissingIntermediateDirectories])goto LABEL_11; {
  unint64_t v17 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath);
  }
  if ((~v17 & 0xF000000000000007) != 0)
  {
    swift_retain();
    sub_10000894C(a3, v17);
    sub_10001BFE4(v17);
    sub_100007C60(a7, a6);
    goto LABEL_16;
  }
  sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log), *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8));
LABEL_12:
  swift_willThrow();
  swift_errorRelease();
  swift_release();
  return swift_release();
}

void sub_100039C94()
{
  swift_getObjectType();
  sub_100018054((uint64_t)v9);
  switch(v9[70])
  {
    case 1:
      uint64_t v1 = (void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classAFiles);
      uint64_t v2 = *(void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classAFiles);
      BOOL v3 = __CFADD__(v2, 1);
      uint64_t v4 = v2 + 1;
      if (!v3) {
        goto LABEL_15;
      }
      __break(1u);
      goto LABEL_5;
    case 2:
LABEL_5:
      uint64_t v1 = (void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classBFiles);
      uint64_t v5 = *(void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classBFiles);
      BOOL v3 = __CFADD__(v5, 1);
      uint64_t v4 = v5 + 1;
      if (!v3) {
        goto LABEL_15;
      }
      __break(1u);
LABEL_8:
      uint64_t v1 = (void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCFiles);
      uint64_t v6 = *(void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCFiles);
      BOOL v3 = __CFADD__(v6, 1);
      uint64_t v4 = v6 + 1;
      if (v3)
      {
        __break(1u);
LABEL_11:
        uint64_t v1 = (void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classDFiles);
        uint64_t v7 = *(void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classDFiles);
        BOOL v3 = __CFADD__(v7, 1);
        uint64_t v4 = v7 + 1;
        if (v3)
        {
          __break(1u);
LABEL_14:
          uint64_t v1 = (void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCxFiles);
          uint64_t v8 = *(void *)(v0 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCxFiles);
          BOOL v3 = __CFADD__(v8, 1);
          uint64_t v4 = v8 + 1;
          if (v3)
          {
            __break(1u);
            JUMPOUT(0x100039D8CLL);
          }
        }
      }
LABEL_15:
      void *v1 = v4;
      return;
    case 3:
      goto LABEL_8;
    case 4:
      goto LABEL_11;
    case 7:
      goto LABEL_14;
    default:
      return;
  }
}

id sub_100039DA8(unint64_t a1)
{
  swift_retain();
  sub_100017A6C(a1, (uint64_t)v17);
  uint64_t v4 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
  unint64_t v5 = *(void *)(v1 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
  if (v2)
  {
    _StringGuts.grow(_:)(48);
    swift_bridgeObjectRelease();
    v6._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v6);
    swift_bridgeObjectRelease();
    sub_100045F30(v2, a1, 0xD00000000000002ELL, 0x80000001003071D0, v4, v5);
    swift_bridgeObjectRelease();
    swift_willThrow();
    return (id)swift_errorRelease();
  }
  else
  {
    _StringGuts.grow(_:)(44);
    swift_bridgeObjectRelease();
    v15[2] = v17[2];
    v15[3] = v17[3];
    uint64_t v16 = v18;
    v15[0] = v17[0];
    v15[1] = v17[1];
    uint64_t v8 = MBNodeAsString((unsigned int *)v15);
    uint64_t v9 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v11 = v10;

    v12._countAndFlagsBits = v9;
    v12._object = v11;
    String.append(_:)(v12);
    swift_bridgeObjectRelease();
    v13._countAndFlagsBits = 0xD000000000000012;
    v13._object = (void *)0x8000000100307220;
    String.append(_:)(v13);
    v14._countAndFlagsBits = sub_10002D874(a1);
    String.append(_:)(v14);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD000000000000016, 0x8000000100307200, v4, v5);
    swift_bridgeObjectRelease();
    return sub_10000819C(a1);
  }
}

uint64_t type metadata accessor for MBRestorePerformer()
{
  return self;
}

id sub_10003A1DC()
{
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_zeroByteFiles] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_assetFiles] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_directories] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_symlinks] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classAFiles] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classBFiles] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCFiles] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classDFiles] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_classCxFiles] = 0;
  *(void *)&v0[OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_durations] = _swiftEmptyArrayStorage;
  v3.receiver = v0;
  v3.super_class = ObjectType;
  return objc_msgSendSuper2(&v3, "init");
}

uint64_t type metadata accessor for MBRestorablePlacementSummary()
{
  return self;
}

uint64_t sub_10003A2F8(void *a1, char *a2, void *a3, uint64_t a4)
{
  uint64_t v9 = sub_10002FB28(a1);
  if (v4) {
    return swift_unknownObjectRelease();
  }
  unint64_t v11 = v9;
  Swift::String v12 = *(void **)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger];
  if (v12)
  {
    uint64_t v13 = swift_allocObject();
    *(void *)(v13 + 40) = &type metadata for MBRestorableOperationLogger;
    *(void *)(v13 + 48) = &off_10040F740;
    *(void *)(v13 + 16) = v12;
    *(void *)(v13 + 24) = a1;
    *(void *)(v13 + 56) = v11;
    unint64_t v11 = v13 | 0x8000000000000000;
    swift_unknownObjectRetain();
  }
  id v14 = v12;
  unint64_t v15 = sub_100038620(a1);
  if (sub_100008804(v11))
  {
    swift_retain();
    swift_retain();
    sub_100039824(v15, v11, a1, 2, (uint64_t)a2, v11, v15);
    sub_100039C94();
    uint64_t v17 = *(void *)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log];
    unint64_t v18 = *(void *)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8];
    _StringGuts.grow(_:)(34);
    swift_bridgeObjectRelease();
    v19._countAndFlagsBits = sub_10002D874(v11);
    String.append(_:)(v19);
    swift_bridgeObjectRelease();
    v20._countAndFlagsBits = 544175136;
    v20._object = (void *)0xE400000000000000;
    String.append(_:)(v20);
    v21._countAndFlagsBits = sub_10002D874(v15);
    String.append(_:)(v21);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD00000000000001ALL, 0x8000000100307170, v17, v18);
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    unint64_t v16 = sub_100039640((uint64_t)a1);
    sub_100038A78(v16, a3, a4);
    sub_1000078E4(v11, v16);
    swift_retain();
    Swift::String v22 = a2;
    swift_retain();
    sub_10003AD1C(v15, v11, a1, 2, (uint64_t)v22, v11, v15, (uint64_t)v22, (uint64_t (*)(unint64_t, unint64_t))sub_100007C60, 0x8000000100307260);

    sub_100039C94();
    swift_unknownObjectRelease();
    swift_release();
  }
  swift_release();
  return swift_release();
}

uint64_t sub_10003AD1C(unint64_t a1, unint64_t a2, void *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, uint64_t (*a9)(unint64_t, unint64_t), unint64_t a10)
{
  sub_10003971C(a6, a7, a8, a9, a10);
  if (!v10)
  {
    swift_release();
    return swift_release();
  }
  swift_getErrorValue();
  unsigned int v17 = sub_100055064((uint64_t)v39[3]);
  if (v17 == 2)
  {
    if ([*(id *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__policy) shouldCreateMissingIntermediateDirectories])
    {
      unint64_t v19 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath);
      if ((~v19 & 0xF000000000000007) != 0)
      {
        swift_retain();
        sub_10000894C(a3, v19);
        sub_10001BFE4(v19);
        sub_10003971C(a6, a7, a8, a9, a10);
        swift_errorRelease();
        swift_release();
        return swift_release();
      }
      sub_1000467F0(4, 0xD000000000000013, 0x8000000100304E40, *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log), *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8));
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v20 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log);
    unint64_t v21 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8);
    v39[0] = 0;
    v39[1] = (id)0xE000000000000000;
    _StringGuts.grow(_:)(43);
    v22._countAndFlagsBits = 0xD000000000000014;
    v22._object = (void *)0x8000000100307190;
    String.append(_:)(v22);
    uint64_t v42 = (uint64_t)a3;
    sub_100006FC8(&qword_10047DE38);
    _print_unlocked<A, B>(_:_:)();
    v23._object = (void *)0x80000001003071B0;
    v23._countAndFlagsBits = 0xD000000000000010;
    String.append(_:)(v23);
    uint64_t v42 = *(void *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer___destinationRootPath);
    sub_10001BFFC(v42);
    sub_100006FC8((uint64_t *)&unk_10047DE40);
    v24._countAndFlagsBits = String.init<A>(describing:)();
    String.append(_:)(v24);
    swift_bridgeObjectRelease();
    v25._countAndFlagsBits = 47;
    v25._object = (void *)0xE100000000000000;
    String.append(_:)(v25);
    id v26 = [a3 relativePath];
    uint64_t v27 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    NSString v29 = v28;

    v30._countAndFlagsBits = v27;
    v30._object = v29;
    String.append(_:)(v30);
    swift_bridgeObjectRelease();
    sub_100045F30(v10, 0xF000000000000007, 0, 0xE000000000000000, v20, v21);
    swift_bridgeObjectRelease();
    goto LABEL_12;
  }
  if (v17 != 17) {
    goto LABEL_11;
  }
  if ([*(id *)(a5 + OBJC_IVAR____TtC7backupd18MBRestorePerformer__policy) shouldRemoveAndRetryPlacingAssetsForRestorable:a3])
  {
    sub_100039DA8(a1);
    sub_10003971C(a6, a7, a8, a9, a10);
    swift_errorRelease();
    swift_release();
    return swift_release();
  }
  swift_retain();
  sub_100017A6C(a1, (uint64_t)v40);
  uint64_t v31 = v41;
  sub_10002D270(a2);
  NSString v32 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  sub_10002D270(a1);
  NSString v33 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  v39[0] = 0;
  id v34 = [a3 moveFileFromSource:v32 destination:v33 destinationSize:v31 conflictResolution:a4 error:v39];

  if (v34)
  {
    id v35 = v39[0];

    swift_errorRelease();
    swift_release();
    return swift_release();
  }
  id v36 = v39[0];
  _convertNSErrorToError(_:)();

LABEL_12:
  swift_willThrow();
  swift_errorRelease();
  swift_release();
  return swift_release();
}

uint64_t sub_10003B1E8(void *a1, char a2, char *a3, void *a4, void *a5)
{
  uint64_t v6 = v5;
  swift_unknownObjectRetain();
  id v12 = a5;
  unint64_t v13 = sub_100038620(a1);
  if (v6) {
    goto LABEL_2;
  }
  unint64_t v15 = v13;
  unint64_t v16 = *(void **)&a3[OBJC_IVAR____TtC7backupd18MBRestorePerformer__errorInjector];
  if (!v16) {
    goto LABEL_6;
  }
  sub_10002D270(v13);
  uint64_t v27 = a4;
  id v17 = v12;
  unint64_t v18 = v15;
  NSString v19 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease();
  id v20 = [v16 errorIfMatches:v19];

  unint64_t v15 = v18;
  id v12 = v17;
  a4 = v27;
  if (v20)
  {
    swift_willThrow();

    swift_unknownObjectRelease();
    return swift_release();
  }
  else
  {
LABEL_6:
    if (a2)
    {
      swift_unknownObjectRetain();
      id v12 = v12;
      sub_10003A2F8(a1, a3, a4, (uint64_t)v12);

      uint64_t result = swift_release();
      uint64_t v22 = *(void *)&a3[OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary];
      uint64_t v23 = *(void *)(v22 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks);
      BOOL v24 = __CFADD__(v23, 1);
      uint64_t v25 = v23 + 1;
      if (!v24)
      {
        *(void *)(v22 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks) = v25;
LABEL_2:

        return swift_unknownObjectRelease();
      }
      __break(1u);
    }
    else
    {
      unint64_t v21 = sub_100039640((uint64_t)a1);
      sub_100038A78(v21, a4, (uint64_t)v12);
      swift_retain();
      id v26 = a3;
      swift_retain();
      sub_10003AD1C(v15, v21, a1, 3, (uint64_t)v26, v21, v15, (uint64_t)v26, (uint64_t (*)(unint64_t, unint64_t))sub_1000078E4, 0x8000000100307280);

      sub_100039C94();
      swift_unknownObjectRelease();
      swift_release();
      return swift_release();
    }
  }
  return result;
}

uint64_t sub_10003B6E8(void *a1, char *a2, void *a3)
{
  uint64_t v7 = sub_10002FB28(a1);
  if (v3) {
    return swift_unknownObjectRelease();
  }
  unint64_t v9 = v7;
  uint64_t v10 = *(void **)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger];
  if (v10)
  {
    uint64_t v11 = swift_allocObject();
    *(void *)(v11 + 40) = &type metadata for MBRestorableOperationLogger;
    *(void *)(v11 + 48) = &off_10040F740;
    *(void *)(v11 + 16) = v10;
    *(void *)(v11 + 24) = a1;
    *(void *)(v11 + 56) = v9;
    unint64_t v9 = v11 | 0x8000000000000000;
    swift_unknownObjectRetain();
  }
  id v12 = v10;
  unint64_t v13 = sub_100038620(a1);
  if (sub_100008804(v9))
  {
    swift_retain();
    swift_retain();
    sub_100039824(v13, v9, a1, 2, (uint64_t)a2, v9, v13);
    sub_100039C94();
    uint64_t v15 = *(void *)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log];
    unint64_t v16 = *(void *)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8];
    _StringGuts.grow(_:)(34);
    swift_bridgeObjectRelease();
    v17._countAndFlagsBits = sub_10002D874(v9);
    String.append(_:)(v17);
    swift_bridgeObjectRelease();
    v18._countAndFlagsBits = 544175136;
    v18._object = (void *)0xE400000000000000;
    String.append(_:)(v18);
    v19._countAndFlagsBits = sub_10002D874(v13);
    String.append(_:)(v19);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD00000000000001ALL, 0x8000000100307170, v15, v16);
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    unint64_t v14 = sub_100039640((uint64_t)a1);
    sub_10003883C(v14, a3);
    sub_1000078E4(v9, v14);
    swift_retain();
    id v20 = a2;
    unint64_t v21 = v13;
    uint64_t v22 = v20;
    swift_retain();
    sub_10003AD1C(v21, v9, a1, 2, (uint64_t)v22, v9, v21, (uint64_t)v22, (uint64_t (*)(unint64_t, unint64_t))sub_100007C60, 0x8000000100307260);

    sub_100039C94();
    swift_unknownObjectRelease();
    swift_release();
  }
  swift_release();
  return swift_release();
}

uint64_t sub_10003C12C(void *a1, char a2, char *a3, void *a4)
{
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  unint64_t v9 = sub_100038620(a1);
  if (v4) {
    goto LABEL_2;
  }
  unint64_t v11 = v9;
  id v12 = *(void **)&a3[OBJC_IVAR____TtC7backupd18MBRestorePerformer__errorInjector];
  if (v12
    && (sub_10002D270(v9),
        unint64_t v21 = v11,
        NSString v13 = String._bridgeToObjectiveC()(),
        swift_bridgeObjectRelease(),
        id v14 = [v12 errorIfMatches:v13],
        v13,
        unint64_t v11 = v21,
        v14))
  {
    swift_willThrow();
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    return swift_release();
  }
  else if (a2)
  {
    swift_unknownObjectRetain();
    swift_bridgeObjectRetain();
    sub_10003B6E8(a1, a3, a4);
    swift_bridgeObjectRelease();
    uint64_t result = swift_release();
    uint64_t v16 = *(void *)&a3[OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary];
    uint64_t v17 = *(void *)(v16 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks);
    BOOL v18 = __CFADD__(v17, 1);
    uint64_t v19 = v17 + 1;
    if (!v18)
    {
      *(void *)(v16 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks) = v19;
LABEL_2:
      swift_bridgeObjectRelease();
      return swift_unknownObjectRelease();
    }
    __break(1u);
  }
  else
  {
    unint64_t v15 = sub_100039640((uint64_t)a1);
    sub_10003883C(v15, a4);
    swift_retain();
    id v20 = a3;
    swift_retain();
    sub_10003AD1C(v11, v15, a1, 3, (uint64_t)v20, v15, v11, (uint64_t)v20, (uint64_t (*)(unint64_t, unint64_t))sub_1000078E4, 0x8000000100307280);

    sub_100039C94();
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_release();
    return swift_release();
  }
  return result;
}

void sub_10003C664(void *a1, char *a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v13 = sub_10002FB28(a1);
  if (v6)
  {
  }
  else
  {
    unint64_t v14 = v13;
    unint64_t v15 = *(void **)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__logger];
    if (v15)
    {
      uint64_t v16 = swift_allocObject();
      *(void *)(v16 + 40) = &type metadata for MBRestorableOperationLogger;
      *(void *)(v16 + 48) = &off_10040F740;
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = a1;
      *(void *)(v16 + 56) = v14;
      unint64_t v14 = v16 | 0x8000000000000000;
      swift_unknownObjectRetain();
    }
    id v17 = v15;
    unint64_t v18 = sub_100038620(a1);
    if (sub_100008804(v14))
    {
      swift_retain();
      swift_retain();
      sub_100039824(v18, v14, a1, 2, (uint64_t)a2, v14, v18);
      sub_100039C94();
      uint64_t v20 = *(void *)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log];
      unint64_t v21 = *(void *)&a2[OBJC_IVAR____TtC7backupd18MBRestorePerformer__log + 8];
      _StringGuts.grow(_:)(34);
      swift_bridgeObjectRelease();
      v22._countAndFlagsBits = sub_10002D874(v14);
      String.append(_:)(v22);
      swift_bridgeObjectRelease();
      v23._countAndFlagsBits = 544175136;
      v23._object = (void *)0xE400000000000000;
      String.append(_:)(v23);
      v24._countAndFlagsBits = sub_10002D874(v18);
      String.append(_:)(v24);
      swift_bridgeObjectRelease();
      sub_100045F18(0xD00000000000001ALL, 0x8000000100307170, v20, v21);

      swift_bridgeObjectRelease();
    }
    else
    {
      unint64_t v26 = v18;
      unint64_t v19 = sub_100039640((uint64_t)a1);
      sub_100038E94(v19, (uint64_t)a3, a4, a5, a6);
      sub_1000078E4(v14, v19);
      swift_retain();
      uint64_t v25 = a2;
      swift_retain();
      sub_10003AD1C(v26, v14, a1, 2, (uint64_t)v25, v14, v26, (uint64_t)v25, (uint64_t (*)(unint64_t, unint64_t))sub_100007C60, 0x8000000100307260);

      sub_100039C94();
      swift_release();
    }
    swift_release();
    swift_release();
  }
}

uint64_t sub_10003D0CC(void *a1, char a2, char *a3, void *a4, unsigned int a5, void *a6, void *a7)
{
  id v14 = a4;
  id v15 = a6;
  swift_unknownObjectRetain();
  unint64_t v16 = sub_100038620(a1);
  if (v7) {
    goto LABEL_2;
  }
  unint64_t v18 = v16;
  unsigned int v29 = a5;
  unint64_t v19 = *(void **)&a3[OBJC_IVAR____TtC7backupd18MBRestorePerformer__errorInjector];
  if (v19)
  {
    sub_10002D270(v16);
    Swift::String v28 = v15;
    NSString v20 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    id v21 = [v19 errorIfMatches:v20];

    id v15 = v28;
    if (v21)
    {
      swift_willThrow();

      swift_release();
      return swift_unknownObjectRelease();
    }
  }
  if ((a2 & 1) == 0)
  {
    unint64_t v22 = sub_100039640((uint64_t)a1);
    sub_100038E94(v22, (uint64_t)v14, v29, (uint64_t)v15, a7);
    swift_retain();
    uint64_t v27 = a3;
    swift_retain();
    sub_10003AD1C(v18, v22, a1, 3, (uint64_t)v27, v22, v18, (uint64_t)v27, (uint64_t (*)(unint64_t, unint64_t))sub_1000078E4, 0x8000000100307280);

    sub_100039C94();
    swift_release();
    swift_release();
    return swift_unknownObjectRelease();
  }
  id v14 = v14;
  id v15 = v15;
  swift_unknownObjectRetain();
  sub_10003C664(a1, a3, v14, v29, (uint64_t)v15, a7);

  swift_unknownObjectRelease();
  uint64_t result = swift_release();
  uint64_t v23 = *(void *)&a3[OBJC_IVAR____TtC7backupd18MBRestorePerformer_restorablePlacementSummary];
  uint64_t v24 = *(void *)(v23 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks);
  BOOL v25 = __CFADD__(v24, 1);
  uint64_t v26 = v24 + 1;
  if (!v25)
  {
    *(void *)(v23 + OBJC_IVAR____TtC7backupd28MBRestorablePlacementSummary_hardlinks) = v26;
LABEL_2:

    return swift_unknownObjectRelease();
  }
  __break(1u);
  return result;
}

uint64_t sub_10003D62C()
{
  sub_1000070A4(v0 + 16);
  swift_release();
  return _swift_deallocObject(v0, 64, 7);
}

uint64_t initializeBufferWithCopyOfBuffer for MBDryRestorePolicy(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(unsigned char *)(result + 8) = *((unsigned char *)a2 + 8);
  *(void *)uint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for MBDryRestorePolicy(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFE && *(unsigned char *)(a1 + 9)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 8);
  if (v3 <= 2) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for MBDryRestorePolicy(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(unsigned char *)(result + 8) = 0;
    *(void *)uint64_t result = a2 - 254;
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 9) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 9) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 8) = -(char)a2;
    }
  }
  return result;
}

uint64_t sub_10003D710(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 8) <= 1u) {
    return *(unsigned __int8 *)(a1 + 8);
  }
  else {
    return (*(_DWORD *)a1 + 2);
  }
}

uint64_t sub_10003D728(uint64_t result, unsigned int a2)
{
  if (a2 >= 2)
  {
    *(void *)uint64_t result = a2 - 2;
    LOBYTE(a2) = 2;
  }
  *(unsigned char *)(result + 8) = a2;
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestorePolicy()
{
  return &type metadata for MBDryRestorePolicy;
}

uint64_t sub_10003D750(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3[2];
  if (!v3) {
    return 0;
  }
  if (a3[4] == a1 && a3[5] == a2) {
    return 1;
  }
  uint64_t result = _stringCompareWithSmolCheck(_:_:expecting:)();
  if (result) {
    return 1;
  }
  if (v3 == 1) {
    return 0;
  }
  unint64_t v9 = a3 + 7;
  for (uint64_t i = 1; ; ++i)
  {
    uint64_t v11 = i + 1;
    if (__OFADD__(i, 1)) {
      break;
    }
    BOOL v12 = *(v9 - 1) == a1 && *v9 == a2;
    if (v12 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
      return 1;
    }
    uint64_t result = 0;
    v9 += 2;
    if (v11 == v3) {
      return result;
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_10003D818()
{
  uint64_t result = (uint64_t)[v0 dryRestoreInterval];
  if (*(double *)&result != 0.0)
  {
    uint64_t v2 = (void *)result;
    [(id)result doubleValue];
    double v4 = v3;

    if (v4 <= 0.0) {
      return 2;
    }
    id v5 = [v0 dryRestoreGBAllowance];
    if (v5 && (uint64_t v6 = v5, [v5 doubleValue], v8 = v7, v6, v8 <= 0.0)) {
      return 2;
    }
    else {
      *(double *)&uint64_t result = v4 * 24.0 * 60.0 * 60.0;
    }
  }
  return result;
}

uint64_t sub_10003D8EC(char *a1, char *a2)
{
  return sub_10004ED9C(*a1, *a2);
}

Swift::Int sub_10003D8F8()
{
  return Hasher._finalize()();
}

uint64_t sub_10003D980()
{
  String.hash(into:)();
  return swift_bridgeObjectRelease();
}

Swift::Int sub_10003D9F4()
{
  return Hasher._finalize()();
}

uint64_t sub_10003DA78@<X0>(Swift::String *a1@<X0>, char *a2@<X8>)
{
  Swift::Int v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_10040F0F0, *a1);
  uint64_t result = swift_bridgeObjectRelease();
  if (v3 == 1) {
    char v5 = 1;
  }
  else {
    char v5 = 2;
  }
  if (!v3) {
    char v5 = 0;
  }
  *a2 = v5;
  return result;
}

void sub_10003DAD8(uint64_t *a1@<X8>)
{
  uint64_t v2 = 0x636170536B736964;
  if (*v1) {
    uint64_t v2 = 0x696D694C72657375;
  }
  unint64_t v3 = 0xE900000000000065;
  if (*v1) {
    unint64_t v3 = 0xE900000000000074;
  }
  *a1 = v2;
  a1[1] = v3;
}

uint64_t sub_10003DB1C()
{
  return RawRepresentable<>.encode(to:)();
}

uint64_t sub_10003DB6C(void *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  v13[0] = a5;
  v13[1] = a3;
  uint64_t v8 = sub_100006FC8(&qword_10047DE88);
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  uint64_t v11 = (char *)v13 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_10000700C(a1, a1[3]);
  sub_10003F104();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  char v18 = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v5)
  {
    char v17 = 1;
    KeyedEncodingContainer.encode(_:forKey:)();
    char v16 = a4 & 1;
    char v15 = 2;
    sub_10003F158();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    char v14 = 3;
    KeyedEncodingContainer.encode(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v11, v8);
}

uint64_t sub_10003DD48()
{
  uint64_t result = 0x7473694C656C6966;
  switch(*v0)
  {
    case 1:
      uint64_t result = 0x6B73694465657266;
      break;
    case 2:
      uint64_t result = 0x42646574696D696CLL;
      break;
    case 3:
      uint64_t result = 0x6764754265747962;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_10003DDF4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = sub_10003F640(a1, a2);
  *a3 = result;
  return result;
}

void sub_10003DE1C(unsigned char *a1@<X8>)
{
  *a1 = 4;
}

uint64_t sub_10003DE28(uint64_t a1)
{
  unint64_t v2 = sub_10003F104();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_10003DE64(uint64_t a1)
{
  unint64_t v2 = sub_10003F104();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_10003DEA0(void *a1)
{
  return sub_10003DB6C(a1, *(void *)v1, *(void *)(v1 + 8), *(unsigned char *)(v1 + 16), *(void *)(v1 + 24));
}

uint64_t sub_10003DEC4(uint64_t a1, uint64_t a2, char a3)
{
  if (a3)
  {
    id v6 = [self sharedOptions];
    id v7 = [v6 dryRestoreGBAllowance];

    if (v7)
    {
      [v7 doubleValue];
      double v5 = v8;

      if (v5 > 0.0) {
        goto LABEL_6;
      }
    }
LABEL_10:
    uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_11;
  }
  double v5 = *(double *)&a2;
  if (*(double *)&a2 <= 0.0) {
    goto LABEL_10;
  }
LABEL_6:
  double v9 = v5 * 1024.0 * 1024.0 * 1024.0;
  if ((~*(void *)&v9 & 0x7FF0000000000000) == 0)
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  if (v9 <= -9.22337204e18)
  {
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }
  if (v9 >= 9.22337204e18)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  uint64_t v10 = (uint64_t)v9;
LABEL_11:
  NSString v11 = [v3 volumeMountPoint];
  if (!v11)
  {
    static String._unconditionallyBridgeFromObjectiveC(_:)();
    NSString v11 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
  }
  uint64_t v12 = MBFreeDiskSpaceForVolume();

  if (v12 < 0)
  {
    __break(1u);
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  if (v12 - 0x140000000 >= v10) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = v12 - 0x140000000;
  }
  if (__OFSUB__(v13, a1)) {
    goto LABEL_21;
  }
  if ((a1 & 0x8000000000000000) == 0) {
    return a1;
  }
LABEL_25:
  uint64_t result = _assertionFailure(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

char *sub_10003E0A0(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = *((void *)a4 + 3);
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = *((void *)a4 + 2);
    if (v7 <= v8) {
      uint64_t v9 = *((void *)a4 + 2);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      sub_100006FC8(&qword_10047DE68);
      uint64_t v10 = (char *)swift_allocObject();
      int64_t v11 = j__malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 25;
      }
      *((void *)v10 + 2) = v8;
      *((void *)v10 + 3) = 2 * (v12 >> 3);
      uint64_t v13 = v10 + 32;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = (char *)&_swiftEmptyArrayStorage;
      uint64_t v13 = (char *)&_swiftEmptyArrayStorage + 32;
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[8 * v8 + 32]) {
          memmove(v13, a4 + 32, 8 * v8);
        }
        *((void *)a4 + 2) = 0;
        goto LABEL_24;
      }
    }
    sub_10003E768(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_10003E1B0(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      sub_100006FC8(&qword_10047D398);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = j__malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 17;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 4);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[2 * v8 + 4]) {
          memmove(v13, a4 + 4, 16 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_10003E874(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

void *sub_10003E2C0(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      sub_100006FC8(&qword_10047DE70);
      uint64_t v10 = (void *)swift_allocObject();
      size_t v11 = j__malloc_size(v10);
      v10[2] = v8;
      v10[3] = 2 * ((uint64_t)(v11 - 32) / 24);
      uint64_t v12 = v10 + 4;
      if (v5)
      {
LABEL_13:
        if (v10 != a4 || v12 >= &a4[3 * v8 + 4]) {
          memmove(v12, a4 + 4, 24 * v8);
        }
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v10 = _swiftEmptyArrayStorage;
      uint64_t v12 = &_swiftEmptyArrayStorage[4];
      if (result) {
        goto LABEL_13;
      }
    }
    sub_10003EC18(0, v8, (unint64_t)v12, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

uint64_t sub_10003E3E8(char a1, int64_t a2, char a3, unint64_t a4)
{
  if (a3)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_29;
      }
      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        uint64_t v7 = a2;
      }
    }
  }
  else
  {
    uint64_t v7 = a2;
  }
  uint64_t v8 = *(void *)(a4 + 16);
  if (v7 <= v8) {
    uint64_t v9 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v9 = v7;
  }
  if (!v9)
  {
    uint64_t v13 = _swiftEmptyArrayStorage;
    goto LABEL_19;
  }
  sub_100006FC8(&qword_10047DE80);
  uint64_t v10 = *(void *)(sub_100006FC8((uint64_t *)&unk_10047DE50) - 8);
  uint64_t v11 = *(void *)(v10 + 72);
  unint64_t v12 = (*(unsigned __int8 *)(v10 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80);
  uint64_t v13 = (void *)swift_allocObject();
  size_t v14 = j__malloc_size(v13);
  if (!v11 || (v14 - v12 == 0x8000000000000000 ? (BOOL v15 = v11 == -1) : (BOOL v15 = 0), v15))
  {
LABEL_29:
    uint64_t result = _assertionFailure(_:_:file:line:flags:)();
    __break(1u);
    return result;
  }
  void v13[2] = v8;
  v13[3] = 2 * ((uint64_t)(v14 - v12) / v11);
LABEL_19:
  uint64_t v16 = *(void *)(sub_100006FC8((uint64_t *)&unk_10047DE50) - 8);
  unint64_t v17 = (*(unsigned __int8 *)(v16 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80);
  unint64_t v18 = (unint64_t)v13 + v17;
  if (a1)
  {
    if ((unint64_t)v13 < a4 || v18 >= a4 + v17 + *(void *)(v16 + 72) * v8)
    {
      swift_arrayInitWithTakeFrontToBack();
    }
    else if (v13 != (void *)a4)
    {
      swift_arrayInitWithTakeBackToFront();
    }
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    sub_10003ED28(0, v8, v18, a4);
  }
  swift_bridgeObjectRelease();
  return (uint64_t)v13;
}

void *sub_10003E658(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }
  unint64_t v6 = a4[3];
  uint64_t v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2) {
    goto LABEL_8;
  }
  if (v7 + 0x4000000000000000 >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
      uint64_t v7 = a2;
    }
LABEL_8:
    uint64_t v8 = a4[2];
    if (v7 <= v8) {
      uint64_t v9 = a4[2];
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      sub_100006FC8(&qword_10047D3E8);
      uint64_t v10 = (void *)swift_allocObject();
      int64_t v11 = j__malloc_size(v10);
      uint64_t v12 = v11 - 32;
      if (v11 < 32) {
        uint64_t v12 = v11 - 17;
      }
      v10[2] = v8;
      v10[3] = 2 * (v12 >> 4);
      uint64_t v13 = v10 + 4;
      if (v5) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v10 = _swiftEmptyArrayStorage;
      uint64_t v13 = &_swiftEmptyArrayStorage[4];
      if (result)
      {
LABEL_15:
        if (v10 != a4 || v13 >= &a4[2 * v8 + 4]) {
          memmove(v13, a4 + 4, 16 * v8);
        }
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_10003E968(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease();
    return v10;
  }
  __break(1u);
  return result;
}

uint64_t sub_10003E768(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 8 * a1 + 32;
    unint64_t v6 = a3 + 8 * v4;
    if (v5 >= v6 || v5 + 8 * v4 <= a3)
    {
      sub_100006FC8(&qword_10047D0A0);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_10003E874(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_10003E968(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 16 * a1 + 32;
    unint64_t v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      sub_100006FC8(&qword_10047D3E0);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

void *sub_10003EA74(unint64_t a1, void *a2)
{
  if (a1 >> 62) {
    goto LABEL_17;
  }
  uint64_t v3 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  swift_bridgeObjectRetain();
  for (; v3; uint64_t v3 = _CocoaArrayWrapper.endIndex.getter())
  {
    uint64_t v4 = _swiftEmptyArrayStorage;
    uint64_t v5 = 4;
    while (1)
    {
      id v6 = (a1 & 0xC000000000000001) != 0
         ? (id)specialized _ArrayBuffer._getElementSlowPath(_:)()
         : *(id *)(a1 + 8 * v5);
      uint64_t v7 = v6;
      uint64_t v8 = v5 - 3;
      if (__OFADD__(v5 - 4, 1)) {
        break;
      }
      id v9 = [a2 dryRestoreConfigurationForAccount:v6];
      if (v9)
      {
        uint64_t v10 = v9;
        uint64_t v11 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v13 = v12;

        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
          uint64_t v4 = sub_10003E1B0(0, v4[2] + 1, 1, v4);
        }
        unint64_t v15 = v4[2];
        unint64_t v14 = v4[3];
        if (v15 >= v14 >> 1) {
          uint64_t v4 = sub_10003E1B0((void *)(v14 > 1), v15 + 1, 1, v4);
        }
        v4[2] = v15 + 1;
        uint64_t v16 = &v4[2 * v15];
        v16[4] = v11;
        v16[5] = v13;
      }
      else
      {
      }
      ++v5;
      if (v8 == v3) {
        goto LABEL_19;
      }
    }
    __break(1u);
LABEL_17:
    swift_bridgeObjectRetain();
  }
  uint64_t v4 = _swiftEmptyArrayStorage;
LABEL_19:
  swift_bridgeObjectRelease();
  return v4;
}

uint64_t sub_10003EC18(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = a4 + 24 * a1 + 32;
    unint64_t v6 = a3 + 24 * v4;
    if (v5 >= v6 || v5 + 24 * v4 <= a3)
    {
      sub_100006FC8(&qword_10047DE78);
      swift_arrayInitWithCopy();
      return v6;
    }
  }
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_10003ED28(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else if ((v4 & 0x8000000000000000) == 0)
  {
    uint64_t v8 = *(void *)(sub_100006FC8((uint64_t *)&unk_10047DE50) - 8);
    uint64_t v9 = a4 + ((*(unsigned __int8 *)(v8 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80));
    uint64_t v10 = *(void *)(v8 + 72);
    unint64_t v11 = v9 + v10 * a1;
    unint64_t v12 = a3 + v10 * v4;
    if (v11 >= v12 || v11 + v10 * v4 <= a3)
    {
      swift_arrayInitWithCopy();
      return v12;
    }
  }
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

uint64_t sub_10003EE84()
{
  id v0 = [self sharedInstance];
  id v1 = [self allServiceAccounts];
  sub_10003F020();
  unint64_t v2 = static Array._unconditionallyBridgeFromObjectiveC(_:)();

  id v3 = v0;
  uint64_t v4 = sub_10003EA74(v2, v3);
  swift_bridgeObjectRelease();

  if (sub_10003D750(0x64656C6261736964, 0xE800000000000000, v4))
  {

    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    id v6 = [self sharedOptions];
    uint64_t v5 = sub_10003D818();
    int v8 = ~v7;

    if (v8)
    {

      swift_bridgeObjectRelease();
    }
    else
    {
      char v9 = sub_10003D750(0xD000000000000011, 0x8000000100307440, v4);
      swift_bridgeObjectRelease();

      if (v9) {
        return 0x40F5180000000000;
      }
      else {
        return 0;
      }
    }
  }
  return v5;
}

unint64_t sub_10003F020()
{
  unint64_t result = qword_10047DE60;
  if (!qword_10047DE60)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_10047DE60);
  }
  return result;
}

__n128 initializeWithCopy for MBDryRestoreBudget(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreBudget(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFF && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  BOOL v4 = v3 >= 2;
  int v5 = v3 - 2;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for MBDryRestoreBudget(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = a2 - 255;
    *(void *)(result + 8) = 0;
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 32) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 16) = a2 + 1;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreBudget()
{
  return &type metadata for MBDryRestoreBudget;
}

unint64_t sub_10003F104()
{
  unint64_t result = qword_10047DE90;
  if (!qword_10047DE90)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DE90);
  }
  return result;
}

unint64_t sub_10003F158()
{
  unint64_t result = qword_10047DE98;
  if (!qword_10047DE98)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DE98);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreBudget.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFD) {
    goto LABEL_17;
  }
  if (a2 + 3 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 3) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 3;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 4;
  int v8 = v6 - 4;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBDryRestoreBudget.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFC)
  {
    unsigned int v6 = ((a2 - 253) >> 8) + 1;
    *unint64_t result = a2 + 3;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x10003F308);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 3;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreBudget.CodingKeys()
{
  return &type metadata for MBDryRestoreBudget.CodingKeys;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreBudgetConstraint(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = v6 - 2;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBDryRestoreBudgetConstraint(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *unint64_t result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x10003F49CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 1;
        break;
    }
  }
  return result;
}

unsigned char *sub_10003F4C4(unsigned char *result, char a2)
{
  *unint64_t result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreBudgetConstraint()
{
  return &type metadata for MBDryRestoreBudgetConstraint;
}

unint64_t sub_10003F4E4()
{
  unint64_t result = qword_10047DEA0;
  if (!qword_10047DEA0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DEA0);
  }
  return result;
}

unint64_t sub_10003F53C()
{
  unint64_t result = qword_10047DEA8;
  if (!qword_10047DEA8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DEA8);
  }
  return result;
}

unint64_t sub_10003F594()
{
  unint64_t result = qword_10047DEB0;
  if (!qword_10047DEB0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DEB0);
  }
  return result;
}

unint64_t sub_10003F5EC()
{
  unint64_t result = qword_10047DEB8;
  if (!qword_10047DEB8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DEB8);
  }
  return result;
}

uint64_t sub_10003F640(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x7473694C656C6966 && a2 == 0xEC000000657A6953;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6B73694465657266 && a2 == 0xED00006563617053 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x42646574696D696CLL && a2 == 0xE900000000000079 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x6764754265747962 && a2 == 0xEA00000000007465)
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 3;
    }
    else {
      return 4;
    }
  }
}

unint64_t sub_10003F850()
{
  unint64_t result = qword_10047DEC0;
  if (!qword_10047DEC0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DEC0);
  }
  return result;
}

uint64_t sub_10003F8A4@<X0>(void *a1@<X0>, void *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8 = type metadata accessor for URL();
  __chkstk_darwin(v8);
  unint64_t v11 = (char *)&v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!a3)
  {
    uint64_t v24 = v9;
    if (qword_10047CB28 != -1) {
      swift_once();
    }
    uint64_t v19 = sub_10000CC8C(v8, (uint64_t)qword_10047DFE0);
    (*(void (**)(char *, uint64_t, uint64_t))(v24 + 16))(v11, v19, v8);
    uint64_t v25 = 0;
    unint64_t v26 = 0xE000000000000000;
    _StringGuts.grow(_:)(22);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v25 = (uint64_t)a1;
    unint64_t v26 = (unint64_t)a2;
    v20._object = (void *)0x80000001003077B0;
    v20._countAndFlagsBits = 0xD000000000000014;
    String.append(_:)(v20);
    URL.appendingPathComponent(_:)();
    swift_bridgeObjectRelease();
    (*(void (**)(char *, uint64_t))(v24 + 8))(v11, v8);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v24 + 56))(a4, 0, 1, v8);
  }
  if (a3 == 1)
  {
    uint64_t v24 = v9;
    id v12 = [a1 persona];
    id v13 = [v12 personaIdentifier];

    uint64_t v14 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v16 = v15;

    if (qword_10047CB28 != -1) {
      swift_once();
    }
    uint64_t v17 = sub_10000CC8C(v8, (uint64_t)qword_10047DFE0);
    (*(void (**)(char *, uint64_t, uint64_t))(v24 + 16))(v11, v17, v8);
    uint64_t v25 = 0;
    unint64_t v26 = 0xE000000000000000;
    _StringGuts.grow(_:)(22);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v25 = v14;
    unint64_t v26 = v16;
    v18._object = (void *)0x80000001003077B0;
    v18._countAndFlagsBits = 0xD000000000000014;
    String.append(_:)(v18);
    URL.appendingPathComponent(_:)();
    swift_bridgeObjectRelease();
    (*(void (**)(char *, uint64_t))(v24 + 8))(v11, v8);
    sub_100040654(a1, a2, 1);
    swift_bridgeObjectRelease();
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v24 + 56))(a4, 0, 1, v8);
  }
  unint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
  return v22(a4, 1, 1, v8);
}

unint64_t sub_10003FC28(void *a1, void *a2, char a3)
{
  unint64_t v5 = 0xD000000000000019;
  if (!a3)
  {
    _StringGuts.grow(_:)(43);
    swift_bridgeObjectRelease();
    unint64_t v17 = 0xD000000000000028;
    v14._countAndFlagsBits = (uint64_t)a1;
    v14._object = a2;
    String.append(_:)(v14);
    v15._countAndFlagsBits = 41;
    v15._object = (void *)0xE100000000000000;
    String.append(_:)(v15);
    return v17;
  }
  if (a3 == 1)
  {
    id v6 = a1;
    _StringGuts.grow(_:)(50);
    swift_bridgeObjectRelease();
    unint64_t v17 = 0xD00000000000002FLL;
    id v7 = [v6 persona];
    id v8 = [v7 personaIdentifier];

    uint64_t v9 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    unint64_t v11 = v10;

    v12._countAndFlagsBits = v9;
    v12._object = v11;
    String.append(_:)(v12);
    swift_bridgeObjectRelease();
    v13._countAndFlagsBits = 41;
    v13._object = (void *)0xE100000000000000;
    String.append(_:)(v13);
    sub_100040654(a1, a2, 1);
    return v17;
  }
  return v5;
}

unint64_t sub_10003FDB0()
{
  return sub_10003FC28(*(void **)v0, *(void **)(v0 + 8), *(unsigned char *)(v0 + 16));
}

uint64_t sub_10003FDBC(uint64_t a1, uint64_t a2)
{
  return sub_100040B2C(*(void **)a1, *(void **)(a1 + 8), *(unsigned char *)(a1 + 16), *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 16));
}

void sub_100040174()
{
  uint64_t v1 = v0 + OBJC_IVAR____TtC7backupd14MigratorConfig_state;
  if (*(unsigned char *)(v0 + OBJC_IVAR____TtC7backupd14MigratorConfig_state + 16) == 1)
  {
    id v3 = *(id *)v1;
    BOOL v2 = *(void **)(v1 + 8);
    id v4 = [*(id *)v1 persona];
    id v5 = [v4 demotedAppsPlistPath];

    static String._unconditionallyBridgeFromObjectiveC(_:)();
    URL.init(fileURLWithPath:isDirectory:)();
    swift_bridgeObjectRelease();
    sub_100040654(v3, v2, 1);
  }
  else
  {
    URL.init(fileURLWithPath:isDirectory:)();
  }
}

uint64_t type metadata accessor for MigratorConfig()
{
  return self;
}

id sub_100040624(id result, id a2, char a3)
{
  if (a3 == 1) {
    return result;
  }
  if (!a3) {
    return (id)swift_bridgeObjectRetain();
  }
  return result;
}

void destroy for MigratorConfig.State(uint64_t a1)
{
}

void sub_100040654(void *a1, id a2, char a3)
{
  if (a3 == 1)
  {
  }
  else if (!a3)
  {
    swift_bridgeObjectRelease();
  }
}

uint64_t _s7backupd14MigratorConfigC5StateOwCP_0(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  id v4 = *(void **)(a2 + 8);
  char v5 = *(unsigned char *)(a2 + 16);
  sub_100040624(*(id *)a2, v4, v5);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 16) = v5;
  return a1;
}

uint64_t assignWithCopy for MigratorConfig.State(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  id v4 = *(void **)(a2 + 8);
  char v5 = *(unsigned char *)(a2 + 16);
  sub_100040624(*(id *)a2, v4, v5);
  id v6 = *(void **)a1;
  id v7 = *(void **)(a1 + 8);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  char v8 = *(unsigned char *)(a1 + 16);
  *(unsigned char *)(a1 + 16) = v5;
  sub_100040654(v6, v7, v8);
  return a1;
}

__n128 initializeWithTake for MigratorConfig.State(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

uint64_t assignWithTake for MigratorConfig.State(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a2 + 16);
  id v4 = *(void **)a1;
  char v5 = *(void **)(a1 + 8);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  char v6 = *(unsigned char *)(a1 + 16);
  *(unsigned char *)(a1 + 16) = v3;
  sub_100040654(v4, v5, v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for MigratorConfig.State(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFE && *(unsigned char *)(a1 + 17)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 <= 2) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for MigratorConfig.State(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(unsigned char *)(result + 16) = 0;
    *(void *)__n128 result = a2 - 254;
    *(void *)(result + 8) = 0;
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 17) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 17) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 16) = -(char)a2;
    }
  }
  return result;
}

uint64_t sub_100040800(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 16) <= 1u) {
    return *(unsigned __int8 *)(a1 + 16);
  }
  else {
    return (*(_DWORD *)a1 + 2);
  }
}

uint64_t sub_100040818(uint64_t result, unsigned int a2)
{
  if (a2 >= 2)
  {
    *(void *)__n128 result = a2 - 2;
    *(void *)(result + 8) = 0;
    LOBYTE(a2) = 2;
  }
  *(unsigned char *)(result + 16) = a2;
  return result;
}

ValueMetadata *type metadata accessor for MigratorConfig.State()
{
  return &type metadata for MigratorConfig.State;
}

unint64_t sub_100040840(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    unsigned int v3 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047DAB8);
  uint64_t v2 = static _DictionaryStorage.allocate(capacity:)();
  unsigned int v3 = (void *)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  uint64_t v5 = v2 + 64;
  uint64_t v6 = a1 + 32;
  swift_retain();
  while (1)
  {
    sub_100040E84(v6, (uint64_t)&v15);
    uint64_t v7 = v15;
    uint64_t v8 = v16;
    unint64_t result = sub_10004096C(v15, v16);
    if (v10) {
      break;
    }
    *(void *)(v5 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    unint64_t v11 = (uint64_t *)(v3[6] + 16 * result);
    uint64_t *v11 = v7;
    v11[1] = v8;
    unint64_t result = (unint64_t)sub_100016C78(&v17, (_OWORD *)(v3[7] + 32 * result));
    uint64_t v12 = v3[2];
    BOOL v13 = __OFADD__(v12, 1);
    uint64_t v14 = v12 + 1;
    if (v13) {
      goto LABEL_11;
    }
    v3[2] = v14;
    v6 += 48;
    if (!--v4)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_10004096C(uint64_t a1, uint64_t a2)
{
  Hasher.init(_seed:)();
  String.hash(into:)();
  Swift::Int v4 = Hasher._finalize()();
  return sub_1000409E4(a1, a2, v4);
}

unint64_t sub_1000409E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v3 + 32);
  unint64_t i = a3 & ~v5;
  if ((*(void *)(v3 + 64 + ((i >> 3) & 0xFFFFFFFFFFFFFF8)) >> i))
  {
    uint64_t v9 = *(void *)(v3 + 48);
    char v10 = (void *)(v9 + 16 * i);
    if ((*v10 != a1 || v10[1] != a2) && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      uint64_t v12 = ~v5;
      unint64_t i = (i + 1) & v12;
      if ((*(void *)(v4 + ((i >> 3) & 0xFFFFFFFFFFFFFF8)) >> i))
      {
        BOOL v13 = (void *)(v9 + 16 * i);
        if ((*v13 != a1 || v13[1] != a2) && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
        {
          for (unint64_t i = (i + 1) & v12; ((*(void *)(v4 + ((i >> 3) & 0xFFFFFFFFFFFFFF8)) >> i) & 1) != 0; unint64_t i = (i + 1) & v12)
          {
            uint64_t v15 = (void *)(v9 + 16 * i);
            if (*v15 == a1 && v15[1] == a2) {
              break;
            }
            if (_stringCompareWithSmolCheck(_:_:expecting:)()) {
              break;
            }
          }
        }
      }
    }
  }
  return i;
}

uint64_t sub_100040B2C(void *a1, void *a2, char a3, unint64_t a4, unint64_t a5, char a6)
{
  if (a3)
  {
    if (a3 == 1)
    {
      if (a6 == 1)
      {
        sub_100040C58();
        sub_100040624(a1, a2, 1);
        sub_100040624((id)a4, (id)a5, 1);
        char v10 = static NSObject.== infix(_:_:)();
        sub_100040654((void *)a4, (id)a5, 1);
        sub_100040654(a1, a2, 1);
        return v10 & 1;
      }
      return 0;
    }
    return a6 == 2 && !(a5 | a4);
  }
  if (a6) {
    return 0;
  }
  if (a1 == (void *)a4 && a2 == (void *)a5) {
    return 1;
  }
  return _stringCompareWithSmolCheck(_:_:expecting:)();
}

unint64_t sub_100040C58()
{
  unint64_t result = qword_10047DEF8;
  if (!qword_10047DEF8)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_10047DEF8);
  }
  return result;
}

uint64_t sub_100040C98(uint64_t a1, uint64_t a2, char a3, char a4)
{
  uint64_t v8 = type metadata accessor for POSIXError();
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  unint64_t v11 = (char *)v13 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (a3)
  {
    if ((a4 & 1) == 0)
    {
      swift_bridgeObjectRelease();
      return 0;
    }
    if (a2) {
      return a1;
    }
    void v13[2] = 2;
    sub_100040840((uint64_t)_swiftEmptyArrayStorage);
    sub_100040E2C();
  }
  else
  {
    swift_bridgeObjectRelease();
    v13[3] = 22;
    sub_100040840((uint64_t)_swiftEmptyArrayStorage);
    sub_100040E2C();
  }
  _BridgedStoredNSError.init(_:userInfo:)();
  POSIXError._nsError.getter();
  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
  swift_willThrow();
  return a1;
}

unint64_t sub_100040E2C()
{
  unint64_t result = qword_10047DF00;
  if (!qword_10047DF00)
  {
    type metadata accessor for POSIXError();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047DF00);
  }
  return result;
}

uint64_t sub_100040E84(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100006FC8(&qword_10047DF08);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

id sub_100040EEC()
{
  uint64_t v1 = OBJC_IVAR____TtC7backupd20AppRestoreDispatcher____lazy_storage___observer;
  uint64_t v2 = *(void **)&v0[OBJC_IVAR____TtC7backupd20AppRestoreDispatcher____lazy_storage___observer];
  id v3 = v2;
  if (v2 == (void *)1)
  {
    uint64_t v4 = v0;
    sub_100006FC8((uint64_t *)&unk_10047D3A0);
    unint64_t inited = swift_initStackObject();
    *(_OWORD *)(inited + 16) = xmmword_1003B1EE0;
    *(void *)(inited + 32) = [objc_allocWithZone((Class)NSNumber) initWithUnsignedInteger:2];
    specialized Array._endMutation()();
    if (inited >> 62)
    {
      swift_bridgeObjectRetain();
      uint64_t v6 = _CocoaArrayWrapper.endIndex.getter();
      swift_bridgeObjectRelease();
      if (!v6) {
        goto LABEL_6;
      }
    }
    else if (!*(void *)((inited & 0xFFFFFFFFFFFFFF8) + 0x10))
    {
LABEL_6:
      swift_bridgeObjectRelease();
      id v7 = objc_allocWithZone((Class)IXAppInstallObserver);
      uint64_t v8 = v4;
      NSString v9 = String._bridgeToObjectiveC()();
      sub_10001C0F4(0, (unint64_t *)&qword_10047D900);
      sub_1000292C4();
      Class isa = Set._bridgeToObjectiveC()().super.isa;
      swift_bridgeObjectRelease();
      id v3 = [v7 initWithMachServiceName:v9 forClients:isa delegate:v8];

      unint64_t v11 = *(void **)&v4[v1];
      *(void *)&v4[v1] = v3;
      id v12 = v3;
      sub_1000445B8(v11);
      goto LABEL_7;
    }
    sub_100043C48(inited);
    goto LABEL_6;
  }
LABEL_7:
  sub_1000445C8(v2);
  return v3;
}

id sub_1000410B8()
{
  id result = [objc_allocWithZone((Class)type metadata accessor for AppRestoreDispatcher()) init];
  qword_10047F3E8 = (uint64_t)result;
  return result;
}

uint64_t sub_100041144()
{
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  *(void *)&v0[OBJC_IVAR____TtC7backupd20AppRestoreDispatcher____lazy_storage___observer] = 1;
  uint64_t v2 = OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock;
  type metadata accessor for MBUnfairLock();
  uint64_t v3 = swift_allocObject();
  uint64_t v4 = v0;
  uint64_t v5 = (_DWORD *)swift_slowAlloc();
  *(void *)(v3 + 16) = v5;
  *uint64_t v5 = 0;
  *(void *)&v0[v2] = v3;
  *(void *)&v4[OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_restorers] = &_swiftEmptyDictionarySingleton;

  v22.receiver = v4;
  v22.super_class = ObjectType;
  uint64_t v6 = objc_msgSendSuper2(&v22, "init");
  id v7 = sub_100040EEC();
  if (v7)
  {
    uint64_t v8 = v7;
    if (qword_10047CB30 != -1) {
      swift_once();
    }
    uint64_t v9 = type metadata accessor for Logger();
    sub_10000CC8C(v9, (uint64_t)qword_10047F400);
    uint64_t v10 = v8;
    unint64_t v11 = Logger.logObject.getter();
    os_log_type_t v12 = static os_log_type_t.default.getter();
    if (os_log_type_enabled(v11, v12))
    {
      BOOL v13 = (uint8_t *)swift_slowAlloc();
      uint64_t v14 = (void *)swift_slowAlloc();
      *(_DWORD *)BOOL v13 = 138412290;
      v21[0] = (uint64_t)v10;
      uint64_t v10 = v10;
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      *uint64_t v14 = v8;

      _os_log_impl((void *)&_mh_execute_header, v11, v12, "Created IXAppInstallObserver instance: %@", v13, 0xCu);
      sub_100006FC8(&qword_10047DFC8);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
      uint64_t v15 = v6;
    }
    else
    {

      unint64_t v11 = v10;
      uint64_t v15 = v10;
    }

    return (uint64_t)v6;
  }
  else
  {

    if (qword_10047CB30 != -1) {
      swift_once();
    }
    uint64_t v17 = type metadata accessor for Logger();
    sub_10000CC8C(v17, (uint64_t)qword_10047F400);
    Swift::String v18 = Logger.logObject.getter();
    os_log_type_t v19 = static os_log_type_t.error.getter();
    if (os_log_type_enabled(v18, v19))
    {
      Swift::String v20 = (uint8_t *)swift_slowAlloc();
      v21[0] = swift_slowAlloc();
      *(_DWORD *)Swift::String v20 = 136315138;
      sub_100046E00(0xD000000000000025, 0x80000001003079C0, v21);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      _os_log_impl((void *)&_mh_execute_header, v18, v19, "Failed to initialize observer for %s", v20, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }

    v21[0] = 0;
    v21[1] = 0xE000000000000000;
    _StringGuts.grow(_:)(36);
    swift_bridgeObjectRelease();
    uint64_t result = _assertionFailure(_:_:file:line:flags:)();
    __break(1u);
  }
  return result;
}

uint64_t sub_100041560(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = v4;
  uint64_t v9 = *(void *)(v3 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock);
  uint64_t v10 = *(os_unfair_lock_s **)(v9 + 16);
  swift_retain();
  os_unfair_lock_lock(v10);
  sub_1000415FC(a1, v3, a2, a3, &v12);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v9 + 16));
  uint64_t result = swift_release();
  if (!v5) {
    return v12;
  }
  return result;
}

id sub_1000415FC@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v68 = a3;
  Swift::String v70 = a5;
  uint64_t v75 = type metadata accessor for URL();
  uint64_t v8 = *(void *)(v75 - 8);
  uint64_t v9 = __chkstk_darwin(v75);
  Swift::String v71 = &v63[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v11 = __chkstk_darwin(v9);
  BOOL v13 = &v63[-v12];
  __chkstk_darwin(v11);
  id v73 = a1;
  uint64_t v74 = &v63[-v14];
  id v15 = [a1 persona];
  id v16 = [v15 personaIdentifier];

  uint64_t v72 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v18 = v17;

  os_log_type_t v19 = (uint64_t *)(a2 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_restorers);
  swift_beginAccess();
  uint64_t v20 = *v19;
  if (*(void *)(*v19 + 16))
  {
    swift_bridgeObjectRetain();
    unint64_t v21 = sub_100031554(v72, v18);
    if (v22)
    {
      uint64_t v23 = *(void **)(*(void *)(v20 + 56) + 8 * v21);
      swift_endAccess();
      id v24 = v23;
      swift_bridgeObjectRelease_n();
      id result = [v24 setDelegate:a4];
      *Swift::String v70 = v24;
      return result;
    }
    swift_bridgeObjectRelease();
  }
  uint64_t v66 = v19;
  uint64_t v67 = a4;
  unint64_t v69 = v18;
  swift_endAccess();
  id v26 = [v73 persona];
  id v27 = [v26 personaIdentifier];

  uint64_t v28 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  unint64_t v30 = v29;

  if (qword_10047CB28 != -1) {
    swift_once();
  }
  uint64_t v31 = v75;
  uint64_t v32 = sub_10000CC8C(v75, (uint64_t)qword_10047DFE0);
  NSString v33 = *(void (**)(unsigned char *, uint64_t, uint64_t))(v8 + 16);
  v33(v13, v32, v31);
  uint64_t v78 = 0;
  unint64_t v79 = 0xE000000000000000;
  _StringGuts.grow(_:)(22);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v78 = v28;
  unint64_t v79 = v30;
  v34._object = (void *)0x80000001003077B0;
  v34._countAndFlagsBits = 0xD000000000000014;
  String.append(_:)(v34);
  id v35 = v74;
  URL.appendingPathComponent(_:)();
  swift_bridgeObjectRelease();
  id v36 = *(void (**)(unsigned char *, uint64_t))(v8 + 8);
  v36(v13, v31);
  swift_bridgeObjectRelease();
  uint64_t v37 = (uint64_t)v71;
  v33(v71, (uint64_t)v35, v31);
  id v38 = objc_allocWithZone((Class)type metadata accessor for MigratorCache());
  NSString v39 = v76;
  id v40 = sub_100045494(v37);
  if (v39)
  {
    v36(v35, v31);
    return (id)swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v41 = v40;
    uint64_t v65 = (uint64_t (*)(unsigned char *, uint64_t))v36;
    Swift::String v71 = (unsigned char *)(v8 + 8);
    swift_beginAccess();
    id v42 = objc_allocWithZone((Class)MBAppRestoreManager);
    unsigned __int8 v43 = v68;
    id v44 = v73;
    swift_bridgeObjectRetain();
    Class isa = Set._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    id v46 = [v42 initWithStateQueue:v43 account:v44 bundleIDs:isa];

    unint64_t v47 = v69;
    if (qword_10047CB30 != -1) {
      swift_once();
    }
    uint64_t v48 = type metadata accessor for Logger();
    sub_10000CC8C(v48, (uint64_t)qword_10047F400);
    swift_bridgeObjectRetain_n();
    id v49 = v46;
    Swift::String v50 = Logger.logObject.getter();
    os_log_type_t v51 = static os_log_type_t.default.getter();
    int v52 = v51;
    uint64_t v76 = v50;
    if (os_log_type_enabled(v50, v51))
    {
      uint64_t v53 = swift_slowAlloc();
      uint64_t v68 = (void *)swift_slowAlloc();
      id v73 = (id)swift_slowAlloc();
      v77[0] = v73;
      *(_DWORD *)uint64_t v53 = 136315394;
      swift_bridgeObjectRetain();
      uint64_t v54 = v72;
      uint64_t v80 = sub_100046E00(v72, v47, (uint64_t *)v77);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      swift_bridgeObjectRelease_n();
      *(_WORD *)(v53 + 12) = 2112;
      int v64 = v52;
      uint64_t v80 = (uint64_t)v49;
      unint64_t v55 = v41;
      id v56 = v49;
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      *uint64_t v68 = v49;

      uint64_t v41 = v55;
      unint64_t v47 = v69;
      id v57 = v76;
      _os_log_impl((void *)&_mh_execute_header, v76, (os_log_type_t)v64, "Created MBAppRestoreManager instance for %s: %@", (uint8_t *)v53, 0x16u);
      sub_100006FC8(&qword_10047DFC8);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();

      uint64_t v58 = v67;
    }
    else
    {

      swift_bridgeObjectRelease_n();
      uint64_t v58 = v67;
      uint64_t v54 = v72;
    }
    uint64_t v60 = v65;
    unsigned __int8 v59 = v66;
    [v49 setDelegate:v58];
    swift_beginAccess();
    id v61 = v49;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v80 = *v59;
    *unsigned __int8 v59 = 0x8000000000000000;
    sub_100032FC0((uint64_t)v61, v54, v47, isUniquelyReferenced_nonNull_native);
    *unsigned __int8 v59 = v80;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_endAccess();

    id result = (id)v60(v74, v75);
    *Swift::String v70 = v61;
  }
  return result;
}

uint64_t type metadata accessor for AppRestoreDispatcher()
{
  return self;
}

void sub_100041E84(void *a1)
{
  id v3 = [a1 bundleID];
  uint64_t v4 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  unint64_t v6 = v5;

  v28[1] = (uint64_t)&OBJC_PROTOCOL____TtP7backupd18RestoreCoordinator_;
  uint64_t v7 = swift_dynamicCastObjCProtocolConditional();
  if (!v7)
  {
    if (qword_10047CB30 == -1) {
      goto LABEL_9;
    }
    goto LABEL_21;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(v1 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock);
  uint64_t v10 = *(os_unfair_lock_s **)(v9 + 16);
  id v11 = a1;
  swift_retain();
  os_unfair_lock_lock(v10);
  uint64_t v12 = (uint64_t *)(v1 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_restorers);
  swift_beginAccess();
  uint64_t v13 = *v12;
  uint64_t v14 = *(os_unfair_lock_s **)(v9 + 16);
  swift_bridgeObjectRetain();
  os_unfair_lock_unlock(v14);
  swift_release();
  swift_bridgeObjectRetain();
  sub_100043FA4(v13);
  unint64_t v16 = v15;
  swift_bridgeObjectRelease();
  if (v16 >> 62)
  {
    if (_CocoaArrayWrapper.endIndex.getter()) {
      goto LABEL_4;
    }
  }
  else if (*(void *)((v16 & 0xFFFFFFFFFFFFFF8) + 0x10))
  {
LABEL_4:
    if ((v16 & 0xC000000000000001) != 0)
    {
      id v17 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
      goto LABEL_7;
    }
    if (*(void *)((v16 & 0xFFFFFFFFFFFFFF8) + 0x10))
    {
      id v17 = *(id *)(v16 + 32);
LABEL_7:
      uint64_t v18 = v17;
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      [v18 restoreCoordinatorShouldBeginRestoringUserData:v8];

      return;
    }
    __break(1u);
LABEL_21:
    swift_once();
LABEL_9:
    uint64_t v19 = type metadata accessor for Logger();
    sub_10000CC8C(v19, (uint64_t)qword_10047F400);
    swift_bridgeObjectRetain();
    uint64_t v20 = Logger.logObject.getter();
    os_log_type_t v21 = static os_log_type_t.error.getter();
    if (os_log_type_enabled(v20, v21))
    {
      char v22 = (uint8_t *)swift_slowAlloc();
      v27[0] = swift_slowAlloc();
      *(_DWORD *)char v22 = 136315138;
      swift_bridgeObjectRetain();
      v28[0] = sub_100046E00(v4, v6, v27);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      swift_bridgeObjectRelease_n();
      _os_log_impl((void *)&_mh_execute_header, v20, v21, "Not a RestoreCoordinator instance for %s", v22, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {

      swift_bridgeObjectRelease_n();
    }
    return;
  }
  swift_bridgeObjectRelease();
  if (qword_10047CB30 != -1) {
    swift_once();
  }
  uint64_t v23 = type metadata accessor for Logger();
  sub_10000CC8C(v23, (uint64_t)qword_10047F400);
  swift_bridgeObjectRetain();
  id v24 = Logger.logObject.getter();
  os_log_type_t v25 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v24, v25))
  {
    id v26 = (uint8_t *)swift_slowAlloc();
    v28[0] = swift_slowAlloc();
    *(_DWORD *)id v26 = 136315138;
    swift_bridgeObjectRetain();
    sub_100046E00(v4, v6, v28);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    _os_log_impl((void *)&_mh_execute_header, v24, v25, "Failed to find a restorer for %s", v26, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    swift_bridgeObjectRelease_n();
  }
}

void sub_10004236C(void *a1, uint64_t a2, uint64_t a3)
{
  id v6 = [a1 bundleID];
  uint64_t v7 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  unint64_t v9 = v8;

  v32[1] = (uint64_t)&OBJC_PROTOCOL____TtP7backupd18RestoreCoordinator_;
  uint64_t v10 = swift_dynamicCastObjCProtocolConditional();
  if (!v10)
  {
    if (qword_10047CB30 == -1) {
      goto LABEL_9;
    }
    goto LABEL_21;
  }
  uint64_t v11 = v10;
  uint64_t v12 = *(void *)(v3 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock);
  uint64_t v13 = *(os_unfair_lock_s **)(v12 + 16);
  id v14 = a1;
  swift_retain();
  os_unfair_lock_lock(v13);
  unint64_t v15 = (uint64_t *)(v3 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_restorers);
  swift_beginAccess();
  uint64_t v16 = *v15;
  id v17 = *(os_unfair_lock_s **)(v12 + 16);
  swift_bridgeObjectRetain();
  os_unfair_lock_unlock(v17);
  swift_release();
  swift_bridgeObjectRetain();
  sub_100043FA4(v16);
  unint64_t v19 = v18;
  swift_bridgeObjectRelease();
  if (v19 >> 62)
  {
    if (_CocoaArrayWrapper.endIndex.getter()) {
      goto LABEL_4;
    }
  }
  else if (*(void *)((v19 & 0xFFFFFFFFFFFFFF8) + 0x10))
  {
LABEL_4:
    if ((v19 & 0xC000000000000001) != 0)
    {
      id v20 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
      goto LABEL_7;
    }
    if (*(void *)((v19 & 0xFFFFFFFFFFFFFF8) + 0x10))
    {
      id v20 = *(id *)(v19 + 32);
LABEL_7:
      os_log_type_t v21 = v20;
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      char v22 = (void *)_convertErrorToNSError(_:)();
      [v21 restoreCoordinator:v11 canceledWithReason:v22 client:a3];

      return;
    }
    __break(1u);
LABEL_21:
    swift_once();
LABEL_9:
    uint64_t v23 = type metadata accessor for Logger();
    sub_10000CC8C(v23, (uint64_t)qword_10047F400);
    swift_bridgeObjectRetain();
    id v24 = Logger.logObject.getter();
    os_log_type_t v25 = static os_log_type_t.error.getter();
    if (os_log_type_enabled(v24, v25))
    {
      id v26 = (uint8_t *)swift_slowAlloc();
      v31[0] = swift_slowAlloc();
      *(_DWORD *)id v26 = 136315138;
      swift_bridgeObjectRetain();
      v32[0] = sub_100046E00(v7, v9, v31);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      swift_bridgeObjectRelease_n();
      _os_log_impl((void *)&_mh_execute_header, v24, v25, "Not a RestoreCoordinator instance for %s", v26, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {

      swift_bridgeObjectRelease_n();
    }
    return;
  }
  swift_bridgeObjectRelease();
  if (qword_10047CB30 != -1) {
    swift_once();
  }
  uint64_t v27 = type metadata accessor for Logger();
  sub_10000CC8C(v27, (uint64_t)qword_10047F400);
  swift_bridgeObjectRetain();
  uint64_t v28 = Logger.logObject.getter();
  os_log_type_t v29 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v28, v29))
  {
    unint64_t v30 = (uint8_t *)swift_slowAlloc();
    v32[0] = swift_slowAlloc();
    *(_DWORD *)unint64_t v30 = 136315138;
    swift_bridgeObjectRetain();
    sub_100046E00(v7, v9, v32);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    _os_log_impl((void *)&_mh_execute_header, v28, v29, "Failed to find a restorer for %s", v30, 0xCu);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    swift_bridgeObjectRelease_n();
  }
}

void sub_100042888(void *a1)
{
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock);
  uint64_t v4 = *(os_unfair_lock_s **)(v3 + 16);
  swift_retain();
  os_unfair_lock_lock(v4);
  id v5 = [a1 persona];
  id v6 = [v5 personaIdentifier];

  uint64_t v7 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v9 = v8;

  uint64_t v10 = (uint64_t *)(v1 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_restorers);
  swift_beginAccess();
  uint64_t v11 = *v10;
  if (*(void *)(v11 + 16) && (unint64_t v12 = sub_100031554(v7, v9), (v13 & 1) != 0))
  {
    id v14 = *(void **)(*(void *)(v11 + 56) + 8 * v12);
    id v15 = v14;
  }
  else
  {
    id v14 = 0;
  }
  swift_bridgeObjectRelease();
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v3 + 16));
  swift_release();
  if (v14)
  {
    if (qword_10047CB30 != -1) {
      swift_once();
    }
    uint64_t v16 = type metadata accessor for Logger();
    sub_10000CC8C(v16, (uint64_t)qword_10047F400);
    id v17 = a1;
    unint64_t v18 = Logger.logObject.getter();
    os_log_type_t v19 = static os_log_type_t.info.getter();
    if (os_log_type_enabled(v18, v19))
    {
      id v20 = (uint8_t *)swift_slowAlloc();
      v36[0] = swift_slowAlloc();
      *(_DWORD *)id v20 = 136315138;
      id v21 = [v17 persona];
      id v22 = [v21 personaIdentifier];

      uint64_t v23 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      unint64_t v25 = v24;

      sub_100046E00(v23, v25, v36);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();

      swift_bridgeObjectRelease();
      _os_log_impl((void *)&_mh_execute_header, v18, v19, "IX: Retrying app data downloads for %s", v20, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {
    }
    [v14 retryAppDataDownloads];
  }
  else
  {
    if (qword_10047CB30 != -1) {
      swift_once();
    }
    uint64_t v26 = type metadata accessor for Logger();
    sub_10000CC8C(v26, (uint64_t)qword_10047F400);
    id v27 = a1;
    uint64_t v28 = Logger.logObject.getter();
    os_log_type_t v29 = static os_log_type_t.info.getter();
    if (os_log_type_enabled(v28, v29))
    {
      unint64_t v30 = (uint8_t *)swift_slowAlloc();
      v36[0] = swift_slowAlloc();
      *(_DWORD *)unint64_t v30 = 136315138;
      id v31 = [v27 persona];
      id v32 = [v31 personaIdentifier];

      uint64_t v33 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      unint64_t v35 = v34;

      sub_100046E00(v33, v35, v36);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();

      swift_bridgeObjectRelease();
      _os_log_impl((void *)&_mh_execute_header, v28, v29, "IX: No app restorer found for persona %s", v30, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {
    }
  }
}

id sub_100042D70()
{
  uint64_t v1 = *(void *)(v0 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock);
  uint64_t v2 = *(os_unfair_lock_s **)(v1 + 16);
  swift_retain();
  os_unfair_lock_lock(v2);
  uint64_t v3 = (unint64_t *)(v0 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_restorers);
  swift_beginAccess();
  unint64_t v4 = *v3;
  uint64_t v5 = *v3 + 64;
  uint64_t v6 = 1 << *(unsigned char *)(*v3 + 32);
  uint64_t v7 = -1;
  if (v6 < 64) {
    uint64_t v7 = ~(-1 << v6);
  }
  unint64_t v8 = v7 & *(void *)(*v3 + 64);
  int64_t v9 = (unint64_t)(v6 + 63) >> 6;
  id result = (id)swift_bridgeObjectRetain_n();
  int64_t v11 = 0;
  while (1)
  {
    if (v8)
    {
      unint64_t v12 = __clz(__rbit64(v8));
      v8 &= v8 - 1;
      unint64_t v13 = v12 | (v11 << 6);
      goto LABEL_5;
    }
    int64_t v14 = v11 + 1;
    if (__OFADD__(v11, 1))
    {
      __break(1u);
      goto LABEL_27;
    }
    if (v14 >= v9) {
      goto LABEL_25;
    }
    unint64_t v15 = *(void *)(v5 + 8 * v14);
    ++v11;
    if (!v15)
    {
      int64_t v11 = v14 + 1;
      if (v14 + 1 >= v9) {
        goto LABEL_25;
      }
      unint64_t v15 = *(void *)(v5 + 8 * v11);
      if (!v15)
      {
        int64_t v11 = v14 + 2;
        if (v14 + 2 >= v9) {
          goto LABEL_25;
        }
        unint64_t v15 = *(void *)(v5 + 8 * v11);
        if (!v15)
        {
          int64_t v11 = v14 + 3;
          if (v14 + 3 >= v9) {
            goto LABEL_25;
          }
          unint64_t v15 = *(void *)(v5 + 8 * v11);
          if (!v15)
          {
            int64_t v11 = v14 + 4;
            if (v14 + 4 >= v9) {
              goto LABEL_25;
            }
            unint64_t v15 = *(void *)(v5 + 8 * v11);
            if (!v15) {
              break;
            }
          }
        }
      }
    }
LABEL_24:
    unint64_t v8 = (v15 - 1) & v15;
    unint64_t v13 = __clz(__rbit64(v15)) + (v11 << 6);
LABEL_5:
    id result = [*(id *)(*(void *)(v4 + 56) + 8 * v13) cancelAndUninstallAllCoordinators];
  }
  int64_t v16 = v14 + 5;
  if (v16 >= v9)
  {
LABEL_25:
    swift_release();
    swift_bridgeObjectRelease();
    *uint64_t v3 = sub_1000495B4((uint64_t)_swiftEmptyArrayStorage);
    swift_bridgeObjectRelease();
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v1 + 16));
    return (id)swift_release();
  }
  unint64_t v15 = *(void *)(v5 + 8 * v16);
  if (v15)
  {
    int64_t v11 = v16;
    goto LABEL_24;
  }
  while (1)
  {
    int64_t v11 = v16 + 1;
    if (__OFADD__(v16, 1)) {
      break;
    }
    if (v11 >= v9) {
      goto LABEL_25;
    }
    unint64_t v15 = *(void *)(v5 + 8 * v11);
    ++v16;
    if (v15) {
      goto LABEL_24;
    }
  }
LABEL_27:
  __break(1u);
  return result;
}

uint64_t sub_100042FA8(void *a1)
{
  id v2 = [a1 persona];
  id v3 = [v2 personaIdentifier];

  uint64_t v4 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  unint64_t v6 = v5;

  uint64_t v7 = *(void *)(v1 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock);
  unint64_t v8 = *(os_unfair_lock_s **)(v7 + 16);
  swift_retain();
  os_unfair_lock_lock(v8);
  sub_100043170(v1, v4, v6);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v7 + 16));
  swift_bridgeObjectRelease();
  return swift_release();
}

uint64_t sub_10004307C(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = *(void *)(v2 + OBJC_IVAR____TtC7backupd20AppRestoreDispatcher_lock);
  unint64_t v6 = *(os_unfair_lock_s **)(v5 + 16);
  swift_retain();
  os_unfair_lock_lock(v6);
  sub_100043170(v2, a1, a2);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v5 + 16));
  return swift_release();
}

void sub_100043170(uint64_t a1, uint64_t a2, unint64_t a3)
{
  swift_beginAccess();
  uint64_t v5 = (void *)sub_1000436E0(a2, a3);
  swift_endAccess();
  if (v5)
  {
    [v5 cancelAndUninstallAllCoordinators];
  }
  else
  {
    if (qword_10047CB30 != -1) {
      swift_once();
    }
    uint64_t v6 = type metadata accessor for Logger();
    sub_10000CC8C(v6, (uint64_t)qword_10047F400);
    swift_bridgeObjectRetain_n();
    uint64_t v7 = Logger.logObject.getter();
    os_log_type_t v8 = static os_log_type_t.error.getter();
    if (os_log_type_enabled(v7, v8))
    {
      int64_t v9 = (uint8_t *)swift_slowAlloc();
      v10[0] = swift_slowAlloc();
      *(_DWORD *)int64_t v9 = 136315138;
      swift_bridgeObjectRetain();
      v10[4] = sub_100046E00(a2, a3, v10);
      UnsafeMutableRawBufferPointer.copyMemory(from:)();
      swift_bridgeObjectRelease_n();
      _os_log_impl((void *)&_mh_execute_header, v7, v8, "Failed find and cancel the restorer for %s", v9, 0xCu);
      swift_arrayDestroy();
      swift_slowDealloc();
      swift_slowDealloc();
    }
    else
    {

      swift_bridgeObjectRelease_n();
    }
  }
}

Class sub_100043408(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3)
  {
    swift_bridgeObjectRetain();
    sub_100006FC8(&qword_10047DFB0);
    v3.super.Class isa = Array._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
  }
  else
  {
    v3.super.Class isa = 0;
  }
  return v3.super.isa;
}

uint64_t sub_100043480(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    sub_100006FC8(&qword_10047DFB0);
    uint64_t v5 = static Array._unconditionallyBridgeFromObjectiveC(_:)();
  }
  else
  {
    uint64_t v5 = 0;
  }
  *a4 = v5;
  return swift_bridgeObjectRelease();
}

uint64_t sub_1000434E4(uint64_t a1, void *a2)
{
  NSArray v3 = *(uint64_t (**)(void))(a1 + 32);
  swift_retain();
  id v4 = a2;
  LOBYTE(v3) = v3();
  swift_release();

  return v3 & 1;
}

uint64_t sub_100043554(void *a1, uint64_t a2)
{
  if (swift_dynamicCastObjCProtocolConditional())
  {
    swift_beginAccess();
    id v4 = a1;
    specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
    if (*(void *)((*(void *)(a2 + 16) & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((*(void *)(a2 + 16) & 0xFFFFFFFFFFFFFF8)
                                                                                       + 0x18) >> 1)
      specialized Array._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    specialized Array._appendElementAssumeUniqueAndCapacity(_:newElement:)();
    specialized Array._endMutation()();
    swift_endAccess();
  }
  return 1;
}

Class sub_100043628(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void))
{
  a4();
  sub_100006FC8(&qword_10047DFB0);
  v4.super.Class isa = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  return v4.super.isa;
}

uint64_t sub_1000436E0(uint64_t a1, uint64_t a2)
{
  NSArray v3 = v2;
  swift_bridgeObjectRetain();
  unint64_t v6 = sub_100031554(a1, a2);
  LOBYTE(a2) = v7;
  swift_bridgeObjectRelease();
  if ((a2 & 1) == 0) {
    return 0;
  }
  int isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v9 = *v3;
  uint64_t v12 = *v3;
  *NSArray v3 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    sub_100033880();
    uint64_t v9 = v12;
  }
  swift_bridgeObjectRelease();
  uint64_t v10 = *(void *)(*(void *)(v9 + 56) + 8 * v6);
  sub_100043A70(v6, v9);
  *NSArray v3 = v9;
  swift_bridgeObjectRelease();
  return v10;
}

unint64_t sub_1000437B0(int64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UUID();
  uint64_t v5 = *(void *)(v4 - 8);
  unint64_t result = __chkstk_darwin(v4);
  os_log_type_t v8 = (char *)&v34 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v10 = (a1 + 1) & ~v9;
  if (((1 << v10) & *(void *)(a2 + 64 + 8 * (v10 >> 6))) != 0)
  {
    uint64_t v11 = ~v9;
    uint64_t v37 = a2 + 64;
    unint64_t result = _HashTable.previousHole(before:)();
    uint64_t v12 = v37;
    if ((*(void *)(v37 + 8 * (v10 >> 6)) & (1 << v10)) != 0)
    {
      unint64_t v35 = (result + 1) & v11;
      int64_t v14 = *(void (**)(char *, unint64_t, uint64_t))(v5 + 16);
      uint64_t v13 = v5 + 16;
      unint64_t v34 = v14;
      uint64_t v15 = *(void *)(v13 + 56);
      uint64_t v36 = v13;
      int64_t v16 = (uint64_t (**)(char *, uint64_t))(v13 - 8);
      do
      {
        int64_t v17 = v15 * v10;
        v34(v8, *(void *)(a2 + 48) + v15 * v10, v4);
        sub_1000445D8();
        uint64_t v18 = dispatch thunk of Hashable._rawHashValue(seed:)();
        unint64_t result = (*v16)(v8, v4);
        unint64_t v19 = v18 & v11;
        if (a1 >= (uint64_t)v35)
        {
          if (v19 >= v35 && a1 >= (uint64_t)v19)
          {
LABEL_17:
            uint64_t v22 = *(void *)(a2 + 48);
            unint64_t result = v22 + v15 * a1;
            unint64_t v23 = v22 + v17 + v15;
            if (v15 * a1 < v17 || result >= v23)
            {
              unint64_t result = swift_arrayInitWithTakeFrontToBack();
            }
            else if (v15 * a1 != v17)
            {
              unint64_t result = swift_arrayInitWithTakeBackToFront();
            }
            uint64_t v25 = *(void *)(a2 + 56);
            uint64_t v26 = (void *)(v25 + 8 * a1);
            id v27 = (void *)(v25 + 8 * v10);
            uint64_t v12 = v37;
            if (a1 != v10 || (a1 = v10, v26 >= v27 + 1))
            {
              void *v26 = *v27;
              a1 = v10;
            }
            goto LABEL_5;
          }
        }
        else if (v19 >= v35 || a1 >= (uint64_t)v19)
        {
          goto LABEL_17;
        }
        uint64_t v12 = v37;
LABEL_5:
        unint64_t v10 = (v10 + 1) & v11;
      }
      while (((*(void *)(v12 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10) & 1) != 0);
    }
    uint64_t v28 = (uint64_t *)(v12 + 8 * ((unint64_t)a1 >> 6));
    uint64_t v29 = *v28;
    uint64_t v30 = (-1 << a1) - 1;
  }
  else
  {
    uint64_t v28 = (uint64_t *)(a2 + 64 + 8 * ((unint64_t)a1 >> 6));
    uint64_t v30 = *v28;
    uint64_t v29 = (-1 << a1) - 1;
  }
  *uint64_t v28 = v30 & v29;
  uint64_t v31 = *(void *)(a2 + 16);
  BOOL v32 = __OFSUB__(v31, 1);
  uint64_t v33 = v31 - 1;
  if (v32)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v33;
    ++*(_DWORD *)(a2 + 36);
  }
  return result;
}

unint64_t sub_100043A70(unint64_t result, uint64_t a2)
{
  int64_t v3 = result;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    unint64_t result = _HashTable.previousHole(before:)();
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (result + 1) & v7;
      do
      {
        Hasher.init(_seed:)();
        swift_bridgeObjectRetain();
        String.hash(into:)();
        Swift::Int v9 = Hasher._finalize()();
        unint64_t result = swift_bridgeObjectRelease();
        unint64_t v10 = v9 & v7;
        if (v3 >= (uint64_t)v8)
        {
          if (v10 < v8) {
            goto LABEL_5;
          }
        }
        else if (v10 >= v8)
        {
          goto LABEL_11;
        }
        if (v3 >= (uint64_t)v10)
        {
LABEL_11:
          uint64_t v11 = *(void *)(a2 + 48);
          uint64_t v12 = (_OWORD *)(v11 + 16 * v3);
          uint64_t v13 = (_OWORD *)(v11 + 16 * v6);
          if (v3 != v6 || v12 >= v13 + 1) {
            *uint64_t v12 = *v13;
          }
          uint64_t v14 = *(void *)(a2 + 56);
          uint64_t v15 = (void *)(v14 + 8 * v3);
          int64_t v16 = (void *)(v14 + 8 * v6);
          if (v3 != v6 || (int64_t v3 = v6, v15 >= v16 + 1))
          {
            *uint64_t v15 = *v16;
            int64_t v3 = v6;
          }
        }
LABEL_5:
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    int64_t v17 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    uint64_t v18 = *v17;
    uint64_t v19 = (-1 << v3) - 1;
  }
  else
  {
    int64_t v17 = (uint64_t *)(v4 + 8 * (result >> 6));
    uint64_t v19 = *v17;
    uint64_t v18 = (-1 << result) - 1;
  }
  uint64_t *v17 = v19 & v18;
  uint64_t v20 = *(void *)(a2 + 16);
  BOOL v21 = __OFSUB__(v20, 1);
  uint64_t v22 = v20 - 1;
  if (v21)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v22;
    ++*(_DWORD *)(a2 + 36);
  }
  return result;
}

void sub_100043C48(unint64_t a1)
{
  unint64_t v2 = a1 >> 62;
  if (a1 >> 62)
  {
    swift_bridgeObjectRetain();
    uint64_t v6 = _CocoaArrayWrapper.endIndex.getter();
    swift_bridgeObjectRelease();
    if (v6)
    {
LABEL_3:
      sub_100006FC8(&qword_10047DFD8);
      int64_t v3 = (void *)static _SetStorage.allocate(capacity:)();
      uint64_t v4 = a1 & 0xFFFFFFFFFFFFFF8;
      if (!v2) {
        goto LABEL_4;
      }
LABEL_8:
      swift_bridgeObjectRetain();
      uint64_t v5 = _CocoaArrayWrapper.endIndex.getter();
      swift_bridgeObjectRelease();
      if (!v5) {
        return;
      }
      goto LABEL_9;
    }
  }
  else if (*(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10))
  {
    goto LABEL_3;
  }
  int64_t v3 = &_swiftEmptySetSingleton;
  uint64_t v4 = a1 & 0xFFFFFFFFFFFFFF8;
  if (v2) {
    goto LABEL_8;
  }
LABEL_4:
  uint64_t v5 = *(void *)(v4 + 16);
  if (!v5) {
    return;
  }
LABEL_9:
  uint64_t v7 = (char *)(v3 + 7);
  uint64_t v43 = v5;
  if ((a1 & 0xC000000000000001) != 0)
  {
    uint64_t v8 = 0;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = specialized _ArrayBuffer._getElementSlowPath(_:)();
        BOOL v10 = __OFADD__(v8++, 1);
        if (v10)
        {
          __break(1u);
          goto LABEL_36;
        }
        uint64_t v11 = v9;
        Swift::Int v12 = NSObject._rawHashValue(seed:)(v3[5]);
        uint64_t v13 = -1 << *((unsigned char *)v3 + 32);
        unint64_t v14 = v12 & ~v13;
        unint64_t v15 = v14 >> 6;
        uint64_t v16 = *(void *)&v7[8 * (v14 >> 6)];
        uint64_t v17 = 1 << v14;
        if (((1 << v14) & v16) != 0) {
          break;
        }
LABEL_20:
        *(void *)&v7[8 * v15] = v17 | v16;
        *(void *)(v3[6] + 8 * v14) = v11;
        uint64_t v23 = v3[2];
        BOOL v10 = __OFADD__(v23, 1);
        uint64_t v24 = v23 + 1;
        if (v10) {
          goto LABEL_37;
        }
        v3[2] = v24;
        if (v8 == v5) {
          return;
        }
      }
      sub_10001C0F4(0, (unint64_t *)&qword_10047D900);
      id v18 = *(id *)(v3[6] + 8 * v14);
      char v19 = static NSObject.== infix(_:_:)();

      if ((v19 & 1) == 0)
      {
        uint64_t v20 = ~v13;
        while (1)
        {
          unint64_t v14 = (v14 + 1) & v20;
          unint64_t v15 = v14 >> 6;
          uint64_t v16 = *(void *)&v7[8 * (v14 >> 6)];
          uint64_t v17 = 1 << v14;
          if ((v16 & (1 << v14)) == 0) {
            break;
          }
          id v21 = *(id *)(v3[6] + 8 * v14);
          char v22 = static NSObject.== infix(_:_:)();

          if (v22) {
            goto LABEL_11;
          }
        }
        uint64_t v5 = v43;
        goto LABEL_20;
      }
LABEL_11:
      swift_unknownObjectRelease();
      uint64_t v5 = v43;
      if (v8 == v43) {
        return;
      }
    }
  }
  uint64_t v25 = 0;
  unint64_t v41 = a1 + 32;
  uint64_t v42 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  while (v25 != v42)
  {
    Swift::Int v26 = v3[5];
    id v27 = *(id *)(v41 + 8 * v25);
    Swift::Int v28 = NSObject._rawHashValue(seed:)(v26);
    uint64_t v29 = -1 << *((unsigned char *)v3 + 32);
    unint64_t v30 = v28 & ~v29;
    unint64_t v31 = v30 >> 6;
    uint64_t v32 = *(void *)&v7[8 * (v30 >> 6)];
    uint64_t v33 = 1 << v30;
    if (((1 << v30) & v32) != 0)
    {
      sub_10001C0F4(0, (unint64_t *)&qword_10047D900);
      id v34 = *(id *)(v3[6] + 8 * v30);
      char v35 = static NSObject.== infix(_:_:)();

      if (v35)
      {
LABEL_24:

        goto LABEL_25;
      }
      uint64_t v36 = ~v29;
      while (1)
      {
        unint64_t v30 = (v30 + 1) & v36;
        unint64_t v31 = v30 >> 6;
        uint64_t v32 = *(void *)&v7[8 * (v30 >> 6)];
        uint64_t v33 = 1 << v30;
        if ((v32 & (1 << v30)) == 0) {
          break;
        }
        id v37 = *(id *)(v3[6] + 8 * v30);
        char v38 = static NSObject.== infix(_:_:)();

        if (v38) {
          goto LABEL_24;
        }
      }
    }
    *(void *)&v7[8 * v31] = v33 | v32;
    *(void *)(v3[6] + 8 * v30) = v27;
    uint64_t v39 = v3[2];
    BOOL v10 = __OFADD__(v39, 1);
    uint64_t v40 = v39 + 1;
    if (v10) {
      goto LABEL_38;
    }
    v3[2] = v40;
LABEL_25:
    if (++v25 == v43) {
      return;
    }
  }
LABEL_36:
  __break(1u);
LABEL_37:
  __break(1u);
LABEL_38:
  __break(1u);
}

void sub_100043FA4(uint64_t a1)
{
  int64_t v2 = 0;
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v16 = a1 + 64;
  uint64_t v4 = 1 << *(unsigned char *)(a1 + 32);
  uint64_t v5 = -1;
  if (v4 < 64) {
    uint64_t v5 = ~(-1 << v4);
  }
  unint64_t v6 = v5 & v3;
  int64_t v7 = (unint64_t)(v4 + 63) >> 6;
  if ((v5 & v3) != 0) {
    goto LABEL_6;
  }
LABEL_7:
  int64_t v10 = v2 + 1;
  if (!__OFADD__(v2, 1))
  {
    if (v10 < v7)
    {
      unint64_t v11 = *(void *)(v16 + 8 * v10);
      ++v2;
      if (v11) {
        goto LABEL_22;
      }
      int64_t v2 = v10 + 1;
      if (v10 + 1 >= v7) {
        goto LABEL_26;
      }
      unint64_t v11 = *(void *)(v16 + 8 * v2);
      if (v11) {
        goto LABEL_22;
      }
      int64_t v2 = v10 + 2;
      if (v10 + 2 >= v7) {
        goto LABEL_26;
      }
      unint64_t v11 = *(void *)(v16 + 8 * v2);
      if (v11) {
        goto LABEL_22;
      }
      int64_t v2 = v10 + 3;
      if (v10 + 3 >= v7) {
        goto LABEL_26;
      }
      unint64_t v11 = *(void *)(v16 + 8 * v2);
      if (v11)
      {
LABEL_22:
        unint64_t v6 = (v11 - 1) & v11;
        for (unint64_t i = __clz(__rbit64(v11)) + (v2 << 6); ; unint64_t i = v8 | (v2 << 6))
        {
          id v13 = *(id *)(*(void *)(a1 + 56) + 8 * i);
          NSString v14 = String._bridgeToObjectiveC()();
          unsigned int v15 = [v13 shouldObserveCoordinatorForBundleID:v14];

          if (v15)
          {
            specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
            specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
            specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
            specialized ContiguousArray._endMutation()();
            if (!v6) {
              goto LABEL_7;
            }
          }
          else
          {

            if (!v6) {
              goto LABEL_7;
            }
          }
LABEL_6:
          unint64_t v8 = __clz(__rbit64(v6));
          v6 &= v6 - 1;
        }
      }
      int64_t v12 = v10 + 4;
      if (v12 < v7)
      {
        unint64_t v11 = *(void *)(v16 + 8 * v12);
        if (v11)
        {
          int64_t v2 = v12;
          goto LABEL_22;
        }
        while (1)
        {
          int64_t v2 = v12 + 1;
          if (__OFADD__(v12, 1)) {
            goto LABEL_28;
          }
          if (v2 >= v7) {
            break;
          }
          unint64_t v11 = *(void *)(v16 + 8 * v2);
          ++v12;
          if (v11) {
            goto LABEL_22;
          }
        }
      }
    }
LABEL_26:
    swift_release();
    return;
  }
  __break(1u);
LABEL_28:
  __break(1u);
}

uint64_t sub_1000441B0()
{
  if (qword_10047F3F0)
  {
    uint64_t v0 = qword_10047F3F0;
    swift_bridgeObjectRetain();
  }
  else
  {
    uint64_t v1 = (void *)swift_allocObject();
    v1[2] = _swiftEmptyArrayStorage;
    uint64_t v0 = (uint64_t)(v1 + 2);
    sub_10001C0F4(0, &qword_10047DFC0);
    ObjCClassFromMetadata = (void *)swift_getObjCClassFromMetadata();
    aBlock[4] = sub_100044580;
    aBlock[5] = v1;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = (id)1107296256;
    aBlock[2] = sub_1000434E4;
    aBlock[3] = &unk_100410A68;
    uint64_t v3 = _Block_copy(aBlock);
    swift_retain();
    swift_release();
    aBlock[0] = 0;
    unsigned int v4 = [ObjCClassFromMetadata enumerateCoordinatorsWithError:aBlock usingBlock:v3];
    _Block_release(v3);
    id v5 = aBlock[0];
    if (v4)
    {
      swift_beginAccess();
      uint64_t v0 = v1[2];
      swift_bridgeObjectRetain();
      swift_release();
      swift_bridgeObjectRetain();
    }
    else
    {
      unint64_t v6 = v5;
      _convertNSErrorToError(_:)();

      swift_willThrow();
      swift_release();
    }
  }
  return v0;
}

uint64_t sub_10004437C()
{
  if (qword_10047F3F8)
  {
    uint64_t v0 = qword_10047F3F8;
    swift_bridgeObjectRetain();
  }
  else
  {
    uint64_t v1 = (void *)swift_allocObject();
    v1[2] = _swiftEmptyArrayStorage;
    uint64_t v0 = (uint64_t)(v1 + 2);
    sub_10001C0F4(0, &qword_10047DFB8);
    ObjCClassFromMetadata = (void *)swift_getObjCClassFromMetadata();
    aBlock[4] = sub_100044580;
    aBlock[5] = v1;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = (id)1107296256;
    aBlock[2] = sub_1000434E4;
    aBlock[3] = &unk_100410A40;
    uint64_t v3 = _Block_copy(aBlock);
    swift_retain();
    swift_release();
    aBlock[0] = 0;
    unsigned int v4 = [ObjCClassFromMetadata enumerateCoordinatorsWithError:aBlock usingBlock:v3];
    _Block_release(v3);
    id v5 = aBlock[0];
    if (v4)
    {
      swift_beginAccess();
      uint64_t v0 = v1[2];
      swift_bridgeObjectRetain();
      swift_release();
      swift_bridgeObjectRetain();
    }
    else
    {
      unint64_t v6 = v5;
      _convertNSErrorToError(_:)();

      swift_willThrow();
      swift_release();
    }
  }
  return v0;
}

uint64_t sub_100044548()
{
  swift_bridgeObjectRelease();
  return _swift_deallocObject(v0, 24, 7);
}

uint64_t sub_100044580(void *a1)
{
  return sub_100043554(a1, v1) & 1;
}

uint64_t sub_1000445A0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1000445B0()
{
  return swift_release();
}

void sub_1000445B8(id a1)
{
  if (a1 != (id)1) {
}
  }

id sub_1000445C8(id result)
{
  if (result != (id)1) {
    return result;
  }
  return result;
}

unint64_t sub_1000445D8()
{
  unint64_t result = qword_10047D400;
  if (!qword_10047D400)
  {
    type metadata accessor for UUID();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047D400);
  }
  return result;
}

uint64_t sub_100044638(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = type metadata accessor for URL();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  int64_t v7 = (char *)&v11 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (qword_10047CB28 != -1) {
    swift_once();
  }
  uint64_t v8 = sub_10000CC8C(v4, (uint64_t)qword_10047DFE0);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v7, v8, v4);
  uint64_t v11 = 0;
  unint64_t v12 = 0xE000000000000000;
  _StringGuts.grow(_:)(22);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v11 = a1;
  unint64_t v12 = a2;
  v9._object = (void *)0x80000001003077B0;
  v9._countAndFlagsBits = 0xD000000000000014;
  String.append(_:)(v9);
  URL.appendingPathComponent(_:)();
  swift_bridgeObjectRelease();
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

uint64_t sub_1000447D8()
{
  uint64_t v0 = type metadata accessor for URL();
  sub_100045B94(v0, qword_10047DFE0);
  sub_10000CC8C(v0, (uint64_t)qword_10047DFE0);
  return URL.init(fileURLWithPath:isDirectory:)();
}

uint64_t sub_100044A80(Swift::Int a1, Swift::Int a2)
{
  uint64_t v5 = *(void *)(v2 + OBJC_IVAR____TtC7backupd13MigratorCache_lock);
  uint64_t v6 = *(os_unfair_lock_s **)(v5 + 16);
  swift_retain();
  os_unfair_lock_lock(v6);
  swift_beginAccess();
  swift_bridgeObjectRetain();
  sub_10001324C(&v8, a1, a2);
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v5 + 16));
  swift_release();
  return swift_bridgeObjectRelease();
}

Swift::Int sub_100044C48()
{
  return Hasher._finalize()();
}

uint64_t sub_100044CA0()
{
  return String.hash(into:)();
}

Swift::Int sub_100044CBC()
{
  return Hasher._finalize()();
}

uint64_t sub_100044D10@<X0>(Swift::String *a1@<X0>, BOOL *a2@<X8>)
{
  Swift::Int v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_10040F140, *a1);
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v3 != 0;
  return result;
}

void sub_100044D64(void *a1@<X8>)
{
  *a1 = 0x4449656C646E7562;
  a1[1] = 0xE900000000000073;
}

uint64_t sub_100044D84()
{
  return 0x4449656C646E7562;
}

uint64_t sub_100044DA0@<X0>(Swift::String string@<0:X0, 8:X1>, BOOL *a2@<X8>)
{
  object = string._object;
  v3._countAndFlagsBits = string._countAndFlagsBits;
  v3._object = object;
  Swift::Int v5 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_10040F178, v3);
  uint64_t result = swift_bridgeObjectRelease();
  *a2 = v5 != 0;
  return result;
}

uint64_t sub_100044DF8(uint64_t a1)
{
  unint64_t v2 = sub_100045A9C();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_100044E34(uint64_t a1)
{
  unint64_t v2 = sub_100045A9C();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_100044E70(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_100006FC8(&qword_10047E050);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  int64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_10000700C(a1, a1[3]);
  sub_100045A9C();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  Swift::Int v8 = (uint64_t *)(v2 + OBJC_IVAR____TtC7backupd13MigratorCache_bundleIDs);
  swift_beginAccess();
  uint64_t v10 = *v8;
  sub_100006FC8(&qword_10047E040);
  sub_100045AF0(&qword_10047E058);
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

id sub_100045008(void *a1)
{
  uint64_t v2 = v1;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v4 = sub_100006FC8(&qword_10047E030);
  uint64_t v18 = *(void *)(v4 - 8);
  uint64_t v19 = v4;
  __chkstk_darwin(v4);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = OBJC_IVAR____TtC7backupd13MigratorCache_lock;
  type metadata accessor for MBUnfairLock();
  uint64_t v8 = swift_allocObject();
  Swift::String v9 = v2;
  uint64_t v10 = (_DWORD *)swift_slowAlloc();
  *(void *)(v8 + 16) = v10;
  _DWORD *v10 = 0;
  *(void *)&v2[v7] = v8;
  uint64_t v11 = (id *)&v9[OBJC_IVAR____TtC7backupd13MigratorCache_bundleIDs];
  *(void *)&v9[OBJC_IVAR____TtC7backupd13MigratorCache_bundleIDs] = &_swiftEmptySetSingleton;
  sub_10000700C(a1, a1[3]);
  sub_100045A9C();
  uint64_t v12 = v20;
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (v12)
  {
    sub_1000070A4((uint64_t)a1);
    swift_release();
    id v14 = *v11;

    swift_bridgeObjectRelease();
    swift_deallocPartialClassInstance();
  }
  else
  {
    uint64_t v20 = v7;
    sub_100006FC8(&qword_10047E040);
    sub_100045AF0(&qword_10047E048);
    uint64_t v13 = v19;
    KeyedDecodingContainer.decode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v18 + 8))(v6, v13);
    uint64_t v16 = v23;
    swift_beginAccess();
    id *v11 = v16;

    swift_bridgeObjectRelease();
    v22.receiver = v9;
    v22.super_class = ObjectType;
    id v14 = objc_msgSendSuper2(&v22, "init");
    sub_1000070A4((uint64_t)a1);
  }
  return v14;
}

id sub_100045494(uint64_t a1)
{
  Swift::String v3 = v1;
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v6 = OBJC_IVAR____TtC7backupd13MigratorCache_lock;
  type metadata accessor for MBUnfairLock();
  uint64_t v7 = swift_allocObject();
  uint64_t v8 = v3;
  Swift::String v9 = (_DWORD *)swift_slowAlloc();
  *(void *)(v7 + 16) = v9;
  *Swift::String v9 = 0;
  *(void *)&v3[v6] = v7;
  objc_super v22 = (id *)&v8[OBJC_IVAR____TtC7backupd13MigratorCache_bundleIDs];
  *(void *)&v8[OBJC_IVAR____TtC7backupd13MigratorCache_bundleIDs] = &_swiftEmptySetSingleton;
  uint64_t v27 = a1;
  uint64_t v10 = Data.init(contentsOf:options:)();
  unint64_t v12 = v11;
  if (v2)
  {
    uint64_t v25 = 0;
    unint64_t v26 = 0xE000000000000000;
    _StringGuts.grow(_:)(27);
    v13._object = (void *)0x8000000100307A80;
    v13._countAndFlagsBits = 0xD000000000000015;
    String.append(_:)(v13);
    v14._countAndFlagsBits = URL.path.getter();
    String.append(_:)(v14);
    swift_bridgeObjectRelease();
    v15._countAndFlagsBits = 8250;
    v15._object = (void *)0xE200000000000000;
    String.append(_:)(v15);
    uint64_t v24 = v2;
    sub_100006FC8(&qword_10047D0A0);
    _print_unlocked<A, B>(_:_:)();
    NSLog(_:_:)();
    swift_bridgeObjectRelease();
    swift_willThrow();
    uint64_t v16 = type metadata accessor for URL();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v16 - 8) + 8))(v27, v16);
    swift_release();
    id v20 = *v22;

    swift_bridgeObjectRelease();
    swift_deallocPartialClassInstance();
  }
  else
  {
    type metadata accessor for PropertyListDecoder();
    swift_allocObject();
    sub_100029128(v10, v12);
    PropertyListDecoder.init()();
    sub_100045B54(&qword_10047E060);
    dispatch thunk of PropertyListDecoder.decode<A>(_:from:)();
    sub_10000C6C0(v10, v12);
    sub_10000C6C0(v10, v12);
    swift_release();
    uint64_t v18 = &v25[OBJC_IVAR____TtC7backupd13MigratorCache_bundleIDs];
    swift_beginAccess();
    uint64_t v19 = *(void **)v18;
    swift_bridgeObjectRetain();

    swift_beginAccess();
    *objc_super v22 = v19;

    swift_bridgeObjectRelease();
    v23.receiver = v8;
    v23.super_class = ObjectType;
    id v20 = objc_msgSendSuper2(&v23, "init");
    uint64_t v21 = type metadata accessor for URL();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v21 - 8) + 8))(v27, v21);
  }
  return v20;
}

uint64_t type metadata accessor for MigratorCache()
{
  return self;
}

id sub_10004596C@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  id v6 = objc_allocWithZone(v2);
  id result = sub_100045008(a1);
  if (!v3) {
    *a2 = result;
  }
  return result;
}

uint64_t sub_1000459BC(void *a1)
{
  return sub_100044E70(a1);
}

unint64_t sub_100045A9C()
{
  unint64_t result = qword_10047E038;
  if (!qword_10047E038)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E038);
  }
  return result;
}

uint64_t sub_100045AF0(unint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    sub_10000BAC4(&qword_10047E040);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_100045B54(unint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    type metadata accessor for MigratorCache();
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t *sub_100045B94(uint64_t a1, uint64_t *a2)
{
  if ((*(_DWORD *)(*(void *)(a1 - 8) + 80) & 0x20000) != 0)
  {
    uint64_t v3 = swift_slowAlloc();
    *a2 = v3;
    return (uint64_t *)v3;
  }
  return a2;
}

unsigned char *storeEnumTagSinglePayload for MigratorCache.CodingKeys(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *uint64_t result = a2;
        return result;
      case 2:
        *(_WORD *)uint64_t result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)uint64_t result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *uint64_t result = 0;
      break;
    case 2:
      *(_WORD *)uint64_t result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x100045C94);
    case 4:
      *(_DWORD *)uint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

ValueMetadata *type metadata accessor for MigratorCache.CodingKeys()
{
  return &type metadata for MigratorCache.CodingKeys;
}

unint64_t sub_100045CD0()
{
  unint64_t result = qword_10047E070;
  if (!qword_10047E070)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E070);
  }
  return result;
}

unint64_t sub_100045D28()
{
  unint64_t result = qword_10047E078;
  if (!qword_10047E078)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E078);
  }
  return result;
}

unint64_t sub_100045D80()
{
  unint64_t result = qword_10047E080;
  if (!qword_10047E080)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E080);
  }
  return result;
}

void *initializeBufferWithCopyOfBuffer for MBLogger(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t destroy for MBLogger()
{
  return swift_bridgeObjectRelease();
}

void *assignWithCopy for MBLogger(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

void *assignWithTake for MBLogger(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for MBLogger(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for MBLogger(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)unint64_t result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBLogger()
{
  return &type metadata for MBLogger;
}

void sub_100045F18(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
}

id sub_100045F30(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  if (qword_10047CB30 != -1) {
    swift_once();
  }
  uint64_t v10 = type metadata accessor for Logger();
  sub_10000CC8C(v10, (uint64_t)qword_10047F400);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_errorRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_errorRetain();
  unint64_t v11 = Logger.logObject.getter();
  os_log_type_t v12 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v11, v12))
  {
    uint64_t v13 = swift_slowAlloc();
    Swift::String v14 = (void *)swift_slowAlloc();
    uint64_t v23 = swift_slowAlloc();
    *(_DWORD *)uint64_t v13 = 136315650;
    swift_bridgeObjectRetain();
    sub_100046E00(a5, a6, &v23);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v13 + 12) = 2080;
    swift_bridgeObjectRetain();
    sub_100046E00(a3, a4, &v23);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v13 + 22) = 2112;
    swift_errorRetain();
    uint64_t v22 = _swift_stdlib_bridgeErrorToNSError();
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    *Swift::String v14 = v22;
    swift_errorRelease();
    swift_errorRelease();
    _os_log_impl((void *)&_mh_execute_header, v11, v12, "%s%s: %@", (uint8_t *)v13, 0x20u);
    sub_100006FC8(&qword_10047DFC8);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease_n();
    swift_errorRelease();
    swift_errorRelease();
  }

  Swift::String v15 = (void *)_convertErrorToNSError(_:)();
  if ((~a2 & 0xF000000000000007) != 0)
  {
    sub_10002D270(a2);
    NSString v16 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
  }
  else
  {
    NSString v16 = 0;
  }
  uint64_t v17 = self;
  NSString v18 = String._bridgeToObjectiveC()();
  id v19 = [v17 errorForNSError:v15 path:v16 description:v18];

  return v19;
}

void sub_100046294(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
}

void sub_1000462AC(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
}

void sub_1000462C4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (qword_10047CB30 != -1) {
    swift_once();
  }
  uint64_t v9 = type metadata accessor for Logger();
  sub_10000CC8C(v9, (uint64_t)qword_10047F400);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_errorRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_errorRetain();
  oslog = Logger.logObject.getter();
  os_log_type_t v10 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(oslog, v10))
  {
    uint64_t v11 = swift_slowAlloc();
    os_log_type_t v12 = (void *)swift_slowAlloc();
    uint64_t v15 = swift_slowAlloc();
    *(_DWORD *)uint64_t v11 = 136315650;
    swift_bridgeObjectRetain();
    sub_100046E00(a4, a5, &v15);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v11 + 12) = 2080;
    swift_bridgeObjectRetain();
    sub_100046E00(a2, a3, &v15);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v11 + 22) = 2112;
    swift_errorRetain();
    uint64_t v14 = _swift_stdlib_bridgeErrorToNSError();
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    *os_log_type_t v12 = v14;
    swift_errorRelease();
    swift_errorRelease();
    _os_log_impl((void *)&_mh_execute_header, oslog, v10, "%s%s: %@", (uint8_t *)v11, 0x20u);
    sub_100006FC8(&qword_10047DFC8);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease_n();
    swift_errorRelease();
    swift_errorRelease();
  }
}

void sub_1000465BC(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
}

void sub_1000465D4(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t (*a5)(void))
{
  if (qword_10047CB30 != -1) {
    swift_once();
  }
  uint64_t v10 = type metadata accessor for Logger();
  sub_10000CC8C(v10, (uint64_t)qword_10047F400);
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRetain_n();
  uint64_t v11 = Logger.logObject.getter();
  os_log_type_t v12 = a5();
  if (os_log_type_enabled(v11, v12))
  {
    uint64_t v13 = swift_slowAlloc();
    uint64_t v14 = swift_slowAlloc();
    *(_DWORD *)uint64_t v13 = 136315394;
    swift_bridgeObjectRetain();
    sub_100046E00(a3, a4, &v14);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v13 + 12) = 2080;
    swift_bridgeObjectRetain();
    sub_100046E00(a1, a2, &v14);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    _os_log_impl((void *)&_mh_execute_header, v11, v12, "%s%s", (uint8_t *)v13, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease_n();
  }
}

id sub_1000467F0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (qword_10047CB30 != -1) {
    swift_once();
  }
  uint64_t v10 = type metadata accessor for Logger();
  sub_10000CC8C(v10, (uint64_t)qword_10047F400);
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRetain_n();
  uint64_t v11 = Logger.logObject.getter();
  os_log_type_t v12 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v11, v12))
  {
    uint64_t v13 = swift_slowAlloc();
    uint64_t v18 = swift_slowAlloc();
    *(_DWORD *)uint64_t v13 = 136315394;
    swift_bridgeObjectRetain();
    sub_100046E00(a4, a5, &v18);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v13 + 12) = 2080;
    swift_bridgeObjectRetain();
    sub_100046E00(a2, a3, &v18);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    _os_log_impl((void *)&_mh_execute_header, v11, v12, "%s%s", (uint8_t *)v13, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease_n();
  }
  uint64_t v14 = self;
  NSString v15 = String._bridgeToObjectiveC()();
  id v16 = [v14 errorWithCode:a1 description:v15];

  return v16;
}

id sub_100046A54(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  if (qword_10047CB30 != -1) {
    swift_once();
  }
  uint64_t v11 = type metadata accessor for Logger();
  sub_10000CC8C(v11, (uint64_t)qword_10047F400);
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRetain_n();
  os_log_type_t v12 = Logger.logObject.getter();
  os_log_type_t v13 = static os_log_type_t.fault.getter();
  if (os_log_type_enabled(v12, v13))
  {
    uint64_t v14 = swift_slowAlloc();
    uint64_t v21 = swift_slowAlloc();
    *(_DWORD *)uint64_t v14 = 136315394;
    swift_bridgeObjectRetain();
    sub_100046E00(a5, a6, &v21);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    *(_WORD *)(v14 + 12) = 2080;
    swift_bridgeObjectRetain();
    sub_100046E00(a3, a4, &v21);
    UnsafeMutableRawBufferPointer.copyMemory(from:)();
    swift_bridgeObjectRelease_n();
    _os_log_impl((void *)&_mh_execute_header, v12, v13, "%s%s", (uint8_t *)v14, 0x16u);
    swift_arrayDestroy();
    swift_slowDealloc();
    swift_slowDealloc();
  }
  else
  {

    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease_n();
  }
  NSString v15 = self;
  if ((~a2 & 0xF000000000000007) != 0)
  {
    swift_retain();
    sub_10002D270(a2);
    NSString v18 = String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease();
    NSString v16 = String._bridgeToObjectiveC()();
    id v17 = [v15 errorWithCode:a1 path:v18 description:v16];
    sub_10001BFE4(a2);
  }
  else
  {
    NSString v16 = String._bridgeToObjectiveC()();
    id v17 = [v15 errorWithCode:a1 description:v16];
  }

  return v17;
}

id sub_100046D34()
{
  uint64_t v0 = type metadata accessor for Logger();
  sub_100045B94(v0, qword_10047F400);
  sub_10000CC8C(v0, (uint64_t)qword_10047F400);
  id result = (id)MBGetMBSwiftLog();
  if (result) {
    return (id)Logger.init(_:)();
  }
  __break(1u);
  return result;
}

void *sub_100046D98(uint64_t a1, uint64_t a2)
{
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  sub_100006FC8(&qword_10047E088);
  unsigned int v4 = (void *)swift_allocObject();
  size_t v5 = j__malloc_size(v4);
  v4[2] = a1;
  v4[3] = 2 * v5 - 64;
  return v4;
}

uint64_t sub_100046E00(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6 = sub_100046ED4(v12, 0, 0, 1, a1, a2);
  uint64_t v7 = v12[0];
  if (v6)
  {
    uint64_t v8 = v6;
    uint64_t ObjectType = (void *)swift_getObjectType();
    v12[0] = v8;
    uint64_t v9 = *a3;
    if (*a3)
    {
      sub_100018584((uint64_t)v12, *a3);
      *a3 = v9 + 32;
    }
  }
  else
  {
    uint64_t ObjectType = &type metadata for _StringGuts;
    v12[0] = a1;
    v12[1] = a2;
    uint64_t v10 = *a3;
    if (*a3)
    {
      sub_100018584((uint64_t)v12, *a3);
      *a3 = v10 + 32;
    }
    swift_bridgeObjectRetain();
  }
  sub_1000070A4((uint64_t)v12);
  return v7;
}

uint64_t sub_100046ED4(uint64_t *a1, char *__dst, uint64_t a3, char a4, uint64_t a5, unint64_t a6)
{
  if ((a6 & 0x2000000000000000) != 0)
  {
    if ((a4 & 1) == 0)
    {
      if (__dst)
      {
        uint64_t v11 = HIBYTE(a6) & 0xF;
        if (a3 - (uint64_t)__dst > v11)
        {
          __src[0] = a5;
          __src[1] = a6 & 0xFFFFFFFFFFFFFFLL;
          if (__src >= (void *)&__dst[v11] || (char *)__src + v11 <= __dst)
          {
            memcpy(__dst, __src, HIBYTE(a6) & 0xF);
            UnsafeMutableRawBufferPointer.subscript.setter();
            uint64_t result = 0;
            *a1 = (uint64_t)__dst;
            return result;
          }
          goto LABEL_17;
        }
      }
    }
LABEL_13:
    uint64_t result = sub_100047090(a5, a6);
    *a1 = v12;
    return result;
  }
  if ((a6 & 0x1000000000000000) != 0) {
    goto LABEL_13;
  }
  if ((a5 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (a6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    goto LABEL_5;
  }
  uint64_t v8 = _StringObject.sharedUTF8.getter();
  if (!v8)
  {
    _assertionFailure(_:_:file:line:flags:)();
    __break(1u);
LABEL_17:
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
    __break(1u);
    return result;
  }
LABEL_5:
  *a1 = v8;
  if ((a6 & 0x8000000000000000) != 0) {
    return 0;
  }
  else {
    return swift_unknownObjectRetain();
  }
}

uint64_t sub_100047090(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (uint64_t)sub_100047128(a1, a2);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v2 = sub_1000472A0(0, *(void *)(v2 + 16) + 1, 1, (char *)v2);
  }
  unint64_t v4 = *(void *)(v2 + 16);
  unint64_t v3 = *(void *)(v2 + 24);
  if (v4 >= v3 >> 1) {
    uint64_t v2 = sub_1000472A0(v3 > 1, v4 + 1, 1, (char *)v2);
  }
  *(void *)(v2 + 16) = v4 + 1;
  *(unsigned char *)(v2 + 32 + v4) = 0;
  return v2;
}

void *sub_100047128(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000) != 0) {
    goto LABEL_10;
  }
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    while (1)
    {
      unint64_t v3 = sub_100046D98(v2, 0);
      if (v2 < 0) {
        break;
      }
      unint64_t v4 = v3;
      uint64_t v5 = _StringGuts.copyUTF8(into:)();
      if (v6) {
        goto LABEL_14;
      }
      if (v5 == v2) {
        return v4;
      }
      _assertionFailure(_:_:file:line:flags:)();
      __break(1u);
LABEL_10:
      uint64_t v2 = String.UTF8View._foreignCount()();
      if (!v2) {
        return &_swiftEmptyArrayStorage;
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)();
    __break(1u);
LABEL_14:
    uint64_t result = (void *)_assertionFailure(_:_:file:line:flags:)();
    __break(1u);
  }
  else
  {
    return &_swiftEmptyArrayStorage;
  }
  return result;
}

uint64_t sub_1000472A0(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_30;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    sub_100006FC8(&qword_10047E088);
    uint64_t v10 = (char *)swift_allocObject();
    size_t v11 = j__malloc_size(v10);
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    uint64_t v10 = (char *)&_swiftEmptyArrayStorage;
  }
  uint64_t v12 = v10 + 32;
  os_log_type_t v13 = a4 + 32;
  if (a1)
  {
    if (v10 != a4 || v12 >= &v13[v8]) {
      memmove(v12, v13, v8);
    }
    *((void *)a4 + 2) = 0;
    goto LABEL_28;
  }
  if (v13 >= &v12[v8] || v12 >= &v13[v8])
  {
    memcpy(v12, v13, v8);
LABEL_28:
    swift_bridgeObjectRelease();
    return (uint64_t)v10;
  }
LABEL_30:
  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

void *sub_1000474E0(uint64_t a1)
{
  uint64_t v3 = type metadata accessor for OS_dispatch_queue.Attributes();
  __chkstk_darwin(v3);
  uint64_t v4 = type metadata accessor for OS_dispatch_queue.AutoreleaseFrequency();
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  int64_t v7 = (char *)v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for DispatchQoS();
  __chkstk_darwin(v8 - 8);
  v1[2] = 0xD000000000000026;
  v1[3] = 0x8000000100307DA0;
  sub_1000224B0();
  static DispatchQoS.utility.getter();
  (*(void (**)(char *, void, uint64_t))(v5 + 104))(v7, enum case for OS_dispatch_queue.AutoreleaseFrequency.workItem(_:), v4);
  v10[1] = &_swiftEmptyArrayStorage;
  sub_1000224F0();
  sub_100006FC8(&qword_10047D7A8);
  sub_100022548();
  dispatch thunk of SetAlgebra.init<A>(_:)();
  v1[4] = OS_dispatch_queue.init(label:qos:attributes:autoreleaseFrequency:target:)();
  v1[5] = a1;
  return v1;
}

void sub_1000476F8(uint64_t a1)
{
  _StringGuts.grow(_:)(50);
  v2._countAndFlagsBits = 0xD000000000000030;
  v2._object = (void *)0x8000000100307F00;
  String.append(_:)(v2);
  type metadata accessor for BGSystemTaskExpirationReason(0);
  _print_unlocked<A, B>(_:_:)();
  sub_100045F18(0, 0xE000000000000000, 0xD000000000000017, 0x8000000100307D60);
  swift_bridgeObjectRelease();
  if (a1 == 1) {
    uint64_t v3 = 2;
  }
  else {
    uint64_t v3 = 3;
  }
  sub_100055258(v3);
}

int *sub_100047894(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v4 = v3;
  double v8 = sub_1000484D4(a3);
  double v9 = COERCE_DOUBLE(sub_100047DF4(a3, a1, a2));
  if (v10)
  {
    _StringGuts.grow(_:)(49);
    swift_bridgeObjectRelease();
    id v21 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
    [v21 setUnitsStyle:0];
    id v22 = [v21 localizedStringFromTimeInterval:v8];

    uint64_t v23 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v25 = v24;

    v26._countAndFlagsBits = v23;
    v26._object = v25;
    String.append(_:)(v26);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD00000000000002FLL, 0x8000000100307DD0, 0xD000000000000017, 0x8000000100307D60);
    swift_bridgeObjectRelease();
    [v4 setScheduleAfter:v8];
    double v27 = v8 + 28800.0;
    Swift::Int v28 = &selRef_setTrySchedulingBefore_;
LABEL_8:
    uint64_t v29 = *v28;
    return (int *)objc_msgSend(v4, v29, v27);
  }
  if (v8 > v9) {
    double v8 = v9;
  }
  _StringGuts.grow(_:)(39);
  swift_bridgeObjectRelease();
  id v11 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
  [v11 setUnitsStyle:0];
  id v12 = [v11 localizedStringFromTimeInterval:v8];

  uint64_t v13 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  NSString v15 = v14;

  v16._countAndFlagsBits = v13;
  v16._object = v15;
  String.append(_:)(v16);
  swift_bridgeObjectRelease();
  sub_100045F18(0xD000000000000025, 0x8000000100307E00, 0xD000000000000017, 0x8000000100307D60);
  swift_bridgeObjectRelease();
  [v4 setScheduleAfter:v8];
  [v4 setTrySchedulingBefore:v8 + 28800.0];
  uint64_t result = (int *)type metadata accessor for MBDryRestoreState();
  uint64_t v18 = a3 + result[14];
  if ((*(unsigned char *)(v18 + 8) & 1) == 0)
  {
    id v19 = result;
    uint64_t v20 = a3 + result[13];
    if ((*(unsigned char *)(v20 + 8) & 1) == 0)
    {
      uint64_t v30 = *(void *)v18;
      double v31 = *(double *)v20;
      _StringGuts.grow(_:)(48);
      uint64_t result = (int *)swift_bridgeObjectRelease();
      if (v30 < 0)
      {
        __break(1u);
        return result;
      }
      id v32 = [self stringFromByteCount:v30 countStyle:3];
      uint64_t v33 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      char v35 = v34;

      v36._countAndFlagsBits = v33;
      v36._object = v35;
      String.append(_:)(v36);
      swift_bridgeObjectRelease();
      v37._countAndFlagsBits = 0x20646E6120;
      v37._object = (void *)0xE500000000000000;
      String.append(_:)(v37);
      id v38 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
      [v38 setUnitsStyle:0];
      id v39 = [v38 localizedStringFromTimeInterval:v31];

      uint64_t v40 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      uint64_t v42 = v41;

      v43._countAndFlagsBits = v40;
      v43._object = v42;
      String.append(_:)(v43);
      swift_bridgeObjectRelease();
      sub_100045F18(0xD000000000000027, 0x8000000100307E30, 0xD000000000000017, 0x8000000100307D60);
      swift_bridgeObjectRelease();
      [v4 setNetworkDownloadSize:v30];
      uint64_t v44 = a3 + v19[12];
      double v45 = *(double *)v44;
      if (*(unsigned char *)(v44 + 8)) {
        double v45 = 0.0;
      }
      double v27 = v31 - v45;
      Swift::Int v28 = &selRef_setExpectedDuration_;
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t sub_100047D88()
{
  swift_bridgeObjectRelease();

  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for MBDryRestoreActivity()
{
  return self;
}

uint64_t sub_100047DF4(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  unsigned int v4 = a3;
  uint64_t v5 = sub_100006FC8(&qword_10047D708);
  __chkstk_darwin(v5 - 8);
  int64_t v7 = (char *)v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for Date();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = __chkstk_darwin(v8);
  id v12 = (char *)v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = __chkstk_darwin(v10);
  NSString v15 = (char *)v26 - v14;
  uint64_t v16 = __chkstk_darwin(v13);
  uint64_t v18 = (char *)v26 - v17;
  __chkstk_darwin(v16);
  uint64_t v20 = (char *)v26 - v19;
  uint64_t result = 0;
  if (v4 <= 1)
  {
    v26[3] = v4;
    static Date.now.getter();
    Date.addingTimeInterval(_:)();
    id v22 = *(void (**)(char *, uint64_t))(v9 + 8);
    v22(v18, v8);
    uint64_t v23 = type metadata accessor for MBDryRestoreState();
    sub_100048E78(a1 + *(int *)(v23 + 40), (uint64_t)v7);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v9 + 48))(v7, 1, v8) == 1)
    {
      static Date.distantPast.getter();
      sub_10001E2A0((uint64_t)v7, &qword_10047D708);
    }
    else
    {
      (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v15, v7, v8);
    }
    Date.addingTimeInterval(_:)();
    static Date.> infix(_:_:)();
    Date.timeIntervalSinceNow.getter();
    uint64_t v25 = v24;
    v22(v12, v8);
    v22(v15, v8);
    v22(v20, v8);
    return v25;
  }
  return result;
}

uint64_t sub_1000480B0(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  unsigned int v5 = a3;
  uint64_t v6 = sub_100006FC8(&qword_10047D708);
  __chkstk_darwin(v6 - 8);
  uint64_t v8 = (char *)&v30 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = type metadata accessor for Date();
  uint64_t v10 = *(void *)(v9 - 8);
  __chkstk_darwin(v9);
  id v12 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v5 > 1)
  {
    sub_100045F18(0xD00000000000001ALL, 0x8000000100307EE0, 0xD000000000000017, 0x8000000100307D60);
    return 2;
  }
  uint64_t v13 = type metadata accessor for MBDryRestoreState();
  sub_100048E78(a1 + *(int *)(v13 + 36), (uint64_t)v8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v10 + 48))(v8, 1, v9) == 1)
  {
    sub_10001E2A0((uint64_t)v8, &qword_10047D708);
    sub_100045F18(0xD00000000000001CLL, 0x8000000100307E80, 0xD000000000000017, 0x8000000100307D60);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v10 + 32))(v12, v8, v9);
    Date.timeIntervalSinceNow.getter();
    double v16 = v15 + *(double *)&a2;
    if (v15 + *(double *)&a2 > 0.0)
    {
      uint64_t v30 = 0;
      unint64_t v31 = 0xE000000000000000;
      _StringGuts.grow(_:)(22);
      swift_bridgeObjectRelease();
      uint64_t v30 = 0xD000000000000014;
      unint64_t v31 = 0x8000000100307EC0;
      id v17 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
      [v17 setUnitsStyle:0];
      id v18 = [v17 localizedStringFromTimeInterval:v16];

      uint64_t v19 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      id v21 = v20;

      v22._countAndFlagsBits = v19;
      v22._object = v21;
      String.append(_:)(v22);
      swift_bridgeObjectRelease();
      sub_100045F18(v30, v31, 0xD000000000000017, 0x8000000100307D60);
      swift_bridgeObjectRelease();
      (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
      return 0;
    }
    uint64_t v30 = 0;
    unint64_t v31 = 0xE000000000000000;
    _StringGuts.grow(_:)(30);
    swift_bridgeObjectRelease();
    uint64_t v30 = 0xD000000000000018;
    unint64_t v31 = 0x8000000100307EA0;
    id v23 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
    [v23 setUnitsStyle:0];
    id v24 = [v23 localizedStringFromTimeInterval:v16];

    uint64_t v25 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    double v27 = v26;

    v28._countAndFlagsBits = v25;
    v28._object = v27;
    String.append(_:)(v28);
    swift_bridgeObjectRelease();
    v29._countAndFlagsBits = 1869046048;
    v29._object = (void *)0xE400000000000000;
    String.append(_:)(v29);
    sub_100045F18(v30, v31, 0xD000000000000017, 0x8000000100307D60);
    swift_bridgeObjectRelease();
    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
  }
  return 1;
}

double sub_1000484D4(uint64_t a1)
{
  uint64_t v2 = sub_100006FC8(&qword_10047D708);
  uint64_t v3 = __chkstk_darwin(v2 - 8);
  unsigned int v5 = (char *)&v25 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v3);
  uint64_t v7 = (char *)&v25 - v6;
  uint64_t v8 = type metadata accessor for Date();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = __chkstk_darwin(v8);
  Swift::String v26 = (char *)&v25 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = __chkstk_darwin(v10);
  uint64_t v14 = (char *)&v25 - v13;
  __chkstk_darwin(v12);
  double v16 = (char *)&v25 - v15;
  static Date.now.getter();
  Date.addingTimeInterval(_:)();
  id v17 = *(void (**)(char *, uint64_t))(v9 + 8);
  v17(v14, v8);
  uint64_t v18 = type metadata accessor for MBDryRestoreState();
  sub_100048E78(a1 + *(int *)(v18 + 44), (uint64_t)v5);
  uint64_t v19 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v9 + 48);
  if (v19(v5, 1, v8) == 1)
  {
    sub_10001E2A0((uint64_t)v5, &qword_10047D708);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 56))(v7, 1, 1, v8);
LABEL_4:
    sub_10001E2A0((uint64_t)v7, &qword_10047D708);
    goto LABEL_5;
  }
  Date.addingTimeInterval(_:)();
  v17(v5, v8);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v9 + 56))(v7, 0, 1, v8);
  if (v19(v7, 1, v8) == 1) {
    goto LABEL_4;
  }
  id v23 = v26;
  (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v26, v7, v8);
  if (static Date.> infix(_:_:)())
  {
    Date.timeIntervalSinceNow.getter();
    double v21 = v24;
    v17(v23, v8);
    goto LABEL_6;
  }
  v17(v23, v8);
LABEL_5:
  Date.timeIntervalSinceNow.getter();
  double v21 = v20;
LABEL_6:
  v17(v16, v8);
  return v21;
}

id sub_100048800()
{
  uint64_t v1 = sub_100006FC8(&qword_10047D708);
  uint64_t v2 = __chkstk_darwin(v1 - 8);
  id v38 = (char *)&v38 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v2);
  unsigned int v5 = (char *)&v38 - v4;
  uint64_t v6 = sub_100006FC8(&qword_10047E140);
  __chkstk_darwin(v6 - 8);
  uint64_t v8 = (char *)&v38 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = (int *)type metadata accessor for MBDryRestoreState();
  uint64_t v10 = *((void *)v9 - 1);
  __chkstk_darwin(v9);
  uint64_t v12 = (char *)&v38 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100045F18(0xD000000000000018, 0x8000000100307D80, 0xD000000000000017, 0x8000000100307D60);
  id v13 = objc_allocWithZone((Class)BGNonRepeatingSystemTaskRequest);
  NSString v14 = String._bridgeToObjectiveC()();
  id v15 = [v13 initWithIdentifier:v14];

  sub_10002A3B8((uint64_t)v8);
  int v16 = (*(uint64_t (**)(char *, uint64_t, int *))(v10 + 48))(v8, 1, v9);
  uint64_t v39 = v0;
  if (v16 == 1)
  {
    *((void *)v12 + 4) = 0;
    *(_OWORD *)uint64_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    v12[40] = 1;
    *((void *)v12 + 6) = 0;
    v12[56] = 1;
    *((void *)v12 + 8) = 0;
    v12[72] = 1;
    id v17 = &v12[v9[9]];
    uint64_t v18 = type metadata accessor for Date();
    uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v18 - 8) + 56);
    v19(v17, 1, 1, v18);
    v19(&v12[v9[10]], 1, 1, v18);
    v19(&v12[v9[11]], 1, 1, v18);
    double v20 = &v12[v9[12]];
    *(void *)double v20 = 0;
    v20[8] = 1;
    double v21 = &v12[v9[13]];
    *(void *)double v21 = 0;
    v21[8] = 1;
    Swift::String v22 = &v12[v9[14]];
    *(void *)Swift::String v22 = 0;
    v22[8] = 1;
    id v23 = &v12[v9[15]];
    *(void *)id v23 = 0;
    *((void *)v23 + 1) = 0;
    v19(&v12[v9[16]], 1, 1, v18);
    v19(&v12[v9[17]], 1, 1, v18);
    sub_10001E2A0((uint64_t)v8, &qword_10047E140);
  }
  else
  {
    sub_100048EE0((uint64_t)v8, (uint64_t)v12);
  }
  id v24 = [objc_allocWithZone((Class)CWFInterface) init];
  [v24 activate];
  id v25 = [v24 networkName];
  if (!v25)
  {
    [v24 invalidate];

    goto LABEL_9;
  }
  Swift::String v26 = v25;
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  v27._countAndFlagsBits = 0x466957656C707041;
  v27._object = (void *)0xE900000000000069;
  LOBYTE(v26) = String.hasPrefix(_:)(v27);
  swift_bridgeObjectRelease();
  [v24 invalidate];

  if ((v26 & 1) == 0)
  {
LABEL_9:
    uint64_t v33 = (uint64_t)&v12[v9[17]];
    sub_10001E2A0(v33, &qword_10047D708);
    uint64_t v34 = type metadata accessor for Date();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v34 - 8) + 56))(v33, 1, 1, v34);
    goto LABEL_10;
  }
  uint64_t v28 = (uint64_t)&v12[v9[17]];
  sub_100048E78(v28, (uint64_t)v5);
  uint64_t v29 = type metadata accessor for Date();
  uint64_t v30 = *(void *)(v29 - 8);
  int v31 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v30 + 48))(v5, 1, v29);
  sub_10001E2A0((uint64_t)v5, &qword_10047D708);
  if (v31 == 1)
  {
    uint64_t v32 = (uint64_t)v38;
    static Date.now.getter();
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v30 + 56))(v32, 0, 1, v29);
    sub_10002C7D8(v32, v28);
  }
LABEL_10:
  sub_100047894(*(void *)(*(void *)(v39 + 40) + OBJC_IVAR____TtC7backupd19MBDryRestoreManager_policy), *(unsigned char *)(*(void *)(v39 + 40) + OBJC_IVAR____TtC7backupd19MBDryRestoreManager_policy + 8), (uint64_t)v12);
  [v15 setRequiresProtectionClass:3];
  [v15 setRequiresUserInactivity:1];
  [v15 setRequiresBuddyComplete:1];
  [v15 setRequiresExternalPower:1];
  [v15 setRequiresNetworkConnectivity:1];
  [v15 setRequiresInexpensiveNetworkConnectivity:1];
  [v15 setRequiresUnconstrainedNetworkConnectivity:1];
  [v15 setPriority:1];
  [v15 setResourceIntensive:1];
  [v15 setResources:5];
  id v35 = v15;
  Class isa = Array._bridgeToObjectiveC()().super.isa;
  [v35 setInvolvedProcesses:isa];

  sub_10002C734((uint64_t)v12);
  return v35;
}

uint64_t sub_100048E78(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100006FC8(&qword_10047D708);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_100048EE0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for MBDryRestoreState();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

unint64_t sub_100048F44(uint64_t a1)
{
  uint64_t v2 = sub_100006FC8((uint64_t *)&unk_10047E1C0);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  unsigned int v5 = (char *)v22 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (!*(void *)(a1 + 16))
  {
    uint64_t v7 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047DAD0);
  uint64_t v6 = static _DictionaryStorage.allocate(capacity:)();
  uint64_t v7 = (void *)v6;
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v8)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v7;
  }
  uint64_t v9 = *(int *)(v2 + 48);
  uint64_t v10 = v6 + 64;
  unint64_t v11 = (*(unsigned __int8 *)(v3 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  v22[1] = a1;
  uint64_t v12 = a1 + v11;
  uint64_t v13 = *(void *)(v3 + 72);
  swift_retain();
  while (1)
  {
    sub_10004D2DC(v12, (uint64_t)v5, (uint64_t *)&unk_10047E1C0);
    unint64_t result = sub_1000314D0((uint64_t)v5);
    if (v15) {
      break;
    }
    unint64_t v16 = result;
    *(void *)(v10 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    uint64_t v17 = v7[6];
    uint64_t v18 = type metadata accessor for UUID();
    unint64_t result = (*(uint64_t (**)(unint64_t, char *, uint64_t))(*(void *)(v18 - 8) + 32))(v17 + *(void *)(*(void *)(v18 - 8) + 72) * v16, v5, v18);
    *(void *)(v7[7] + 8 * v16) = *(void *)&v5[v9];
    uint64_t v19 = v7[2];
    BOOL v20 = __OFADD__(v19, 1);
    uint64_t v21 = v19 + 1;
    if (v20) {
      goto LABEL_11;
    }
    uint64_t v7[2] = v21;
    v12 += v13;
    if (!--v8)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_100049138(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v2 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047DAC0);
  uint64_t v2 = (void *)static _DictionaryStorage.allocate(capacity:)();
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  uint64_t v4 = (uint64_t *)(a1 + 48);
  while (1)
  {
    uint64_t v5 = *(v4 - 2);
    uint64_t v6 = *(v4 - 1);
    uint64_t v7 = *v4;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    unint64_t result = sub_100031554(v5, v6);
    if (v9) {
      break;
    }
    *(void *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    uint64_t v10 = (uint64_t *)(v2[6] + 16 * result);
    uint64_t *v10 = v5;
    v10[1] = v6;
    *(void *)(v2[7] + 8 * result) = v7;
    uint64_t v11 = v2[2];
    BOOL v12 = __OFADD__(v11, 1);
    uint64_t v13 = v11 + 1;
    if (v12) {
      goto LABEL_11;
    }
    v2[2] = v13;
    v4 += 3;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_100049254(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v2 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047DAC8);
  uint64_t v2 = (void *)static _DictionaryStorage.allocate(capacity:)();
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  uint64_t v4 = (uint64_t *)(a1 + 48);
  while (1)
  {
    uint64_t v5 = *(v4 - 2);
    uint64_t v6 = *(v4 - 1);
    uint64_t v7 = *v4;
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
    unint64_t result = sub_100031554(v5, v6);
    if (v9) {
      break;
    }
    *(void *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    uint64_t v10 = (uint64_t *)(v2[6] + 16 * result);
    uint64_t *v10 = v5;
    v10[1] = v6;
    *(void *)(v2[7] + 8 * result) = v7;
    uint64_t v11 = v2[2];
    BOOL v12 = __OFADD__(v11, 1);
    uint64_t v13 = v11 + 1;
    if (v12) {
      goto LABEL_11;
    }
    v2[2] = v13;
    v4 += 3;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_100049370(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v3 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047DAB8);
  uint64_t v2 = static _DictionaryStorage.allocate(capacity:)();
  uint64_t v3 = (void *)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  uint64_t v5 = v2 + 64;
  uint64_t v6 = a1 + 32;
  swift_retain();
  while (1)
  {
    sub_10004D2DC(v6, (uint64_t)&v15, &qword_10047DF08);
    uint64_t v7 = v15;
    uint64_t v8 = v16;
    unint64_t result = sub_100031554(v15, v16);
    if (v10) {
      break;
    }
    *(void *)(v5 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    uint64_t v11 = (uint64_t *)(v3[6] + 16 * result);
    uint64_t *v11 = v7;
    v11[1] = v8;
    unint64_t result = (unint64_t)sub_100016C78(&v17, (_OWORD *)(v3[7] + 32 * result));
    uint64_t v12 = v3[2];
    BOOL v13 = __OFADD__(v12, 1);
    uint64_t v14 = v12 + 1;
    if (v13) {
      goto LABEL_11;
    }
    v3[2] = v14;
    v6 += 48;
    if (!--v4)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1000494A8(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v2 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047E1B8);
  uint64_t v2 = (void *)static _DictionaryStorage.allocate(capacity:)();
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  uint64_t v4 = (void **)(a1 + 40);
  while (1)
  {
    uint64_t v5 = *v4;
    id v6 = *(v4 - 1);
    id v7 = v5;
    unint64_t result = sub_1000315CC((uint64_t)v6);
    if (v9) {
      break;
    }
    *(void *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    uint64_t v10 = 8 * result;
    *(void *)(v2[6] + v10) = v6;
    *(void *)(v2[7] + v10) = v7;
    uint64_t v11 = v2[2];
    BOOL v12 = __OFADD__(v11, 1);
    uint64_t v13 = v11 + 1;
    if (v12) {
      goto LABEL_11;
    }
    v2[2] = v13;
    v4 += 2;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1000495B4(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v2 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047DA88);
  uint64_t v2 = (void *)static _DictionaryStorage.allocate(capacity:)();
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  uint64_t v4 = (void **)(a1 + 48);
  while (1)
  {
    uint64_t v5 = (uint64_t)*(v4 - 2);
    uint64_t v6 = (uint64_t)*(v4 - 1);
    id v7 = *v4;
    swift_bridgeObjectRetain();
    id v8 = v7;
    unint64_t result = sub_100031554(v5, v6);
    if (v10) {
      break;
    }
    *(void *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    uint64_t v11 = (uint64_t *)(v2[6] + 16 * result);
    uint64_t *v11 = v5;
    v11[1] = v6;
    *(void *)(v2[7] + 8 * result) = v8;
    uint64_t v12 = v2[2];
    BOOL v13 = __OFADD__(v12, 1);
    uint64_t v14 = v12 + 1;
    if (v13) {
      goto LABEL_11;
    }
    v2[2] = v14;
    v4 += 3;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1000496D0(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v3 = &_swiftEmptyDictionarySingleton;
    goto LABEL_9;
  }
  sub_100006FC8(&qword_10047E188);
  uint64_t v2 = static _DictionaryStorage.allocate(capacity:)();
  uint64_t v3 = (void *)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  uint64_t v5 = v2 + 64;
  uint64_t v6 = a1 + 32;
  swift_retain();
  while (1)
  {
    sub_10004D2DC(v6, (uint64_t)v15, &qword_10047E190);
    unint64_t result = sub_100031610((uint64_t)v15);
    if (v8) {
      break;
    }
    *(void *)(v5 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    uint64_t v9 = v3[6] + 40 * result;
    long long v10 = v15[0];
    long long v11 = v15[1];
    *(void *)(v9 + 32) = v16;
    *(_OWORD *)uint64_t v9 = v10;
    *(_OWORD *)(v9 + 16) = v11;
    unint64_t result = (unint64_t)sub_100016C78(&v17, (_OWORD *)(v3[7] + 32 * result));
    uint64_t v12 = v3[2];
    BOOL v13 = __OFADD__(v12, 1);
    uint64_t v14 = v12 + 1;
    if (v13) {
      goto LABEL_11;
    }
    v3[2] = v14;
    v6 += 72;
    if (!--v4)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_100049814()
{
  type metadata accessor for PropertyListEncoder();
  swift_allocObject();
  PropertyListEncoder.init()();
  type metadata accessor for MBDryRestoreState();
  sub_10004D284();
  uint64_t v1 = dispatch thunk of PropertyListEncoder.encode<A>(_:)();
  if (!v0)
  {
    uint64_t v3 = v1;
    unint64_t v4 = v2;
    uint64_t v5 = self;
    Class isa = Data._bridgeToObjectiveC()().super.isa;
    v16[0] = 0;
    id v7 = [v5 propertyListWithData:isa options:0 format:0 error:v16];

    if (v7)
    {
      id v8 = v16[0];
      _bridgeAnyObjectToAny(_:)();
      swift_unknownObjectRelease();
      sub_100006FC8(&qword_10047D4E8);
      if (swift_dynamicCast())
      {
        sub_10000C6C0(v3, v4);
        swift_release();
        return v15;
      }
      long long v11 = self;
      v16[0] = 0;
      v16[1] = (id)0xE000000000000000;
      _StringGuts.grow(_:)(39);
      v12._object = (void *)0x8000000100308030;
      v12._countAndFlagsBits = 0xD000000000000012;
      String.append(_:)(v12);
      _print_unlocked<A, B>(_:_:)();
      v13._countAndFlagsBits = 0xD000000000000013;
      v13._object = (void *)0x8000000100308050;
      String.append(_:)(v13);
      NSString v10 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v14 = [v11 errorWithCode:10 description:v10];
    }
    else
    {
      NSString v10 = v16[0];
      _convertNSErrorToError(_:)();
    }

    swift_willThrow();
    sub_10000C6C0(v3, v4);
  }
  return swift_release();
}

uint64_t sub_100049AA0()
{
  memcpy(__dst, v0, sizeof(__dst));
  type metadata accessor for PropertyListEncoder();
  swift_allocObject();
  PropertyListEncoder.init()();
  sub_10004D230();
  uint64_t v2 = dispatch thunk of PropertyListEncoder.encode<A>(_:)();
  if (!v1)
  {
    uint64_t v4 = v2;
    unint64_t v5 = v3;
    uint64_t v6 = self;
    Class isa = Data._bridgeToObjectiveC()().super.isa;
    v19[0] = 0;
    id v8 = [v6 propertyListWithData:isa options:0 format:0 error:v19];

    if (v8)
    {
      id v9 = v19[0];
      _bridgeAnyObjectToAny(_:)();
      swift_unknownObjectRelease();
      sub_100006FC8(&qword_10047D4E8);
      if (swift_dynamicCast())
      {
        sub_10000C6C0(v4, v5);
        swift_release();
        return v18;
      }
      Swift::String v12 = self;
      v19[0] = 0;
      v19[1] = (id)0xE000000000000000;
      _StringGuts.grow(_:)(39);
      id v16 = v19[0];
      id v17 = v19[1];
      v13._object = (void *)0x8000000100308030;
      v13._countAndFlagsBits = 0xD000000000000012;
      String.append(_:)(v13);
      memcpy(v19, __dst, 0x229uLL);
      _print_unlocked<A, B>(_:_:)();
      v14._countAndFlagsBits = 0xD000000000000013;
      v14._object = (void *)0x8000000100308050;
      String.append(_:)(v14);
      NSString v15 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      objc_msgSend(v12, "errorWithCode:description:", 10, v15, v16, v17);
    }
    else
    {
      id v11 = v19[0];
      _convertNSErrorToError(_:)();
    }
    swift_willThrow();
    sub_10000C6C0(v4, v5);
  }
  return swift_release();
}

uint64_t sub_100049D4C()
{
  sub_10004D028(v0, (uint64_t)v22, &qword_10047E170);
  type metadata accessor for PropertyListEncoder();
  swift_allocObject();
  PropertyListEncoder.init()();
  sub_100006FC8(&qword_10047E170);
  sub_10004D1BC();
  uint64_t v2 = dispatch thunk of PropertyListEncoder.encode<A>(_:)();
  if (!v1)
  {
    uint64_t v4 = v2;
    unint64_t v5 = v3;
    uint64_t v6 = self;
    Class isa = Data._bridgeToObjectiveC()().super.isa;
    id v20 = 0;
    id v8 = [v6 propertyListWithData:isa options:0 format:0 error:&v20];

    if (v8)
    {
      id v9 = v20;
      _bridgeAnyObjectToAny(_:)();
      swift_unknownObjectRelease();
      sub_100006FC8(&qword_10047D4E8);
      if (swift_dynamicCast())
      {
        sub_10000C6C0(v4, v5);
        swift_release();
        return v18;
      }
      Swift::String v12 = self;
      id v20 = 0;
      unint64_t v21 = 0xE000000000000000;
      _StringGuts.grow(_:)(39);
      id v16 = v20;
      unint64_t v17 = v21;
      v13._object = (void *)0x8000000100308030;
      v13._countAndFlagsBits = 0xD000000000000012;
      String.append(_:)(v13);
      sub_10004D028((uint64_t)v22, (uint64_t)&v20, &qword_10047E170);
      sub_10004D028((uint64_t)&v20, (uint64_t)v19, &qword_10047E170);
      _print_unlocked<A, B>(_:_:)();
      v14._countAndFlagsBits = 0xD000000000000013;
      v14._object = (void *)0x8000000100308050;
      String.append(_:)(v14);
      NSString v11 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v15 = objc_msgSend(v12, "errorWithCode:description:", 10, v11, v16, v17);
    }
    else
    {
      NSString v11 = v20;
      _convertNSErrorToError(_:)();
    }

    swift_willThrow();
    sub_10000C6C0(v4, v5);
  }
  return swift_release();
}

uint64_t sub_10004A01C()
{
  *(_OWORD *)&v19[48] = v0[4];
  *(_OWORD *)&v19[64] = v0[5];
  *(_OWORD *)&v19[80] = v0[6];
  *(void *)&v19[96] = *((void *)v0 + 14);
  long long v18 = *v0;
  *(_OWORD *)uint64_t v19 = v0[1];
  *(_OWORD *)&v19[16] = v0[2];
  *(_OWORD *)&v19[32] = v0[3];
  type metadata accessor for PropertyListEncoder();
  swift_allocObject();
  PropertyListEncoder.init()();
  sub_10004D168();
  uint64_t v2 = dispatch thunk of PropertyListEncoder.encode<A>(_:)();
  if (!v1)
  {
    uint64_t v4 = v2;
    unint64_t v5 = v3;
    uint64_t v6 = self;
    Class isa = Data._bridgeToObjectiveC()().super.isa;
    *(void *)&long long v20 = 0;
    id v8 = [v6 propertyListWithData:isa options:0 format:0 error:&v20];

    if (v8)
    {
      id v9 = (id)v20;
      _bridgeAnyObjectToAny(_:)();
      swift_unknownObjectRelease();
      sub_100006FC8(&qword_10047D4E8);
      if (swift_dynamicCast())
      {
        sub_10000C6C0(v4, v5);
        swift_release();
        return v16;
      }
      Swift::String v12 = self;
      *(void *)&long long v20 = 0;
      *((void *)&v20 + 1) = 0xE000000000000000;
      _StringGuts.grow(_:)(39);
      long long v17 = v20;
      v13._object = (void *)0x8000000100308030;
      v13._countAndFlagsBits = 0xD000000000000012;
      String.append(_:)(v13);
      long long v20 = v18;
      char v21 = v19[0];
      long long v22 = *(_OWORD *)&v19[8];
      long long v23 = *(_OWORD *)&v19[24];
      long long v24 = *(_OWORD *)&v19[40];
      long long v25 = *(_OWORD *)&v19[56];
      long long v26 = *(_OWORD *)&v19[72];
      long long v27 = *(_OWORD *)&v19[88];
      _print_unlocked<A, B>(_:_:)();
      v14._countAndFlagsBits = 0xD000000000000013;
      v14._object = (void *)0x8000000100308050;
      String.append(_:)(v14);
      NSString v11 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      id v15 = objc_msgSend(v12, "errorWithCode:description:", 10, v11, v17);
    }
    else
    {
      NSString v11 = (id)v20;
      _convertNSErrorToError(_:)();
    }

    swift_willThrow();
    sub_10000C6C0(v4, v5);
  }
  return swift_release();
}

uint64_t sub_10004A30C(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for MBDryRestoreState();
  __chkstk_darwin(v2);
  uint64_t v4 = (char *)&v22 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = sub_100006FC8(&qword_10047D708);
  uint64_t v6 = __chkstk_darwin(v5 - 8);
  id v8 = (char *)&v22 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v6);
  NSString v10 = (char *)&v22 - v9;
  id v11 = [objc_allocWithZone((Class)CWFInterface) init];
  [v11 activate];
  id v12 = [v11 networkName];
  if (!v12)
  {
    [v11 invalidate];

    goto LABEL_6;
  }
  Swift::String v13 = v12;
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  v14._countAndFlagsBits = 0x466957656C707041;
  v14._object = (void *)0xE900000000000069;
  LOBYTE(v13) = String.hasPrefix(_:)(v14);
  swift_bridgeObjectRelease();
  [v11 invalidate];

  if ((v13 & 1) == 0)
  {
LABEL_6:
    uint64_t v19 = a1 + *(int *)(v2 + 68);
    sub_10001E2A0(v19, &qword_10047D708);
    uint64_t v20 = type metadata accessor for Date();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v20 - 8) + 56))(v19, 1, 1, v20);
    goto LABEL_7;
  }
  uint64_t v15 = a1 + *(int *)(v2 + 68);
  sub_10004D2DC(v15, (uint64_t)v10, &qword_10047D708);
  uint64_t v16 = type metadata accessor for Date();
  uint64_t v17 = *(void *)(v16 - 8);
  int v18 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v17 + 48))(v10, 1, v16);
  sub_10001E2A0((uint64_t)v10, &qword_10047D708);
  if (v18 == 1)
  {
    static Date.now.getter();
    (*(void (**)(char *, void, uint64_t, uint64_t))(v17 + 56))(v8, 0, 1, v16);
    sub_10002C7D8((uint64_t)v8, v15);
  }
LABEL_7:
  sub_10002C840(a1, (uint64_t)v4);
  sub_10002A6C8();
  return sub_10002C734((uint64_t)v4);
}

uint64_t type metadata accessor for MBDryRestoreCommand()
{
  return self;
}

unint64_t sub_10004A78C(unint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    swift_stdlib_random();
    unint64_t result = (0 * (unsigned __int128)v1) >> 64;
    if (-(uint64_t)v1 % v1)
    {
      while (1)
        swift_stdlib_random();
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

void *sub_10004A818(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 >> 62) {
    goto LABEL_20;
  }
  uint64_t v5 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  swift_bridgeObjectRetain();
  for (; v5; uint64_t v5 = _CocoaArrayWrapper.endIndex.getter())
  {
    uint64_t v6 = 4;
    while (1)
    {
      id v7 = (a1 & 0xC000000000000001) != 0
         ? (id)specialized _ArrayBuffer._getElementSlowPath(_:)()
         : *(id *)(a1 + 8 * v6);
      id v8 = v7;
      uint64_t v9 = v6 - 3;
      if (__OFADD__(v6 - 4, 1)) {
        break;
      }
      id v10 = [v7 snapshotUUID];
      if (v10)
      {
        id v11 = v10;
        uint64_t v12 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v14 = v13;

        if (v12 == a2 && v14 == a3)
        {
          swift_bridgeObjectRelease();
LABEL_18:
          swift_bridgeObjectRelease();
          return v8;
        }
        char v16 = _stringCompareWithSmolCheck(_:_:expecting:)();
        swift_bridgeObjectRelease();
        if (v16) {
          goto LABEL_18;
        }
      }

      ++v6;
      if (v9 == v5) {
        goto LABEL_21;
      }
    }
    __break(1u);
LABEL_20:
    swift_bridgeObjectRetain();
  }
LABEL_21:
  swift_bridgeObjectRelease();
  return 0;
}

void sub_10004A9AC(uint64_t a1)
{
  uint64_t v2 = (void *)__chkstk_darwin(a1);
  v192 = (char *)v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  id v191 = v7;
  v190 = v2;
  uint64_t v9 = v8;
  uint64_t v10 = sub_100006FC8(&qword_10047D708);
  uint64_t v11 = __chkstk_darwin(v10 - 8);
  uint64_t v13 = (char *)&v113 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v11);
  uint64_t v15 = (char *)&v113 - v14;
  uint64_t v16 = sub_100006FC8(&qword_10047E140);
  __chkstk_darwin(v16 - 8);
  int v18 = (char *)&v113 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = type metadata accessor for MBDryRestoreState();
  uint64_t v20 = *(void *)(v19 - 8);
  __chkstk_darwin(v19);
  uint64_t v22 = (char *)&v113 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = (uint64_t)v192;
  unint64_t v24 = (unint64_t)sub_1000557F8((uint64_t)v4);
  if (v23) {
    return;
  }
  unint64_t v25 = v24;
  uint64_t v186 = v20;
  v187 = v18;
  v188 = (int *)v19;
  v185 = v15;
  v184 = v13;
  v189 = v4;
  v192 = v22;
  uint64_t v26 = (uint64_t)v191;
  if (!v191)
  {
    if (v24 >> 62)
    {
      unint64_t v109 = v24;
      swift_bridgeObjectRetain();
      uint64_t v110 = _CocoaArrayWrapper.endIndex.getter();
      swift_bridgeObjectRelease();
      if (v110)
      {
        swift_bridgeObjectRetain();
        unint64_t v29 = _CocoaArrayWrapper.endIndex.getter();
        swift_bridgeObjectRelease();
        if ((v29 & 0x8000000000000000) != 0)
        {
LABEL_51:
          __break(1u);
          return;
        }
        unint64_t v25 = v109;
        if (v29)
        {
LABEL_7:
          unint64_t v30 = v25;
          unint64_t v31 = sub_10004A78C(v29);
          if ((v30 & 0xC000000000000001) == 0)
          {
            if ((v31 & 0x8000000000000000) != 0)
            {
              __break(1u);
            }
            else if (v31 < *(void *)((v30 & 0xFFFFFFFFFFFFFF8) + 0x10))
            {
              id v32 = *(id *)(v30 + 8 * v31 + 32);
LABEL_11:
              uint64_t v28 = v32;
              swift_bridgeObjectRelease();
              goto LABEL_12;
            }
            __break(1u);
LABEL_50:

            __break(1u);
            goto LABEL_51;
          }
          id v32 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
          goto LABEL_11;
        }
        __break(1u);
      }
    }
    else
    {
      unint64_t v29 = *(void *)((v24 & 0xFFFFFFFFFFFFFF8) + 0x10);
      if (v29) {
        goto LABEL_7;
      }
    }
    swift_bridgeObjectRelease();
LABEL_42:
    sub_1000467F0(502, 0xD000000000000017, 0x8000000100308010, 0x7365722D7972643DLL, 0xEE00203D65726F74);
    swift_willThrow();
    return;
  }
  unint64_t v27 = v24;
  swift_bridgeObjectRetain();
  uint64_t v28 = sub_10004A818(v27, (uint64_t)v190, v26);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (!v28) {
    goto LABEL_42;
  }
LABEL_12:
  id v33 = v28;
  id v34 = [v33 snapshotUUID];
  if (!v34)
  {
    sub_1000467F0(502, 0xD000000000000014, 0x8000000100307F90, 0x7365722D7972643DLL, 0xEE00203D65726F74);
    swift_willThrow();

    return;
  }
  id v35 = v34;
  id v191 = v28;
  uint64_t v182 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  v190 = v36;

  id v183 = v33;
  id v37 = [v33 backupUUID];
  if (!v37) {
    goto LABEL_50;
  }
  id v38 = v37;
  uint64_t v39 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v41 = v40;

  id v42 = [v6 persona];
  id v43 = [v42 dryRestoreContentDirectory];
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  sub_100006FC8((uint64_t *)&unk_10047D910);
  unint64_t v44 = swift_allocBox();
  FilePath.init(_:)();
  sub_1000083B8(v44);
  uint64_t v179 = v39;
  unint64_t v181 = v44;
  id v45 = [v42 dryRestoreMetadataDirectory];
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  unint64_t v46 = swift_allocBox();
  FilePath.init(_:)();
  sub_1000083B8(v46);
  uint64_t v180 = 0;
  id v176 = v42;
  uint64_t v177 = v41;
  uint64_t v47 = (uint64_t)v187;
  sub_10002A3B8((uint64_t)v187);
  uint64_t v48 = v188;
  int v49 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(v186 + 48))(v47, 1, v188);
  unint64_t v178 = v46;
  if (v49 == 1)
  {
    uint64_t v50 = (uint64_t)v192;
    *((void *)v192 + 4) = 0;
    *(_OWORD *)uint64_t v50 = 0u;
    *(_OWORD *)(v50 + 16) = 0u;
    *(unsigned char *)(v50 + 40) = 1;
    *(void *)(v50 + 48) = 0;
    *(unsigned char *)(v50 + 56) = 1;
    *(void *)(v50 + 64) = 0;
    *(unsigned char *)(v50 + 72) = 1;
    uint64_t v186 = v50 + v48[9];
    uint64_t v51 = type metadata accessor for Date();
    int v52 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v51 - 8) + 56);
    v52(v186, 1, 1, v51);
    v52(v50 + v48[10], 1, 1, v51);
    v52(v50 + v48[11], 1, 1, v51);
    uint64_t v53 = v50 + v48[12];
    *(void *)uint64_t v53 = 0;
    *(unsigned char *)(v53 + 8) = 1;
    uint64_t v54 = v50 + v48[13];
    *(void *)uint64_t v54 = 0;
    *(unsigned char *)(v54 + 8) = 1;
    uint64_t v55 = v50 + v48[14];
    *(void *)uint64_t v55 = 0;
    *(unsigned char *)(v55 + 8) = 1;
    id v56 = (void *)(v50 + v48[15]);
    *id v56 = 0;
    v56[1] = 0;
    v52(v50 + v48[16], 1, 1, v51);
    v52(v50 + v48[17], 1, 1, v51);
    sub_10001E2A0(v47, &qword_10047E140);
  }
  else
  {
    sub_100048EE0(v47, (uint64_t)v192);
  }
  id v57 = [objc_allocWithZone((Class)CWFInterface) init];
  [v57 activate];
  id v58 = [v57 networkName];
  if (v58)
  {
    unsigned __int8 v59 = v58;
    static String._unconditionallyBridgeFromObjectiveC(_:)();

    v60._countAndFlagsBits = 0x466957656C707041;
    v60._object = (void *)0xE900000000000069;
    LOBYTE(v59) = String.hasPrefix(_:)(v60);
    swift_bridgeObjectRelease();
    [v57 invalidate];

    if (v59)
    {
      uint64_t v61 = (uint64_t)v192;
      uint64_t v62 = (uint64_t)&v192[v48[17]];
      uint64_t v63 = (uint64_t)v185;
      sub_10004D2DC(v62, (uint64_t)v185, &qword_10047D708);
      uint64_t v64 = type metadata accessor for Date();
      uint64_t v65 = *(void *)(v64 - 8);
      int v66 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v65 + 48))(v63, 1, v64);
      sub_10001E2A0(v63, &qword_10047D708);
      if (v66 == 1)
      {
        uint64_t v67 = (uint64_t)v184;
        static Date.now.getter();
        (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v65 + 56))(v67, 0, 1, v64);
        sub_10002C7D8(v67, v62);
      }
      goto LABEL_25;
    }
  }
  else
  {
    [v57 invalidate];
  }
  uint64_t v61 = (uint64_t)v192;
  uint64_t v68 = (uint64_t)&v192[v48[17]];
  sub_10001E2A0(v68, &qword_10047D708);
  uint64_t v69 = type metadata accessor for Date();
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v69 - 8) + 56))(v68, 1, 1, v69);
LABEL_25:
  uint64_t v70 = v180;
  uint64_t v71 = sub_10001A794(v181, v178, v182, v190, v179, v177, 1, v6, v189, v9, 0);
  if (v70)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_10004A30C(v61);

    swift_release();
    swift_release();

    sub_10002C734(v61);
  }
  else
  {
    uint64_t v72 = (Swift::String *)v71;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_10004F414((uint64_t)v72);
    sub_10000EB88();
    v189 = v72;
    sub_10000EF94();
    sub_100018EC4();
    sub_1000101C4();
    uint64_t v138 = 0;
    id v94 = sub_10000E134();
    if (v94)
    {
      char v95 = v94;
      char v96 = self;
      swift_errorRetain();
      swift_errorRetain();
      swift_errorRetain();
      uint64_t v118 = v72;
      uint64_t v97 = (void *)_convertErrorToNSError(_:)();
      LODWORD(v96) = [v96 isCancelledError:v97];

      v190 = v95;
      if (v96)
      {
        sub_100045F18(0xD000000000000013, 0x8000000100307FF0, 0xD000000000000018, 0x8000000100307FD0);
        sub_100050D24(2, (uint64_t)v72, (uint64_t)&v293);
        uint64_t v117 = v293;
        int v152 = v294;
        uint64_t v171 = v296;
        uint64_t v172 = v295;
        uint64_t v173 = v297;
        int v116 = v298;
        int v169 = v299;
        uint64_t v114 = v301;
        uint64_t v115 = v300;
        uint64_t v168 = v302;
        int v151 = v303;
        int v153 = v324;
        int v154 = v326;
        int v155 = v328;
        int v156 = v330;
        int v157 = v332;
        int v158 = v334;
        int v159 = v336;
        int v160 = v338;
        int v161 = v340;
        int v162 = v342;
        int v163 = v348;
        int v164 = v350;
        int v165 = v352;
        int v166 = v354;
        int v167 = v356;
        int v170 = v358;
        int v98 = v360;
        int v99 = v362;
        uint64_t v100 = v305;
        uint64_t v129 = v304;
        uint64_t v130 = v306;
        uint64_t v101 = v307;
        int v131 = v308[16];
        int v132 = v308[17];
        uint64_t v133 = v309;
        uint64_t v134 = v311;
        int v122 = v310;
        int v123 = v312;
        uint64_t v135 = v313;
        uint64_t v136 = v315;
        int v124 = v314;
        int v125 = v316;
        uint64_t v137 = v317;
        int v126 = v318;
        int v127 = v320;
        uint64_t v139 = v319;
        uint64_t v140 = v321;
        int v128 = v322;
        uint64_t v141 = v323;
        uint64_t v142 = v325;
        uint64_t v143 = v327;
        uint64_t v144 = v329;
        uint64_t v145 = v331;
        uint64_t v146 = v333;
        uint64_t v147 = v335;
        uint64_t v148 = v337;
        uint64_t v149 = v339;
        uint64_t v150 = v341;
        uint64_t v174 = v343;
        uint64_t v175 = v344;
        LODWORD(v177) = v345;
        LODWORD(v179) = v346;
        uint64_t v180 = v347;
        uint64_t v182 = v349;
        v184 = v351;
        v185 = (char *)v353;
        uint64_t v186 = v355;
        v187 = (char *)v357;
        uint64_t v102 = v359;
        v188 = v361;
        sub_10004D028((uint64_t)v308, (uint64_t)v436, &qword_10047E180);
        swift_bridgeObjectRetain();
        uint64_t v103 = v114;
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        sub_10004D08C((uint64_t)v436);
        char v253 = v153;
        char v255 = v154;
        char v257 = v155;
        char v259 = v156;
        char v261 = v157;
        char v263 = v158;
        char v265 = v159;
        char v267 = v160;
        char v269 = v161;
        char v271 = v162;
        char v277 = v163;
        char v279 = v164;
        char v281 = v165;
        char v283 = v166;
        char v285 = v167;
        char v287 = v170;
        int v119 = v98;
        int v120 = v99;
        char v289 = v98;
        uint64_t v104 = v115;
        char v291 = v99;
        uint64_t v105 = v117;
        uint64_t v221 = v117;
        char v222 = v152;
        uint64_t v223 = v172;
        uint64_t v224 = v171;
        uint64_t v225 = v173;
        char v106 = v116;
        char v226 = v116;
        char v227 = v169;
        uint64_t v228 = v115;
        uint64_t v229 = v103;
        uint64_t v230 = v168;
        char v231 = v151;
        uint64_t v232 = v129;
        uint64_t v233 = v100;
        uint64_t v234 = v130;
        *(void *)v235 = v101;
        *(_OWORD *)&v235[8] = xmmword_1003B2EC0;
        char v236 = v131;
        char v237 = v132;
        uint64_t v238 = v133;
        char v239 = v122;
        uint64_t v240 = v134;
        char v241 = v123;
        uint64_t v242 = v135;
        char v243 = v124;
        uint64_t v244 = v136;
        char v245 = v125;
        uint64_t v246 = v137;
        char v247 = v126;
        uint64_t v248 = v139;
        char v249 = v127;
        uint64_t v250 = v140;
        char v251 = v128;
        uint64_t v252 = v141;
        uint64_t v254 = v142;
        uint64_t v256 = v143;
        uint64_t v258 = v144;
        uint64_t v260 = v145;
        uint64_t v262 = v146;
        uint64_t v264 = v147;
        uint64_t v266 = v148;
        uint64_t v268 = v149;
        uint64_t v270 = v150;
        uint64_t v272 = v174;
        uint64_t v273 = v175;
        char v274 = v177;
        char v275 = v179;
        uint64_t v276 = v180;
        uint64_t v278 = v182;
        v280 = v184;
        uint64_t v282 = (uint64_t)v185;
        uint64_t v284 = v186;
        uint64_t v286 = (uint64_t)v187;
        uint64_t v121 = v102;
        uint64_t v288 = v102;
        v290 = v188;
        sub_10004D0B8((uint64_t)&v221);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        sub_10004D110((uint64_t)&v221);
        swift_errorRelease();
        swift_errorRelease();

        swift_errorRelease();
        int64x2_t v107 = vdupq_n_s64(0x636E614372657375uLL);
        v107.i64[0] = v101;
        unint64_t v108 = 0xED000064656C6C65;
      }
      else
      {
        sub_100052074((uint64_t)v95, (uint64_t)v72, (uint64_t)&v363);
        swift_errorRelease();
        swift_errorRelease();

        swift_errorRelease();
        v188 = v433;
        uint64_t v121 = v431;
        int v119 = v432;
        int v120 = v434;
        int v170 = v430;
        v187 = (char *)v429;
        uint64_t v186 = v427;
        int v167 = v428;
        int v166 = v426;
        v185 = (char *)v425;
        v184 = v423;
        int v165 = v424;
        int v164 = v422;
        uint64_t v182 = v421;
        uint64_t v180 = v419;
        int v163 = v420;
        LODWORD(v179) = v418;
        LODWORD(v177) = v417;
        uint64_t v174 = v415;
        uint64_t v175 = v416;
        int v162 = v414;
        int v161 = v412;
        int v160 = v410;
        int v159 = v408;
        int v158 = v406;
        int v157 = v404;
        int v156 = v402;
        int v155 = v400;
        int v154 = v398;
        int v153 = v396;
        int64x2_t v107 = v377;
        uint64_t v149 = v411;
        uint64_t v150 = v413;
        uint64_t v147 = v407;
        uint64_t v148 = v409;
        uint64_t v145 = v403;
        uint64_t v146 = v405;
        uint64_t v143 = v399;
        uint64_t v144 = v401;
        uint64_t v141 = v395;
        uint64_t v142 = v397;
        uint64_t v139 = v391;
        uint64_t v140 = v393;
        int v127 = v392;
        int v128 = v394;
        uint64_t v136 = v387;
        uint64_t v137 = v389;
        int v125 = v388;
        int v126 = v390;
        uint64_t v134 = v383;
        uint64_t v135 = v385;
        int v123 = v384;
        int v124 = v386;
        uint64_t v133 = v381;
        int v122 = v382;
        int v131 = v379;
        int v132 = v380;
        unint64_t v108 = v378;
        uint64_t v129 = v374;
        uint64_t v130 = v376;
        uint64_t v100 = v375;
        uint64_t v168 = v372;
        int v151 = v373;
        uint64_t v104 = v370;
        uint64_t v103 = v371;
        int v169 = v369;
        char v106 = v368;
        uint64_t v171 = v366;
        uint64_t v172 = v365;
        uint64_t v173 = v367;
        int v152 = v364;
        uint64_t v105 = v363;
      }
      LOBYTE(v193) = v106;
      char v220 = v151;
      char v219 = v122;
      char v218 = v123;
      char v217 = v124;
      char v216 = v125;
      char v215 = v126;
      char v214 = v127;
      char v213 = v128;
      char v212 = v153;
      char v211 = v154;
      char v210 = v155;
      char v209 = v156;
      char v208 = v157;
      char v207 = v158;
      char v206 = v159;
      char v205 = v160;
      char v204 = v161;
      char v203 = v162;
      char v202 = v163;
      char v201 = v164;
      char v200 = v165;
      char v199 = v166;
      char v198 = v167;
      char v197 = v170;
      char v196 = v119;
      char v195 = v120;
      uint64_t v221 = v105;
      char v222 = v152;
      uint64_t v223 = v172;
      uint64_t v224 = v171;
      uint64_t v225 = v173;
      char v227 = v169;
      uint64_t v228 = v104;
      uint64_t v229 = v103;
      uint64_t v230 = v168;
      uint64_t v232 = v129;
      uint64_t v233 = v100;
      uint64_t v234 = v130;
      *(void *)&v235[16] = v108;
      *(int64x2_t *)v235 = v107;
      char v226 = v106;
      char v231 = v151;
      char v236 = v131;
      char v237 = v132;
      uint64_t v238 = v133;
      char v239 = v122;
      uint64_t v240 = v134;
      char v241 = v123;
      uint64_t v242 = v135;
      char v243 = v124;
      uint64_t v244 = v136;
      char v245 = v125;
      uint64_t v246 = v137;
      char v247 = v126;
      uint64_t v248 = v139;
      char v249 = v127;
      uint64_t v250 = v140;
      char v251 = v128;
      uint64_t v252 = v141;
      char v253 = v153;
      uint64_t v254 = v142;
      char v255 = v154;
      uint64_t v256 = v143;
      char v257 = v155;
      uint64_t v258 = v144;
      char v259 = v156;
      uint64_t v260 = v145;
      char v261 = v157;
      uint64_t v262 = v146;
      char v263 = v158;
      uint64_t v264 = v147;
      char v265 = v159;
      uint64_t v266 = v148;
      char v267 = v160;
      uint64_t v268 = v149;
      char v269 = v161;
      uint64_t v270 = v150;
      char v271 = v162;
      uint64_t v272 = v174;
      uint64_t v273 = v175;
      char v274 = v177;
      char v275 = v179;
      uint64_t v276 = v180;
      char v277 = v163;
      uint64_t v278 = v182;
      char v279 = v164;
      v280 = v184;
      char v281 = v165;
      uint64_t v282 = (uint64_t)v185;
      char v283 = v166;
      uint64_t v284 = v186;
      char v285 = v167;
      uint64_t v286 = (uint64_t)v187;
      char v287 = v170;
      uint64_t v288 = v121;
      char v289 = v119;
      v290 = v188;
      char v291 = v120;
      Enumerator.Options.rawValue.getter(&v221);
      sub_10004D028((uint64_t)&v221, (uint64_t)v292, &qword_10047E170);
      char v111 = 1;
      uint64_t v112 = v190;
    }
    else
    {
      sub_10004F5B4((uint64_t)v72, &v221);
      Enumerator.Options.rawValue.getter(&v221);
      sub_10004D028((uint64_t)&v221, (uint64_t)v292, &qword_10047E170);
      char v111 = 0;
      uint64_t v112 = 0;
    }
    sub_10004D028((uint64_t)v292, (uint64_t)&v438, &qword_10047E170);
    id v73 = v189;
    sub_100019070(v111);
    v190 = v112;
    if (v112)
    {
      uint64_t v74 = self;
      swift_errorRetain();
      uint64_t v75 = (void *)_convertErrorToNSError(_:)();
      swift_errorRelease();
      id v76 = [v74 dictionaryRepresentationForError:v75 withMultiErrors:1];

      unint64_t v77 = static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();
    }
    else
    {
      unint64_t v77 = sub_1000496D0((uint64_t)_swiftEmptyArrayStorage);
    }
    sub_100006FC8(&qword_10047D770);
    uint64_t v78 = swift_allocObject();
    *(void *)(v78 + 32) = 1702125938;
    *(_OWORD *)(v78 + 16) = xmmword_1003B2ED0;
    *(void *)(v78 + 40) = 0xE400000000000000;
    sub_10000E340((uint64_t)&v435);
    uint64_t v79 = sub_10001D890();
    *(void *)(v78 + 72) = &type metadata for String;
    *(void *)(v78 + 48) = v79;
    *(void *)(v78 + 56) = v80;
    *(void *)(v78 + 80) = 0x6574617473;
    *(void *)(v78 + 88) = 0xE500000000000000;
    uint64_t v81 = (uint64_t)v192;
    uint64_t v82 = v138;
    uint64_t v83 = sub_100049814();
    if (v82)
    {
      sub_10004CEDC(v292);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      sub_10001E2A0(v78 + 32, &qword_10047DF08);
      swift_setDeallocating();
      sub_100006FC8(&qword_10047DF08);
      swift_arrayDestroy();
      swift_deallocClassInstance();
      swift_errorRelease();

      sub_10004A30C(v81);
      swift_release();
      swift_release();

      sub_10002C734(v81);
    }
    else
    {
      uint64_t v84 = v83;
      v188 = (int *)v77;
      uint64_t v85 = sub_100006FC8(&qword_10047D4E8);
      *(void *)(v78 + 128) = 0x7274656D656C6574;
      uint64_t v86 = v85;
      *(void *)(v78 + 120) = v85;
      *(void *)(v78 + 96) = v84;
      *(void *)(v78 + 136) = 0xE900000000000079;
      uint64_t v87 = sub_100049D4C();
      sub_10004CEDC(v292);
      *(void *)(v78 + 144) = v87;
      *(void *)(v78 + 168) = v86;
      *(void *)(v78 + 176) = 0x6F697463656C6573;
      *(void *)(v78 + 184) = 0xE90000000000006ELL;
      char v88 = (char *)v189 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession__selection;
      swift_beginAccess();
      long long v89 = *((_OWORD *)v88 + 5);
      v436[6] = *((_OWORD *)v88 + 4);
      v436[7] = v89;
      v436[8] = *((_OWORD *)v88 + 6);
      uint64_t v437 = *((void *)v88 + 14);
      long long v90 = *((_OWORD *)v88 + 1);
      v436[2] = *(_OWORD *)v88;
      v436[3] = v90;
      long long v91 = *((_OWORD *)v88 + 3);
      v436[4] = *((_OWORD *)v88 + 2);
      v436[5] = v91;
      *(void *)(v78 + 192) = sub_10004A01C();
      *(void *)(v78 + 216) = v86;
      *(void *)(v78 + 224) = 0x726F727265;
      *(void *)(v78 + 232) = 0xE500000000000000;
      *(void *)(v78 + 264) = sub_100006FC8(&qword_10047E178);
      *(void *)(v78 + 240) = v188;
      sub_100049370(v78);
      uint64_t v193 = 0;
      unint64_t v194 = 0xE000000000000000;
      _StringGuts.grow(_:)(23);
      swift_bridgeObjectRelease();
      uint64_t v193 = 0xD000000000000015;
      unint64_t v194 = 0x8000000100307FB0;
      v92._countAndFlagsBits = Dictionary.description.getter();
      String.append(_:)(v92);
      swift_bridgeObjectRelease();
      sub_100045F18(v193, v194, 0x7365722D7972643DLL, 0xEE00203D65726F74);
      swift_errorRelease();

      swift_bridgeObjectRelease();
      uint64_t v93 = (uint64_t)v192;
      sub_10004A30C((uint64_t)v192);

      swift_release();
      swift_release();

      sub_10002C734(v93);
    }
  }
}

uint64_t *sub_10004CEDC(uint64_t *a1)
{
  return a1;
}

uint64_t sub_10004CFC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a8 != 1)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_10004D028(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = sub_100006FC8(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_10004D08C(uint64_t a1)
{
  return a1;
}

uint64_t sub_10004D0B8(uint64_t a1)
{
  return a1;
}

uint64_t sub_10004D110(uint64_t a1)
{
  return a1;
}

unint64_t sub_10004D168()
{
  unint64_t result = qword_10047E198;
  if (!qword_10047E198)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E198);
  }
  return result;
}

unint64_t sub_10004D1BC()
{
  unint64_t result = qword_10047E1A0;
  if (!qword_10047E1A0)
  {
    sub_10000BAC4(&qword_10047E170);
    sub_10004D230();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E1A0);
  }
  return result;
}

unint64_t sub_10004D230()
{
  unint64_t result = qword_10047E1A8;
  if (!qword_10047E1A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E1A8);
  }
  return result;
}

unint64_t sub_10004D284()
{
  unint64_t result = qword_10047E1B0;
  if (!qword_10047E1B0)
  {
    type metadata accessor for MBDryRestoreState();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E1B0);
  }
  return result;
}

uint64_t sub_10004D2DC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = sub_100006FC8(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_10004D340(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 16))
  {
    Hasher.init(_seed:)();
    String.hash(into:)();
    Swift::Int v6 = Hasher._finalize()();
    uint64_t v7 = -1 << *(unsigned char *)(a3 + 32);
    unint64_t v8 = v6 & ~v7;
    uint64_t v9 = a3 + 56;
    if ((*(void *)(a3 + 56 + ((v8 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v8))
    {
      uint64_t v10 = *(void *)(a3 + 48);
      uint64_t v11 = (void *)(v10 + 16 * v8);
      BOOL v12 = *v11 == a1 && v11[1] == a2;
      if (v12 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
        return 1;
      }
      uint64_t v14 = ~v7;
      unint64_t v15 = (v8 + 1) & v14;
      if ((*(void *)(v9 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v15))
      {
        while (1)
        {
          uint64_t v16 = (void *)(v10 + 16 * v15);
          BOOL v17 = *v16 == a1 && v16[1] == a2;
          if (v17 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
            break;
          }
          uint64_t result = 0;
          unint64_t v15 = (v15 + 1) & v14;
          if (((*(void *)(v9 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v15) & 1) == 0) {
            return result;
          }
        }
        return 1;
      }
    }
  }
  return 0;
}

void sub_10004D478()
{
  sub_10000EB88();
  if (!v1)
  {
    sub_10000EF94();
    uint64_t v2 = *(void **)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
    uint64_t v3 = *(void *)(v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
    uint64_t v4 = *(void **)(v3 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress);
    uint64_t v5 = *(void *)(v3 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_backgroundDomainNames);
    id v10 = *(id *)(v3 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_foregroundDomainNames);
    id v6 = v4;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    sub_100011968(v5);
    sub_100015914((uint64_t)v10);
    swift_bridgeObjectRelease();
    Class isa = Set._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    id v10 = 0;
    LODWORD(v2) = [v2 addRemainingProgress:v6 forDomainNames:isa error:&v10];

    if (v2)
    {
      id v8 = v10;
      sub_1000101C4();
    }
    else
    {
      id v9 = v10;
      _convertNSErrorToError(_:)();

      swift_willThrow();
    }
  }
}

void sub_10004D620()
{
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v4 = *(char **)((char *)v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
  Swift::String v36 = *(char **)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_foregroundDomainNames];
  swift_bridgeObjectRetain();
  uint64_t v5 = swift_bridgeObjectRetain();
  sub_100011968(v5);
  uint64_t v6 = (uint64_t)v36;
  uint64_t v7 = *((void *)v36 + 2);
  if (v7)
  {
    uint64_t v34 = v2;
    id v35 = v0;
    id v8 = *(void **)((char *)v0 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
    swift_bridgeObjectRetain();
    id v9 = v36 + 40;
    for (uint64_t i = v7 - 1; ; --i)
    {
      swift_bridgeObjectRetain();
      NSString v11 = String._bridgeToObjectiveC()();
      swift_bridgeObjectRelease();
      Swift::String v36 = 0;
      unsigned int v12 = [v8 ingestFileListForDomainNamed:v11 error:&v36];

      if (!v12)
      {
        uint64_t v14 = v36;
        swift_bridgeObjectRelease_n();
        goto LABEL_12;
      }
      if (!i) {
        break;
      }
      v9 += 16;
      uint64_t v13 = v36;
    }
    unint64_t v15 = v36;
    swift_bridgeObjectRelease();
    uint64_t v2 = v34;
    uint64_t v3 = v35;
  }
  uint64_t v16 = *(void **)((char *)v3 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB);
  BOOL v17 = *(void **)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress];
  swift_bridgeObjectRetain();
  id v18 = v17;
  sub_100015914(v6);
  swift_bridgeObjectRelease();
  Class isa = Set._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  Swift::String v36 = 0;
  unsigned int v20 = [v16 addRemainingProgress:v18 forDomainNames:isa error:&v36];

  if (v20)
  {
    uint64_t v21 = v36;
    id v22 = sub_10000E990();
    uint64_t v23 = swift_bridgeObjectRetain();
    sub_100015914(v23);
    swift_bridgeObjectRelease();
    Class v24 = Set._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    [v22 setDomainNamesToForegroundRestore:v24];

    id v35 = &v33;
    __chkstk_darwin(v25);
    uint64_t v32[2] = v3;
    uint64_t v26 = v4;
    sub_1000159C8(v6, (uint64_t)v26);
    unint64_t v28 = v27;

    unint64_t v29 = v26;
    id v30 = v16;
    id v31 = v22;
    sub_10004E1C8(v28, sub_10004ED98, (uint64_t)v32, v30, v29, v31, 0);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();

    if (v2)
    {
    }
    else
    {
      sub_1000185E0(0xD00000000000001CLL, (void *)0x8000000100304850);

      swift_bridgeObjectRelease();
    }
  }
  else
  {
    uint64_t v14 = v36;
    swift_bridgeObjectRelease();
LABEL_12:
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }
}

void sub_10004D9E0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2;
  uint64_t v7 = *(char **)&v2[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context];
  uint64_t v8 = *(void *)&v7[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_backgroundDomainNames];
  swift_bridgeObjectRetain();
  char v9 = sub_10004D340(a1, a2, v8);
  swift_bridgeObjectRelease();
  uint64_t v51 = (void **)sub_100006FC8(&qword_10047D398);
  uint64_t inited = swift_initStackObject();
  long long v50 = xmmword_1003B1EF0;
  *(_OWORD *)(inited + 16) = xmmword_1003B1EF0;
  *(void *)(inited + 32) = a1;
  *(void *)(inited + 40) = a2;
  swift_bridgeObjectRetain();
  uint64_t v11 = sub_100015914(inited);
  swift_setDeallocating();
  swift_arrayDestroy();
  if (v9)
  {
    uint64_t v51 = v3;
    unsigned int v12 = v4;
    uint64_t v13 = *(void **)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB];
    NSString v14 = String._bridgeToObjectiveC()();
    id v52 = 0;
    unsigned int v15 = [v13 ingestFileListForDomainNamed:v14 error:&v52];

    if (!v15) {
      goto LABEL_11;
    }
    uint64_t v16 = v7;
    BOOL v17 = *(void **)&v7[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress];
    id v18 = v52;
    id v19 = v17;
    uint64_t v20 = v11;
    Class isa = Set._bridgeToObjectiveC()().super.isa;
    id v52 = 0;
    unsigned int v22 = [v13 addRemainingProgress:v19 forDomainNames:isa error:&v52];

    id v24 = v52;
    if (!v22)
    {
LABEL_11:
      id v41 = v52;
      swift_bridgeObjectRelease();
      _convertNSErrorToError(_:)();

      swift_willThrow();
      return;
    }
    __chkstk_darwin(v23);
    uint64_t v47 = v12;
    uint64_t v25 = v16;
    id v26 = v13;
    id v27 = v24;
    sub_100015B38(v20, v25, v26, 0, (uint64_t (*)(void *))sub_10004ED7C);
    swift_bridgeObjectRelease();

    if (v51) {
      return;
    }
    sub_1000185E0(0xD00000000000001CLL, (void *)0x8000000100304870);
  }
  else
  {
    id v28 = sub_10000E990();
    int v49 = *(void **)&v4[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB];
    sub_10000ECA8(v49, v28);
    if (v3)
    {
      swift_bridgeObjectRelease();

      return;
    }
    uint64_t v48 = v4;
    id v29 = *(id *)&v7[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress];
    Class v30 = Set._bridgeToObjectiveC()().super.isa;
    swift_bridgeObjectRelease();
    id v52 = 0;
    unsigned int v31 = [v49 addRemainingProgress:v29 forDomainNames:v30 error:&v52];

    id v32 = v52;
    if (!v31)
    {
      id v42 = v52;
      _convertNSErrorToError(_:)();

      swift_willThrow();
      return;
    }
    uint64_t v33 = swift_initStackObject();
    uint64_t v51 = &v48;
    *(_OWORD *)(v33 + 16) = v50;
    *(void *)(v33 + 32) = a1;
    *(void *)&long long v50 = v33 + 32;
    *(void *)(v33 + 40) = a2;
    __chkstk_darwin(v33);
    uint64_t v47 = v48;
    swift_bridgeObjectRetain();
    uint64_t v34 = v7;
    id v35 = v32;
    sub_1000159C8(v33, (uint64_t)v34);
    unint64_t v37 = v36;

    id v38 = v34;
    uint64_t v39 = v49;
    id v40 = v28;
    sub_10004E1C8(v37, sub_10004ED98, (uint64_t)&v46, v39, v38, v40, 0);
    swift_bridgeObjectRelease();

    swift_setDeallocating();
    swift_arrayDestroy();
    id v43 = v48;
    sub_1000185E0(0xD00000000000001CLL, (void *)0x8000000100304850);
    swift_bridgeObjectRelease();
    sub_10000F7D8(v39, v38, v43);
    sub_1000185E0(v44, v45);

    swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
}

uint64_t type metadata accessor for MBRestoreDomainCommand()
{
  return self;
}

unint64_t sub_10004E118(void *a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(*(void *)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context)
                 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_contentPath);
  swift_retain();
  id v4 = [a1 name];
  uint64_t v5 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v7 = v6;

  unint64_t v8 = sub_10002D538(v5, v7, v3);
  swift_release();
  swift_bridgeObjectRelease();
  return v8;
}

void *sub_10004E1C8(unint64_t a1, uint64_t (*a2)(void), uint64_t a3, void *a4, void *a5, void *a6, void *a7)
{
  if (a1 >> 62) {
    goto LABEL_16;
  }
  uint64_t v7 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  while (1)
  {
    uint64_t result = _swiftEmptyArrayStorage;
    if (!v7) {
      break;
    }
    id v45 = _swiftEmptyArrayStorage;
    specialized ContiguousArray.reserveCapacity(_:)();
    if (v7 < 0) {
      __break(1u);
    }
    uint64_t v9 = 0;
    uint64_t v32 = v7;
    while (v7 != v9)
    {
      if ((a1 & 0xC000000000000001) != 0) {
        id v10 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
      }
      else {
        id v10 = *(id *)(a1 + 8 * v9 + 32);
      }
      uint64_t v11 = v10;
      uint64_t v12 = a2();
      id v44 = 0;
      id v13 = [a4 planForDomain:v11 restoreType:1 error:&v44];
      id v14 = v44;
      if (!v13)
      {
        id v31 = v44;
        _convertNSErrorToError(_:)();

        swift_willThrow();
        swift_release();
        return (void *)swift_release();
      }
      id v15 = v13;
      uint64_t v42 = v9 + 1;
      id v40 = v11;
      uint64_t v16 = (id (*)(void *))swift_allocObject();
      *((void *)v16 + 2) = a5;
      *((void *)v16 + 3) = v12;
      *((void *)v16 + 4) = a6;
      *((void *)v16 + 5) = v15;
      *((void *)v16 + 6) = a7;
      id v41 = (objc_class *)type metadata accessor for _DryRestoreDomainOperation();
      BOOL v17 = (char *)objc_allocWithZone(v41);
      uint64_t v39 = OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engine;
      sub_100006FC8(&qword_10047E260);
      uint64_t v18 = swift_allocObject();
      type metadata accessor for MBUnfairLock();
      uint64_t v19 = swift_allocObject();
      swift_retain();
      id v20 = a6;
      id v21 = a7;
      unsigned int v22 = v17;
      uint64_t v7 = v32;
      id v23 = a5;
      id v24 = v14;
      id v25 = v40;
      id v26 = (_DWORD *)swift_slowAlloc();
      *(void *)(v19 + 16) = v26;
      _DWORD *v26 = 0;
      *(void *)(v18 + 16) = v19;
      *(void *)(v18 + 24) = 0;
      *(void *)&v17[v39] = v18;
      *(void *)&v22[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__context] = v23;
      *(void *)&v22[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__restorePath] = v12;
      *(void *)&v22[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__domain] = v25;
      id v27 = (id (**)(void *))&v22[OBJC_IVAR____TtC7backupdP33_A98A1189104A0FB44C8DB626A50FE70726_DryRestoreDomainOperation__engineCreationBlock];
      *id v27 = sub_10004ED58;
      v27[1] = v16;
      id v28 = v23;
      uint64_t v9 = v42;
      id v29 = v28;
      id v30 = v25;
      swift_retain();
      swift_retain();

      v43.receiver = v22;
      v43.super_class = v41;
      objc_msgSendSuper2(&v43, "init");

      swift_release();
      swift_release();
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
      specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
      specialized ContiguousArray._endMutation()();
      if (v32 == v42) {
        return v45;
      }
    }
    __break(1u);
LABEL_16:
    swift_bridgeObjectRetain();
    uint64_t v7 = _CocoaArrayWrapper.endIndex.getter();
    swift_bridgeObjectRelease();
  }
  return result;
}

void sub_10004E54C(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, void *a9, Swift::String *a10)
{
  uint64_t v40 = a8;
  _StringGuts.grow(_:)(25);
  swift_bridgeObjectRelease();
  v16._countAndFlagsBits = a1;
  v16._object = a2;
  String.append(_:)(v16);
  v17._countAndFlagsBits = 544497952;
  v17._object = (void *)0xE400000000000000;
  String.append(_:)(v17);
  v18._countAndFlagsBits = a3;
  v18._object = a4;
  String.append(_:)(v18);
  sub_100045F18(0xD000000000000011, 0x80000001003080E0, 0xD000000000000011, 0x80000001003080C0);
  swift_bridgeObjectRelease();
  sub_100006FC8((uint64_t *)&unk_10047D910);
  unint64_t v19 = swift_allocBox();
  swift_bridgeObjectRetain();
  FilePath.init(_:)();
  sub_100007F74(511, v19);
  if (v10)
  {
    swift_release();
    return;
  }
  id v20 = a9;
  uint64_t v36 = a1;
  BOOL v21 = a1 == 0x4742747365676E49 && a2 == (void *)0xE800000000000000;
  char v22 = v21;
  char v35 = v22;
  char v23 = 1;
  if (!v21)
  {
    if ((_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0
      || a1 == 0x756F726765726F46 && a2 == (void *)0xEA0000000000646ELL)
    {
      goto LABEL_23;
    }
    char v24 = _stringCompareWithSmolCheck(_:_:expecting:)();
    BOOL v26 = a1 == 0x756F72676B636142 && a2 == (void *)0xEA0000000000646ELL;
    char v23 = 1;
    if (v24) {
      goto LABEL_24;
    }
    id v20 = a9;
    if (v26) {
      goto LABEL_25;
    }
    if ((_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0 || a1 == 4412481 && a2 == (void *)0xE300000000000000) {
LABEL_23:
    }
      char v23 = 1;
    else {
      char v23 = _stringCompareWithSmolCheck(_:_:expecting:)();
    }
LABEL_24:
    id v20 = a9;
  }
LABEL_25:
  char v27 = v23 ^ 1;
  id v28 = (char *)sub_10001A794(v19, v19, a5, a6, a7, v40, (v23 ^ 1) & 1, v20, a10, 0, 1);
  if (v36 == 0x4746747365676E49 && a2 == (void *)0xE800000000000000
    || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    sub_10000EB88();
  }
  else if (v35 & 1) != 0 || (_stringCompareWithSmolCheck(_:_:expecting:)())
  {
    sub_10000EF94();
  }
  else if (v36 == 0x756F726765726F46 && a2 == (void *)0xEA0000000000646ELL {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    sub_10000F214();
  }
  else
  {
    if ((v36 != 0x756F72676B636142 || a2 != (void *)0xEA0000000000646ELL)
      && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      if (v36 == 4412481 && a2 == (void *)0xE300000000000000
        || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
      {
        sub_100045F18(0xD000000000000014, 0x80000001003048B0, 0xD000000000000016, 0x80000001003047B0);
        sub_10000F878(*(void **)&v28[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_planDB], *(char **)&v28[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context], v28);
        char v29 = v27;
        sub_1000185E0(v33, v34);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      else if (v36 == 0xD000000000000012 && a2 == (void *)0x8000000100308100 {
             || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
      }
      {
        char v29 = v27;
        sub_10004D478();
      }
      else
      {
        char v29 = v27;
        if (v36 == 0x6968747972657645 && a2 == (void *)0xEE0074736146676ELL
          || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
        {
          sub_10004D620();
        }
        else
        {
          sub_10004D9E0(v36, (uint64_t)a2);
        }
      }
      goto LABEL_32;
    }
    sub_10000F5B0();
  }
  char v29 = v27;
LABEL_32:
  sub_10000E340((uint64_t)v39);
  v30._countAndFlagsBits = 0x3A7972616D6D7553;
  v30._object = (void *)0xE900000000000020;
  String.append(_:)(v30);
  v31._countAndFlagsBits = sub_10001D890();
  String.append(_:)(v31);
  swift_bridgeObjectRelease();
  v32._countAndFlagsBits = 10;
  v32._object = (void *)0xE100000000000000;
  String.append(_:)(v32);
  _print_unlocked<A, B>(_:_:)();
  sub_100045F18(0, 0xE000000000000000, 0xD000000000000011, 0x80000001003080C0);
  swift_bridgeObjectRelease();
  sub_100019070(v29 & 1);
  if (sub_10000E134()) {
    swift_willThrow();
  }
  swift_release();
}

uint64_t sub_10004ECFC()
{
  swift_release();
  swift_unknownObjectRelease();

  return _swift_deallocObject(v0, 56, 7);
}

id sub_10004ED58(void *a1)
{
  return sub_100011128(a1, *(void *)(v1 + 16), *(void *)(v1 + 24), *(void **)(v1 + 32), *(void *)(v1 + 40), *(void **)(v1 + 48));
}

unint64_t sub_10004ED7C(void *a1)
{
  return sub_10004E118(a1, *(void *)(v1 + 16));
}

uint64_t sub_10004ED9C(char a1, char a2)
{
  BOOL v2 = (a1 & 1) == 0;
  if (a1) {
    uint64_t v3 = 0x696D694C72657375;
  }
  else {
    uint64_t v3 = 0x636170536B736964;
  }
  if (v2) {
    unint64_t v4 = 0xE900000000000065;
  }
  else {
    unint64_t v4 = 0xE900000000000074;
  }
  if (a2) {
    uint64_t v5 = 0x696D694C72657375;
  }
  else {
    uint64_t v5 = 0x636170536B736964;
  }
  if (a2) {
    unint64_t v6 = 0xE900000000000074;
  }
  else {
    unint64_t v6 = 0xE900000000000065;
  }
  if (v3 == v5 && v4 == v6) {
    char v7 = 1;
  }
  else {
    char v7 = _stringCompareWithSmolCheck(_:_:expecting:)();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v7 & 1;
}

uint64_t sub_10004EE48(unsigned __int8 a1, char a2)
{
  uint64_t v2 = 0x73736563637573;
  unint64_t v3 = 0xE700000000000000;
  uint64_t v4 = a1;
  unint64_t v5 = 0x73736563637573;
  switch(v4)
  {
    case 1:
      unint64_t v3 = 0xE600000000000000;
      unint64_t v5 = 0x64656C696166;
      break;
    case 2:
      unint64_t v5 = 0x7075727265746E69;
      unint64_t v3 = 0xEB00000000646574;
      break;
    case 3:
      unint64_t v3 = 0xE500000000000000;
      unint64_t v5 = 0x7465736572;
      break;
    case 4:
      unint64_t v3 = 0x8000000100303DE0;
      unint64_t v5 = 0xD000000000000017;
      break;
    case 5:
      unint64_t v5 = 0x6E6F6F536F6F74;
      break;
    case 6:
      unint64_t v3 = 0xE800000000000000;
      unint64_t v5 = 0x6576697463616E69;
      break;
    default:
      break;
  }
  unint64_t v6 = 0xE700000000000000;
  switch(a2)
  {
    case 1:
      unint64_t v6 = 0xE600000000000000;
      if (v5 == 0x64656C696166) {
        goto LABEL_19;
      }
      goto LABEL_22;
    case 2:
      unint64_t v6 = 0xEB00000000646574;
      if (v5 != 0x7075727265746E69) {
        goto LABEL_22;
      }
      goto LABEL_19;
    case 3:
      unint64_t v6 = 0xE500000000000000;
      if (v5 != 0x7465736572) {
        goto LABEL_22;
      }
      goto LABEL_19;
    case 4:
      unint64_t v6 = 0x8000000100303DE0;
      if (v5 != 0xD000000000000017) {
        goto LABEL_22;
      }
      goto LABEL_19;
    case 5:
      uint64_t v2 = 0x6E6F6F536F6F74;
      goto LABEL_18;
    case 6:
      unint64_t v6 = 0xE800000000000000;
      if (v5 != 0x6576697463616E69) {
        goto LABEL_22;
      }
      goto LABEL_19;
    default:
LABEL_18:
      if (v5 != v2) {
        goto LABEL_22;
      }
LABEL_19:
      if (v3 == v6) {
        char v7 = 1;
      }
      else {
LABEL_22:
      }
        char v7 = _stringCompareWithSmolCheck(_:_:expecting:)();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return v7 & 1;
  }
}

uint64_t sub_10004F094(unsigned __int8 a1, unsigned __int8 a2)
{
  unint64_t v2 = 0xD000000000000010;
  unint64_t v3 = 0x8000000100303D50;
  int v4 = a1;
  if (a1)
  {
    if (a1 == 1) {
      unint64_t v5 = 0x756C6F5673667061;
    }
    else {
      unint64_t v5 = 0x6E6F697461657263;
    }
    if (v4 == 1) {
      unint64_t v6 = 0xEE0044495555656DLL;
    }
    else {
      unint64_t v6 = 0xEC00000065746144;
    }
    int v7 = a2;
    if (!a2) {
      goto LABEL_15;
    }
    goto LABEL_9;
  }
  unint64_t v5 = 0xD000000000000010;
  unint64_t v6 = 0x8000000100303D50;
  int v7 = a2;
  if (a2)
  {
LABEL_9:
    if (v7 == 1) {
      unint64_t v2 = 0x756C6F5673667061;
    }
    else {
      unint64_t v2 = 0x6E6F697461657263;
    }
    if (v7 == 1) {
      unint64_t v3 = 0xEE0044495555656DLL;
    }
    else {
      unint64_t v3 = 0xEC00000065746144;
    }
  }
LABEL_15:
  if (v5 == v2 && v6 == v3) {
    char v8 = 1;
  }
  else {
    char v8 = _stringCompareWithSmolCheck(_:_:expecting:)();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v8 & 1;
}

uint64_t sub_10004F1CC()
{
  String.hash(into:)();
  return swift_bridgeObjectRelease();
}

Swift::Int sub_10004F2E8()
{
  return Hasher._finalize()();
}

uint64_t sub_10004F414(uint64_t a1)
{
  uint64_t v3 = sub_100006FC8(&qword_10047D708);
  __chkstk_darwin(v3 - 8);
  unint64_t v5 = (char *)&v18 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100045F18(0xD000000000000010, 0x80000001003081B0, 0xD000000000000018, 0x8000000100307FD0);
  uint64_t v6 = *(void *)(a1 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
  uint64_t v8 = *(void *)(v6 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_accountUUID);
  uint64_t v7 = *(void *)(v6 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_accountUUID + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)uint64_t v1 = v8;
  *(void *)(v1 + 8) = v7;
  uint64_t v9 = v6 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_snapshotUUID;
  uint64_t v11 = *(void *)(v6 + OBJC_IVAR____TtC7backupd19MBDryRestoreContext_snapshotUUID);
  uint64_t v10 = *(void *)(v9 + 8);
  swift_bridgeObjectRetain();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)(v1 + 16) = v11;
  *(void *)(v1 + 24) = v10;
  uint64_t v13 = *(void *)(v1 + 48);
  if (*(unsigned char *)(v1 + 56)) {
    uint64_t v13 = 0;
  }
  BOOL v14 = __CFADD__(v13, 1);
  uint64_t v15 = v13 + 1;
  if (v14)
  {
    __break(1u);
  }
  else
  {
    *(void *)(v1 + 48) = v15;
    *(unsigned char *)(v1 + 56) = 0;
    static Date.now.getter();
    uint64_t v16 = type metadata accessor for Date();
    (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56))(v5, 0, 1, v16);
    uint64_t v17 = type metadata accessor for MBDryRestoreState();
    return sub_10002C7D8((uint64_t)v5, v1 + *(int *)(v17 + 36));
  }
  return result;
}

void *sub_10004F5B4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = v2;
  char v35 = a2;
  uint64_t v5 = sub_100006FC8(&qword_10047D708);
  __chkstk_darwin(v5 - 8);
  uint64_t v7 = (char *)&v32 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for Date();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = __chkstk_darwin(v8);
  uint64_t v12 = (char *)&v32 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v10);
  BOOL v14 = (char *)&v32 - v13;
  unint64_t v34 = (unint64_t)"Dry restore summary: ";
  sub_100045F18(0xD00000000000001ELL, 0x8000000100308140, 0xD000000000000018, 0x8000000100307FD0);
  static Date.now.getter();
  uint64_t v15 = (int *)type metadata accessor for MBDryRestoreState();
  uint64_t v16 = v3 + v15[9];
  sub_100048E78(v16, (uint64_t)v7);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v9 + 48))(v7, 1, v8) == 1)
  {
    sub_100052D98((uint64_t)v7);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v12, v7, v8);
    Date.timeIntervalSince(_:)();
    uint64_t v18 = v17;
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
    uint64_t v19 = v3 + v15[13];
    *(void *)uint64_t v19 = v18;
    *(unsigned char *)(v19 + 8) = 0;
  }
  id v20 = (void *)(a1 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession__selection);
  swift_beginAccess();
  uint64_t v21 = v20[12];
  if ((v21 & 0x8000000000000000) == 0)
  {
    BOOL v22 = __CFADD__(v21, *v20);
    uint64_t v23 = v21 + *v20;
    if (!v22)
    {
      uint64_t v24 = v3 + v15[14];
      *(void *)uint64_t v24 = v23;
      *(unsigned char *)(v24 + 8) = 0;
      sub_100050D24(0, a1, (uint64_t)v36);
      sub_100052D98(v16);
      id v25 = *(void (**)(uint64_t, char *, uint64_t))(v9 + 16);
      v25(v16, v14, v8);
      uint64_t v33 = v15;
      uint64_t v26 = v16;
      uint64_t v27 = v8;
      id v28 = *(void (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 56);
      v28(v26, 0, 1, v27);
      uint64_t v29 = v3 + v15[10];
      sub_100052D98(v29);
      v25(v29, v14, v27);
      v28(v29, 0, 1, v27);
      sub_100045F18(0xD000000000000010, 0x8000000100308160, 0xD000000000000018, v34 | 0x8000000000000000);
      swift_bridgeObjectRelease();
      *(void *)uint64_t v3 = 0;
      *(void *)(v3 + 8) = 0;
      swift_bridgeObjectRelease();
      *(void *)(v3 + 48) = 0;
      *(void *)(v3 + 16) = 0;
      *(void *)(v3 + 24) = 0;
      *(unsigned char *)(v3 + 56) = 1;
      uint64_t v30 = v3 + v33[12];
      *(void *)uint64_t v30 = 0;
      *(unsigned char *)(v30 + 8) = 1;
      *(void *)(v3 + 32) = 0;
      *(unsigned char *)(v3 + 40) = 1;
      (*(void (**)(char *, uint64_t))(v9 + 8))(v14, v27);
      return memcpy(v35, v36, 0x229uLL);
    }
    __break(1u);
  }
  uint64_t result = (void *)_assertionFailure(_:_:file:line:flags:)();
  __break(1u);
  return result;
}

unint64_t sub_10004F9C8(char a1)
{
  unint64_t result = 0x7274656D656C6574;
  switch(a1)
  {
    case 1:
      unint64_t result = 0x6574617473;
      break;
    case 2:
      unint64_t result = 0x4374706D65747461;
      break;
    case 3:
      unint64_t result = 0x6C617461466E6F6ELL;
      break;
    case 4:
      unint64_t result = 0x54746E756F636361;
      break;
    case 5:
      unint64_t result = 0xD000000000000022;
      break;
    case 6:
      unint64_t result = 0x446572756C696166;
      break;
    case 7:
      unint64_t result = 0x436572756C696166;
      break;
    case 8:
    case 27:
    case 28:
    case 32:
    case 33:
    case 40:
      unint64_t result = 0xD000000000000012;
      break;
    case 9:
      unint64_t result = 0xD000000000000010;
      break;
    case 10:
      unint64_t result = 0xD000000000000011;
      break;
    case 11:
      unint64_t result = 0x6575716552727474;
      break;
    case 12:
      unint64_t result = 0x7065636341727474;
      break;
    case 13:
      unint64_t result = 0xD000000000000016;
      break;
    case 14:
      unint64_t result = 0xD000000000000013;
      break;
    case 15:
      unint64_t result = 0xD000000000000016;
      break;
    case 16:
      unint64_t result = 0xD000000000000014;
      break;
    case 17:
      unint64_t result = 0xD000000000000013;
      break;
    case 18:
      unint64_t result = 0xD000000000000014;
      break;
    case 19:
      unint64_t result = 0xD000000000000011;
      break;
    case 20:
      unint64_t result = 0xD000000000000010;
      break;
    case 21:
      unint64_t result = 0xD000000000000010;
      break;
    case 22:
      unint64_t result = 0xD000000000000010;
      break;
    case 23:
      unint64_t result = 0xD000000000000010;
      break;
    case 24:
      unint64_t result = 0xD000000000000011;
      break;
    case 25:
      unint64_t result = 0xD000000000000018;
      break;
    case 26:
      unint64_t result = 0xD000000000000019;
      break;
    case 29:
      unint64_t result = 0xD000000000000014;
      break;
    case 30:
      unint64_t result = 0xD000000000000014;
      break;
    case 31:
      unint64_t result = 0x6F6D654D6B616570;
      break;
    case 34:
      unint64_t result = 0xD000000000000011;
      break;
    case 35:
      unint64_t result = 0x7269446C61746F74;
      break;
    case 36:
      unint64_t result = 0xD000000000000013;
      break;
    case 37:
      unint64_t result = 0xD000000000000018;
      break;
    case 38:
      unint64_t result = 0xD000000000000014;
      break;
    case 39:
      unint64_t result = 0xD00000000000001BLL;
      break;
    case 41:
      unint64_t result = 0xD000000000000015;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_10004FEB8(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v5 = sub_100006FC8(&qword_10047E280);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = &v10[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_10000700C(a1, a1[3]);
  sub_100053AA8();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v10[0] = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v2)
  {
    v10[0] = *(unsigned char *)(v3 + 8);
    char v11 = 1;
    sub_100053AFC();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    v10[0] = 2;
    KeyedEncodingContainer.encode(_:forKey:)();
    v10[0] = 3;
    KeyedEncodingContainer.encode(_:forKey:)();
    sub_10004D028(v3 + 32, (uint64_t)v12, &qword_10047E298);
    sub_10004D028((uint64_t)v12, (uint64_t)v10, &qword_10047E298);
    char v11 = 4;
    type metadata accessor for MBAccountType(0);
    sub_100053B50(&qword_10047E2A0, type metadata accessor for MBAccountType);
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    v10[0] = 5;
    KeyedEncodingContainer.encode(_:forKey:)();
    v10[0] = 6;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 7;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 8;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 9;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 10;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 11;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 12;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 13;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 14;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 15;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 16;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 17;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 18;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 19;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 20;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 21;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 22;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 23;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 24;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 25;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 26;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 27;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 28;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 29;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 30;
    KeyedEncodingContainer.encode(_:forKey:)();
    v10[0] = 31;
    KeyedEncodingContainer.encode(_:forKey:)();
    v10[0] = 32;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 33;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 34;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 35;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 36;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 37;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 38;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 39;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 40;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v10[0] = 41;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v6 + 8))(v8, v5);
}

unint64_t sub_10005074C(char a1)
{
  unint64_t result = 0x73736563637573;
  switch(a1)
  {
    case 1:
      unint64_t result = 0x64656C696166;
      break;
    case 2:
      unint64_t result = 0x7075727265746E69;
      break;
    case 3:
      unint64_t result = 0x7465736572;
      break;
    case 4:
      unint64_t result = 0xD000000000000017;
      break;
    case 5:
      unint64_t result = 0x6E6F6F536F6F74;
      break;
    case 6:
      unint64_t result = 0x6576697463616E69;
      break;
    default:
      return result;
  }
  return result;
}

unint64_t sub_100050834()
{
  return sub_10004F9C8(*v0);
}

uint64_t sub_10005083C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = sub_100054020(a1, a2);
  *a3 = result;
  return result;
}

void sub_100050864(unsigned char *a1@<X8>)
{
  *a1 = 42;
}

uint64_t sub_100050870(uint64_t a1)
{
  unint64_t v2 = sub_100053AA8();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000508AC(uint64_t a1)
{
  unint64_t v2 = sub_100053AA8();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000508E8(void *a1)
{
  memcpy(v4, v1, sizeof(v4));
  return sub_10004FEB8(a1);
}

uint64_t sub_10005093C(unsigned __int8 *a1, char *a2)
{
  return sub_10004EE48(*a1, *a2);
}

Swift::Int sub_100050948()
{
  return sub_10004F2E8();
}

uint64_t sub_100050954()
{
  return sub_10004F1CC();
}

Swift::Int sub_10005095C()
{
  return sub_10004F2E8();
}

unint64_t sub_100050964@<X0>(Swift::String *a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t result = sub_100055010(*a1);
  *a2 = result;
  return result;
}

unint64_t sub_100050994@<X0>(unint64_t *a1@<X8>)
{
  unint64_t result = sub_10005074C(*v1);
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t sub_1000509C0()
{
  return RawRepresentable<>.encode(to:)();
}

uint64_t sub_100050A10()
{
  return RawRepresentable<>.encode(to:)();
}

uint64_t sub_100050A90()
{
  return RawRepresentable<>.encode(to:)();
}

void sub_100050B10()
{
  sub_100049AA0();
  _StringGuts.grow(_:)(33);
  swift_bridgeObjectRelease();
  v0._countAndFlagsBits = Dictionary.description.getter();
  String.append(_:)(v0);
  swift_bridgeObjectRelease();
  sub_100045F18(0xD00000000000001FLL, 0x8000000100308200, 0xD000000000000018, 0x8000000100307FD0);
  swift_bridgeObjectRelease();
  uint64_t v1 = self;
  Class isa = Dictionary._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  [v1 sendDryRestoreEvent:isa];
}

double sub_100050D24@<D0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = sub_100006FC8(&qword_10047D708);
  uint64_t v9 = __chkstk_darwin(v8 - 8);
  char v11 = (char *)&v95 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = __chkstk_darwin(v9);
  int v119 = (char *)&v95 - v13;
  __chkstk_darwin(v12);
  uint64_t v15 = (char *)&v95 - v14;
  uint64_t v16 = type metadata accessor for Date();
  uint64_t v133 = *(void *)(v16 - 8);
  uint64_t v17 = __chkstk_darwin(v16);
  uint64_t v118 = (char *)&v95 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v19 = __chkstk_darwin(v17);
  uint64_t v21 = (char *)&v95 - v20;
  uint64_t v22 = __chkstk_darwin(v19);
  uint64_t v24 = (char *)&v95 - v23;
  uint64_t v25 = __chkstk_darwin(v22);
  uint64_t v135 = (char *)&v95 - v26;
  uint64_t v131 = v25;
  int v124 = a1;
  int v123 = v11;
  if (a2)
  {
    uint64_t v27 = *(char **)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context);
    id v28 = (uint64_t *)(a2 + OBJC_IVAR____TtC7backupd19MBDryRestoreSession__selection);
    swift_beginAccess();
    uint64_t v29 = *v28;
    uint64_t v30 = v28[1];
    uint64_t v136 = *((unsigned __int8 *)v28 + 16);
    uint64_t v96 = v28[3];
    uint64_t v97 = v30;
    uint64_t v31 = v28[5];
    uint64_t v128 = v28[6];
    uint64_t v129 = v29;
    uint64_t v32 = v28[11];
    uint64_t v125 = v31;
    uint64_t v126 = v32;
    uint64_t v127 = v28[13];
    uint64_t v121 = v28[14];
    int v132 = v27;
    uint64_t v33 = v27;
    uint64_t v16 = v131;
    sub_10000E340((uint64_t)&v213);
    long long v205 = v214;
    char v204 = v213;
    uint64_t v206 = v215;
    long long v207 = v216;
    long long v208 = v217;
    long long v209 = v218;
    long long v210 = v219;
    long long v211 = v220;
    uint64_t v212 = v221;
    sub_100052E38((uint64_t)&v204);
    sub_10004D028((uint64_t)&v204, (uint64_t)v222, &qword_10047E268);
  }
  else
  {
    sub_100052DF8((uint64_t)&v204);
    sub_10004D028((uint64_t)&v204, (uint64_t)v222, &qword_10047E268);
    uint64_t v128 = 0;
    uint64_t v129 = 0;
    uint64_t v96 = 0;
    uint64_t v97 = 0;
    uint64_t v125 = 0;
    uint64_t v126 = 0;
    uint64_t v127 = 0;
    uint64_t v121 = 0;
    int v132 = 0;
    uint64_t v136 = 2;
  }
  uint64_t v34 = v133;
  uint64_t v122 = MBFreeDiskSpace();
  char v35 = v135;
  static Date.now.getter();
  uint64_t v134 = (int *)type metadata accessor for MBDryRestoreState();
  sub_100048E78(v4 + v134[9], (uint64_t)v15);
  (*(void (**)(char *, char *, uint64_t))(v34 + 16))(v21, v35, v16);
  uint64_t v36 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v34 + 48);
  if (v36(v15, 1, v16) == 1)
  {
    uint64_t v117 = *(void (**)(char *, char *, uint64_t))(v34 + 32);
    v117(v24, v21, v16);
    sub_100052D98((uint64_t)v15);
  }
  else
  {
    (*(void (**)(char *, uint64_t))(v34 + 8))(v21, v16);
    uint64_t v117 = *(void (**)(char *, char *, uint64_t))(v34 + 32);
    v117(v24, v15, v16);
  }
  Date.timeIntervalSince(_:)();
  double v38 = v37;
  uint64_t v130 = *(void (**)(char *, uint64_t))(v34 + 8);
  v130(v24, v16);
  uint64_t v39 = v4 + v134[12];
  double v40 = *(double *)v39;
  if (*(unsigned char *)(v39 + 8)) {
    double v40 = 0.0;
  }
  *(double *)uint64_t v39 = v38 + v40;
  *(unsigned char *)(v39 + 8) = 0;
  if (v136 == 2)
  {
    int v120 = 2;
    LODWORD(v121) = 2;
  }
  else
  {
    char v41 = v121;
    if (v121)
    {
      if (v136)
      {
        char v42 = _stringCompareWithSmolCheck(_:_:expecting:)();
        swift_bridgeObjectRelease();
        char v41 = v42 ^ 1;
      }
      else
      {
        swift_bridgeObjectRelease();
        char v41 = 0;
        char v42 = 1;
      }
    }
    else
    {
      char v42 = 0;
    }
    int v120 = v41 & 1;
    LODWORD(v121) = v42 & 1;
  }
  uint64_t v43 = (uint64_t)v119;
  if (*(unsigned char *)(v4 + 40) == 1)
  {
    char v204 = 0;
    swift_stdlib_random();
    id v44 = v204;
  }
  else
  {
    id v44 = *(char **)(v4 + 32);
  }
  id v45 = v132;
  *(void *)(v4 + 32) = v44;
  *(unsigned char *)(v4 + 40) = 0;
  uint64_t v46 = *(void *)(v4 + 48);
  int v47 = *(unsigned __int8 *)(v4 + 56);
  uint64_t v48 = *(void *)(v4 + 64);
  int v49 = *(unsigned __int8 *)(v4 + 72);
  int v119 = v44;
  uint64_t v113 = v46;
  int v112 = v47;
  uint64_t v110 = v48;
  int v108 = v49;
  if (v45) {
    id v95 = [*(id *)&v45[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_persona] accountType];
  }
  else {
    id v95 = 0;
  }
  sub_100048E78(v4 + v134[17], v43);
  if (v36((char *)v43, 1, v16) == 1)
  {
    sub_100052D98(v43);
    BOOL v101 = 0;
  }
  else
  {
    long long v50 = v118;
    v117(v118, (char *)v43, v16);
    Date.timeIntervalSinceNow.getter();
    double v52 = v51;
    v130(v50, v16);
    BOOL v101 = v52 < -259200.0;
  }
  if (v136 == 2)
  {
    uint64_t v128 = 0;
    uint64_t v129 = 0;
    uint64_t v126 = 0;
    uint64_t v127 = 0;
    uint64_t v125 = 0;
  }
  double v102 = *(double *)v39;
  char v53 = *(unsigned char *)(v39 + 8);
  sub_10004D028((uint64_t)v222, (uint64_t)&v204, &qword_10047E268);
  int v54 = sub_100052E1C((uint64_t)&v204);
  if (v54 == 1)
  {
    uint64_t v117 = 0;
    uint64_t v118 = 0;
    uint64_t v116 = 0;
    uint64_t v111 = 0;
    uint64_t v114 = 0;
  }
  else
  {
    uint64_t v114 = v210;
    sub_10004D028((uint64_t)v222, (uint64_t)v203, &qword_10047E268);
    uint64_t v111 = v203[11];
    uint64_t v116 = v203[12];
    uint64_t v117 = (void (*)(char *, char *, uint64_t))v203[13];
    uint64_t v118 = (char *)v203[14];
  }
  sub_10004D028((uint64_t)v222, (uint64_t)v203, &qword_10047E268);
  int v55 = sub_100052E1C((uint64_t)v203);
  if (v55 == 1)
  {
    uint64_t v115 = 0;
    uint64_t v104 = 0;
    uint64_t v106 = 0;
  }
  else
  {
    uint64_t v106 = v203[1];
    sub_10004D028((uint64_t)v222, (uint64_t)v202, &qword_10047E268);
    uint64_t v115 = v202[0];
    uint64_t v104 = v202[2];
  }
  uint64_t v107 = MBPeakProcessMemoryUsage();
  sub_10004D028((uint64_t)v222, (uint64_t)v202, &qword_10047E268);
  int v56 = sub_100052E1C((uint64_t)v202);
  if (v56 == 1)
  {
    double v105 = 0.0;
    uint64_t v109 = 0;
    uint64_t v103 = 0;
    uint64_t v99 = 0;
    uint64_t v100 = 0;
    uint64_t v98 = 0;
    double v57 = 0.0;
    double v58 = 0.0;
  }
  else
  {
    uint64_t v99 = v202[8];
    sub_10004D028((uint64_t)v222, (uint64_t)v137, &qword_10047E268);
    uint64_t v98 = v140;
    uint64_t v100 = v141;
    uint64_t v103 = v142;
    uint64_t v109 = v143;
    double v57 = (double)v139 / v138;
    double v105 = v138;
    double v58 = (double)*(unint64_t *)&v137[1] / v137[0] * 0.000000953674316;
  }
  BOOL v59 = v56 == 1;
  BOOL v60 = v55 == 1;
  uint64_t v61 = v132;
  BOOL v201 = v132 == 0;
  char v198 = 1;
  char v194 = 0;
  char v192 = v53;
  BOOL v62 = v136 == 2;
  BOOL v63 = v136 == 2;
  BOOL v190 = v136 == 2;
  BOOL v188 = v136 == 2;
  uint64_t v64 = v97;
  if (v136 == 2) {
    uint64_t v64 = 0;
  }
  uint64_t v136 = v64;
  if (v62) {
    uint64_t v65 = 0;
  }
  else {
    uint64_t v65 = v96;
  }
  BOOL v186 = v63;
  if (v108) {
    uint64_t v66 = 0;
  }
  else {
    uint64_t v66 = v110;
  }
  BOOL v184 = v63;
  if (v112) {
    uint64_t v67 = 0;
  }
  else {
    uint64_t v67 = v113;
  }
  BOOL v182 = v63;
  BOOL v180 = v54 == 1;
  BOOL v178 = v54 == 1;
  BOOL v176 = v54 == 1;
  BOOL v174 = v54 == 1;
  BOOL v172 = v54 == 1;
  BOOL v170 = v63;
  BOOL v168 = v60;
  BOOL v166 = v60;
  BOOL v164 = v60;
  BOOL v162 = v63;
  BOOL v158 = v59;
  BOOL v156 = v59;
  BOOL v154 = v59;
  BOOL v152 = v59;
  BOOL v150 = v59;
  BOOL v148 = v59;
  BOOL v146 = v59;
  BOOL v144 = v59;
  uint64_t v68 = (uint64_t)v123;
  static Date.now.getter();

  uint64_t v69 = v131;
  v130(v135, v131);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v133 + 56))(v68, 0, 1, v69);
  sub_10002C7D8(v68, v4 + v134[11]);
  *(void *)a3 = v119;
  *(unsigned char *)(a3 + 8) = v124;
  *(void *)(a3 + 16) = v67;
  *(void *)(a3 + 24) = v66;
  *(_DWORD *)(a3 + 9) = LODWORD(v137[0]);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)((char *)v137 + 3);
  *(void *)(a3 + 32) = v95;
  *(unsigned char *)(a3 + 40) = v201;
  *(unsigned char *)(a3 + 41) = v101;
  *(_DWORD *)(a3 + 42) = v199;
  *(_WORD *)(a3 + 46) = v200;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  *(void *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 72) = v198;
  *(_DWORD *)(a3 + 73) = *(_DWORD *)v197;
  *(_DWORD *)(a3 + 76) = *(_DWORD *)&v197[3];
  double result = 0.0;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_WORD *)(a3 + 128) = 514;
  *(_DWORD *)(a3 + 130) = v195;
  *(_WORD *)(a3 + 134) = v196;
  *(double *)(a3 + 136) = v38;
  *(unsigned char *)(a3 + 144) = v194;
  int v71 = *(_DWORD *)v193;
  *(_DWORD *)(a3 + 148) = *(_DWORD *)&v193[3];
  *(_DWORD *)(a3 + 145) = v71;
  *(double *)(a3 + 152) = v102;
  *(unsigned char *)(a3 + 160) = v192;
  *(_DWORD *)(a3 + 164) = *(_DWORD *)&v191[3];
  *(_DWORD *)(a3 + 161) = *(_DWORD *)v191;
  *(void *)(a3 + 168) = v125;
  *(unsigned char *)(a3 + 176) = v190;
  *(_DWORD *)(a3 + 180) = *(_DWORD *)&v189[3];
  *(_DWORD *)(a3 + 177) = *(_DWORD *)v189;
  *(void *)(a3 + 184) = v126;
  *(unsigned char *)(a3 + 192) = v188;
  int v72 = *(_DWORD *)v187;
  *(_DWORD *)(a3 + 196) = *(_DWORD *)&v187[3];
  *(_DWORD *)(a3 + 193) = v72;
  *(void *)(a3 + 200) = v127;
  *(unsigned char *)(a3 + 208) = v186;
  int v73 = *(_DWORD *)v185;
  *(_DWORD *)(a3 + 212) = *(_DWORD *)&v185[3];
  *(_DWORD *)(a3 + 209) = v73;
  *(void *)(a3 + 216) = v128;
  *(unsigned char *)(a3 + 224) = v184;
  int v74 = *(_DWORD *)v183;
  *(_DWORD *)(a3 + 228) = *(_DWORD *)&v183[3];
  *(_DWORD *)(a3 + 225) = v74;
  *(void *)(a3 + 232) = v129;
  *(unsigned char *)(a3 + 240) = v182;
  int v75 = *(_DWORD *)v181;
  *(_DWORD *)(a3 + 244) = *(_DWORD *)&v181[3];
  *(_DWORD *)(a3 + 241) = v75;
  *(void *)(a3 + 248) = v114;
  *(unsigned char *)(a3 + 256) = v180;
  int v76 = *(_DWORD *)v179;
  *(_DWORD *)(a3 + 260) = *(_DWORD *)&v179[3];
  *(_DWORD *)(a3 + 257) = v76;
  *(void *)(a3 + 264) = v111;
  *(unsigned char *)(a3 + 272) = v178;
  int v77 = *(_DWORD *)v177;
  *(_DWORD *)(a3 + 276) = *(_DWORD *)&v177[3];
  *(_DWORD *)(a3 + 273) = v77;
  *(void *)(a3 + 280) = v116;
  *(unsigned char *)(a3 + 288) = v176;
  int v78 = *(_DWORD *)v175;
  *(_DWORD *)(a3 + 292) = *(_DWORD *)&v175[3];
  *(_DWORD *)(a3 + 289) = v78;
  *(void *)(a3 + 296) = v117;
  *(unsigned char *)(a3 + 304) = v174;
  int v79 = *(_DWORD *)v173;
  *(_DWORD *)(a3 + 308) = *(_DWORD *)&v173[3];
  *(_DWORD *)(a3 + 305) = v79;
  *(void *)(a3 + 312) = v118;
  *(unsigned char *)(a3 + 320) = v172;
  int v80 = *(_DWORD *)v171;
  *(_DWORD *)(a3 + 324) = *(_DWORD *)&v171[3];
  *(_DWORD *)(a3 + 321) = v80;
  *(void *)(a3 + 328) = v65;
  *(unsigned char *)(a3 + 336) = v170;
  int v81 = *(_DWORD *)v169;
  *(_DWORD *)(a3 + 340) = *(_DWORD *)&v169[3];
  *(_DWORD *)(a3 + 337) = v81;
  *(void *)(a3 + 344) = v106;
  *(unsigned char *)(a3 + 352) = v168;
  int v82 = *(_DWORD *)v167;
  *(_DWORD *)(a3 + 356) = *(_DWORD *)&v167[3];
  *(_DWORD *)(a3 + 353) = v82;
  *(void *)(a3 + 360) = v104;
  *(unsigned char *)(a3 + 368) = v166;
  int v83 = *(_DWORD *)v165;
  *(_DWORD *)(a3 + 372) = *(_DWORD *)&v165[3];
  *(_DWORD *)(a3 + 369) = v83;
  *(void *)(a3 + 376) = v115;
  *(unsigned char *)(a3 + 384) = v164;
  int v84 = *(_DWORD *)v163;
  *(_DWORD *)(a3 + 388) = *(_DWORD *)&v163[3];
  *(_DWORD *)(a3 + 385) = v84;
  *(void *)(a3 + 392) = v136;
  *(unsigned char *)(a3 + 400) = v162;
  int v85 = *(_DWORD *)v161;
  *(_DWORD *)(a3 + 404) = *(_DWORD *)&v161[3];
  *(_DWORD *)(a3 + 401) = v85;
  uint64_t v86 = v107;
  *(void *)(a3 + 408) = v122;
  *(void *)(a3 + 416) = v86;
  *(unsigned char *)(a3 + 424) = v120;
  *(unsigned char *)(a3 + 425) = v121;
  int v87 = v159;
  *(_WORD *)(a3 + 430) = v160;
  *(_DWORD *)(a3 + 426) = v87;
  *(void *)(a3 + 432) = v99;
  *(unsigned char *)(a3 + 440) = v158;
  int v88 = *(_DWORD *)v157;
  *(_DWORD *)(a3 + 444) = *(_DWORD *)&v157[3];
  *(_DWORD *)(a3 + 441) = v88;
  *(void *)(a3 + 448) = v98;
  *(unsigned char *)(a3 + 456) = v156;
  int v89 = *(_DWORD *)v155;
  *(_DWORD *)(a3 + 460) = *(_DWORD *)&v155[3];
  *(_DWORD *)(a3 + 457) = v89;
  *(void *)(a3 + 464) = v100;
  *(unsigned char *)(a3 + 472) = v154;
  int v90 = *(_DWORD *)v153;
  *(_DWORD *)(a3 + 476) = *(_DWORD *)&v153[3];
  *(_DWORD *)(a3 + 473) = v90;
  *(void *)(a3 + 480) = v103;
  *(unsigned char *)(a3 + 488) = v152;
  int v91 = *(_DWORD *)v151;
  *(_DWORD *)(a3 + 492) = *(_DWORD *)&v151[3];
  *(_DWORD *)(a3 + 489) = v91;
  *(void *)(a3 + 496) = v109;
  *(unsigned char *)(a3 + 504) = v150;
  int v92 = *(_DWORD *)v149;
  *(_DWORD *)(a3 + 508) = *(_DWORD *)&v149[3];
  *(_DWORD *)(a3 + 505) = v92;
  *(double *)(a3 + 512) = v105;
  *(unsigned char *)(a3 + 520) = v148;
  int v93 = *(_DWORD *)v147;
  *(_DWORD *)(a3 + 524) = *(_DWORD *)&v147[3];
  *(_DWORD *)(a3 + 521) = v93;
  *(double *)(a3 + 528) = v58;
  *(unsigned char *)(a3 + 536) = v146;
  int v94 = *(_DWORD *)v145;
  *(_DWORD *)(a3 + 540) = *(_DWORD *)&v145[3];
  *(_DWORD *)(a3 + 537) = v94;
  *(double *)(a3 + 544) = v57;
  *(unsigned char *)(a3 + 552) = v144;
  return result;
}

void *sub_100051A38@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_100045F18(0xD000000000000013, 0x8000000100307FF0, 0xD000000000000018, 0x8000000100307FD0);
  sub_100050D24(2, a2, (uint64_t)&v79);
  uint64_t v6 = v86;
  uint64_t v75 = v92;
  uint64_t v76 = v90;
  __dst = a3;
  uint64_t v73 = v85;
  uint64_t v74 = v89;
  uint64_t v72 = v91;
  unint64_t v7 = 0xEE00676E69747261;
  unint64_t v8 = 0x745370756B636162;
  switch(a1)
  {
    case 0:
      break;
    case 1:
      unint64_t v7 = 0xEB00000000676E69;
      unint64_t v8 = 0x726F747365527369;
      break;
    case 2:
      unint64_t v7 = 0x8000000100308120;
      unint64_t v8 = 0xD000000000000010;
      break;
    case 3:
      unint64_t v7 = 0xEB000000006E776FLL;
      unint64_t v8 = 0x6E6B6E5574736762;
      break;
    case 4:
      unint64_t v7 = 0xED000064656C6C65;
      unint64_t v8 = 0x636E614372657375;
      break;
    case 5:
      unint64_t v7 = 0xE700000000000000;
      unint64_t v8 = 0x6572756C696166;
      break;
    default:
      *(void *)&__src[0] = a1;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      _diagnoseUnexpectedEnumCaseValue<A, B>(type:rawValue:)();
      __break(1u);
      JUMPOUT(0x10005205CLL);
  }
  uint64_t v56 = v79;
  char v55 = v80;
  long long v71 = v81;
  uint64_t v54 = v82;
  char v53 = v83;
  char v51 = v84;
  __int16 v52 = v93[8];
  uint64_t v49 = v94;
  uint64_t v50 = v87;
  char v47 = v95;
  char v48 = v88;
  uint64_t v46 = v96;
  char v44 = v109;
  char v45 = v97;
  char v42 = v113;
  char v43 = v111;
  char v40 = v115;
  char v70 = v117;
  char v69 = v119;
  char v68 = v121;
  char v67 = v123;
  char v66 = v125;
  char v65 = v127;
  char v64 = v132;
  char v63 = v134;
  char v62 = v136;
  char v61 = v138;
  char v60 = v140;
  char v59 = v142;
  char v58 = v144;
  char v57 = v146;
  char v9 = v99;
  uint64_t v23 = v100;
  char v10 = v101;
  uint64_t v18 = v102;
  uint64_t v19 = v98;
  char v22 = v103;
  uint64_t v11 = v104;
  uint64_t v12 = v106;
  char v16 = v107;
  char v17 = v105;
  uint64_t v14 = v110;
  uint64_t v15 = v108;
  uint64_t v20 = v114;
  uint64_t v21 = v112;
  uint64_t v24 = v118;
  uint64_t v25 = v116;
  uint64_t v26 = v122;
  uint64_t v27 = v120;
  uint64_t v28 = v126;
  uint64_t v29 = v124;
  uint64_t v30 = v128;
  uint64_t v31 = v129;
  __int16 v32 = v130;
  uint64_t v33 = v133;
  uint64_t v34 = v131;
  uint64_t v35 = v137;
  uint64_t v36 = v135;
  uint64_t v37 = v141;
  uint64_t v38 = v139;
  uint64_t v39 = v143;
  uint64_t v41 = v145;
  sub_10004D028((uint64_t)v93, (uint64_t)v147, &qword_10047E180);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  sub_10004D08C((uint64_t)v147);
  *(void *)&__src[0] = v56;
  BYTE8(__src[0]) = v55;
  *(void *)&void __src[2] = v54;
  BYTE8(__src[2]) = v53;
  BYTE9(__src[2]) = v51;
  *(void *)&__src[3] = v73;
  *(void *)&__src[4] = v50;
  BYTE8(__src[4]) = v48;
  *(void *)&__src[5] = v74;
  *(void *)&__src[6] = v72;
  *(void *)&__src[7] = v8;
  LOWORD(__src[8]) = v52;
  *((void *)&__src[8] + 1) = v49;
  LOBYTE(__src[9]) = v47;
  *((void *)&__src[9] + 1) = v46;
  LOBYTE(__src[10]) = v45;
  *((void *)&__src[10] + 1) = v19;
  LOBYTE(__src[11]) = v9;
  *((void *)&__src[11] + 1) = v23;
  LOBYTE(__src[12]) = v10;
  *((void *)&__src[12] + 1) = v18;
  LOBYTE(__src[13]) = v22;
  *((void *)&__src[13] + 1) = v11;
  LOBYTE(__src[14]) = v17;
  *((void *)&__src[14] + 1) = v12;
  LOBYTE(__src[15]) = v16;
  *((void *)&__src[15] + 1) = v15;
  *((void *)&__src[16] + 1) = v14;
  LOBYTE(__src[16]) = v44;
  LOBYTE(__src[17]) = v43;
  *((void *)&__src[17] + 1) = v21;
  *((void *)&__src[18] + 1) = v20;
  LOBYTE(__src[18]) = v42;
  LOBYTE(__src[19]) = v40;
  *((void *)&__src[19] + 1) = v25;
  *((void *)&__src[20] + 1) = v24;
  __src[1] = v71;
  *((void *)&__src[3] + 1) = v6;
  *((void *)&__src[5] + 1) = v76;
  *((void *)&__src[6] + 1) = v75;
  *((void *)&__src[7] + 1) = v7;
  LOBYTE(__src[20]) = v70;
  LOBYTE(__src[21]) = v69;
  LOBYTE(__src[22]) = v68;
  *((void *)&__src[21] + 1) = v27;
  *((void *)&__src[22] + 1) = v26;
  LOBYTE(__src[23]) = v67;
  LOBYTE(__src[24]) = v66;
  *((void *)&__src[23] + 1) = v29;
  *((void *)&__src[24] + 1) = v28;
  LOBYTE(__src[25]) = v65;
  *((void *)&__src[25] + 1) = v30;
  *(void *)&__src[26] = v31;
  WORD4(__src[26]) = v32;
  BYTE8(__src[27]) = v64;
  *(void *)&__src[27] = v34;
  *(void *)&__src[28] = v33;
  BYTE8(__src[28]) = v63;
  BYTE8(__src[29]) = v62;
  *(void *)&__src[29] = v36;
  *(void *)&__src[30] = v35;
  BYTE8(__src[30]) = v61;
  BYTE8(__src[31]) = v60;
  *(void *)&__src[31] = v38;
  *(void *)&__src[32] = v37;
  BYTE8(__src[32]) = v59;
  *(void *)&__src[33] = v39;
  BYTE8(__src[33]) = v58;
  *(void *)&__src[34] = v41;
  BYTE8(__src[34]) = v57;
  sub_10004D0B8((uint64_t)__src);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_10004D110((uint64_t)__src);
  return memcpy(__dst, __src, 0x229uLL);
}

double sub_100052074@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  sub_1000462C4(a1, 0x206E6F6973736553, 0xEE0064656C696166, 0xD000000000000018, 0x8000000100307FD0);
  sub_100050D24(1, a2, (uint64_t)__src);
  memcpy(__dst, __src, 0x229uLL);
  swift_getErrorValue();
  sub_1000526E4((uint64_t)__dst, v29, v30);
  swift_errorRetain();
  LOWORD(a2) = sub_100052E40(v4);
  swift_errorRelease();
  sub_100045F18(0xD000000000000010, 0x8000000100308160, 0xD000000000000018, 0x8000000100307FD0);
  swift_bridgeObjectRelease();
  *(void *)uint64_t v4 = 0;
  *(void *)(v4 + 8) = 0;
  swift_bridgeObjectRelease();
  *(void *)(v4 + 48) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)(v4 + 24) = 0;
  *(unsigned char *)(v4 + 56) = 1;
  uint64_t v7 = v4 + *(int *)(type metadata accessor for MBDryRestoreState() + 48);
  *(void *)uint64_t v7 = 0;
  *(unsigned char *)(v7 + 8) = 1;
  *(void *)(v4 + 32) = 0;
  *(unsigned char *)(v4 + 40) = 1;
  char v89 = BYTE8(__dst[2]);
  char v86 = BYTE8(__dst[4]);
  char v83 = __dst[9];
  char v81 = __dst[10];
  char v79 = __dst[11];
  char v77 = __dst[12];
  char v75 = __dst[13];
  char v73 = __dst[14];
  char v71 = __dst[15];
  char v69 = __dst[16];
  char v67 = __dst[17];
  char v65 = __dst[18];
  char v63 = __dst[19];
  char v61 = __dst[20];
  char v59 = __dst[21];
  char v57 = __dst[22];
  char v55 = __dst[23];
  char v53 = __dst[24];
  char v51 = __dst[25];
  char v47 = BYTE8(__dst[27]);
  char v45 = BYTE8(__dst[28]);
  char v43 = BYTE8(__dst[29]);
  char v41 = BYTE8(__dst[30]);
  char v39 = BYTE8(__dst[31]);
  char v37 = BYTE8(__dst[32]);
  char v35 = BYTE8(__dst[33]);
  char v33 = BYTE8(__dst[34]);
  *(void *)a3 = *(void *)&__dst[0];
  *(unsigned char *)(a3 + 8) = BYTE8(__dst[0]);
  *(_DWORD *)(a3 + 9) = __src[0];
  *(_DWORD *)(a3 + 12) = *(_DWORD *)((char *)__src + 3);
  *(void *)(a3 + 32) = *(void *)&__dst[2];
  *(unsigned char *)(a3 + 40) = v89;
  *(unsigned char *)(a3 + 41) = BYTE9(__dst[2]);
  *(_DWORD *)(a3 + 42) = v87;
  *(_WORD *)(a3 + 46) = v88;
  *(void *)(a3 + 64) = *(void *)&__dst[4];
  *(unsigned char *)(a3 + 72) = v86;
  *(_DWORD *)(a3 + 76) = *(_DWORD *)((char *)__dst + 3);
  *(_DWORD *)(a3 + 73) = __dst[0];
  *(unsigned char *)(a3 + 128) = a2 & 1;
  uint64_t v8 = *((void *)&__dst[8] + 1);
  *(unsigned char *)(a3 + 129) = BYTE1(a2) & 1;
  *(_WORD *)(a3 + 134) = v85;
  *(_DWORD *)(a3 + 130) = v84;
  uint64_t v9 = *((void *)&__dst[9] + 1);
  *(void *)(a3 + 136) = v8;
  *(unsigned char *)(a3 + 144) = v83;
  *(_DWORD *)(a3 + 148) = *(_DWORD *)&v82[3];
  *(_DWORD *)(a3 + 145) = *(_DWORD *)v82;
  uint64_t v10 = *((void *)&__dst[10] + 1);
  *(void *)(a3 + 152) = v9;
  *(unsigned char *)(a3 + 160) = v81;
  *(_DWORD *)(a3 + 164) = *(_DWORD *)&v80[3];
  *(_DWORD *)(a3 + 161) = *(_DWORD *)v80;
  uint64_t v11 = *((void *)&__dst[11] + 1);
  *(void *)(a3 + 168) = v10;
  *(unsigned char *)(a3 + 176) = v79;
  *(_DWORD *)(a3 + 180) = *(_DWORD *)&v78[3];
  *(_DWORD *)(a3 + 177) = *(_DWORD *)v78;
  uint64_t v12 = *((void *)&__dst[12] + 1);
  *(void *)(a3 + 184) = v11;
  *(unsigned char *)(a3 + 192) = v77;
  *(_DWORD *)(a3 + 196) = *(_DWORD *)&v76[3];
  *(_DWORD *)(a3 + 193) = *(_DWORD *)v76;
  uint64_t v13 = *((void *)&__dst[13] + 1);
  *(void *)(a3 + 200) = v12;
  *(unsigned char *)(a3 + 208) = v75;
  *(_DWORD *)(a3 + 212) = *(_DWORD *)&v74[3];
  *(_DWORD *)(a3 + 209) = *(_DWORD *)v74;
  uint64_t v14 = *((void *)&__dst[14] + 1);
  *(void *)(a3 + 216) = v13;
  *(unsigned char *)(a3 + 224) = v73;
  *(_DWORD *)(a3 + 228) = *(_DWORD *)&v72[3];
  *(_DWORD *)(a3 + 225) = *(_DWORD *)v72;
  uint64_t v15 = *((void *)&__dst[15] + 1);
  *(void *)(a3 + 232) = v14;
  *(unsigned char *)(a3 + 240) = v71;
  *(_DWORD *)(a3 + 244) = *(_DWORD *)&v70[3];
  *(_DWORD *)(a3 + 241) = *(_DWORD *)v70;
  *(void *)(a3 + 248) = v15;
  *(unsigned char *)(a3 + 256) = v69;
  *(_DWORD *)(a3 + 260) = *(_DWORD *)&v68[3];
  *(_DWORD *)(a3 + 257) = *(_DWORD *)v68;
  *(_DWORD *)(a3 + 276) = *(_DWORD *)&v66[3];
  *(_DWORD *)(a3 + 273) = *(_DWORD *)v66;
  uint64_t v16 = *((void *)&__dst[17] + 1);
  *(void *)(a3 + 264) = *((void *)&__dst[16] + 1);
  *(unsigned char *)(a3 + 272) = v67;
  *(void *)(a3 + 280) = v16;
  *(unsigned char *)(a3 + 288) = v65;
  *(_DWORD *)(a3 + 292) = *(_DWORD *)&v64[3];
  *(_DWORD *)(a3 + 289) = *(_DWORD *)v64;
  *(_DWORD *)(a3 + 308) = *(_DWORD *)&v62[3];
  *(_DWORD *)(a3 + 305) = *(_DWORD *)v62;
  uint64_t v17 = *((void *)&__dst[19] + 1);
  *(void *)(a3 + 296) = *((void *)&__dst[18] + 1);
  *(unsigned char *)(a3 + 304) = v63;
  *(void *)(a3 + 312) = v17;
  *(unsigned char *)(a3 + 320) = v61;
  *(_DWORD *)(a3 + 324) = *(_DWORD *)&v60[3];
  *(_DWORD *)(a3 + 321) = *(_DWORD *)v60;
  *(_DWORD *)(a3 + 340) = *(_DWORD *)&v58[3];
  *(_DWORD *)(a3 + 337) = *(_DWORD *)v58;
  uint64_t v18 = *((void *)&__dst[21] + 1);
  *(void *)(a3 + 328) = *((void *)&__dst[20] + 1);
  *(unsigned char *)(a3 + 336) = v59;
  *(void *)(a3 + 344) = v18;
  *(unsigned char *)(a3 + 352) = v57;
  *(_DWORD *)(a3 + 356) = *(_DWORD *)&v56[3];
  *(_DWORD *)(a3 + 353) = *(_DWORD *)v56;
  *(_DWORD *)(a3 + 372) = *(_DWORD *)&v54[3];
  *(_DWORD *)(a3 + 369) = *(_DWORD *)v54;
  uint64_t v19 = *((void *)&__dst[23] + 1);
  *(void *)(a3 + 360) = *((void *)&__dst[22] + 1);
  *(unsigned char *)(a3 + 368) = v55;
  *(void *)(a3 + 376) = v19;
  *(unsigned char *)(a3 + 384) = v53;
  *(_DWORD *)(a3 + 388) = *(_DWORD *)&v52[3];
  *(_DWORD *)(a3 + 385) = *(_DWORD *)v52;
  *(_DWORD *)(a3 + 404) = *(_DWORD *)&v50[3];
  *(_DWORD *)(a3 + 401) = *(_DWORD *)v50;
  *(void *)(a3 + 392) = *((void *)&__dst[24] + 1);
  *(unsigned char *)(a3 + 400) = v51;
  uint64_t v20 = *(void *)&__dst[26];
  *(void *)(a3 + 408) = *((void *)&__dst[25] + 1);
  *(void *)(a3 + 416) = v20;
  *(_WORD *)(a3 + 424) = WORD4(__dst[26]);
  *(_WORD *)(a3 + 430) = v49;
  *(_DWORD *)(a3 + 426) = v48;
  *(_DWORD *)(a3 + 444) = *(_DWORD *)&v46[3];
  *(_DWORD *)(a3 + 441) = *(_DWORD *)v46;
  uint64_t v21 = *(void *)&__dst[28];
  *(void *)(a3 + 432) = *(void *)&__dst[27];
  *(unsigned char *)(a3 + 440) = v47;
  *(void *)(a3 + 448) = v21;
  *(unsigned char *)(a3 + 456) = v45;
  *(_DWORD *)(a3 + 460) = *(_DWORD *)&v44[3];
  *(_DWORD *)(a3 + 457) = *(_DWORD *)v44;
  *(_DWORD *)(a3 + 476) = *(_DWORD *)&v42[3];
  *(_DWORD *)(a3 + 473) = *(_DWORD *)v42;
  *(_DWORD *)(a3 + 492) = *(_DWORD *)&v40[3];
  *(_DWORD *)(a3 + 489) = *(_DWORD *)v40;
  *(_DWORD *)(a3 + 508) = *(_DWORD *)&v38[3];
  *(_DWORD *)(a3 + 505) = *(_DWORD *)v38;
  *(_DWORD *)(a3 + 524) = *(_DWORD *)&v36[3];
  *(_DWORD *)(a3 + 521) = *(_DWORD *)v36;
  uint64_t v22 = *(void *)&__dst[30];
  *(void *)(a3 + 464) = *(void *)&__dst[29];
  *(unsigned char *)(a3 + 472) = v43;
  *(void *)(a3 + 480) = v22;
  *(unsigned char *)(a3 + 488) = v41;
  *(_DWORD *)(a3 + 540) = *(_DWORD *)&v34[3];
  *(_DWORD *)(a3 + 537) = *(_DWORD *)v34;
  uint64_t v23 = *(void *)&__dst[32];
  *(void *)(a3 + 496) = *(void *)&__dst[31];
  *(unsigned char *)(a3 + 504) = v39;
  *(void *)(a3 + 512) = v23;
  *(unsigned char *)(a3 + 520) = v37;
  *(void *)(a3 + 528) = *(void *)&__dst[33];
  *(unsigned char *)(a3 + 536) = v35;
  *(void *)(a3 + 544) = *(void *)&__dst[34];
  *(unsigned char *)(a3 + 552) = v33;
  double result = *(double *)&__dst[1];
  long long v25 = __dst[3];
  long long v26 = __dst[5];
  long long v27 = __dst[6];
  long long v28 = __dst[7];
  *(_OWORD *)(a3 + 16) = __dst[1];
  *(_OWORD *)(a3 + 48) = v25;
  *(_OWORD *)(a3 + 80) = v26;
  *(_OWORD *)(a3 + 96) = v27;
  *(_OWORD *)(a3 + 112) = v28;
  return result;
}

void sub_1000526E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = __chkstk_darwin(a1);
  uint64_t v9 = (char *)v33 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v7);
  uint64_t v11 = (char *)v33 - v10;
  uint64_t v12 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 16);
  v33[0] = v13;
  v12((char *)v33 - v10, v13, a2);
  uint64_t v14 = _getErrorEmbeddedNSError<A>(_:)();
  v33[1] = a3;
  if (v14)
  {
    (*(void (**)(char *, uint64_t))(v6 + 8))(v11, a2);
  }
  else
  {
    swift_allocError();
    (*(void (**)(uint64_t, char *, uint64_t))(v6 + 32))(v15, v11, a2);
  }
  uint64_t v16 = (void *)_convertErrorToNSError(_:)();
  swift_errorRelease();
  id v17 = MBExtractFirstMBErrorOrCKError(v16);

  if (v17)
  {
    id v18 = [v17 domain];
    uint64_t v19 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v21 = v20;

    swift_bridgeObjectRelease();
    *(void *)(a1 + 48) = v19;
    *(void *)(a1 + 56) = v21;
    *(void *)(a1 + 64) = [v17 code];
    *(unsigned char *)(a1 + 72) = 0;
    id v22 = [v17 localizedDescription];
    uint64_t v23 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v25 = v24;

    swift_bridgeObjectRelease();
    *(void *)(a1 + 80) = v23;
    *(void *)(a1 + 88) = v25;
    v12(v9, v33[0], a2);
    if (_getErrorEmbeddedNSError<A>(_:)())
    {
      (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
    }
    else
    {
      swift_allocError();
      (*(void (**)(uint64_t, char *, uint64_t))(v6 + 32))(v26, v9, a2);
    }
    long long v27 = self;
    long long v28 = (void *)_convertErrorToNSError(_:)();
    swift_errorRelease();
    id v29 = [v27 signatureForError:v28];

    uint64_t v30 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v32 = v31;

    swift_bridgeObjectRelease();
    *(void *)(a1 + 96) = v30;
    *(void *)(a1 + 104) = v32;
  }
  else
  {
    __break(1u);
  }
}

unint64_t sub_100052A08(uint64_t a1)
{
  unint64_t result = 0x745370756B636162;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      unint64_t result = 0x726F747365527369;
      break;
    case 2:
      unint64_t result = 0xD000000000000010;
      break;
    case 3:
      unint64_t result = 0x6E6B6E5574736762;
      break;
    case 4:
      unint64_t result = 0x636E614372657375;
      break;
    case 5:
      unint64_t result = 0x6572756C696166;
      break;
    default:
      _diagnoseUnexpectedEnumCaseValue<A, B>(type:rawValue:)();
      __break(1u);
      JUMPOUT(0x100052B20);
  }
  return result;
}

void *sub_100052B38@<X0>(void *a1@<X8>)
{
  sub_100045F18(0xD000000000000011, 0x8000000100308220, 0xD000000000000018, 0x8000000100307FD0);
  sub_100050D24(3, 0, (uint64_t)__src);
  swift_getErrorValue();
  sub_1000526E4((uint64_t)__src, v5, v6);
  sub_100045F18(0xD000000000000010, 0x8000000100308160, 0xD000000000000018, 0x8000000100307FD0);
  swift_bridgeObjectRelease();
  *(void *)uint64_t v1 = 0;
  *(void *)(v1 + 8) = 0;
  swift_bridgeObjectRelease();
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0;
  *(unsigned char *)(v1 + 56) = 1;
  uint64_t v3 = v1 + *(int *)(type metadata accessor for MBDryRestoreState() + 48);
  *(void *)uint64_t v3 = 0;
  *(unsigned char *)(v3 + 8) = 1;
  *(void *)(v1 + 32) = 0;
  *(unsigned char *)(v1 + 40) = 1;
  return memcpy(a1, __src, 0x229uLL);
}

void *sub_100052C64@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_1000462C4(a1, 0xD000000000000017, 0x8000000100308240, 0xD000000000000018, 0x8000000100307FD0);
  sub_100050D24(4, 0, (uint64_t)__src);
  swift_getErrorValue();
  sub_1000526E4((uint64_t)__src, v6, v7);
  sub_100045F18(0xD000000000000010, 0x8000000100308160, 0xD000000000000018, 0x8000000100307FD0);
  swift_bridgeObjectRelease();
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  swift_bridgeObjectRelease();
  *(void *)(v2 + 48) = 0;
  *(void *)(v2 + 16) = 0;
  *(void *)(v2 + 24) = 0;
  *(unsigned char *)(v2 + 56) = 1;
  uint64_t v4 = v2 + *(int *)(type metadata accessor for MBDryRestoreState() + 48);
  *(void *)uint64_t v4 = 0;
  *(unsigned char *)(v4 + 8) = 1;
  *(void *)(v2 + 32) = 0;
  *(unsigned char *)(v2 + 40) = 1;
  return memcpy(a2, __src, 0x229uLL);
}

unint64_t sub_100052D90()
{
  return sub_100052A08(*v0);
}

uint64_t sub_100052D98(uint64_t a1)
{
  uint64_t v2 = sub_100006FC8(&qword_10047D708);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

double sub_100052DF8(uint64_t a1)
{
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(unsigned char *)(a1 + 120) = 1;
  return result;
}

uint64_t sub_100052E1C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_100052E38(uint64_t result)
{
  *(unsigned char *)(result + 120) = 0;
  return result;
}

uint64_t sub_100052E40(uint64_t a1)
{
  uint64_t v2 = sub_100006FC8(&qword_10047D708);
  uint64_t v3 = __chkstk_darwin(v2 - 8);
  uint64_t v5 = (char *)&v26 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v3);
  uint64_t v7 = (char *)&v26 - v6;
  uint64_t v8 = type metadata accessor for Date();
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  uint64_t v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = a1 + *(int *)(type metadata accessor for MBDryRestoreState() + 64);
  sub_100048E78(v12, (uint64_t)v7);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v9 + 48))(v7, 1, v8) == 1)
  {
    sub_100052D98((uint64_t)v7);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v11, v7, v8);
    Date.timeIntervalSinceNow.getter();
    if (v13 > 259200.0)
    {
      double v14 = -v13;
      uint64_t v26 = 0;
      unint64_t v27 = 0xE000000000000000;
      _StringGuts.grow(_:)(46);
      swift_bridgeObjectRelease();
      uint64_t v26 = 0xD00000000000002CLL;
      unint64_t v27 = 0x8000000100308180;
      id v15 = [objc_allocWithZone((Class)NSRelativeDateTimeFormatter) init];
      [v15 setUnitsStyle:0];
      id v16 = [v15 localizedStringFromTimeInterval:v14];

      uint64_t v17 = static String._unconditionallyBridgeFromObjectiveC(_:)();
      uint64_t v19 = v18;

      v20._countAndFlagsBits = v17;
      v20._object = v19;
      String.append(_:)(v20);
      swift_bridgeObjectRelease();
      sub_100045F18(v26, v27, 0xD000000000000018, 0x8000000100307FD0);
      swift_bridgeObjectRelease();
      (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
      int v21 = 0;
      int v22 = 0;
      return v22 | v21;
    }
    (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
  }
  static Date.now.getter();
  int v21 = 1;
  (*(void (**)(char *, void, uint64_t, uint64_t))(v9 + 56))(v5, 0, 1, v8);
  sub_10002C7D8((uint64_t)v5, v12);
  uint64_t v23 = self;
  uint64_t v24 = (void *)_convertErrorToNSError(_:)();
  LODWORD(v23) = [v23 reportDryRestoreError:v24];

  if (v23) {
    int v22 = 256;
  }
  else {
    int v22 = 0;
  }
  return v22 | v21;
}

uint64_t destroy for MBDryRestoreTelemetry()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for MBDryRestoreTelemetry(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  uint64_t v3 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v3;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  uint64_t v4 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v4;
  uint64_t v5 = *(void *)(a2 + 104);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = v5;
  uint64_t v6 = *(void *)(a2 + 120);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = v6;
  *(_WORD *)(a1 + 128) = *(_WORD *)(a2 + 128);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a2 + 144);
  uint64_t v7 = *(void *)(a2 + 152);
  *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
  *(void *)(a1 + 152) = v7;
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(unsigned char *)(a1 + 208) = *(unsigned char *)(a2 + 208);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(unsigned char *)(a1 + 224) = *(unsigned char *)(a2 + 224);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  uint64_t v8 = *(void *)(a2 + 232);
  *(unsigned char *)(a1 + 240) = *(unsigned char *)(a2 + 240);
  *(void *)(a1 + 232) = v8;
  uint64_t v9 = *(void *)(a2 + 248);
  *(unsigned char *)(a1 + 256) = *(unsigned char *)(a2 + 256);
  *(void *)(a1 + 248) = v9;
  uint64_t v10 = *(void *)(a2 + 264);
  *(unsigned char *)(a1 + 272) = *(unsigned char *)(a2 + 272);
  *(void *)(a1 + 264) = v10;
  uint64_t v11 = *(void *)(a2 + 280);
  *(unsigned char *)(a1 + 288) = *(unsigned char *)(a2 + 288);
  *(void *)(a1 + 280) = v11;
  uint64_t v12 = *(void *)(a2 + 296);
  *(unsigned char *)(a1 + 304) = *(unsigned char *)(a2 + 304);
  *(void *)(a1 + 296) = v12;
  uint64_t v13 = *(void *)(a2 + 312);
  *(unsigned char *)(a1 + 320) = *(unsigned char *)(a2 + 320);
  *(void *)(a1 + 312) = v13;
  uint64_t v14 = *(void *)(a2 + 328);
  *(unsigned char *)(a1 + 336) = *(unsigned char *)(a2 + 336);
  *(void *)(a1 + 328) = v14;
  uint64_t v15 = *(void *)(a2 + 344);
  *(unsigned char *)(a1 + 352) = *(unsigned char *)(a2 + 352);
  *(void *)(a1 + 344) = v15;
  uint64_t v16 = *(void *)(a2 + 360);
  *(unsigned char *)(a1 + 368) = *(unsigned char *)(a2 + 368);
  *(void *)(a1 + 360) = v16;
  uint64_t v17 = *(void *)(a2 + 376);
  *(unsigned char *)(a1 + 384) = *(unsigned char *)(a2 + 384);
  *(void *)(a1 + 376) = v17;
  uint64_t v18 = *(void *)(a2 + 392);
  *(unsigned char *)(a1 + 400) = *(unsigned char *)(a2 + 400);
  *(void *)(a1 + 392) = v18;
  uint64_t v19 = *(void *)(a2 + 416);
  *(void *)(a1 + 408) = *(void *)(a2 + 408);
  *(void *)(a1 + 416) = v19;
  *(unsigned char *)(a1 + 424) = *(unsigned char *)(a2 + 424);
  *(unsigned char *)(a1 + 425) = *(unsigned char *)(a2 + 425);
  uint64_t v20 = *(void *)(a2 + 432);
  *(unsigned char *)(a1 + 440) = *(unsigned char *)(a2 + 440);
  *(void *)(a1 + 432) = v20;
  uint64_t v21 = *(void *)(a2 + 448);
  *(unsigned char *)(a1 + 456) = *(unsigned char *)(a2 + 456);
  *(void *)(a1 + 448) = v21;
  uint64_t v22 = *(void *)(a2 + 464);
  *(unsigned char *)(a1 + 472) = *(unsigned char *)(a2 + 472);
  *(void *)(a1 + 464) = v22;
  uint64_t v23 = *(void *)(a2 + 480);
  *(unsigned char *)(a1 + 488) = *(unsigned char *)(a2 + 488);
  *(void *)(a1 + 480) = v23;
  uint64_t v24 = *(void *)(a2 + 496);
  *(unsigned char *)(a1 + 504) = *(unsigned char *)(a2 + 504);
  *(void *)(a1 + 496) = v24;
  uint64_t v25 = *(void *)(a2 + 512);
  *(unsigned char *)(a1 + 520) = *(unsigned char *)(a2 + 520);
  *(void *)(a1 + 512) = v25;
  uint64_t v26 = *(void *)(a2 + 528);
  *(unsigned char *)(a1 + 536) = *(unsigned char *)(a2 + 536);
  *(void *)(a1 + 528) = v26;
  uint64_t v27 = *(void *)(a2 + 544);
  *(unsigned char *)(a1 + 552) = *(unsigned char *)(a2 + 552);
  *(void *)(a1 + 544) = v27;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for MBDryRestoreTelemetry(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 32);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 32) = v4;
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a2 + 41);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v5 = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(void *)(a1 + 64) = v5;
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a2 + 128);
  *(unsigned char *)(a1 + 129) = *(unsigned char *)(a2 + 129);
  uint64_t v6 = *(void *)(a2 + 136);
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a2 + 144);
  *(void *)(a1 + 136) = v6;
  uint64_t v7 = *(void *)(a2 + 152);
  *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
  *(void *)(a1 + 152) = v7;
  uint64_t v8 = *(void *)(a2 + 168);
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  *(void *)(a1 + 168) = v8;
  uint64_t v9 = *(void *)(a2 + 184);
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  *(void *)(a1 + 184) = v9;
  uint64_t v10 = *(void *)(a2 + 200);
  *(unsigned char *)(a1 + 208) = *(unsigned char *)(a2 + 208);
  *(void *)(a1 + 200) = v10;
  uint64_t v11 = *(void *)(a2 + 216);
  *(unsigned char *)(a1 + 224) = *(unsigned char *)(a2 + 224);
  *(void *)(a1 + 216) = v11;
  uint64_t v12 = *(void *)(a2 + 232);
  *(unsigned char *)(a1 + 240) = *(unsigned char *)(a2 + 240);
  *(void *)(a1 + 232) = v12;
  uint64_t v13 = *(void *)(a2 + 248);
  *(unsigned char *)(a1 + 256) = *(unsigned char *)(a2 + 256);
  *(void *)(a1 + 248) = v13;
  uint64_t v14 = *(void *)(a2 + 264);
  *(unsigned char *)(a1 + 272) = *(unsigned char *)(a2 + 272);
  *(void *)(a1 + 264) = v14;
  uint64_t v15 = *(void *)(a2 + 280);
  *(unsigned char *)(a1 + 288) = *(unsigned char *)(a2 + 288);
  *(void *)(a1 + 280) = v15;
  uint64_t v16 = *(void *)(a2 + 296);
  *(unsigned char *)(a1 + 304) = *(unsigned char *)(a2 + 304);
  *(void *)(a1 + 296) = v16;
  uint64_t v17 = *(void *)(a2 + 312);
  *(unsigned char *)(a1 + 320) = *(unsigned char *)(a2 + 320);
  *(void *)(a1 + 312) = v17;
  uint64_t v18 = *(void *)(a2 + 328);
  *(unsigned char *)(a1 + 336) = *(unsigned char *)(a2 + 336);
  *(void *)(a1 + 328) = v18;
  uint64_t v19 = *(void *)(a2 + 344);
  *(unsigned char *)(a1 + 352) = *(unsigned char *)(a2 + 352);
  *(void *)(a1 + 344) = v19;
  uint64_t v20 = *(void *)(a2 + 360);
  *(unsigned char *)(a1 + 368) = *(unsigned char *)(a2 + 368);
  *(void *)(a1 + 360) = v20;
  uint64_t v21 = *(void *)(a2 + 376);
  *(unsigned char *)(a1 + 384) = *(unsigned char *)(a2 + 384);
  *(void *)(a1 + 376) = v21;
  uint64_t v22 = *(void *)(a2 + 392);
  *(unsigned char *)(a1 + 400) = *(unsigned char *)(a2 + 400);
  *(void *)(a1 + 392) = v22;
  *(void *)(a1 + 408) = *(void *)(a2 + 408);
  *(void *)(a1 + 416) = *(void *)(a2 + 416);
  *(unsigned char *)(a1 + 424) = *(unsigned char *)(a2 + 424);
  *(unsigned char *)(a1 + 425) = *(unsigned char *)(a2 + 425);
  uint64_t v23 = *(void *)(a2 + 432);
  *(unsigned char *)(a1 + 440) = *(unsigned char *)(a2 + 440);
  *(void *)(a1 + 432) = v23;
  uint64_t v24 = *(void *)(a2 + 448);
  *(unsigned char *)(a1 + 456) = *(unsigned char *)(a2 + 456);
  *(void *)(a1 + 448) = v24;
  uint64_t v25 = *(void *)(a2 + 464);
  *(unsigned char *)(a1 + 472) = *(unsigned char *)(a2 + 472);
  *(void *)(a1 + 464) = v25;
  uint64_t v26 = *(void *)(a2 + 480);
  *(unsigned char *)(a1 + 488) = *(unsigned char *)(a2 + 488);
  *(void *)(a1 + 480) = v26;
  uint64_t v27 = *(void *)(a2 + 496);
  *(unsigned char *)(a1 + 504) = *(unsigned char *)(a2 + 504);
  *(void *)(a1 + 496) = v27;
  uint64_t v28 = *(void *)(a2 + 512);
  *(unsigned char *)(a1 + 520) = *(unsigned char *)(a2 + 520);
  *(void *)(a1 + 512) = v28;
  uint64_t v29 = *(void *)(a2 + 528);
  *(unsigned char *)(a1 + 536) = *(unsigned char *)(a2 + 536);
  *(void *)(a1 + 528) = v29;
  uint64_t v30 = *(void *)(a2 + 544);
  *(unsigned char *)(a1 + 552) = *(unsigned char *)(a2 + 552);
  *(void *)(a1 + 544) = v30;
  return a1;
}

void *initializeWithTake for MBDryRestoreTelemetry(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x229uLL);
}

uint64_t assignWithTake for MBDryRestoreTelemetry(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a2 + 41);
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  swift_bridgeObjectRelease();
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  uint64_t v5 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v5;
  swift_bridgeObjectRelease();
  uint64_t v6 = *(void *)(a2 + 104);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = v6;
  swift_bridgeObjectRelease();
  uint64_t v7 = *(void *)(a2 + 120);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = v7;
  swift_bridgeObjectRelease();
  *(_WORD *)(a1 + 128) = *(_WORD *)(a2 + 128);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a2 + 144);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(unsigned char *)(a1 + 208) = *(unsigned char *)(a2 + 208);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(unsigned char *)(a1 + 224) = *(unsigned char *)(a2 + 224);
  *(void *)(a1 + 232) = *(void *)(a2 + 232);
  *(unsigned char *)(a1 + 240) = *(unsigned char *)(a2 + 240);
  *(unsigned char *)(a1 + 256) = *(unsigned char *)(a2 + 256);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  uint64_t v8 = *(void *)(a2 + 264);
  *(unsigned char *)(a1 + 272) = *(unsigned char *)(a2 + 272);
  *(void *)(a1 + 264) = v8;
  *(unsigned char *)(a1 + 288) = *(unsigned char *)(a2 + 288);
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  *(unsigned char *)(a1 + 304) = *(unsigned char *)(a2 + 304);
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(unsigned char *)(a1 + 320) = *(unsigned char *)(a2 + 320);
  *(void *)(a1 + 312) = *(void *)(a2 + 312);
  *(unsigned char *)(a1 + 336) = *(unsigned char *)(a2 + 336);
  *(void *)(a1 + 328) = *(void *)(a2 + 328);
  uint64_t v9 = *(void *)(a2 + 344);
  *(unsigned char *)(a1 + 352) = *(unsigned char *)(a2 + 352);
  *(void *)(a1 + 344) = v9;
  uint64_t v10 = *(void *)(a2 + 360);
  *(unsigned char *)(a1 + 368) = *(unsigned char *)(a2 + 368);
  *(void *)(a1 + 360) = v10;
  uint64_t v11 = *(void *)(a2 + 376);
  *(unsigned char *)(a1 + 384) = *(unsigned char *)(a2 + 384);
  *(void *)(a1 + 376) = v11;
  uint64_t v12 = *(void *)(a2 + 392);
  *(unsigned char *)(a1 + 400) = *(unsigned char *)(a2 + 400);
  *(void *)(a1 + 392) = v12;
  uint64_t v13 = *(void *)(a2 + 416);
  *(void *)(a1 + 408) = *(void *)(a2 + 408);
  *(void *)(a1 + 416) = v13;
  *(unsigned char *)(a1 + 424) = *(unsigned char *)(a2 + 424);
  *(unsigned char *)(a1 + 425) = *(unsigned char *)(a2 + 425);
  uint64_t v14 = *(void *)(a2 + 432);
  *(unsigned char *)(a1 + 440) = *(unsigned char *)(a2 + 440);
  *(void *)(a1 + 432) = v14;
  uint64_t v15 = *(void *)(a2 + 448);
  *(unsigned char *)(a1 + 456) = *(unsigned char *)(a2 + 456);
  *(void *)(a1 + 448) = v15;
  uint64_t v16 = *(void *)(a2 + 464);
  *(unsigned char *)(a1 + 472) = *(unsigned char *)(a2 + 472);
  *(void *)(a1 + 464) = v16;
  uint64_t v17 = *(void *)(a2 + 480);
  *(unsigned char *)(a1 + 488) = *(unsigned char *)(a2 + 488);
  *(void *)(a1 + 480) = v17;
  uint64_t v18 = *(void *)(a2 + 496);
  *(unsigned char *)(a1 + 504) = *(unsigned char *)(a2 + 504);
  *(void *)(a1 + 496) = v18;
  uint64_t v19 = *(void *)(a2 + 512);
  *(unsigned char *)(a1 + 520) = *(unsigned char *)(a2 + 520);
  *(void *)(a1 + 512) = v19;
  uint64_t v20 = *(void *)(a2 + 528);
  *(unsigned char *)(a1 + 536) = *(unsigned char *)(a2 + 536);
  *(void *)(a1 + 528) = v20;
  uint64_t v21 = *(void *)(a2 + 544);
  *(unsigned char *)(a1 + 552) = *(unsigned char *)(a2 + 552);
  *(void *)(a1 + 544) = v21;
  return a1;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreTelemetry(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFF && *(unsigned char *)(a1 + 553)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for MBDryRestoreTelemetry(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 552) = 0;
    *(_OWORD *)(result + 536) = 0u;
    *(_OWORD *)(result + 520) = 0u;
    *(_OWORD *)(result + 504) = 0u;
    *(_OWORD *)(result + 488) = 0u;
    *(_OWORD *)(result + 472) = 0u;
    *(_OWORD *)(result + 456) = 0u;
    *(_OWORD *)(result + 440) = 0u;
    *(_OWORD *)(result + 424) = 0u;
    *(_OWORD *)(result + 408) = 0u;
    *(_OWORD *)(result + 392) = 0u;
    *(_OWORD *)(result + 376) = 0u;
    *(_OWORD *)(result + 360) = 0u;
    *(_OWORD *)(result + 344) = 0u;
    *(_OWORD *)(result + 328) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(void *)double result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 553) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 553) = 0;
    }
    if (a2) {
      *(void *)(result + 56) = a2;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreTelemetry()
{
  return &type metadata for MBDryRestoreTelemetry;
}

unint64_t sub_100053AA8()
{
  unint64_t result = qword_10047E288;
  if (!qword_10047E288)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E288);
  }
  return result;
}

unint64_t sub_100053AFC()
{
  unint64_t result = qword_10047E290;
  if (!qword_10047E290)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E290);
  }
  return result;
}

uint64_t sub_100053B50(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreTelemetry.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xD7) {
    goto LABEL_17;
  }
  if (a2 + 41 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 41) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 41;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 41;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 41;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0x2A;
  int v8 = v6 - 42;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBDryRestoreTelemetry.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 41 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 41) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xD7) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xD6)
  {
    unsigned int v6 = ((a2 - 215) >> 8) + 1;
    *uint64_t result = a2 + 41;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x100053CF4);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 41;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreTelemetry.CodingKeys()
{
  return &type metadata for MBDryRestoreTelemetry.CodingKeys;
}

uint64_t getEnumTagSinglePayload for MBDryRestoreSessionState(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFA) {
    goto LABEL_17;
  }
  if (a2 + 6 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 6) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 6;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 7;
  int v8 = v6 - 7;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for MBDryRestoreSessionState(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 6 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 6) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFA) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF9)
  {
    unsigned int v6 = ((a2 - 250) >> 8) + 1;
    *uint64_t result = a2 + 6;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x100053E88);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 6;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for MBDryRestoreSessionState()
{
  return &type metadata for MBDryRestoreSessionState;
}

unint64_t sub_100053EC4()
{
  unint64_t result = qword_10047E2A8;
  if (!qword_10047E2A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E2A8);
  }
  return result;
}

unint64_t sub_100053F1C()
{
  unint64_t result = qword_10047E2B0;
  if (!qword_10047E2B0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E2B0);
  }
  return result;
}

unint64_t sub_100053F74()
{
  unint64_t result = qword_10047E2B8;
  if (!qword_10047E2B8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E2B8);
  }
  return result;
}

unint64_t sub_100053FCC()
{
  unint64_t result = qword_10047E2C0;
  if (!qword_10047E2C0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E2C0);
  }
  return result;
}

uint64_t sub_100054020(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x7274656D656C6574 && a2 == 0xEB00000000444979;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6574617473 && a2 == 0xE500000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x4374706D65747461 && a2 == 0xEC000000746E756FLL {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x6C617461466E6F6ELL && a2 == 0xEE0073726F727245 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 0x54746E756F636361 && a2 == 0xEB00000000657079 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else if (a1 == 0xD000000000000022 && a2 == 0x8000000100308260 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 5;
  }
  else if (a1 == 0x446572756C696166 && a2 == 0xED00006E69616D6FLL {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 6;
  }
  else if (a1 == 0x436572756C696166 && a2 == 0xEB0000000065646FLL {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 7;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x8000000100308290 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 8;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x80000001003082B0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 9;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x80000001003082D0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 10;
  }
  else if (a1 == 0x6575716552727474 && a2 == 0xEC00000064657473 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 11;
  }
  else if (a1 == 0x7065636341727474 && a2 == 0xEB00000000646574 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 12;
  }
  else if (a1 == 0xD000000000000016 && a2 == 0x80000001003082F0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 13;
  }
  else if (a1 == 0xD000000000000013 && a2 == 0x8000000100305EC0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 14;
  }
  else if (a1 == 0xD000000000000016 && a2 == 0x8000000100308310 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 15;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x8000000100308330 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 16;
  }
  else if (a1 == 0xD000000000000013 && a2 == 0x8000000100308350 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 17;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x8000000100308370 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 18;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x8000000100308390 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 19;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x80000001003052A0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 20;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x80000001003052C0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 21;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x80000001003052E0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 22;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x8000000100305300 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 23;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x8000000100305320 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 24;
  }
  else if (a1 == 0xD000000000000018 && a2 == 0x80000001003083B0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 25;
  }
  else if (a1 == 0xD000000000000019 && a2 == 0x80000001003083D0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 26;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x8000000100305190 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 27;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x80000001003083F0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 28;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x8000000100308410 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 29;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x8000000100308430 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 30;
  }
  else if (a1 == 0x6F6D654D6B616570 && a2 == 0xEF65676173557972 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 31;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x8000000100308450 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 32;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x8000000100308470 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 33;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x8000000100305260 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 34;
  }
  else if (a1 == 0x7269446C61746F74 && a2 == 0xEF646563616C5073 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 35;
  }
  else if (a1 == 0xD000000000000013 && a2 == 0x8000000100305220 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 36;
  }
  else if (a1 == 0xD000000000000018 && a2 == 0x8000000100305240 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 37;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x8000000100305280 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 38;
  }
  else if (a1 == 0xD00000000000001BLL && a2 == 0x8000000100308490 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 39;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x80000001003084B0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 40;
  }
  else if (a1 == 0xD000000000000015 && a2 == 0x80000001003084D0)
  {
    swift_bridgeObjectRelease();
    return 41;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 41;
    }
    else {
      return 42;
    }
  }
}

unint64_t sub_100054FBC()
{
  unint64_t result = qword_10047E2C8;
  if (!qword_10047E2C8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E2C8);
  }
  return result;
}

unint64_t sub_100055010(Swift::String string)
{
  object = string._object;
  v2._countAndFlagsBits = string._countAndFlagsBits;
  v2._object = object;
  unint64_t v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_10040F1E0, v2);
  swift_bridgeObjectRelease();
  if (v3 >= 7) {
    return 7;
  }
  else {
    return v3;
  }
}

id sub_100055064(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 8);
  __chkstk_darwin(a1);
  unsigned int v4 = (char *)&v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v2 + 16))(v4, v5, a1);
  if (_getErrorEmbeddedNSError<A>(_:)())
  {
    (*(void (**)(char *, uint64_t))(v2 + 8))(v4, a1);
  }
  else
  {
    swift_allocError();
    (*(void (**)(uint64_t, char *, uint64_t))(v2 + 32))(v6, v4, a1);
  }
  BOOL v7 = self;
  int v8 = (void *)_convertErrorToNSError(_:)();
  swift_errorRelease();
  id v9 = [v7 errnoForError:v8];

  return v9;
}

void *sub_1000551D8()
{
  uint64_t v1 = OBJC_IVAR____TtC7backupd19MBDryRestoreManager____lazy_storage___dryRestoreActivity;
  if (*(void *)&v0[OBJC_IVAR____TtC7backupd19MBDryRestoreManager____lazy_storage___dryRestoreActivity])
  {
    uint64_t v2 = *(void **)&v0[OBJC_IVAR____TtC7backupd19MBDryRestoreManager____lazy_storage___dryRestoreActivity];
  }
  else
  {
    uint64_t v3 = v0;
    type metadata accessor for MBDryRestoreActivity();
    swift_allocObject();
    uint64_t v2 = sub_1000474E0((uint64_t)v0);
    *(void *)&v3[v1] = v2;
    swift_retain();
    swift_release();
  }
  swift_retain();
  return v2;
}

void sub_100055258(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC7backupd19MBDryRestoreManager__runState);
  uint64_t v4 = *(void *)(v3 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v4 + 16));
  swift_beginAccess();
  uint64_t v5 = *(void **)(v3 + 24);
  int v6 = *(unsigned __int8 *)(v3 + 32);
  *(void *)(v3 + 24) = a1;
  *(unsigned char *)(v3 + 32) = 0;
  if (v6 == 1)
  {
    id v7 = v5;
    sub_10001946C();
    LOBYTE(v6) = 1;
    sub_100034564(v5, 1);
  }
  sub_100034564(v5, v6);
  swift_endAccess();
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 16));
}

uint64_t sub_10005530C()
{
  uint64_t v1 = sub_100006FC8(&qword_10047D708);
  uint64_t v2 = __chkstk_darwin(v1 - 8);
  uint64_t v4 = (char *)&v34 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v2);
  int v6 = (char *)&v34 - v5;
  uint64_t v7 = sub_100006FC8(&qword_10047E140);
  __chkstk_darwin(v7 - 8);
  id v9 = (char *)&v34 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = (int *)type metadata accessor for MBDryRestoreState();
  uint64_t v11 = *((void *)v10 - 1);
  __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v34 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_10002A3B8((uint64_t)v9);
  int v14 = (*(uint64_t (**)(char *, uint64_t, int *))(v11 + 48))(v9, 1, v10);
  char v35 = v4;
  uint64_t v36 = v0;
  if (v14 == 1)
  {
    *((void *)v13 + 4) = 0;
    *(_OWORD *)uint64_t v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    v13[40] = 1;
    *((void *)v13 + 6) = 0;
    v13[56] = 1;
    *((void *)v13 + 8) = 0;
    v13[72] = 1;
    uint64_t v15 = &v13[v10[9]];
    uint64_t v16 = type metadata accessor for Date();
    uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v16 - 8) + 56);
    v17(v15, 1, 1, v16);
    v17(&v13[v10[10]], 1, 1, v16);
    v17(&v13[v10[11]], 1, 1, v16);
    uint64_t v18 = &v13[v10[12]];
    *(void *)uint64_t v18 = 0;
    v18[8] = 1;
    uint64_t v19 = &v13[v10[13]];
    *(void *)uint64_t v19 = 0;
    v19[8] = 1;
    uint64_t v20 = &v13[v10[14]];
    *(void *)uint64_t v20 = 0;
    v20[8] = 1;
    uint64_t v21 = &v13[v10[15]];
    *(void *)uint64_t v21 = 0;
    *((void *)v21 + 1) = 0;
    v17(&v13[v10[16]], 1, 1, v16);
    v17(&v13[v10[17]], 1, 1, v16);
    sub_10001E2A0((uint64_t)v9, &qword_10047E140);
  }
  else
  {
    sub_100048EE0((uint64_t)v9, (uint64_t)v13);
  }
  id v22 = [objc_allocWithZone((Class)CWFInterface) init];
  [v22 activate];
  id v23 = [v22 networkName];
  if (!v23)
  {
    [v22 invalidate];

    goto LABEL_9;
  }
  uint64_t v24 = v23;
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  v25._countAndFlagsBits = 0x466957656C707041;
  v25._object = (void *)0xE900000000000069;
  LOBYTE(v24) = String.hasPrefix(_:)(v25);
  swift_bridgeObjectRelease();
  [v22 invalidate];

  if ((v24 & 1) == 0)
  {
LABEL_9:
    uint64_t v31 = (uint64_t)&v13[v10[17]];
    sub_10001E2A0(v31, &qword_10047D708);
    uint64_t v32 = type metadata accessor for Date();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v32 - 8) + 56))(v31, 1, 1, v32);
    goto LABEL_10;
  }
  uint64_t v26 = (uint64_t)&v13[v10[17]];
  sub_100048E78(v26, (uint64_t)v6);
  uint64_t v27 = type metadata accessor for Date();
  uint64_t v28 = *(void *)(v27 - 8);
  int v29 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v28 + 48))(v6, 1, v27);
  sub_10001E2A0((uint64_t)v6, &qword_10047D708);
  if (v29 == 1)
  {
    uint64_t v30 = (uint64_t)v35;
    static Date.now.getter();
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v28 + 56))(v30, 0, 1, v27);
    sub_10002C7D8(v30, v26);
  }
LABEL_10:
  sub_100055FAC((uint64_t)v13);
  sub_100050B10();
  sub_10004D110((uint64_t)&v37);
  sub_100055CD0((uint64_t)v13);
  return sub_10002C734((uint64_t)v13);
}

void *sub_1000557F8(uint64_t a1)
{
  id v3 = [self sharedInstance];
  if (!v3) {
    goto LABEL_21;
  }
  uint64_t v4 = v3;
  uint64_t v17 = 0;
  id v5 = [v3 fetchRestorableSnapshotsForAccount:v1 connection:a1 error:&v17];
  int v6 = v17;
  if (v5)
  {
    uint64_t v7 = v5;
    sub_10001C0F4(0, &qword_10047E318);
    unint64_t v8 = static Array._unconditionallyBridgeFromObjectiveC(_:)();
    id v9 = v6;

    uint64_t v17 = _swiftEmptyArrayStorage;
    if (v8 >> 62)
    {
      swift_bridgeObjectRetain();
      uint64_t v10 = _CocoaArrayWrapper.endIndex.getter();
      swift_bridgeObjectRelease();
      if (v10) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v10 = *(void *)((v8 & 0xFFFFFFFFFFFFFF8) + 0x10);
      if (v10)
      {
LABEL_5:
        if (v10 >= 1)
        {
          for (uint64_t i = 0; i != v10; ++i)
          {
            if ((v8 & 0xC000000000000001) != 0) {
              id v12 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
            }
            else {
              id v12 = *(id *)(v8 + 8 * i + 32);
            }
            uint64_t v13 = v12;
            id v14 = [v12 commitID];
            if (v14)
            {

              specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
              specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)();
              specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)();
              specialized ContiguousArray._endMutation()();
            }
            else
            {
            }
          }
          swift_bridgeObjectRelease();
          int v6 = v17;
          goto LABEL_18;
        }
        __break(1u);
LABEL_21:
        __break(1u);
      }
    }
    swift_bridgeObjectRelease();
    int v6 = _swiftEmptyArrayStorage;
LABEL_18:

    return v6;
  }
  uint64_t v15 = v17;
  _convertNSErrorToError(_:)();

  swift_willThrow();
  return v6;
}

unint64_t sub_100055A40@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = sub_10005A798(*a1);
  *(void *)a2 = result;
  *(unsigned char *)(a2 + 8) = v4 & 1;
  return result;
}

id sub_100055ACC()
{
  uint64_t ObjectType = (objc_class *)swift_getObjectType();
  *(void *)&v0[OBJC_IVAR____TtC7backupd19MBDryRestoreManager____lazy_storage___dryRestoreActivity] = 0;
  uint64_t v2 = &v0[OBJC_IVAR____TtC7backupd19MBDryRestoreManager_policy];
  id v3 = v0;
  uint64_t v4 = sub_10003EE84();
  char v6 = v5;
  uint64_t v16 = 0;
  unint64_t v17 = 0xE000000000000000;
  _StringGuts.grow(_:)(19);
  v7._object = (void *)0x8000000100308570;
  v7._countAndFlagsBits = 0xD000000000000011;
  String.append(_:)(v7);
  uint64_t v14 = v4;
  char v15 = v6;
  _print_unlocked<A, B>(_:_:)();
  sub_100045F18(0, 0xE000000000000000, 0xD000000000000015, 0x8000000100304F70);
  swift_bridgeObjectRelease();
  *(void *)uint64_t v2 = v4;
  v2[8] = v6;
  uint64_t v8 = OBJC_IVAR____TtC7backupd19MBDryRestoreManager__runState;
  sub_100006FC8(&qword_10047E310);
  uint64_t v9 = swift_allocObject();
  type metadata accessor for MBUnfairLock();
  uint64_t v10 = swift_allocObject();
  uint64_t v11 = (_DWORD *)swift_slowAlloc();
  *(void *)(v10 + 16) = v11;
  _DWORD *v11 = 0;
  *(void *)(v9 + 16) = v10;
  *(void *)(v9 + 24) = 0;
  *(unsigned char *)(v9 + 32) = 2;
  *(void *)&v3[v8] = v9;

  v13.receiver = v3;
  v13.super_class = ObjectType;
  return objc_msgSendSuper2(&v13, "init");
}

uint64_t sub_100055CD0(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for MBDryRestoreState();
  __chkstk_darwin(v2);
  uint64_t v4 = (char *)&v22 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = sub_100006FC8(&qword_10047D708);
  uint64_t v6 = __chkstk_darwin(v5 - 8);
  uint64_t v8 = (char *)&v22 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v6);
  uint64_t v10 = (char *)&v22 - v9;
  id v11 = [objc_allocWithZone((Class)CWFInterface) init];
  [v11 activate];
  id v12 = [v11 networkName];
  if (!v12)
  {
    [v11 invalidate];

    goto LABEL_6;
  }
  objc_super v13 = v12;
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  v14._countAndFlagsBits = 0x466957656C707041;
  v14._object = (void *)0xE900000000000069;
  LOBYTE(v13) = String.hasPrefix(_:)(v14);
  swift_bridgeObjectRelease();
  [v11 invalidate];

  if ((v13 & 1) == 0)
  {
LABEL_6:
    uint64_t v19 = a1 + *(int *)(v2 + 68);
    sub_10001E2A0(v19, &qword_10047D708);
    uint64_t v20 = type metadata accessor for Date();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v20 - 8) + 56))(v19, 1, 1, v20);
    goto LABEL_7;
  }
  uint64_t v15 = a1 + *(int *)(v2 + 68);
  sub_100048E78(v15, (uint64_t)v10);
  uint64_t v16 = type metadata accessor for Date();
  uint64_t v17 = *(void *)(v16 - 8);
  int v18 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v17 + 48))(v10, 1, v16);
  sub_10001E2A0((uint64_t)v10, &qword_10047D708);
  if (v18 == 1)
  {
    static Date.now.getter();
    (*(void (**)(char *, void, uint64_t, uint64_t))(v17 + 56))(v8, 0, 1, v16);
    sub_10002C7D8((uint64_t)v8, v15);
  }
LABEL_7:
  sub_10002C840(a1, (uint64_t)v4);
  sub_10002A6C8();
  return sub_10002C734((uint64_t)v4);
}

__n128 sub_100055FAC(uint64_t a1)
{
  uint64_t v2 = __chkstk_darwin(a1);
  uint64_t v4 = v3;
  char v5 = sub_1000480B0(v2, *(void *)(v1 + OBJC_IVAR____TtC7backupd19MBDryRestoreManager_policy), *(unsigned char *)(v1 + OBJC_IVAR____TtC7backupd19MBDryRestoreManager_policy + 8));
  if (v5 == 2)
  {
    uint64_t v6 = &v91;
    uint64_t v7 = &v94;
    uint64_t v8 = &v93;
    uint64_t v9 = &v92;
    sub_100045F18(0x62616E6520746F4ELL, 0xEB0000000064656CLL, 0xD000000000000016, 0x8000000100308590);
    sub_100045F18(0x6974636120746F4ELL, 0xEA00000000006576, 0xD000000000000018, 0x8000000100307FD0);
    uint64_t v10 = (__n128 *)v90;
    id v11 = v90;
    int v12 = 6;
LABEL_5:
    sub_100050D24(v12, 0, (uint64_t)v11);
    goto LABEL_6;
  }
  if ((v5 & 1) == 0)
  {
    uint64_t v6 = &v76;
    uint64_t v9 = &v77;
    uint64_t v8 = &v78;
    uint64_t v7 = &v79;
    sub_100045F18(0xD000000000000014, 0x80000001003085B0, 0xD000000000000016, 0x8000000100308590);
    sub_100045F18(0xD000000000000019, 0x80000001003085D0, 0xD000000000000018, 0x8000000100307FD0);
    uint64_t v10 = (__n128 *)v75;
    id v11 = v75;
    int v12 = 5;
    goto LABEL_5;
  }
  id v20 = sub_10005683C();
  if (v20)
  {
    uint64_t v6 = &v81;
    uint64_t v9 = &v82;
    uint64_t v8 = &v83;
    uint64_t v7 = &v84;
    uint64_t v95 = 0;
    unint64_t v96 = 0xE000000000000000;
    uint64_t v22 = v20;
    uint64_t v46 = v20;
    id v47 = v21;
    _StringGuts.grow(_:)(35);
    swift_bridgeObjectRelease();
    uint64_t v95 = 0xD00000000000001DLL;
    unint64_t v96 = 0x8000000100308670;
    id v23 = [v22 description];
    uint64_t v24 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v26 = v25;

    v27._countAndFlagsBits = v24;
    v27._object = v26;
    String.append(_:)(v27);
    swift_bridgeObjectRelease();
    v28._countAndFlagsBits = 8236;
    v28._object = (void *)0xE200000000000000;
    String.append(_:)(v28);
    id v29 = [v47 description];
    uint64_t v30 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v32 = v31;

    v33._countAndFlagsBits = v30;
    v33._object = v32;
    String.append(_:)(v33);
    swift_bridgeObjectRelease();
    sub_100045F18(v95, v96, 0xD000000000000016, 0x8000000100308590);
    swift_bridgeObjectRelease();
    uint64_t v10 = (__n128 *)&v80;
  }
  else
  {
    uint64_t v6 = &v86;
    uint64_t v9 = &v87;
    uint64_t v8 = &v88;
    uint64_t v7 = &v89;
    uint64_t v46 = (void *)sub_100058E78();
    id v47 = v34;
    _StringGuts.grow(_:)(41);
    swift_bridgeObjectRelease();
    id v35 = [v46 description];
    uint64_t v36 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v38 = v37;

    v39._countAndFlagsBits = v36;
    v39._object = v38;
    String.append(_:)(v39);
    swift_bridgeObjectRelease();
    v40._countAndFlagsBits = 8236;
    v40._object = (void *)0xE200000000000000;
    String.append(_:)(v40);
    id v41 = [v47 description];
    uint64_t v42 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    char v44 = v43;

    v45._countAndFlagsBits = v42;
    v45._object = v44;
    String.append(_:)(v45);
    swift_bridgeObjectRelease();
    sub_100045F18(0xD000000000000023, 0x8000000100308640, 0xD000000000000016, 0x8000000100308590);
    swift_bridgeObjectRelease();
    uint64_t v10 = (__n128 *)&v85;
  }
  sub_100057174(v2);

LABEL_6:
  unsigned __int8 v48 = v10[2].n128_u8[8];
  unsigned __int8 v74 = v10[4].n128_u8[8];
  unsigned __int8 v73 = v10[9].n128_u8[0];
  unsigned __int8 v72 = v10[10].n128_u8[0];
  unsigned __int8 v71 = v10[11].n128_u8[0];
  unsigned __int8 v70 = v10[12].n128_u8[0];
  unsigned __int8 v69 = v10[13].n128_u8[0];
  unsigned __int8 v68 = v10[14].n128_u8[0];
  unsigned __int8 v67 = v10[15].n128_u8[0];
  unsigned __int8 v66 = *(unsigned char *)v6;
  unsigned __int8 v65 = *((unsigned char *)v6 + 16);
  unsigned __int8 v64 = *((unsigned char *)v6 + 32);
  unsigned __int8 v63 = *((unsigned char *)v6 + 48);
  unsigned __int8 v62 = *((unsigned char *)v6 + 64);
  unsigned __int8 v61 = *((unsigned char *)v6 + 80);
  unsigned __int8 v60 = *((unsigned char *)v6 + 96);
  unsigned __int8 v59 = *((unsigned char *)v6 + 112);
  unsigned __int8 v58 = *((unsigned char *)v6 + 128);
  unsigned __int8 v57 = *((unsigned char *)v6 + 144);
  unsigned __int8 v56 = *((unsigned char *)v6 + 184);
  unsigned __int8 v55 = *((unsigned char *)v6 + 200);
  unsigned __int8 v54 = *((unsigned char *)v6 + 216);
  unsigned __int8 v53 = *((unsigned char *)v6 + 232);
  unsigned __int8 v52 = *((unsigned char *)v6 + 248);
  unsigned __int8 v51 = *(unsigned char *)v9;
  unsigned __int8 v50 = *(unsigned char *)v8;
  unint64_t v13 = v10[24].n128_u64[1];
  unsigned __int8 v49 = *(unsigned char *)v7;
  v4->n128_u64[0] = v10->n128_u64[0];
  v4->n128_u8[8] = v10->n128_u8[8];
  v4[2].n128_u64[0] = v10[2].n128_u64[0];
  v4[2].n128_u8[8] = v48;
  v4[2].n128_u8[9] = v10[2].n128_u8[9];
  v4[4].n128_u64[0] = v10[4].n128_u64[0];
  v4[4].n128_u8[8] = v74;
  v4[8].n128_u16[0] = v10[8].n128_u16[0];
  v4[8].n128_u64[1] = v10[8].n128_u64[1];
  v4[9].n128_u8[0] = v73;
  v4[9].n128_u64[1] = v10[9].n128_u64[1];
  v4[10].n128_u8[0] = v72;
  v4[10].n128_u64[1] = v10[10].n128_u64[1];
  v4[11].n128_u8[0] = v71;
  v4[11].n128_u64[1] = v10[11].n128_u64[1];
  v4[12].n128_u8[0] = v70;
  v4[12].n128_u64[1] = v10[12].n128_u64[1];
  v4[13].n128_u8[0] = v69;
  v4[13].n128_u64[1] = v10[13].n128_u64[1];
  v4[14].n128_u8[0] = v68;
  v4[14].n128_u64[1] = v10[14].n128_u64[1];
  v4[15].n128_u8[0] = v67;
  v4[15].n128_u64[1] = v10[15].n128_u64[1];
  v4[16].n128_u8[0] = v66;
  v4[16].n128_u64[1] = v10[16].n128_u64[1];
  v4[17].n128_u8[0] = v65;
  v4[17].n128_u64[1] = v10[17].n128_u64[1];
  v4[18].n128_u8[0] = v64;
  v4[18].n128_u64[1] = v10[18].n128_u64[1];
  v4[19].n128_u8[0] = v63;
  v4[19].n128_u64[1] = v10[19].n128_u64[1];
  v4[20].n128_u8[0] = v62;
  v4[20].n128_u64[1] = v10[20].n128_u64[1];
  v4[21].n128_u8[0] = v61;
  v4[21].n128_u64[1] = v10[21].n128_u64[1];
  v4[22].n128_u8[0] = v60;
  v4[22].n128_u64[1] = v10[22].n128_u64[1];
  v4[23].n128_u8[0] = v59;
  v4[23].n128_u64[1] = v10[23].n128_u64[1];
  v4[24].n128_u8[0] = v58;
  v4[24].n128_u64[1] = v13;
  v4[25].n128_u8[0] = v57;
  unint64_t v14 = v10[26].n128_u64[0];
  v4[25].n128_u64[1] = v10[25].n128_u64[1];
  v4[26].n128_u64[0] = v14;
  v4[26].n128_u16[4] = v10[26].n128_u16[4];
  v4[27].n128_u64[0] = v10[27].n128_u64[0];
  v4[27].n128_u8[8] = v56;
  v4[28].n128_u64[0] = v10[28].n128_u64[0];
  v4[28].n128_u8[8] = v55;
  v4[29].n128_u64[0] = v10[29].n128_u64[0];
  v4[29].n128_u8[8] = v54;
  v4[30].n128_u64[0] = v10[30].n128_u64[0];
  v4[30].n128_u8[8] = v53;
  v4[31].n128_u64[0] = v10[31].n128_u64[0];
  v4[31].n128_u8[8] = v52;
  v4[32].n128_u64[0] = v10[32].n128_u64[0];
  v4[32].n128_u8[8] = v51;
  v4[33].n128_u64[0] = v10[33].n128_u64[0];
  v4[33].n128_u8[8] = v50;
  __n128 result = v10[1];
  __n128 v16 = v10[3];
  __n128 v17 = v10[5];
  __n128 v18 = v10[6];
  __n128 v19 = v10[7];
  v4[34].n128_u64[0] = v10[34].n128_u64[0];
  v4[34].n128_u8[8] = v49;
  v4[1] = result;
  v4[3] = v16;
  v4[5] = v17;
  v4[6] = v18;
  v4[7] = v19;
  return result;
}

id sub_10005683C()
{
  uint64_t v2 = v1;
  uint64_t v3 = (void *)v0[1];
  if (!v3)
  {
    uint64_t v25 = 0xD00000000000001FLL;
    uint64_t v26 = "No previous dry restore account";
LABEL_17:
    sub_100045F18(v25, (unint64_t)(v26 - 32) | 0x8000000000000000, 0xD000000000000016, 0x8000000100308590);
    return 0;
  }
  uint64_t v4 = v0;
  uint64_t v5 = v0[2];
  uint64_t v6 = (void *)v0[3];
  uint64_t v7 = v0 + 2;
  if (!v6)
  {
    uint64_t v25 = 0xD000000000000020;
    uint64_t v26 = "No previous dry restore snapshot";
    goto LABEL_17;
  }
  uint64_t v50 = *v0;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  id result = (id)MBBuildVersion();
  if (result)
  {
    uint64_t v9 = result;
    uint64_t v49 = v5;
    uint64_t v10 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    int v12 = v11;

    unint64_t v13 = (uint64_t *)((char *)v4 + *(int *)(type metadata accessor for MBDryRestoreState() + 60));
    unint64_t v14 = (void *)v13[1];
    if (v14)
    {
      uint64_t v15 = *v13;
      BOOL v16 = *v13 == v10 && v14 == v12;
      if (!v16 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
      {
        swift_bridgeObjectRetain();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        _StringGuts.grow(_:)(65);
        v36._countAndFlagsBits = 0xD000000000000017;
        v36._object = (void *)0x8000000100308900;
        String.append(_:)(v36);
        v37._countAndFlagsBits = v15;
        v37._object = v14;
        String.append(_:)(v37);
        swift_bridgeObjectRelease();
        v38._countAndFlagsBits = 0xD000000000000026;
        v38._object = (void *)0x8000000100308920;
        String.append(_:)(v38);
        v39._countAndFlagsBits = v10;
        v39._object = v12;
        String.append(_:)(v39);
        swift_bridgeObjectRelease();
        uint64_t v31 = 0;
        __n128 v19 = (void *)0xE000000000000000;
        unint64_t v32 = 0xE000000000000000;
        goto LABEL_23;
      }
      swift_bridgeObjectRelease();
    }
    *unint64_t v13 = v10;
    v13[1] = (uint64_t)v12;
    id v17 = [self allServiceAccounts];
    sub_10001C0F4(0, (unint64_t *)&qword_10047DE60);
    unint64_t v18 = static Array._unconditionallyBridgeFromObjectiveC(_:)();

    swift_bridgeObjectRetain();
    __n128 v19 = sub_100059718(v18, v50, (uint64_t)v3);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (v19)
    {
      swift_bridgeObjectRelease();
      id v20 = [v19 persona];
      id v21 = [v20 dryRestoreContentDirectory];
      static String._unconditionallyBridgeFromObjectiveC(_:)();

      sub_100006FC8((uint64_t *)&unk_10047D910);
      unint64_t v51 = swift_allocBox();
      FilePath.init(_:)();
      id v22 = [v20 dryRestoreMetadataDirectory];
      static String._unconditionallyBridgeFromObjectiveC(_:)();

      uint64_t v23 = swift_allocBox();
      FilePath.init(_:)();
      uint64_t v24 = sub_1000557F8(0);
      if (v2)
      {
        swift_bridgeObjectRelease();

        swift_release();
      }
      else
      {
        unint64_t v33 = (unint64_t)v24;
        unint64_t v48 = v23;
        swift_bridgeObjectRetain();
        uint64_t v34 = sub_10004A818(v33, v49, (uint64_t)v6);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (v34)
        {
          swift_bridgeObjectRelease();
          if (sub_100008804(v51))
          {
            char v35 = sub_100008804(v48);
            if (v35)
            {

              swift_release();
              swift_release();
              return v19;
            }
            _StringGuts.grow(_:)(47);
            swift_bridgeObjectRelease();
            v47._countAndFlagsBits = sub_10002D874(v48);
            String.append(_:)(v47);
            swift_bridgeObjectRelease();
            sub_1000467F0(502, 0xD00000000000002DLL, 0x80000001003088D0, 0xD000000000000016, 0x8000000100308590);
            swift_bridgeObjectRelease();
            swift_willThrow();

            swift_release();
          }
          else
          {
            _StringGuts.grow(_:)(46);
            swift_bridgeObjectRelease();
            v46._countAndFlagsBits = sub_10002D874(v51);
            String.append(_:)(v46);
            swift_bridgeObjectRelease();
            sub_1000467F0(502, 0xD00000000000002CLL, 0x80000001003088A0, 0xD000000000000016, 0x8000000100308590);
            swift_bridgeObjectRelease();
            swift_willThrow();

            swift_release();
          }
          swift_release();

          return v19;
        }
        _StringGuts.grow(_:)(62);
        v40._countAndFlagsBits = 0xD00000000000001ALL;
        v40._object = (void *)0x8000000100308800;
        String.append(_:)(v40);
        v41._countAndFlagsBits = v49;
        v41._object = v6;
        String.append(_:)(v41);
        swift_bridgeObjectRelease();
        v42._countAndFlagsBits = 0xD000000000000020;
        v42._object = (void *)0x8000000100308820;
        String.append(_:)(v42);
        _print_unlocked<A, B>(_:_:)();
        sub_100045F18(0, 0xE000000000000000, 0xD000000000000016, 0x8000000100308590);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        *uint64_t v7 = 0;
        v7[1] = 0;
        _StringGuts.grow(_:)(41);
        swift_bridgeObjectRelease();
        v43._countAndFlagsBits = sub_10002D874(v51);
        String.append(_:)(v43);
        swift_bridgeObjectRelease();
        v44._countAndFlagsBits = 8236;
        v44._object = (void *)0xE200000000000000;
        String.append(_:)(v44);
        v45._countAndFlagsBits = sub_10002D874(v48);
        String.append(_:)(v45);
        swift_bridgeObjectRelease();
        sub_100045F18(0xD000000000000023, 0x8000000100308850, 0xD000000000000016, 0x8000000100308590);
        swift_bridgeObjectRelease();
        sub_1000083B8(v51);
        sub_1000083B8(v48);
        sub_1000467F0(502, 0xD00000000000001BLL, 0x8000000100308880, 0xD000000000000016, 0x8000000100308590);
        swift_willThrow();

        swift_release();
      }
      swift_release();
      return v19;
    }
    swift_bridgeObjectRelease();
    _StringGuts.grow(_:)(44);
    v27._countAndFlagsBits = 0xD000000000000026;
    v27._object = (void *)0x80000001003087B0;
    String.append(_:)(v27);
    v28._countAndFlagsBits = v50;
    v28._object = v3;
    String.append(_:)(v28);
    v29._countAndFlagsBits = 8250;
    v29._object = (void *)0xE200000000000000;
    String.append(_:)(v29);
    _print_unlocked<A, B>(_:_:)();
    sub_1000465BC(0, 0xE000000000000000, 0xD000000000000016, 0x8000000100308590);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    *uint64_t v4 = 0;
    v4[1] = 0;
    _StringGuts.grow(_:)(30);
    swift_bridgeObjectRelease();
    v30._countAndFlagsBits = v50;
    v30._object = v3;
    String.append(_:)(v30);
    swift_bridgeObjectRelease();
    uint64_t v31 = 0xD00000000000001CLL;
    __n128 v19 = (void *)0x80000001003087E0;
    unint64_t v32 = 0x80000001003087E0;
LABEL_23:
    sub_1000467F0(502, v31, v32, 0xD000000000000016, 0x8000000100308590);
    swift_bridgeObjectRelease();
    swift_willThrow();
    return v19;
  }
  __break(1u);
  return result;
}

unint64_t sub_100057174(uint64_t a1)
{
  __chkstk_darwin(a1);
  uint64_t v2 = v1;
  char v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  unint64_t result = (unint64_t)[v5 snapshotUUID];
  if (!result)
  {
    __break(1u);
    goto LABEL_23;
  }
  int v12 = (void *)result;
  char v183 = v4;
  uint64_t v13 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v15 = v14;

  unint64_t result = (unint64_t)[v6 backupUUID];
  if (!result)
  {
LABEL_23:
    __break(1u);
    return result;
  }
  BOOL v16 = (void *)result;
  uint64_t v180 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v185 = v17;

  id v18 = [v8 persona];
  uint64_t v177 = v8;
  id v19 = [v18 dryRestoreContentDirectory];
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  sub_100006FC8((uint64_t *)&unk_10047D910);
  unint64_t v20 = swift_allocBox();
  FilePath.init(_:)();
  unint64_t v188 = sub_10002D538(v13, (uint64_t)v15, v20);
  swift_release();
  id v21 = [v18 dryRestoreMetadataDirectory];
  static String._unconditionallyBridgeFromObjectiveC(_:)();

  unint64_t v22 = swift_allocBox();
  FilePath.init(_:)();
  unint64_t v23 = sub_10002D538(v13, (uint64_t)v15, v22);
  swift_release();
  uint64_t v24 = *(void *)(v2 + OBJC_IVAR____TtC7backupd19MBDryRestoreManager__runState);
  uint64_t v25 = *(void *)(v24 + 16);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v25 + 16));
  swift_beginAccess();
  uint64_t v26 = *(void *)(v24 + 24);
  int v27 = *(unsigned __int8 *)(v24 + 32);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v25 + 16));
  if (v27)
  {
    uint64_t v139 = v18;
    unsigned __int8 v60 = (void *)sub_10001A794(v188, v23, v13, v15, v180, v185, (v183 & 1) == 0, v177, 0, 0, 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    id v61 = v60;
    sub_10004F414((uint64_t)v61);
    unsigned __int8 v62 = (char *)v61;
    uint64_t v63 = sub_1000344B4(v24, v62);
    char v65 = v64;

    if (v65)
    {
      sub_100045F18(0xD000000000000016, 0x80000001003086B0, 0xD000000000000016, 0x8000000100308590);
      sub_1000598C0(v183 & 1, (uint64_t)v420);
      uint64_t v69 = *(void *)(v24 + 16);
      os_unfair_lock_lock(*(os_unfair_lock_t *)(v69 + 16));
      unsigned __int8 v70 = *(void **)(v24 + 24);
      int v71 = *(unsigned __int8 *)(v24 + 32);
      *(void *)(v24 + 24) = 1;
      *(unsigned char *)(v24 + 32) = 2;
      sub_1000590A8(v70, v71);
      sub_100034564(v70, v71);
      os_unfair_lock_unlock(*(os_unfair_lock_t *)(v69 + 16));
      sub_1000191CC(0xD000000000000014, 0x8000000100304DA0, *(void (**)(void))&v62[OBJC_IVAR____TtC7backupd19MBDryRestoreSession__releaseRestoreLock]);
      unsigned __int8 v72 = v62;
      sub_10001BBE8(0xD000000000000015, 0x8000000100304DC0, (uint64_t)v72, (uint64_t)v72);

      unsigned __int8 v73 = v72;
      char v138 = v71;
      if (v71)
      {
        sub_10001BD04(0xD000000000000015, 0x8000000100304DE0, (uint64_t)v73, (uint64_t)v73, 1);

        unsigned __int8 v74 = v73;
        sub_10001BE24(0xD000000000000019, 0x8000000100304E20, (uint64_t)v74, (uint64_t)v74);
      }
      else
      {
        sub_10001BD04(0xD000000000000015, 0x8000000100304DE0, (uint64_t)v73, (uint64_t)v73, 0);

        char v75 = v73;
        sub_10001BE3C(0xD00000000000001FLL, 0x8000000100304E00, (uint64_t)v75, (uint64_t)v75);
        uint64_t v63 = (uint64_t)v70;
      }

      uint64_t v76 = *(char **)&v73[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context];
      [*(id *)&v76[OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress] ended];
      sub_10004D028((uint64_t)v420, (uint64_t)&v691, &qword_10047E170);
      if (sub_10005A3DC((uint64_t)&v691) == 1)
      {
        uint64_t v77 = v76;
        id v78 = sub_10000E134();

        if (v78)
        {
          uint64_t v79 = self;
          swift_errorRetain();
          swift_errorRetain();
          char v80 = (void *)_convertErrorToNSError(_:)();
          LODWORD(v79) = [v79 isCancelledError:v80];

          if (v79)
          {
            char v97 = v70;
            sub_100045F18(0xD000000000000013, 0x8000000100307FF0, 0xD000000000000018, 0x8000000100307FD0);
            uint64_t v98 = v73;
            sub_100050D24(2, (uint64_t)v73, (uint64_t)&v421);
            uint64_t v94 = v421;
            char v165 = v422;
            char v58 = v425;
            uint64_t v146 = v428;
            uint64_t v147 = v424;
            char v56 = v429;
            long long v134 = v430;
            long long v136 = v427;
            long long v130 = v423;
            long long v132 = v431;
            char v166 = v432[16];
            char v167 = v432[17];
            char v95 = v434;
            char v96 = v426;
            uint64_t v163 = v435;
            uint64_t v164 = v433;
            char v168 = v448;
            char v170 = v450;
            char v172 = v452;
            char v174 = v454;
            char v175 = v456;
            char v178 = v458;
            char v112 = v462;
            char v114 = v460;
            char v93 = v464;
            char v108 = v472;
            char v110 = v466;
            char v106 = v476;
            unsigned int v107 = v474;
            char v101 = v478;
            char v81 = v480;
            char v82 = v482;
            char v99 = v480;
            char v100 = v482;
            char v181 = v484;
            char v186 = v486;
            char v83 = v436;
            char v84 = v438;
            uint64_t v148 = v439;
            uint64_t v149 = v437;
            char v92 = v440;
            char v140 = v442;
            uint64_t v150 = v443;
            uint64_t v151 = v441;
            char v142 = v444;
            char v144 = v446;
            uint64_t v152 = v447;
            uint64_t v153 = v445;
            uint64_t v154 = v451;
            uint64_t v155 = v449;
            uint64_t v156 = v455;
            uint64_t v157 = v453;
            uint64_t v158 = v459;
            uint64_t v159 = v457;
            uint64_t v160 = v463;
            uint64_t v161 = v461;
            uint64_t v162 = v465;
            uint64_t v184 = v467;
            uint64_t v187 = v468;
            char v126 = v470;
            char v128 = v469;
            uint64_t v122 = v473;
            uint64_t v124 = v471;
            uint64_t v118 = v477;
            uint64_t v120 = v475;
            uint64_t v102 = v481;
            uint64_t v103 = v479;
            uint64_t v104 = v483;
            uint64_t v105 = v485;
            sub_10004D028((uint64_t)v432, (uint64_t)v771, &qword_10047E180);
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            swift_bridgeObjectRetain();
            sub_10004D08C((uint64_t)v771);
            long long v116 = xmmword_1003B2EC0;
            char v218 = v168;
            char v220 = v170;
            char v222 = v172;
            char v224 = v174;
            char v226 = v175;
            char v228 = v178;
            char v230 = v114;
            char v232 = v112;
            char v234 = v93;
            char v236 = v110;
            char v242 = v108;
            char v244 = v107;
            char v246 = v106;
            char v248 = v101;
            char v250 = v81;
            char v252 = v82;
            char v254 = v181;
            char v256 = v186;
            char v46 = v93;
            uint64_t v59 = v94;
            uint64_t v189 = v94;
            char v190 = v165;
            long long v191 = v130;
            uint64_t v192 = v147;
            char v193 = v58;
            char v57 = v96;
            char v194 = v96;
            long long v195 = v136;
            uint64_t v196 = v146;
            char v197 = v56;
            long long v198 = v134;
            long long v199 = v132;
            long long v200 = xmmword_1003B2EC0;
            char v201 = v166;
            char v202 = v167;
            uint64_t v203 = v164;
            char v55 = v95;
            char v204 = v95;
            uint64_t v205 = v163;
            char v54 = v83;
            char v206 = v83;
            uint64_t v207 = v149;
            char v53 = v84;
            char v208 = v84;
            uint64_t v209 = v148;
            char v52 = v92;
            char v210 = v92;
            uint64_t v211 = v151;
            char v212 = v140;
            uint64_t v213 = v150;
            char v214 = v142;
            uint64_t v215 = v153;
            char v216 = v144;
            uint64_t v217 = v152;
            uint64_t v219 = v155;
            uint64_t v221 = v154;
            uint64_t v223 = v157;
            uint64_t v225 = v156;
            uint64_t v227 = v159;
            uint64_t v229 = v158;
            uint64_t v231 = v161;
            uint64_t v233 = v160;
            uint64_t v235 = v162;
            uint64_t v237 = v184;
            uint64_t v238 = v187;
            char v239 = v128;
            char v240 = v126;
            uint64_t v241 = v124;
            uint64_t v243 = v122;
            uint64_t v245 = v120;
            uint64_t v247 = v118;
            uint64_t v249 = v103;
            uint64_t v251 = v102;
            uint64_t v253 = v104;
            uint64_t v255 = v105;
            sub_10004D0B8((uint64_t)&v189);
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            sub_10004D110((uint64_t)&v189);
            swift_errorRelease();

            swift_release();
            swift_release();
            sub_100034564(v97, v138);
            swift_errorRelease();
          }
          else
          {
            sub_100052074((uint64_t)v78, (uint64_t)v73, (uint64_t)&v487);
            swift_errorRelease();

            swift_release();
            swift_release();
            sub_100034564(v70, v71);
            swift_errorRelease();

            char v186 = v554;
            uint64_t v104 = v551;
            uint64_t v105 = v553;
            char v181 = v552;
            uint64_t v102 = v549;
            uint64_t v103 = v547;
            char v99 = v548;
            char v100 = v550;
            char v101 = v546;
            uint64_t v118 = v545;
            uint64_t v120 = v543;
            char v106 = v544;
            unsigned int v107 = v542;
            uint64_t v122 = v541;
            uint64_t v124 = v539;
            char v126 = v538;
            char v128 = v537;
            uint64_t v187 = v536;
            uint64_t v184 = v535;
            char v108 = v540;
            char v110 = v534;
            char v112 = v530;
            char v114 = v528;
            char v178 = v526;
            char v175 = v524;
            char v174 = v522;
            char v172 = v520;
            char v170 = v518;
            char v168 = v516;
            char v46 = v532;
            long long v116 = v498;
            long long v132 = v497;
            long long v134 = v496;
            long long v136 = v493;
            long long v130 = v489;
            uint64_t v161 = v529;
            uint64_t v162 = v533;
            uint64_t v159 = v525;
            uint64_t v160 = v531;
            uint64_t v157 = v521;
            uint64_t v158 = v527;
            uint64_t v155 = v517;
            uint64_t v156 = v523;
            uint64_t v153 = v513;
            uint64_t v154 = v519;
            char v144 = v514;
            char v142 = v512;
            uint64_t v151 = v509;
            uint64_t v152 = v515;
            char v140 = v510;
            uint64_t v148 = v507;
            char v52 = v508;
            uint64_t v149 = v505;
            uint64_t v150 = v511;
            char v53 = v506;
            char v54 = v504;
            uint64_t v163 = v503;
            uint64_t v164 = v501;
            char v55 = v502;
            char v167 = v500;
            char v166 = v499;
            char v56 = v495;
            char v57 = v492;
            uint64_t v146 = v494;
            uint64_t v147 = v490;
            char v58 = v491;
            char v165 = v488;
            uint64_t v59 = v487;
          }
          swift_errorRelease();
          long long v48 = v116;
          long long v51 = v130;
          long long v47 = v132;
          long long v49 = v134;
          long long v50 = v136;
          char v44 = v112;
          char v45 = v114;
          uint64_t v38 = v122;
          uint64_t v39 = v124;
          char v40 = v108;
          char v43 = v110;
          uint64_t v35 = v118;
          uint64_t v36 = v120;
          uint64_t v31 = v102;
          uint64_t v32 = v103;
          char v37 = v106;
          unint64_t result = v107;
          uint64_t v29 = v104;
          uint64_t v28 = v105;
          char v34 = v101;
          char v33 = v99;
          char v30 = v100;
          char v41 = v126;
          char v42 = v128;
        }
        else if (v71)
        {
          sub_10004F5B4((uint64_t)v73, &v623);

          swift_release();
          swift_release();
          sub_100034564(v70, v71);
          char v186 = v690;
          char v181 = v688;
          char v30 = v686;
          char v33 = v684;
          char v34 = v682;
          char v37 = v680;
          unint64_t result = v678;
          char v40 = v676;
          char v41 = v674;
          char v42 = v673;
          char v43 = v670;
          char v178 = v662;
          char v175 = v660;
          char v174 = v658;
          char v172 = v656;
          char v170 = v654;
          char v168 = v652;
          char v144 = v650;
          char v142 = v648;
          char v140 = v646;
          char v52 = v644;
          char v53 = v642;
          char v54 = v640;
          char v55 = v638;
          char v167 = v636;
          char v166 = v635;
          long long v47 = v633;
          long long v48 = v634;
          long long v49 = v632;
          char v56 = v631;
          long long v50 = v629;
          long long v51 = v625;
          char v57 = v628;
          char v58 = v627;
          char v165 = v624;
          char v46 = v668;
          uint64_t v28 = v689;
          uint64_t v29 = v687;
          uint64_t v31 = v685;
          uint64_t v32 = v683;
          uint64_t v35 = v681;
          uint64_t v36 = v679;
          uint64_t v38 = v677;
          uint64_t v39 = v675;
          uint64_t v187 = v672;
          char v44 = v666;
          uint64_t v184 = v671;
          char v45 = v664;
          uint64_t v162 = v669;
          uint64_t v160 = v667;
          uint64_t v161 = v665;
          uint64_t v158 = v663;
          uint64_t v159 = v661;
          uint64_t v156 = v659;
          uint64_t v157 = v657;
          uint64_t v154 = v655;
          uint64_t v155 = v653;
          uint64_t v152 = v651;
          uint64_t v153 = v649;
          uint64_t v150 = v647;
          uint64_t v151 = v645;
          uint64_t v148 = v643;
          uint64_t v149 = v641;
          uint64_t v163 = v639;
          uint64_t v164 = v637;
          uint64_t v146 = v630;
          uint64_t v147 = v626;
          uint64_t v59 = v623;
        }
        else
        {
          sub_100051A38(v63, (uint64_t)v73, &v555);

          swift_release();
          swift_release();
          sub_100034564(v70, 0);

          char v186 = v622;
          char v181 = v620;
          char v30 = v618;
          char v33 = v616;
          char v34 = v614;
          char v37 = v612;
          unint64_t result = v610;
          char v40 = v608;
          char v41 = v606;
          char v42 = v605;
          char v43 = v602;
          char v178 = v594;
          char v175 = v592;
          char v174 = v590;
          char v172 = v588;
          char v170 = v586;
          char v168 = v584;
          char v46 = v600;
          char v144 = v582;
          char v142 = v580;
          char v140 = v578;
          char v52 = v576;
          char v53 = v574;
          char v54 = v572;
          char v55 = v570;
          char v167 = v568;
          char v166 = v567;
          long long v48 = v566;
          long long v47 = v565;
          long long v49 = v564;
          char v56 = v563;
          long long v50 = v561;
          long long v51 = v557;
          char v57 = v560;
          char v58 = v559;
          char v165 = v556;
          uint64_t v28 = v621;
          uint64_t v29 = v619;
          uint64_t v31 = v617;
          uint64_t v32 = v615;
          uint64_t v35 = v613;
          uint64_t v36 = v611;
          uint64_t v38 = v609;
          uint64_t v39 = v607;
          uint64_t v187 = v604;
          char v44 = v598;
          uint64_t v184 = v603;
          char v45 = v596;
          uint64_t v162 = v601;
          uint64_t v160 = v599;
          uint64_t v161 = v597;
          uint64_t v158 = v595;
          uint64_t v159 = v593;
          uint64_t v156 = v591;
          uint64_t v157 = v589;
          uint64_t v154 = v587;
          uint64_t v155 = v585;
          uint64_t v152 = v583;
          uint64_t v153 = v581;
          uint64_t v150 = v579;
          uint64_t v151 = v577;
          uint64_t v148 = v575;
          uint64_t v149 = v573;
          uint64_t v163 = v571;
          uint64_t v164 = v569;
          uint64_t v146 = v562;
          uint64_t v147 = v558;
          uint64_t v59 = v555;
        }
      }
      else
      {
        char v165 = v692;
        char v85 = v73;
        uint64_t v59 = v691;
        LOBYTE(v189) = v695;
        v771[0] = v696;
        char v770 = v699;
        long long v135 = v700;
        long long v137 = v697;
        long long v131 = v693;
        long long v133 = v701;
        long long v117 = v702;
        char v166 = v703;
        char v167 = v704;
        uint64_t v146 = v698;
        uint64_t v147 = v694;
        char v769 = v706;
        char v768 = v708;
        uint64_t v163 = v707;
        uint64_t v164 = v705;
        char v767 = v710;
        char v766 = v712;
        uint64_t v148 = v711;
        uint64_t v149 = v709;
        char v765 = v714;
        char v764 = v716;
        uint64_t v150 = v715;
        uint64_t v151 = v713;
        char v763 = v718;
        char v762 = v720;
        uint64_t v152 = v719;
        uint64_t v153 = v717;
        char v761 = v722;
        char v760 = v724;
        uint64_t v154 = v723;
        uint64_t v155 = v721;
        char v759 = v726;
        char v176 = v728;
        uint64_t v156 = v727;
        uint64_t v157 = v725;
        char v179 = v730;
        char v141 = v732;
        uint64_t v158 = v731;
        uint64_t v159 = v729;
        char v143 = v734;
        uint64_t v160 = v735;
        uint64_t v161 = v733;
        uint64_t v162 = v737;
        char v145 = v738;
        uint64_t v184 = v739;
        uint64_t v187 = v740;
        char v127 = v742;
        char v129 = v741;
        char v113 = v744;
        char v115 = v736;
        uint64_t v123 = v745;
        uint64_t v125 = v743;
        char v169 = v746;
        uint64_t v119 = v749;
        uint64_t v121 = v747;
        char v171 = v750;
        char v109 = v752;
        char v111 = v748;
        uint64_t v86 = v751;
        uint64_t v87 = v753;
        char v173 = v754;
        uint64_t v88 = v755;
        char v182 = v756;
        uint64_t v89 = v70;
        uint64_t v90 = v757;
        char v91 = v758;

        swift_release();
        swift_release();
        sub_100034564(v89, v138);

        long long v48 = v117;
        long long v51 = v131;
        long long v47 = v133;
        long long v49 = v135;
        long long v50 = v137;
        uint64_t v38 = v123;
        uint64_t v39 = v125;
        uint64_t v35 = v119;
        uint64_t v36 = v121;
        uint64_t v32 = v86;
        uint64_t v31 = v87;
        uint64_t v29 = v88;
        uint64_t v28 = v90;
        char v41 = v127;
        char v42 = v129;
        char v186 = v91 & 1;
        char v174 = v759;
        char v181 = v182 & 1;
        char v30 = v173 & 1;
        char v172 = v760;
        char v33 = v109 & 1;
        char v34 = v171 & 1;
        char v170 = v761;
        char v37 = v111 & 1;
        unint64_t result = v169 & 1;
        char v168 = v762;
        char v40 = v113 & 1;
        char v43 = v145 & 1;
        char v144 = v763;
        char v44 = v143 & 1;
        char v142 = v764;
        char v45 = v141 & 1;
        char v178 = v179 & 1;
        char v175 = v176 & 1;
        char v140 = v765;
        char v52 = v766;
        char v53 = v767;
        char v54 = v768;
        char v55 = v769;
        char v56 = v770;
        char v57 = v771[0];
        char v46 = v115 & 1;
        char v58 = v189;
      }
    }
    else
    {
      sub_100045F18(0xD000000000000027, 0x80000001003086D0, 0xD000000000000016, 0x8000000100308590);
      sub_1000191CC(0xD000000000000014, 0x8000000100304DA0, *(void (**)(void))&v62[OBJC_IVAR____TtC7backupd19MBDryRestoreSession__releaseRestoreLock]);
      unsigned __int8 v66 = v62;
      sub_10001BBE8(0xD000000000000015, 0x8000000100304DC0, (uint64_t)v66, (uint64_t)v66);

      unsigned __int8 v67 = v66;
      sub_10001BD04(0xD000000000000015, 0x8000000100304DE0, (uint64_t)v67, (uint64_t)v67, 1);

      unsigned __int8 v68 = v67;
      sub_10001BE24(0xD000000000000019, 0x8000000100304E20, (uint64_t)v68, (uint64_t)v68);

      [*(id *)(*(void *)&v68[OBJC_IVAR____TtC7backupd19MBDryRestoreSession_context]+ OBJC_IVAR____TtC7backupd19MBDryRestoreContext_progress) ended];
      sub_100051A38(v63, (uint64_t)v68, &v352);

      swift_release();
      swift_release();
      uint64_t v28 = v418;
      char v186 = v419;
      uint64_t v29 = v416;
      char v181 = v417;
      char v30 = v415;
      uint64_t v31 = v414;
      uint64_t v32 = v412;
      char v33 = v413;
      char v34 = v411;
      uint64_t v35 = v410;
      uint64_t v36 = v408;
      char v37 = v409;
      unint64_t result = v407;
      uint64_t v38 = v406;
      uint64_t v39 = v404;
      char v40 = v405;
      char v41 = v403;
      char v42 = v402;
      uint64_t v187 = v401;
      uint64_t v184 = v400;
      char v43 = v399;
      char v44 = v395;
      char v45 = v393;
      char v178 = v391;
      char v175 = v389;
      char v174 = v387;
      char v172 = v385;
      char v170 = v383;
      char v168 = v381;
      char v46 = v397;
      long long v48 = v363;
      long long v47 = v362;
      long long v49 = v361;
      long long v50 = v358;
      long long v51 = v354;
      uint64_t v162 = v398;
      uint64_t v160 = v396;
      uint64_t v161 = v394;
      uint64_t v158 = v392;
      uint64_t v159 = v390;
      uint64_t v156 = v388;
      uint64_t v157 = v386;
      uint64_t v154 = v384;
      uint64_t v155 = v382;
      uint64_t v152 = v380;
      uint64_t v153 = v378;
      char v144 = v379;
      uint64_t v150 = v376;
      char v142 = v377;
      uint64_t v151 = v374;
      char v140 = v375;
      uint64_t v148 = v372;
      char v52 = v373;
      uint64_t v149 = v370;
      char v53 = v371;
      uint64_t v163 = v368;
      char v54 = v369;
      uint64_t v164 = v366;
      char v55 = v367;
      char v167 = v365;
      char v166 = v364;
      uint64_t v146 = v359;
      char v56 = v360;
      char v57 = v357;
      uint64_t v147 = v355;
      char v58 = v356;
      char v165 = v353;
      uint64_t v59 = v352;
    }
  }
  else
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_100051A38(v26, 0, &v284);

    swift_release();
    swift_release();
    uint64_t v28 = v350;
    char v186 = v351;
    uint64_t v29 = v348;
    char v181 = v349;
    char v30 = v347;
    uint64_t v31 = v346;
    uint64_t v32 = v344;
    char v33 = v345;
    char v34 = v343;
    uint64_t v35 = v342;
    uint64_t v36 = v340;
    char v37 = v341;
    unint64_t result = v339;
    uint64_t v38 = v338;
    uint64_t v39 = v336;
    char v40 = v337;
    char v41 = v335;
    char v42 = v334;
    uint64_t v187 = v333;
    uint64_t v184 = v332;
    char v43 = v331;
    char v44 = v327;
    char v45 = v325;
    char v178 = v323;
    char v175 = v321;
    char v174 = v319;
    char v172 = v317;
    char v170 = v315;
    char v168 = v313;
    char v46 = v329;
    long long v47 = v294;
    long long v48 = v295;
    long long v49 = v293;
    long long v50 = v290;
    long long v51 = v286;
    uint64_t v162 = v330;
    uint64_t v160 = v328;
    uint64_t v161 = v326;
    uint64_t v158 = v324;
    uint64_t v159 = v322;
    uint64_t v156 = v320;
    uint64_t v157 = v318;
    uint64_t v154 = v316;
    uint64_t v155 = v314;
    uint64_t v152 = v312;
    uint64_t v153 = v310;
    char v144 = v311;
    uint64_t v150 = v308;
    char v142 = v309;
    uint64_t v151 = v306;
    char v140 = v307;
    uint64_t v148 = v304;
    char v52 = v305;
    uint64_t v149 = v302;
    char v53 = v303;
    uint64_t v163 = v300;
    char v54 = v301;
    uint64_t v164 = v298;
    char v55 = v299;
    char v167 = v297;
    char v166 = v296;
    uint64_t v146 = v291;
    char v56 = v292;
    char v57 = v289;
    uint64_t v147 = v287;
    char v58 = v288;
    char v165 = v285;
    uint64_t v59 = v284;
  }
  char v283 = v58;
  char v282 = v56;
  char v281 = v55;
  char v280 = v54;
  char v279 = v53;
  char v278 = v52;
  char v277 = v140;
  char v276 = v142;
  char v275 = v144;
  char v274 = v168;
  char v273 = v170;
  char v272 = v172;
  char v271 = v174;
  char v270 = v175;
  char v269 = v178;
  char v268 = v45;
  char v267 = v44;
  char v266 = v46;
  char v265 = v43;
  char v264 = v40;
  char v263 = result;
  char v262 = v37;
  char v261 = v34;
  char v260 = v33;
  char v259 = v30;
  char v258 = v181;
  char v257 = v186;
  *(void *)uint64_t v10 = v59;
  *(unsigned char *)(v10 + 8) = v165;
  *(void *)(v10 + 32) = v147;
  *(unsigned char *)(v10 + 41) = v57;
  *(void *)(v10 + 64) = v146;
  *(unsigned char *)(v10 + 128) = v166;
  *(unsigned char *)(v10 + 40) = v283;
  *(unsigned char *)(v10 + 72) = v282;
  *(_OWORD *)(v10 + 16) = v51;
  *(_OWORD *)(v10 + 48) = v50;
  *(_OWORD *)(v10 + 80) = v49;
  *(_OWORD *)(v10 + 96) = v47;
  *(_OWORD *)(v10 + 112) = v48;
  *(unsigned char *)(v10 + 129) = v167;
  *(void *)(v10 + 136) = v164;
  *(unsigned char *)(v10 + 144) = v281;
  *(void *)(v10 + 152) = v163;
  *(unsigned char *)(v10 + 160) = v280;
  *(void *)(v10 + 168) = v149;
  *(unsigned char *)(v10 + 176) = v279;
  *(void *)(v10 + 184) = v148;
  *(unsigned char *)(v10 + 192) = v278;
  *(void *)(v10 + 200) = v151;
  *(unsigned char *)(v10 + 208) = v277;
  *(void *)(v10 + 216) = v150;
  *(unsigned char *)(v10 + 224) = v276;
  *(void *)(v10 + 232) = v153;
  *(unsigned char *)(v10 + 240) = v275;
  *(void *)(v10 + 248) = v152;
  *(unsigned char *)(v10 + 256) = v274;
  *(void *)(v10 + 264) = v155;
  *(unsigned char *)(v10 + 272) = v273;
  *(void *)(v10 + 280) = v154;
  *(unsigned char *)(v10 + 288) = v272;
  *(void *)(v10 + 296) = v157;
  *(unsigned char *)(v10 + 304) = v271;
  *(void *)(v10 + 312) = v156;
  *(unsigned char *)(v10 + 320) = v270;
  *(void *)(v10 + 328) = v159;
  *(unsigned char *)(v10 + 336) = v269;
  *(void *)(v10 + 344) = v158;
  *(unsigned char *)(v10 + 352) = v268;
  *(void *)(v10 + 360) = v161;
  *(unsigned char *)(v10 + 368) = v267;
  *(void *)(v10 + 376) = v160;
  *(unsigned char *)(v10 + 384) = v266;
  *(void *)(v10 + 392) = v162;
  *(unsigned char *)(v10 + 400) = v265;
  *(void *)(v10 + 408) = v184;
  *(void *)(v10 + 416) = v187;
  *(unsigned char *)(v10 + 424) = v42;
  *(unsigned char *)(v10 + 425) = v41;
  *(void *)(v10 + 432) = v39;
  *(unsigned char *)(v10 + 440) = v264;
  *(void *)(v10 + 448) = v38;
  *(unsigned char *)(v10 + 456) = v263;
  *(void *)(v10 + 464) = v36;
  *(unsigned char *)(v10 + 472) = v262;
  *(void *)(v10 + 480) = v35;
  *(unsigned char *)(v10 + 488) = v261;
  *(void *)(v10 + 496) = v32;
  *(unsigned char *)(v10 + 504) = v260;
  *(void *)(v10 + 512) = v31;
  *(unsigned char *)(v10 + 520) = v259;
  *(void *)(v10 + 528) = v29;
  *(unsigned char *)(v10 + 536) = v258;
  *(void *)(v10 + 544) = v28;
  *(unsigned char *)(v10 + 552) = v257;
  return result;
}

unint64_t sub_100058E78()
{
  sub_100045F18(0xD000000000000025, 0x8000000100308700, 0xD000000000000016, 0x8000000100308590);
  id v2 = [self allServiceAccounts];
  sub_10001C0F4(0, (unint64_t *)&qword_10047DE60);
  id v3 = (id)static Array._unconditionallyBridgeFromObjectiveC(_:)();

  id v4 = v0;
  uint64_t v5 = sub_10005A5C0((unint64_t)v3);
  swift_bridgeObjectRelease();

  if (v1) {
    return (unint64_t)v3;
  }
  unint64_t v6 = v5[2];
  if (!v6)
  {
    swift_bridgeObjectRelease();
    sub_1000467F0(502, 0xD00000000000002BLL, 0x8000000100308730, 0xD000000000000016, 0x8000000100308590);
    swift_willThrow();
    return (unint64_t)v3;
  }
  unint64_t result = sub_10004A78C(v6);
  if ((result & 0x8000000000000000) != 0)
  {
    __break(1u);
  }
  else if (result < v5[2])
  {
    uint64_t v8 = &v5[2 * result];
    uint64_t v9 = (void *)v8[5];
    id v3 = (id)v8[4];
    v9;
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  __break(1u);
  return result;
}

uint64_t type metadata accessor for MBDryRestoreManager()
{
  return self;
}

uint64_t initializeBufferWithCopyOfBuffer for _RunState(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  char v4 = *(unsigned char *)(a2 + 8);
  sub_1000590A8(*(id *)a2, v4);
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 8) = v4;
  return a1;
}

id sub_1000590A8(id result, char a2)
{
  if (a2 == 1) {
    return result;
  }
  return result;
}

void destroy for _RunState(uint64_t a1)
{
}

uint64_t assignWithCopy for _RunState(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  char v4 = *(unsigned char *)(a2 + 8);
  sub_1000590A8(*(id *)a2, v4);
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v3;
  char v6 = *(unsigned char *)(a1 + 8);
  *(unsigned char *)(a1 + 8) = v4;
  sub_100034564(v5, v6);
  return a1;
}

uint64_t assignWithTake for _RunState(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a2 + 8);
  char v4 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  char v5 = *(unsigned char *)(a1 + 8);
  *(unsigned char *)(a1 + 8) = v3;
  sub_100034564(v4, v5);
  return a1;
}

ValueMetadata *type metadata accessor for _RunState()
{
  return &type metadata for _RunState;
}

void sub_100059170(uint64_t *a1, id *a2)
{
  uint64_t v5 = type metadata accessor for Date();
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  char v44 = (char *)&v36 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = sub_100006FC8(&qword_10047D708);
  uint64_t v9 = __chkstk_darwin(v8 - 8);
  id v11 = (char *)&v36 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v9);
  uint64_t v13 = (char *)&v36 - v12;
  id v45 = *a2;
  id v14 = [v45 backupUUID];
  if (!v14)
  {
    __break(1u);
    goto LABEL_15;
  }
  uint64_t v15 = v14;
  uint64_t v16 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  uint64_t v18 = v17;

  uint64_t v19 = *a1;
  if (!*(void *)(*a1 + 16))
  {
LABEL_11:
    id v34 = v45;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v46 = *a1;
    *a1 = 0x8000000000000000;
    sub_100032FCC((uint64_t)v34, v16, v18, isUniquelyReferenced_nonNull_native);
    *a1 = v46;
    goto LABEL_12;
  }
  swift_bridgeObjectRetain();
  unint64_t v20 = sub_100031554(v16, v18);
  if ((v21 & 1) == 0)
  {
    swift_bridgeObjectRelease();
    goto LABEL_11;
  }
  uint64_t v41 = v16;
  uint64_t v42 = v2;
  id v43 = *(id *)(*(void *)(v19 + 56) + 8 * v20);
  swift_bridgeObjectRelease();
  id v22 = [v45 date];
  if (!v22)
  {
LABEL_15:
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v6 + 56))(v13, 1, 1, v5);
    goto LABEL_16;
  }
  unint64_t v23 = v22;
  uint64_t v24 = v44;
  static Date._unconditionallyBridgeFromObjectiveC(_:)();

  char v40 = *(void (**)(char *, char *, uint64_t))(v6 + 32);
  v40(v13, v24, v5);
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v6 + 56);
  v25(v13, 0, 1, v5);
  uint64_t v36 = v6;
  uint64_t v39 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v6 + 48);
  if (v39(v13, 1, v5) == 1)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  char v37 = v25;
  uint64_t v38 = v6 + 56;
  id v26 = [v43 date];
  if (!v26)
  {
LABEL_17:
    v37(v11, 1, 1, v5);
    goto LABEL_18;
  }
  int v27 = v26;
  uint64_t v28 = v44;
  static Date._unconditionallyBridgeFromObjectiveC(_:)();

  v40(v11, v28, v5);
  v37(v11, 0, 1, v5);
  if (v39(v11, 1, v5) == 1)
  {
LABEL_18:
    __break(1u);
    return;
  }
  char v29 = static Date.> infix(_:_:)();
  char v30 = *(void (**)(char *, uint64_t))(v36 + 8);
  v30(v11, v5);
  v30(v13, v5);
  uint64_t v31 = v41;
  if (v29)
  {
    id v32 = v45;
    char v33 = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v46 = *a1;
    *a1 = 0x8000000000000000;
    sub_100032FCC((uint64_t)v32, v31, v18, v33);
    *a1 = v46;

LABEL_12:
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return;
  }
  swift_bridgeObjectRelease();
}

void *sub_1000595B0(unint64_t a1, void *a2)
{
  unint64_t v2 = a1;
  if (a1 >> 62) {
    goto LABEL_15;
  }
  uint64_t v3 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  while (1)
  {
    if (!v3) {
      return _swiftEmptyArrayStorage;
    }
    unint64_t result = (void *)sub_100014A0C(0, v3 & ~(v3 >> 63), 0);
    if (v3 < 0) {
      break;
    }
    uint64_t v5 = 0;
    unint64_t v13 = v2 & 0xC000000000000001;
    unint64_t v6 = v2;
    while (v3 != v5)
    {
      if (v13) {
        id v7 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
      }
      else {
        id v7 = *(id *)(v2 + 8 * v5 + 32);
      }
      id v8 = v7;
      unint64_t v9 = _swiftEmptyArrayStorage[2];
      unint64_t v10 = _swiftEmptyArrayStorage[3];
      id v11 = a2;
      if (v9 >= v10 >> 1) {
        sub_100014A0C(v10 > 1, v9 + 1, 1);
      }
      ++v5;
      _swiftEmptyArrayStorage[2] = v9 + 1;
      uint64_t v12 = &_swiftEmptyArrayStorage[2 * v9];
      v12[4] = v11;
      v12[5] = v8;
      unint64_t v2 = v6;
      if (v3 == v5) {
        return _swiftEmptyArrayStorage;
      }
    }
    __break(1u);
LABEL_15:
    swift_bridgeObjectRetain();
    uint64_t v3 = _CocoaArrayWrapper.endIndex.getter();
    swift_bridgeObjectRelease();
  }
  __break(1u);
  return result;
}

void *sub_100059718(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  unint64_t v7 = a1;
  if (a1 >> 62)
  {
LABEL_20:
    swift_bridgeObjectRetain();
    uint64_t v8 = _CocoaArrayWrapper.endIndex.getter();
    if (v8) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t v8 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
    swift_bridgeObjectRetain();
    if (v8)
    {
LABEL_3:
      uint64_t v22 = v4;
      unint64_t v23 = v7;
      unint64_t v24 = v7 & 0xC000000000000001;
      uint64_t v4 = 4;
      do
      {
        uint64_t v9 = v4 - 4;
        if (v24)
        {
          id v10 = (id)specialized _ArrayBuffer._getElementSlowPath(_:)();
          uint64_t v11 = v4 - 3;
          if (__OFADD__(v9, 1)) {
            goto LABEL_19;
          }
        }
        else
        {
          id v10 = *(id *)(v7 + 8 * v4);
          uint64_t v11 = v4 - 3;
          if (__OFADD__(v9, 1))
          {
LABEL_19:
            __break(1u);
            goto LABEL_20;
          }
        }
        uint64_t v12 = v8;
        unint64_t v13 = v10;
        uint64_t v14 = a3;
        id v15 = objc_msgSend(v10, "accountIdentifier", v22);
        uint64_t v16 = static String._unconditionallyBridgeFromObjectiveC(_:)();
        uint64_t v18 = v17;

        a3 = v14;
        BOOL v19 = v16 == a2 && v18 == v14;
        if (v19)
        {
          swift_bridgeObjectRelease();
LABEL_18:
          swift_bridgeObjectRelease();
          return v13;
        }
        char v20 = _stringCompareWithSmolCheck(_:_:expecting:)();
        swift_bridgeObjectRelease();
        if (v20) {
          goto LABEL_18;
        }

        ++v4;
        uint64_t v8 = v12;
        BOOL v19 = v11 == v12;
        unint64_t v7 = v23;
      }
      while (!v19);
    }
  }
  swift_bridgeObjectRelease();
  return 0;
}

uint64_t sub_1000598C0@<X0>(char a1@<W2>, uint64_t a2@<X8>)
{
  if ((a1 & 1) == 0)
  {
    sub_10000EB88();
    sub_10000EF94();
    sub_100018EC4();
  }
  sub_1000101C4();
  sub_10005A400((uint64_t)&v4);
  sub_10004D028((uint64_t)&v4, (uint64_t)&v5, &qword_10047E170);
  return sub_10004D028((uint64_t)&v5, a2, &qword_10047E170);
}

uint64_t sub_10005A3DC(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 56);
  if (v1 >= 0xFFFFFFFF) {
    LODWORD(v1) = -1;
  }
  int v2 = v1 - 1;
  if (v2 < 0) {
    int v2 = -1;
  }
  return (v2 + 1);
}

double sub_10005A400(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 1;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 537) = 0u;
  return result;
}

unint64_t sub_10005A45C()
{
  unint64_t result = (unint64_t)sub_1000557F8(0);
  if (!v0)
  {
    unint64_t v2 = result;
    uint64_t v11 = &_swiftEmptyDictionarySingleton;
    if (result >> 62) {
      goto LABEL_12;
    }
    uint64_t v3 = *(void *)((result & 0xFFFFFFFFFFFFFF8) + 0x10);
    swift_bridgeObjectRetain();
    for (; v3; uint64_t v3 = _CocoaArrayWrapper.endIndex.getter())
    {
      uint64_t v4 = 4;
      while (1)
      {
        id v5 = (v2 & 0xC000000000000001) != 0
           ? (id)specialized _ArrayBuffer._getElementSlowPath(_:)()
           : *(id *)(v2 + 8 * v4);
        unint64_t v6 = v5;
        uint64_t v7 = v4 - 3;
        if (__OFADD__(v4 - 4, 1)) {
          break;
        }
        id v10 = v5;
        sub_100059170((uint64_t *)&v11, &v10);

        ++v4;
        if (v7 == v3)
        {
          swift_bridgeObjectRelease_n();
          uint64_t v8 = v11;
          goto LABEL_14;
        }
      }
      __break(1u);
LABEL_12:
      swift_bridgeObjectRetain();
    }
    swift_bridgeObjectRelease_n();
    uint64_t v8 = &_swiftEmptyDictionarySingleton;
LABEL_14:
    uint64_t v9 = sub_1000197FC((uint64_t)v8);
    swift_bridgeObjectRelease();
    return (unint64_t)v9;
  }
  return result;
}

void *sub_10005A5C0(unint64_t a1)
{
  if (a1 >> 62) {
    goto LABEL_13;
  }
  uint64_t v3 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  swift_bridgeObjectRetain();
  for (; v3; uint64_t v3 = _CocoaArrayWrapper.endIndex.getter())
  {
    uint64_t v4 = 4;
    while (1)
    {
      id v5 = (a1 & 0xC000000000000001) != 0
         ? (id)specialized _ArrayBuffer._getElementSlowPath(_:)()
         : *(id *)(a1 + 8 * v4);
      unint64_t v6 = v5;
      uint64_t v7 = v4 - 3;
      if (__OFADD__(v4 - 4, 1)) {
        break;
      }
      unint64_t v8 = sub_10005A45C();
      if (v1)
      {
        swift_bridgeObjectRelease();

        return (void *)swift_bridgeObjectRelease();
      }
      unint64_t v9 = v8;
      id v10 = v6;
      uint64_t v11 = sub_1000595B0(v9, v10);
      swift_bridgeObjectRelease();

      sub_100011D34((uint64_t)v11);
      ++v4;
      if (v7 == v3) {
        goto LABEL_14;
      }
    }
    __break(1u);
LABEL_13:
    swift_bridgeObjectRetain();
  }
LABEL_14:
  swift_bridgeObjectRelease();
  return _swiftEmptyArrayStorage;
}

ValueMetadata *type metadata accessor for MBDryRestoreInterruptionCause()
{
  return &type metadata for MBDryRestoreInterruptionCause;
}

unint64_t sub_10005A744()
{
  unint64_t result = qword_10047E320;
  if (!qword_10047E320)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_10047E320);
  }
  return result;
}

unint64_t sub_10005A798(unint64_t result)
{
  if (result > 5) {
    return 0;
  }
  return result;
}

char *sub_10005A7AC(char *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    v9[0] = result;
    v9[1] = 0;
    unint64_t result = (char *)fts_open(v9, 84, 0);
    if (result)
    {
      id v5 = (FTS *)result;
      unint64_t v6 = fts_read((FTS *)result);
      if (v6)
      {
        uint64_t v7 = v6;
        do
        {
          int fts_info = v7->fts_info;
          if (fts_info != 6)
          {
            if (fts_info == 1)
            {
              if (a2)
              {
                if (((*(uint64_t (**)(uint64_t, FTSENT *))(a2 + 16))(a2, v7) & 1) == 0) {
                  fts_set(v5, v7, 4);
                }
              }
            }
            else if (a3 && fts_info == 8)
            {
              (*(void (**)(uint64_t, FTSENT *))(a3 + 16))(a3, v7);
            }
          }
          uint64_t v7 = fts_read(v5);
        }
        while (v7);
      }
      return (char *)fts_close(v5);
    }
  }
  return result;
}

uint64_t sub_10005A8BC(const char *a1, int a2, int a3, char a4)
{
  uint64_t v16 = 0;
  long long v15 = xmmword_1003B32C8;
  uint64_t v14 = 0;
  if (getattrlist(a1, &v15, &v14, 8uLL, 0)) {
    return *__error();
  }
  if (HIDWORD(v14) == a3 || a2 != -1 && HIDWORD(v14) != a2) {
    return 0;
  }
  if (a2 == -1)
  {
    if (a4) {
      fprintf(__stdoutp, "%s set %i\n");
    }
  }
  else if (a4)
  {
    fprintf(__stdoutp, "%s update %i -> %i\n");
  }
  int v13 = a3;
  if (!setattrlist(a1, &v15, &v13, 4uLL, 0)) {
    return 0;
  }
  unint64_t v8 = __error();
  uint64_t v9 = *v8;
  id v10 = __stderrp;
  uint64_t v11 = strerror(*v8);
  fprintf(v10, "failed (%s) to update class for %s\n", v11, a1);
  return v9;
}

uint64_t sub_10005A9FC(const char *a1, int a2, int a3, int a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  bzero(v18, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, v18)) {
    return 0xFFFFFFFFLL;
  }
  int v8 = a2 | 0x18;
  if ((a2 & 0x1C) != 0) {
    int v8 = a2;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  id v14[2] = sub_10005AB44;
  v14[3] = &unk_100410EB8;
  int v15 = v8;
  int v16 = a3;
  int v17 = a4;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_10005AB88;
  v10[3] = &unk_100410ED8;
  int v11 = a3;
  int v12 = v8;
  int v13 = a4;
  sub_10005A7AC(v18, (uint64_t)v14, (uint64_t)v10);
  return 0;
}

uint64_t sub_10005AB44(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[8];
  if ((v2 & 4) != 0)
  {
    unint64_t v6 = *(const char **)(a2 + 48);
    int v4 = a1[9];
    int v5 = a1[10];
    uint64_t v3 = v6;
    goto LABEL_5;
  }
  if ((v2 & 8) != 0)
  {
    uint64_t v3 = *(const char **)(a2 + 48);
    int v4 = -1;
    int v5 = 0;
LABEL_5:
    sub_10005A8BC(v3, v4, v5, v2);
  }
  return 1;
}

_DWORD *sub_10005AB88(_DWORD *result, uint64_t a2)
{
  int v3 = result[8];
  if (v3)
  {
    int v4 = result[9];
    if ((v4 & 0x10) != 0)
    {
      if (result[10]) {
        int v5 = result[10];
      }
      else {
        int v5 = 3;
      }
      return (_DWORD *)sub_10005A8BC(*(const char **)(a2 + 48), v3, v5, v4);
    }
  }
  return result;
}

uint64_t MBSynchronizeFileListsWithSnapshotDirectory(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  id v15 = a1;
  id v16 = a2;
  id v17 = a3;
  id v18 = a4;
  id v19 = a5;
  id v20 = a6;
  id v21 = a8;
  if (+[MBFileOperation createDirectories:4294967294 destinationBasePath:@"/" destinationRpath:v15 permissions:493 error:a7])
  {
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    _OWORD v24[2] = sub_10005AD6C;
    v24[3] = &unk_100410F00;
    id v25 = v15;
    id v26 = v16;
    id v27 = v17;
    id v28 = v18;
    id v29 = v19;
    id v30 = v20;
    id v31 = v21;
    uint64_t v22 = MBAcquireSnapshotDirectoryLock(v25, a7, v24);
  }
  else
  {
    uint64_t v22 = 0;
  }

  return v22;
}

BOOL sub_10005AD6C(uint64_t a1, void *a2)
{
  int v3 = *(void **)(a1 + 40);
  int v4 = *(void **)(a1 + 48);
  int v5 = *(void **)(a1 + 56);
  unint64_t v6 = *(void **)(a1 + 64);
  uint64_t v7 = *(void **)(a1 + 72);
  int v8 = *(void **)(a1 + 80);
  id v9 = *(id *)(a1 + 32);
  id v10 = v3;
  id v11 = v4;
  id v12 = v5;
  id v13 = v6;
  id v41 = v7;
  id v38 = v8;
  char v40 = v9;
  if (!v9) {
    __assert_rtn("_synchronizeFileListsWithSnapshotDirectory", "MBSynchronizeFileLists.m", 57, "snapshotDirectory");
  }
  if (!v10) {
    __assert_rtn("_synchronizeFileListsWithSnapshotDirectory", "MBSynchronizeFileLists.m", 58, "commitID");
  }
  if (!v11) {
    __assert_rtn("_synchronizeFileListsWithSnapshotDirectory", "MBSynchronizeFileLists.m", 59, "hmacKey");
  }
  if (!v12) {
    __assert_rtn("_synchronizeFileListsWithSnapshotDirectory", "MBSynchronizeFileLists.m", 60, "references");
  }
  if (!v13) {
    __assert_rtn("_synchronizeFileListsWithSnapshotDirectory", "MBSynchronizeFileLists.m", 61, "tracker");
  }
  uint64_t v82 = 0;
  char v83 = &v82;
  uint64_t v84 = 0x2020000000;
  uint64_t v85 = 0;
  uint64_t v78 = 0;
  uint64_t v79 = &v78;
  uint64_t v80 = 0x2020000000;
  uint64_t v81 = 0;
  uint64_t v74 = 0;
  char v75 = &v74;
  uint64_t v76 = 0x2020000000;
  uint64_t v77 = 0;
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v39 = v10;
  id v15 = objc_opt_new();
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  id v16 = v12;
  id v17 = [v16 countByEnumeratingWithState:&v70 objects:v94 count:16];
  char v37 = v13;
  if (v17)
  {
    uint64_t v18 = *(void *)v71;
    while (2)
    {
      for (uint64_t i = 0; i != v17; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v71 != v18) {
          objc_enumerationMutation(v16);
        }
        if (([v15 addDomainReference:*(void *)(*((void *)&v70 + 1) + 8 * i) error:a2] & 1) == 0)
        {
          BOOL v29 = 0;
          id v30 = v16;
          goto LABEL_25;
        }
      }
      id v17 = [v16 countByEnumeratingWithState:&v70 objects:v94 count:16];
      if (v17) {
        continue;
      }
      break;
    }
  }

  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3221225472;
  v63[2] = sub_10005B4A8;
  v63[3] = &unk_100410F28;
  id v20 = v15;
  id v64 = v20;
  id v65 = v11;
  id v21 = v41;
  id v66 = v21;
  id v22 = v40;
  id v67 = v22;
  id v23 = v10;
  id v68 = v23;
  uint64_t v69 = &v74;
  if (MBEnumerateDomainNamesForSnapshot(v22, v23, a2, v63))
  {
    v59[0] = _NSConcreteStackBlock;
    v59[1] = 3221225472;
    v59[2] = sub_10005B64C;
    v59[3] = &unk_100410F50;
    id v24 = v21;
    id v60 = v24;
    id v25 = v38;
    id v61 = v25;
    unsigned __int8 v62 = &v82;
    [v20 enumerateConsolidatedDomainNamesAndReference:v59];
    uint64_t v53 = 0;
    char v54 = &v53;
    uint64_t v55 = 0x3032000000;
    char v56 = sub_10005B7A8;
    char v57 = sub_10005B7B8;
    id v58 = (id)objc_opt_new();
    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472;
    v45[2] = sub_10005B7C0;
    v45[3] = &unk_100410FA0;
    id v26 = [[MBCKBatchFetch alloc] initWithOperationTracker:v37];
    uint64_t v46 = v26;
    id v47 = v22;
    id v48 = v23;
    long long v51 = &v53;
    id v49 = v24;
    id v50 = v25;
    char v52 = &v78;
    [v20 enumerateReferencesWithUnknownDomainName:v45];
    v42[0] = _NSConcreteStackBlock;
    v42[1] = 3221225472;
    v42[2] = sub_10005BB00;
    v42[3] = &unk_100410FC8;
    char v44 = &v53;
    id v27 = dispatch_semaphore_create(0);
    id v43 = v27;
    [(MBCKBatchFetch *)v26 fetchRecordsWithCompletion:v42];
    dispatch_semaphore_wait(v27, 0xFFFFFFFFFFFFFFFFLL);
    id v28 = [(id)v54[5] count];
    BOOL v29 = v28 == 0;
    if (v28)
    {
      if (a2)
      {
        *a2 = +[MBError errorWithErrors:v54[5]];
      }
    }
    else
    {
      double v31 = CFAbsoluteTimeGetCurrent();
      id v32 = MBGetDefaultLog();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = v83[3];
        uint64_t v34 = v79[3];
        uint64_t v35 = v75[3];
        *(_DWORD *)buf = 134218752;
        double v87 = v31 - Current;
        __int16 v88 = 2048;
        uint64_t v89 = v33;
        __int16 v90 = 2048;
        uint64_t v91 = v34;
        __int16 v92 = 2048;
        uint64_t v93 = v35;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "=domain record op= Finished file list synchronization in %.2fs - consolidated:%llu fetched:%llu deleted:%llu", buf, 0x2Au);
        _MBLog();
      }
    }
    _Block_object_dispose(&v53, 8);
  }
  else
  {
    BOOL v29 = 0;
  }

  id v30 = v64;
LABEL_25:

  _Block_object_dispose(&v74, 8);
  _Block_object_dispose(&v78, 8);
  _Block_object_dispose(&v82, 8);

  return v29;
}

void sub_10005B434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10005B4A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (([*(id *)(a1 + 32) consolidateDomainName:v3 hmacKey:*(void *)(a1 + 40)] & 1) == 0)
  {
    int v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v13 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "=domain record op= Deleting file list for %@ that isn't present in snapshot", buf, 0xCu);
      _MBLog();
    }

    [*(id *)(a1 + 48) trackDeletedDomainDuringFileListSynchronization:v3];
    int v5 = *(void **)(a1 + 56);
    uint64_t v6 = *(void *)(a1 + 64);
    id v11 = 0;
    unsigned __int8 v7 = MBDeleteFileListDB(v5, v6, v3, (uint64_t)&v11);
    id v8 = v11;
    if ((v7 & 1) == 0)
    {
      id v9 = MBGetDefaultLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        id v13 = v3;
        __int16 v14 = 2112;
        id v15 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "=domain record op= Failed to delete file list database for domain %@: %@", buf, 0x16u);
        _MBLog();
      }
    }
    ++*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
  }
  return 1;
}

uint64_t sub_10005B64C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned __int8 v7 = MBGetDefaultLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = [v6 baseRecordID];
    *(_DWORD *)buf = 138412546;
    id v12 = v8;
    __int16 v13 = 2112;
    id v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "=domain record op= Consolidated baseRecordID %@ with domain on disk %@", buf, 0x16u);

    id v10 = [v6 baseRecordID];
    _MBLog();
  }
  [*(id *)(a1 + 32) trackConsolidatedDomainDuringFileListSynchronization:v5];
  (*(void (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v5);
  ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);

  return 1;
}

uint64_t sub_10005B7A8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10005B7B8(uint64_t a1)
{
}

uint64_t sub_10005B7C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = *(void **)(a1 + 32);
  int v4 = *(void **)(a1 + 40);
  id v6 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  void v22[2] = sub_10005BA6C;
  _OWORD v22[3] = &unk_100410F78;
  unsigned __int8 v7 = *(void **)(a1 + 48);
  id v23 = *(id *)(a1 + 56);
  id v24 = *(id *)(a1 + 64);
  id v8 = v3;
  id v9 = v4;
  id v10 = v7;
  id v11 = v6;
  id v12 = v22;
  id v13 = v5;
  id v14 = [v8 baseRecordID];
  id v15 = +[MBDomainRecord recordIDFromBaseRecordID:v14 pageIndex:0];

  id v16 = MBGetDefaultLog();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412546;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "=domain record op= Fetching domain record ID %@ from reference %@", buf, 0x16u);
    _MBLog();
  }

  *(void *)buf = _NSConcreteStackBlock;
  *(void *)&buf[8] = 3221225472;
  *(void *)&buf[16] = sub_10005BBF0;
  id v26 = &unk_100410FF0;
  id v27 = v9;
  id v28 = v10;
  id v30 = v8;
  id v31 = v12;
  id v29 = v11;
  id v17 = v9;
  id v18 = v10;
  id v19 = v11;
  id v20 = v8;
  [v13 fetchRecordWithID:v15 completion:buf];

  ++*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
  return 1;
}

void sub_10005BA6C(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  [v5 trackDownloadedDomainDuringFileListSynchronization:v7];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005BB00(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    int v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "=domain record op= Failed to fetch domain records: %@", buf, 0xCu);
      _MBLog();
    }

    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObject:v3];
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10005BBF0(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  if (v8)
  {
    id v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      id v22 = v7;
      __int16 v23 = 2112;
      id v24 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "=domain record op= Failed to fetch recordID %@: %@", buf, 0x16u);
      _MBLog();
    }
  }
  else
  {
    id v10 = +[MBDomainRecord domainRecordFromCKRecord:a3];
    id v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = [v10 domainName];
      *(_DWORD *)buf = 138412546;
      id v22 = v7;
      __int16 v23 = 2112;
      id v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "=domain record op= Fetched domain record %@ for domain %@", buf, 0x16u);

      id v19 = [v10 domainName];
      _MBLog();
    }
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 40);
    id v20 = 0;
    unsigned __int8 v15 = [v10 decompressAssetIntoSnapshotDirectoryRoot:v13 commitID:v14 error:&v20];
    id v9 = v20;
    if (v15)
    {
      uint64_t v16 = *(void *)(a1 + 64);
      id v17 = [v10 domainName];
      (*(void (**)(uint64_t, void *, void, uint64_t))(v16 + 16))(v16, v17, *(void *)(a1 + 56), 1);
    }
    else
    {
      id v18 = MBGetDefaultLog();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        id v22 = v7;
        __int16 v23 = 2112;
        id v24 = v9;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "=domain record op= Failed to decompress domain record %@: %@", buf, 0x16u);
        _MBLog();
      }

      [*(id *)(a1 + 48) addObject:v9];
    }
  }
}

void sub_10005CB24(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v5 = v3;
    id v6 = [v5 applicationType];
    unsigned __int8 v7 = [v6 isEqualToString:LSSystemApplicationType];

    if (v7) {
      goto LABEL_31;
    }
    id v8 = (char *)[v5 installType];
    if ((unint64_t)(v8 - 7) > 1) {
      goto LABEL_31;
    }
    id v9 = v8;
    id v10 = [v5 bundleIdentifier];
    id v11 = [v5 managedPersonas];
    if ([v11 count])
    {
      id v12 = MBGetDefaultLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        id v22 = v10;
        __int16 v23 = 2114;
        id v24 = v11;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Found app %@ with managed personae: %{public}@", buf, 0x16u);
        id v19 = v10;
        id v20 = v11;
        _MBLog();
      }
    }
    if (!*(unsigned char *)(a1 + 64))
    {
      if ([v11 containsObject:*(void *)(a1 + 32)]) {
        goto LABEL_16;
      }
      uint64_t v13 = MBGetDefaultLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        id v18 = *(NSObject **)(a1 + 32);
        *(_DWORD *)buf = 138412802;
        id v22 = v10;
        __int16 v23 = 2048;
        id v24 = v9;
        __int16 v25 = 2114;
        id v26 = v18;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Skipping demoted bundle: %@/%lu for managed persona %{public}@", buf, 0x20u);
        _MBLog();
      }
LABEL_27:

      goto LABEL_30;
    }
    uint64_t v13 = [v5 purchaserDSID];
    if (![v11 count]
      || *(void *)(a1 + 32) && (objc_msgSend(v11, "containsObject:") & 1) != 0)
    {
      if (objc_msgSend(v11, "count", v19, v20)
        || ([*(id *)(a1 + 40) addAccountWithDSID:v13] & 1) != 0)
      {

LABEL_16:
        uint64_t v14 = MBGetDefaultLog();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          id v22 = v10;
          __int16 v23 = 2048;
          id v24 = v9;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Found demoted bundle: %@/%lu", buf, 0x16u);
          id v19 = v10;
          id v20 = v9;
          _MBLog();
        }

        if (v9 == (char *)8)
        {
          unsigned __int8 v15 = *(void **)(a1 + 56);
          goto LABEL_29;
        }
        if (v9 == (char *)7)
        {
          unsigned __int8 v15 = *(void **)(a1 + 48);
LABEL_29:
          objc_msgSend(v15, "addObject:", v10, v19, v20);
        }
LABEL_30:

LABEL_31:
        goto LABEL_32;
      }
      uint64_t v16 = MBGetDefaultLog();
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 138412802;
      id v22 = v10;
      __int16 v23 = 2048;
      id v24 = v9;
      __int16 v25 = 2112;
      id v26 = v13;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Skipping demoted bundle:%@/%lu for DSID %@", buf, 0x20u);
    }
    else
    {
      uint64_t v16 = MBGetDefaultLog();
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
LABEL_24:

        goto LABEL_27;
      }
      id v17 = *(NSObject **)(a1 + 32);
      *(_DWORD *)buf = 138412802;
      id v22 = v10;
      __int16 v23 = 2048;
      id v24 = v9;
      __int16 v25 = 2114;
      id v26 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Skipping demoted bundle:%@/%lu for personal persona %{public}@", buf, 0x20u);
    }
    _MBLog();
    goto LABEL_24;
  }
LABEL_32:
}

uint64_t sub_10005D404()
{
  objc_opt_class();
  qword_100482328 = objc_opt_new();
  return _objc_release_x1();
}

id sub_10005D570(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _finishXPCWithError:a2];
}

void sub_10005FB5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_10005FB8C(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = objc_opt_new();
  id v6 = [v3 accountIdentifier];
  unsigned __int8 v7 = [v4 stringByAppendingFormat:@".%@", v6];
  [v5 setUniqueIdentifier:v7];

  [v5 setTypeIdentifier:v4];
  if ([v3 isPrimaryAccount])
  {
    id v8 = [v3 accountIdentifier];
  }
  else
  {
    id v9 = +[ACAccountStore defaultStore];
    id v10 = [v3 accountIdentifier];
    id v11 = [v9 accountWithIdentifier:v10];
    id v8 = [v11 objectForKeyedSubscript:ACAccountPropertyRemoteManagingAccountIdentifier];
  }
  [v5 setAccountIdentifier:v8];
  [v5 setExtensionIdentifier:@"com.apple.MobileBackup.framework.FollowUpUIExtension"];

  return v5;
}

uint64_t sub_10005FCEC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10005FCFC(uint64_t a1)
{
}

void sub_10005FD04(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;

  if (v6)
  {
    id v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      id v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to get localized string from byte count: %{public}@", buf, 0xCu);
      _MBLog();
    }
  }
}

id sub_10005FDF8(uint64_t a1)
{
  [*(id *)(a1 + 32) _postFollowUpItem:*(void *)(a1 + 40)];
  int v2 = *(void **)(a1 + 32);
  return _[v2 _refreshBackgroundRestoreFollowUps];
}

void sub_1000600C4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1000600E4(uint64_t a1, int a2)
{
  if (a2)
  {
    id v3 = MBGetDefaultLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Not posting restore finished follow up because of ICQ offer", v9, 2u);
      _MBLog();
    }

    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 40) _restoreFinishedFollowUpItemForAccount:*(void *)(a1 + 48)];
    uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    id v8 = *(NSObject **)(a1 + 32);
    return dispatch_semaphore_signal(v8);
  }
}

id sub_1000601B4(uint64_t a1)
{
  [*(id *)(a1 + 32) _postFollowUpItem:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
  int v2 = *(void **)(a1 + 32);
  return _[v2 _refreshBackgroundRestoreFollowUps];
}

id sub_100060D1C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _refreshBackgroundRestoreFollowUps];
}

void sub_1000615F8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10006160C(id a1)
{
  qword_100482338 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___MBHelperServiceProtocol];
  _objc_release_x1();
}

void sub_100061654(uint64_t a1)
{
  id obj = *(id *)(a1 + 32);
  objc_sync_enter(obj);
  uint64_t v1 = (void *)qword_100482330;
  qword_100482330 = 0;

  objc_sync_exit(obj);
}

int main(int argc, const char **argv, const char **envp)
{
  MBSetIsRunningInDaemon();
  MBLogEnableFileLogging();
  id v3 = (void *)os_transaction_create();
  atexit_b(&stru_100411188);
  uint64_t v5 = +[MBXPCServer sharedInstance];
  uint64_t v6 = +[MBDaemon sharedDaemon];
  [v6 setupSignalHandlers];
  uint64_t v7 = +[MBCKManager sharedInstance];
  [v7 setUpXPCEventHandler];
  id v8 = +[MBBackupScheduler sharedInstance];
  id v9 = +[MBActivityScheduler sharedInstance];
  id v10 = self;

  if (!v6) {
    __assert_rtn("main", "backupd_main.m", 50, "daemon");
  }
  [v6 run];

  return 0;
}

void sub_1000620AC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      uint64_t v13 = MBGetDefaultLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543618;
        id v16 = (id)objc_opt_class();
        __int16 v17 = 2112;
        id v18 = v9;
        id v14 = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to fetch %{public}@ record: %@", buf, 0x16u);

        objc_opt_class();
        _MBLog();
      }
    }
  }
  else
  {
    [*(id *)(a1 + 32) refreshWithRecord:v8];
  }
  (*(void (**)(void, id, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v9, v10, v11, v12);
}

void sub_10006234C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100062364(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100062374(uint64_t a1)
{
}

void sub_10006237C(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000628B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
}

void sub_1000628EC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v12 = a2;
  id v7 = a3;
  id v8 = a4;
  if (v8)
  {
    id v9 = *(id *)(a1 + 32);
    objc_sync_enter(v9);
    if (+[MBError isCKNotFoundError:v8])
    {
      if (!v12) {
        __assert_rtn("+[MBCKModel fetchFromServerWithOperationTracker:childrenOfClass:refs:cache:completion:]_block_invoke", "MBCKModel.m", 142, "recordID");
      }
      objc_msgSend(*(id *)(a1 + 32), "addObject:");
    }
    else
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a4);
    }
    objc_sync_exit(v9);
  }
  else
  {
    if (!v7) {
      __assert_rtn("+[MBCKModel fetchFromServerWithOperationTracker:childrenOfClass:refs:cache:completion:]_block_invoke", "MBCKModel.m", 150, "record");
    }
    id v10 = [objc_alloc(*(Class *)(a1 + 64)) initWithRecord:v7 cache:*(void *)(a1 + 40)];
    id v11 = *(id *)(a1 + 48);
    objc_sync_enter(v11);
    [*(id *)(a1 + 48) addObject:v10];
    objc_sync_exit(v11);

    id v9 = v10;
  }
}

void sub_100062A4C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100062A64(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3) {
    id v3 = *(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
  }
  id v6 = v3;
  id v4 = (char *)[*(id *)(a1 + 32) count];
  uint64_t v5 = &v4[(void)[*(id *)(a1 + 40) count]];
  if (v5 > [*(id *)(a1 + 48) count]) {
    __assert_rtn("+[MBCKModel fetchFromServerWithOperationTracker:childrenOfClass:refs:cache:completion:]_block_invoke_2", "MBCKModel.m", 159, "children.count + missing.count <= refs.count");
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

id sub_100062E58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) handleSaveComplete:a2 withError:a3 completion:*(void *)(a1 + 40)];
}

void sub_100062F58(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      uint64_t v7 = v5;
      __int16 v8 = 2112;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error preparing record %@ for save to server: %@", buf, 0x16u);
      _MBLog();
    }

    (*(void (**)(void, id))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v3);
  }
  else
  {
    [*(id *)(a1 + 32) addSavesWithOperationTracker:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
  }
}

void sub_10006319C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000631B4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id sub_100063430(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) handleSaveComplete:a2 withError:a3 completion:*(void *)(a1 + 40)];
}

void sub_100063568(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      uint64_t v7 = v5;
      __int16 v8 = 2112;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error preparing record %@ for save to server: %@", buf, 0x16u);
      _MBLog();
    }

    (*(void (**)(void, id))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v3);
  }
  else
  {
    [*(id *)(a1 + 32) addSavesWithBatchSave:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
  }
}

void sub_1000638F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100063990(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100063F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100063FA4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100064750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100064768(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100064778(uint64_t a1)
{
}

void sub_100064780(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100064A54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100064A88(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v9 = a3;
  id v6 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  __int16 v8 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained _handleAssetFetchResponseFor:*(void *)(a1 + 32) decrypter:*(void *)(a1 + 40) record:v9 withFetchError:v6];
  }
}

void sub_100064B80(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100065774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose((const void *)(v13 - 160), 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000657B4(void *a1, void *a2)
{
  uint64_t v3 = a1[4];
  id v4 = *(void **)(a1[5] + 16);
  id v5 = a2;
  id v6 = [v4 metadata];
  uint64_t v7 = [v6 encryptionKey];
  id v8 = [*(id *)(a1[5] + 16) originalFileSize];
  id v9 = [*(id *)(a1[5] + 8) device];
  id v10 = [v9 hardwareModel];
  uint64_t v11 = *(void *)(a1[7] + 8);
  id obj = *(id *)(v11 + 40);
  LOBYTE(v3) = [v5 decryptFileWithPath:v3 encryptionKey:v7 size:v8 hardwareModel:v10 error:&obj];

  objc_storeStrong((id *)(v11 + 40), obj);
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = v3;
}

int64_t sub_100066324(id a1, MBCKSnapshot *a2, MBCKSnapshot *a3)
{
  id v4 = a3;
  id v5 = [(MBCKSnapshot *)a2 created];
  id v6 = [(MBCKSnapshot *)v4 created];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

void sub_100066BCC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100067718(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v5 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      id v21 = v5;
      __int16 v22 = 2112;
      id v23 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error fetching manifest records from server for domain %@: %@", buf, 0x16u);
      _MBLog();
    }

    id v6 = *(id *)(a1 + 40);
    objc_sync_enter(v6);
    [*(id *)(a1 + 40) addObject:v3];
    objc_sync_exit(v6);
  }
  else
  {
    id v7 = [*(id *)(a1 + 48) domainName];

    if (v7)
    {
      id v8 = *(id *)(*(void *)(a1 + 56) + 72);
      objc_sync_enter(v8);
      id v9 = *(void **)(a1 + 48);
      id v10 = *(void **)(*(void *)(a1 + 56) + 72);
      uint64_t v11 = [v9 domainName];
      [v10 setObject:v9 forKeyedSubscript:v11];

      objc_sync_exit(v8);
      uint64_t v12 = *(void *)(a1 + 64);
      if (v12) {
        (*(void (**)(uint64_t, void))(v12 + 16))(v12, *(void *)(a1 + 48));
      }
    }
    else
    {
      uint64_t v13 = MBGetDefaultLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        id v14 = [*(id *)(a1 + 48) recordID];
        *(_DWORD *)buf = 138543362;
        id v21 = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Manifest %{public}@ had no domain name", buf, 0xCu);

        id v19 = [*(id *)(a1 + 48) recordID];
        _MBLog();
      }
      id v15 = *(id *)(a1 + 40);
      objc_sync_enter(v15);
      id v16 = *(void **)(a1 + 40);
      __int16 v17 = [*(id *)(a1 + 48) recordID];
      id v18 = +[MBError errorWithCode:4, @"Manifest %@ had no domain name", v17 format];
      [v16 addObject:v18];

      objc_sync_exit(v15);
    }
  }
}

void sub_1000679B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000679DC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 32) count])
  {
    id v4 = +[MBError errorWithErrors:*(void *)(a1 + 32)];
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    if (!v3)
    {
LABEL_9:
      id v7 = MBGetDefaultLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        id v8 = [*(id *)(a1 + 40) snapshotID];
        *(_DWORD *)buf = 138412290;
        uint64_t v12 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Done fetching all manifests from the server for snapshot %@", buf, 0xCu);

        id v10 = [*(id *)(a1 + 40) snapshotID];
        _MBLog();
      }
      id v4 = 0;
      *(unsigned char *)(*(void *)(a1 + 40) + 106) = 1;
      goto LABEL_12;
    }
    id v4 = v3;
  }
  id v5 = MBGetDefaultLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    id v6 = [*(id *)(a1 + 40) snapshotID];
    *(_DWORD *)buf = 138412546;
    uint64_t v12 = v6;
    __int16 v13 = 2112;
    id v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to fetch the manifest records from the server for snapshot %@: %@", buf, 0x16u);

    id v9 = [*(id *)(a1 + 40) snapshotID];
    _MBLog();
  }
LABEL_12:
  (*(void (**)(void, id))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
}

void sub_100067D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100067D3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100067D4C(uint64_t a1)
{
}

void sub_100067D54(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100068BAC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100068BE8(uint64_t a1)
{
}

void sub_100068BF0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to delete old manifests: %@", buf, 0xCu);
      _MBLog();
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100068CCC(uint64_t a1)
{
  int v2 = [*(id *)(a1 + 32) cache];
  id v3 = [v2 deleteCloudFilesPendingDeleteForManifestID:*(void *)(a1 + 40)];

  id v4 = *(NSObject **)(a1 + 48);
  dispatch_group_leave(v4);
}

void sub_100068D24(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to reclaim quota for replaced files: %@", buf, 0xCu);
      _MBLog();
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100068E00(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v3 = *(id *)(a1 + 32);
    objc_sync_enter(v3);
    [*(id *)(a1 + 32) addObject:v4];
    objc_sync_exit(v3);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_100068E78(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100068E8C(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100068EEC(uint64_t a1)
{
  if ([*(id *)(a1 + 32) count])
  {
    id v3 = +[MBError errorWithErrors:*(void *)(a1 + 32)];
    if (!v3) {
      goto LABEL_9;
    }
LABEL_6:
    id v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v6 = *(void **)(a1 + 40);
      *(_DWORD *)buf = 138543618;
      uint64_t v33 = v6;
      __int16 v34 = 2112;
      id v35 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to prepare the manifests for snapshot %{public}@: %@", buf, 0x16u);
      _MBLog();
    }

    (*(void (**)(void, id))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), v3);
    goto LABEL_30;
  }
  id v4 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
  if (v4)
  {
    id v3 = v4;
    goto LABEL_6;
  }
LABEL_9:
  id v7 = MBGetDefaultLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = *(void **)(a1 + 40);
    *(_DWORD *)buf = 138543362;
    uint64_t v33 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Successfully prepared all manifests for snapshot %{public}@", buf, 0xCu);
    uint64_t v25 = *(void *)(a1 + 40);
    _MBLog();
  }

  id v9 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(*(id *)(*(void *)(a1 + 48) + 72), "count"));
  id v10 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(*(id *)(*(void *)(a1 + 48) + 72), "count"));
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  uint64_t v11 = [*(id *)(*(void *)(a1 + 48) + 72) allValues];
  id v12 = [v11 countByEnumeratingWithState:&v27 objects:v31 count:16];
  if (!v12)
  {
    id v3 = 0;
    goto LABEL_29;
  }
  id v13 = v12;
  uint64_t v14 = *(void *)v28;
  while (2)
  {
    for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v28 != v14) {
        objc_enumerationMutation(v11);
      }
      id v16 = *(void **)(*((void *)&v27 + 1) + 8 * i);
      if ((objc_msgSend(v16, "isPersistedToServer", v25) & 1) == 0)
      {
        id v19 = MBGetDefaultLog();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v33 = v16;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Attempted to commit a snapshot with unsaved manifest: %@", buf, 0xCu);
          _MBLog();
        }
        CFStringRef v20 = @"Attempted to commit a snapshot with unsaved manifest";
        goto LABEL_28;
      }
      __int16 v17 = [v16 domainName];

      if (!v17)
      {
        id v19 = MBGetDefaultLog();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          id v21 = [v16 recordRepresentation];
          *(_DWORD *)buf = 138412546;
          uint64_t v33 = v16;
          __int16 v34 = 2112;
          id v35 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Manifest has no domain name: %@, %@", buf, 0x16u);

          id v26 = [v16 recordRepresentation];
          _MBLog();
        }
        CFStringRef v20 = @"Attempted to add a manifest without a domain name to a snapshot";
LABEL_28:

        id v3 = +[MBError errorWithCode:306 format:v20];
        goto LABEL_29;
      }
      [v9 addObject:v16];
      id v18 = [v16 baseRecordIDString];
      [v10 addObject:v18];
    }
    id v13 = [v11 countByEnumeratingWithState:&v27 objects:v31 count:16];
    id v3 = 0;
    if (v13) {
      continue;
    }
    break;
  }
LABEL_29:

  uint64_t v22 = *(void *)(a1 + 48);
  id v23 = *(void **)(v22 + 136);
  *(void *)(v22 + 136) = v10;
  id v24 = v10;

  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
LABEL_30:
}

uint64_t sub_10006B638(id *a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = a2;
  id v10 = a3;
  uint64_t v11 = MBGetDefaultLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138544130;
    id v16 = v9;
    __int16 v17 = 2112;
    id v18 = v10;
    __int16 v19 = 2048;
    uint64_t v20 = a4;
    __int16 v21 = 2048;
    uint64_t v22 = a5;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "=commit= Marking domain %{public}@ (baseRecordID:%@ pageCount:%llu) checksum [0x%llx] as modified", buf, 0x2Au);
    _MBLog();
  }

  id v12 = [[MBCKSnapshotToDomainRecordReference alloc] initWithBaseRecordID:v10 pageCount:a4 checksum:a5];
  [a1[4] addObject:v12];
  [a1[5] trackModifiedDomainInCommit:v9];
  if ([a1[6] count])
  {
    id v13 = +[MBDomainRecord domainHmacFromBaseRecordID:v10];
    if ([a1[6] containsObject:v13])
    {
      [a1[5] trackRepairedDomain:v9];
      [a1[5] trackDeletedDomainInCommit:v9];
      [a1[7] removeObject:v13];
    }
  }
  return 1;
}

uint64_t sub_10006B7E8(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[MBDomainRecord domainHmacFromBaseRecordID:v6];
  id v8 = MBGetDefaultLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543874;
    id v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    __int16 v15 = 2112;
    id v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "=commit= Marking domain %{public}@ with hmac %@ and baseRecordID %@ to be removed", buf, 0x20u);
    _MBLog();
  }

  [a1[4] addObject:v7];
  [a1[5] trackDeletedDomainInCommit:v5];
  if ([a1[6] count])
  {
    id v9 = +[MBDomainRecord domainHmacFromBaseRecordID:v6];
    if ([a1[6] containsObject:v9])
    {
      [a1[5] trackRepairedDomain:v5];
      [a1[7] removeObject:v9];
    }
  }
  return 1;
}

id MBGetLatestDomainRecordReferencesFromSnapshots(void *a1)
{
  id v1 = a1;
  int v2 = objc_opt_new();
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  id obj = v1;
  id v34 = [obj countByEnumeratingWithState:&v44 objects:v54 count:16];
  if (v34)
  {
    uint64_t v33 = *(void *)v45;
    do
    {
      uint64_t v3 = 0;
      do
      {
        if (*(void *)v45 != v33) {
          objc_enumerationMutation(obj);
        }
        id v4 = *(void **)(*((void *)&v44 + 1) + 8 * v3);
        id v5 = MBGetDefaultLog();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          id v6 = [v4 snapshotID];
          *(_DWORD *)buf = 138412290;
          id v50 = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "=replay= Starting to replay snapshot: %@", buf, 0xCu);

          long long v30 = [v4 snapshotID];
          _MBLog();
        }
        [v4 type];
        uint64_t v35 = v3;
        if (MBSnapshotTypeIsFull())
        {
          id v7 = MBGetDefaultLog();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            id v8 = [v4 snapshotID];
            *(_DWORD *)buf = 138412290;
            id v50 = v8;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "=replay= Detected full backup for %@, invalidating latest refs", buf, 0xCu);

            long long v30 = [v4 snapshotID];
            _MBLog();
          }
          uint64_t v9 = objc_opt_new();

          int v2 = (void *)v9;
        }
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        id v10 = objc_msgSend(v4, "domainHmacsToRemove", v30, v31);
        id v11 = [v10 countByEnumeratingWithState:&v40 objects:v53 count:16];
        if (v11)
        {
          id v12 = v11;
          uint64_t v13 = *(void *)v41;
          do
          {
            for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v41 != v13) {
                objc_enumerationMutation(v10);
              }
              __int16 v15 = *(void **)(*((void *)&v40 + 1) + 8 * i);
              id v16 = MBGetDefaultLog();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
              {
                __int16 v17 = [v4 snapshotID];
                *(_DWORD *)buf = 138412546;
                id v50 = v17;
                __int16 v51 = 2112;
                char v52 = v15;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "=replay= Snapshot %@ contains reference to deleted domain hmac %@", buf, 0x16u);

                long long v30 = [v4 snapshotID];
                id v31 = v15;
                _MBLog();
              }
              [v2 setObject:0 forKeyedSubscript:v15];
            }
            id v12 = [v10 countByEnumeratingWithState:&v40 objects:v53 count:16];
          }
          while (v12);
        }

        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        id v18 = [v4 modifiedDomainRecordReferences];
        id v19 = [v18 countByEnumeratingWithState:&v36 objects:v48 count:16];
        if (v19)
        {
          id v20 = v19;
          uint64_t v21 = *(void *)v37;
          do
          {
            for (j = 0; j != v20; j = (char *)j + 1)
            {
              if (*(void *)v37 != v21) {
                objc_enumerationMutation(v18);
              }
              id v23 = *(void **)(*((void *)&v36 + 1) + 8 * (void)j);
              id v24 = objc_msgSend(v23, "baseRecordID", v30);
              uint64_t v25 = +[MBDomainRecord domainHmacFromBaseRecordID:v24];
              [v2 setObject:v23 forKeyedSubscript:v25];
              id v26 = MBGetDefaultLog();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
              {
                long long v27 = [v4 snapshotID];
                *(_DWORD *)buf = 138412546;
                id v50 = v27;
                __int16 v51 = 2112;
                char v52 = v24;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "=replay= Snapshot %@ contains reference to modified domain baseRecordID: %@", buf, 0x16u);

                long long v30 = [v4 snapshotID];
                id v31 = v24;
                _MBLog();
              }
            }
            id v20 = [v18 countByEnumeratingWithState:&v36 objects:v48 count:16];
          }
          while (v20);
        }

        uint64_t v3 = v35 + 1;
      }
      while ((id)(v35 + 1) != v34);
      id v34 = [obj countByEnumeratingWithState:&v44 objects:v54 count:16];
    }
    while (v34);
  }

  long long v28 = [v2 allValues];

  return v28;
}

id MBGetAllDomainHMACsInSnapshots(void *a1)
{
  id v1 = a1;
  int v2 = objc_opt_new();
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id obj = v1;
  id v3 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v17 = *(void *)v23;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v23 != v17) {
          objc_enumerationMutation(obj);
        }
        id v6 = *(void **)(*((void *)&v22 + 1) + 8 * i);
        [v6 type];
        if (MBSnapshotTypeIsFull())
        {
          uint64_t v7 = objc_opt_new();

          int v2 = (void *)v7;
        }
        long long v20 = 0u;
        long long v21 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        id v8 = [v6 modifiedDomainRecordReferences];
        id v9 = [v8 countByEnumeratingWithState:&v18 objects:v26 count:16];
        if (v9)
        {
          id v10 = v9;
          uint64_t v11 = *(void *)v19;
          do
          {
            for (j = 0; j != v10; j = (char *)j + 1)
            {
              if (*(void *)v19 != v11) {
                objc_enumerationMutation(v8);
              }
              uint64_t v13 = [*(id *)(*((void *)&v18 + 1) + 8 * (void)j) baseRecordID];
              uint64_t v14 = +[MBDomainRecord domainHmacFromBaseRecordID:v13];
              [v2 addObject:v14];
            }
            id v10 = [v8 countByEnumeratingWithState:&v18 objects:v26 count:16];
          }
          while (v10);
        }
      }
      id v4 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
    }
    while (v4);
  }

  return v2;
}

id MBGetAllDomainQuotasByDomainHMAC(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = [v3 indexOfObjectPassingTest:&stru_100411438];
  if (v4 == (unsigned char *)0x7FFFFFFFFFFFFFFFLL)
  {
    if (a2)
    {
      +[MBError errorWithCode:204 format:@"No domains assets snapshot found"];
      id v5 = 0;
      *a2 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v5 = 0;
    }
  }
  else
  {
    id v30 = v3;
    id v6 = objc_msgSend(v3, "subarrayWithRange:", v4, (unsigned char *)objc_msgSend(v3, "count") - v4);
    id v7 = (id)objc_opt_new();
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    id obj = v6;
    id v8 = [obj countByEnumeratingWithState:&v37 objects:v44 count:16];
    if (v8)
    {
      id v9 = v8;
      long long v29 = a2;
      uint64_t v32 = *(void *)v38;
      while (2)
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v38 != v32) {
            objc_enumerationMutation(obj);
          }
          uint64_t v11 = *(void **)(*((void *)&v37 + 1) + 8 * i);
          [v11 type];
          if (MBSnapshotTypeIsFull())
          {
            uint64_t v12 = objc_opt_new();

            id v7 = (id)v12;
          }
          uint64_t v13 = [v11 domainRecordQuotas];
          if (!v13)
          {
            long long v24 = MBGetDefaultLog();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              long long v25 = [v11 recordID];
              *(_DWORD *)buf = 138412290;
              long long v43 = v25;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Domain quotas missing from snapshot record %@", buf, 0xCu);

              long long v28 = [v11 recordID];
              _MBLog();
            }
            id v3 = v30;
            if (v29)
            {
              id v26 = [v11 recordID];
              void *v29 = +[MBError errorWithCode:4, @"Domain quotas missing from snapshot record %@", v26 format];
            }
            long long v23 = obj;

            id v5 = 0;
            goto LABEL_30;
          }
          uint64_t v14 = v13;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          id v15 = [v13 countByEnumeratingWithState:&v33 objects:v41 count:16];
          if (v15)
          {
            id v16 = v15;
            uint64_t v17 = *(void *)v34;
            do
            {
              for (j = 0; j != v16; j = (char *)j + 1)
              {
                if (*(void *)v34 != v17) {
                  objc_enumerationMutation(v14);
                }
                long long v19 = *(void **)(*((void *)&v33 + 1) + 8 * (void)j);
                long long v20 = [v19 domainHmac];
                long long v21 = [v7 objectForKeyedSubscript:v20];

                if (v21)
                {
                  long long v22 = [v7 objectForKeyedSubscript:v20];
                  objc_msgSend(v22, "addQuota:", objc_msgSend(v19, "quota"));
                }
                else
                {
                  [v7 setObject:v19 forKeyedSubscript:v20];
                }
              }
              id v16 = [v14 countByEnumeratingWithState:&v33 objects:v41 count:16];
            }
            while (v16);
          }
        }
        id v9 = [obj countByEnumeratingWithState:&v37 objects:v44 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }
    long long v23 = obj;

    id v7 = v7;
    id v5 = v7;
    id v3 = v30;
LABEL_30:
  }
  return v5;
}

BOOL sub_10006CFF8(id a1, MBCKSnapshot *a2, unint64_t a3, BOOL *a4)
{
  return (id)[(MBCKSnapshot *)a2 snapshotFormat] == (id)3;
}

uint64_t MBSnapshotTypeForFormatTransition(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1 == -1) {
    __assert_rtn("MBSnapshotTypeForFormatTransition", "MBCKSnapshot.m", 1021, "previousFormat != MBSnapshotFormatUnspecified");
  }
  if (a2 == -1) {
    __assert_rtn("MBSnapshotTypeForFormatTransition", "MBCKSnapshot.m", 1022, "nextFormat != MBSnapshotFormatUnspecified");
  }
  if (a1 == a2) {
    goto LABEL_4;
  }
  uint64_t v3 = a2;
  if (a2 != 3)
  {
    if (a2)
    {
      if (a1 <= a2)
      {
LABEL_4:
        uint64_t v3 = 1;
        goto LABEL_12;
      }
      if (a3)
      {
        *a3 = +[MBError errorWithCode:205, @"Invalid format transition %llu -> %llu", a1, a2 format];
      }
      uint64_t v3 = -1;
    }
    else
    {
      uint64_t v3 = 2;
    }
  }
LABEL_12:
  id v5 = MBGetDefaultLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = MBStringForSnapshotType();
    id v7 = MBStringForSnapshotFormat();
    id v8 = MBStringForSnapshotFormat();
    *(_DWORD *)buf = 138412802;
    uint64_t v14 = v6;
    __int16 v15 = 2112;
    id v16 = v7;
    __int16 v17 = 2112;
    long long v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Determined snapshot type:%@ for format transition %@ -> %@", buf, 0x20u);

    id v9 = MBStringForSnapshotType();
    id v10 = MBStringForSnapshotFormat();
    uint64_t v12 = MBStringForSnapshotFormat();
    _MBLog();
  }
  return v3;
}

id MBOperationGroupNamePrefixForBackup(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = objc_opt_new();
  id v5 = MBStringForSnapshotFormat();
  [v4 appendFormat:@"%@|", v5];

  if (v3 && (uint64_t)[v3 snapshotFormat] < a2)
  {
    [v4 appendFormat:@"transition|"];
  }
  else
  {
    id v6 = MBStringForSnapshotType();
    [v4 appendFormat:@"%@|", v6];
  }
  id v7 = +[MBBehaviorOptions sharedOptions];
  objc_msgSend(v4, "appendFormat:", @"%d|", objc_msgSend(v7, "isAutomation"));

  return v4;
}

BOOL MBSnapshotsAreTransitioningFormats(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (!v4) {
    __assert_rtn("MBSnapshotsAreTransitioningFormats", "MBCKSnapshot.m", 1061, "currentSnapshot");
  }
  id v5 = v4;
  if (v3)
  {
    id v6 = [v3 snapshotFormat];
    BOOL v7 = v6 != [v5 snapshotFormat];
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

CFStringRef MBStringForCameraRollState(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 2) {
    return @"unspecified";
  }
  else {
    return off_100411458[a1 - 1];
  }
}

id sub_10006EBE4(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.01 maxProgress:0.05];

  id v5 = *(void **)(a1 + 32);
  return [v5 refreshCacheWithError:a2];
}

id sub_10006EC50(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.05 maxProgress:0.1];

  id v5 = *(void **)(a1 + 32);
  return _[v5 synchronizeFileListsWithError:a2];
}

id sub_10006ECBC(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) findRestorablesWithError:a2];
}

id sub_10006ECC8(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.1 maxProgress:0.95];

  id v5 = *(void **)(a1 + 32);
  return _[v5 downloadRestorablesWithError:a2];
}

id sub_10006ED34(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) restoreEntitlementsWithError:a2];
}

id sub_10006ED40(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _configureAndInstallPlaceholdersWithError:a2];
}

id sub_10006ED4C(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) annotateRestoreWithError:a2];
}

id sub_10006ED58(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) verifyRestoreWithError:a2];
}

id sub_10006ED64(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) finalizeRestoreWithError:a2];
}

void sub_100070E90(_Unwind_Exception *a1)
{
}

uint64_t sub_100070F18(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  return result;
}

uint64_t sub_100070F28(uint64_t a1, uint64_t a2)
{
  return 1;
}

void sub_100071A64(uint64_t a1, void *a2, void *a3, int a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = MBGetDefaultLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412802;
    id v11 = v7;
    __int16 v12 = 1024;
    int v13 = a4;
    __int16 v14 = 2112;
    id v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= =sync= Fetched %@ (downloaded: %d) with reference %@", buf, 0x1Cu);
    _MBLog();
  }

  [*(id *)(a1 + 32) addObject:v7];
}

void sub_100071E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_100071EB4(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (!v5) {
    __assert_rtn("-[MBCKRestoreEngine _markForegroundRestorablesForBackgroundRestoreInPlan:domainName:error:]_block_invoke", "MBCKRestoreEngine.m", 894, "restorable");
  }
  if (!a3) {
    __assert_rtn("-[MBCKRestoreEngine _markForegroundRestorablesForBackgroundRestoreInPlan:domainName:error:]_block_invoke", "MBCKRestoreEngine.m", 895, "enumeratorError");
  }
  id v6 = v5;
  ++*(void *)(*(void *)(a1[5] + 8) + 24);
  id v7 = [*(id *)(a1[4] + 288) foregroundStateForRestorable:v5];
  if (v7 == (id)3) {
    ++*(void *)(*(void *)(a1[6] + 8) + 24);
  }

  return v7;
}

void sub_100072868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

uint64_t sub_1000728F8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100072908(uint64_t a1)
{
}

uint64_t sub_100072910(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 relativePath];

  if (!v4)
  {
    id v7 = MBGetDefaultLog();
    uint64_t v16 = 1;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_INFO)) {
      goto LABEL_26;
    }
    __int16 v17 = [v3 fileID];
    *(_DWORD *)buf = 138412546;
    id v30 = v17;
    __int16 v31 = 1024;
    LODWORD(v32) = [v3 deleted];
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "=ckrestore-engine= Ignoring fileID: %@ with NULL relativePath (deleted: %d)", buf, 0x12u);

    long long v18 = [v3 fileID];
    [v3 deleted];
    _MBLog();
    goto LABEL_24;
  }
  id v5 = *(void **)(a1 + 32);
  id v6 = [v3 domainName];
  id v7 = [v5 domainForName:v6];

  if (!v7)
  {
    long long v18 = MBGetDefaultLog();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v30 = v3;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "=ckrestore-engine= Unable to get domain for file: %@", buf, 0xCu);
      _MBLog();
    }
    id v7 = 0;
    goto LABEL_24;
  }
  [v3 setupWithDomain:v7];
  uint64_t v8 = [v3 relativePath];
  if (v8)
  {
    id v9 = (void *)v8;
    id v10 = [*(id *)(a1 + 40) restorePolicy];
    unsigned int v11 = [v10 shouldRestoreSystemFile:v3];

    if (!v11) {
      goto LABEL_25;
    }
  }
  if ([v3 size])
  {
    uint64_t v12 = [v3 signature];
    if (!v12) {
      __assert_rtn("-[MBCKRestoreEngine findRestorablesWithError:]_block_invoke", "MBCKRestoreEngine.m", 972, "file.size == 0 || file.signature");
    }
  }
  if (![v3 volumeType]) {
    __assert_rtn("-[MBCKRestoreEngine findRestorablesWithError:]_block_invoke", "MBCKRestoreEngine.m", 973, "file.volumeType != MBVolumeTypeUnspecified");
  }
  uint64_t v13 = [*(id *)(a1 + 48) addFileToRestoreFiles:v3];
  uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;

  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
  {
    long long v18 = [v7 name];
    uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 8);
    long long v22 = *(void **)(v19 + 40);
    long long v20 = (id *)(v19 + 40);
    long long v21 = v22;
    if (v22)
    {
      if ([v21 isEqualToString:v18])
      {
        uint64_t v23 = *(void *)(*(void *)(a1 + 72) + 8);
        uint64_t v24 = *(void *)(v23 + 24) + 1;
LABEL_23:
        *(void *)(v23 + 24) = v24;
        ++*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
LABEL_24:

LABEL_25:
        uint64_t v16 = 1;
        goto LABEL_26;
      }
      long long v25 = MBGetDefaultLog();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        id v26 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
        uint64_t v27 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
        *(_DWORD *)buf = 134218242;
        id v30 = v26;
        __int16 v31 = 2114;
        uint64_t v32 = v27;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= Found %llu restorables for \"%{public}@\"", buf, 0x16u);
        _MBLog();
      }

      long long v20 = (id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    }
    objc_storeStrong(v20, v18);
    uint64_t v23 = *(void *)(*(void *)(a1 + 72) + 8);
    uint64_t v24 = 1;
    goto LABEL_23;
  }
  uint64_t v16 = 0;
LABEL_26:

  return v16;
}

uint64_t sub_100073D94(id *a1, void *a2)
{
  id v3 = a2;
  if ([a1[4] useFileLists]) {
    [a1[5] addObject:v3];
  }
  if (([a1[6] isSystemDomainName:v3] & 1) != 0
    || (+[MBDomain isSystemContainerName:v3] & 1) != 0
    || (+[MBDomain isSystemSharedContainerName:](MBDomain, "isSystemSharedContainerName:", v3) & 1) != 0|| [v3 isEqualToString:@"SkippedFilesDomain"])
  {
    [a1[7] addObject:v3];
  }
  else if (([a1[4] useFileLists] & 1) == 0 {
         && +[MBDomain isAppPlaceholderName:v3])
  }
  {
    id v5 = +[MBDomain containerIDWithName:v3];
    id v6 = [a1[4] excludedAppBundleIDs];
    unsigned int v7 = [v6 containsObject:v5];

    if (v7)
    {
      uint64_t v8 = MBGetDefaultLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        unsigned int v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= Excluding app placeholder for %{public}@", buf, 0xCu);
        _MBLog();
      }
    }
    else
    {
      [a1[4] _uninstallExistingAppWithBundleID:v5 error:0];
      id v9 = MBGetDefaultLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        unsigned int v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= App wasn't already installed %@. Adding it to domainNamesToRestore", buf, 0xCu);
        _MBLog();
      }

      [a1[7] addObject:v3];
    }
  }
  return 1;
}

uint64_t sub_100073FC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "=ckrestore-engine= Found placeholder ipa corresponding to bundleID %@", buf, 0xCu);
    _MBLog();
  }

  [*(id *)(a1 + 32) _uninstallExistingAppWithBundleID:v3 error:0];
  return 1;
}

uint64_t sub_1000740A4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000740B8(id result, uint64_t a2, uint64_t a3)
{
  if (!(a3 | a2))
  {
    id v3 = result;
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *((void *)v3 + 4);
      *(_DWORD *)buf = 138412290;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= Removing from foreground restore: %@ (not present in backup)", buf, 0xCu);
      _MBLog();
    }

    return [*((id *)v3 + 5) addObject:*((void *)v3 + 4)];
  }
  return result;
}

void sub_100074BAC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100074BC8(uint64_t a1)
{
  int v2 = MBGetDefaultLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = [*(id *)(a1 + 40) restoreRootPath];
    *(_DWORD *)buf = 138543618;
    uint64_t v15 = v3;
    __int16 v16 = 2112;
    id v17 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= Starting domain restore for %{public}@ at path %@", buf, 0x16u);

    uint64_t v12 = [*(id *)(a1 + 40) restoreRootPath];
    _MBLog();
  }
  uint64_t v5 = *(void **)(a1 + 40);
  id v13 = 0;
  unsigned __int8 v6 = [v5 runWithError:&v13];
  id v7 = v13;
  uint64_t v8 = MBGetDefaultLog();
  id v9 = v8;
  if (v6)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      uint64_t v15 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "=ckrestore-engine= Finished domain restore for %{public}@", buf, 0xCu);
      _MBLog();
    }
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      id v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "=ckrestore-engine= Failed to restore using plan for domain %{public}@: %@", buf, 0x16u);
      _MBLog();
    }

    id v9 = *(id *)(a1 + 48);
    objc_sync_enter(v9);
    [*(id *)(a1 + 48) addObject:v7];
    objc_sync_exit(v9);
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
}

void sub_100074E10(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100075B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x258], 8);
  _Block_object_dispose(&STACK[0x278], 8);
  _Block_object_dispose(&STACK[0x298], 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100075C20(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (char *)[v3 size];
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) += &v4[(void)[v3 resourcesSize]];
  uint64_t v5 = [*(id *)(a1 + 32) domainManager];
  unsigned __int8 v6 = [v3 domainName];
  id v7 = [v5 domainForName:v6];

  uint64_t v8 = *(void **)(a1 + 40);
  id v9 = [v7 name];
  LODWORD(v_Block_object_dispose(&STACK[0x270], 8) = [v8 containsObject:v9];

  if (v8)
  {
    uint64_t v10 = (char *)[v3 size];
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += &v10[(void)[v3 resourcesSize]];
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  }

  return 1;
}

uint64_t sub_100075D34(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 isRegularFile] && (objc_msgSend(v3, "deleted") & 1) == 0)
  {
    uint64_t v5 = (char *)[v3 size];
    unsigned __int8 v6 = &v5[(void)[v3 resourcesSize]];
    id v7 = [*(id *)(a1 + 32) domainManager];
    uint64_t v8 = [v3 domainName];
    id v9 = [v7 domainForName:v8];

    uint64_t v10 = *(void **)(a1 + 40);
    uint64_t v11 = [v9 name];
    LOBYTE(v10) = [v10 containsObject:v11];

    if ((v10 & 1) == 0)
    {
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v6;
      ++*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      uint64_t v4 = 1;
LABEL_19:

      goto LABEL_20;
    }
    [v3 setupWithDomain:v9];
    char v24 = 0;
    uint64_t v12 = *(void **)(*(void *)(a1 + 32) + 288);
    id v23 = 0;
    unsigned __int8 v13 = [v12 shouldRestoreFile:v3 markFileAsSkipped:&v24 error:&v23];
    id v14 = v23;
    if (v13)
    {
      if (([v3 downloaded] & 1) == 0)
      {
        ++*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
        *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) += v6;
        uint64_t v15 = MBGetDefaultLog();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          id v26 = v3;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "=ckrestore-engine= Adding file to download batch: %@", buf, 0xCu);
          _MBLog();
        }

        [*(id *)(a1 + 48) prefetchRecord:v3];
      }
      ++*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
      uint64_t v16 = *(void *)(*(void *)(a1 + 96) + 8);
      uint64_t v17 = (uint64_t)&v6[*(void *)(v16 + 24)];
    }
    else
    {
      if (v24)
      {
        long long v18 = [*(id *)(a1 + 32) cache];
        id v19 = [v18 setRestoreState:13 forFile:v3];
      }
      long long v20 = [*(id *)(a1 + 32) progressModel];
      [v20 finishedItem:v3 size:v6];

      if (v14
        && (+[MBError isError:v14 withCode:213] & 1) == 0)
      {
        long long v22 = MBGetDefaultLog();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          id v26 = v3;
          __int16 v27 = 2112;
          id v28 = v14;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "=ckrestore-engine= Failed to determine if file %@ should be restored: %@", buf, 0x16u);
          _MBLog();
        }

        uint64_t v4 = 0;
        goto LABEL_18;
      }
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v6;
      uint64_t v16 = *(void *)(*(void *)(a1 + 64) + 8);
      uint64_t v17 = *(void *)(v16 + 24) + 1;
    }
    *(void *)(v16 + 24) = v17;
    uint64_t v4 = 1;
LABEL_18:

    goto LABEL_19;
  }
  uint64_t v4 = 1;
LABEL_20:

  return v4;
}

void sub_100077040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19)
{
  objc_sync_exit(v19);
  _Unwind_Resume(a1);
}

void sub_100077114(id a1)
{
  qword_100482348 = objc_opt_new();
  _objc_release_x1();
}

void sub_100077F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id obj, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
}

void sub_100077FF8(id a1)
{
  qword_100482358 = objc_opt_new();
  _objc_release_x1();
}

void sub_100078034(uint64_t a1, uint64_t a2, id obj)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), obj);
}

int64_t sub_100078054(id a1, id a2, id a3)
{
  if (objc_msgSend(a2, "containerType", a3) == 1) {
    return 1;
  }
  else {
    return -1;
  }
}

id sub_100078824(uint64_t a1, uint64_t a2)
{
  return [*(id *)(*(void *)(a1 + 32) + 40) domainForName:a2];
}

uint64_t sub_100079E9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 domainName];
  uint64_t v5 = [v3 entitlements];
  unsigned __int8 v6 = v5;
  if (v5)
  {
    if (![v5 count])
    {
      id v7 = MBGetDefaultLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v15 = v4;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= No entitlements for domain %@", buf, 0xCu);
        unsigned __int8 v13 = v4;
        _MBLog();
      }
    }
    uint64_t v8 = objc_msgSend(v3, "entitlementsPath", v13);
    id v9 = [v3 owningBundleID];
    if (!v9)
    {
      id v9 = +[MBDomain containerIDWithName:v4];
    }
    uint64_t v10 = MBGetDefaultLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412802;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      uint64_t v17 = v8;
      __int16 v18 = 2112;
      id v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "=ckrestore-engine= Setting entitlements for %@ (%@): %@", buf, 0x20u);
      _MBLog();
    }

    uint64_t v11 = [[MBPlaceholderEntitlements alloc] initWithBundleID:v9 relativePath:v8 entitlements:v6];
    [*(id *)(a1 + 32) setObject:v11 forKeyedSubscript:v4];
  }
  else
  {
    uint64_t v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v15 = v4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "=ckrestore-engine= Found nil entitlements dictionary for domain %@", buf, 0xCu);
      _MBLog();
    }
  }

  return 1;
}

void sub_10007AFCC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10007C0E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10007C0FC(uint64_t a1)
{
  v7[0] = *(void *)(*(void *)(a1 + 32) + 32);
  v6[0] = @"CACHE_DELETE_VOLUME";
  v6[1] = @"CACHE_DELETE_AMOUNT";
  int v2 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 56)];
  v6[2] = @"CACHE_DELETE_URGENCY_LIMIT";
  v7[1] = v2;
  uint64_t v7[2] = &off_100439E88;
  id v3 = +[NSDictionary dictionaryWithObjects:v7 forKeys:v6 count:3];

  long long v5 = *(_OWORD *)(a1 + 40);
  id v4 = (id)v5;
  *(void *)(*(void *)(a1 + 32) + 16) = CacheDeletePurgeSpaceWithInfo();
}

void sub_10007C248(uint64_t a1, void *a2)
{
  id v4 = [a2 objectForKey:@"CACHE_DELETE_AMOUNT"];
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v4 unsignedLongLongValue];

  long long v5 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v5);
}

id sub_10007C39C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _cancel];
}

uint64_t MBEnumerateDirectoryNodes(int a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v42[0] = word_10047E688;
  v42[1] = 0;
  int v43 = dword_10047E68C | 0x20000001;
  int v44 = 0;
  uint64_t v45 = unk_10047E694;
  int v46 = dword_10047E69C;
  id v7 = v5;
  id v8 = [v7 mutableBytes];
  id v35 = v7;
  id v9 = (char *)[v7 length];
  long long v39 = +[NSFileManager defaultManager];
  id v36 = v6;
  int v34 = a1;
  int v10 = getattrlistbulk(a1, v42, v8, (size_t)v9, 0x29uLL);
  if (v10 >= 1)
  {
    long long v38 = &v9[(void)v8];
    size_t v37 = (size_t)v9;
    do
    {
      unint64_t v11 = 0;
      do
      {
        if (v11 >= (unint64_t)v9) {
          __assert_rtn("MBEnumerateDirectoryNodes", "MBNode.m", 148, "byteOffset < attrBufSize");
        }
        uint64_t v12 = (char *)v8 + v11;
        if (*(_DWORD *)((char *)v8 + v11 + 24))
        {
          id v28 = (void (**)(void, void, void, void))v36;
          long long v29 = v35;
          CFStringRef v30 = @"getattrlistbulk() enumeration error";
          goto LABEL_32;
        }
        uint64_t v13 = *(unsigned int *)v12;
        id v15 = v39;
        uint64_t v16 = (uint64_t)&v12[*((int *)v12 + 7) + 28];
        uint64_t v17 = *((unsigned int *)v12 + 8);
        if (v16 + v17 > (unint64_t)v38) {
          __assert_rtn("_checkedNameFromRef", "MBNode.m", 104, "nameOffset + nameLen <= bufferEnd");
        }
        uint64_t v18 = (v17 - 1);
        if (*(unsigned char *)(v16 + v18)) {
          __assert_rtn("_checkedNameFromRef", "MBNode.m", 105, "nameOffset[nameLen - 1] == '\\0'");
        }
        id v19 = v15;
        long long v20 = (char *)v8;
        uint64_t v21 = [v15 stringWithFileSystemRepresentation:&v12[*((int *)v12 + 7) + 28] length:v18];
        if (!v21)
        {
          char v24 = +[NSData dataWithBytes:v16 length:v18];
          long long v25 = MBGetDefaultLog();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(void *)&uint8_t buf[4] = v24;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Unexpected mbNode name: %@", buf, 0xCu);
            _MBLog();
          }

          if (MBIsInternalInstall())
          {
            id v26 = MBGetDefaultLog();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(void *)&uint8_t buf[4] = v24;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "Unexpected mbNode name: %@", buf, 0xCu);
              goto LABEL_17;
            }
            goto LABEL_18;
          }
          if (!dword_100482368 && !atomic_fetch_add_explicit(&dword_100482368, 1u, memory_order_relaxed))
          {
            id v26 = MBGetDefaultLog();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "Unexpected mbNode name", buf, 2u);
LABEL_17:
              _MBLog();
            }
LABEL_18:
          }
          long long v22 = 0;
LABEL_22:

          goto LABEL_23;
        }
        long long v22 = (void *)v21;

        uint64_t v41 = 0;
        memset(v40, 0, sizeof(v40));
        long long v50 = *(_OWORD *)(v12 + 84);
        long long v51 = *(_OWORD *)(v12 + 100);
        long long v52 = *(_OWORD *)(v12 + 116);
        long long v53 = *(_OWORD *)(v12 + 132);
        *(_OWORD *)buf = *(_OWORD *)(v12 + 36);
        long long v48 = *(_OWORD *)(v12 + 52);
        long long v49 = *(_OWORD *)(v12 + 68);
        if ((sub_10007CBB4((unsigned int *)buf, (uint64_t)v40, v22, 0) & 1) == 0) {
          goto LABEL_22;
        }
        char v23 = (*((uint64_t (**)(id, void *, _OWORD *, void))v36 + 2))(v36, v22, v40, 0);

        if ((v23 & 1) == 0)
        {
          uint64_t v32 = 0;
          goto LABEL_33;
        }
LABEL_23:
        v11 += v13;
        --v10;
        id v8 = v20;
        id v9 = (char *)v37;
      }
      while (v10);
      int v27 = getattrlistbulk(v34, v42, v8, v37, 0x29uLL);
      int v10 = v27;
    }
    while (v27 > 0);
  }
  if (v10 < 0)
  {
    CFStringRef v30 = @"getattrlistbulk() error";
    id v28 = (void (**)(void, void, void, void))v36;
    long long v29 = v35;
LABEL_32:
    __int16 v31 = +[MBError errorWithErrno:*__error() format:v30];
    ((void (**)(void, void, void, void *))v28)[2](v28, 0, 0, v31);

    uint64_t v32 = 0;
  }
  else
  {
    uint64_t v32 = 1;
LABEL_33:
    id v28 = (void (**)(void, void, void, void))v36;
    long long v29 = v35;
  }

  return v32;
}

uint64_t sub_10007CBB4(unsigned int *a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  if (!a2) {
    __assert_rtn("_mbNodeFromAttrs", "MBNode.m", 230, "mbNode");
  }
  id v8 = v7;
  unsigned int v9 = *a1;
  unsigned int v10 = a1[15];
  if (*a1 == 1)
  {
    __int16 v11 = 0x8000;
  }
  else if (v9 == 2)
  {
    __int16 v11 = 0x4000;
  }
  else
  {
    if (v9 != 5)
    {
      if (a4)
      {
        +[MBError errorWithCode:242, v7, @"Not a directory, symlink, or regular file (%d)", *a1 path format];
        uint64_t v18 = 0;
        *a4 = (id)objc_claimAutoreleasedReturnValue();
        goto LABEL_26;
      }
LABEL_13:
      uint64_t v18 = 0;
      goto LABEL_26;
    }
    __int16 v11 = -24576;
  }
  int v12 = MBProtectionClassSupportedValue(a1[20], v9 == 1, a4);
  if (v12 == 255) {
    goto LABEL_13;
  }
  unsigned int v13 = a1[21];
  if (v9 == 2)
  {
    uint64_t v14 = 0;
    BOOL v15 = 0;
    uint64_t v16 = 0;
    unsigned int v17 = 0;
  }
  else
  {
    BOOL v15 = v13 > 1;
    uint64_t v16 = *((void *)a1 + 12);
    if (v9 == 1)
    {
      uint64_t v14 = *((void *)a1 + 11);
      unsigned int v17 = a1[17];
    }
    else
    {
      uint64_t v14 = 0;
      unsigned int v17 = 0;
    }
    unsigned int v13 = 1;
  }
  uint64_t v19 = 26;
  if (v9 == 2) {
    uint64_t v19 = 24;
  }
  uint64_t v20 = *(void *)&a1[v19];
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 4_Block_object_dispose(&STACK[0x230], 8) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v21 = *(void *)(a1 + 1);
  uint64_t v22 = *(void *)(a1 + 5);
  uint64_t v23 = *(void *)(a1 + 9);
  uint64_t v24 = *((void *)a1 + 9);
  if (v9 == 1 && (v20 & 0x40) != 0) {
    char v25 = 2;
  }
  else {
    char v25 = 0;
  }
  uint64_t v26 = *(void *)(a1 + 13);
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 4) = v26;
  *(_DWORD *)(a2 + 12) = 0;
  *(void *)(a2 + 16) = v21;
  *(void *)(a2 + 24) = v22;
  *(void *)(a2 + 32) = v23;
  *(void *)(a2 + 40) = v14;
  *(void *)(a2 + 4_Block_object_dispose(&STACK[0x230], 8) = v24;
  *(_DWORD *)(a2 + 56) = v17;
  *(void *)(a2 + 60) = v16;
  *(_WORD *)(a2 + 6_Block_object_dispose(&STACK[0x230], 8) = v11 | v10 & 0xFFF;
  *(unsigned char *)(a2 + 70) = v12;
  *(unsigned char *)(a2 + 71) = (v15 & 0xFB | (4 * ((v20 & 2) != 0)) | v25) ^ 4;
  unsigned int v27 = a1[16];
  *(_DWORD *)(a2 + 12) = v27;
  if ((v27 & 0x40000000) != 0) {
    *(void *)(a2 + 40) = 0;
  }
  uint64_t v18 = 1;
LABEL_26:

  return v18;
}

uint64_t MBNodeForPath(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  if (!v5) {
    __assert_rtn("MBNodeForPath", "MBNode.m", 187, "path");
  }
  if (!a2) {
    __assert_rtn("MBNodeForPath", "MBNode.m", 188, "mbNode");
  }
  memset(v10, 0, 136);
  id v6 = v5;
  if (getattrlist((const char *)[v6 fileSystemRepresentation], &word_10047E688, v10, 0x88uLL, 0x29u))
  {
    if (a3)
    {
      +[MBError errorWithErrno:*__error() path:v6 format:@"getattrlist() error"];
      uint64_t v7 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      uint64_t v7 = 0;
    }
  }
  else
  {
    v9[4] = *(_OWORD *)((char *)&v10[5] + 8);
    v9[5] = *(_OWORD *)((char *)&v10[6] + 8);
    void v9[6] = *(_OWORD *)((char *)&v10[7] + 8);
    v9[0] = *(_OWORD *)((char *)&v10[1] + 8);
    v9[1] = *(_OWORD *)((char *)&v10[2] + 8);
    v9[2] = *(_OWORD *)((char *)&v10[3] + 8);
    _OWORD v9[3] = *(_OWORD *)((char *)&v10[4] + 8);
    uint64_t v7 = sub_10007CBB4((unsigned int *)v9, a2, v6, a3);
  }

  return v7;
}

uint64_t MBNodeForRelativePathAt(int a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v7 = a2;
  if (a1 < 0) {
    __assert_rtn("MBNodeForRelativePathAt", "MBNode.m", 213, "fd >= 0");
  }
  id v8 = v7;
  if (!v7) {
    __assert_rtn("MBNodeForRelativePathAt", "MBNode.m", 214, "relativePath");
  }
  if (!a3) {
    __assert_rtn("MBNodeForRelativePathAt", "MBNode.m", 215, "mbNode");
  }
  if ([(__CFString *)v7 length]) {
    unsigned int v9 = v8;
  }
  else {
    unsigned int v9 = @".";
  }
  memset(v13, 0, 136);
  if (getattrlistat(a1, (const char *)[(__CFString *)v9 fileSystemRepresentation], &word_10047E688, v13, 0x88uLL, 0x29uLL))
  {
    if (a4)
    {
      +[MBError errorWithErrno:*__error() path:v8 format:@"getattrlistat() error"];
      uint64_t v10 = 0;
      *a4 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      uint64_t v10 = 0;
    }
  }
  else
  {
    v12[4] = *(_OWORD *)((char *)&v13[5] + 8);
    v12[5] = *(_OWORD *)((char *)&v13[6] + 8);
    void v12[6] = *(_OWORD *)((char *)&v13[7] + 8);
    v12[0] = *(_OWORD *)((char *)&v13[1] + 8);
    v12[1] = *(_OWORD *)((char *)&v13[2] + 8);
    v12[2] = *(_OWORD *)((char *)&v13[3] + 8);
    uint64_t v12[3] = *(_OWORD *)((char *)&v13[4] + 8);
    uint64_t v10 = sub_10007CBB4((unsigned int *)v12, a3, v8, a4);
  }

  return v10;
}

NSString *MBNodeAsString(unsigned int *a1)
{
  return +[NSString stringWithFormat:@"<MBNode %p: mode 0%o, direntCount %u, uid %d, gid %d, birth %ld, modified %ld, flags 0x%x, statusChanged %ld, fileSize %llu, inode %llu, genCount %u, cloneID %llu, pc %hhu, xattrs %d>", a1, *((unsigned __int16 *)a1 + 34), *a1, a1[1], a1[2], *((void *)a1 + 2), *((void *)a1 + 3), a1[3], *((void *)a1 + 4), *((void *)a1 + 5), *((void *)a1 + 6), a1[14], *(void *)(a1 + 15), *((unsigned __int8 *)a1 + 70), (*((unsigned __int8 *)a1 + 71) >> 2) & 1];
}

CFStringRef MBNodeTypeString(__int16 a1)
{
  CFStringRef v1 = @"regular file";
  int v2 = a1 & 0xF000;
  CFStringRef v3 = @"(unknown)";
  if (v2 == 0x4000) {
    CFStringRef v3 = @"directory";
  }
  if (v2 != 0x8000) {
    CFStringRef v1 = v3;
  }
  if (v2 == 40960) {
    return @"symbolic link";
  }
  else {
    return v1;
  }
}

BOOL MBBackwardsCompatibleMBNodeFromStat(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(unsigned __int16 *)(a1 + 4);
  int v4 = v3 & 0xF000;
  if (v4 == 0x4000 || v4 == 0x8000 || v4 == 40960)
  {
    if (v4 == 0x8000)
    {
      uint64_t v5 = *(void *)(a1 + 96);
      char v6 = (*(unsigned __int16 *)(a1 + 6) > 1u) | 4;
    }
    else
    {
      if (v4 == 0x4000)
      {
        uint64_t v5 = 0;
        int v7 = *(unsigned __int16 *)(a1 + 6);
        char v6 = 4;
        goto LABEL_12;
      }
      uint64_t v5 = 0;
      char v6 = 4;
    }
    int v7 = 1;
LABEL_12:
    *(void *)(a2 + 64) = 0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 4_Block_object_dispose(&STACK[0x230], 8) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    uint64_t v9 = *(void *)(a1 + 80);
    uint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 64);
    uint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 16);
    *(_DWORD *)a2 = v7;
    *(void *)(a2 + 4) = v13;
    *(_DWORD *)(a2 + 12) = 0;
    *(void *)(a2 + 16) = v9;
    *(void *)(a2 + 24) = v10;
    *(void *)(a2 + 32) = v11;
    *(void *)(a2 + 40) = v5;
    *(void *)(a2 + 4_Block_object_dispose(&STACK[0x230], 8) = v12;
    *(_DWORD *)(a2 + 56) = 0;
    *(void *)(a2 + 60) = 0;
    *(_WORD *)(a2 + 6_Block_object_dispose(&STACK[0x230], 8) = v3;
    *(unsigned char *)(a2 + 70) = 0;
    *(unsigned char *)(a2 + 71) = v6;
    int v14 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)(a2 + 12) = v14;
    if ((v14 & 0x40000000) != 0) {
      *(void *)(a2 + 40) = 0;
    }
    return v4 == 0x8000 || v4 == 40960 || v4 == 0x4000;
  }
  if (a3)
  {
    *a3 = +[MBError posixErrorWithFormat:@"Not a directory, symlink, or regular file (%d)", v3];
  }
  return v4 == 0x8000 || v4 == 40960 || v4 == 0x4000;
}

void sub_10007DC58(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if ([a1[4] isInvalid])
  {
    id v8 = +[MBError errorWithCode:1 format:@"Invalidated"];
    id v9 = a1[5];
    objc_sync_enter(v9);
    [a1[5] setObject:v8 forKeyedSubscript:v5];
    objc_sync_exit(v9);
  }
  else
  {
    id v20 = [a1[6] objectForKeyedSubscript:v5];
    id v10 = a1[4];
    id v21 = 0;
    uint64_t v11 = [v10 _resolveRelativePath:v5 error:&v21];
    id v8 = v21;
    if (v11)
    {
      state = copyfile_state_alloc();
      id v12 = v11;
      uint64_t v13 = (const char *)[v12 fileSystemRepresentation];
      id v14 = v20;
      int v15 = copyfile(v13, (const char *)[v14 fileSystemRepresentation], state, 0x12C0000u);
      if (v15)
      {
        int v18 = *__error();
        uint64_t v16 = +[MBError posixErrorWithPath:v12 format:@"copyfile failed"];

        [a1[5] setObject:v16 forKeyedSubscript:v5];
        unsigned int v17 = MBGetDefaultLog();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138413058;
          id v23 = v12;
          __int16 v24 = 2112;
          id v25 = v14;
          __int16 v26 = 1024;
          int v27 = v15;
          __int16 v28 = 1024;
          int v29 = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "copyfile(%@, %@) failed (%d): %{errno}d", buf, 0x22u);
          _MBLog();
        }
      }
      else
      {
        uint64_t v16 = (uint64_t)v8;
      }
      copyfile_state_free(state);
      id v8 = (id)v16;
    }
    else
    {
      [a1[5] setObject:v8 forKeyedSubscript:v5];
    }
  }
}

void sub_10007DEE4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10007ED48(_Unwind_Exception *a1)
{
}

void sub_10007ED88(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    int v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v5 = [*(id *)(a1 + 32) keybagUUIDString];
      *(_DWORD *)buf = 138412546;
      id v8 = v5;
      __int16 v9 = 2112;
      id v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to save keybag record for %@ to server: %@", buf, 0x16u);

      id v6 = [*(id *)(a1 + 32) keybagUUIDString];
      _MBLog();
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

uint64_t sub_10007EE98(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10007EEA8(uint64_t a1)
{
}

void sub_10007EEB0(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to batch save keybags records to server %@", buf, 0xCu);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10007F384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location,char a26)
{
  objc_destroyWeak(v26);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v27 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_10007F3D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [[MBCKKeyBag alloc] initWithRecord:v3 device:*(void *)(a1 + 32)];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_10007F44C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
    id v7 = [WeakRetained operationID];

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a3);
    id v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412802;
      uint64_t v11 = v9;
      __int16 v12 = 2114;
      uint64_t v13 = v7;
      __int16 v14 = 2112;
      id v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Keybag %@ fetch operation %{public}@ failed with error: %@", buf, 0x20u);
      _MBLog();
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void sub_100080730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t sub_100080758(uint64_t a1)
{
  dispatch_semaphore_t v2 = dispatch_semaphore_create(20);
  id v3 = (void *)qword_100482370;
  qword_100482370 = (uint64_t)v2;

  Name = class_getName(*(Class *)(a1 + 32));
  id v5 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v6 = dispatch_queue_create(Name, v5);
  id v7 = (void *)qword_100482378;
  qword_100482378 = (uint64_t)v6;

  qword_100482380 = (uint64_t)[objc_alloc((Class)NSMutableArray) initWithCapacity:20];
  return _objc_release_x1();
}

void sub_100080804(uint64_t a1)
{
  if ((unint64_t)[(id)qword_100482380 count] >= 0x15) {
    __assert_rtn("+[MBCKKeyBag unlockKeybag:accountType:error:block:]_block_invoke_2", "MBCKKeyBag.m", 364, "sUnlockedKeybags.count <= sMaxUnlockedKeybagCount");
  }
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id v2 = (id)qword_100482380;
  id v3 = (char *)[v2 countByEnumeratingWithState:&v36 objects:v45 count:16];
  if (v3)
  {
    id v4 = v3;
    id v5 = 0;
    uint64_t v6 = *(void *)v37;
    while (2)
    {
      id v7 = 0;
      id v8 = &v5[(void)v4];
      do
      {
        if (*(void *)v37 != v6) {
          objc_enumerationMutation(v2);
        }
        uint64_t v9 = *(void **)(*((void *)&v36 + 1) + 8 * (void)v7);
        if (v9 == *(void **)(a1 + 32)
          || objc_msgSend(*(id *)(*((void *)&v36 + 1) + 8 * (void)v7), "isEqual:"))
        {
          objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v9);
          uint64_t v10 = (uint64_t)&v7[(void)v5];
          goto LABEL_14;
        }
        ++v7;
      }
      while (v4 != v7);
      id v4 = (char *)[v2 countByEnumeratingWithState:&v36 objects:v45 count:16];
      uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
      id v5 = v8;
      if (v4) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  }
LABEL_14:

  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
  {
    if (v10)
    {
      if (v10 == 0x7FFFFFFFFFFFFFFFLL) {
        __assert_rtn("+[MBCKKeyBag unlockKeybag:accountType:error:block:]_block_invoke_2", "MBCKKeyBag.m", 377, "index != NSNotFound");
      }
      [(id)qword_100482380 removeObjectAtIndex:v10];
      [(id)qword_100482380 insertObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) atIndex:0];
    }
    goto LABEL_33;
  }
  if ([(id)qword_100482380 count] == (id)20)
  {
    uint64_t v11 = [(id)qword_100482380 count];
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    __int16 v12 = [(id)qword_100482380 reverseObjectEnumerator];
    uint64_t v13 = [v12 countByEnumeratingWithState:&v32 objects:v44 count:16];
    if (!v13) {
      goto LABEL_27;
    }
    __int16 v14 = v13;
    uint64_t v15 = *(void *)v33;
LABEL_21:
    unint64_t v16 = 0;
    unsigned int v17 = (unsigned char *)(v11 - v14);
    while (1)
    {
      if (*(void *)v33 != v15) {
        objc_enumerationMutation(v12);
      }
      int v18 = *(void **)(*((void *)&v32 + 1) + 8 * v16);
      if (!v18[10]) {
        break;
      }
      if (v14 == (unsigned char *)++v16)
      {
        __int16 v14 = [v12 countByEnumeratingWithState:&v32 objects:v44 count:16];
        uint64_t v11 = v17;
        if (!v14)
        {
LABEL_27:

          goto LABEL_28;
        }
        goto LABEL_21;
      }
    }
    uint64_t v19 = v18;

    if (v11 + 0x8000000000000000 == (unsigned char *)v16) {
LABEL_28:
    }
      __assert_rtn("+[MBCKKeyBag unlockKeybag:accountType:error:block:]_block_invoke_2", "MBCKKeyBag.m", 403, "index != NSNotFound");
    [(id)qword_100482380 removeObjectAtIndex:&v11[~v16]];
    [v19 lock];
  }
  id v20 = *(void **)(a1 + 32);
  uint64_t v21 = *(void *)(a1 + 56);
  id v31 = 0;
  unsigned __int8 v22 = [v20 unlockWithAccountType:v21 error:&v31];
  id v23 = v31;
  if (v22)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), *(id *)(a1 + 32));
    [(id)qword_100482380 insertObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) atIndex:0];

LABEL_33:
    uint64_t v24 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    uint64_t v25 = *(void *)(v24 + 80);
    if (v25 < 0) {
      __assert_rtn("+[MBCKKeyBag unlockKeybag:accountType:error:block:]_block_invoke", "MBCKKeyBag.m", 420, "0 <= unlockedKeybag->_dc");
    }
    *(void *)(v24 + 80) = v25 + 1;
    if ((unint64_t)[(id)qword_100482380 count] >= 0x15) {
      __assert_rtn("+[MBCKKeyBag unlockKeybag:accountType:error:block:]_block_invoke", "MBCKKeyBag.m", 423, "sUnlockedKeybags.count <= sMaxUnlockedKeybagCount");
    }
    return;
  }
  __int16 v26 = MBGetDefaultLog();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    uint64_t v27 = [*(id *)(a1 + 32) keybagUUIDString];
    *(_DWORD *)buf = 138412546;
    uint64_t v41 = v27;
    __int16 v42 = 2112;
    id v43 = v23;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to unlock keybag %@: %@", buf, 0x16u);

    CFStringRef v30 = [*(id *)(a1 + 32) keybagUUIDString];
    _MBLog();
  }
  uint64_t v28 = *(void *)(*(void *)(a1 + 48) + 8);
  int v29 = *(void **)(v28 + 40);
  *(void *)(v28 + 40) = v23;
}

uint64_t sub_100080C80(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)(result + 32) + 8) + 40);
  --*(void *)(v1 + 80);
  if ((*(void *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 40) + 80) & 0x8000000000000000) != 0) {
    __assert_rtn("+[MBCKKeyBag unlockKeybag:accountType:error:block:]_block_invoke_2", "MBCKKeyBag.m", 437, "0 <= unlockedKeybag->_dc");
  }
  return result;
}

void sub_100081058(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10008118C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100081514(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

void sub_10008157C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000815E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000823E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_100082498(uint64_t a1, void *a2, void *a3)
{
  if (a2)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    id v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v11 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Passcode policy evaluation succeeded: %@", buf, 0xCu);
LABEL_10:
      _MBLog();
    }
  }
  else if (objc_msgSend(objc_msgSend(a3, "domain"), "isEqualToString:", LAErrorDomain) {
         && [a3 code] == (id)-5)
  }
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    id v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v11 = a3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Skipping passcode policy evaluation: %@", buf, 0xCu);
      goto LABEL_10;
    }
  }
  else
  {
    id v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v11 = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Passcode policy evaluation failed: %@", buf, 0xCu);
      goto LABEL_10;
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10008368C(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)BYBuddyDaemonCloudSyncClient);
  [*(id *)(a1 + 32) setCloudSyncClient:v2];

  id v3 = *(void **)(a1 + 32);
  id v4 = [v3 cloudSyncClient];
  [v4 setDelegate:v3];
}

id sub_10008411C(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.0 maxProgress:0.01];

  id v5 = *(void **)(a1 + 32);
  return [v5 setUpWithError:a2];
}

id sub_100084184(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.02 maxProgress:0.03];

  id v5 = *(void **)(a1 + 32);
  return [v5 refreshCacheWithError:a2];
}

id sub_1000841F0(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.03 maxProgress:0.05];

  id v5 = *(void **)(a1 + 32);
  return _[v5 synchronizeFileListsWithError:a2];
}

id sub_10008425C(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.05 maxProgress:0.05];

  id v5 = *(void **)(a1 + 32);
  return _[v5 createVolumeSnapshots:a2];
}

id sub_1000842C4(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.05 maxProgress:0.25];

  id v5 = *(void **)(a1 + 32);
  return [v5 findChangesWithError:a2];
}

id sub_10008432C(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.25 maxProgress:0.25];

  id v5 = *(void **)(a1 + 32);
  return _[v5 reserveQuotaWithError:a2];
}

id sub_100084390(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.25 maxProgress:0.9];

  id v5 = *(void **)(a1 + 32);
  return _[v5 prepareToUploadChangesWithError:a2];
}

id sub_1000843F8(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) uploadAssetsWithError:a2];
}

id sub_100084404(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) uploadChangesWithError:a2];
}

id sub_100084410(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.9 maxProgress:0.95];

  id v5 = *(void **)(a1 + 32);
  return _[v5 uploadDomainRecords:a2];
}

id sub_10008447C(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) progressModel];
  [v4 beginStageWithMinProgress:0.95 maxProgress:1.0];

  id v5 = *(void **)(a1 + 32);
  return _[v5 commitSnapshotWithError:a2];
}

id sub_1000844E4(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) finishBackupWithError:a2];
}

void sub_100086F50(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1000860BCLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_100087830(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100087880(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100087890(uint64_t a1)
{
}

void sub_100087898(uint64_t a1, void *a2, void *a3, int a4)
{
  id v7 = a2;
  id v8 = a3;
  uint64_t v9 = *(void **)(a1 + 32);
  uint64_t v10 = [v8 baseRecordID];
  id v11 = [v8 pageCount];
  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
  id obj = *(id *)(v12 + 40);
  unsigned __int8 v13 = [v9 addDomainFromPreviousSnapshotsWithName:v7 recordID:v10 pageCount:v11 error:&obj];
  objc_storeStrong((id *)(v12 + 40), obj);

  __int16 v14 = MBGetDefaultLog();
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v15)
    {
      *(_DWORD *)buf = 138412802;
      id v19 = v7;
      __int16 v20 = 1024;
      int v21 = a4;
      __int16 v22 = 2112;
      id v23 = v8;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Added domain %@(%d) with reference %@ into pending snapshot database", buf, 0x1Cu);
LABEL_6:
      _MBLog();
    }
  }
  else if (v15)
  {
    unint64_t v16 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    *(_DWORD *)buf = 138412290;
    id v19 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Failed to insert domain name into pending snapshot DB: %@", buf, 0xCu);
    goto LABEL_6;
  }
}

id sub_100088DBC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v3 = 0;
  return [v1 handleCancelation:&v3];
}

id sub_10008AB78(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v3 = 0;
  return [v1 handleCancelation:&v3];
}

int64_t sub_10008ABA4(id a1, id a2, id a3)
{
  id v4 = a2;
  id v5 = a3;
  int v6 = sub_10008AC88(v4);
  if (v6 == sub_10008AC88(v5))
  {
    id v7 = [v4 name];
    id v8 = [v5 name];
    int64_t v9 = (int64_t)[v7 compare:v8];
  }
  else
  {
    unsigned int v10 = sub_10008AC88(v4);
    if (v10 >= sub_10008AC88(v5))
    {
      int v11 = sub_10008AC88(v4);
      int64_t v9 = v11 != sub_10008AC88(v5);
    }
    else
    {
      int64_t v9 = -1;
    }
  }

  return v9;
}

uint64_t sub_10008AC88(void *a1)
{
  id v1 = a1;
  if ([v1 isAppDomain])
  {
    if ([v1 isPlaceholderAppDomain]) {
      uint64_t v2 = 1;
    }
    else {
      uint64_t v2 = 2;
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_10008B468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10008B4A8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    id v6 = a2;
    id v7 = +[NSNumber numberWithUnsignedLongLong:a4];
    [*(id *)(a1 + 32) setObject:v7 forKeyedSubscript:v6];
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += a4;
}

uint64_t sub_10008B528(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = +[NSNumber numberWithLongLong:a3];
  [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:v5];

  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += a3;
  return 1;
}

void sub_10008C248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

uint64_t sub_10008C290(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_10008C2B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Resuming previously uploaded domain: %@", buf, 0xCu);
    _MBLog();
  }

  id v5 = [*(id *)(*(void *)(a1 + 32) + 344) resumeInProgressManifest:v3];
  return 1;
}

uint64_t sub_10008C3A8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned int v7 = [*(id *)(a1 + 32) isSystemDomainName:v5];
  unsigned int v8 = [*(id *)(a1 + 32) isSystemDomainName:v6];
  if (v7) {
    uint64_t v9 = v7 & v8 ^ 1;
  }
  else {
    uint64_t v9 = -1;
  }
  if ((v7 & 1) == 0 && (v8 & 1) == 0) {
    uint64_t v9 = (uint64_t)[v5 compare:v6];
  }

  return v9;
}

void sub_10008C434(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  unsigned int v8 = [*(id *)(a1 + 32) progressModel];
  [v8 willTransferItemsWithSize:a4 count:a3 + a2];

  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = a4;
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = a3;
}

void sub_10008DA08(_Unwind_Exception *a1)
{
}

uint64_t sub_10008DB60(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += a3;
  return result;
}

void sub_10008DB78(uint64_t a1)
{
}

void sub_10008DB80(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138543874;
      uint64_t v10 = v5;
      __int16 v11 = 2112;
      uint64_t v12 = v6;
      __int16 v13 = 2112;
      id v14 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "=cloud-backup= Failed to delete pending files for manifest %{public}@ (%@): %@", buf, 0x20u);
      _MBLog();
    }

    unsigned int v7 = [*(id *)(a1 + 48) cache];
    id v8 = [v7 deleteCloudFilesPendingDeleteForManifestID:*(void *)(a1 + 32)];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
}

uint64_t sub_10008DCA0(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int16 v11 = a2;
  id v12 = a3;
  [*(id *)(a1 + 32) resumeWatchdogIfNeeded];
  uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v15 = *(void *)(v13 + 40);
  id v14 = (id *)(v13 + 40);
  if (!v15)
  {
    unint64_t v16 = *(void **)(a1 + 32);
    id obj = 0;
    unsigned __int8 v17 = [v16 handleCancelation:&obj];
    objc_storeStrong(v14, obj);
    if ((v17 & 1) == 0)
    {
      id v20 = *(id *)(*(void *)(a1 + 32) + 40);
      unsigned __int8 v21 = [v20 containsDomainName:v11];
      if (a5 == 3 && (v21 & 1) == 0)
      {
        __int16 v22 = MBGetDefaultLog();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          char v97 = v11;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Creating uninstalled domain (%@)", buf, 0xCu);
          uint64_t v76 = v11;
          _MBLog();
        }

        id v23 = +[MBDomain uninstalledDomainWithName:v11];
        [v20 addDomain:v23];
      }
      uint64_t v24 = objc_msgSend(*(id *)(a1 + 32), "mountedSnapshotTracker", v76);
      uint64_t v25 = [v20 domainForName:v11];
      if (!v25) {
        __assert_rtn("-[MBCKBackupEngine uploadChangesWithError:]_block_invoke", "MBCKBackupEngine.m", 1850, "domain");
      }
      __int16 v26 = (void *)v25;
      id v82 = v20;
      uint64_t v27 = objc_alloc_init(MBCKFileChange);
      [(MBCKFileChange *)v27 setDomain:v26];
      [(MBCKFileChange *)v27 setRelativePath:v12];
      [(MBCKFileChange *)v27 setChangeType:a5];
      [(MBCKFileChange *)v27 setShouldCopy:a6];
      uint64_t v81 = v24;
      char v83 = v26;
      id v86 = v12;
      if (a5 == 3)
      {
        uint64_t v84 = [*(id *)(*(void *)(a1 + 32) + 344) resumeInProgressManifest:v11];
        uint64_t v28 = [(MBCKFileChange *)v84 manifestID];
        int v29 = *(void **)(a1 + 40);
        id v93 = 0;
        unsigned __int8 v30 = [v29 committedManifestContainsDomain:v11 relativePath:v12 pendingManifestID:v28 error:&v93];
        id v31 = v93;
        if (v31)
        {
          long long v32 = v31;
          uint64_t v33 = *(void *)(*(void *)(a1 + 56) + 8);
          long long v34 = *(void **)(v33 + 40);
          *(void *)(v33 + 40) = v31;
          goto LABEL_14;
        }
        if ((v30 & 1) == 0)
        {
          uint64_t v55 = MBGetDefaultLog();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412546;
            char v97 = v27;
            __int16 v98 = 2112;
            char v99 = v28;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_INFO, "=cloud-backup= Not uploading deletion marker for uncommitted file %@ pendingManifest %@", buf, 0x16u);
            _MBLog();
          }

          char v56 = [*(id *)(a1 + 32) cache];
          long long v32 = [v56 removeUncommittedFileWithDomain:v11 relativePath:v12 pendingManifestID:v28];

          if (!v32)
          {
            uint64_t v18 = 1;
            goto LABEL_15;
          }
          uint64_t v57 = *(void *)(*(void *)(a1 + 56) + 8);
          long long v34 = *(void **)(v57 + 40);
          *(void *)(v57 + 40) = v32;
LABEL_14:
          id v35 = v32;

          uint64_t v18 = 0;
LABEL_15:

          long long v36 = v81;
          long long v37 = v82;
          long long v38 = v84;
LABEL_66:

          goto LABEL_4;
        }
      }
      else
      {
        long long v39 = [v26 rootPath];
        long long v40 = [v26 volumeMountPoint];
        uint64_t v41 = [v24 snapshotMountPointForVolumeMountPoint:v40];
        __int16 v42 = v26;
        id v43 = (void *)v41;
        if ([v42 shouldBackupRelativePathFromLiveFileSystem:v12])
        {

          id v43 = 0;
        }
        int v44 = MBSnapshotPathFromLivePath();
        [(MBCKFileChange *)v27 setSnapshotPath:v43];
        uint64_t v45 = [v44 stringByAppendingPathComponent:v12];
        [(MBCKFileChange *)v27 setAbsolutePath:v45];
      }
      char v92 = 0;
      uint64_t v46 = *(void *)(a1 + 32);
      long long v47 = *(void **)(v46 + 344);
      uint64_t v48 = *(void *)(a1 + 48);
      id v91 = 0;
      unsigned __int8 v49 = [v47 addFileChange:v27 batchSave:v48 engine:v46 skipped:&v92 error:&v91];
      long long v50 = (MBCKFileChange *)v91;
      long long v38 = v50;
      if (v49)
      {
        long long v37 = v82;
        id v12 = v86;
        if (v92)
        {
          BOOL v51 = 0;
          goto LABEL_51;
        }
        if (a5 == 3)
        {
          ++*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
          char v54 = (void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
          a4 = 1;
        }
        else
        {
          ++*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
          *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) += a4;
          ++*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
          char v54 = (void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24);
        }
        *v54 += a4;
        if (__ROR8__(0xD288CE703AFB7E91* (*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24)+ *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)), 4) > 0x68DB8BAC710CBuLL)
        {
          BOOL v51 = 1;
          goto LABEL_51;
        }
        uint64_t v85 = v50;
        id v58 = MBGetDefaultLog();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v59 = *(MBCKFileChange **)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
          id v60 = *(MBCKFileChange **)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
          uint64_t v61 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
          *(_DWORD *)buf = 134218754;
          char v97 = v59;
          __int16 v98 = 2048;
          char v99 = v60;
          __int16 v100 = 2048;
          uint64_t v101 = v61;
          __int16 v102 = 2114;
          uint64_t v103 = v11;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Queued %llu files (%llu) and %llu deletes for %{public}@", buf, 0x2Au);
          uint64_t v79 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
          uint64_t v80 = v11;
          uint64_t v77 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
          uint64_t v78 = *(MBCKFileChange **)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
LABEL_49:
          _MBLog();
          goto LABEL_50;
        }
        goto LABEL_50;
      }
      long long v52 = v50;
      long long v37 = v82;
      id v12 = v86;
      uint64_t v85 = v50;
      if (+[MBError isError:v50 withCode:4])
      {
        long long v53 = MBGetDefaultLog();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          char v97 = v27;
          __int16 v98 = 2112;
          char v99 = v85;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "=cloud-backup= Deleted since scan: %@ %@", buf, 0x16u);
LABEL_39:
          _MBLog();
        }
      }
      else if (+[MBError isError:v52 withCode:209])
      {
        long long v53 = MBGetDefaultLog();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          char v97 = v27;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Missing encryption key for %@", buf, 0xCu);
          goto LABEL_39;
        }
      }
      else
      {
        if (!+[MBError isError:v52 withCode:215])
        {
          if (!+[MBError isError:v52 withCode:13])
          {
            unsigned int v71 = +[MBError isError:v52 withCode:16];
            long long v72 = MBGetDefaultLog();
            id v58 = v72;
            if (!v71)
            {
              if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412546;
                char v97 = v27;
                __int16 v98 = 2112;
                char v99 = v85;
                _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "=cloud-backup= Failed to add %@: %@", buf, 0x16u);
                _MBLog();
              }

              uint64_t v74 = *(void *)(*(void *)(a1 + 56) + 8);
              char v75 = v85;
              uint64_t v18 = 0;
              long long v53 = *(NSObject **)(v74 + 40);
              *(void *)(v74 + 40) = v75;
              goto LABEL_64;
            }
            if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
            {
              long long v73 = +[MBError descriptionForError:v85 paths:0];
              *(_DWORD *)buf = 138412546;
              char v97 = v73;
              __int16 v98 = 2112;
              char v99 = v27;
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "=cloud-backup= %@: %@", buf, 0x16u);

              uint64_t v77 = +[MBError descriptionForError:v85 paths:0];
              uint64_t v78 = v27;
              _MBLog();
            }
            goto LABEL_50;
          }
          id v58 = MBGetDefaultLog();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            char v97 = v27;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "=cloud-backup= SQLite file is locked: %@", buf, 0xCu);
            uint64_t v77 = v27;
            goto LABEL_49;
          }
LABEL_50:

          BOOL v51 = v92 == 0;
          long long v38 = v85;
LABEL_51:
          uint64_t v18 = 1;
          if (!v51) {
            goto LABEL_65;
          }
          unint64_t v62 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)
              + *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
          if (!v62 || v62 % 0x64) {
            goto LABEL_65;
          }
          uint64_t v85 = v38;
          long long v89 = 0u;
          long long v90 = 0u;
          long long v87 = 0u;
          long long v88 = 0u;
          uint64_t v63 = [*(id *)(*(void *)(a1 + 32) + 344) manifestsByDomainName];
          long long v53 = [v63 allValues];

          id v64 = [v53 countByEnumeratingWithState:&v87 objects:v95 count:16];
          if (v64)
          {
            id v65 = v64;
            uint64_t v66 = *(void *)v88;
            while (2)
            {
              for (uint64_t i = 0; i != v65; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v88 != v66) {
                  objc_enumerationMutation(v53);
                }
                uint64_t v68 = objc_msgSend(*(id *)(*((void *)&v87 + 1) + 8 * i), "fileUploadError", v77, v78, v79, v80);
                if (v68)
                {
                  uint64_t v69 = *(void *)(*(void *)(a1 + 56) + 8);
                  long long v70 = *(void **)(v69 + 40);
                  *(void *)(v69 + 40) = v68;

                  uint64_t v18 = 0;
                  goto LABEL_64;
                }
              }
              id v65 = [v53 countByEnumeratingWithState:&v87 objects:v95 count:16];
              if (v65) {
                continue;
              }
              break;
            }
          }
LABEL_64:

          long long v38 = v85;
LABEL_65:
          long long v36 = v81;
          goto LABEL_66;
        }
        long long v53 = MBGetDefaultLog();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          char v97 = v27;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Encryption key: %@", buf, 0xCu);
          goto LABEL_39;
        }
      }
      uint64_t v18 = 1;
      goto LABEL_64;
    }
  }
  uint64_t v18 = 0;
LABEL_4:

  return v18;
}

void sub_10008E7D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  uint64_t v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
      uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
      id v9 = [*(id *)(a1 + 32) count];
      *(_DWORD *)buf = 134219010;
      id v54 = v6;
      __int16 v55 = 2048;
      uint64_t v56 = v7;
      __int16 v57 = 2048;
      uint64_t v58 = v8;
      __int16 v59 = 2048;
      id v60 = v9;
      __int16 v61 = 2112;
      id v62 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "=cloud-backup= Finished uploading %llu files (%llu) and %llu deletes for %lu domains: %@", buf, 0x34u);
      uint64_t v10 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
      uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
      uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
      id v44 = [*(id *)(a1 + 32) count];
      id v45 = v3;
      uint64_t v42 = v11;
      uint64_t v43 = v12;
      id v41 = v10;
      _MBLog();
    }

    if (+[MBError isCKPartialFailureError:v3])
    {
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      uint64_t v13 = [v3 userInfo];
      id v14 = [v13 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
      id v15 = [v14 allValues];

      id v16 = [v15 countByEnumeratingWithState:&v48 objects:v52 count:16];
      if (!v16)
      {
LABEL_30:

        goto LABEL_31;
      }
      id v17 = v16;
      char v18 = 0;
      char v19 = 0;
      uint64_t v20 = *(void *)v49;
      do
      {
        for (uint64_t i = 0; i != v17; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v49 != v20) {
            objc_enumerationMutation(v15);
          }
          uint64_t v22 = *(void *)(*((void *)&v48 + 1) + 8 * i);
          if (+[MBError isCKError:withCode:](MBError, "isCKError:withCode:", v22, 25, v41, v42, v43, v44, v45))
          {
            if (v18 & 1) != 0 && (v19) {
              char v19 = 1;
            }
            else {
              char v19 = !+[MBError isAssetTooLargeError:v22];
            }
            char v18 = 1;
          }
        }
        id v17 = [v15 countByEnumeratingWithState:&v48 objects:v52 count:16];
      }
      while (v17);

      if ((v18 & 1) == 0) {
        goto LABEL_31;
      }
      unsigned int v23 = v19 & 1;
    }
    else
    {
      if (!+[MBError isCKError:v3 withCode:25])
      {
LABEL_31:
        *(unsigned char *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 0;
        long long v36 = objc_msgSend(*(id *)(a1 + 40), "retryStrategy", v41);
        unsigned int v37 = [v36 canRetryAfterError:v3];

        if (v37) {
          uint64_t v38 = *(void *)(a1 + 112);
        }
        else {
          uint64_t v38 = *(void *)(a1 + 120);
        }
        uint64_t v39 = *(void *)(v38 + 8);
        id v40 = v3;
        uint64_t v5 = *(NSObject **)(v39 + 40);
        *(void *)(v39 + 40) = v40;
        goto LABEL_35;
      }
      unsigned int v23 = !+[MBError isAssetTooLargeError:v3];
    }
    uint64_t v28 = MBGetDefaultLog();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      id v54 = v3;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "=cloud-backup= Resetting pending snapshot ID to clear quota after error: %{public}@", buf, 0xCu);
      id v41 = v3;
      _MBLog();
    }

    int v29 = [*(id *)(a1 + 40) device];
    [v29 clearPendingSnapshotAndRebuildFileChanges:1];

    unsigned __int8 v30 = [*(id *)(a1 + 40) device];
    uint64_t v31 = *(void *)(a1 + 48);
    id v47 = 0;
    LODWORD(v29) = [v30 saveWithOperationTracker:v31 error:&v47];
    id v32 = v47;
    if ((v29 & v23) == 1)
    {
      uint64_t v33 = *(void **)(a1 + 56);
      uint64_t v34 = *(void *)(a1 + 64);
      id v46 = v32;
      unsigned int v35 = [v33 resetCacheWithAccount:v34 error:&v46];
      id v15 = v46;

      if (v35) {
        MBExit(1);
      }
    }
    else
    {

      id v15 = v32;
    }
    goto LABEL_30;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
    uint64_t v25 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
    uint64_t v26 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
    id v27 = [*(id *)(a1 + 32) count];
    *(_DWORD *)buf = 134218752;
    id v54 = v24;
    __int16 v55 = 2048;
    uint64_t v56 = v25;
    __int16 v57 = 2048;
    uint64_t v58 = v26;
    __int16 v59 = 2048;
    id v60 = v27;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "=cloud-backup= Finished uploading %llu files (%llu) and %llu deletes for %lu domains", buf, 0x2Au);
    [*(id *)(a1 + 32) count];
    _MBLog();
  }
LABEL_35:

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
}

int64_t sub_10009284C(id a1, NSNumber *a2, NSNumber *a3)
{
  return [(NSNumber *)a3 compare:a2];
}

void sub_100092934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_100092EE0()
{
  uint64_t v0 = (objc_class *)objc_opt_class();
  id v5 = +[NSString stringWithFormat:@"%s.wifiQuality", class_getName(v0)];
  id v1 = (const char *)[v5 UTF8String];
  uint64_t v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v3 = dispatch_queue_create(v1, v2);
  id v4 = (void *)qword_1004823A0;
  qword_1004823A0 = (uint64_t)v3;
}

void sub_100092F88(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) wifiQuality];
  id v3 = [v2 count];

  if ((unint64_t)v3 >= 0x1E) {
    [*(id *)(*(void *)(a1 + 32) + 120) removeObjectAtIndex:0];
  }
  id v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = (void *)v4[15];
  id v7 = [v4 _serializedWiFiQualityMeasurementFromInterface:v5];
  [v6 addObject:v7];
}

void sub_100093020(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 120) insertObject:*(void *)(a1 + 40) atIndex:0];
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (void *)v2[15];
  id v4 = [v2 _serializedWiFiQualityMeasurementFromInterface:*(void *)(a1 + 48)];
  [v3 addObject:v4];

  [*(id *)(a1 + 48) invalidate];
  uint64_t v5 = [*(id *)(a1 + 32) wifiQualityGroup];
  dispatch_group_leave(v5);
}

void sub_100093E0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "MDM request to install restored apps failed: %{public}@", buf, 0xCu);
      _MBLog();
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100093FF0(uint64_t a1)
{
  atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 32) + 8));
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  id v69 = 0;
  id v3 = [(id)objc_opt_class() regularRestoreCoordinatorsAndReturnError:&v69];
  id v4 = v69;
  if (!v3)
  {
    uint64_t v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v74 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "IX: error enumerateCoordinatorsUsingBlock: %@", buf, 0xCu);
      id v49 = v4;
      _MBLog();
    }
  }
  long long v51 = v2;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  id obj = v3;
  id v6 = [obj countByEnumeratingWithState:&v65 objects:v72 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v66;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v66 != v8) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v65 + 1) + 8 * i);
        uint64_t v11 = objc_msgSend(v10, "bundleID", v49);
        if (v11)
        {
          if ([*(id *)(a1 + 32) shouldObserveCoordinatorForBundleID:v11])
          {
            [v51 setObject:v10 forKeyedSubscript:v11];
            goto LABEL_19;
          }
          uint64_t v12 = MBGetDefaultLog();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138412290;
            id v74 = v10;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "IX: InstallCoordinator %@ had a bundle ID associated with a different persona", buf, 0xCu);
            id v49 = v10;
            goto LABEL_17;
          }
        }
        else
        {
          uint64_t v12 = MBGetDefaultLog();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            id v74 = v10;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "IX: InstallCoordinator %@ had no bundle ID", buf, 0xCu);
            id v49 = v10;
LABEL_17:
            _MBLog();
          }
        }

LABEL_19:
      }
      id v7 = [obj countByEnumeratingWithState:&v65 objects:v72 count:16];
    }
    while (v7);
  }

  uint64_t v13 = MBGetDefaultLog();
  id v14 = v51;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    id v15 = [v51 count];
    *(_DWORD *)buf = 134217984;
    id v74 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "IX: Done registering install coordination observers for regular apps (%lu)", buf, 0xCu);
    id v49 = [v51 count];
    _MBLog();
  }

  id v52 = objc_alloc_init((Class)NSMutableArray);
  id v64 = v4;
  id v16 = [(id)objc_opt_class() demotedRestoreCoordinatorsAndReturnError:&v64];
  id v50 = v64;

  if (!v16)
  {
    id v17 = MBGetDefaultLog();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v74 = v50;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "IX: error (demoted) enumerateCoordinatorsUsingBlock: %@", buf, 0xCu);
      id v49 = v50;
      _MBLog();
    }
  }
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  id v54 = v16;
  id v18 = [v54 countByEnumeratingWithState:&v60 objects:v71 count:16];
  if (v18)
  {
    id v19 = v18;
    uint64_t v20 = *(void *)v61;
    do
    {
      for (j = 0; j != v19; j = (char *)j + 1)
      {
        if (*(void *)v61 != v20) {
          objc_enumerationMutation(v54);
        }
        uint64_t v22 = *(void **)(*((void *)&v60 + 1) + 8 * (void)j);
        unsigned int v23 = objc_msgSend(v22, "bundleID", v49);
        if (!v23)
        {
          uint64_t v26 = MBGetDefaultLog();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            id v74 = v22;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "IX: Demoted InstallCoordinator %@ had no bundle ID", buf, 0xCu);
            id v49 = v22;
            goto LABEL_41;
          }
LABEL_42:

          goto LABEL_43;
        }
        unsigned int v24 = [*(id *)(a1 + 32) shouldObserveCoordinatorForBundleID:v23];
        uint64_t v25 = MBGetDefaultLog();
        uint64_t v26 = v25;
        if (!v24)
        {
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138412290;
            id v74 = v22;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "IX: InstallCoordinator %@ had a demoted bundle ID associated with a different persona", buf, 0xCu);
            id v49 = v22;
LABEL_41:
            _MBLog();
          }
          goto LABEL_42;
        }
        if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          id v74 = v23;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "IX: Tracking demoted app %@", buf, 0xCu);
          id v49 = v23;
          _MBLog();
        }

        [v51 setObject:v22 forKeyedSubscript:v23];
        [v52 addObject:v23];
LABEL_43:
      }
      id v19 = [v54 countByEnumeratingWithState:&v60 objects:v71 count:16];
    }
    while (v19);
  }

  id v27 = MBGetDefaultLog();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    id v28 = [v54 count];
    *(_DWORD *)buf = 134217984;
    id v74 = v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "IX: Done registering install coordination observers for demoted apps (%lu)", buf, 0xCu);
    [v54 count];
    _MBLog();
  }

  int v29 = MBGetDefaultLog();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    id v30 = [v51 count];
    *(_DWORD *)buf = 134217984;
    id v74 = v30;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "IX: Tracking %lu install coordinators", buf, 0xCu);
    [v51 count];
    _MBLog();
  }

  id v31 = [v51 count];
  id v32 = *(id **)(a1 + 32);
  if (v31)
  {
    objc_storeStrong(v32 + 3, v51);
    uint64_t v33 = [*(id *)(a1 + 32) account];
    uint64_t v34 = [v33 persona];
    unsigned int v35 = [v34 isDataSeparatedPersona];

    if (v35) {
      [*(id *)(a1 + 32) _requestMDMAppInstallation];
    }
    id v36 = objc_alloc_init((Class)ASDCompleteCoordinatorsRequest);
    [v36 startWithCompletionHandler:&stru_100411AE8];
    id v37 = [v52 count];
    uint64_t v38 = MBGetDefaultLog();
    uint64_t v39 = v38;
    if (v37)
    {
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        id v40 = [v52 count];
        *(_DWORD *)buf = 134217984;
        id v74 = v40;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "IX: Kicking off data restores for %lu demoted apps", buf, 0xCu);
        [v52 count];
        _MBLog();
      }

      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      uint64_t v39 = v52;
      id v41 = [v39 countByEnumeratingWithState:&v56 objects:v70 count:16];
      if (v41)
      {
        id v42 = v41;
        uint64_t v43 = *(void *)v57;
        do
        {
          for (k = 0; k != v42; k = (char *)k + 1)
          {
            if (*(void *)v57 != v43) {
              objc_enumerationMutation(v39);
            }
            id v45 = *(void **)(*((void *)&v56 + 1) + 8 * (void)k);
            id v46 = MBGetDefaultLog();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 138412290;
              id v74 = v45;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "IX: Queueing up data restore for demoted app %@", buf, 0xCu);
              _MBLog();
            }

            uint64_t v47 = *(void *)(a1 + 32);
            long long v48 = *(NSObject **)(v47 + 32);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_100094B08;
            block[3] = &unk_1004110B0;
            block[4] = v47;
            block[5] = v45;
            dispatch_async(v48, block);
          }
          id v42 = [v39 countByEnumeratingWithState:&v56 objects:v70 count:16];
        }
        while (v42);
        id v14 = v51;
      }
    }
    else if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_INFO, "IX: No demoted apps found in backup", buf, 2u);
      _MBLog();
    }

    atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 32) + 8));
  }
  else
  {
    [v32 _finishAppDataRestore];
  }
}

void sub_1000949EC(id a1, BOOL a2, NSError *a3)
{
  BOOL v3 = a2;
  id v4 = a3;
  uint64_t v5 = MBGetDefaultLog();
  id v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "IX: Done configuring install coordinators", buf, 2u);
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "IX: Done configuring install coordinators but couldn't signal appstored: %@", buf, 0xCu);
    goto LABEL_6;
  }
}

void sub_100094B08(uint64_t a1)
{
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40), 0xFFFFFFFFFFFFFFFFLL);
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v10 = 0;
  unsigned int v4 = [v2 _restoreApplicationWithBundleID:v3 failed:0 context:v3 error:&v10];
  id v5 = v10;
  id v6 = MBGetDefaultLog();
  id v7 = v6;
  if (v4)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      uint64_t v12 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "IX: Set up restore of user data for demoted app with bundleID %@", buf, 0xCu);
      _MBLog();
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412546;
      uint64_t v12 = v9;
      __int16 v13 = 2112;
      id v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "IX: Could not set up restore of user data for demoted app with bundleID %@ error %@", buf, 0x16u);
      _MBLog();
    }

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40));
  }
}

void sub_100094D54(uint64_t a1)
{
  uint64_t v3 = [*(id *)(a1 + 32) account];
  unsigned int v4 = MBGetDefaultLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [v3 accountIdentifier];
    id v6 = [v3 persona];
    id v7 = [v6 personaIdentifier];
    int v8 = *(unsigned __int8 *)(a1 + 40);
    *(_DWORD *)buf = 138543874;
    id v14 = v5;
    __int16 v15 = 2114;
    id v16 = v7;
    __int16 v17 = 1024;
    int v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished restoring all apps for account %{public}@(%{public}@ cancelled:%d", buf, 0x1Cu);

    uint64_t v9 = [v3 accountIdentifier];
    id v10 = [v3 persona];
    uint64_t v12 = [v10 personaIdentifier];
    _MBLog();
  }
  uint64_t v11 = [*(id *)(a1 + 32) delegate];
  [v11 didFinishAppRestoresWithAccount:v3 cancelled:*(unsigned __int8 *)(a1 + 40)];
}

void sub_1000950B0(uint64_t a1)
{
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40), 0xFFFFFFFFFFFFFFFFLL);
  id v2 = [*(id *)(a1 + 40) bundleID];
  uint64_t v3 = *(void **)(a1 + 32);
  id v8 = 0;
  unsigned int v4 = [v3 _restoreApplicationWithBundleID:v2 failed:0 context:v2 error:&v8];
  id v5 = v8;
  id v6 = MBGetDefaultLog();
  id v7 = v6;
  if (v4)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      id v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "IX: Set up restore of user data for %@ because the app asset started downloading", buf, 0xCu);
      _MBLog();
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      id v10 = v2;
      __int16 v11 = 2112;
      id v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "IX: Could not set up restore of user data for %@ when the app asset started downloading error %@", buf, 0x16u);
      _MBLog();
    }

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40));
  }
}

void sub_100095570(uint64_t a1)
{
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40), 0xFFFFFFFFFFFFFFFFLL);
  id v2 = MBGetDefaultLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "IX: Coordinator was canceled but hasn't been promised app data yet. Starting to restore it", buf, 2u);
    _MBLog();
  }

  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  id v11 = 0;
  unsigned int v5 = [v3 _restoreApplicationWithBundleID:v4 failed:0 context:v4 error:&v11];
  id v6 = v11;
  id v7 = MBGetDefaultLog();
  id v8 = v7;
  if (v5)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      uint64_t v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "IX: Set up restore of user data for %@ because the coordinator was canceled", buf, 0xCu);
      _MBLog();
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412546;
      uint64_t v13 = v10;
      __int16 v14 = 2112;
      id v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "IX: Could not set up restore of user data for %@ when the coordinator was canceled. error %@ ", buf, 0x16u);
      _MBLog();
    }

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40));
  }
}

void sub_100096324(uint64_t a1)
{
  if (![*(id *)(*(void *)(a1 + 32) + 24) count])
  {
    int v18 = *(void **)(a1 + 32);
    [v18 _finishAppDataRestore];
    return;
  }
  char v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id obj = [*(id *)(*(void *)(a1 + 32) + 24) allKeys];
  id v2 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (!v2) {
    goto LABEL_29;
  }
  id v3 = v2;
  uint64_t v4 = 0;
  uint64_t v21 = *(void *)v23;
  uint64_t v20 = IXErrorDomain;
  do
  {
    for (uint64_t i = 0; i != v3; uint64_t i = (char *)i + 1)
    {
      id v6 = v4;
      if (*(void *)v23 != v21) {
        objc_enumerationMutation(obj);
      }
      id v7 = *(void **)(*((void *)&v22 + 1) + 8 * i);
      id v8 = [*(id *)(*(void *)(a1 + 32) + 24) objectForKeyedSubscript:v7];
      uint64_t v9 = [v8 userDataPromiseWithError:0];
      char v26 = 0;
      uint64_t v4 = [v8 userDataRestoreShouldBegin:&v26];

      if (v4)
      {
        uint64_t v10 = [v4 domain];
        if ([v10 isEqualToString:v20]) {
          BOOL v11 = [v4 code] == (id)6;
        }
        else {
          BOOL v11 = 0;
        }

        if (!v9)
        {
LABEL_11:
          if (v26) {
            int v12 = 1;
          }
          else {
            int v12 = v11;
          }
          if (v12 != 1) {
            goto LABEL_26;
          }
LABEL_21:
          __int16 v14 = [*(id *)(a1 + 32) delegate];
          [v9 percentComplete];
          unsigned __int8 v15 = objc_msgSend(v14, "isEngineInProgressForBundleID:percentComplete:", v7);

          if ((v15 & 1) == 0)
          {
            uint64_t v16 = 48;
            if (v11)
            {
              uint64_t v16 = 40;
              __int16 v17 = v8;
            }
            else
            {
              __int16 v17 = v7;
            }
            [*(id *)(a1 + v16) addObject:v17];
          }
          goto LABEL_26;
        }
      }
      else
      {
        BOOL v11 = 0;
        if (!v9) {
          goto LABEL_11;
        }
      }
      unsigned int v13 = [v9 isComplete] ^ 1;
      if (v26) {
        unsigned int v13 = 1;
      }
      if ((v13 | v11)) {
        goto LABEL_21;
      }
LABEL_26:
    }
    id v3 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
  }
  while (v3);

LABEL_29:
}

void sub_1000965C8(uint64_t a1)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        objc_msgSend(*(id *)(a1 + 40), "stopTrackingCoordinator:withSuccess:", *(void *)(*((void *)&v7 + 1) + 8 * (void)v6), 0, (void)v7);
        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }
    while (v4);
  }
}

void sub_1000966C0(uint64_t a1)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v13 objects:v19 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v13 + 1) + 8 * i);
        long long v8 = MBGetDefaultLog();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v18 = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "IX: Coordinator for %@ needs to be restarted because it hit a soft failure after backupd promised it data. Queuing restore", buf, 0xCu);
          _MBLog();
        }

        uint64_t v9 = *(void *)(a1 + 40);
        long long v10 = *(NSObject **)(v9 + 32);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10009689C;
        block[3] = &unk_1004110B0;
        block[4] = v9;
        block[5] = v7;
        dispatch_async(v10, block);
      }
      id v4 = [v2 countByEnumeratingWithState:&v13 objects:v19 count:16];
    }
    while (v4);
  }
}

void sub_10009689C(uint64_t a1)
{
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40), 0xFFFFFFFFFFFFFFFFLL);
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v13 = 0;
  unsigned int v4 = [v2 _restoreApplicationWithBundleID:v3 failed:0 context:v3 error:&v13];
  id v5 = v13;
  if (!v4)
  {
    unsigned int v8 = +[MBError isError:v5 withCode:3];
    uint64_t v9 = MBGetDefaultLog();
    long long v10 = v9;
    if (v8)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        uint64_t v11 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 138412290;
        uint64_t v15 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "IX: Restore already in progress for %@", buf, 0xCu);
LABEL_10:
        _MBLog();
      }
    }
    else if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412546;
      uint64_t v15 = v12;
      __int16 v16 = 2112;
      id v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "IX: Could not restart restore of user data for %@: %@", buf, 0x16u);
      goto LABEL_10;
    }

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 32) + 40));
    goto LABEL_12;
  }
  id v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    uint64_t v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "IX: Restarted restore of user data for %@", buf, 0xCu);
    _MBLog();
  }

LABEL_12:
}

void sub_100096C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100096C20(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100096C30(uint64_t a1)
{
}

void sub_100096C38(void *a1)
{
  uint64_t v2 = [*(id *)(a1[4] + 24) objectForKeyedSubscript:a1[5]];
  uint64_t v3 = *(void *)(a1[6] + 8);
  unsigned int v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  if (*(void *)(*(void *)(a1[6] + 8) + 40))
  {
    id v5 = (void *)a1[4];
    _objc_msgSend(v5, "_setUpDataPromiseForCoordinator:");
  }
  else
  {
    id v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = a1[5];
      *(_DWORD *)buf = 138412290;
      uint64_t v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "IX: Can't restore data for %@ because it doesn't have an InstallCoordinator", buf, 0xCu);
      _MBLog();
    }
  }
}

void sub_100097000(uint64_t a1)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  id obj = [*(id *)(*(void *)(a1 + 32) + 24) allKeys];
  id v2 = [obj countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v2)
  {
    id v3 = v2;
    uint64_t v4 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v3; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v4) {
          objc_enumerationMutation(obj);
        }
        uint64_t v6 = *(void *)(*((void *)&v10 + 1) + 8 * i);
        uint64_t v7 = [*(id *)(*(void *)(a1 + 32) + 24) objectForKeyedSubscript:v6];
        [*(id *)(a1 + 32) stopTrackingCoordinator:v7 withSuccess:0];
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 3221225472;
        v9[2] = sub_10009719C;
        _OWORD v9[3] = &unk_100411060;
        v9[4] = v6;
        +[IXAppInstallCoordinator uninstallAppWithBundleID:v6 requestUserConfirmation:0 completion:v9];
      }
      id v3 = [obj countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v3);
  }
}

void sub_10009719C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = MBGetDefaultLog();
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      uint64_t v9 = v6;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "IX: Couldn't uninstall app %@: %@", buf, 0x16u);
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "IX: Uninstalled app %@ after restore cancellation", buf, 0xCu);
    goto LABEL_6;
  }
}

void sub_100097650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_100097688(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  uint64_t v3 = *(unsigned __int8 *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v6 = [*(id *)(a1 + 32) account];
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v7 + 40);
  LOBYTE(v3) = [v2 restoreApplicationWithBundleID:v5 failed:v3 qos:&off_100439ED0 context:v4 account:v6 error:&obj];
  objc_storeStrong((id *)(v7 + 40), obj);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v3;
}

void sub_100099460(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000994F8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100099590(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100099EF4(_Unwind_Exception *a1)
{
}

uint64_t sub_100099F88(uint64_t a1)
{
  return (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16))(0.0);
}

void sub_100099FA4(uint64_t a1, double a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10009A03C;
  v4[3] = &unk_100411BB0;
  uint64_t v3 = *(NSObject **)(a1 + 32);
  id v5 = *(id *)(a1 + 40);
  double v6 = a2;
  dispatch_async(v3, v4);
}

uint64_t sub_10009A03C(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, void, double))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), 1, 0, *(double *)(a1 + 40));
}

uint64_t sub_10009A05C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, double))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 48), *(void *)(a1 + 32), 1.0);
}

void sub_10009B430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&STACK[0x310], 8);
  _Block_object_dispose(&STACK[0x330], 8);
  _Block_object_dispose((const void *)(v67 - 192), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10009B4F8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10009B508(uint64_t a1)
{
}

void sub_10009B510(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = [v8 count];
  id v11 = [v9 count];
  long long v12 = MBGetDefaultLog();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    long long v13 = [v7 recordID];
    long long v14 = [v7 domainName];
    *(_DWORD *)buf = 134218754;
    id v25 = v10;
    __int16 v26 = 2048;
    id v27 = v11;
    __int16 v28 = 2114;
    int v29 = v13;
    __int16 v30 = 2114;
    id v31 = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Fetched %lu file refs and %lu placeholder refs for manifest %{public}@(%{public}@)", buf, 0x2Au);

    uint64_t v15 = [v7 recordID];
    uint64_t v21 = [v7 domainName];
    _MBLog();
  }
  id v16 = *(id *)(a1 + 32);
  objc_sync_enter(v16);
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) += v10;
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v11;
  objc_sync_exit(v16);

  if (v10)
  {
    id v17 = *(void **)(a1 + 40);
    uint64_t v18 = *(void *)(*(void *)(a1 + 64) + 8);
    id obj = *(id *)(v18 + 40);
    [v17 addFileReferences:v8 forManifest:v7 error:&obj];
    objc_storeStrong((id *)(v18 + 40), obj);
  }
  if (v11)
  {
    id v19 = *(void **)(a1 + 40);
    uint64_t v20 = *(void *)(*(void *)(a1 + 64) + 8);
    id v22 = *(id *)(v20 + 40);
    [v19 addPlaceholderReferences:v9 forManifest:v7 error:&v22];
    objc_storeStrong((id *)(v20 + 40), v22);
  }
}

void sub_10009B750(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) watchdog];
  [v4 resume];

  id v21 = 0;
  unsigned __int8 v5 = [v3 saveToCacheWithError:&v21];
  id v6 = v21;
  id v7 = v21;
  if ((v5 & 1) == 0)
  {
    id v8 = *(id *)(a1 + 32);
    objc_sync_enter(v8);
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v11 = *(void *)(v9 + 40);
    id v10 = (id *)(v9 + 40);
    if (!v11)
    {
      objc_storeStrong(v10, v6);
      long long v12 = MBGetDefaultLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        long long v13 = v12;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          long long v14 = [v3 recordID];
          *(_DWORD *)buf = 138543618;
          uint64_t v23 = (uint64_t)v14;
          __int16 v24 = 2114;
          id v25 = v7;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to save manifest record %{public}@ to cache: %{public}@", buf, 0x16u);
        }
        uint64_t v20 = [v3 recordID];
        _MBLog();
      }
    }
    objc_sync_exit(v8);
  }
  id v15 = *(id *)(a1 + 32);
  objc_sync_enter(v15);
  uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v17 = *(void *)(v16 + 24) + 1;
  *(void *)(v16 + 24) = v17;
  objc_sync_exit(v15);

  if (__ROR8__(0x8F5C28F5C28F5C29 * v17, 2) <= 0x28F5C28F5C28F5CuLL)
  {
    uint64_t v18 = MBGetDefaultLog();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      id v19 = *(void **)(a1 + 40);
      *(_DWORD *)buf = 134218242;
      uint64_t v23 = v17;
      __int16 v24 = 2114;
      id v25 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Fetched %lu manifest records for snapshot %{public}@", buf, 0x16u);
      _MBLog();
    }
  }
}

void sub_10009B9CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009B9F0(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a2);
    unsigned __int8 v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      uint64_t v13 = v6;
      __int16 v14 = 2114;
      id v15 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to fetch all manifests for snapshot %{public}@: %{public}@", buf, 0x16u);
      _MBLog();
    }
  }
  id v7 = MBGetDefaultLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
    uint64_t v9 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
    uint64_t v11 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 134218754;
    uint64_t v13 = v8;
    __int16 v14 = 2048;
    id v15 = v9;
    __int16 v16 = 2048;
    uint64_t v17 = v10;
    __int16 v18 = 2114;
    uint64_t v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetched a total of %lu manifest records, %lu placeholder refs, %lu file refs for snapshot %{public}@", buf, 0x2Au);
    _MBLog();
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_10009BBCC(void *a1, void *a2)
{
  id v4 = a2;
  objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), a2);
  unsigned __int8 v5 = MBGetDefaultLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = a1[4];
    uint64_t v7 = a1[5];
    uint64_t v8 = *(void *)(*(void *)(a1[7] + 8) + 24);
    *(_DWORD *)buf = 138544130;
    uint64_t v10 = v6;
    __int16 v11 = 2114;
    uint64_t v12 = v7;
    __int16 v13 = 2048;
    uint64_t v14 = v8;
    __int16 v15 = 2114;
    id v16 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ query for snapshot %{public}@ updated the cursor (%lu): %{public}@", buf, 0x2Au);
    _MBLog();
  }
}

void sub_10009BCF8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (MBIsInternalInstall()
    && *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) >= *(void *)(a1 + 104))
  {
    uint64_t v39 = MBGetDefaultLog();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = *(void *)(a1 + 32);
      id v41 = *(void **)(a1 + 40);
      uint64_t v42 = *(void *)(a1 + 104);
      *(_DWORD *)buf = 138543874;
      uint64_t v50 = v40;
      __int16 v51 = 2114;
      id v52 = v41;
      __int16 v53 = 2048;
      uint64_t v54 = v42;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Force cancelling %{public}@ query for snapshot %{public}@ after fetching %llu records", buf, 0x20u);
      _MBLog();
    }

    uint64_t v43 = *(void **)(a1 + 48);
    id v14 = +[MBError errorWithCode:202, @"Backup canceled (simulated for %@ after fetching %llu records)", *(void *)(a1 + 32), *(void *)(a1 + 104) format];
    [v43 cancelWithError:v14];
  }
  else
  {
    id v4 = *(void **)(a1 + 56);
    id v48 = 0;
    unsigned __int8 v5 = [v4 domainNameForFileRecord:v3 error:&v48];
    id v6 = v48;
    if (v5)
    {
      uint64_t v7 = +[MBCKFile fileWithRecord:v3 cache:*(void *)(a1 + 64) snapshot:*(void *)(a1 + 72) domainName:v5];
      uint64_t v8 = MBGetDefaultLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = [v7 recordIDString];
        uint64_t v10 = [v7 domainName];
        *(_DWORD *)buf = 138412546;
        uint64_t v50 = (uint64_t)v9;
        __int16 v51 = 2112;
        id v52 = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Fetched %@ (%@)", buf, 0x16u);

        __int16 v11 = [v7 recordIDString];
        [v7 domainName];
        v46 = id v44 = v11;
        _MBLog();
      }
      id v47 = v6;
      unsigned __int8 v12 = [v7 saveToCacheWithError:&v47];
      id v13 = v47;
      id v14 = v47;

      if ((v12 & 1) == 0)
      {
        uint64_t v15 = *(void *)(*(void *)(a1 + 88) + 8);
        uint64_t v17 = *(void *)(v15 + 40);
        id v16 = (id *)(v15 + 40);
        if (!v17)
        {
          objc_storeStrong(v16, v13);
          __int16 v18 = MBGetDefaultLog();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            uint64_t v19 = [v3 recordID];
            uint64_t v20 = [v19 recordName];
            *(_DWORD *)buf = 138543618;
            uint64_t v50 = (uint64_t)v20;
            __int16 v51 = 2114;
            id v52 = v14;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to save file record %{public}@ to cache: %{public}@", buf, 0x16u);

            id v21 = [v3 recordID];
            id v44 = [v21 recordName];
            id v46 = v14;
            _MBLog();
          }
        }
      }
      id v22 = objc_msgSend(v3, "pluginFields", v44, v46);

      if (v22)
      {
        uint64_t v23 = [v3 pluginFields];
        __int16 v24 = [v23 objectForKeyedSubscript:@"progress"];
        [v24 doubleValue];
        double v26 = v25;

        double v27 = v26 / 100.0;
        __int16 v28 = [*(id *)(a1 + 48) progressModel];
        [v28 updatingProgress:0 previousProgress:v27 size:*(double *)(*(void *)(*(void *)(a1 + 96) + 8) + 24)];

        *(double *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = v27;
      }
      int v29 = [*(id *)(a1 + 48) watchdog];
      [v29 resume];

      uint64_t v30 = *(void *)(*(void *)(a1 + 80) + 8);
      uint64_t v31 = *(void *)(v30 + 24) + 1;
      *(void *)(v30 + 24) = v31;
      if (__ROR8__(0x1CAC083126E978D5 * v31, 3) <= 0x4189374BC6A7EFuLL)
      {
        id v32 = MBGetDefaultLog();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = *(void **)(a1 + 40);
          *(_DWORD *)buf = 134218242;
          uint64_t v50 = v31;
          __int16 v51 = 2114;
          id v52 = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Fetched %lu file records for snapshot %{public}@", buf, 0x16u);
          _MBLog();
        }
      }
    }
    else
    {
      uint64_t v34 = MBGetDefaultLog();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
      {
        unsigned int v35 = [v3 recordID];
        id v36 = [v35 recordName];
        *(_DWORD *)buf = 138543618;
        uint64_t v50 = (uint64_t)v36;
        __int16 v51 = 2112;
        id v52 = v6;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, "Failed to retrieve domain name for file ID: %{public}@ %@", buf, 0x16u);

        id v37 = [v3 recordID];
        id v45 = [v37 recordName];
        _MBLog();
      }
      uint64_t v38 = *(void *)(*(void *)(a1 + 88) + 8);
      id v14 = v6;
      uint64_t v7 = *(void **)(v38 + 40);
      *(void *)(v38 + 40) = v14;
    }
  }
}

void sub_10009C2C4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = MBGetDefaultLog();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138543874;
      uint64_t v24 = v9;
      __int16 v25 = 2114;
      uint64_t v26 = v10;
      __int16 v27 = 2112;
      id v28 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}@ query for snapshot %{public}@ failed: %@", buf, 0x20u);
      _MBLog();
    }

    uint64_t v11 = *(void *)(*(void *)(a1 + 64) + 8);
    id v12 = v6;
    id v13 = *(NSObject **)(v11 + 40);
    *(void *)(v11 + 40) = v12;
  }
  else
  {
    if (v8)
    {
      uint64_t v14 = *(void *)(a1 + 32);
      uint64_t v15 = *(void *)(a1 + 40);
      id v16 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
      *(_DWORD *)buf = 138544130;
      uint64_t v24 = v14;
      __int16 v25 = 2114;
      uint64_t v26 = v15;
      __int16 v27 = 2048;
      id v28 = v16;
      __int16 v29 = 2114;
      id v30 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}@ query for snapshot %{public}@ updated the query cursor (%lu): %{public}@", buf, 0x2Au);
      _MBLog();
    }

    id v13 = MBGetDefaultLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = *(void *)(a1 + 32);
      uint64_t v18 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138543618;
      uint64_t v24 = v17;
      __int16 v25 = 2114;
      uint64_t v26 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}@ query for snapshot %{public}@ completed", buf, 0x16u);
      _MBLog();
    }
  }

  uint64_t v19 = MBGetDefaultLog();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
    uint64_t v21 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 134218242;
    uint64_t v24 = v20;
    __int16 v25 = 2114;
    uint64_t v26 = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Fetched a total of %lu file records for snapshot %{public}@", buf, 0x16u);
    _MBLog();
  }

  id v22 = [*(id *)(a1 + 48) progressModel];
  [v22 updatingProgress:0 previousProgress:1.0 size:*(double *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)];

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
}

void sub_10009CF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a71, 8);
  _Unwind_Resume(a1);
}

void sub_10009CF60(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) watchdog];
  [v1 resume];
}

void sub_10009CFA4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_10009EC08(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) count];
    *(_DWORD *)buf = 134218242;
    id v10 = v5;
    __int16 v11 = 2114;
    id v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Found cached snapshot (%lu): %{public}@", buf, 0x16u);
    [*(id *)(a1 + 32) count];
    _MBLog();
  }

  id v6 = *(void **)(a1 + 32);
  uint64_t v7 = [v3 snapshotID];
  [v6 addObject:v7];

  objc_msgSend(*(id *)(a1 + 40), "setCachedSnapshotCount:", (char *)objc_msgSend(*(id *)(a1 + 40), "cachedSnapshotCount") + 1);
  return 1;
}

uint64_t sub_10009ED34(id *a1)
{
  id v2 = +[NSDate date];
  [v2 timeIntervalSinceReferenceDate];
  double v4 = v3;

  id v5 = [a1[4] removeAllFileChanges];
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id v6 = a1[5];
  id v7 = [v6 countByEnumeratingWithState:&v31 objects:v37 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v32;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v32 != v9) {
          objc_enumerationMutation(v6);
        }
        __int16 v11 = *(void **)(*((void *)&v31 + 1) + 8 * i);
        id v12 = [a1[4] addPendingSnapshot:v11];
        id v13 = [a1[4] commitSnapshot:v11];
        id v14 = a1[4];
        uint64_t v15 = [v11 snapshotID];
        id v16 = [v14 addSnapshotIntoFileChanges:v15];
      }
      id v8 = [v6 countByEnumeratingWithState:&v31 objects:v37 count:16];
    }
    while (v8);
  }

  id v17 = [a1[4] removeDeletedFileChanges];
  if ([a1[6] isBackupEngine])
  {
    uint64_t v18 = [a1[7] pendingSnapshotRecordID];

    if (v18)
    {
      uint64_t v19 = MBGetDefaultLog();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = [a1[7] pendingSnapshotRecordID];
        *(_DWORD *)buf = 138543362;
        double v36 = *(double *)&v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Adding pending snapshot %{public}@ into FileChanges table", buf, 0xCu);

        id v30 = [a1[7] pendingSnapshotRecordID];
        _MBLog();
      }
      id v21 = a1[4];
      id v22 = [a1[7] pendingSnapshotRecordID];
      id v23 = [v21 addSnapshotIntoFileChanges:v22];
    }
  }
  id v24 = objc_msgSend(a1[4], "removeAllOrphanedItems", v30);
  +[NSDate timeIntervalSinceReferenceDate];
  double v26 = v25 - v4;
  __int16 v27 = MBGetDefaultLog();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    double v36 = v26;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "FileChanges table recreated in %0.3fs", buf, 0xCu);
    _MBLog();
  }

  id v28 = +[NSNumber numberWithDouble:v26];
  [*((id *)a1[6] + 28) setObject:v28 forKeyedSubscript:@"CacheFileChangesRebuildTime"];

  return 1;
}

void sub_10009F898(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id MBDomainHMACForDomainName(uint64_t a1, uint64_t a2)
{
  id v2 = +[MBDigestSHA1 sha1HmacForString:a1 key:a2];
  double v3 = [v2 base64EncodedStringWithOptions:0];

  return v3;
}

uint64_t sub_1000A1CEC(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_1000A1D10(uint64_t a1, void *a2)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 120);
  id v3 = a2;
  double v4 = [v3 snapshotID];
  [v2 setValue:v3 forKey:v4];

  return 1;
}

void sub_1000A2354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    if (!v29) {
      JUMPOUT(0x1000A22BCLL);
    }
    JUMPOUT(0x1000A22ACLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A23D8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000A23E8(uint64_t a1)
{
}

uint64_t sub_1000A23F0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) cache];
  id v3 = [v2 addPendingSnapshot:*(void *)(a1 + 40)];

  double v4 = [*(id *)(a1 + 32) cache];
  id v5 = [v4 commitSnapshot:*(void *)(a1 + 40)];

  id v6 = objc_alloc_init((Class)NSMutableDictionary);
  id v7 = [*(id *)(a1 + 32) cache];
  uint64_t v8 = *(void *)(a1 + 48);
  v205[0] = _NSConcreteStackBlock;
  v205[1] = 3221225472;
  v205[2] = sub_1000A3B14;
  v205[3] = &unk_100411750;
  id v9 = v6;
  id v206 = v9;
  uint64_t v10 = [v7 enumerateManifestsForSnapshot:v8 foundManifest:v205];
  uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 8);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  if (!*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
  {
    id v18 = objc_alloc((Class)NSMutableSet);
    uint64_t v19 = [v9 allKeys];
    id v13 = [v18 initWithArray:v19];

    id v20 = objc_alloc_init((Class)NSMutableDictionary);
    id v21 = [*(id *)(a1 + 32) cache];
    uint64_t v22 = *(void *)(a1 + 56);
    v203[0] = _NSConcreteStackBlock;
    v203[1] = 3221225472;
    v203[2] = sub_1000A3B6C;
    v203[3] = &unk_100411750;
    id v16 = v20;
    id v204 = v16;
    uint64_t v23 = [v21 enumerateManifestsForSnapshot:v22 foundManifest:v203];
    uint64_t v24 = *(void *)(*(void *)(a1 + 80) + 8);
    double v25 = *(void **)(v24 + 40);
    *(void *)(v24 + 40) = v23;

    if (!*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
    {
      id v30 = objc_alloc((Class)NSMutableSet);
      id v175 = v16;
      long long v31 = [v16 allKeys];
      long long v32 = [v30 initWithArray:v31];

      char v168 = v13;
      id v33 = [objc_alloc((Class)NSMutableSet) initWithSet:v13];
      char v169 = v32;
      [v33 minusSet:v32];
      long long v201 = 0u;
      long long v202 = 0u;
      long long v199 = 0u;
      long long v200 = 0u;
      uint64_t v29 = v33;
      id v34 = [v29 countByEnumeratingWithState:&v199 objects:v217 count:16];
      if (v34)
      {
        id v35 = v34;
        uint64_t v36 = *(void *)v200;
        do
        {
          for (uint64_t i = 0; i != v35; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v200 != v36) {
              objc_enumerationMutation(v29);
            }
            uint64_t v38 = *(void **)(*((void *)&v199 + 1) + 8 * i);
            uint64_t v39 = [*(id *)(a1 + 32) cache];
            uint64_t v40 = [v39 moveManifest:v38 toSnapshot:*(void *)(a1 + 64)];
            uint64_t v41 = *(void *)(*(void *)(a1 + 80) + 8);
            uint64_t v42 = *(void **)(v41 + 40);
            *(void *)(v41 + 40) = v40;

            if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
            {
              __int16 v55 = MBGetDefaultLog();
              if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
              {
                uint64_t v94 = *(void **)(a1 + 64);
                char v95 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
                *(_DWORD *)buf = 138412802;
                id v212 = v38;
                __int16 v213 = 2112;
                char v214 = v94;
                __int16 v215 = 2112;
                char v216 = v95;
                _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Unable to move manifest: %@ to snapshot: %@: %@", buf, 0x20u);
                _MBLog();
              }
              uint64_t v17 = 0;
              id v44 = v29;
              goto LABEL_48;
            }
          }
          id v35 = [v29 countByEnumeratingWithState:&v199 objects:v217 count:16];
        }
        while (v35);
      }

      id v43 = [objc_alloc((Class)NSMutableSet) initWithSet:v169];
      [v43 minusSet:v168];
      long long v197 = 0u;
      long long v198 = 0u;
      long long v195 = 0u;
      long long v196 = 0u;
      id v44 = v43;
      id v45 = [v44 countByEnumeratingWithState:&v195 objects:v210 count:16];
      if (!v45)
      {
LABEL_24:

        id v13 = v168;
        id v54 = [objc_alloc((Class)NSMutableSet) initWithSet:v168];
        double v26 = v169;
        [v54 intersectSet:v169];
        long long v193 = 0u;
        long long v194 = 0u;
        long long v191 = 0u;
        long long v192 = 0u;
        __int16 v55 = v54;
        id v16 = v175;
        char v173 = v44;
        char v174 = v29;
        id v165 = [v55 countByEnumeratingWithState:&v191 objects:v209 count:16];
        if (!v165) {
          goto LABEL_38;
        }
        id v170 = *(id *)v192;
        uint64_t v162 = v55;
        while (1)
        {
          long long v56 = 0;
          do
          {
            if (*(id *)v192 != v170) {
              objc_enumerationMutation(v55);
            }
            uint64_t v57 = *(void *)(*((void *)&v191 + 1) + 8 * (void)v56);
            id v58 = [objc_alloc((Class)NSString) initWithFormat:@"%@:%@", *(void *)(a1 + 64), v57];
            id v59 = v9;
            long long v60 = [v9 valueForKey:v57];
            long long v61 = [v16 valueForKey:v57];
            long long v62 = MBGetDefaultLog();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 138412290;
              id v212 = v58;
              _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_INFO, "Merging into %@", buf, 0xCu);
              id v156 = v58;
              _MBLog();
            }

            id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 96));
            unsigned int v64 = [WeakRetained isBackupEngine];

            if (v64)
            {
              id v65 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 96));
              [v65 resumeWatchdogIfNeeded];
            }
            long long v66 = objc_msgSend(*(id *)(a1 + 32), "cache", v156);
            uint64_t v67 = [v60 manifestID];
            long long v68 = [v61 manifestID];
            uint64_t v69 = [v66 mergeManifest:v67 withNewerManifest:v68 outputManifest:v58 mergeDeletions:*(unsigned __int8 *)(a1 + 88)];
            uint64_t v70 = *(void *)(*(void *)(a1 + 80) + 8);
            unsigned int v71 = *(void **)(v70 + 40);
            *(void *)(v70 + 40) = v69;

            if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
            {
              __int16 v100 = MBGetDefaultLog();
              if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
              {
                uint64_t v101 = [v60 manifestID];
                __int16 v102 = [v61 manifestID];
                uint64_t v103 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
                *(_DWORD *)buf = 138412802;
                id v212 = v101;
                __int16 v213 = 2112;
                char v214 = v102;
                __int16 v215 = 2112;
                char v216 = v103;
                _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "Unable to merge manifest: %@ %@ %@", buf, 0x20u);

                uint64_t v104 = [v60 manifestID];
                uint64_t v159 = [v61 manifestID];
                _MBLog();

                goto LABEL_62;
              }
LABEL_63:
              id v13 = v168;
LABEL_64:
              id v44 = v173;

              __int16 v55 = v162;
              uint64_t v17 = 0;
              id v9 = v59;
LABEL_49:
              id v16 = v175;
              double v26 = v169;
              goto LABEL_50;
            }
            long long v72 = [*(id *)(a1 + 32) cache];
            uint64_t v73 = [v72 removeManifestAndFiles:v60];
            uint64_t v74 = *(void *)(*(void *)(a1 + 80) + 8);
            char v75 = *(void **)(v74 + 40);
            *(void *)(v74 + 40) = v73;

            if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
            {
              __int16 v100 = MBGetDefaultLog();
              if (!os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
                goto LABEL_63;
              }
              uint64_t v105 = [v60 manifestID];
              char v106 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
              *(_DWORD *)buf = 138412546;
              id v212 = v105;
              __int16 v213 = 2112;
              char v214 = v106;
              _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "Unable to remove old manifestA: %@ %@", buf, 0x16u);

              uint64_t v104 = [v60 manifestID];
LABEL_61:
              _MBLog();
LABEL_62:
              id v13 = v168;

              goto LABEL_64;
            }
            uint64_t v76 = [*(id *)(a1 + 32) cache];
            uint64_t v77 = [v76 removeManifestAndFiles:v61];
            uint64_t v78 = *(void *)(*(void *)(a1 + 80) + 8);
            uint64_t v79 = *(void **)(v78 + 40);
            *(void *)(v78 + 40) = v77;

            if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
            {
              __int16 v100 = MBGetDefaultLog();
              if (!os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
                goto LABEL_63;
              }
              unsigned int v107 = [v61 manifestID];
              char v108 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
              *(_DWORD *)buf = 138412546;
              id v212 = v107;
              __int16 v213 = 2112;
              char v214 = v108;
              _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "Unable to remove old manifestB: %@ %@", buf, 0x16u);

              uint64_t v104 = [v61 manifestID];
              goto LABEL_61;
            }
            uint64_t v80 = *(void *)(a1 + 40);
            uint64_t v81 = [v61 domainName];
            id v82 = [*(id *)(a1 + 32) cache];
            char v83 = +[MBCKManifest manifestWithSnapshot:v80 domainName:v81 count:0 cache:v82];

            uint64_t v29 = v174;
            uint64_t v84 = [*(id *)(a1 + 32) cache];
            id v85 = [v84 addManifest:v83 toPendingSnapshot:*(void *)(a1 + 40)];

            long long v56 = (char *)v56 + 1;
            id v9 = v59;
            id v16 = v175;
            __int16 v55 = v162;
          }
          while (v165 != v56);
          id v13 = v168;
          double v26 = v169;
          id v165 = [v162 countByEnumeratingWithState:&v191 objects:v209 count:16];
          if (!v165)
          {
LABEL_38:

            id v86 = [*(id *)(a1 + 32) cache];
            uint64_t v87 = [v86 removeSnapshot:*(void *)(a1 + 48)];
            uint64_t v88 = *(void *)(*(void *)(a1 + 80) + 8);
            long long v89 = *(void **)(v88 + 40);
            *(void *)(v88 + 40) = v87;

            if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
            {
              long long v90 = MBGetDefaultLog();
              if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
              {
                id v91 = [*(id *)(a1 + 48) snapshotID];
                char v92 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
                *(_DWORD *)buf = 138412546;
                id v212 = v91;
                __int16 v213 = 2112;
                char v214 = v92;
                _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "Unable to remove old snapshotA: %@ %@", buf, 0x16u);

                id v93 = [*(id *)(a1 + 48) snapshotID];
                goto LABEL_68;
              }
              goto LABEL_69;
            }
            char v109 = [*(id *)(a1 + 32) cache];
            id v110 = [v109 removeSnapshot:*(void *)(a1 + 56)];

            if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
            {
              long long v90 = MBGetDefaultLog();
              if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
              {
                char v111 = [*(id *)(a1 + 56) snapshotID];
                char v112 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
                *(_DWORD *)buf = 138412546;
                id v212 = v111;
                __int16 v213 = 2112;
                char v214 = v112;
                _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "Unable to remove old snapshotB: %@ %@", buf, 0x16u);

                id v93 = [*(id *)(a1 + 56) snapshotID];
LABEL_68:
                _MBLog();
              }
LABEL_69:

              uint64_t v17 = 0;
              id v44 = v173;
              goto LABEL_50;
            }
            char v113 = *(void **)(a1 + 72);
            id v44 = v173;
            if (!v113) {
              goto LABEL_113;
            }
            uint64_t v163 = v55;
            long long v189 = 0u;
            long long v190 = 0u;
            long long v187 = 0u;
            long long v188 = 0u;
            id obj = [v113 manifestsByDomainName];
            id v114 = [obj countByEnumeratingWithState:&v187 objects:v208 count:16];
            id v161 = v9;
            if (!v114)
            {

              char v135 = 1;
              goto LABEL_92;
            }
            id v115 = v114;
            id v171 = *(id *)v188;
            char v166 = 1;
            while (2)
            {
              uint64_t v116 = 0;
LABEL_74:
              if (*(id *)v188 != v171) {
                objc_enumerationMutation(obj);
              }
              long long v117 = *(void **)(*((void *)&v187 + 1) + 8 * v116);
              uint64_t v118 = objc_msgSend(*(id *)(a1 + 72), "manifestsByDomainName", v155, v158, v160);
              uint64_t v119 = [v118 objectForKeyedSubscript:v117];

              uint64_t v120 = [*(id *)(a1 + 72) manifestIDs];
              uint64_t v121 = [v119 baseRecordIDString];
              id v122 = [v120 indexOfObject:v121];

              uint64_t v123 = [*(id *)(a1 + 32) cache];
              uint64_t v124 = [v119 manifestID];
              uint64_t v125 = *(void *)(*(void *)(a1 + 80) + 8);
              id v186 = *(id *)(v125 + 40);
              id v126 = [v123 checksumForManifest:v124 error:&v186];
              objc_storeStrong((id *)(v125 + 40), v186);

              if (v122 == (id)0x7FFFFFFFFFFFFFFFLL)
              {
                char v127 = MBGetDefaultLog();
                if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
                {
                  char v128 = [*(id *)(a1 + 72) manifestIDs];
                  char v129 = [v119 recordIDString];
                  *(_DWORD *)buf = 138412802;
                  id v212 = v117;
                  __int16 v213 = 2114;
                  char v214 = v128;
                  __int16 v215 = 2114;
                  char v216 = v129;
                  _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, "Manifest: %@ %{public}@ %{public}@ - unable to find index to verify cache", buf, 0x20u);

                  long long v130 = [*(id *)(a1 + 72) manifestIDs];
                  [v119 recordIDString];
                  v160 = uint64_t v158 = v130;
                  uint64_t v155 = v117;
                  _MBLog();

                  id v44 = v173;
                  uint64_t v29 = v174;
                  goto LABEL_83;
                }
                id v44 = v173;
                uint64_t v29 = v174;
LABEL_86:
              }
              else
              {
                long long v131 = [*(id *)(a1 + 72) manifestChecksums];
                long long v132 = [v131 objectAtIndexedSubscript:v122];
                id v133 = [v132 longLongValue];

                id v44 = v173;
                uint64_t v29 = v174;
                if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) || v133 != v126)
                {
                  char v127 = MBGetDefaultLog();
                  if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
                  {
                    long long v134 = [v119 manifestID];
                    *(_DWORD *)buf = 138412546;
                    id v212 = v117;
                    __int16 v213 = 2112;
                    char v214 = v134;
                    _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, "Manifest: %@ (%@) maybe corrupted in the cache.", buf, 0x16u);

                    long long v130 = [v119 manifestID];
                    uint64_t v155 = v117;
                    uint64_t v158 = v130;
                    _MBLog();
                    char v166 = 0;
LABEL_83:
                  }
                  else
                  {
                    char v166 = 0;
                  }
                  goto LABEL_86;
                }
              }

              if (v115 == (id)++v116)
              {
                id v115 = [obj countByEnumeratingWithState:&v187 objects:v208 count:16];
                if (!v115)
                {

                  id v9 = v161;
                  id v13 = v168;
                  double v26 = v169;
                  id v16 = v175;
                  __int16 v55 = v163;
                  char v135 = v166;
                  if ((v166 & 1) == 0) {
                    goto LABEL_108;
                  }
LABEL_92:
                  char v167 = v135;
                  long long v184 = 0u;
                  long long v185 = 0u;
                  long long v182 = 0u;
                  long long v183 = 0u;
                  objc_msgSend(*(id *)(a1 + 72), "manifestsByDomainName", v155);
                  id v172 = (id)objc_claimAutoreleasedReturnValue();
                  id v136 = [v172 countByEnumeratingWithState:&v182 objects:v207 count:16];
                  if (v136)
                  {
                    id v137 = v136;
                    uint64_t v138 = *(void *)v183;
                    do
                    {
                      for (j = 0; j != v137; j = (char *)j + 1)
                      {
                        if (*(void *)v183 != v138) {
                          objc_enumerationMutation(v172);
                        }
                        char v140 = *(void **)(*((void *)&v182 + 1) + 8 * (void)j);
                        char v141 = objc_msgSend(*(id *)(a1 + 72), "manifestsByDomainName", v157, v158, v160);
                        char v142 = [v141 objectForKeyedSubscript:v140];

                        dispatch_semaphore_t v143 = dispatch_semaphore_create(0);
                        v179[0] = _NSConcreteStackBlock;
                        v179[1] = 3221225472;
                        v179[2] = sub_1000A3BC4;
                        v179[3] = &unk_100410FC8;
                        uint64_t v181 = *(void *)(a1 + 80);
                        char v144 = v143;
                        uint64_t v180 = v144;
                        [v142 saveToCacheWithCompletion:v179];
                        dispatch_semaphore_wait(v144, 0xFFFFFFFFFFFFFFFFLL);
                        if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
                        {
                          char v145 = MBGetDefaultLog();
                          if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
                          {
                            uint64_t v146 = [v142 manifestID];
                            uint64_t v147 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
                            *(_DWORD *)buf = 138412802;
                            id v212 = v140;
                            __int16 v213 = 2112;
                            char v214 = v146;
                            __int16 v215 = 2112;
                            char v216 = v147;
                            _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_ERROR, "Manifest: %@ (%@) unable to save to the cache: %@", buf, 0x20u);

                            uint64_t v158 = [v142 manifestID];
                            uint64_t v160 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
                            uint64_t v157 = v140;
                            _MBLog();
                          }
                          char v167 = 0;
                          id v16 = v175;
                        }
                      }
                      id v137 = [v172 countByEnumeratingWithState:&v182 objects:v207 count:16];
                    }
                    while (v137);
                  }

                  dispatch_semaphore_t v148 = dispatch_semaphore_create(0);
                  v176[0] = _NSConcreteStackBlock;
                  v176[1] = 3221225472;
                  v176[2] = sub_1000A3C24;
                  v176[3] = &unk_100410FC8;
                  uint64_t v149 = *(void **)(a1 + 72);
                  uint64_t v178 = *(void *)(a1 + 80);
                  uint64_t v150 = v148;
                  uint64_t v177 = v150;
                  [v149 saveToCacheWithCompletion:v176];
                  dispatch_semaphore_wait(v150, 0xFFFFFFFFFFFFFFFFLL);
                  id v9 = v161;
                  id v13 = v168;
                  double v26 = v169;
                  id v44 = v173;
                  uint64_t v29 = v174;
                  __int16 v55 = v163;
                  char v151 = v167;
                  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
                  {
                    uint64_t v152 = MBGetDefaultLog();
                    if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v153 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
                      *(_DWORD *)buf = 138412290;
                      id v212 = v153;
                      _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_ERROR, "Could not save cache: %@", buf, 0xCu);
                      _MBLog();
                    }

                    char v151 = 0;
                    id v16 = v175;
                  }

                  if ((v151 & 1) == 0)
                  {
LABEL_108:
                    uint64_t v154 = MBGetDefaultLog();
                    if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_ERROR, "Journal replay merge action did not succeed.", buf, 2u);
                      goto LABEL_115;
                    }
LABEL_116:

                    [*(id *)(a1 + 72) forgetManifests];
                    uint64_t v17 = 1;
LABEL_50:

LABEL_51:
                    goto LABEL_52;
                  }
                  if (*(void *)(a1 + 72))
                  {
                    uint64_t v154 = MBGetDefaultLog();
                    if (!os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_116;
                    }
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEFAULT, "Journal replay merge action succeeded.", buf, 2u);
LABEL_115:
                    _MBLog();
                    goto LABEL_116;
                  }
LABEL_113:
                  uint64_t v154 = MBGetDefaultLog();
                  if (!os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_116;
                  }
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEFAULT, "Journal replay merge action succeeded (intermediate action).", buf, 2u);
                  goto LABEL_115;
                }
                continue;
              }
              goto LABEL_74;
            }
          }
        }
      }
      id v46 = v45;
      uint64_t v47 = *(void *)v196;
LABEL_18:
      uint64_t v48 = 0;
      while (1)
      {
        if (*(void *)v196 != v47) {
          objc_enumerationMutation(v44);
        }
        id v49 = *(void **)(*((void *)&v195 + 1) + 8 * v48);
        uint64_t v50 = [*(id *)(a1 + 32) cache];
        uint64_t v51 = [v50 moveManifest:v49 toSnapshot:*(void *)(a1 + 64)];
        uint64_t v52 = *(void *)(*(void *)(a1 + 80) + 8);
        __int16 v53 = *(void **)(v52 + 40);
        *(void *)(v52 + 40) = v51;

        if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40)) {
          break;
        }
        if (v46 == (id)++v48)
        {
          id v46 = [v44 countByEnumeratingWithState:&v195 objects:v210 count:16];
          if (!v46) {
            goto LABEL_24;
          }
          goto LABEL_18;
        }
      }
      char v96 = MBGetDefaultLog();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      {
        char v97 = *(void **)(a1 + 64);
        __int16 v98 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
        *(_DWORD *)buf = 138412802;
        id v212 = v49;
        __int16 v213 = 2112;
        char v214 = v97;
        __int16 v215 = 2112;
        char v216 = v98;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_ERROR, "Unable to move manifest: %@ to snapshot: %@: %@", buf, 0x20u);
        _MBLog();
      }

      uint64_t v17 = 0;
      __int16 v55 = v44;
LABEL_48:
      id v13 = v168;
      goto LABEL_49;
    }
    double v26 = MBGetDefaultLog();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      __int16 v27 = [*(id *)(a1 + 56) snapshotID];
      id v28 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
      *(_DWORD *)buf = 138412546;
      id v212 = v27;
      __int16 v213 = 2112;
      char v214 = v28;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Unable to enumerate manifests for snapshot %@: %@", buf, 0x16u);

      uint64_t v29 = [*(id *)(a1 + 56) snapshotID];
      _MBLog();
      uint64_t v17 = 0;
      goto LABEL_51;
    }
    uint64_t v17 = 0;
LABEL_52:

    goto LABEL_53;
  }
  id v13 = MBGetDefaultLog();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    id v14 = [*(id *)(a1 + 48) snapshotID];
    uint64_t v15 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
    *(_DWORD *)buf = 138412546;
    id v212 = v14;
    __int16 v213 = 2112;
    char v214 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Unable to enumerate manifests for snapshot %@: %@", buf, 0x16u);

    id v16 = [*(id *)(a1 + 48) snapshotID];
    _MBLog();
    uint64_t v17 = 0;
LABEL_53:

    goto LABEL_54;
  }
  uint64_t v17 = 0;
LABEL_54:

  return v17;
}

uint64_t sub_1000A3B14(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  double v4 = [v3 domainHmac];
  [v2 setObject:v3 forKeyedSubscript:v4];

  return 1;
}

uint64_t sub_1000A3B6C(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  double v4 = [v3 domainHmac];
  [v2 setObject:v3 forKeyedSubscript:v4];

  return 1;
}

void sub_1000A3BC4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000A3C24(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000A401C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A4038(uint64_t a1)
{
  id v2 = (id *)(a1 + 32);
  id v3 = [*(id *)(a1 + 32) cache];
  id v4 = [v3 addPendingSnapshot:*(void *)(a1 + 40)];

  id v5 = [*v2 cache];
  id v6 = [v5 commitSnapshot:*(void *)(a1 + 40)];

  id v102 = [objc_alloc((Class)NSSet) initWithArray:*(void *)(a1 + 48)];
  id v7 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v8 = [*v2 cache];
  uint64_t v9 = *(void *)(a1 + 56);
  v127[0] = _NSConcreteStackBlock;
  v127[1] = 3221225472;
  v127[2] = sub_1000A4FA0;
  v127[3] = &unk_100411750;
  id v101 = v7;
  id v128 = v101;
  uint64_t v10 = [v8 enumerateManifestsForSnapshot:v9 foundManifest:v127];
  uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 8);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
  {
    id v13 = MBGetDefaultLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      id v14 = [*(id *)(a1 + 56) snapshotID];
      uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Couldn't enumerate manifest for snapshot %@: %@", buf, 0x16u);

      char v95 = [*(id *)(a1 + 56) snapshotID];
      _MBLog();
    }
    goto LABEL_28;
  }
  long long v125 = 0u;
  long long v126 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  id v16 = v101;
  id v17 = [v16 countByEnumeratingWithState:&v123 objects:v141 count:16];
  if (v17)
  {
    uint64_t v18 = *(void *)v124;
    do
    {
      for (uint64_t i = 0; i != v17; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v124 != v18) {
          objc_enumerationMutation(v16);
        }
        uint64_t v20 = *(void *)(*((void *)&v123 + 1) + 8 * i);
        id v21 = [v16 objectForKeyedSubscript:v20];
        id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 96));
        unsigned int v23 = [WeakRetained isBackupEngine];

        if (v23)
        {
          id v24 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 96));
          [v24 resumeWatchdogIfNeeded];
        }
        unsigned int v25 = [v102 containsObject:v20];
        double v26 = [*(id *)(a1 + 32) cache];
        __int16 v27 = v26;
        if (v25)
        {
          uint64_t v28 = [v26 removeManifestAndFiles:v21];
          uint64_t v29 = *(void *)(*(void *)(a1 + 80) + 8);
          id v30 = *(void **)(v29 + 40);
          *(void *)(v29 + 40) = v28;

          if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
          {
            uint64_t v42 = MBGetDefaultLog();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              id v44 = [v21 manifestID];
              uint64_t v45 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
              *(_DWORD *)buf = 138412546;
              *(void *)&uint8_t buf[4] = v44;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v45;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Unable to remove old manifest: %@ %@", buf, 0x16u);

              id v46 = [v21 manifestID];
              _MBLog();
              goto LABEL_26;
            }
            goto LABEL_27;
          }
        }
        else
        {
          long long v31 = [v21 manifestID];
          uint64_t v32 = [v27 moveManifest:v31 toSnapshot:*(void *)(a1 + 64)];
          uint64_t v33 = *(void *)(*(void *)(a1 + 80) + 8);
          id v34 = *(void **)(v33 + 40);
          *(void *)(v33 + 40) = v32;

          if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
          {
            uint64_t v42 = MBGetDefaultLog();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              uint64_t v47 = [v21 manifestID];
              uint64_t v48 = *(void *)(a1 + 64);
              id v49 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 80) + 8) + 40);
              *(_DWORD *)buf = 138412802;
              *(void *)&uint8_t buf[4] = v47;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v48;
              *(_WORD *)&buf[22] = 2112;
              id v137 = v49;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Unable to move manifest: %@ to snapshot: %@: %@", buf, 0x20u);

              id v46 = [v21 manifestID];
              _MBLog();
LABEL_26:
            }
LABEL_27:

            goto LABEL_28;
          }
        }
      }
      id v17 = [v16 countByEnumeratingWithState:&v123 objects:v141 count:16];
    }
    while (v17);
  }

  id v35 = [*(id *)(a1 + 32) cache];
  uint64_t v36 = [v35 removeSnapshot:*(void *)(a1 + 56)];
  uint64_t v37 = *(void *)(*(void *)(a1 + 80) + 8);
  uint64_t v38 = *(void **)(v37 + 40);
  *(void *)(v37 + 40) = v36;

  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
  {
    uint64_t v39 = MBGetDefaultLog();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      uint64_t v40 = [*(id *)(a1 + 56) snapshotID];
      uint64_t v41 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v41;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Unable to remove old snapshot: %@ %@", buf, 0x16u);

      char v96 = [*(id *)(a1 + 56) snapshotID];
      _MBLog();
    }
    goto LABEL_28;
  }
  uint64_t v52 = *(void **)(a1 + 72);
  if (!v52) {
    goto LABEL_75;
  }
  long long v121 = 0u;
  long long v122 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  id obj = [v52 manifestsByDomainName];
  id v53 = [obj countByEnumeratingWithState:&v119 objects:v140 count:16];
  if (!v53)
  {

    char v105 = 1;
    goto LABEL_51;
  }
  uint64_t v106 = *(void *)v120;
  char v105 = 1;
  do
  {
    for (j = 0; j != v53; j = (char *)j + 1)
    {
      if (*(void *)v120 != v106) {
        objc_enumerationMutation(obj);
      }
      uint64_t v55 = *(void *)(*((void *)&v119 + 1) + 8 * (void)j);
      long long v56 = objc_msgSend(*(id *)(a1 + 72), "manifestsByDomainName", v94, v98, v100);
      uint64_t v57 = [v56 objectForKeyedSubscript:v55];

      id v58 = [*(id *)(a1 + 72) manifestIDs];
      id v59 = [v57 baseRecordIDString];
      id v60 = [v58 indexOfObject:v59];

      long long v61 = [*(id *)(a1 + 32) cache];
      long long v62 = [v57 manifestID];
      uint64_t v63 = *(void *)(*(void *)(a1 + 80) + 8);
      id v118 = *(id *)(v63 + 40);
      id v64 = [v61 checksumForManifest:v62 error:&v118];
      objc_storeStrong((id *)(v63 + 40), v118);

      if (v60 == (id)0x7FFFFFFFFFFFFFFFLL)
      {
        id v65 = MBGetDefaultLog();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          long long v66 = [*(id *)(a1 + 72) manifestIDs];
          uint64_t v67 = [v57 recordIDString];
          *(_DWORD *)buf = 138412802;
          *(void *)&uint8_t buf[4] = v55;
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v66;
          *(_WORD *)&buf[22] = 2114;
          id v137 = v67;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "Manifest: %@ %{public}@ %{public}@ - unable to find index to verify cache", buf, 0x20u);

          long long v68 = [*(id *)(a1 + 72) manifestIDs];
          [v57 recordIDString];
          v100 = __int16 v98 = v68;
          uint64_t v94 = v55;
          _MBLog();

          goto LABEL_43;
        }
        goto LABEL_45;
      }
      uint64_t v69 = [*(id *)(a1 + 72) manifestChecksums];
      uint64_t v70 = [v69 objectAtIndexedSubscript:v60];
      id v71 = [v70 longLongValue];

      if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) || v71 != v64)
      {
        id v65 = MBGetDefaultLog();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          long long v72 = [v57 manifestID];
          uint64_t v73 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 80) + 8) + 40);
          *(_DWORD *)buf = 138412802;
          *(void *)&uint8_t buf[4] = v55;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v72;
          *(_WORD *)&buf[22] = 2112;
          id v137 = v73;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "Manifest: %@ (%@) maybe corrupted in the cache, error:%@", buf, 0x20u);

          long long v68 = [v57 manifestID];
          __int16 v98 = v68;
          __int16 v100 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
          uint64_t v94 = v55;
          _MBLog();
          char v105 = 0;
LABEL_43:
        }
        else
        {
          char v105 = 0;
        }
LABEL_45:
      }
    }
    id v53 = [obj countByEnumeratingWithState:&v119 objects:v140 count:16];
  }
  while (v53);

  if ((v105 & 1) == 0) {
    goto LABEL_69;
  }
LABEL_51:
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x3032000000;
  id v137 = sub_1000A23D8;
  uint64_t v138 = sub_1000A23E8;
  id v139 = 0;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  uint64_t v74 = objc_msgSend(*(id *)(a1 + 72), "manifestsByDomainName", v94, v98);
  id v75 = [v74 countByEnumeratingWithState:&v114 objects:v135 count:16];
  if (v75)
  {
    uint64_t v107 = *(void *)v115;
    id obja = v74;
    do
    {
      for (k = 0; k != v75; k = (char *)k + 1)
      {
        if (*(void *)v115 != v107) {
          objc_enumerationMutation(obja);
        }
        uint64_t v77 = *(void *)(*((void *)&v114 + 1) + 8 * (void)k);
        uint64_t v78 = objc_msgSend(*(id *)(a1 + 72), "manifestsByDomainName", v97, v99, v100);
        uint64_t v79 = [v78 objectForKeyedSubscript:v77];

        dispatch_semaphore_t v80 = dispatch_semaphore_create(0);
        v111[0] = _NSConcreteStackBlock;
        v111[1] = 3221225472;
        v111[2] = sub_1000A4FF8;
        v111[3] = &unk_100410FC8;
        char v113 = buf;
        uint64_t v81 = v80;
        char v112 = v81;
        [v79 saveToCacheWithCompletion:v111];
        dispatch_semaphore_wait(v81, 0xFFFFFFFFFFFFFFFFLL);
        if (*(void *)(*(void *)&buf[8] + 40))
        {
          id v82 = MBGetDefaultLog();
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
          {
            char v83 = v82;
            if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
            {
              uint64_t v84 = [v79 manifestID];
              uint64_t v85 = *(void *)(*(void *)&buf[8] + 40);
              *(_DWORD *)char v129 = 138412802;
              uint64_t v130 = v77;
              __int16 v131 = 2112;
              long long v132 = v84;
              __int16 v133 = 2112;
              uint64_t v134 = v85;
              _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "Manifest: %@ (%@) unable to save to the cache: %@", v129, 0x20u);
            }
            char v99 = [v79 manifestID];
            __int16 v100 = *(void **)(*(void *)&buf[8] + 40);
            uint64_t v97 = v77;
            _MBLog();
          }
          objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40), *(id *)(*(void *)&buf[8] + 40));
          char v105 = 0;
        }
      }
      uint64_t v74 = obja;
      id v75 = [obja countByEnumeratingWithState:&v114 objects:v135 count:16];
    }
    while (v75);
  }

  dispatch_semaphore_t v86 = dispatch_semaphore_create(0);
  uint64_t v87 = *(void **)(a1 + 72);
  v108[0] = _NSConcreteStackBlock;
  v108[1] = 3221225472;
  v108[2] = sub_1000A5058;
  v108[3] = &unk_100410FC8;
  id v110 = buf;
  uint64_t v88 = v86;
  char v109 = v88;
  [v87 saveToCacheWithCompletion:v108];
  dispatch_semaphore_wait(v88, 0xFFFFFFFFFFFFFFFFLL);
  if (*(void *)(*(void *)&buf[8] + 40))
  {
    long long v89 = MBGetDefaultLog();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      uint64_t v90 = *(void *)(a1 + 64);
      id v91 = *(void **)(*(void *)&buf[8] + 40);
      *(_DWORD *)char v129 = 138412546;
      uint64_t v130 = v90;
      __int16 v131 = 2112;
      long long v132 = v91;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "Snapshot: %@ unable to save to the cache: %@", v129, 0x16u);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40), *(id *)(*(void *)&buf[8] + 40));
    char v105 = 0;
  }

  _Block_object_dispose(buf, 8);
  if (v105)
  {
    if (*(void *)(a1 + 72))
    {
      id v93 = MBGetDefaultLog();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Journal replay removeDomain action succeeded.", buf, 2u);
LABEL_77:
        _MBLog();
        goto LABEL_78;
      }
      goto LABEL_78;
    }
LABEL_75:
    id v93 = MBGetDefaultLog();
    if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Journal replay removeDomain action succeeded (intermediate action).", buf, 2u);
      goto LABEL_77;
    }
LABEL_78:

    [*(id *)(a1 + 72) forgetManifests];
    uint64_t v50 = 1;
    goto LABEL_29;
  }
LABEL_69:
  char v92 = MBGetDefaultLog();
  if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "Journal replay removeDomain action did not succeed.", buf, 2u);
    _MBLog();
  }

LABEL_28:
  uint64_t v50 = 0;
LABEL_29:

  return v50;
}

void sub_1000A4F58(_Unwind_Exception *a1)
{
}

uint64_t sub_1000A4FA0(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v3 domainHmac];
  [v2 setObject:v3 forKeyedSubscript:v4];

  return 1;
}

void sub_1000A4FF8(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000A5058(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000A5A70()
{
}

id MBGetHealthRelatedDomains()
{
  if (qword_1004823C8 != -1) {
    dispatch_once(&qword_1004823C8, &stru_100411E38);
  }
  uint64_t v0 = (void *)qword_1004823C0;
  return v0;
}

void sub_1000A7C10(id a1)
{
  qword_1004823C0 = +[NSSet setWithArray:&off_10043B148];
  _objc_release_x1();
}

BOOL sub_1000A7FDC(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  uint64_t v11 = *(void *)(a1 + 32);
  id v12 = *(void **)(v11 + 56);
  if (v12)
  {
    if (![v12 isEqualToString:v9])
    {
      BOOL v20 = 1;
      goto LABEL_27;
    }
    uint64_t v11 = *(void *)(a1 + 32);
  }
  if (a4)
  {
    [*(id *)(v11 + 16) addObject:v9];
    uint64_t v11 = *(void *)(a1 + 32);
  }
  uint64_t v13 = [*(id *)(v11 + 8) objectForKeyedSubscript:v10];
  id v14 = (void *)v13;
  uint64_t v15 = *(void *)(a1 + 32);
  if (*(void *)(v15 + 8)) {
    BOOL v16 = v13 == 0;
  }
  else {
    BOOL v16 = 0;
  }
  if (v16)
  {
    BOOL v20 = 1;
  }
  else
  {
    id v17 = *(void **)(v15 + 40);
    id v26 = 0;
    id v18 = [v17 sizeOfScannedDomain:v9 error:&v26];
    id v19 = v26;
    BOOL v20 = v19 == 0;
    if (v19)
    {
      id v21 = MBGetDefaultLog();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        id v28 = v9;
        __int16 v29 = 2112;
        id v30 = v19;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "=quota-calculation= Error fetching local size of domain: %@: %@", buf, 0x16u);
        _MBLog();
      }

      if (a5) {
        *a5 = v19;
      }
    }
    else
    {
      if (*(void *)(*(void *)(a1 + 32) + 8))
      {
        id v22 = [v14 quota];
      }
      else
      {
        unsigned int v23 = MBGetDefaultLog();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v28 = v9;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "=quota-calculation= Using local size estimate for domain %@ because domainQuota wasn't present on the snapshotRecord", buf, 0xCu);
          _MBLog();
        }

        id v22 = v18;
      }
      id v24 = MBGetDefaultLog();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218754;
        id v28 = v22;
        __int16 v29 = 2048;
        id v30 = v18;
        __int16 v31 = 2112;
        id v32 = v9;
        __int16 v33 = 2112;
        id v34 = v10;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "=quota-calculation= Fetched server quota of %llu bytes and scanned size of %llu bytes for domain %@ with hmac  %@", buf, 0x2Au);
        _MBLog();
      }

      [*(id *)(a1 + 32) _addCloudSize:v22 localSize:v18 forDomain:v9];
    }
  }
LABEL_27:

  return v20;
}

uint64_t sub_1000A833C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a2;
  [*(id *)(a1 + 32) _addCloudSize:a4 localSize:0 forDomain:v6];
  if (!*(void *)(*(void *)(a1 + 32) + 56) || objc_msgSend(v6, "isEqualToString:"))
  {
    id v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = [*(id *)(a1 + 32) _sizeOfDomain:v6];
      *(_DWORD *)buf = 134218498;
      uint64_t v12 = a4;
      __int16 v13 = 2112;
      id v14 = v6;
      __int16 v15 = 2112;
      BOOL v16 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "=quota-calculation= Fetched placeholder size of %llu for %@ (total: %@)", buf, 0x20u);

      id v10 = [*(id *)(a1 + 32) _sizeOfDomain:v6];
      _MBLog();
    }
  }

  return 1;
}

uint64_t sub_1000A8B7C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) _sizeOfDomain:v6];
  uint64_t v8 = v7;
  if (v7)
  {
    objc_msgSend(*(id *)(a1 + 32), "_addCloudSize:localSize:forDomain:", objc_msgSend(v7, "cloudSize"), objc_msgSend(v7, "localSize"), v5);
    id v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = [*(id *)(a1 + 32) _sizeOfDomain:v5];
      *(_DWORD *)buf = 138413058;
      id v14 = v6;
      __int16 v15 = 2112;
      id v16 = v5;
      __int16 v17 = 2112;
      id v18 = v8;
      __int16 v19 = 2112;
      BOOL v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "=quota-calculation= Fetched child domain %@ of %@ with size %@ (total: %@)", buf, 0x2Au);

      uint64_t v12 = [*(id *)(a1 + 32) _sizeOfDomain:v5];
      _MBLog();
    }
  }

  return 1;
}

void sub_1000A8DC4(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  if ((sub_1000A8ED0(v7) & 1) == 0)
  {
    id v6 = objc_msgSend(objc_alloc((Class)MBDomainInfo), "initWithDomainName:systemApp:remoteSize:localSize:enabled:restricted:", v7, objc_msgSend(*(id *)(*(void *)(a1 + 32) + 16), "containsObject:", v7), objc_msgSend(v5, "cloudSize"), objc_msgSend(v5, "localSize"), objc_msgSend(*(id *)(*(void *)(a1 + 32) + 80), "containsObject:", v7) ^ 1, objc_msgSend(*(id *)(*(void *)(a1 + 32) + 72), "containsObject:", v7));
    [*(id *)(a1 + 40) addObject:v6];
  }
}

uint64_t sub_1000A8ED0(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"HealthDomain"])
  {
    id v2 = MBDeviceClass();
    if ([v2 isEqualToString:@"iPad"])
    {
    }
    else
    {
      unsigned int v3 = [v2 isEqualToString:@"RealityDevice"];

      if (!v3)
      {
LABEL_9:
        uint64_t v7 = 0;
        goto LABEL_10;
      }
    }
  }
  id v4 = MBGetHealthRelatedDomains();
  unsigned int v5 = [v4 containsObject:v1];

  if (!v5) {
    goto LABEL_9;
  }
  id v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    id v10 = v1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "=quota-calculation= Skipping health-related domain %@", buf, 0xCu);
    _MBLog();
  }

  uint64_t v7 = 1;
LABEL_10:

  return v7;
}

int64_t sub_1000A901C(id a1, MBDomainInfo *a2, MBDomainInfo *a3)
{
  id v4 = a2;
  unsigned int v5 = a3;
  id v6 = [(MBDomainInfo *)v5 size];
  if (v6 >= [(MBDomainInfo *)v4 size])
  {
    id v8 = [(MBDomainInfo *)v5 size];
    int64_t v7 = v8 != [(MBDomainInfo *)v4 size];
  }
  else
  {
    int64_t v7 = -1;
  }

  return v7;
}

void sub_1000A9554(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AA834(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ((sub_1000A8ED0(v3) & 1) == 0) {
    [*(id *)(a1 + 32) addObject:v3];
  }

  return 1;
}

int64_t sub_1000AA878(id a1, id a2, id a3)
{
  id v4 = a2;
  id v5 = a3;
  id v6 = [v5 size];
  if (v6 >= [v4 size])
  {
    id v8 = [v5 size];
    int64_t v7 = v8 != [v4 size];
  }
  else
  {
    int64_t v7 = -1;
  }

  return v7;
}

id MBCalculateQuotaForDomainsInCurrentDevice(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (!v5) {
    __assert_rtn("MBCalculateQuotaForDomainsInCurrentDevice", "MBCalculateQuota.m", 563, "serviceAccount");
  }
  int64_t v7 = v6;
  id v8 = MBGetDefaultLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "=quota-calculation= Calculating quota for domains in current device", buf, 2u);
    _MBLog();
  }

  id v9 = +[MBCKManager sharedInstance];
  id v10 = +[MBCKOperationPolicy expensiveCellularPolicy];
  [v10 setFetchAssets:0];
  uint64_t v11 = [v9 databaseManager];
  uint64_t v12 = +[MBCKOperationTracker operationTrackerWithAccount:v5 databaseManager:v11 policy:v10 error:a3];

  if (v12)
  {
    __int16 v13 = [v7 processName];
    id v14 = [v10 operationGroupWithName:@"calculateQuotaForDomainsInCurrentDevice" processName:v13];
    [v12 setCkOperationGroup:v14];

    __int16 v15 = MBDeviceUUID();
    id v32 = 0;
    id v16 = +[MBCKAccount fetchDeviceRecordAndSnapshots:v15 account:v5 manager:v9 tracker:v12 error:&v32];
    id v17 = v32;

    if (v16)
    {
      __int16 v31 = v7;
      id v18 = v17;
      __int16 v19 = [v16 snapshots];
      BOOL v20 = [v19 lastObject];
      id v21 = [v20 snapshotFormat];

      id v22 = MBGetDefaultLog();
      BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_INFO);
      if (v21 == (id)3)
      {
        if (v23)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "=quota-calculation= Calculating quota using domain sizer", buf, 2u);
          _MBLog();
        }

        uint64_t v24 = +[_DomainSizer sizeDomainsWithManager:v9 operationTracker:v12 account:v5 device:v16 error:a3];
      }
      else
      {
        if (v23)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "=quota-calculation= Calculating quota for all manifest sizer", buf, 2u);
          _MBLog();
        }

        uint64_t v24 = +[_ManifestSizer sizeDomainsWithManager:v9 account:v5 error:a3];
      }
      unsigned int v25 = (void *)v24;
      id v17 = v18;
      __int16 v27 = MBGetDefaultLog();
      int64_t v7 = v31;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        id v28 = [v25 count];
        *(_DWORD *)buf = 134217984;
        id v34 = v28;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "=quota-calculation= Fetched %lu domain infos", buf, 0xCu);
        [v25 count];
        _MBLog();
      }

      __int16 v29 = MBGetDefaultLog();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        id v34 = v25;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "=quota-calculation= Domain infos: %@", buf, 0xCu);
        _MBLog();
      }
    }
    else
    {
      id v26 = MBGetDefaultLog();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        id v34 = v17;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "=quota-calculation= Failed to fetch device record: %@", buf, 0xCu);
        _MBLog();
      }

      unsigned int v25 = 0;
      if (a3) {
        *a3 = v17;
      }
    }
  }
  else
  {
    unsigned int v25 = 0;
  }

  return v25;
}

id MBCalculateQuotaForDomain(void *a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  if (!v8) {
    __assert_rtn("MBCalculateQuotaForDomain", "MBCalculateQuota.m", 599, "serviceAccount");
  }
  id v10 = v9;
  uint64_t v11 = MBGetDefaultLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    id v30 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "=quota-calculation= Calculating quota for domain %@", buf, 0xCu);
    _MBLog();
  }

  uint64_t v12 = +[MBCKManager sharedInstance];
  __int16 v13 = +[MBCKOperationPolicy expensiveCellularPolicy];
  [v13 setFetchAssets:0];
  id v14 = [v12 databaseManager];
  __int16 v15 = +[MBCKOperationTracker operationTrackerWithAccount:v8 databaseManager:v14 policy:v13 error:a4];

  if (v15)
  {
    id v16 = [v10 processName];
    id v17 = [v13 operationGroupWithName:@"calculateQuotaForDomain" processName:v16];
    [v15 setCkOperationGroup:v17];

    id v18 = MBDeviceUUID();
    __int16 v19 = +[MBCKAccount fetchDeviceRecordAndSnapshots:v18 account:v8 manager:v12 tracker:v15 error:a4];

    if (v19)
    {
      id v28 = v10;
      BOOL v20 = [v19 snapshots];
      id v21 = [v20 lastObject];
      id v22 = [v21 snapshotFormat];

      BOOL v23 = MBGetDefaultLog();
      BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_INFO);
      if (v22 == (id)3)
      {
        if (v24)
        {
          *(_DWORD *)buf = 138412290;
          id v30 = v7;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "=quota-calculation= Calculating quota for domain %@ using domain sizer", buf, 0xCu);
          _MBLog();
        }

        unsigned int v25 = +[_DomainSizer sizeDomain:v7 manager:v12 operationTracker:v15 account:v8 device:v19 error:a4];
        id v26 = [v25 firstObject];
        id v10 = v28;
      }
      else
      {
        if (v24)
        {
          *(_DWORD *)buf = 138412290;
          id v30 = v7;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "=quota-calculation= Calculating quota for domain %@ using manifest sizer", buf, 0xCu);
          _MBLog();
        }

        id v26 = +[_ManifestSizer sizeDomainWithName:v7 manager:v12 account:v8 error:a4];
        unsigned int v25 = MBGetDefaultLog();
        id v10 = v28;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          id v30 = v7;
          __int16 v31 = 2112;
          id v32 = v26;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "=quota-calculation= Fetched domain info for %@: %@", buf, 0x16u);
          _MBLog();
        }
      }
    }
    else
    {
      id v26 = 0;
    }
  }
  else
  {
    id v26 = 0;
  }

  return v26;
}

void sub_1000AB958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

int64_t sub_1000AC030(id a1, MBSnapshot *a2, MBSnapshot *a3)
{
  id v4 = a3;
  id v5 = [(MBSnapshot *)a2 date];
  id v6 = [(MBSnapshot *)v4 date];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

void sub_1000AC0F4(id a1)
{
  qword_1004823E8 = objc_alloc_init(MBCKManager);
  _objc_release_x1();
}

void sub_1000AC350(uint64_t a1)
{
  id v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v3 = dispatch_queue_create("com.apple.backupd.account.notifications", v2);

  id v4 = objc_opt_new();
  [v4 setMaxConcurrentOperationCount:1];
  [v4 setQualityOfService:17];
  [v4 setUnderlyingQueue:v3];
  objc_initWeak(&location, *(id *)(a1 + 32));
  id v5 = +[NSNotificationCenter defaultCenter];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1000AC528;
  uint64_t v12[3] = &unk_100412028;
  id v13 = *(id *)(a1 + 32);
  objc_copyWeak(&v14, &location);
  uint64_t v6 = [v5 addObserverForName:@"MBAccountAvailableNotification" object:0 queue:v4 usingBlock:v12];
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = *(void **)(v7 + 248);
  *(void *)(v7 + 24_Block_object_dispose(&STACK[0x250], 8) = v6;

  [*(id *)(a1 + 32) _migrateMobileBackupDatabaseFromRootToMobile];
  [*(id *)(a1 + 32) _loadRestoreState];
  uint64_t v9 = +[MBThermalPressureMonitor sharedThermalPressureMonitor];
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void **)(v10 + 272);
  *(void *)(v10 + 272) = v9;

  objc_destroyWeak(&v14);
  objc_destroyWeak(&location);
}

void sub_1000AC500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AC528(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1000AC5F4;
  void v6[3] = &unk_100412000;
  id v7 = v3;
  id v5 = v3;
  objc_copyWeak(&v8, (id *)(a1 + 40));
  dispatch_async(v4, v6);
  objc_destroyWeak(&v8);
}

void sub_1000AC5F4(uint64_t a1)
{
  id v2 = MBGetDefaultLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) name];
    *(_DWORD *)buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received notification: %@", buf, 0xCu);

    id v5 = [*(id *)(a1 + 32) name];
    _MBLog();
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained _handleAccountAvailable];
}

void sub_1000AD528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

uint64_t sub_1000AD5B8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000AD5C8(uint64_t a1)
{
}

uint64_t sub_1000AD5D0(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) restoreSession];
  return _objc_release_x1();
}

void sub_1000AD61C(uint64_t a1)
{
  [*(id *)(a1 + 32) setDeviceForRestore:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) setRestoreSession:*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40)];
  [*(id *)(a1 + 32) setRestoreSessionOverridden:1];
  [*(id *)(a1 + 32) setLockManager:*(void *)(a1 + 48)];
  [*(id *)(a1 + 32) setRestoreKeyBagsByID:*(void *)(a1 + 56)];
  [*(id *)(a1 + 32) setServiceState:5];
  id v2 = [*(id *)(a1 + 64) persona];
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 72);
  id v8 = 0;
  id v5 = [v3 openOrUseExistingPlanWithPersona:v2 snapshotUUID:v4 error:&v8];
  id v6 = v8;

  if (!v5)
  {
    id v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v10 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "Failed to open plan while setting up restore session: %@", buf, 0xCu);
      _MBLog();
    }
  }
}

id sub_1000ADA14(uint64_t a1)
{
  return [*(id *)(a1 + 32) _clearRestoreSessionWithAccount:*(void *)(a1 + 40)];
}

void sub_1000AF4C0(uint64_t a1)
{
  id v3 = MBGetDefaultLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Delayed restore timer fired", v6, 2u);
    _MBLog();
  }

  uint64_t v4 = +[MBXPCServer sharedInstance];
  id v5 = [v4 scheduler];

  [v5 warnUserOfDelayedRestoreWithAccount:*(void *)(a1 + 32)];
}

void sub_1000AF948(uint64_t a1)
{
  id v3 = MBGetDefaultLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Background Restore TTR timer fired", v5, 2u);
    _MBLog();
  }

  uint64_t v4 = [*(id *)(a1 + 32) persona];
  +[MBTapToRadar reportBackgroundRestoreTimeoutWithPersona:v4];
}

void sub_1000B044C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000B06D8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000B19E4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 224), 8);
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1000B1A30(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState] == 1)
  {
    id v2 = [*(id *)(a1 + 32) engines];
    id v3 = [v2 lastObject];
    [v3 cancel];

    uint64_t v4 = [*(id *)(a1 + 32) serviceGroup];
    dispatch_time_t v5 = dispatch_time(0, 60000000000);
    intptr_t v6 = dispatch_group_wait(v4, v5);

    if (v6)
    {
      uint64_t v7 = +[MBError errorWithCode:15 format:@"Timed out while canceling scan"];
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
}

void sub_1000B1B18(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) serviceState];
  id v3 = MBGetDefaultLog();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      unsigned int v5 = [*(id *)(a1 + 32) serviceState];
      *(_DWORD *)buf = 67109120;
      unsigned int v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Can't set up the backup while busy (%d)", buf, 8u);
      [*(id *)(a1 + 32) serviceState];
      _MBLog();
    }

    uint64_t v6 = +[MBError errorWithCode:14 format:@"Manager not in idle state"];
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    if (v4)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting up backup", buf, 2u);
      _MBLog();
    }

    [*(id *)(a1 + 32) setServiceState:2];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
}

id sub_1000B1C90(uint64_t a1)
{
  return [*(id *)(a1 + 32) setServiceState:0];
}

void sub_1000B2090(uint64_t a1)
{
}

void sub_1000B2098(uint64_t a1)
{
  [*(id *)(a1 + 32) manager:*(void *)(a1 + 40) didSetBackupEnabled:*(unsigned __int8 *)(a1 + 48)];
}

void sub_1000B23BC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

id sub_1000B23DC(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) serviceState];
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_1000B2410(uint64_t a1)
{
  [*(id *)(a1 + 32) _syncBackupEnabledWithAccount:*(void *)(a1 + 40) connection:*(void *)(a1 + 48)];
  id v3 = +[MBDaemon sharedDaemon];
  [v3 releaseWorkAssertion:*(void *)(a1 + 64)];

  id v4 = self;
}

uint64_t sub_1000B2970(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = [*(id *)(a1 + 32) _copyBackupStateInfoForInitialMegaBackup:*(unsigned __int8 *)(a1 + 56) account:*(void *)(a1 + 40)];
  return _objc_release_x1();
}

uint64_t sub_1000B2C14(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!*(unsigned char *)(a1 + 40) && [v5 backupPolicy] == (id)1)
  {
    uint64_t v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      id v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Removing snapshot (MegaBackup): %{public}@", buf, 0xCu);
LABEL_9:
      _MBLog();
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  id v8 = *(id *)(a1 + 32);
  if (v8 != [v5 accountType])
  {
    uint64_t v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v10 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 134218498;
      id v13 = v10;
      __int16 v14 = 2048;
      id v15 = [v5 accountType];
      __int16 v16 = 2114;
      id v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Removing snapshot (account type: %ld/%ld): %{public}@", buf, 0x20u);
      [v5 accountType];
      goto LABEL_9;
    }
LABEL_10:

    uint64_t v9 = 0;
    goto LABEL_11;
  }
  uint64_t v9 = 1;
LABEL_11:

  return v9;
}

void sub_1000B36D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a64, 8);
  _Block_object_dispose(&STACK[0x240], 8);
  _Block_object_dispose(&STACK[0x270], 8);
  _Block_object_dispose(&STACK[0x290], 8);
  _Block_object_dispose((const void *)(v64 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1000B377C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id v51 = 0;
  id v4 = +[MBCKAccount fetchAccountWithOperationTracker:v3 cache:0 error:&v51];
  id v5 = v51;
  id v6 = v51;
  uint64_t v7 = v6;
  if (v4)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    id v50 = v6;
    unsigned __int8 v9 = [v4 fetchDevicesWithOperationTracker:v8 error:&v50];
    id v10 = v50;
    id v11 = v50;

    if (v9)
    {
      uint64_t v12 = [v4 devicesByUUID];
      id v13 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 3 * (void)objc_msgSend(v12, "count"));
      uint64_t v14 = [v12 allValues];
      uint64_t v15 = *(void *)(*(void *)(a1 + 72) + 8);
      __int16 v16 = *(void **)(v15 + 40);
      *(void *)(v15 + 40) = v14;

      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      id obj = *(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
      id v17 = [obj countByEnumeratingWithState:&v46 objects:v53 count:16];
      if (v17)
      {
        id v18 = v17;
        uint64_t v36 = *(void *)v47;
        id v32 = v11;
        __int16 v33 = v2;
        __int16 v31 = v12;
        id v34 = v13;
        do
        {
          for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v47 != v36) {
              objc_enumerationMutation(obj);
            }
            BOOL v20 = *(void **)(*((void *)&v46 + 1) + 8 * i);
            id v21 = objc_msgSend(v20, "snapshotRefs", v31, v32, v33);
            long long v42 = 0u;
            long long v43 = 0u;
            long long v44 = 0u;
            long long v45 = 0u;
            id v22 = v21;
            id v23 = [v22 countByEnumeratingWithState:&v42 objects:v52 count:16];
            if (v23)
            {
              id v24 = v23;
              uint64_t v25 = *(void *)v43;
              do
              {
                for (j = 0; j != v24; j = (char *)j + 1)
                {
                  if (*(void *)v43 != v25) {
                    objc_enumerationMutation(v22);
                  }
                  __int16 v27 = [*(id *)(*((void *)&v42 + 1) + 8 * (void)j) recordID];
                  [*(id *)(a1 + 40) objectForKey:v27];
                  if (objc_claimAutoreleasedReturnValue()) {
                    __assert_rtn("-[MBCKManager getBackupListWithOperationTracker:shouldFilter:error:]_block_invoke", "MBCKManager.m", 1274, "![devicesBySnapshotRecordID objectForKey:recordID]");
                  }
                  [*(id *)(a1 + 40) setObject:v20 forKey:v27];
                }
                id v24 = [v22 countByEnumeratingWithState:&v42 objects:v52 count:16];
              }
              while (v24);
            }

            if ([v22 count]) {
              [v34 addObjectsFromArray:v22];
            }
          }
          id v18 = [obj countByEnumeratingWithState:&v46 objects:v53 count:16];
          id v11 = v32;
          unsigned int v2 = v33;
          uint64_t v12 = v31;
          id v13 = v34;
        }
        while (v18);
      }

      if ([v13 count])
      {
        dispatch_group_enter(*(dispatch_group_t *)(a1 + 48));
        uint64_t v28 = *(void *)(a1 + 32);
        v37[0] = _NSConcreteStackBlock;
        v37[1] = 3221225472;
        v37[2] = sub_1000B3B8C;
        v37[3] = &unk_100412110;
        uint64_t v29 = *(void *)(a1 + 80);
        uint64_t v39 = *(void *)(a1 + 64);
        uint64_t v40 = v29;
        id v30 = *(void **)(a1 + 48);
        uint64_t v41 = *(void *)(a1 + 56);
        id v38 = v30;
        +[MBCKDevice fetchSnapshotsWithRefs:v13 operationTracker:v28 completion:v37];
      }
      else
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
      }
    }
    else
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), v10);
    }
  }
  else
  {
    if (+[MBError isError:v6 withCode:204]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    }
    else {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), v5);
    }
    id v11 = v7;
  }
}

void sub_1000B3B8C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v8 = a2;
  id v7 = a4;
  if (v7)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a4);
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a2);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000B3C34(uint64_t a1)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 56);
  id v4 = *(void **)(a1 + 40);
  id v5 = [*(id *)(a1 + 32) account];
  v10.receiver = v4;
  v10.super_class = (Class)MBCKManager;
  id v11 = 0;
  uint64_t v6 = objc_msgSendSuper2(&v10, "getBackupListWithFiltering:account:connection:error:", v3, v5, 0, &v11);
  id v7 = v11;
  uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
  unsigned __int8 v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v6;
}

void sub_1000B3CF0(uint64_t a1)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    context = v2;
    *(unsigned char *)(v3 + 24) = 0;
    id v4 = objc_opt_new();
    long long v78 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    id v5 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    id v6 = [v5 countByEnumeratingWithState:&v78 objects:v86 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v79;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v79 != v8) {
            objc_enumerationMutation(v5);
          }
          objc_super v10 = *(void **)(*((void *)&v78 + 1) + 8 * i);
          id v11 = [v10 backupUDID];
          [v4 setObject:v10 forKey:v11];
        }
        id v7 = [v5 countByEnumeratingWithState:&v78 objects:v86 count:16];
      }
      while (v7);
    }

    uint64_t v69 = objc_opt_new();
    long long v74 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    id v12 = *(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    id v13 = [v12 countByEnumeratingWithState:&v74 objects:v85 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v75;
      do
      {
        for (j = 0; j != v14; j = (char *)j + 1)
        {
          if (*(void *)v75 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void *)(*((void *)&v74 + 1) + 8 * (void)j);
          id v18 = objc_opt_new();
          [v69 setObject:v18 forKey:v17];
        }
        id v14 = [v12 countByEnumeratingWithState:&v74 objects:v85 count:16];
      }
      while (v14);
    }
    id v65 = v4;

    uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 8);
    BOOL v20 = *(void **)(v19 + 40);
    *(void *)(v19 + 40) = 0;

    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    id obj = *(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
    id v68 = [obj countByEnumeratingWithState:&v70 objects:v84 count:16];
    if (v68)
    {
      uint64_t v67 = *(void *)v71;
      do
      {
        for (k = 0; k != v68; k = (char *)k + 1)
        {
          if (*(void *)v71 != v67) {
            objc_enumerationMutation(obj);
          }
          id v22 = *(void **)(*((void *)&v70 + 1) + 8 * (void)k);
          uint64_t v24 = [v22 recordID];
          if (!v24) {
            __assert_rtn("-[MBCKManager getBackupListWithOperationTracker:shouldFilter:error:]_block_invoke_4", "MBCKManager.m", 1322, "recordID");
          }
          uint64_t v25 = (void *)v24;
          uint64_t v26 = [*(id *)(a1 + 32) objectForKey:v24];
          if (!v26) {
            __assert_rtn("-[MBCKManager getBackupListWithOperationTracker:shouldFilter:error:]_block_invoke_4", "MBCKManager.m", 1324, "device");
          }
          __int16 v27 = (void *)v26;
          uint64_t v28 = a1;
          [v22 setDevice:v26];
          id v29 = [objc_alloc((Class)CKReference) initWithRecordID:v25 action:0];
          id v30 = [v27 snapshotRefs];
          id v31 = [v30 indexOfObject:v29];

          if (v31 == (id)0x7FFFFFFFFFFFFFFFLL) {
            __assert_rtn("-[MBCKManager getBackupListWithOperationTracker:shouldFilter:error:]_block_invoke_4", "MBCKManager.m", 1328, "index != NSNotFound");
          }
          id v32 = [v27 snapshotCommitDates];
          id v33 = [v32 count];

          if (v31 < v33)
          {
            id v34 = [v27 snapshotCommitDates];
            id v35 = [v34 objectAtIndexedSubscript:v31];
            [v22 setCreated:v35];
          }
          uint64_t v36 = objc_msgSend(v69, "objectForKey:", v27, v63);
          if (!v36) {
            __assert_rtn("-[MBCKManager getBackupListWithOperationTracker:shouldFilter:error:]_block_invoke_4", "MBCKManager.m", 1333, "snapshots");
          }
          uint64_t v37 = v36;
          [v36 addObject:v22];
          id v38 = MBGetDefaultLog();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            char v83 = v22;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, "Found snapshot: %@", buf, 0xCu);
            uint64_t v63 = v22;
            _MBLog();
          }

          a1 = v28;
        }
        id v68 = [obj countByEnumeratingWithState:&v70 objects:v84 count:16];
      }
      while (v68);
    }

    uint64_t v39 = [v69 keyEnumerator];
    uint64_t v40 = [v39 nextObject];
    if (v40)
    {
      uint64_t v41 = (void *)v40;
      do
      {
        long long v42 = objc_msgSend(v69, "objectForKey:", v41, v63);
        long long v43 = [(id)objc_opt_class() _removeIncompatibleSnapshotsWithAccountType:*(void *)(a1 + 96) device:v41 snapshots:v42];

        uint64_t v44 = [v41 deviceUUID];
        if (!v44) {
          __assert_rtn("-[MBCKManager getBackupListWithOperationTracker:shouldFilter:error:]_block_invoke", "MBCKManager.m", 1346, "backupUUID");
        }
        long long v45 = (void *)v44;
        long long v46 = MBDeviceUUID();
        unsigned int v47 = [v45 isEqualToString:v46];

        if (v47)
        {
          uint64_t v48 = MBDeviceUDID_Legacy();

          long long v45 = (void *)v48;
        }
        long long v49 = [v65 objectForKey:v45];
        id v50 = +[MBBackup backupByMergingMBSBackup:v49 device:v41 snapshots:v43 filterSnapshots:*(unsigned __int8 *)(a1 + 104)];
        [v65 setObject:v50 forKey:v45];

        uint64_t v51 = [v39 nextObject];

        uint64_t v41 = (void *)v51;
      }
      while (v51);
    }

    uint64_t v52 = [v65 dictionaryRepresentation];
    uint64_t v53 = *(void *)(*(void *)(a1 + 80) + 8);
    id v54 = *(void **)(v53 + 40);
    *(void *)(v53 + 40) = v52;

    uint64_t v55 = [*(id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) allValues];
    id v56 = [v55 mutableCopy];

    id v57 = [v56 indexOfObjectPassingTest:&stru_100412178];
    if (v57 != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      id v58 = v57;
      id v59 = [v56 objectAtIndexedSubscript:v57];
      [v56 removeObjectAtIndex:v58];
      [v56 insertObject:v59 atIndex:0];
    }
    uint64_t v60 = *(void *)(*(void *)(a1 + 88) + 8);
    long long v61 = *(void **)(v60 + 40);
    *(void *)(v60 + 40) = v56;
    id v62 = v56;

    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
    unsigned int v2 = context;
  }
}

BOOL sub_1000B43EC(id a1, MBBackup *a2, unint64_t a3, BOOL *a4)
{
  id v5 = [(MBBackup *)a2 backupUDID];
  id v6 = MBDeviceUUID();
  unsigned int v7 = [v5 isEqualToString:v6];

  if (v7) {
    *a4 = 1;
  }
  return v7;
}

void sub_1000B5CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
}

void sub_1000B5D80(id a1, CKRecord *a2)
{
  unsigned int v2 = MBGetDefaultLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "InheritBackup record fetched block. Nothing to do here", v3, 2u);
    _MBLog();
  }
}

void sub_1000B5DFC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    id v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Hitting InheritBackup endpoint resulted in error %@", buf, 0xCu);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
    char v7 = 0;
  }
  else
  {
    char v7 = 1;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v7;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000B6064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B607C(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) nextBackupSize];
  return _objc_release_x1();
}

void sub_1000B61FC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) nextBackupSize];
  if (v2)
  {
    [*(id *)(a1 + 40) setState:2];
    objc_msgSend(*(id *)(a1 + 40), "setSize:", objc_msgSend(v2, "unsignedLongLongValue"));
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 40), "setState:", objc_msgSend(*(id *)(a1 + 32), "serviceState") == 1);
  }
}

void sub_1000B6488(id a1)
{
  uint64_t v1 = MBGetDefaultLog();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Backup engine timed out - exiting", buf, 2u);
    _MBLog();
  }

  if (MBIsInternalInstall())
  {
    id v2 = MBGetDefaultLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Backup engine timed out", v3, 2u);
      _MBLog();
    }
  }
  if (dword_1004823D4 != -1 && atomic_fetch_add_explicit(&dword_1004823D4, 1u, memory_order_relaxed) != -1) {
    _MBCreateDiagnosticReport(@"Backup engine timed out", 0);
  }
  sleep(0x1Eu);
  MBExit(1);
}

void sub_1000B6E90(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1000B6ED0(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000B6F30(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState] == 1)
  {
    id v2 = *(void **)(a1 + 40);
    uint64_t v3 = *(void *)(a1 + 48);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    uint64_t v5[2] = sub_1000B7008;
    v5[3] = &unk_100411060;
    id v6 = *(id *)(a1 + 56);
    [v2 _cancelBackupAndScanEnginesWithAccount:v3 timeout:60 completion:v5];
  }
  else
  {
    id v4 = *(NSObject **)(a1 + 56);
    dispatch_group_leave(v4);
  }
}

void sub_1000B7008(uint64_t a1, void *a2)
{
  if (a2) {
    objc_exception_throw([objc_alloc((Class)MBException) initWithCode:1 format:@"Timed out while canceling scan engine"]);
  }
  uint64_t v3 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v3);
}

void sub_1000B7068(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState])
  {
    id v2 = MBGetDefaultLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v3 = [*(id *)(a1 + 32) serviceState];
      *(_DWORD *)buf = 67109120;
      unsigned int v24 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Ignoring backup request while busy (%d)", buf, 8u);
      [*(id *)(a1 + 32) serviceState];
      _MBLog();
    }

    uint64_t v4 = +[MBError errorWithCode:14 format:@"Manager not in idle state"];
    uint64_t v5 = *(void *)(*(void *)(a1 + 88) + 8);
    id v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;

    *(unsigned char *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = 0;
  }
  else
  {
    [*(id *)(*(void *)(a1 + 40) + 40) allPersonaStates];
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    id v7 = (id)objc_claimAutoreleasedReturnValue();
    id v8 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v19;
      while (2)
      {
        id v11 = 0;
        do
        {
          if (*(void *)v19 != v10) {
            objc_enumerationMutation(v7);
          }
          if ([*(id *)(*((void *)&v18 + 1) + 8 * (void)v11) serviceState] == 3)
          {
            id v14 = MBGetDefaultLog();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Ignoring backup request because a concurrent backup is already in progress", buf, 2u);
              _MBLog();
            }

            uint64_t v15 = +[MBError errorWithCode:14 format:@"Backup already in progress"];
            uint64_t v16 = *(void *)(*(void *)(a1 + 88) + 8);
            uint64_t v17 = *(void **)(v16 + 40);
            *(void *)(v16 + 40) = v15;

            char v13 = 0;
            id v12 = v7;
            goto LABEL_17;
          }
          id v11 = (char *)v11 + 1;
        }
        while (v9 != v11);
        id v9 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }

    [*(id *)(a1 + 32) setServiceState:3];
    id v12 = [*(id *)(a1 + 40) _backupEngineWithReason:*(void *)(a1 + 104) settingsContext:*(void *)(a1 + 48) account:*(void *)(a1 + 56)];
    [v12 setCkOperationGroup:*(void *)(a1 + 64)];
    [v12 setCkOperationPolicy:*(void *)(a1 + 72)];
    [v12 setCkOperationTracker:*(void *)(a1 + 80)];
    [*(id *)(a1 + 40) _startBackupWithEngine:v12 account:*(void *)(a1 + 56)];
    char v13 = 1;
LABEL_17:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = v13;
  }
}

void sub_1000B7834(uint64_t a1, unsigned int a2, void *a3, double a4)
{
  id v7 = a3;
  id v8 = MBGetDefaultLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    if (a2 > 4) {
      CFStringRef v9 = @"unknown";
    }
    else {
      CFStringRef v9 = *(&off_100412B98 + (int)a2);
    }
    *(_DWORD *)buf = 138412290;
    *(void *)long long v71 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Engine callback (%@)", buf, 0xCu);
    if (a2 > 4) {
      CFStringRef v10 = @"unknown";
    }
    else {
      CFStringRef v10 = *(&off_100412B98 + (int)a2);
    }
    CFStringRef v59 = v10;
    _MBLog();
  }

  id v11 = [*(id *)(a1 + 32) watchdog];
  id v12 = [*(id *)(a1 + 32) backupStateDescription];
  char v13 = [*(id *)(a1 + 40) delegate];
  float v14 = a4;
  *(float *)&double v15 = v14;
  [*(id *)(a1 + 48) setProgress:v15];
  uint64_t v63 = v11;
  switch(a2)
  {
    case 0u:
      uint64_t v16 = MBGetDefaultLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = *(void *)(a1 + 56);
        *(_DWORD *)buf = 138543362;
        *(void *)long long v71 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Started backup, reason:%{public}@", buf, 0xCu);
        CFStringRef v59 = *(const __CFString **)(a1 + 56);
        _MBLog();
      }
      long long v18 = v13;

      [v11 resume];
      if (*(unsigned char *)(a1 + 96))
      {
        [*(id *)(a1 + 40) _updateMegaBackupStatus:0 account:*(void *)(a1 + 64)];
        [*(id *)(a1 + 40) submitMegaLifeCycleTelemetriesWithAccount:*(void *)(a1 + 64)];
        long long v19 = [*(id *)(a1 + 64) persona];
        id v20 = [v19 copyPreferencesValueForKey:@"MegaBackupFlowStartDate" class:objc_opt_class()];
        id v21 = [v19 copyPreferencesValueForKey:@"InitialMegaBackupStartDateDelta" class:objc_opt_class()];
        id v22 = v21;
        if (v20 && !v21)
        {
          id v61 = v7;
          +[NSDate now];
          v24 = id v23 = v12;
          [v24 timeIntervalSinceDate:v20];
          uint64_t v26 = +[NSNumber numberWithInt:(int)v25];
          [v19 setPreferencesValue:v26 forKey:@"InitialMegaBackupStartDateDelta"];

          id v7 = v61;
          id v12 = v23;
        }
        objc_msgSend(*(id *)(a1 + 40), "submitMegaLifeCycleTelemetriesWithAccount:", *(void *)(a1 + 64), v59);

        uint64_t v27 = *(unsigned char *)(a1 + 96) != 0;
      }
      else
      {
        uint64_t v27 = 0;
      }
      unsigned int v47 = *(void **)(a1 + 40);
      uint64_t v48 = *(void *)(a1 + 48);
      uint64_t v32 = -1;
      double v49 = 0.0;
      goto LABEL_46;
    case 1u:
      if ([*(id *)(a1 + 48) state] == 2)
      {
        [*(id *)(a1 + 72) progressAtLastUpdate];
        if (v29 != a4) {
          [v11 resume];
        }
      }
      else
      {
        [*(id *)(a1 + 48) setState:2];
        [v11 resume];
        [*(id *)(a1 + 72) reset];
      }
      long long v45 = *(void **)(a1 + 72);
      double v46 = 0.25;
      long long v18 = v13;
      if (a4 >= 0.25)
      {
        *(float *)&double v46 = a4;
        if (![v45 shouldUpdateWithProgress:v46])
        {
LABEL_18:
          uint64_t v28 = 0;
LABEL_38:
          int v44 = 0;
          uint64_t v32 = -1;
          goto LABEL_49;
        }
        uint64_t v32 = (uint64_t)[*(id *)(a1 + 72) minutesRemaining];
        [*(id *)(a1 + 48) setEstimatedTimeRemaining:v32];
        id v50 = *(void **)(a1 + 40);
        uint64_t v51 = (uint64_t)[*(id *)(a1 + 80) bytesRemaining];
        uint64_t v48 = *(void *)(a1 + 48);
        uint64_t v27 = *(unsigned __int8 *)(a1 + 96);
        unsigned int v47 = v50;
        *(float *)&double v49 = a4;
        uint64_t v52 = v32;
      }
      else
      {
        [v45 reset];
        unsigned int v47 = *(void **)(a1 + 40);
        uint64_t v48 = *(void *)(a1 + 48);
        uint64_t v27 = *(unsigned __int8 *)(a1 + 96);
        uint64_t v32 = -1;
        *(float *)&double v49 = a4;
LABEL_46:
        uint64_t v52 = -1;
        uint64_t v51 = -1;
      }
      objc_msgSend(v47, "_didUpdateBackupProgress:estimatedTimeRemaining:bytesRemaining:engineState:stateInfo:isInitialMegaBackup:", v52, v51, v12, v48, v27, v49, v59);
      uint64_t v28 = 0;
LABEL_48:
      int v44 = 1;
LABEL_49:
      uint64_t v53 = *(NSObject **)(*(void *)(a1 + 40) + 16);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000B8234;
      block[3] = &unk_100412B28;
      id v67 = *(id *)(a1 + 88);
      id v68 = *(id *)(a1 + 48);
      char v69 = *(unsigned char *)(a1 + 96);
      dispatch_async(v53, block);
      if (a2 - 2 <= 2)
      {
        if (v32 == -1) {
          uint64_t v32 = (uint64_t)[*(id *)(a1 + 72) minutesRemaining];
        }
        id v54 = *(NSObject **)(*(void *)(a1 + 40) + 16);
        v64[0] = _NSConcreteStackBlock;
        v64[1] = 3221225472;
        v64[2] = sub_1000B8284;
        v64[3] = &unk_100411128;
        id v65 = *(id *)(a1 + 88);
        dispatch_async(v54, v64);
        [*(id *)(a1 + 88) setNextBackupSize:0];
        [v63 suspend];
        [(id)objc_opt_class() saveBackupStateInfo:*(void *)(a1 + 48) forInitialMegaBackup:0 account:*(void *)(a1 + 64)];
        if (*(unsigned char *)(a1 + 96)) {
          [(id)objc_opt_class() saveBackupStateInfo:*(void *)(a1 + 48) forInitialMegaBackup:1 account:*(void *)(a1 + 64)];
        }
        +[MBBackupScheduler postBackupCompletionNotificationWithAccount:completionError:](MBBackupScheduler, "postBackupCompletionNotificationWithAccount:completionError:", *(void *)(a1 + 64), v28, v59);

        int v44 = 1;
      }
      uint64_t v55 = +[MBNotificationCenter sharedNotificationCenter];
      objc_msgSend(v55, "postNotification:ifStateChanged:", kMBManagerBackupStateChangedNotification, objc_msgSend(*(id *)(a1 + 48), "state"));

      if (!v44) {
        goto LABEL_63;
      }
      if (v32 == -1)
      {
        id v58 = MBGetDefaultLog();
        if (!os_log_type_enabled(v58, OS_LOG_TYPE_INFO)) {
          goto LABEL_62;
        }
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)long long v71 = a2;
        *(_WORD *)&v71[4] = 2048;
        *(double *)&v71[6] = a4;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_INFO, "p:%d|%0.2f|?|?", buf, 0x12u);
      }
      else
      {
        [*(id *)(a1 + 72) secondsRemaining];
        uint64_t v57 = v56;
        id v58 = MBGetDefaultLog();
        if (!os_log_type_enabled(v58, OS_LOG_TYPE_INFO)) {
          goto LABEL_62;
        }
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)long long v71 = a2;
        *(_WORD *)&v71[4] = 2048;
        *(double *)&v71[6] = a4;
        __int16 v72 = 2048;
        uint64_t v73 = v57;
        __int16 v74 = 2048;
        uint64_t v75 = v32;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_INFO, "p:%d|%0.2f|%.0fs|%lum", buf, 0x26u);
      }
      _MBLog();
LABEL_62:

LABEL_63:
      return;
    case 2u:
      [v11 resume];
      [*(id *)(a1 + 48) setState:4];
      LODWORD(v30) = 1.0;
      [*(id *)(a1 + 48) setProgress:v30];
      [*(id *)(a1 + 48) setEstimatedTimeRemaining:0];
      id v31 = +[MBError errorWithCode:0 format:@"Backup succeeded"];
      uint64_t v28 = MBSanitizeErrorWithDate(v31);
      [*(id *)(a1 + 48) setError:v28];

      [*(id *)(a1 + 48) setBackupAttemptCount:0];
      uint64_t v32 = (uint64_t)[*(id *)(a1 + 72) minutesRemaining];
      [*(id *)(a1 + 48) setEstimatedTimeRemaining:v32];
      LODWORD(v33) = 1.0;
      [*(id *)(a1 + 40) _didUpdateBackupProgress:v32 estimatedTimeRemaining:0 bytesRemaining:v12 engineState:*(void *)(a1 + 48) stateInfo:*(unsigned __int8 *)(a1 + 96) isInitialMegaBackup:v33];
      if (!*(unsigned char *)(a1 + 96)) {
        goto LABEL_31;
      }
      [*(id *)(a1 + 40) _updateMegaBackupStatus:1 account:*(void *)(a1 + 64)];
      [*(id *)(a1 + 40) _setIsInitialMegaBackupCompleted:1];
      [(id)objc_opt_class() saveBackupStateInfo:*(void *)(a1 + 48) forInitialMegaBackup:1 account:*(void *)(a1 + 64)];
      id v34 = [*(id *)(a1 + 40) prebuddyFollowUpTimer];
      if (v34) {
        goto LABEL_26;
      }
      if ([*(id *)(a1 + 40) isPrebuddyMode])
      {
        id v34 = [*(id *)(a1 + 40) prebuddyFollowUpTimerForAccount:*(void *)(a1 + 64)];
        [*(id *)(a1 + 40) setPrebuddyFollowUpTimer:v34];
LABEL_26:
      }
      id v35 = v13;
      uint64_t v60 = v12;
      id v62 = v7;
      uint64_t v36 = objc_msgSend(*(id *)(a1 + 64), "persona", v59);
      id v37 = [v36 copyPreferencesValueForKey:@"MegaBackupFlowStartDate" class:objc_opt_class()];
      id v38 = [v36 copyPreferencesValueForKey:@"InitialMegaBackupFinishedDateDelta" class:objc_opt_class()];
      uint64_t v39 = v38;
      if (v37 && !v38)
      {
        uint64_t v40 = +[NSDate now];
        [v40 timeIntervalSinceDate:v37];
        long long v42 = +[NSNumber numberWithInt:(int)v41];
        [v36 setPreferencesValue:v42 forKey:@"InitialMegaBackupFinishedDateDelta"];
      }
      [*(id *)(a1 + 40) submitMegaLifeCycleTelemetriesWithAccount:*(void *)(a1 + 64)];

      id v12 = v60;
      id v7 = v62;
      char v13 = v35;
LABEL_31:
      long long v18 = v13;
      objc_msgSend(v13, "managerDidFinishBackup:", *(void *)(a1 + 40), v59);
      goto LABEL_48;
    case 3u:
      __assert_rtn("-[MBCKManager _startBackupWithEngine:account:]_block_invoke", "MBCKManager.m", 1977, "0 && \"Unexpected state\"");
    case 4u:
      [v11 resume];
      [*(id *)(a1 + 48) setState:6];
      uint64_t v28 = MBSanitizeErrorWithDate(v7);
      [*(id *)(a1 + 48) setError:v28];
      if ([*(id *)(a1 + 40) isPrebuddyMode] && *(unsigned char *)(a1 + 96))
      {
        long long v43 = [*(id *)(a1 + 40) prebuddyFollowUpController];
        [v43 updateFollowupWithBackupProgress:*(void *)(a1 + 48)];
      }
      objc_msgSend(v13, "manager:didFailBackupWithError:", *(void *)(a1 + 40), v7, v59);
      if (+[MBError isError:v7 withCode:204]) {
        [*(id *)(a1 + 40) _syncBackupEnabledWithAccount:*(void *)(a1 + 64) connection:0];
      }
      long long v18 = v13;
      objc_msgSend(*(id *)(a1 + 48), "setBackupAttemptCount:", (char *)objc_msgSend(*(id *)(a1 + 48), "backupAttemptCount") + 1);
      goto LABEL_38;
    default:
      long long v18 = v13;
      goto LABEL_18;
  }
}

id sub_1000B8234(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) setBackup:*(void *)(a1 + 40)];
  if (*(unsigned char *)(a1 + 48))
  {
    unsigned int v3 = *(void **)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    return [v3 setInitialMegaBackup:v4];
  }
  return result;
}

id sub_1000B8284(uint64_t a1)
{
  return [*(id *)(a1 + 32) setServiceState:0];
}

void sub_1000B8AEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000B8B34(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@ fired. Updating prebuddy followup", buf, 0xCu);
      _MBLog();
    }

    [WeakRetained updatePrebuddyFollowUp:*(void *)(a1 + 32)];
  }
}

void sub_1000B9510(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1000B9574(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 16));
  uint64_t v4 = *(void **)(a1 + 40);
  if (!v4) {
    __assert_rtn("-[MBCKManager deleteBackupUDID:disableIfCurrentDevice:account:connection:error:]_block_invoke", "MBCKManager.m", 2225, "device");
  }
  if (v3) {
    objc_exception_throw([objc_alloc((Class)MBException) initWithCode:1 format:@"Timed out while canceling engines"]);
  }
  id v5 = [v4 pendingSnapshotQuotaReserved];
  if (v5)
  {
    id v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138543362;
      uint64_t v38 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Clearing pending snapshot for %{public}@", buf, 0xCu);
      uint64_t v32 = *(void *)(a1 + 48);
      _MBLog();
    }

    [*(id *)(a1 + 40) clearPendingSnapshotAndRebuildFileChanges:1];
  }
  if (*(unsigned char *)(a1 + 112)
    && [*(id *)(a1 + 40) hasBackupEnabledState]
    && [*(id *)(a1 + 40) backupEnabled])
  {
    id v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138543362;
      uint64_t v38 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Turning off backupEnabled in the device record for %{public}@", buf, 0xCu);
      uint64_t v32 = *(void *)(a1 + 48);
      _MBLog();
    }
  }
  else if (!v5)
  {
    goto LABEL_18;
  }
  CFStringRef v10 = *(void **)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v12 = *(void *)(*(void *)(a1 + 96) + 8);
  id obj = *(id *)(v12 + 40);
  unsigned __int8 v13 = objc_msgSend(v10, "saveWithOperationTracker:error:", v11, &obj, v32);
  objc_storeStrong((id *)(v12 + 40), obj);
  if ((v13 & 1) == 0)
  {
    float v14 = MBGetDefaultLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = *(void *)(a1 + 48);
      uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
      *(_DWORD *)buf = 138543618;
      uint64_t v38 = v15;
      __int16 v39 = 2112;
      uint64_t v40 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to save the device record for %{public}@: %@", buf, 0x16u);
      uint64_t v32 = *(void *)(a1 + 48);
      uint64_t v33 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
      _MBLog();
    }

    uint64_t v17 = *(void *)(*(void *)(a1 + 96) + 8);
    long long v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = 0;
  }
LABEL_18:
  if (*(unsigned char *)(a1 + 112)) {
    [*(id *)(a1 + 32) setBackupEnabled:0 account:*(void *)(a1 + 64) connection:*(void *)(a1 + 72)];
  }
  long long v19 = *(void **)(a1 + 32);
  uint64_t v20 = *(void *)(a1 + 64);
  uint64_t v21 = *(void *)(*(void *)(a1 + 96) + 8);
  id v35 = *(id *)(v21 + 40);
  unsigned __int8 v22 = objc_msgSend(v19, "resetCacheWithAccount:error:", v20, &v35, v32, v33);
  objc_storeStrong((id *)(v21 + 40), v35);
  if ((v22 & 1) == 0)
  {
    uint64_t v28 = MBGetDefaultLog();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      uint64_t v29 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
      *(_DWORD *)buf = 138412290;
      uint64_t v38 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to reset the cache: %@", buf, 0xCu);
LABEL_27:
      _MBLog();
    }
LABEL_28:

    goto LABEL_29;
  }
  id v23 = *(void **)(a1 + 80);
  uint64_t v25 = *(void *)(a1 + 48);
  uint64_t v24 = *(void *)(a1 + 56);
  uint64_t v26 = *(void *)(*(void *)(a1 + 96) + 8);
  id v34 = *(id *)(v26 + 40);
  unsigned __int8 v27 = [v23 deleteDeviceWithOperationTracker:v24 deviceUUID:v25 error:&v34];
  objc_storeStrong((id *)(v26 + 40), v34);
  if ((v27 & 1) == 0)
  {
    uint64_t v28 = MBGetDefaultLog();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v31 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
      *(_DWORD *)buf = 138543618;
      uint64_t v38 = v30;
      __int16 v39 = 2112;
      uint64_t v40 = v31;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to delete the device record for %{public}@: %@", buf, 0x16u);
      goto LABEL_27;
    }
    goto LABEL_28;
  }
  [*(id *)(a1 + 32) clearPrebuddyWithAccount:*(void *)(a1 + 64) accountSignOut:0];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 1;
LABEL_29:
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 88));
}

void sub_1000B99F8(void *a1)
{
  id v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = *(void *)(a1[7] + 8);
  id obj = *(id *)(v5 + 40);
  unsigned __int8 v6 = [v2 deleteDeviceWithOperationTracker:v3 deviceUUID:v4 error:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  if (v6)
  {
    *(unsigned char *)(*(void *)(a1[8] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = a1[6];
      uint64_t v9 = *(void *)(*(void *)(a1[7] + 8) + 40);
      *(_DWORD *)buf = 138543618;
      uint64_t v12 = v8;
      __int16 v13 = 2112;
      uint64_t v14 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to delete the device record for %{public}@: %@", buf, 0x16u);
      _MBLog();
    }
  }
}

void sub_1000B9D80(id a1, NSString *a2, MBCKSnapshotToDomainRecordReference *a3, BOOL a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = MBGetDefaultLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Synchronizing %@", buf, 0xCu);
    _MBLog();
  }
}

void sub_1000BAD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x220], 8);
  _Unwind_Resume(a1);
}

id sub_1000BADD4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) restoreSession];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  id result = [*(id *)(a1 + 32) finishedAppRestores];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = (_BYTE)result;
  return result;
}

id sub_1000BB364(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = [*(id *)(a1 + 32) accountIdentifier];
    *(_DWORD *)buf = 138412290;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Cellular access changed for account %@ - retrying pending downloads if necessary", buf, 0xCu);

    uint64_t v9 = [*(id *)(a1 + 32) accountIdentifier];
    _MBLog();
  }
  return objc_msgSend(*(id *)(a1 + 40), "_retryAppDataDownloadsWithConnectivity:account:", a2, a3, *(void *)(a1 + 32));
}

void sub_1000BBB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1000BBBD0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) restoreSession];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  uint64_t v5 = [*(id *)(a1 + 32) lockManager];
  uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  id v11 = [*(id *)(a1 + 32) restoreQosByContext];
  uint64_t v8 = [v11 objectForKey:*(void *)(a1 + 40)];
  uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
  CFStringRef v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_1000BC160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1000BC1B0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) restoreSession];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  uint64_t v5 = [*(id *)(a1 + 32) lockManager];
  uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  id v11 = [*(id *)(a1 + 32) restoreQosByContext];
  uint64_t v8 = [v11 objectForKey:*(void *)(a1 + 40)];
  uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
  CFStringRef v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_1000BC7E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

uint64_t sub_1000BC844(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) restoreSession];
  return _objc_release_x1();
}

void sub_1000BCF4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000BCF9C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) restoreSession];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = [*(id *)(a1 + 32) lockManager];
  return _objc_release_x1();
}

void sub_1000BD568(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1000BD5A4(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState] != 5)
  {
    uint64_t v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v9 = [*(id *)(a1 + 32) serviceState];
      CFStringRef v10 = [*(id *)(a1 + 40) restoreMode];
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)int v44 = v9;
      *(_WORD *)&v44[4] = 2114;
      *(void *)&v44[6] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Ignoring background restore request while not in restore session (%d): %{public}@", buf, 0x12u);

      id v11 = [*(id *)(a1 + 32) serviceState];
      [*(id *)(a1 + 40) restoreMode];
      v37 = id v35 = v11;
      _MBLog();
    }
    CFStringRef v6 = @"Manager not in restore session";
    uint64_t v7 = 204;
    goto LABEL_9;
  }
  uint64_t v2 = [*(id *)(a1 + 32) enginesByContext];
  uint64_t v3 = [v2 objectForKey:*(void *)(a1 + 48)];

  if (v3)
  {
    uint64_t v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138412290;
      *(void *)int v44 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ignoring multiple concurrent request made from client %@", buf, 0xCu);
      id v35 = *(id *)(a1 + 48);
      _MBLog();
    }

    CFStringRef v6 = @"Restore request exists for client";
    uint64_t v7 = 3;
LABEL_9:
    uint64_t v12 = +[MBError errorWithCode:format:](MBError, "errorWithCode:format:", v7, v6, v35, v37);
    uint64_t v13 = *(void *)(*(void *)(a1 + 80) + 8);
    uint64_t v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = v12;
    goto LABEL_10;
  }
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v14 = [*(id *)(a1 + 32) engines];
  id v15 = [v14 countByEnumeratingWithState:&v38 objects:v42 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = *(void *)v39;
    while (2)
    {
      for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v39 != v17) {
          objc_enumerationMutation(v14);
        }
        long long v19 = *(void **)(*((void *)&v38 + 1) + 8 * i);
        uint64_t v20 = [*(id *)(a1 + 40) restoreMode];
        uint64_t v21 = [v19 context];
        unsigned __int8 v22 = [v21 restoreMode];
        unsigned int v23 = [v20 isEqual:v22];

        if (v23)
        {
          uint64_t v29 = MBGetDefaultLog();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v30 = [*(id *)(a1 + 40) restoreMode];
            *(_DWORD *)buf = 138412290;
            *(void *)int v44 = v30;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Ignoring duplicate background restore request: %@", buf, 0xCu);

            uint64_t v36 = [*(id *)(a1 + 40) restoreMode];
            _MBLog();
          }
          uint64_t v31 = [*(id *)(a1 + 40) restoreMode];
          uint64_t v32 = +[MBError errorWithCode:3, @"Manager already background restoring %@", v31 format];
          uint64_t v33 = *(void *)(*(void *)(a1 + 80) + 8);
          id v34 = *(void **)(v33 + 40);
          *(void *)(v33 + 40) = v32;

          goto LABEL_10;
        }
      }
      id v16 = [v14 countByEnumeratingWithState:&v38 objects:v42 count:16];
      if (v16) {
        continue;
      }
      break;
    }
  }

  uint64_t v24 = *(void **)(a1 + 56);
  uint64_t v25 = *(void *)(a1 + 40);
  uint64_t v26 = [v24 debugContext];
  uint64_t v14 = [v24 _restoreEngineWithRestoreType:2 settingsContext:v25 debugContext:v26 excludedAppBundleIDs:0];

  [v14 setCkOperationGroup:*(void *)(a1 + 64)];
  [v14 setCkOperationPolicy:*(void *)(a1 + 72)];
  [v14 setCkOperationTracker:0];
  uint64_t v27 = [*(id *)(a1 + 32) restoreLogger];
  [v14 setRestoreLogger:v27];

  [*(id *)(a1 + 56) _startRestoreWithEngine:v14 delegateContext:*(void *)(a1 + 48)];
  uint64_t v28 = [*(id *)(a1 + 56) serviceDelegate];
  [v28 manager:*(void *)(a1 + 56) didUpdateBackgroundRestoreWithContext:0];

  *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 1;
LABEL_10:
}

void sub_1000BE310(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Block_object_dispose((const void *)(v1 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_1000BE33C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState])
  {
    uint64_t v2 = MBGetDefaultLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v3 = [*(id *)(a1 + 32) serviceState];
      *(_DWORD *)buf = 67109120;
      LODWORD(v49) = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Ignoring restore request while busy (%d)", buf, 8u);
      [*(id *)(a1 + 32) serviceState];
      _MBLog();
    }

    uint64_t v4 = +[MBError errorWithCode:14 format:@"Manager not in idle state"];
    uint64_t v5 = *(void *)(*(void *)(a1 + 128) + 8);
    CFStringRef v6 = *(MBCKLockManager **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
  else
  {
    uint64_t v7 = [MBCKLockManager alloc];
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    CFStringRef v10 = [*(id *)(a1 + 56) databaseManager];
    id v11 = *(void **)(a1 + 56);
    uint64_t v12 = *(void *)(a1 + 64);
    uint64_t v13 = [v11 thermalPressureMonitor];
    CFStringRef v6 = [(MBCKLockManager *)v7 initWithAccount:v8 restoreType:1 backupUDID:v9 databaseManager:v10 delegate:v11 operationGroup:v12 thermalPressureMonitor:v13 snapshotUUID:*(void *)(a1 + 72)];

    [*(id *)(a1 + 32) setLockManager:v6];
    uint64_t v14 = [*(id *)(a1 + 56) _ckSettingsContextForRestoreWithDeviceUUID:*(void *)(a1 + 48) account:*(void *)(a1 + 40) delegateContext:0];
    [v14 setLockManager:v6];
    [v14 setSnapshotID:*(void *)(a1 + 144)];
    [v14 setSnapshotUUID:*(void *)(a1 + 72)];
    [v14 setRestoreMode:*(void *)(a1 + 80)];
    if (MBIsInternalInstall())
    {
      id v15 = +[MBBehaviorOptions sharedOptions];
      unsigned int v16 = [v15 useRestoreOperationLog];

      if (v16)
      {
        uint64_t v17 = MBGetDefaultLog();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "Using restore operation log for foreground restore", buf, 2u);
          _MBLog();
        }

        long long v18 = [MBRestoreOperationLogger alloc];
        long long v19 = [*(id *)(a1 + 88) restoreOperationLogPath];
        uint64_t v20 = [(MBRestoreOperationLogger *)v18 initWithPath:v19];
        [*(id *)(a1 + 32) setRestoreLogger:v20];
      }
    }
    uint64_t v21 = (void *)os_transaction_create();
    [*(id *)(a1 + 32) setRestoreTransaction:v21];

    [*(id *)(a1 + 32) setServiceState:4];
    unsigned __int8 v22 = *(void **)(a1 + 56);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 72);
    id v47 = 0;
    unsigned __int8 v25 = [v22 setupRestorePlanForAccount:v23 snapshotUUID:v24 error:&v47];
    id v26 = v47;
    uint64_t v27 = v26;
    if (v25)
    {
      uint64_t v28 = [*(id *)(a1 + 32) restore];
      [v28 setState:1];
      [v28 setIsBackground:0];
      [v28 setProgress:0.0];
      [v28 setEstimatedTimeRemaining:-1];
      [v28 setError:0];
      uint64_t v29 = [MBServiceRestoreSession alloc];
      uint64_t v30 = [*(id *)(a1 + 88) personaIdentifier];
      uint64_t v31 = [(MBServiceRestoreSession *)v29 initWithPersonaIdentifier:v30];

      [(MBServiceRestoreSession *)v31 setBackupUDID:*(void *)(a1 + 48)];
      [(MBServiceRestoreSession *)v31 setSnapshotID:*(void *)(a1 + 144)];
      [(MBServiceRestoreSession *)v31 setSnapshotUUID:*(void *)(a1 + 72)];
      [(MBServiceRestoreSession *)v31 setTelemetryID:*(void *)(*(void *)(a1 + 56) + 232)];
      [*(id *)(a1 + 32) setRestoreSession:v31];
      if ([(MBServiceRestoreSession *)v31 isMBSSession]) {
        __assert_rtn("-[MBCKManager startRestoreForSnapshot:options:account:connection:error:]_block_invoke", "MBCKManager.m", 2914, "!restoreSession.isMBSSession");
      }
      uint64_t v32 = MBGetDefaultLog();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = [*(id *)(a1 + 40) accountIdentifier];
        id v34 = [*(id *)(a1 + 88) personaIdentifier];
        id v35 = [(MBServiceRestoreSession *)v31 propertyList];
        *(_DWORD *)buf = 138544130;
        double v49 = v33;
        __int16 v50 = 2114;
        uint64_t v51 = v34;
        __int16 v52 = 2048;
        uint64_t v53 = v31;
        __int16 v54 = 2114;
        uint64_t v55 = v35;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Created new restore session for account %{public}@(%{public}@): (%p) %{public}@", buf, 0x2Au);

        uint64_t v36 = [*(id *)(a1 + 40) accountIdentifier];
        id v37 = [*(id *)(a1 + 88) personaIdentifier];
        double v46 = [(MBServiceRestoreSession *)v31 propertyList];
        _MBLog();
      }
      long long v38 = +[MBCKRemoteConfiguration sharedInstance];
      [v38 resetCachedConfigurationForAccount:*(void *)(a1 + 40)];

      [(MBCKLockManager *)v6 startRenewingLock];
      long long v39 = *(void **)(a1 + 56);
      long long v40 = [v39 debugContext];
      long long v41 = [*(id *)(a1 + 96) excludedAppBundleIDs];
      long long v42 = [v39 _restoreEngineWithRestoreType:1 settingsContext:v14 debugContext:v40 excludedAppBundleIDs:v41];

      [v42 setCkOperationGroup:*(void *)(a1 + 64)];
      [v42 setCkOperationPolicy:*(void *)(a1 + 104)];
      [v42 setCkOperationTracker:*(void *)(a1 + 112)];
      long long v43 = [*(id *)(a1 + 32) restoreLogger];
      [v42 setRestoreLogger:v43];

      [*(id *)(a1 + 56) _startRestoreWithEngine:v42 delegateContext:*(void *)(a1 + 120)];
      *(unsigned char *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) = 1;
    }
    else
    {
      uint64_t v44 = *(void *)(*(void *)(a1 + 128) + 8);
      id v45 = v26;
      uint64_t v28 = *(void **)(v44 + 40);
      *(void *)(v44 + 40) = v45;
    }
  }
}

void sub_1000BEF4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1000BEF80(id a1)
{
  unsigned int v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.backupd.fetchDeviceForRestore", v3);
  uint64_t v2 = (void *)qword_1004823F8;
  qword_1004823F8 = (uint64_t)v1;
}

void sub_1000BEFE4(uint64_t a1)
{
  uint64_t v65 = 0;
  long long v66 = &v65;
  uint64_t v67 = 0x2020000000;
  char v68 = 0;
  uint64_t v2 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BF78C;
  block[3] = &unk_100412350;
  uint64_t v63 = *(void *)(a1 + 72);
  id v62 = *(id *)(a1 + 40);
  uint64_t v64 = &v65;
  dispatch_sync(v2, block);
  uint64_t v3 = *(void *)(a1 + 72);
  if (*(unsigned char *)(a1 + 88) || (long long v43 = *(void **)(*(void *)(v3 + 8) + 40)) == 0)
  {
LABEL_2:
    uint64_t v4 = *(void *)(v3 + 8);
    uint64_t v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = 0;

    CFStringRef v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void **)(a1 + 48);
      *(_DWORD *)buf = 138412290;
      long long v70 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Fetching device for restore %@", buf, 0xCu);
      uint64_t v53 = *(void *)(a1 + 48);
      _MBLog();
    }

    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(void *)(a1 + 64);
    uint64_t v10 = *(void *)(*(void *)(a1 + 80) + 8);
    id obj = *(id *)(v10 + 40);
    id v11 = +[MBCKAccount fetchAccountWithOperationTracker:v8 cache:v9 error:&obj];
    objc_storeStrong((id *)(v10 + 40), obj);
    uint64_t v12 = *(void *)(*(void *)(a1 + 80) + 8);
    id v15 = *(void **)(v12 + 40);
    uint64_t v14 = (id *)(v12 + 40);
    uint64_t v13 = v15;
    if (v11)
    {
      uint64_t v16 = *(void *)(a1 + 56);
      id v59 = v13;
      unsigned int v17 = [v11 fetchDevicesWithOperationTracker:v16 error:&v59];
      objc_storeStrong(v14, v59);
      if (!v17) {
        goto LABEL_30;
      }
      uint64_t v18 = [v11 deviceForUUID:*(void *)(a1 + 48)];
      uint64_t v19 = *(void *)(*(void *)(a1 + 72) + 8);
      uint64_t v20 = *(void **)(v19 + 40);
      *(void *)(v19 + 40) = v18;

      uint64_t v21 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
      if (v21)
      {
        uint64_t v22 = *(void *)(a1 + 56);
        uint64_t v23 = *(void *)(*(void *)(a1 + 80) + 8);
        id v58 = *(id *)(v23 + 40);
        unsigned __int8 v24 = [v21 fetchSnapshotsWithOperationTracker:v22 error:&v58];
        objc_storeStrong((id *)(v23 + 40), v58);
        if (v24)
        {
          if (*((unsigned char *)v66 + 24)) {
            goto LABEL_10;
          }
          unsigned __int8 v25 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) keybagManager];
          uint64_t v26 = *(void *)(a1 + 56);
          uint64_t v27 = *(void *)(*(void *)(a1 + 80) + 8);
          id v57 = *(id *)(v27 + 40);
          unsigned __int8 v28 = [v25 fetchKeybagsWithOperationTracker:v26 error:&v57];
          objc_storeStrong((id *)(v27 + 40), v57);

          if (v28)
          {
LABEL_10:
            uint64_t v29 = objc_msgSend(*(id *)(a1 + 32), "debugContext", v53);
            [v29 setFlag:@"DidFetchDeviceDuringRestore"];

            uint64_t v30 = MBGetDefaultLog();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v31 = v30;
              if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v32 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) deviceUUID];
                uint64_t v33 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) keybagManager];
                id v34 = [v33 keybagsByUUIDString];
                id v35 = [v34 count];
                *(_DWORD *)buf = 138543618;
                long long v70 = v32;
                __int16 v71 = 2048;
                id v72 = v35;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Fetched device for restore: %{public}@ keybagCount: %lu", buf, 0x16u);
              }
              uint64_t v36 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) deviceUUID];
              id v37 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) keybagManager];
              long long v38 = [v37 keybagsByUUIDString];
              [v38 count];
              _MBLog();
            }
            long long v39 = *(NSObject **)(*(void *)(a1 + 32) + 16);
            v54[0] = _NSConcreteStackBlock;
            v54[1] = 3221225472;
            v54[2] = sub_1000BF810;
            v54[3] = &unk_100411100;
            long long v40 = *(id *)(a1 + 40);
            uint64_t v41 = *(void *)(a1 + 72);
            uint64_t v55 = v40;
            uint64_t v56 = v41;
            dispatch_sync(v39, v54);
            long long v42 = v55;
          }
          else
          {
            long long v42 = MBGetDefaultLog();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v52 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
              *(_DWORD *)buf = 138412290;
              long long v70 = v52;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Failed to fetch keybags: %@", buf, 0xCu);
              _MBLog();
            }
          }
        }
        else
        {
          long long v42 = MBGetDefaultLog();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            uint64_t v51 = *(void **)(a1 + 48);
            *(_DWORD *)buf = 138543362;
            long long v70 = v51;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Failed to prefetch snapshots for for %{public}@", buf, 0xCu);
            _MBLog();
          }
        }
        goto LABEL_29;
      }
      uint64_t v48 = MBGetDefaultLog();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        double v49 = *(void **)(a1 + 48);
        *(_DWORD *)buf = 138543362;
        long long v70 = v49;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "No device record found for %{public}@", buf, 0xCu);
        _MBLog();
      }

      uint64_t v47 = +[MBError errorWithCode:204 format:@"No backups found"];
    }
    else
    {
      if (!+[MBError isCKNotFoundError:v13])
      {
        id v11 = 0;
        goto LABEL_30;
      }
      uint64_t v47 = +[MBError errorWithCode:210 format:@"No account found"];
      id v11 = 0;
    }
    uint64_t v50 = *(void *)(*(void *)(a1 + 80) + 8);
    long long v42 = *(NSObject **)(v50 + 40);
    *(void *)(v50 + 40) = v47;
LABEL_29:

    goto LABEL_30;
  }
  uint64_t v44 = [v43 deviceUUID];
  unsigned __int8 v45 = [v44 isEqualToString:*(void *)(a1 + 48)];

  if ((v45 & 1) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 72);
    goto LABEL_2;
  }
  id v11 = MBGetDefaultLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    id v11 = v11;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      double v46 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) deviceUUID];
      *(_DWORD *)buf = 138543362;
      long long v70 = v46;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Found cached restore device: %{public}@", buf, 0xCu);
    }
    long long v42 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) deviceUUID];
    _MBLog();
    goto LABEL_29;
  }
LABEL_30:

  _Block_object_dispose(&v65, 8);
}

void sub_1000BF72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1000BF78C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) deviceForRestore];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  id v5 = [*(id *)(a1 + 32) restoreKeyBagsByID];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v5 count] != 0;
}

id sub_1000BF810(uint64_t a1)
{
  return [*(id *)(a1 + 32) setDeviceForRestore:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
}

void sub_1000BFDFC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

id sub_1000BFE1C(uint64_t a1)
{
  [*(id *)(a1 + 32) setServiceState:0];
  uint64_t v2 = [*(id *)(a1 + 32) lockManager];
  [v2 stopRenewingLock];

  uint64_t v3 = *(void **)(a1 + 32);
  return [v3 clearRestoreSession];
}

void sub_1000BFE74(uint64_t a1, unsigned int a2, void *a3, double a4)
{
  id v7 = a3;
  dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 16));
  uint64_t v8 = MBGetDefaultLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    if (a2 > 4) {
      CFStringRef v9 = @"unknown";
    }
    else {
      CFStringRef v9 = *(&off_100412B98 + (int)a2);
    }
    *(_DWORD *)buf = 138412290;
    *(void *)char v83 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Engine callback (%@)", buf, 0xCu);
    if (a2 > 4) {
      CFStringRef v10 = @"unknown";
    }
    else {
      CFStringRef v10 = *(&off_100412B98 + (int)a2);
    }
    CFStringRef v48 = v10;
    _MBLog();
  }

  if (*(unsigned char *)(a1 + 104))
  {
    id v11 = *(NSObject **)(*(void *)(a1 + 32) + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000C084C;
    block[3] = &unk_100412A88;
    id v80 = *(id *)(a1 + 40);
    double v81 = a4;
    dispatch_sync(v11, block);
  }
  uint64_t v12 = objc_msgSend(*(id *)(a1 + 32), "serviceDelegate", v48);
  switch(a2)
  {
    case 0u:
      if (!*(void *)(a1 + 48))
      {
        uint64_t v14 = 0;
        goto LABEL_34;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v14 = *(void *)(a1 + 48);
LABEL_34:
        *(float *)&double v13 = a4;
        uint64_t v17 = -1;
        [v12 manager:*(void *)(a1 + 32) didUpdateProgress:-1 estimatedTimeRemaining:v14 context:v13];
        goto LABEL_57;
      }
      uint64_t v30 = [*(id *)(a1 + 56) installCoordinator];

      if (v30)
      {
        uint64_t v31 = [*(id *)(a1 + 56) installCoordinator];
        [v31 updateProgress:0.0];
      }
LABEL_37:
      char v19 = 0;
      uint64_t v17 = -1;
LABEL_58:
      *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = a2;
      int v41 = *(unsigned __int8 *)(a1 + 104);
      if (!*(unsigned char *)(a1 + 106)) {
        goto LABEL_61;
      }
      if (!*(unsigned char *)(a1 + 104)) {
        goto LABEL_72;
      }
      long long v42 = +[MBNotificationCenter sharedNotificationCenter];
      objc_msgSend(v42, "postNotification:ifStateChanged:", kMBManagerRestoreStateChangedNotification, objc_msgSend(*(id *)(a1 + 40), "state"));

      int v41 = *(unsigned __int8 *)(a1 + 104);
LABEL_61:
      BOOL v43 = v41 == 0;
      char v44 = v19 ^ 1;
      if (v43) {
        char v44 = 1;
      }
      if (v44) {
        goto LABEL_72;
      }
      if (v17 == -1)
      {
        uint64_t v47 = MBGetDefaultLog();
        if (!os_log_type_enabled(v47, OS_LOG_TYPE_INFO)) {
          goto LABEL_71;
        }
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)char v83 = a2;
        *(_WORD *)&v83[4] = 2048;
        *(double *)&v83[6] = a4;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_INFO, "p:%d|%0.2f|?|?", buf, 0x12u);
      }
      else
      {
        [*(id *)(a1 + 64) secondsRemaining];
        uint64_t v46 = v45;
        uint64_t v47 = MBGetDefaultLog();
        if (!os_log_type_enabled(v47, OS_LOG_TYPE_INFO)) {
          goto LABEL_71;
        }
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)char v83 = a2;
        *(_WORD *)&v83[4] = 2048;
        *(double *)&v83[6] = a4;
        __int16 v84 = 2048;
        uint64_t v85 = v46;
        __int16 v86 = 2048;
        uint64_t v87 = v17;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_INFO, "p:%d|%0.2f|%.0fs|%lum", buf, 0x26u);
      }
      _MBLog();
LABEL_71:

LABEL_72:
      return;
    case 1u:
      if (*(unsigned char *)(a1 + 104))
      {
        id v15 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        v77[0] = _NSConcreteStackBlock;
        v77[1] = 3221225472;
        v77[2] = sub_1000C085C;
        id v77[3] = &unk_100411128;
        id v78 = *(id *)(a1 + 40);
        dispatch_sync(v15, v77);
      }
      if (*(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) != 1) {
        [*(id *)(a1 + 64) reset];
      }
      float v16 = a4;
      *(float *)&double v13 = v16;
      if (![*(id *)(a1 + 64) shouldUpdateWithProgress:v13]) {
        goto LABEL_40;
      }
      if (*(void *)(a1 + 48) && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        uint64_t v32 = [*(id *)(a1 + 56) installCoordinator];

        if (v32)
        {
          uint64_t v33 = [*(id *)(a1 + 56) installCoordinator];
          [v33 updateProgress:a4];
        }
LABEL_40:
        char v19 = 0;
        uint64_t v17 = -1;
      }
      else
      {
        uint64_t v17 = (uint64_t)[*(id *)(a1 + 64) minutesRemaining];
        *(float *)&double v18 = a4;
        [v12 manager:*(void *)(a1 + 32) didUpdateProgress:v17 estimatedTimeRemaining:*(void *)(a1 + 48) context:v18];
        char v19 = 1;
      }
      if (*(unsigned char *)(a1 + 104))
      {
        if (v17 == -1) {
          uint64_t v17 = (uint64_t)[*(id *)(a1 + 64) minutesRemaining];
        }
        id v34 = *(NSObject **)(*(void *)(a1 + 32) + 16);
        v74[0] = _NSConcreteStackBlock;
        v74[1] = 3221225472;
        v74[2] = sub_1000C0868;
        v74[3] = &unk_100412A88;
        id v75 = *(id *)(a1 + 40);
        uint64_t v76 = v17;
        dispatch_sync(v34, v74);
      }
      goto LABEL_58;
    case 2u:
      if (!*(unsigned char *)(a1 + 104)) {
        goto LABEL_55;
      }
      if (!MBIsInternalInstall()) {
        goto LABEL_49;
      }
      uint64_t v20 = +[MBBehaviorOptions sharedOptions];
      unsigned int v21 = [v20 snapshotAfterForegroundRestore];

      if (!v21) {
        goto LABEL_49;
      }
      id v73 = 0;
      unsigned __int8 v22 = +[MBFileSystemManager createSnapshotForVolume:@"/private/var" name:@"snapshotAfterForegroundRestore" error:&v73 cancelationHandler:0];
      id v23 = v73;
      unsigned __int8 v24 = MBGetDefaultLog();
      unsigned __int8 v25 = v24;
      if (v22)
      {
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_48;
        }
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Created snapshotAfterForegroundRestore", buf, 2u);
      }
      else
      {
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          goto LABEL_48;
        }
        *(_DWORD *)buf = 138412290;
        *(void *)char v83 = v23;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Unable to create snapshot after foreground restore: %@", buf, 0xCu);
      }
      _MBLog();
LABEL_48:

LABEL_49:
      id v35 = *(NSObject **)(*(void *)(a1 + 32) + 16);
      v67[0] = _NSConcreteStackBlock;
      v67[1] = 3221225472;
      v67[2] = sub_1000C0870;
      v67[3] = &unk_100412460;
      char v72 = *(unsigned char *)(a1 + 105);
      uint64_t v27 = &v68;
      id v68 = *(id *)(a1 + 40);
      id v36 = *(id *)(a1 + 72);
      uint64_t v37 = *(void *)(a1 + 32);
      id v69 = v36;
      uint64_t v70 = v37;
      id v71 = *(id *)(a1 + 80);
      dispatch_sync(v35, v67);

      uint64_t v29 = v69;
LABEL_50:

LABEL_51:
      if (*(unsigned char *)(a1 + 104))
      {
        uint64_t v17 = (uint64_t)[*(id *)(a1 + 64) minutesRemaining];
        if (a2 == 4 && *(unsigned char *)(a1 + 104)) {
          [(id)objc_opt_class() saveRestoreStateInfo:*(void *)(a1 + 40) account:*(void *)(a1 + 80)];
        }
      }
      else
      {
LABEL_55:
        uint64_t v17 = -1;
      }
      long long v38 = *(NSObject **)(*(void *)(a1 + 32) + 16);
      v49[0] = _NSConcreteStackBlock;
      v49[1] = 3221225472;
      _OWORD v49[2] = sub_1000C0954;
      v49[3] = &unk_100412488;
      unsigned int v59 = a2;
      id v39 = *(id *)(a1 + 48);
      uint64_t v40 = *(void *)(a1 + 32);
      id v50 = v39;
      uint64_t v51 = v40;
      uint64_t v58 = v17;
      id v52 = *(id *)(a1 + 64);
      id v53 = *(id *)(a1 + 56);
      id v54 = *(id *)(a1 + 80);
      id v55 = v7;
      id v56 = *(id *)(a1 + 88);
      char v60 = *(unsigned char *)(a1 + 104);
      id v57 = *(id *)(a1 + 72);
      dispatch_async(v38, v49);

LABEL_57:
      char v19 = 1;
      goto LABEL_58;
    case 3u:
      if (!*(unsigned char *)(a1 + 104)) {
        goto LABEL_55;
      }
      uint64_t v26 = *(NSObject **)(*(void *)(a1 + 32) + 16);
      v65[0] = _NSConcreteStackBlock;
      v65[1] = 3221225472;
      v65[2] = sub_1000C08E4;
      v65[3] = &unk_100411128;
      uint64_t v27 = &v66;
      id v66 = *(id *)(a1 + 40);
      dispatch_sync(v26, v65);
      goto LABEL_51;
    case 4u:
      if (!*(unsigned char *)(a1 + 104)) {
        goto LABEL_55;
      }
      unsigned __int8 v28 = *(NSObject **)(*(void *)(a1 + 32) + 16);
      v61[0] = _NSConcreteStackBlock;
      v61[1] = 3221225472;
      v61[2] = sub_1000C08F0;
      v61[3] = &unk_100411358;
      uint64_t v27 = &v62;
      id v62 = *(id *)(a1 + 40);
      id v63 = v7;
      id v64 = *(id *)(a1 + 72);
      dispatch_sync(v28, v61);

      uint64_t v29 = v63;
      goto LABEL_50;
    default:
      goto LABEL_37;
  }
}

id sub_1000C084C(uint64_t a1)
{
  double v1 = *(double *)(a1 + 40);
  *(float *)&double v1 = v1;
  return [*(id *)(a1 + 32) setProgress:v1];
}

id sub_1000C085C(uint64_t a1)
{
  return [*(id *)(a1 + 32) setState:2];
}

id sub_1000C0868(uint64_t a1)
{
  return [*(id *)(a1 + 32) setEstimatedTimeRemaining:*(void *)(a1 + 40)];
}

id *sub_1000C0870(id *result)
{
  if (*((unsigned char *)result + 64))
  {
    double v1 = result;
    [result[4] setState:4];
    LODWORD(v2) = 1.0;
    [v1[4] setProgress:v2];
    [v1[4] setEstimatedTimeRemaining:0];
    [v1[5] setServiceState:0];
    [v1[5] setRestore:0];
    return (id *)[v1[6] loadRestoreStateWithAccount:v1[7]];
  }
  return result;
}

id sub_1000C08E4(uint64_t a1)
{
  return [*(id *)(a1 + 32) setState:5];
}

id sub_1000C08F0(uint64_t a1)
{
  [*(id *)(a1 + 32) setState:6];
  double v2 = MBSanitizeError(*(void **)(a1 + 40));
  [*(id *)(a1 + 32) setError:v2];

  uint64_t v3 = *(void **)(a1 + 48);
  return [v3 setServiceState:0];
}

id sub_1000C0954(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 104);
  if (v2 == 4)
  {
    if (!*(void *)(a1 + 32) || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      unsigned __int8 v24 = [*(id *)(a1 + 40) serviceDelegate];
      unsigned __int8 v25 = [*(id *)(a1 + 56) restoreMode];
      unsigned int v26 = [v25 isBackgroundFiles];

      if (v26)
      {
        long long v66 = 0u;
        long long v67 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        uint64_t v27 = [*(id *)(a1 + 56) restoreMode];
        unsigned __int8 v28 = [v27 paths];

        id v29 = [v28 countByEnumeratingWithState:&v64 objects:v76 count:16];
        if (v29)
        {
          id v30 = v29;
          uint64_t v31 = *(void *)v65;
          do
          {
            for (uint64_t i = 0; i != v30; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v65 != v31) {
                objc_enumerationMutation(v28);
              }
              [v24 manager:*(void *)(a1 + 40) didFailRestoreForPath:*(void *)(*((void *)&v64 + 1) + 8 * i) withContext:*(void *)(a1 + 32) error:*(void *)(a1 + 72)];
            }
            id v30 = [v28 countByEnumeratingWithState:&v64 objects:v76 count:16];
          }
          while (v30);
        }
      }
      [v24 manager:*(void *)(a1 + 40) didFailRestoreWithContext:*(void *)(a1 + 32) error:*(void *)(a1 + 72)];
    }
    uint64_t v33 = [*(id *)(a1 + 56) restoreMode];
    unsigned int v34 = [v33 isBackgroundApp];

    if (v34)
    {
      id v35 = +[AppRestoreDispatcher shared];
      id v36 = [v35 appRestorerForAccount:*(void *)(a1 + 64) stateQueue:*(void *)(*(void *)(a1 + 40) + 16) delegate:*(void *)(a1 + 40) error:0];

      if (!v36)
      {
        uint64_t v37 = MBGetDefaultLog();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          long long v38 = *(void **)(a1 + 64);
          *(_DWORD *)buf = 138412290;
          id v73 = v38;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Failed to find the app restore manager for %@", buf, 0xCu);
          id v61 = *(void **)(a1 + 64);
          _MBLog();
        }
      }
      id v39 = objc_msgSend(*(id *)(a1 + 80), "cache", v61);
      uint64_t v40 = [*(id *)(a1 + 56) restoreMode];
      int v41 = [v40 bundleID];
      id v42 = [v39 clearAgentForDomainRestoresWithAgentDomain:v41];

      BOOL v43 = [*(id *)(a1 + 56) installCoordinator];

      if (v43)
      {
        unsigned __int8 v44 = +[MBError isRetryableRestoreError:*(void *)(a1 + 72)];
        uint64_t v45 = MBGetDefaultLog();
        uint64_t v46 = v45;
        if (v44)
        {
          if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
          {
            uint64_t v47 = [*(id *)(a1 + 56) restoreMode];
            CFStringRef v48 = [v47 bundleID];
            uint64_t v49 = *(void *)(a1 + 72);
            *(_DWORD *)buf = 138412546;
            id v73 = v48;
            __int16 v74 = 2112;
            uint64_t v75 = v49;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "IX: Not canceling data promise for %@ because restore needs to be retried after transient error - %@", buf, 0x16u);

            id v50 = [*(id *)(a1 + 56) restoreMode];
            id v61 = [v50 bundleID];
            uint64_t v62 = *(void *)(a1 + 72);
            _MBLog();
          }
          uint64_t v51 = [*(id *)(a1 + 56) installCoordinator];
          [v51 updateProgress:0.0];

          [v36 openRestoreSlot];
        }
        else
        {
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            id v52 = [*(id *)(a1 + 56) restoreMode];
            id v53 = [v52 bundleID];
            uint64_t v54 = *(void *)(a1 + 72);
            *(_DWORD *)buf = 138412546;
            id v73 = v53;
            __int16 v74 = 2112;
            uint64_t v75 = v54;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "IX: Cancelling the data promise because restore failed for bundleID %@ with a non retryable error - %@", buf, 0x16u);

            id v55 = [*(id *)(a1 + 56) restoreMode];
            id v61 = [v55 bundleID];
            uint64_t v62 = *(void *)(a1 + 72);
            _MBLog();
          }
          id v56 = [*(id *)(a1 + 56) installCoordinator];
          [v36 stopTrackingCoordinator:v56 withSuccess:0];
        }
      }
    }
    if (*(unsigned char *)(a1 + 108))
    {
      id v57 = MBGetDefaultLog();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_INFO, "Restore failed. Clearing all restore data", buf, 2u);
        _MBLog();
      }

      uint64_t v58 = *(void **)(a1 + 40);
      uint64_t v59 = *(void *)(a1 + 64);
      id v63 = 0;
      [v58 resetCacheWithAccount:v59 error:&v63];
      id v22 = v63;
      if (!v22) {
        goto LABEL_58;
      }
      id v23 = MBGetDefaultLog();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v73 = v22;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Failed to remove all restore data: %@", buf, 0xCu);
        id v61 = v22;
        _MBLog();
      }
LABEL_57:

LABEL_58:
    }
  }
  else if (v2 == 2)
  {
    if (!*(void *)(a1 + 32) || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      uint64_t v3 = [*(id *)(a1 + 40) serviceDelegate];
      id v5 = *(id *)(a1 + 96);
      if (v5 == (id)-1) {
        id v5 = [*(id *)(a1 + 48) minutesRemaining];
      }
      LODWORD(v4) = 1.0;
      [v3 manager:*(void *)(a1 + 40) didUpdateProgress:v5 estimatedTimeRemaining:*(void *)(a1 + 32) context:v4];
      CFStringRef v6 = [*(id *)(a1 + 56) restoreMode];
      unsigned int v7 = [v6 isBackgroundFiles];

      if (v7)
      {
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        uint64_t v8 = [*(id *)(a1 + 56) restoreMode];
        CFStringRef v9 = [v8 paths];

        id v10 = [v9 countByEnumeratingWithState:&v68 objects:v77 count:16];
        if (v10)
        {
          id v11 = v10;
          uint64_t v12 = *(void *)v69;
          do
          {
            for (j = 0; j != v11; j = (char *)j + 1)
            {
              if (*(void *)v69 != v12) {
                objc_enumerationMutation(v9);
              }
              [v3 manager:*(void *)(a1 + 40) didFinishRestoreForPath:*(void *)(*((void *)&v68 + 1) + 8 * (void)j) withContext:*(void *)(a1 + 32)];
            }
            id v11 = [v9 countByEnumeratingWithState:&v68 objects:v77 count:16];
          }
          while (v11);
        }
      }
      [v3 manager:*(void *)(a1 + 40) didFinishRestoreWithContext:*(void *)(a1 + 32)];
    }
    uint64_t v14 = [*(id *)(a1 + 56) restoreMode];
    unsigned int v15 = [v14 isBackgroundApp];

    if (v15)
    {
      float v16 = [*(id *)(a1 + 56) installCoordinator];

      if (v16)
      {
        uint64_t v17 = +[AppRestoreDispatcher shared];
        double v18 = [v17 appRestorerForAccount:*(void *)(a1 + 64) stateQueue:*(void *)(*(void *)(a1 + 40) + 16) delegate:*(void *)(a1 + 40) error:0];

        if (!v18)
        {
          char v19 = MBGetDefaultLog();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            uint64_t v20 = *(void **)(a1 + 64);
            *(_DWORD *)buf = 138412290;
            id v73 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to find the app restore manager for %@", buf, 0xCu);
            id v61 = *(void **)(a1 + 64);
            _MBLog();
          }
        }
        unsigned int v21 = objc_msgSend(*(id *)(a1 + 56), "installCoordinator", v61);
        [v18 stopTrackingCoordinator:v21 withSuccess:1];
      }
      id v22 = [*(id *)(a1 + 56) restoreMode];
      id v23 = [v22 bundleID];
      +[AITransactionLog logStep:2 byParty:6 phase:2 success:1 forBundleID:v23 description:@"App data restore completed"];
      goto LABEL_57;
    }
  }
  id result = objc_msgSend(*(id *)(a1 + 88), "restoreSessionOverridden", v61, v62);
  if (result) {
    return [*(id *)(a1 + 40) _clearRestoreSessionWithAccount:*(void *)(a1 + 64)];
  }
  return result;
}

void sub_1000C157C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState] == 5)
  {
    [*(id *)(a1 + 32) unboostBackgroundRestore];
    int v2 = *(void **)(a1 + 32);
    uint64_t v3 = *(void *)(a1 + 40);
    _[v2 setUnboostBackgroundRestoreHandler:v3];
  }
  else
  {
    +[MBError errorWithCode:format:](MBError, "errorWithCode:format:", 1, @"Not running a background restore (%d)", [*(id *)(a1 + 32) serviceState]);
    id v4 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

uint64_t sub_1000C1B1C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned int v7 = [v5 backupUUID];
  uint64_t v8 = [v6 backupUUID];
  unsigned __int8 v9 = [v7 isEqualToString:v8];

  if (v9) {
    goto LABEL_6;
  }
  id v10 = [v5 backupUUID];
  unsigned __int8 v11 = [v10 isEqualToString:*(void *)(a1 + 32)];

  if ((v11 & 1) == 0)
  {
    double v13 = [v6 backupUUID];
    unsigned __int8 v14 = [v13 isEqualToString:*(void *)(a1 + 32)];

    if (v14)
    {
      uint64_t v12 = 1;
      goto LABEL_7;
    }
LABEL_6:
    unsigned int v15 = [v6 date];
    float v16 = [v5 date];
    uint64_t v12 = (uint64_t)[v15 compare:v16];

    goto LABEL_7;
  }
  uint64_t v12 = -1;
LABEL_7:

  return v12;
}

void sub_1000C1FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t sub_1000C2008(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) restoreSession];
  return _objc_release_x1();
}

void sub_1000C2054(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) serviceState];
  if (v2 == 5)
  {
    unsigned int v3 = [*(id *)(a1 + 32) finishedAppRestores];
    unsigned int v4 = [*(id *)(a1 + 40) airTrafficDidFinishRestore];
    if (!*(unsigned char *)(a1 + 56))
    {
      unsigned int v5 = v4;
      if ([*(id *)(a1 + 32) serviceState] == 5)
      {
        if ([*(id *)(a1 + 48) isPrimaryAccount])
        {
          if ((v3 & v5 & 1) == 0)
          {
            id v6 = MBGetDefaultLog();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
            {
              if (v5) {
                CFStringRef v7 = @"done";
              }
              else {
                CFStringRef v7 = @"ongoing";
              }
              if (v3) {
                CFStringRef v8 = @"done";
              }
              else {
                CFStringRef v8 = @"ongoing";
              }
              *(_DWORD *)buf = 138412546;
              CFStringRef v89 = v7;
              __int16 v90 = 2112;
              *(void *)id v91 = v8;
              _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ignoring finish restore request while either app data restore or air traffic restore is incomplete. ATC: %@, IX: %@", buf, 0x16u);
LABEL_19:
              _MBLog();
              goto LABEL_82;
            }
            goto LABEL_82;
          }
        }
        else if ((v3 & 1) == 0)
        {
          id v6 = MBGetDefaultLog();
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_82;
          }
          *(_DWORD *)buf = 138412290;
          CFStringRef v89 = @"ongoing";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ignoring finish restore request while app data restore is incomplete. IX: %@", buf, 0xCu);
          goto LABEL_19;
        }
      }
    }
    uint64_t v12 = MBGetDefaultLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 56)) {
        CFStringRef v13 = @"Cancelling";
      }
      else {
        CFStringRef v13 = @"Finishing";
      }
      *(_DWORD *)buf = 138412290;
      CFStringRef v89 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%@ restore and releasing lock", buf, 0xCu);
      if (*(unsigned char *)(a1 + 56)) {
        CFStringRef v14 = @"Cancelling";
      }
      else {
        CFStringRef v14 = @"Finishing";
      }
      CFStringRef v72 = v14;
      _MBLog();
    }

    unsigned int v15 = [*(id *)(a1 + 48) persona];
    id v6 = [v15 placeholderRestoreDirectory];

    float v16 = MBGetDefaultLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v89 = (const __CFString *)v6;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Removing placeholderRestoreDirectory: %@", buf, 0xCu);
      CFStringRef v72 = (const __CFString *)v6;
      _MBLog();
    }

    uint64_t v17 = +[NSFileManager defaultManager];
    id v87 = 0;
    unsigned __int8 v18 = [v17 removeItemAtPath:v6 error:&v87];
    char v19 = (__CFString *)v87;

    if ((v18 & 1) == 0)
    {
      uint64_t v20 = MBGetDefaultLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        CFStringRef v89 = v19;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to remove placeholderRestoreDirectory: %@", buf, 0xCu);
        CFStringRef v72 = v19;
        _MBLog();
      }
    }
    if (*(unsigned char *)(a1 + 56))
    {
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      unsigned int v21 = [*(id *)(a1 + 32) engines];
      id v22 = [v21 countByEnumeratingWithState:&v83 objects:v95 count:16];
      if (v22)
      {
        id v23 = v22;
        uint64_t v24 = *(void *)v84;
        do
        {
          for (uint64_t i = 0; i != v23; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v84 != v24) {
              objc_enumerationMutation(v21);
            }
            objc_msgSend(*(id *)(*((void *)&v83 + 1) + 8 * i), "cancel", v72);
          }
          id v23 = [v21 countByEnumeratingWithState:&v83 objects:v95 count:16];
        }
        while (v23);
      }

      if (*(unsigned char *)(a1 + 56)) {
        goto LABEL_61;
      }
    }
    char v82 = 0;
    unsigned int v26 = objc_msgSend(*(id *)(a1 + 48), "persona", v72);
    unsigned int v27 = [v26 getBooleanValueForKey:@"UseInheritBackupEndpoint" keyExists:&v82];

    if (v82)
    {
      unsigned __int8 v28 = MBGetDefaultLog();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        if (v27) {
          id v29 = "YES";
        }
        else {
          id v29 = "NO";
        }
        *(_DWORD *)buf = 138412546;
        CFStringRef v89 = @"UseInheritBackupEndpoint";
        __int16 v90 = 2080;
        *(void *)id v91 = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%@=%s", buf, 0x16u);
        CFStringRef v72 = @"UseInheritBackupEndpoint";
        uint64_t v75 = v29;
        _MBLog();
      }

      if (v82)
      {
        if (!v27)
        {
LABEL_61:
          int v41 = objc_msgSend(*(id *)(a1 + 48), "persona", v72, v75);
          id v80 = 0;
          unsigned __int8 v42 = +[MBRestoreDepot disposeAllDepotsForPersona:v41 error:&v80];
          BOOL v43 = (__CFString *)v80;

          if ((v42 & 1) == 0)
          {
            unsigned __int8 v44 = MBGetDefaultLog();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              CFStringRef v89 = v43;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Failed to dispose all depots: %@", buf, 0xCu);
              id v73 = v43;
              _MBLog();
            }
          }
          objc_msgSend(*(id *)(a1 + 32), "setServiceState:", 6, v73);
          if (MBIsInternalInstall())
          {
            uint64_t v45 = [*(id *)(a1 + 32) restorePlan];
            uint64_t v46 = [*(id *)(a1 + 48) persona];
            +[MBTapToRadar reportRestoreErrorsIn:v45 persona:v46];
          }
          uint64_t v47 = [*(id *)(a1 + 32) restore];
          [v47 setState:3];
          [v47 setIsBackground:1];
          [(id)objc_opt_class() saveRestoreStateInfo:v47 account:*(void *)(a1 + 48)];
          CFStringRef v48 = +[MBNotificationCenter sharedNotificationCenter];
          objc_msgSend(v48, "postNotification:ifStateChanged:", kMBManagerRestoreStateChangedNotification, objc_msgSend(v47, "state"));

          uint64_t v49 = [*(id *)(a1 + 32) restoreSession];
          [v49 setFinishing:1];

          uint64_t v50 = *(unsigned __int8 *)(a1 + 56);
          uint64_t v51 = [*(id *)(a1 + 32) restoreSession];
          [v51 setCancelled:v50];

          id v52 = [*(id *)(a1 + 32) backgroundRestoreProgressMonitor];
          [v52 cancel];

          [*(id *)(a1 + 32) setBackgroundRestoreProgressMonitor:0];
          id v53 = [*(id *)(a1 + 32) restoreLogger];
          [v53 close];

          [*(id *)(a1 + 32) setRestoreLogger:0];
          uint64_t v54 = [v47 date];
          if (v54)
          {
            id v55 = +[NSDate date];
            id v56 = [v47 date];
            [v55 timeIntervalSinceDate:v56];
            CFStringRef v58 = v57;
          }
          else
          {
            CFStringRef v58 = 0;
          }

          uint64_t v59 = MBGetDefaultLog();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            CFStringRef v89 = v58;
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "Total duration of iCloud background restore: %0.3fs", buf, 0xCu);
            CFStringRef v74 = v58;
            _MBLog();
          }

          if (([*(id *)(a1 + 32) restoreSessionOverridden] & 1) == 0)
          {
            char v60 = [*(id *)(a1 + 32) restoreSession];
            id v61 = v60;
            if (*(unsigned char *)(a1 + 57))
            {
              uint64_t v62 = [v60 propertyList];
              id v63 = MBGetDefaultLog();
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                long long v64 = [*(id *)(a1 + 48) accountIdentifier];
                [*(id *)(a1 + 48) persona];
                long long v65 = v79 = v19;
                long long v66 = [v65 personaIdentifier];
                *(_DWORD *)buf = 138413058;
                CFStringRef v89 = v64;
                __int16 v90 = 2114;
                *(void *)id v91 = v66;
                *(_WORD *)&v91[8] = 2048;
                char v92 = v61;
                __int16 v93 = 2114;
                uint64_t v94 = v62;
                _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Saving restore session for account %@(%{public}@): (%p) %{public}@", buf, 0x2Au);

                long long v67 = [*(id *)(a1 + 48) accountIdentifier];
                long long v68 = [*(id *)(a1 + 48) persona];
                [v68 personaIdentifier];
                long long v77 = v61;
                id v78 = v62;
                v76 = CFStringRef v74 = v67;
                _MBLog();

                char v19 = v79;
              }

              long long v69 = [*(id *)(a1 + 48) persona];
              [v69 setPreferencesValue:v62 forKey:@"RestoreSession"];
            }
            else
            {
              [v60 saveAtPath:@"/var/mobile/Library/Preferences/com.apple.MobileBackup.plist"];
            }
          }
          long long v70 = objc_msgSend(*(id *)(a1 + 32), "lockManager", v74, v76, v77, v78);
          [v70 releaseLockSync];

          if (*(unsigned char *)(a1 + 56))
          {
            long long v71 = [*(id *)(a1 + 40) delegate];
            [v71 managerDidCancelRestore:*(void *)(a1 + 40)];
          }
          goto LABEL_82;
        }
      }
    }
    id v30 = objc_msgSend(*(id *)(*(void *)(a1 + 40) + 40), "objectForKeyedSubscript:", *(void *)(a1 + 48), v72, v75);
    uint64_t v31 = [v30 restoreSession];

    uint64_t v32 = [v31 snapshotUUID];
    uint64_t v33 = [v31 backupUDID];
    unsigned int v34 = MBGetDefaultLog();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      CFStringRef v89 = v32;
      __int16 v90 = 2112;
      *(void *)id v91 = v33;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Trying to inherit backup snapshot %@ from device %@", buf, 0x16u);
      CFStringRef v72 = v32;
      uint64_t v75 = v33;
      _MBLog();
    }

    id v35 = *(void **)(a1 + 40);
    uint64_t v36 = *(void *)(a1 + 48);
    id v81 = 0;
    unsigned __int8 v37 = [v35 inheritSnapshotWithAccount:v36 fromSnapshot:v32 fromDevice:v33 error:&v81];
    long long v38 = (__CFString *)v81;
    id v39 = MBGetDefaultLog();
    uint64_t v40 = v39;
    if (v37)
    {
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "InheritBackup succeeded", buf, 2u);
LABEL_59:
        _MBLog();
      }
    }
    else if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v89 = v38;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "InheritBackup failed: %@", buf, 0xCu);
      CFStringRef v72 = v38;
      goto LABEL_59;
    }

    goto LABEL_61;
  }
  unsigned int v9 = v2;
  id v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 56)) {
      CFStringRef v10 = @"cancel";
    }
    else {
      CFStringRef v10 = @"finish";
    }
    int v11 = *(_DWORD *)(*(void *)(a1 + 40) + 8);
    *(_DWORD *)buf = 138543874;
    CFStringRef v89 = v10;
    __int16 v90 = 1024;
    *(_DWORD *)id v91 = v9;
    *(_WORD *)&v91[4] = 1024;
    *(_DWORD *)&v91[6] = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ignoring %{public}@ restore request while not in background restore (%d/%d) ", buf, 0x18u);
    goto LABEL_19;
  }
LABEL_82:
}

uint64_t sub_1000C2CEC(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 200) = +[MBDryRestoreManager createManager];
  return _objc_release_x1();
}

void sub_1000C2FE4(uint64_t a1)
{
  [*(id *)(a1 + 32) finishAirTrafficRestoreWithAccount:*(void *)(a1 + 40)];
  id v3 = self;
}

uint64_t sub_1000C3CC4(uint64_t a1)
{
  return 1;
}

void sub_1000C4188(void *a1)
{
  if (a1[4])
  {
    uint64_t v3 = a1[5];
    unsigned int v2 = (void *)a1[6];
    id v23 = 0;
    unsigned int v4 = [v2 domainForPath:v3 relativePath:&v23];
    unsigned int v5 = v23;
    if (v4)
    {
      id v6 = (void *)a1[7];
      uint64_t v7 = a1[5];
      id v22 = 0;
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472;
      v20[2] = sub_1000C44F8;
      v20[3] = &unk_100411728;
      id v21 = v4;
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      void v19[2] = sub_1000C4500;
      long long v19[3] = &unk_100412578;
      v19[4] = a1[9];
      [v6 atcRestorableForAbsolutePath:v7 error:&v22 domainProvider:v20 restorableAccessor:v19];
      CFStringRef v8 = v22;
      if (v8)
      {
        unsigned int v9 = MBGetDefaultLog();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          unsigned __int8 v25 = v8;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "=atc= Failed to get restore plan restorable: %@", buf, 0xCu);
          uint64_t v17 = v8;
          _MBLog();
        }
      }
      CFStringRef v10 = (void *)a1[8];
      uint64_t v11 = a1[5];
      unsigned __int8 v18 = v8;
      uint64_t v12 = objc_msgSend(v10, "fetchRestorableFileForPath:error:", v11, &v18, v17);
      CFStringRef v13 = v18;

      if (v12)
      {
        *(unsigned char *)(*(void *)(a1[9] + 8) + 24) = 1;
      }
      else if (v13)
      {
        float v16 = MBGetDefaultLog();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          unsigned __int8 v25 = v13;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "=atc= Failed to get legacy cache restorable: %@", buf, 0xCu);
          _MBLog();
        }
      }
    }
    else
    {
      CFStringRef v13 = MBGetDefaultLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        unsigned int v15 = a1[5];
        *(_DWORD *)buf = 138412290;
        unsigned __int8 v25 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "=atc= Failed to get domain for %@", buf, 0xCu);
        _MBLog();
      }
    }
  }
  else
  {
    unsigned int v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v14 = a1[5];
      *(_DWORD *)buf = 138412290;
      unsigned __int8 v25 = v14;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "=atc= No active restore session for request for whether file exists: %@", buf, 0xCu);
      _MBLog();
    }
  }
}

id sub_1000C44F8(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

uint64_t sub_1000C4500(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  return 0;
}

void sub_1000C474C(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    id v22 = MBGetDefaultLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      uint64_t v34 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "No active restore session for request for whether app data exists for %@", buf, 0xCu);
      _MBLog();
    }
    goto LABEL_27;
  }
  uint64_t v2 = +[MBDomain nameWithAppID:*(void *)(a1 + 40)];
  if (!v2) {
    return;
  }
  id v3 = (id)v2;
  unsigned int v4 = [*(id *)(a1 + 48) dependentDomainsForApp:v2 error:0];
  id v5 = [v4 mutableCopy];
  if (!v5) {
    id v5 = [objc_alloc((Class)NSMutableSet) initWithCapacity:1];
  }
  [v5 addObject:v3];
  id v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    uint64_t v34 = v7;
    __int16 v35 = 2112;
    id v36 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Finding pending restore size for app %@: %@", buf, 0x16u);
    _MBLog();
  }

  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id obj = v5;
  id v8 = [obj countByEnumeratingWithState:&v29 objects:v39 count:16];
  unsigned __int8 v25 = v4;
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v30;
    do
    {
      uint64_t v11 = 0;
      uint64_t v12 = v3;
      do
      {
        if (*(void *)v30 != v10) {
          objc_enumerationMutation(obj);
        }
        id v3 = *(id *)(*((void *)&v29 + 1) + 8 * (void)v11);

        CFStringRef v13 = *(void **)(a1 + 48);
        v27[0] = _NSConcreteStackBlock;
        v27[1] = 3221225472;
        v27[2] = sub_1000C4BD4;
        uint64_t v27[3] = &unk_1004125C8;
        long long v28 = *(_OWORD *)(a1 + 56);
        CFStringRef v14 = [v13 fetchRestoreSizeForDomain:v3 callback:v27];
        if (v14)
        {
          unsigned int v15 = MBGetDefaultLog();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v16 = *(void *)(a1 + 40);
            *(_DWORD *)buf = 138412546;
            uint64_t v34 = v16;
            __int16 v35 = 2112;
            id v36 = v14;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get pending restore size for app %@: %@", buf, 0x16u);
            _MBLog();
          }
        }
        uint64_t v11 = (char *)v11 + 1;
        uint64_t v12 = v3;
      }
      while (v9 != v11);
      id v9 = [obj countByEnumeratingWithState:&v29 objects:v39 count:16];
    }
    while (v9);
  }

  int v17 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  unsigned __int8 v18 = MBGetDefaultLog();
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if (v17)
  {
    if (v19)
    {
      uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      id v21 = *(void **)(a1 + 40);
      *(_DWORD *)buf = 134218498;
      uint64_t v34 = v20;
      __int16 v35 = 2112;
      id v36 = v21;
      __int16 v37 = 2112;
      uint64_t v38 = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Restore data exists of size %{bytes}llu for app with bundle ID %@ (%@)", buf, 0x20u);
LABEL_25:
      _MBLog();
    }
  }
  else if (v19)
  {
    uint64_t v24 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    uint64_t v34 = v24;
    __int16 v35 = 2112;
    id v36 = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Restore data does not exist for app with bundle ID %@ (%@)", buf, 0x16u);
    goto LABEL_25;
  }

  id v22 = v25;
LABEL_27:
}

uint64_t sub_1000C4BD4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) |= a3 != 0;
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) += a2;
  return result;
}

void sub_1000C522C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t sub_1000C5264(void *a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = v3;
  if (!a1[4]) {
    goto LABEL_4;
  }
  uint64_t v5 = [v3 relativePath];
  if (!v5) {
    goto LABEL_4;
  }
  id v6 = (void *)v5;
  uint64_t v7 = [v4 relativePath];
  unsigned __int8 v8 = [v7 hasPrefix:a1[4]];

  if ((v8 & 1) == 0)
  {
    ++*(void *)(*(void *)(a1[7] + 8) + 24);
    uint64_t v11 = (void *)a1[5];
    id v9 = +[NSNull null];
    uint64_t v10 = v11;
  }
  else
  {
LABEL_4:
    [v4 setupWithDomain:a1[6]];
    id v9 = +[MBFileInfo fileInfoWithRestorable:v4];
    uint64_t v10 = (void *)a1[5];
  }
  [v10 addObject:v9];

  return 1;
}

void sub_1000C785C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState] == 5)
  {
    uint64_t v2 = +[AppRestoreDispatcher shared];
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(v4 + 16);
    id v13 = 0;
    id v6 = [v2 appRestorerForAccount:v3 stateQueue:v5 delegate:v4 error:&v13];
    id v7 = v13;
    id v8 = v13;

    if (v6)
    {
      [*(id *)(a1 + 32) setFinishedAppRestores:0];
      [v6 startObservingInstallCoordinators];
      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    }
    else
    {
      uint64_t v11 = MBGetDefaultLog();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = *(void *)(a1 + 40);
        *(_DWORD *)buf = 138412546;
        uint64_t v15 = v12;
        __int16 v16 = 2112;
        id v17 = v8;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to find the app restore manager for %@: %@", buf, 0x16u);
        _MBLog();
      }

      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), v7);
    }
  }
  else
  {
    id v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v10 = [*(id *)(a1 + 32) serviceState];
      *(_DWORD *)buf = 67109120;
      LODWORD(v15) = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Not currently in bg restore (%d)", buf, 8u);
      [*(id *)(a1 + 32) serviceState];
      _MBLog();
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
  }
}

void sub_1000C7DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1000C7DE0(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) serviceState];
  uint64_t v3 = MBGetDefaultLog();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      unsigned int v5 = [*(id *)(a1 + 32) serviceState];
      *(_DWORD *)buf = 67109120;
      LODWORD(v37) = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Not scanning while busy (%d)", buf, 8u);
      id v28 = [*(id *)(a1 + 32) serviceState];
      _MBLog();
    }

    if ([*(id *)(a1 + 32) serviceState] == 1)
    {
      CFStringRef v6 = @"Scan already running";
      uint64_t v7 = 3;
    }
    else
    {
      CFStringRef v6 = @"Manager not in idle state";
      uint64_t v7 = 14;
    }
    uint64_t v25 = +[MBError errorWithCode:format:](MBError, "errorWithCode:format:", v7, v6, v28);
    uint64_t v26 = *(void *)(*(void *)(a1 + 64) + 8);
    unsigned int v27 = *(void **)(v26 + 40);
    *(void *)(v26 + 40) = v25;

    *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 0;
  }
  else
  {
    if (v4)
    {
      id v8 = [*(id *)(a1 + 40) accountIdentifier];
      id v9 = [*(id *)(a1 + 40) persona];
      unsigned int v10 = [v9 personaIdentifier];
      *(_DWORD *)buf = 138543618;
      __int16 v37 = v8;
      __int16 v38 = 2114;
      id v39 = v10;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Starting scanning for account %{public}@(%{public}@)", buf, 0x16u);

      uint64_t v11 = [*(id *)(a1 + 40) accountIdentifier];
      uint64_t v12 = [*(id *)(a1 + 40) persona];
      long long v29 = [v12 personaIdentifier];
      _MBLog();
    }
    uint64_t v13 = (void *)os_transaction_create();
    [*(id *)(a1 + 32) setServiceState:1];
    [*(id *)(a1 + 32) setNextBackupSize:0];
    CFStringRef v14 = [[MBCKSizingEngine alloc] initWithSettingsContext:*(void *)(a1 + 48) serviceManager:*(void *)(a1 + 56)];
    [(MBCKEngine *)v14 cache];
    if (objc_claimAutoreleasedReturnValue()) {
      __assert_rtn("-[MBCKManager _startScanWithSettingsContext:error:]_block_invoke", "MBCKManager.m", 4273, "!engine.cache");
    }
    uint64_t v15 = MBAllCKPlugins();
    __int16 v16 = [(MBCKEngine *)v14 context];
    [v16 setPlugins:v15];

    id v17 = [*(id *)(a1 + 32) engines];
    unsigned __int8 v18 = [v17 arrayByAddingObject:v14];
    [*(id *)(a1 + 32) setEngines:v18];

    BOOL v19 = +[MBDaemon sharedDaemon];
    [v19 holdWorkAssertion:*(void *)(a1 + 80)];

    uint64_t v20 = [*(id *)(a1 + 32) serviceGroup];
    id v21 = dispatch_get_global_queue(17, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000C81C8;
    block[3] = &unk_100412AD8;
    uint64_t v22 = *(void *)(a1 + 56);
    long long v31 = v14;
    uint64_t v32 = v22;
    id v33 = *(id *)(a1 + 32);
    id v34 = v13;
    uint64_t v35 = *(void *)(a1 + 80);
    id v23 = v13;
    uint64_t v24 = v14;
    dispatch_group_async(v20, v21, block);

    *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 1;
  }
}

void sub_1000C81C8(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  id v14 = 0;
  unsigned __int8 v4 = [v3 runWithError:&v14];
  id v5 = v14;
  CFStringRef v6 = *(NSObject **)(*(void *)(a1 + 40) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000C8308;
  block[3] = &unk_100412618;
  unsigned __int8 v13 = v4;
  id v10 = *(id *)(a1 + 48);
  id v11 = *(id *)(a1 + 32);
  id v12 = *(id *)(a1 + 56);
  dispatch_sync(v6, block);
  uint64_t v7 = +[MBDaemon sharedDaemon];
  [v7 releaseWorkAssertion:*(void *)(a1 + 64)];

  id v8 = self;
}

id sub_1000C8308(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    unsigned int v2 = +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", [*(id *)(a1 + 40) modifiedBytes]);
    [*(id *)(a1 + 32) setNextBackupSize:v2];
  }
  [*(id *)(a1 + 32) setServiceState:0];
  uint64_t v3 = [*(id *)(a1 + 32) engines];
  uint64_t v7 = *(void *)(a1 + 40);
  unsigned __int8 v4 = +[NSArray arrayWithObjects:&v7 count:1];
  id v5 = [v3 arrayByExcludingObjectsInArray:v4];
  [*(id *)(a1 + 32) setEngines:v5];

  return self;
}

void sub_1000C8C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a71, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C8CC0(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_1000C8CEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned __int8 v4 = [v3 domainName];
  id v5 = [v3 relativePath];
  if (v5)
  {
    CFStringRef v6 = [*(id *)(a1 + 32) objectForKeyedSubscript:v4];
    if (!v6)
    {
      CFStringRef v6 = objc_opt_new();
      [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:v4];
    }
    uint64_t v7 = +[NSMutableArray arrayWithCapacity:3];
    [v7 addObject:v5];
    id v8 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", [v3 size]);
    id v9 = [v8 stringValue];
    [v7 addObject:v9];

    if ([v3 deleted])
    {
      CFStringRef v10 = @"-";
    }
    else if ([v3 isRegularFile])
    {
      CFStringRef v10 = @"f";
    }
    else if ([v3 isDirectory])
    {
      CFStringRef v10 = @"d";
    }
    else if ([v3 isSymbolicLink])
    {
      CFStringRef v10 = @"l";
    }
    else
    {
      CFStringRef v10 = @"?";
    }
    [v7 addObject:v10];
    id v11 = [v7 componentsJoinedByString:@"|"];
    [v6 addObject:v11];
  }
  return 1;
}

void sub_1000CA9C8(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) serviceState];
  if (v2 == 4 || [*(id *)(a1 + 32) serviceState] == 5)
  {
    id v3 = [*(id *)(a1 + 32) enginesByContext];
    unsigned __int8 v4 = [v3 objectForKey:*(void *)(a1 + 40)];

    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v5 = MBGetDefaultLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 40);
        if (v2 == 4) {
          uint64_t v7 = "foreground";
        }
        else {
          uint64_t v7 = "background";
        }
        *(_DWORD *)buf = 136315394;
        id v9 = v7;
        __int16 v10 = 2112;
        uint64_t v11 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Canceling %s restore for %@", buf, 0x16u);
        _MBLog();
      }

      [v4 cancelWithReason:*(void *)(a1 + 48)];
    }
  }
}

id sub_1000CAC58(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState])
  {
    unsigned int v2 = [*(id *)(a1 + 32) engines];
    [v2 makeObjectsPerformSelector:"cancel"];
  }
  else
  {
    unsigned int v2 = MBGetDefaultLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)unsigned __int8 v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Ignoring cancel request while idle", v4, 2u);
      _MBLog();
    }
  }

  return self;
}

void sub_1000CAE8C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState] == 3)
  {
    if (*(void *)(a1 + 48))
    {
      unsigned int v2 = [*(id *)(a1 + 32) enginesByContext];
      id v3 = [v2 objectForKey:*(void *)(a1 + 48)];

      [v3 cancelWithError:*(void *)(a1 + 56)];
    }
    else
    {
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v11 = [*(id *)(a1 + 32) engines];
      id v12 = [v11 countByEnumeratingWithState:&v19 objects:v23 count:16];
      if (v12)
      {
        id v13 = v12;
        uint64_t v14 = *(void *)v20;
        do
        {
          uint64_t v15 = 0;
          do
          {
            if (*(void *)v20 != v14) {
              objc_enumerationMutation(v11);
            }
            __int16 v16 = *(void **)(*((void *)&v19 + 1) + 8 * (void)v15);
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              [v16 cancelWithError:*(void *)(a1 + 56)];
            }
            uint64_t v15 = (char *)v15 + 1;
          }
          while (v13 != v15);
          id v13 = [v11 countByEnumeratingWithState:&v19 objects:v23 count:16];
        }
        while (v13);
      }
    }
    id v17 = self;
  }
  else
  {
    unsigned __int8 v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [*(id *)(a1 + 40) accountIdentifier];
      uint64_t v6 = [*(id *)(a1 + 40) persona];
      uint64_t v7 = [v6 personaIdentifier];
      unsigned int v8 = [*(id *)(a1 + 32) serviceState];
      *(_DWORD *)buf = 138543874;
      uint64_t v25 = v5;
      __int16 v26 = 2114;
      unsigned int v27 = v7;
      __int16 v28 = 1024;
      unsigned int v29 = v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ignoring cancelation request for account %{public}@(%{public}@) (%d)", buf, 0x1Cu);

      id v9 = [*(id *)(a1 + 40) accountIdentifier];
      __int16 v10 = [*(id *)(a1 + 40) persona];
      unsigned __int8 v18 = [v10 personaIdentifier];
      [*(id *)(a1 + 32) serviceState];
      _MBLog();
    }
  }
}

id sub_1000CB480(uint64_t a1, uint64_t a2)
{
  id result = objc_retainBlock(*(id *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_1000CB4AC(uint64_t a1)
{
}

void sub_1000CB4B4(void *a1)
{
  if (*(void *)(*(void *)(a1[6] + 8) + 40))
  {
    [*(id *)(a1[4] + 40) allPersonaStates];
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v2 = (id)objc_claimAutoreleasedReturnValue();
    id v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v12;
      while (2)
      {
        uint64_t v6 = 0;
        do
        {
          if (*(void *)v12 != v5) {
            objc_enumerationMutation(v2);
          }
          if (objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * (void)v6), "serviceState", (void)v11))
          {

            goto LABEL_12;
          }
          uint64_t v6 = (char *)v6 + 1;
        }
        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
        if (v4) {
          continue;
        }
        break;
      }
    }

    dispatch_block_cancel(*(dispatch_block_t *)(*(void *)(a1[6] + 8) + 40));
    uint64_t v7 = *(void *)(a1[6] + 8);
    unsigned int v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = 0;

    uint64_t v9 = *(void *)(a1[7] + 8);
    __int16 v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = 0;

    (*(void (**)(void))(a1[5] + 16))();
LABEL_12:
  }
}

void sub_1000CB628(void *a1)
{
  if (*(void *)(*(void *)(a1[6] + 8) + 40))
  {
    [*(id *)(a1[4] + 40) allPersonaStates];
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    id v2 = (id)objc_claimAutoreleasedReturnValue();
    id v3 = [v2 countByEnumeratingWithState:&v26 objects:v32 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v27;
      char v5 = 1;
LABEL_4:
      uint64_t v6 = 0;
      while (1)
      {
        if (*(void *)v27 != v4) {
          objc_enumerationMutation(v2);
        }
        unsigned int v7 = [*(id *)(*((void *)&v26 + 1) + 8 * v6) serviceState];
        if ((v7 & 0xFFFFFFFD) == 1) {
          break;
        }
        v5 &= v7 == 0;
        if (v3 == (id)++v6)
        {
          id v3 = [v2 countByEnumeratingWithState:&v26 objects:v32 count:16];
          if (v3) {
            goto LABEL_4;
          }

          if (v5)
          {
            id v3 = 0;
            goto LABEL_24;
          }
          int v25 = *(_DWORD *)(a1[4] + 8);
          long long v14 = MBGetDefaultLog();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            int v31 = v25;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Ignoring backup/scan task cancelation request while busy (%d)", buf, 8u);
            _MBLog();
          }
          CFStringRef v15 = @"Not in idle state";
          goto LABEL_21;
        }
      }

      uint64_t v8 = a1[4];
      int v9 = *(_DWORD *)(v8 + 8);
      [*(id *)(v8 + 32) makeObjectsPerformSelector:"cancel"];
      unint64_t v10 = a1[9];
      if (!v10) {
        goto LABEL_18;
      }
      if (v10 <= 5) {
        unint64_t v10 = 5;
      }
      unint64_t v11 = v10;
      uint64_t v12 = *(void *)(a1[7] + 8);
      unint64_t v13 = *(void *)(v12 + 24);
      if (v13 >= v11 / 5)
      {
LABEL_18:
        long long v14 = MBGetDefaultLog();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          int v31 = v9;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Timed out while waiting for backup/scan engine cancelation (%d)", buf, 8u);
          _MBLog();
        }
        CFStringRef v15 = @"Not in idle state (timeout)";
LABEL_21:

        id v3 = +[MBError errorWithCode:14 format:v15];
        if (!v3) {
          __assert_rtn("-[MBCKManager _cancelBackupAndScanEnginesWithTimeout:completion:]_block_invoke", "MBCKManager.m", 4809, "isIdle || cancelError");
        }
        goto LABEL_24;
      }
      if (__ROR8__(0xAAAAAAAAAAAAAAABLL * v13, 2) < 0x1555555555555556uLL)
      {
        long long v20 = MBGetDefaultLog();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          int v31 = v9;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Waiting for backup/scan engine cancelation (%d)", buf, 8u);
          _MBLog();
        }

        uint64_t v21 = *(void *)(a1[7] + 8);
        uint64_t v22 = *(void *)(v21 + 24);
        *(void *)(v21 + 24) = v22 + 1;
        if (!v22) {
          dispatch_group_notify(*(dispatch_group_t *)(a1[4] + 24), *(dispatch_queue_t *)(a1[4] + 16), *(dispatch_block_t *)(*(void *)(a1[8] + 8) + 40));
        }
      }
      else
      {
        *(void *)(v12 + 24) = v13 + 1;
      }
      unint64_t v23 = a1[9];
      if (v23 >= 5) {
        unint64_t v23 = 5;
      }
      dispatch_time_t v24 = dispatch_time(0, 1000000000 * v23);
      dispatch_after(v24, *(dispatch_queue_t *)(a1[4] + 16), *(dispatch_block_t *)(*(void *)(a1[6] + 8) + 40));
    }
    else
    {

LABEL_24:
      dispatch_block_cancel(*(dispatch_block_t *)(*(void *)(a1[8] + 8) + 40));
      uint64_t v16 = *(void *)(a1[8] + 8);
      id v17 = *(void **)(v16 + 40);
      *(void *)(v16 + 40) = 0;

      uint64_t v18 = *(void *)(a1[6] + 8);
      long long v19 = *(void **)(v18 + 40);
      *(void *)(v18 + 40) = 0;

      (*(void (**)(void))(a1[5] + 16))(a1[5]);
    }
  }
}

id sub_1000CBD30(id result)
{
  if (*(void *)(*(void *)(*((void *)result + 6) + 8) + 40))
  {
    double v1 = result;
    id result = [*((id *)result + 4) serviceState];
    if (!result)
    {
      dispatch_block_cancel(*(dispatch_block_t *)(*(void *)(v1[6] + 8) + 40));
      uint64_t v2 = *(void *)(v1[6] + 8);
      id v3 = *(void **)(v2 + 40);
      *(void *)(v2 + 40) = 0;

      uint64_t v4 = *(void *)(v1[7] + 8);
      char v5 = *(void **)(v4 + 40);
      *(void *)(v4 + 40) = 0;

      uint64_t v6 = *(uint64_t (**)(void))(v1[5] + 16);
      return (id)v6();
    }
  }
  return result;
}

void sub_1000CBDD0(uint64_t a1)
{
  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)) {
    return;
  }
  unsigned int v2 = [*(id *)(a1 + 32) serviceState];
  unsigned int v3 = v2;
  if ((v2 & 0xFFFFFFFD) != 1)
  {
    if (!v2)
    {
      unint64_t v11 = 0;
LABEL_19:
      dispatch_block_cancel(*(dispatch_block_t *)(*(void *)(*(void *)(a1 + 72) + 8) + 40));
      uint64_t v12 = *(void *)(*(void *)(a1 + 72) + 8);
      unint64_t v13 = *(void **)(v12 + 40);
      *(void *)(v12 + 40) = 0;

      uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8);
      CFStringRef v15 = *(void **)(v14 + 40);
      *(void *)(v14 + 40) = 0;

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48));
      return;
    }
    int v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      unsigned int v23 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Ignoring backup/scan task cancelation request while busy (%d)", buf, 8u);
      CFStringRef v10 = @"Not in idle state";
LABEL_14:
      _MBLog();
      goto LABEL_18;
    }
    CFStringRef v10 = @"Not in idle state";
LABEL_18:

    unint64_t v11 = +[MBError errorWithCode:14 format:v10];
    if (!v11) {
      __assert_rtn("-[MBCKManager _cancelBackupAndScanEnginesWithAccount:timeout:completion:]_block_invoke", "MBCKManager.m", 4862, "serviceState == kMBServiceManagerStateIdle || cancelError");
    }
    goto LABEL_19;
  }
  uint64_t v4 = [*(id *)(a1 + 32) engines];
  [v4 makeObjectsPerformSelector:"cancel"];

  unint64_t v5 = *(void *)(a1 + 80);
  if (!v5) {
    goto LABEL_12;
  }
  if (v5 <= 5) {
    unint64_t v5 = 5;
  }
  unint64_t v6 = v5;
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  unint64_t v8 = *(void *)(v7 + 24);
  if (v8 >= v6 / 5)
  {
LABEL_12:
    int v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      unsigned int v23 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Timed out while waiting for backup/scan engine cancelation (%d)", buf, 8u);
      CFStringRef v10 = @"Not in idle state (timeout)";
      goto LABEL_14;
    }
    CFStringRef v10 = @"Not in idle state (timeout)";
    goto LABEL_18;
  }
  if (__ROR8__(0xAAAAAAAAAAAAAAABLL * v8, 2) < 0x1555555555555556uLL)
  {
    uint64_t v16 = MBGetDefaultLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      unsigned int v23 = v3;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Waiting for backup/scan engine cancelation (%d)", buf, 8u);
      _MBLog();
    }

    uint64_t v17 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v18 = *(void *)(v17 + 24);
    *(void *)(v17 + 24) = v18 + 1;
    if (!v18)
    {
      long long v19 = [*(id *)(a1 + 32) serviceGroup];
      dispatch_group_notify(v19, *(dispatch_queue_t *)(*(void *)(a1 + 40) + 16), *(dispatch_block_t *)(*(void *)(*(void *)(a1 + 72) + 8) + 40));
    }
  }
  else
  {
    *(void *)(v7 + 24) = v8 + 1;
  }
  unint64_t v20 = *(void *)(a1 + 80);
  if (v20 >= 5) {
    unint64_t v20 = 5;
  }
  dispatch_time_t v21 = dispatch_time(0, 1000000000 * v20);
  dispatch_after(v21, *(dispatch_queue_t *)(*(void *)(a1 + 40) + 16), *(dispatch_block_t *)(*(void *)(*(void *)(a1 + 56) + 8) + 40));
}

void sub_1000CCD38(uint64_t a1)
{
  unsigned int v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKeyedSubscript:*(void *)(a1 + 40)];
  if ([v2 serviceState] != 3)
  {
    unint64_t v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138543362;
      uint64_t v25 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Removing domain %{public}@", buf, 0xCu);
      _MBLog();
    }

    CFStringRef v10 = *(void **)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    id v23 = 0;
    uint64_t v12 = [v10 openCacheWithAccount:v11 accessType:1 error:&v23];
    id v13 = v23;
    uint64_t v14 = v13;
    if (v12)
    {
      uint64_t v15 = *(void *)(a1 + 48);
      uint64_t v16 = [*(id *)(a1 + 32) databaseManager];
      uint64_t v17 = *(void *)(a1 + 40);
      uint64_t v18 = *(void *)(a1 + 56);
      id v22 = v14;
      LOBYTE(v15) = +[MBCKRemoveDomainRequest removeDomain:v15 cache:v12 databaseManager:v16 account:v17 connection:v18 error:&v22];
      unint64_t v6 = v22;

      if (v15)
      {
LABEL_11:

        goto LABEL_12;
      }
      uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 8);
      unint64_t v20 = v6;
    }
    else
    {
      uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 8);
      unint64_t v20 = v13;
    }
    unint64_t v6 = v20;
    dispatch_time_t v21 = *(void **)(v19 + 40);
    *(void *)(v19 + 40) = v20;

    goto LABEL_11;
  }
  uint64_t v3 = +[MBError errorWithCode:14 format:@"Cannot call RemoveDomain while a backup is in progress"];
  uint64_t v4 = *(void *)(*(void *)(a1 + 64) + 8);
  unint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  unint64_t v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138412290;
    uint64_t v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot call RemoveDomain on %@ while a backup is in progress", buf, 0xCu);
    _MBLog();
  }
LABEL_12:
}

void sub_1000CDFA8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

id sub_1000CE024(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (+[MBRetryStrategy couldRetryError:v4])
  {
    unint64_t v5 = [*(id *)(a1 + 32) persona];
    [v5 setPreferencesValue:&__kCFBooleanTrue forKey:@"HasDeferredDiscountingQuota"];

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a2);
    id v6 = 0;
  }
  else
  {
    uint64_t v7 = *(void **)(a1 + 40);
    unint64_t v8 = MBDeviceUDID_Legacy();
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v11 = *(void **)(v10 + 40);
    v13.receiver = v7;
    v13.super_class = (Class)MBCKManager;
    id obj = v11;
    id v6 = objc_msgSendSuper2(&v13, "discountCameraRollQuotaForBackupUDID:account:connection:error:", v8, v9, 0, &obj);
    objc_storeStrong((id *)(v10 + 40), obj);
  }
  return v6;
}

void sub_1000CE128(uint64_t a1, int a2, id obj)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), obj);
  id v5 = obj;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000CEAAC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (!a2)
  {
    uint64_t v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = *(void **)(a1 + 56);
      uint64_t v13 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 134218498;
      id v16 = v12;
      __int16 v17 = 2112;
      uint64_t v18 = v13;
      __int16 v19 = 2112;
      id v20 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid server response for updating mega backup status (%ld), request ID: %@ error: %@", buf, 0x20u);
LABEL_11:
      _MBLog();
    }
LABEL_12:

    goto LABEL_13;
  }
  if (a2 != 1) {
    goto LABEL_13;
  }
  uint64_t v9 = MBGetDefaultLog();
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (!v7)
  {
    if (v10)
    {
      uint64_t v14 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      id v16 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Did not receive a new mega backup expiration date from server: %{public}@", buf, 0xCu);
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138543618;
    id v16 = v7;
    __int16 v17 = 2114;
    uint64_t v18 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Received new mega backup expiration date from server: %{public}@, requestID: %{public}@", buf, 0x16u);
    _MBLog();
  }

  [*(id *)(a1 + 40) _setMegaBackupExpirationDate:v7 account:*(void *)(a1 + 48)];
LABEL_13:
}

void sub_1000CEDFC(uint64_t a1)
{
  if (([*(id *)(a1 + 32) _refreshLockdownLastBackupDateWithAccount:*(void *)(a1 + 40)] & 1) == 0)
  {
    uint64_t v3 = MBGetDefaultLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to refresh lockdown last backup date from server", v4, 2u);
      _MBLog();
    }
  }
}

void sub_1000CF548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000CF594(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  if (v7)
  {
    id v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = [*(id *)(a1 + 32) recordID];
      *(_DWORD *)buf = 138412546;
      uint64_t v12 = v9;
      __int16 v13 = 2112;
      id v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch the device record:%@ (dateOfLastBackup): %@", buf, 0x16u);

      BOOL v10 = [*(id *)(a1 + 32) recordID];
      _MBLog();
    }
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a4);
  }
  else
  {
    [*(id *)(a1 + 32) refreshWithRecord:a3];
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void sub_1000CF9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1000CFA04(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v11 = a3;
  id v7 = a4;
  switch(a2)
  {
    case 2:
      [*(id *)(a1 + 32) updateMegaBackupExpirationDate:v11 account:*(void *)(a1 + 40)];
      *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 1;
      break;
    case 1:
      uint64_t v8 = +[MBError errorWithCode:1, @"Server did not allow the requested expiration date: %@", *(void *)(a1 + 48) format];
      uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
      BOOL v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v8;

      break;
    case 0:
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), a4);
      break;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
}

void sub_1000CFF0C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState])
  {
    unsigned int v2 = MBGetDefaultLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      unsigned int v3 = [*(id *)(a1 + 32) serviceState];
      uint64_t v4 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 67109378;
      unsigned int v15 = v3;
      __int16 v16 = 2112;
      uint64_t v17 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Ignoring keybag is locking notification while busy (%d) account:%@", buf, 0x12u);
      [*(id *)(a1 + 32) serviceState];
      _MBLog();
    }

    id v5 = +[MBDaemon sharedDaemon];
    [v5 releaseWorkAssertion:*(void *)(a1 + 64)];
  }
  else
  {
    id v6 = dispatch_group_create();
    dispatch_group_enter(v6);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 48);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1000D0138;
    v11[3] = &unk_1004110B0;
    uint64_t v12 = v6;
    id v13 = *(id *)(a1 + 56);
    id v5 = v6;
    +[MBCKEncryptionManager keybagIsLockingWithAccount:v7 serviceManager:v8 completion:v11];
    uint64_t v9 = dispatch_get_global_queue(17, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000D0170;
    block[3] = &unk_100411038;
    void block[4] = *(void *)(a1 + 64);
    dispatch_group_notify(v5, v9, block);
  }
}

id sub_1000D0138(uint64_t a1)
{
  return self;
}

void sub_1000D0170(uint64_t a1)
{
  unsigned int v3 = +[MBDaemon sharedDaemon];
  [v3 releaseWorkAssertion:*(void *)(a1 + 32)];
}

void sub_1000D06A0(uint64_t a1)
{
  if ([*(id *)(a1 + 32) serviceState] == 5)
  {
    unsigned int v2 = [*(id *)(a1 + 32) restoreKeyBagsByID];
    id v3 = [v2 count];

    if (!v3)
    {
      uint64_t v4 = *(void *)(a1 + 40);
      id v9 = 0;
      id v5 = +[MBCKEncryptionManager loadRestoreKeyBagsWithAccount:v4 error:&v9];
      id v6 = v9;
      if (v5)
      {
        [*(id *)(a1 + 32) setRestoreKeyBagsByID:v5];
      }
      else
      {
        uint64_t v7 = MBGetDefaultLog();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          id v11 = v6;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to load the restore keybags when device unlocked: %@", buf, 0xCu);
          _MBLog();
        }

        [*(id *)(a1 + 48) setPreferencesValue:&__kCFBooleanTrue forKey:@"NotifyDaemonNextTimeKeyBagIsUnlocked"];
      }
      id v8 = self;
    }
  }
}

void sub_1000D0804(uint64_t a1)
{
  +[MBCKEncryptionManager keybagIsUnlockedWithAccount:*(void *)(a1 + 32) serviceManager:*(void *)(a1 + 40)];
}

void sub_1000D0850(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v3 = +[MBDaemon sharedDaemon];
  [v3 releaseWorkAssertion:*(void *)(a1 + 48)];

  id v4 = self;
}

id sub_1000D1058(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return self;
}

void sub_1000D1184(uint64_t a1)
{
  uint64_t v1 = MBGetDefaultLog();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v2 = v1;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v3 = *(const __CFString **)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      CFStringRef v168 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received accountChange:%@", buf, 0xCu);
    }

    long long v114 = *(void **)(a1 + 32);
    _MBLog();
  }

  long long v161 = 0u;
  long long v162 = 0u;
  long long v159 = 0u;
  long long v160 = 0u;
  id v4 = +[MBServiceAccount allServiceAccounts];
  id v5 = [v4 countByEnumeratingWithState:&v159 objects:v175 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v160;
LABEL_7:
    uint64_t v8 = 0;
    while (1)
    {
      if (*(void *)v160 != v7) {
        objc_enumerationMutation(v4);
      }
      id v9 = *(void **)(*((void *)&v159 + 1) + 8 * v8);
      BOOL v10 = objc_msgSend(v9, "accountIdentifier", v114);
      id v11 = [*(id *)(a1 + 32) accountIdentifier];
      unsigned int v12 = [v10 isEqualToString:v11];

      if (v12) {
        break;
      }
      if (v6 == (id)++v8)
      {
        id v6 = [v4 countByEnumeratingWithState:&v159 objects:v175 count:16];
        if (v6) {
          goto LABEL_7;
        }
        goto LABEL_13;
      }
    }
    id v13 = v9;
    unsigned int v14 = [*(id *)(a1 + 32) isPrimaryAccount];
    if (v14 != [v13 isPrimaryAccount]
      && MBIsInternalInstall()
      && !dword_1004823E0
      && !atomic_fetch_add_explicit(&dword_1004823E0, 1u, memory_order_relaxed))
    {
      unsigned int v15 = MBGetDefaultLog();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        __int16 v16 = v15;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "Account notifications are out of sync", buf, 2u);
        }

        _MBLog();
      }
    }
    if (v13)
    {
      uint64_t v17 = [v13 isPrimaryAccount];
      uint64_t v129 = 0;
      goto LABEL_26;
    }
  }
  else
  {
LABEL_13:
  }
  uint64_t v17 = objc_msgSend(*(id *)(a1 + 32), "isPrimaryAccount", v114);
  id v13 = 0;
  uint64_t v129 = 1;
LABEL_26:
  uint64_t v18 = MBGetDefaultLog();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v19 = v18;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      id v20 = [v13 accountIdentifier];
      dispatch_time_t v21 = [v13 dsid];
      unsigned int v22 = [v13 isEnabled];
      *(_DWORD *)buf = 138544386;
      CFStringRef v168 = v20;
      __int16 v169 = 2112;
      id v170 = v21;
      __int16 v171 = 1024;
      *(_DWORD *)id v172 = v22;
      *(_WORD *)&v172[4] = 1024;
      *(_DWORD *)&v172[6] = v17;
      __int16 v173 = 1024;
      id v23 = v17;
      uint64_t v24 = v129;
      int v174 = v129;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Account changed: %{public}@, dsid:%@, enabled:%d, isPrimary:%d, isRemoved:%d", buf, 0x28u);
    }
    else
    {
      id v23 = v17;
      uint64_t v24 = v129;
    }

    uint64_t v25 = [v13 accountIdentifier];
    [v13 dsid];
    LODWORD(v129) = v24;
    long long v124 = v23;
    long long v119 = v125 = v24;
    uint64_t v122 = [v13 isEnabled];
    long long v114 = v25;
    _MBLog();

    uint64_t v17 = v23;
  }

  long long v126 = +[MBCKRemoteConfiguration sharedInstance];
  char v127 = v13;
  if (v17)
  {
    [*(id *)(a1 + 40) _updateLockdownKeysForAccountState:v13];
    if (v129)
    {
      long long v26 = +[MBPersona personalPersonaWithError:0];
      [v26 setPreferencesValue:0 forKey:@"AccountEnabledDate"];
      [v26 setPreferencesValue:0 forKey:@"DisabledDomains"];
      [v26 setPreferencesValue:0 forKey:@"NilBackupDateFetchDate"];
      [v26 setPreferencesValue:0 forKey:@"FSEventState"];
      [v26 setPreferencesValue:0 forKey:@"BackupStateInfo"];
      [v126 resetCachedConfigurationForAccount:0];

      uint64_t v27 = a1;
      goto LABEL_35;
    }
    if ([v13 isEnabled] && objc_msgSend(v13, "isAuthenticated"))
    {
      int v31 = +[MBDaemon sharedDaemon];
      [v31 holdWorkAssertion:*(void *)(a1 + 56)];

      uint64_t v32 = [*(id *)(a1 + 40) databaseManager];
      v158[0] = _NSConcreteStackBlock;
      v158[1] = 3221225472;
      v158[2] = sub_1000D2550;
      v158[3] = &unk_100412860;
      v158[4] = *(void *)(a1 + 56);
      [v32 fetchConfigurationWithAccount:v13 configuration:v126 completion:v158];
    }
LABEL_47:
    if (objc_msgSend(v13, "isEnabled", v114, v119, v122, v124, v125))
    {
      id v33 = [v13 persona];
      id v34 = [v33 copyPreferencesValueForKey:@"AccountEnabledDate" class:objc_opt_class()];

      if (v34) {
        goto LABEL_60;
      }
      uint64_t v35 = +[NSDate date];
      id v36 = MBGetDefaultLog();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v37 = v17;
        __int16 v38 = v36;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          id v39 = [v13 accountIdentifier];
          MBStringWithDate();
          id v40 = (id)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138543874;
          CFStringRef v168 = @"AccountEnabledDate";
          __int16 v169 = 2114;
          id v170 = v39;
          __int16 v171 = 2114;
          *(void *)id v172 = v40;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Updating %{public}@ for account %{public}@: %{public}@", buf, 0x20u);
        }
        int v41 = [v13 accountIdentifier];
        MBStringWithDate();
        v123 = long long v120 = v41;
        CFStringRef v116 = @"AccountEnabledDate";
        _MBLog();

        uint64_t v17 = v37;
      }

      unsigned __int8 v42 = [v13 persona];
      [v42 setPreferencesValue:v35 forKey:@"AccountEnabledDate"];

      id v34 = 0;
    }
    else
    {
      BOOL v43 = MBGetDefaultLog();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        unsigned __int8 v44 = v43;
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v45 = [v13 accountIdentifier];
          *(_DWORD *)buf = 138543618;
          CFStringRef v168 = @"AccountEnabledDate";
          __int16 v169 = 2114;
          id v170 = v45;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Clearing %{public}@ for account %{public}@", buf, 0x16u);
        }
        [v13 accountIdentifier];
        v120 = CFStringRef v116 = @"AccountEnabledDate";
        _MBLog();
      }
      uint64_t v46 = [v13 persona];
      [v46 setPreferencesValue:0 forKey:@"AccountEnabledDate"];

      id v34 = +[MBXPCServer sharedInstance];
      uint64_t v35 = [v34 scheduler];
      [v35 clearNilBackupDateFetchDateForAccount:v13];
    }

LABEL_60:
    id v139 = [v13 accountIdentifier];
    uint64_t v47 = [v13 persona];
    id v128 = [v47 personaIdentifier];

    if ([v13 isEnabled])
    {
      long long v30 = 0;
    }
    else
    {
      CFStringRef v48 = [*(id *)(*(void *)(a1 + 40) + 40) objectForKeyedSubscript:v13];
      char v166 = v48;
      long long v30 = +[NSArray arrayWithObjects:&v166 count:1];
    }
    goto LABEL_63;
  }
  uint64_t v27 = a1;
  if ((v129 & 1) == 0) {
    goto LABEL_47;
  }
LABEL_35:
  objc_msgSend(*(id *)(v27 + 32), "accountIdentifier", v114, v119, v122, v124, v125);
  id v139 = (__CFString *)objc_claimAutoreleasedReturnValue();
  id v128 = [*(id *)(v27 + 32) personaIdentifier];
  if (!v128
    && ([*(id *)(v27 + 32) isPrimaryAccount] & 1) == 0
    && MBIsInternalInstall()
    && !dword_1004823E4
    && !atomic_fetch_add_explicit(&dword_1004823E4, 1u, memory_order_relaxed))
  {
    long long v28 = MBGetDefaultLog();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      CFStringRef v29 = *(const __CFString **)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      CFStringRef v168 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "Account change %@ has nil personaIdentifier", buf, 0xCu);
      uint64_t v115 = *(void *)(a1 + 32);
      _MBLog();
    }

    uint64_t v27 = a1;
  }
  long long v30 = objc_msgSend(*(id *)(*(void *)(v27 + 40) + 40), "allPersonaStates", v115);
LABEL_63:
  if (objc_msgSend(v30, "count", v116, v120, v123))
  {
    uint64_t v49 = MBGetDefaultLog();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v50 = v49;
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        CFStringRef v168 = v139;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Canceling the backup/scan engines for account %{public}@", buf, 0xCu);
      }

      long long v117 = v139;
      _MBLog();
    }
  }
  long long v156 = 0u;
  long long v157 = 0u;
  long long v154 = 0u;
  long long v155 = 0u;
  id obj = v30;
  id v51 = [obj countByEnumeratingWithState:&v154 objects:v165 count:16];
  if (v51)
  {
    id v52 = v51;
    uint64_t v53 = *(void *)v155;
    uint64_t v131 = *(void *)v155;
    do
    {
      uint64_t v54 = 0;
      id v132 = v52;
      do
      {
        if (*(void *)v155 != v53) {
          objc_enumerationMutation(obj);
        }
        id v55 = *(void **)(*((void *)&v154 + 1) + 8 * (void)v54);
        if (objc_msgSend(v55, "serviceState", v117, v121) == 1
          || [v55 serviceState] == 3)
        {
          id v137 = [v55 serviceGroup];
          long long v150 = 0u;
          long long v151 = 0u;
          long long v152 = 0u;
          long long v153 = 0u;
          id v56 = [v55 engines];
          id v57 = [v56 countByEnumeratingWithState:&v150 objects:v164 count:16];
          if (v57)
          {
            id v58 = v57;
            char v135 = v54;
            char v59 = 0;
            uint64_t v60 = *(void *)v151;
            id v61 = &off_100439000;
            do
            {
              for (uint64_t i = 0; i != v58; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v151 != v60) {
                  objc_enumerationMutation(v56);
                }
                id v63 = *(void **)(*((void *)&v150 + 1) + 8 * i);
                if ([v63 isCloudKitEngine]
                  && [v63 conformsToProtocol:v61[187]])
                {
                  long long v64 = [v63 serviceAccount];
                  long long v65 = [v64 accountIdentifier];
                  long long v66 = v65;
                  if (v65) {
                    char v67 = 0;
                  }
                  else {
                    char v67 = (char)v17;
                  }
                  if ((v67 & 1) != 0 || [v65 isEqualToString:v139])
                  {
                    long long v68 = v17;
                    long long v69 = MBGetDefaultLog();
                    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
                    {
                      long long v70 = v69;
                      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 138543618;
                        CFStringRef v168 = v139;
                        __int16 v169 = 2114;
                        id v170 = v63;
                        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "Canceling engine for account %{public}@: %{public}@", buf, 0x16u);
                      }

                      id v121 = v63;
                      _MBLog();
                    }

                    long long v71 = +[MBEngine stringForEngineMode:](MBEngine, "stringForEngineMode:", [v63 engineMode]);
                    CFStringRef v72 = +[MBError errorWithCode:217, @"%@ cancelled", v71 format];

                    [v63 cancelWithError:v72];
                    char v59 = 1;
                    uint64_t v17 = v68;
                    id v61 = &off_100439000;
                  }
                }
              }
              id v58 = [v56 countByEnumeratingWithState:&v150 objects:v164 count:16];
            }
            while (v58);

            uint64_t v53 = v131;
            id v52 = v132;
            uint64_t v54 = v135;
            id v73 = v137;
            if (v59)
            {
              dispatch_time_t v74 = dispatch_time(0, 60000000000);
              if (dispatch_group_wait(v137, v74)) {
                objc_exception_throw([objc_alloc((Class)MBException) initWithCode:1 format:@"Timed out while canceling engine"]);
              }
            }
          }
          else
          {

            id v73 = v137;
          }
        }
        uint64_t v54 = (char *)v54 + 1;
      }
      while (v54 != v52);
      id v52 = [obj countByEnumeratingWithState:&v154 objects:v165 count:16];
    }
    while (v52);
  }

  char v75 = v129;
  if (v128) {
    int v76 = v129;
  }
  else {
    int v76 = 0;
  }
  if (v76 == 1)
  {
    long long v77 = dispatch_get_global_queue(17, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000D25A8;
    block[3] = &unk_100411128;
    id v149 = v128;
    dispatch_async(v77, block);

    char v75 = v129;
  }
  id v78 = v127;
  if (v75)
  {
    id v79 = +[MBFollowUpManager sharedManager];
    id v80 = [*(id *)(a1 + 32) accountIdentifier];
    [v79 clearPendingFollowUpsWithAccountIdentifier:v80 identifiers:&off_10043B1A8];

    id v81 = 0;
  }
  else
  {
    uint64_t v82 = a1;
    if (([v127 isEnabled] & 1) == 0
      && +[MBCKDatabaseManager fetchedSyncZoneWithAccount:v127])
    {
      MBDeviceUUID();
      long long v83 = (__CFString *)objc_claimAutoreleasedReturnValue();
      long long v84 = *(void **)(a1 + 40);
      id v147 = 0;
      unsigned __int8 v85 = [v84 clearPendingSnapshotForBackupUUID:v83 enabledState:0 account:v127 error:&v147];
      id v86 = v147;
      if ((v85 & 1) == 0)
      {
        id v87 = MBGetDefaultLog();
        if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
        {
          char v88 = (char)v17;
          uint64_t v17 = v87;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543618;
            CFStringRef v168 = v83;
            __int16 v169 = 2112;
            id v170 = v86;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to removed the pending snapshots for device %{public}@: %@", buf, 0x16u);
          }

          long long v117 = v83;
          id v121 = v86;
          _MBLog();
          LOBYTE(v17) = v88;
        }
      }
      uint64_t v82 = a1;
    }
    if (objc_msgSend(v127, "isEnabled", v117, v121)) {
      goto LABEL_147;
    }
    +[MBFollowUpManager sharedManager];
    v90 = uint64_t v89 = v82;
    id v91 = [*(id *)(v89 + 32) accountIdentifier];
    [v90 clearPendingFollowUpsWithAccountIdentifier:v91 identifiers:&off_10043B1A8];

    id v79 = [*(id *)(*(void *)(v89 + 40) + 40) objectForKeyedSubscript:v127];
    id v81 = v79;
  }

  uint64_t v92 = [v81 encryptionManager];
  __int16 v93 = (void *)v92;
  if (v92)
  {
    __int16 v133 = (void *)v92;
    id v136 = v81;
    char v138 = (char)v17;
    long long v145 = 0u;
    long long v146 = 0u;
    long long v143 = 0u;
    long long v144 = 0u;
    uint64_t v94 = [v127 persona];
    char v95 = [v94 volumesToBackUp];

    id v96 = [v95 countByEnumeratingWithState:&v143 objects:v163 count:16];
    if (v96)
    {
      id v97 = v96;
      uint64_t v98 = *(void *)v144;
      do
      {
        for (j = 0; j != v97; j = (char *)j + 1)
        {
          if (*(void *)v144 != v98) {
            objc_enumerationMutation(v95);
          }
          CFStringRef v100 = *(const __CFString **)(*((void *)&v143 + 1) + 8 * (void)j);
          id v142 = 0;
          unsigned __int8 v101 = +[MBCKEncryptionManager tearDownBackupForVolume:error:](MBCKEncryptionManager, "tearDownBackupForVolume:error:", v100, &v142, v117, v121);
          id v102 = v142;
          if ((v101 & 1) == 0)
          {
            uint64_t v103 = MBGetDefaultLog();
            if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
            {
              uint64_t v104 = v103;
              if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412546;
                CFStringRef v168 = v100;
                __int16 v169 = 2114;
                id v170 = v102;
                _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_ERROR, "Failed to tear down backup for %@: %{public}@", buf, 0x16u);
              }

              long long v117 = (__CFString *)v100;
              id v121 = v102;
              _MBLog();
            }
          }
        }
        id v97 = [v95 countByEnumeratingWithState:&v143 objects:v163 count:16];
      }
      while (v97);
    }

    id v78 = v127;
    id v81 = v136;
    LOBYTE(v17) = v138;
    __int16 v93 = v133;
  }
  char v105 = v17 ^ 1;
  if (!v81) {
    char v105 = 1;
  }
  uint64_t v82 = a1;
  if ((v105 & 1) == 0)
  {
    if ([v81 serviceState] - 4 > 2)
    {
      [*(id *)(a1 + 40) resetCacheWithAccount:v78 error:0];
    }
    else
    {
      uint64_t v106 = MBGetDefaultLog();
      if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v107 = v106;
        if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEBUG, "Not resetting cache as we're in the middle of a restore", buf, 2u);
        }

        _MBLog();
      }

      uint64_t v82 = a1;
    }
  }

  if ((v129 & 1) == 0)
  {
LABEL_147:
    char v108 = objc_msgSend(*(id *)(*(void *)(v82 + 40) + 40), "objectForKeyedSubscript:", v78, v117);
    if ([v108 serviceState] == 5)
    {
      char v109 = MBGetDefaultLog();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
      {
        id v110 = v109;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
        {
          char v111 = [v78 accountIdentifier];
          *(_DWORD *)buf = 138543362;
          CFStringRef v168 = v111;
          _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "Account (%{public}@) changed during background restore - retrying pending downloads if necessary", buf, 0xCu);

          id v78 = v127;
        }

        id v118 = [v78 accountIdentifier];
        _MBLog();
      }
      char v112 = *(void **)(a1 + 40);
      v140[0] = _NSConcreteStackBlock;
      v140[1] = 3221225472;
      v140[2] = sub_1000D2600;
      v140[3] = &unk_100412378;
      v140[4] = v112;
      id v141 = *(id *)(a1 + 48);
      [v112 fetchNetworkConnectivityWithBlock:v140];
    }
  }
  id v113 = self;
}

void sub_1000D2550(uint64_t a1)
{
  id v2 = +[MBDaemon sharedDaemon];
  [v2 releaseWorkAssertion:*(void *)(a1 + 32)];
}

void sub_1000D25A8(uint64_t a1)
{
  id v2 = +[AppRestoreDispatcher shared];
  [v2 cancelAndUninstallRestorerForPersonaIdentifier:*(void *)(a1 + 32)];
}

id sub_1000D2600(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return self;
}

void sub_1000D28A8(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKeyedSubscript:*(void *)(a1 + 40)];
  CFStringRef v3 = [v2 restoreSession];
  id v4 = v3;
  if (v3 && [v3 isMBSSession])
  {
    uint64_t v5 = *(void *)(a1 + 48);
    v9.receiver = *(id *)(a1 + 32);
    v9.super_class = (Class)MBCKManager;
    objc_msgSendSuper2(&v9, "lockManagerDidReleaseLock:", v5);
  }
  else
  {
    id v6 = *(void **)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = NSStringFromSelector(*(SEL *)(a1 + 56));
    [v6 _finishedRestoreWithAccount:v7 reason:v8];
  }
}

void sub_1000D2BB8(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKeyedSubscript:*(void *)(a1 + 40)];
  CFStringRef v3 = [v2 restoreSession];
  id v4 = v3;
  if (v3 && [v3 isMBSSession])
  {
    uint64_t v5 = *(void *)(a1 + 48);
    v9.receiver = *(id *)(a1 + 32);
    v9.super_class = (Class)MBCKManager;
    objc_msgSendSuper2(&v9, "lockManagerDidReleaseLock:", v5);
  }
  else
  {
    id v6 = *(void **)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = NSStringFromSelector(*(SEL *)(a1 + 56));
    [v6 _finishedRestoreWithAccount:v7 reason:v8];
  }
}

void sub_1000D44F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
}

void sub_1000D4554(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v32 = a2;
  id v7 = a3;
  id v8 = a4;
  uint64_t v35 = v7;
  if (v8)
  {
    if (+[MBError isCKNotFoundError:](MBError, "isCKNotFoundError:", v8, v32, v8))
    {
      id v9 = *(id *)(a1 + 32);
      objc_sync_enter(v9);
      ++*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
      objc_sync_exit(v9);
    }
  }
  else
  {
    uint64_t v10 = objc_msgSend(v7, "objectForKeyedSubscript:", @"owners", v32, 0);
    id v11 = (void *)v10;
    if (v10) {
      unsigned int v12 = (void *)v10;
    }
    else {
      unsigned int v12 = &__NSArray0__struct;
    }
    id v13 = v12;

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      __assert_rtn("-[MBCKManager deviceLockInfosWithAccount:connection:error:]_block_invoke", "MBCKManager.m", 6062, "!ownerUUIDs || [ownerUUIDs isKindOfClass:NSArray.class]");
    }
    uint64_t v14 = [v35 objectForKeyedSubscript:@"births"];
    unsigned int v15 = (void *)v14;
    if (v14) {
      __int16 v16 = (void *)v14;
    }
    else {
      __int16 v16 = &__NSArray0__struct;
    }
    id v17 = v16;

    objc_opt_class();
    id v40 = v17;
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      __assert_rtn("-[MBCKManager deviceLockInfosWithAccount:connection:error:]_block_invoke", "MBCKManager.m", 6064, "!creationDates || [creationDates isKindOfClass:NSArray.class]");
    }
    uint64_t v18 = [v35 objectForKeyedSubscript:@"expirations"];
    __int16 v19 = (void *)v18;
    if (v18) {
      id v20 = (void *)v18;
    }
    else {
      id v20 = &__NSArray0__struct;
    }
    id v21 = v20;

    objc_opt_class();
    unsigned int v22 = v21;
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      __assert_rtn("-[MBCKManager deviceLockInfosWithAccount:connection:error:]_block_invoke", "MBCKManager.m", 6066, "!expirationDates || [expirationDates isKindOfClass:NSArray.class]");
    }
    id v38 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v13, "count"));
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    id obj = v13;
    id v39 = [obj countByEnumeratingWithState:&v41 objects:v45 count:16];
    if (v39)
    {
      uint64_t v23 = 0;
      uint64_t v37 = *(void *)v42;
      do
      {
        for (uint64_t i = 0; i != v39; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v42 != v37) {
            objc_enumerationMutation(obj);
          }
          uint64_t v25 = *(void *)(*((void *)&v41 + 1) + 8 * i);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0) {
            __assert_rtn("-[MBCKManager deviceLockInfosWithAccount:connection:error:]_block_invoke", "MBCKManager.m", 6071, "[ownerUUID isKindOfClass:NSString.class]");
          }
          long long v26 = [*(id *)(a1 + 40) objectForKeyedSubscript:v25];
          uint64_t v27 = [v26 deviceName];
          if ((char *)i + v23 >= [v40 count])
          {
            long long v28 = 0;
          }
          else
          {
            long long v28 = [v40 objectAtIndexedSubscript:(char *)i + v23];
            if (v28)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0) {
                __assert_rtn("-[MBCKManager deviceLockInfosWithAccount:connection:error:]_block_invoke", "MBCKManager.m", 6076, "!creationDate || [creationDate isKindOfClass:NSDate.class]");
              }
            }
          }
          if ((char *)i + v23 >= [v22 count])
          {
            CFStringRef v29 = 0;
          }
          else
          {
            CFStringRef v29 = [v22 objectAtIndexedSubscript:(char *)i + v23];
            if (v29)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0) {
                __assert_rtn("-[MBCKManager deviceLockInfosWithAccount:connection:error:]_block_invoke", "MBCKManager.m", 6078, "!expirationDate || [expirationDate isKindOfClass:NSDate.class]");
              }
            }
          }
          long long v30 = objc_opt_new();
          [v30 setDeviceName:*(void *)(a1 + 48)];
          [v30 setDeviceUUID:*(void *)(a1 + 56)];
          [v30 setOwnerDeviceUUID:v25];
          [v30 setOwnerDeviceName:v27];
          [v30 setCreationDate:v28];
          [v30 setExpirationDate:v29];
          [v38 addObject:v30];
        }
        id v39 = [obj countByEnumeratingWithState:&v41 objects:v45 count:16];
        v23 += (uint64_t)i;
      }
      while (v39);
    }

    id v31 = *(id *)(a1 + 32);
    objc_sync_enter(v31);
    [*(id *)(a1 + 64) addObjectsFromArray:v38];
    ++*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
    objc_sync_exit(v31);
  }
}

void sub_1000D4A68(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D4A84(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D4D58(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  attr = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_UTILITY, 0);

  dispatch_queue_t v2 = dispatch_queue_create("com.apple.backupd.retryAppDataDownloads", attr);
  CFStringRef v3 = (void *)qword_100482408;
  qword_100482408 = (uint64_t)v2;
}

void sub_1000D4DDC(uint64_t a1)
{
  id v2 = +[AppRestoreDispatcher shared];
  [v2 retryAppDataDownloadsForAccount:*(void *)(a1 + 32)];
}

void sub_1000D5248(uint64_t a1)
{
  [*(id *)(a1 + 32) run];
  [*(id *)(a1 + 40) drop];
  CFStringRef v3 = +[MBDaemon sharedDaemon];
  [v3 releaseWorkAssertion:*(void *)(a1 + 80)];

  id v4 = *(NSObject **)(*(void *)(a1 + 48) + 16);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  uint64_t v5[2] = sub_1000D536C;
  v5[3] = &unk_100411608;
  id v6 = *(id *)(a1 + 56);
  id v7 = *(id *)(a1 + 64);
  id v8 = *(id *)(a1 + 32);
  id v9 = *(id *)(a1 + 72);
  dispatch_async(v4, v5);
}

void sub_1000D536C(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [*(id *)(a1 + 40) enginesByContext];
    [v2 removeObjectForKey:*(void *)(a1 + 32)];
  }
  [*(id *)(a1 + 48) setWatchdog:0];
  CFStringRef v3 = [*(id *)(a1 + 40) engines];
  uint64_t v10 = *(void *)(a1 + 48);
  id v4 = +[NSArray arrayWithObjects:&v10 count:1];
  uint64_t v5 = [v3 arrayByExcludingObjectsInArray:v4];
  [*(id *)(a1 + 40) setEngines:v5];

  id v6 = +[MBXPCServer sharedInstance];
  id v7 = [v6 connectionsQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D54E4;
  block[3] = &unk_100411128;
  id v9 = *(id *)(a1 + 56);
  dispatch_async(v7, block);
}

id sub_1000D54E4()
{
  return self;
}

void sub_1000D57D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000D57F0(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40), a2);
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 80);
    if (v5 == 1)
    {
      id v6 = *(void **)(a1 + 40);
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v8 = *(void *)(a1 + 56);
      uint64_t v9 = *(void *)(a1 + 64);
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = sub_1000D5990;
      long long v18[3] = &unk_100410FC8;
      uint64_t v20 = *(void *)(a1 + 72);
      id v19 = *(id *)(a1 + 32);
      [v6 _startSourceDeviceTransferWithSessionInfo:v7 connection:v8 personaIdentifier:v9 completion:v18];
      uint64_t v10 = v19;
    }
    else
    {
      if (v5 != 2) {
        __assert_rtn("-[MBCKManager startDeviceTransferWithTaskType:sessionInfo:connection:error:]_block_invoke", "MBCKManager.m", 6215, "taskType == MBDeviceTransferTaskTypeTarget");
      }
      id v11 = *(void **)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 64);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      _OWORD v15[2] = sub_1000D59F0;
      v15[3] = &unk_100410FC8;
      uint64_t v17 = *(void *)(a1 + 72);
      id v16 = *(id *)(a1 + 32);
      [v11 _startTargetDeviceTransferWithSessionInfo:v12 connection:v13 personaIdentifier:v14 completion:v15];
      uint64_t v10 = v16;
    }
  }
}

void sub_1000D5990(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D59F0(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D5DD0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_1000D5DF0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(NSObject **)(v3 + 16);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000D5EC0;
  v8[3] = &unk_100412888;
  v8[4] = v3;
  id v9 = WeakRetained;
  id v5 = *(id *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 56);
  id v10 = v5;
  uint64_t v11 = v6;
  id v7 = WeakRetained;
  dispatch_async(v4, v8);
}

void sub_1000D5EC0(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 32) removeObject:*(void *)(a1 + 40)];
  *(_DWORD *)(*(void *)(a1 + 32) + _Block_object_dispose(&STACK[0x250], 8) = 0;
  [*(id *)(a1 + 48) setServiceState:0];
  uint64_t v2 = +[MBDaemon sharedDaemon];
  [v2 releaseWorkAssertion:*(void *)(a1 + 56)];

  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 24);
  dispatch_group_leave(v3);
}

void sub_1000D5F5C(uint64_t a1)
{
  dispatch_group_enter(*(dispatch_group_t *)(*(void *)(a1 + 32) + 24));
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  [*(id *)(a1 + 40) start];
}

void sub_1000D634C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_1000D636C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(NSObject **)(v3 + 16);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000D643C;
  v8[3] = &unk_100412888;
  v8[4] = v3;
  id v9 = WeakRetained;
  id v5 = *(id *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 56);
  id v10 = v5;
  uint64_t v11 = v6;
  id v7 = WeakRetained;
  dispatch_async(v4, v8);
}

void sub_1000D643C(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 32) removeObject:*(void *)(a1 + 40)];
  *(_DWORD *)(*(void *)(a1 + 32) + _Block_object_dispose(&STACK[0x250], 8) = 0;
  [*(id *)(a1 + 48) setServiceState:0];
  uint64_t v2 = +[MBDaemon sharedDaemon];
  [v2 releaseWorkAssertion:*(void *)(a1 + 56)];

  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 24);
  dispatch_group_leave(v3);
}

void sub_1000D64D8(uint64_t a1)
{
  dispatch_group_enter(*(dispatch_group_t *)(*(void *)(a1 + 32) + 24));
  [*(id *)(a1 + 40) start];
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000D6674(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v1 + 8) == 3)
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    id v3 = *(id *)(v1 + 32);
    id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v13;
      do
      {
        id v7 = 0;
        do
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8 * (void)v7);
          objc_opt_class();
          if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
          {
            id v9 = v8;
            id v10 = objc_msgSend(v9, "connection", (void)v12);
            uint64_t v11 = *(void **)(a1 + 40);

            if (v10 == v11) {
              [v8 cancel];
            }
          }
          id v7 = (char *)v7 + 1;
        }
        while (v5 != v7);
        id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v5);
    }
  }
}

void sub_1000D69B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v1 + 8) == 3)
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    id v3 = *(id *)(v1 + 32);
    id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v13;
      do
      {
        id v7 = 0;
        do
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8 * (void)v7);
          objc_opt_class();
          if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
          {
            id v9 = v8;
            id v10 = objc_msgSend(v9, "connection", (void)v12);
            uint64_t v11 = *(void **)(a1 + 40);

            if (v10 == v11) {
              [v8 resume];
            }
          }
          id v7 = (char *)v7 + 1;
        }
        while (v5 != v7);
        id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v5);
    }
  }
}

void sub_1000D6E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000D6E98(void *a1)
{
  uint64_t v2 = a1[4];
  if (*(_DWORD *)(v2 + 8) == 3)
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    id v3 = *(id *)(v2 + 32);
    id v4 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v16;
      while (2)
      {
        for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v16 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void **)(*((void *)&v15 + 1) + 8 * i);
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            id v9 = [v8 connection];
            id v10 = (void *)a1[5];

            if (v9 == v10)
            {
              objc_storeStrong((id *)(*(void *)(a1[7] + 8) + 40), v8);
              goto LABEL_16;
            }
          }
        }
        id v5 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }
  }
  else
  {
    uint64_t v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = *(_DWORD *)(a1[4] + 8);
      *(_DWORD *)buf = 67109120;
      int v21 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid state: %d", buf, 8u);
      _MBLog();
    }

    uint64_t v13 = +[MBError errorWithCode:1 format:@"Invalid state"];
    uint64_t v14 = *(void *)(a1[6] + 8);
    id v3 = *(id *)(v14 + 40);
    *(void *)(v14 + 40) = v13;
  }
LABEL_16:
}

id sub_1000D76F8(uint64_t a1)
{
  return [*(id *)(a1 + 32) setFinishedAppRestores:1];
}

void sub_1000D7874(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D7BA0(uint64_t a1)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 40), "allPersonaStates", 0);
  id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v10 + 1) + 8 * i);
        if ([v8 serviceState] == 5)
        {
          id v9 = [v8 backgroundRestoreProgressMonitor];
          unint64_t v1 = v1 & 0xFFFFFFFF00000000 | *(unsigned int *)(a1 + 44);
          [v9 handleNetworkPathUpdateWithType:*(unsigned int *)(a1 + 40) state:v1];
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v5);
  }
}

void sub_1000D7E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_sync_exit(v15);
  _Unwind_Resume(a1);
}

void sub_1000D7E88(uint64_t a1, uint64_t a2, unsigned int a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _handleNetworkPathUpdateWithPathType:a2 state:a3];
}

void sub_1000D8030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000D8048(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  *(void *)(v3 + 32) = a2;
  *(void *)(v3 + 40) = a3;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D811C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000D8138(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    string = xpc_dictionary_get_string(v3, _xpc_event_key_name);
    if (string)
    {
      uint64_t v6 = +[NSString stringWithUTF8String:string];
      id v7 = MBGetDefaultLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        long long v12 = v6;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "com.apple.notifyd.matching: %@", buf, 0xCu);
        long long v10 = v6;
        _MBLog();
      }

      char v8 = BYSetupAssistantNeedsToRun();
      if (![v6 isEqualToString:@"AppleLanguagePreferencesChangedNotification"]
        || (v8 & 1) != 0)
      {
        if (objc_msgSend(v6, "isEqualToString:", @"com.apple.security.octagon.trust-status-change", v10)|| objc_msgSend(v6, "isEqualToString:", @"com.apple.security.secureobjectsync.circlechanged")|| objc_msgSend(v6, "isEqualToString:", @"com.apple.security.secureobjectsync.viewschanged"))
        {
          [WeakRetained _keychainSyncStatusDidChange];
        }
        else
        {
          id v9 = MBGetDefaultLog();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            long long v12 = v6;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "-[MBCKManager setUpXPCEventHandler] does not need to handle event: %@", buf, 0xCu);
            _MBLog();
          }
        }
      }
      else
      {
        [WeakRetained userLanguageDidChange];
      }
    }
  }
}

void sub_1000D8490(void *a1)
{
  id v2 = [*(id *)(a1[4] + 40) objectForKeyedSubscript:a1[5]];
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = [v2 serviceState] == 5;
}

void sub_1000D8614(void *a1)
{
  id v5 = [*(id *)(a1[4] + 40) objectForKeyedSubscript:a1[5]];
  unsigned int v2 = [v5 serviceState];
  BOOL v4 = v2 == 6 || (v2 & 0xFFFFFFFE) == 4;
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = v4;
}

void sub_1000D8748(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 40) allPersonaStates];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    while (2)
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        if (objc_msgSend(*(id *)(*((void *)&v7 + 1) + 8 * i), "serviceState", (void)v7) == 5)
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
          goto LABEL_11;
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
LABEL_11:
}

void sub_1000D892C(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 40) allPersonaStates];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    while (2)
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        if (objc_msgSend(*(id *)(*((void *)&v7 + 1) + 8 * i), "serviceState", (void)v7))
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
          goto LABEL_11;
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
LABEL_11:
}

void sub_1000D8C1C(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKeyedSubscript:*(void *)(a1 + 40)];
  id v3 = [*(id *)(a1 + 40) persona];
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v5 + 40);
  uint64_t v6 = [v2 openOrUseExistingPlanWithPersona:v3 snapshotUUID:v4 error:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 8);
  long long v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;
}

void sub_1000D8E70(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKeyedSubscript:*(void *)(a1 + 40)];
  id v3 = [*(id *)(a1 + 40) persona];
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v5 + 40);
  unsigned __int8 v6 = [v2 closeRestorePlanWithPersona:v3 snapshotUUID:v4 error:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v6;
}

void sub_1000D9298(id a1)
{
  unint64_t v1 = MBGetCacheDir();
  id v2 = [v1 stringByAppendingPathComponent:@"cloudkit_cache.db"];
  id v6 = v1;
  sub_10005A9FC((const char *)[v6 fileSystemRepresentation], 8, 4, 3);
  id v3 = [objc_alloc((Class)NSString) initWithFormat:@"%@-wal", v2];
  id v4 = v2;
  sub_10005A9FC((const char *)[v4 fileSystemRepresentation], 16, 4, 3);
  id v5 = v3;
  sub_10005A9FC((const char *)[v5 fileSystemRepresentation], 16, 4, 3);
}

void sub_1000D9634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D9658(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000D9668(uint64_t a1)
{
}

void sub_1000D9670(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 60)) {
    goto LABEL_10;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 56) == 1)
  {
    id v3 = (atomic_uint *)*(id *)(v2 + 8);
    if ([(atomic_uint *)v3 invalidated])
    {
      uint64_t v4 = 8;
LABEL_7:
      uint64_t v5 = *(void *)(a1 + 32);
      id v6 = *(void **)(v5 + v4);
      *(void *)(v5 + v4) = 0;

      goto LABEL_10;
    }
  }
  else
  {
    id v3 = (atomic_uint *)*(id *)(v2 + 16);
    if ([(atomic_uint *)v3 invalidated])
    {
      uint64_t v4 = 16;
      goto LABEL_7;
    }
  }
  if (!v3)
  {
LABEL_10:
    uint64_t v7 = [[MBCKCache alloc] initWithTracker:*(void *)(a1 + 32)];
    if (!v7) {
      __assert_rtn("-[MBCKCacheTracker openCacheWithAccessType:cached:error:]_block_invoke", "MBCKCache.m", 153, "cache");
    }
    id v3 = (atomic_uint *)v7;
    if (*(_DWORD *)(a1 + 56) == 1) {
      uint64_t v8 = 6;
    }
    else {
      uint64_t v8 = 1;
    }
    id v27 = 0;
    unsigned __int8 v9 = [(MBCKCache *)v7 _openWithFlags:v8 error:&v27];
    id v10 = v27;
    if (v9)
    {
      [*(id *)(a1 + 32) _addCache:v3];
      int v11 = *(_DWORD *)(a1 + 56);
      uint64_t v12 = *(void *)(a1 + 32);
      long long v13 = v3;
      uint64_t v14 = v13;
      if (v11 == 1)
      {
        long long v15 = *(void **)(v12 + 8);
        *(void *)(v12 + _Block_object_dispose(&STACK[0x250], 8) = v13;
      }
      else
      {
        long long v15 = *(void **)(v12 + 16);
        *(void *)(v12 + 16) = v13;
      }

      unsigned int v22 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
      goto LABEL_26;
    }
    unsigned int v16 = +[MBError isError:v10 withCode:4];
    long long v17 = MBGetDefaultLog();
    long long v18 = v17;
    if (v16)
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = *(_DWORD *)(a1 + 56);
        uint64_t v20 = [*(id *)(a1 + 32) path];
        *(_DWORD *)buf = 67109634;
        int v29 = v19;
        __int16 v30 = 2114;
        id v31 = v20;
        __int16 v32 = 2112;
        id v33 = v10;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Failed to open cache (%d) at %{public}@: %@", buf, 0x1Cu);

        int v21 = [*(id *)(a1 + 32) path];
LABEL_24:
        _MBLog();
      }
    }
    else if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      int v23 = *(_DWORD *)(a1 + 56);
      uint64_t v24 = [*(id *)(a1 + 32) path];
      *(_DWORD *)buf = 67109634;
      int v29 = v23;
      __int16 v30 = 2114;
      id v31 = v24;
      __int16 v32 = 2112;
      id v33 = v10;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to open cache (%d) at %{public}@: %@", buf, 0x1Cu);

      int v21 = [*(id *)(a1 + 32) path];
      goto LABEL_24;
    }

    unsigned int v22 = (void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    uint64_t v14 = (atomic_uint *)v10;
LABEL_26:
    uint64_t v25 = v14;
    long long v26 = *v22;
    *unsigned int v22 = v25;

    goto LABEL_27;
  }
  atomic_fetch_add(v3 + 2, 1u);
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v3);
LABEL_27:
}

id sub_1000D9B54(uint64_t a1)
{
  [*(id *)(a1 + 32) _invalidate];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  return _[v2 _removeCache:v3];
}

void sub_1000DA934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000DA958(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = *(void *)(a1[7] + 8);
  id obj = *(id *)(v4 + 40);
  unsigned __int8 v5 = [v2 _resetDatabaseForAccount:v3 error:&obj];
  objc_storeStrong((id *)(v4 + 40), obj);
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = v5;
}

void sub_1000DABF8(uint64_t a1)
{
  uint64_t v2 = MBGetDefaultLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Closing PQL connection %@", buf, 0xCu);
    _MBLog();
  }

  uint64_t v4 = *(void **)(a1 + 32);
  id v9 = 0;
  unsigned __int8 v5 = [v4 close:&v9];
  id v6 = v9;
  if ((v5 & 1) == 0)
  {
    uint64_t v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 134218242;
      uint64_t v11 = v8;
      __int16 v12 = 2112;
      id v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to close the PQL connection %p: %@", buf, 0x16u);
      _MBLog();
    }
  }
}

void sub_1000DB3C8(_Unwind_Exception *a1)
{
}

void sub_1000DB520(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(v3 + 16);
    *(void *)(v3 + 16) = 0;

    unsigned __int8 v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      id v11 = v2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Closing PQL connection %@", buf, 0xCu);
      _MBLog();
    }

    id v9 = 0;
    unsigned __int8 v6 = [v2 close:&v9];
    id v7 = v9;
    if ((v6 & 1) == 0)
    {
      uint64_t v8 = MBGetDefaultLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218242;
        id v11 = v2;
        __int16 v12 = 2112;
        id v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to close the PQL connection %p: %@", buf, 0x16u);
        _MBLog();
      }
    }
  }
}

void sub_1000DB878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000DB890(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  uint64_t v3 = v2;
  if (v2)
  {
    [v2 setLastError:0];
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1000DB9D4;
    v11[3] = &unk_100412C38;
    id v12 = *(id *)(a1 + 40);
    if (([v3 groupInTransaction:v11] & 1) == 0)
    {
      uint64_t v4 = [v3 lastError];
      if (v4) {
        +[MBError errorWithCode:1 error:v4 format:@"The transaction was aborted"];
      }
      else {
      uint64_t v5 = +[MBError errorWithCode:1 format:@"The transaction was aborted"];
      }
      uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
      uint64_t v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v5;
    }
  }
  else
  {
    uint64_t v6 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
}

uint64_t sub_1000DB9D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000DBA50(uint64_t a1)
{
  return _[*(id *)(*(void *)(a1 + 32) + 16) forceBatchStart];
}

id sub_1000DBAC8(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 16) flush];
}

void sub_1000DBB98(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) tracker];
  if (!v2) {
    __assert_rtn("-[MBCKCache _removeCorruptDatabaseWithError:completion:]_block_invoke", "MBCKCache.m", 524, "tracker");
  }
  id v3 = v2;
  [v2 _removeCorruptDatabaseWithError:*(void *)(a1 + 40)];
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000DBFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000DC028(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (!WeakRetained) {
    goto LABEL_25;
  }
  id v11 = MBGetDefaultLog();
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  if (v8)
  {
    if (!v12) {
      goto LABEL_8;
    }
    *(_DWORD *)buf = 138412802;
    id v26 = v8;
    __int16 v27 = 2112;
    id v28 = v7;
    __int16 v29 = 2112;
    id v30 = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Sqlite request %@ failed on %@ with error: %@", buf, 0x20u);
    id v23 = v7;
    id v24 = v9;
    id v22 = v8;
  }
  else
  {
    if (!v12) {
      goto LABEL_8;
    }
    *(_DWORD *)buf = 138412546;
    id v26 = v7;
    __int16 v27 = 2112;
    id v28 = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Sqlite failed on %@ with error: %@", buf, 0x16u);
    id v22 = v7;
    id v23 = v9;
  }
  _MBLog();
LABEL_8:

  id v13 = [v9 domain];
  unsigned int v14 = [v13 isEqualToString:PQLSqliteErrorDomain];

  if (!v14) {
    goto LABEL_25;
  }
  unint64_t v15 = (unint64_t)[v9 code];
  id v16 = [v9 extendedSqliteCode];
  if (v15 > 0x18) {
    goto LABEL_19;
  }
  if (((1 << v15) & 0x1384000) != 0) {
    goto LABEL_11;
  }
  if (v15 != 1) {
    goto LABEL_15;
  }
  int v19 = [v9 userInfo];
  uint64_t v20 = [v19 objectForKeyedSubscript:@"SqliteSQL"];

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {

    goto LABEL_11;
  }
  unsigned __int8 v21 = [v20 isEqualToString:@"commit"];

  if ((v21 & 1) == 0)
  {
LABEL_11:
    long long v17 = MBGetDefaultLog();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      long long v18 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      id v26 = v18;
      __int16 v27 = 2112;
      id v28 = v9;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Unexpected SQLite error for db at %@: %@", buf, 0x16u);
      id v22 = *(id *)(a1 + 32);
      id v23 = v9;
      _MBLog();
    }

LABEL_15:
    if (v15 == 13)
    {
      sleep(5u);
      goto LABEL_25;
    }
  }
LABEL_19:
  if (v16 == (id)6922)
  {
    if (!*(unsigned char *)(a1 + 48)) {
      MBExit(1);
    }
  }
  else if (v15 == 26 || v15 == 11)
  {
    objc_msgSend(WeakRetained, "_removeCorruptDatabaseWithError:completion:", v9, &stru_100412C80, v22, v23, v24);
  }
LABEL_25:
}

void sub_1000DC368(id a1)
{
}

void sub_1000DCDF4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DCE34(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  v20[0] = @"CREATE TABLE IF NOT EXISTS FileChanges (domain TEXT, relativePath TEXT, size INTEGER, changeType INTEGER, PRIMARY KEY (domain, relativePath));";
  v20[1] = @"CREATE INDEX IF NOT EXISTS FileChangesDomainIdx ON FileChanges(domain);";
  v20[2] = @"CREATE INDEX IF NOT EXISTS FileChangesChangeTypeIdx ON FileChanges(changeType);";
  uint64_t v5 = +[NSArray arrayWithObjects:v20 count:3];
  v19[0] = @"CREATE TABLE IF NOT EXISTS FoundEncryptionKeys (inode INTEGER, path TEXT NOT NULL UNIQUE, key BLOB);";
  v19[1] = @"CREATE INDEX IF NOT EXISTS FoundEncryptionKeysInodeIdx ON FoundEncryptionKeys(inode);";
  void v19[2] = @"CREATE INDEX IF NOT EXISTS FoundEncryptionKeysPathIdx ON FoundEncryptionKeys(path);";
  uint64_t v6 = +[NSArray arrayWithObjects:v19 count:3];
  v18[0] = @"CREATE TABLE IF NOT EXISTS Snapshots (snapshotID TEXT PRIMARY KEY, committed INTEGER, created INTEGER, snapshot BLOB);";
  v18[1] = @"CREATE INDEX IF NOT EXISTS SnapshotsIDIdx ON Snapshots(snapshotID);";
  id v7 = +[NSArray arrayWithObjects:v18 count:2];
  v17[0] = @"CREATE TABLE IF NOT EXISTS Manifests (manifestID TEXT PRIMARY KEY, snapshotID TEXT, domain TEXT, manifest BLOB); ";
  v17[1] = @"CREATE INDEX IF NOT EXISTS ManifestsSnapshotIDIdx ON Manifests(snapshotID); ";
  v17[2] = @"CREATE INDEX IF NOT EXISTS ManifestsDomainIdx ON Manifests(domain); ";
  v17[3] = @"CREATE TRIGGER IF NOT EXISTS DeleteManifestFiles AFTER DELETE ON Manifests BEGIN DELETE FROM Files WHERE manifestID = OLD.manifestID;END;";
  id v8 = +[NSArray arrayWithObjects:v17 count:4];
  v16[0] = @"CREATE TABLE IF NOT EXISTS Files (fileID TEXT, manifestID TEXT, domain TEXT, modified INTEGER, relativePath TEXT, deleted INTEGER, fileType INTEGER, file BLOB, PRIMARY KEY (manifestID, relativePath, domain));";
  v16[1] = @"CREATE INDEX IF NOT EXISTS FilesManifestIDIdx ON Files(manifestID);";
  id v16[2] = @"CREATE INDEX IF NOT EXISTS FilesDomainRelativePathIdx ON Files(domain, relativePath);";
  id v9 = +[NSArray arrayWithObjects:v16 count:3];
  v15[0] = @"CREATE TABLE IF NOT EXISTS RestoreFiles (domain TEXT NOT NULL, fileID TEXT NOT NULL, relativePath TEXT NOT NULL, absolutePath TEXT DEFAULT NULL, restoreState INTEGER NOT NULL DEFAULT 0, FOREIGN KEY (fileID) REFERENCES Files(fileID), PRIMARY KEY (domain, relativePath)); ";
  v15[1] = @"CREATE INDEX IF NOT EXISTS RestoreFilesDomainIdx ON RestoreFiles(domain); ";
  _OWORD v15[2] = @"CREATE INDEX IF NOT EXISTS RestoreFilesAbsolutePathIdx ON RestoreFiles(absolutePath); ";
  v15[3] = @"CREATE INDEX IF NOT EXISTS RestoreFilesRestoreStateIdx ON RestoreFiles(restoreState);";
  uint64_t v10 = +[NSArray arrayWithObjects:v15 count:4];
  v14[0] = @"CREATE TABLE IF NOT EXISTS RestoreDomains (domain TEXT PRIMARY KEY, state INTEGER NOT NULL DEFAULT 0, agent TEXT DEFAULT NULL); ";
  v14[1] = @"CREATE INDEX IF NOT EXISTS RestoreDomainsStateIdx ON RestoreDomains(state); ";
  id v14[2] = @"CREATE INDEX IF NOT EXISTS RestoreDomainsAgentIdx ON RestoreDomains(agent);";
  id v11 = +[NSArray arrayWithObjects:v14 count:3];
  if (sub_1000E9070(v4, v5, a3)
    && sub_1000E9070(v4, v6, a3)
    && sub_1000E9070(v4, v7, a3)
    && sub_1000E9070(v4, v8, a3)
    && sub_1000E9070(v4, v9, a3)
    && sub_1000E9070(v4, v10, a3))
  {
    uint64_t v12 = sub_1000E9070(v4, v11, a3);
  }
  else
  {
    uint64_t v12 = 0;
  }

  return v12;
}

uint64_t sub_1000DD0F8(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B1C0, a3);
}

uint64_t sub_1000DD104(void *a1, uint64_t a2, void *a3)
{
  v8[0] = @"CREATE TABLE IF NOT EXISTS Restores (deviceUUID TEXT NOT NULL, snapshotUUID TEXT NOT NULL, state INTEGER NOT NULL DEFAULT 1, PRIMARY KEY (deviceUUID, snapshotUUID));";
  v8[1] = @"CREATE INDEX IF NOT EXISTS RestoresStateIdx ON Restores(state);";
  id v4 = a1;
  uint64_t v5 = +[NSArray arrayWithObjects:v8 count:2];
  uint64_t v6 = sub_1000E9070(v4, v5, a3);

  return v6;
}

uint64_t sub_1000DD1BC(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B1D8, a3);
}

uint64_t sub_1000DD1C8(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B1F0, a3);
}

uint64_t sub_1000DD1D4(void *a1, uint64_t a2, void *a3)
{
  CFStringRef v8 = @"CREATE TABLE IF NOT EXISTS Properties (key TEXT PRIMARY KEY, value TEXT);";
  id v4 = a1;
  uint64_t v5 = +[NSArray arrayWithObjects:&v8 count:1];
  uint64_t v6 = sub_1000E9070(v4, v5, a3);

  return v6;
}

uint64_t sub_1000DD284(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B208, a3);
}

uint64_t sub_1000DD290(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B220, a3);
}

uint64_t sub_1000DD29C(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B250, a3);
}

uint64_t sub_1000DD2A8(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B268, a3);
}

uint64_t sub_1000DD2B4(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B280, a3);
}

uint64_t sub_1000DD2C0(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B2B0, a3);
}

uint64_t sub_1000DD2CC(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  v41[0] = objc_opt_class();
  v41[1] = objc_opt_class();
  v41[2] = objc_opt_class();
  v41[3] = objc_opt_class();
  v41[4] = objc_opt_class();
  v41[5] = objc_opt_class();
  v41[6] = objc_opt_class();
  v41[7] = objc_opt_class();
  v41[8] = objc_opt_class();
  v41[9] = objc_opt_class();
  v41[10] = objc_opt_class();
  id v7 = +[NSArray arrayWithObjects:v41 count:11];
  id v31 = +[NSSet setWithArray:v7];

  id v30 = v5;
  id v8 = [v5 fetch:@"SELECT rowid, file FROM Files"];
  if (![v8 next])
  {
    int v20 = 0;
    id v17 = 0;
    unsigned __int8 v21 = 0;
    unint64_t v10 = 0;
    unint64_t v9 = 0;
    goto LABEL_19;
  }
  id v28 = a3;
  id v29 = v6;
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  id v11 = 0;
  while (1)
  {
    id v13 = [v8 numberAtIndex:0];
    unsigned int v14 = [v8 dataAtIndex:1];
    unint64_t v15 = v14;
    if (!v14) {
      goto LABEL_8;
    }
    v9 += (unint64_t)[v14 length];
    id v32 = v11;
    id v16 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v31 fromData:v15 error:&v32];
    id v17 = v32;

    if (!v16) {
      break;
    }
    long long v18 = [v16 asArchiveData];
    int v19 = v18;
    if (!v18)
    {
      uint64_t v23 = +[MBError errorWithCode:10 format:@"Unable to encode as protobuf"];
LABEL_16:
      unsigned __int8 v21 = (void *)v23;

      goto LABEL_17;
    }
    v10 += (unint64_t)[v18 length];
    if (([v30 execute:@"UPDATE Files SET file = %@ WHERE rowid=%@", v19, v13] & 1) == 0)
    {
      uint64_t v23 = [v30 lastError];
      goto LABEL_16;
    }

    id v11 = v17;
LABEL_8:

    if (([v8 next] & 1) == 0)
    {
      int v20 = 0;
      unsigned __int8 v21 = 0;
      id v17 = v11;
      goto LABEL_18;
    }
  }
  id v22 = MBGetDefaultLog();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    unint64_t v34 = (unint64_t)v17;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Unable to decode blob as NSKeyedArchive: %@", buf, 0xCu);
    _MBLog();
  }

  unsigned __int8 v21 = +[MBError errorWithCode:11 format:@"Unable to decode as NSKeyedArchive"];
LABEL_17:

  int v20 = 1;
LABEL_18:
  a3 = v28;
  id v6 = v29;
LABEL_19:
  id v24 = MBGetDefaultLog();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134218752;
    if (v9 <= v10) {
      unint64_t v25 = v10 - v9;
    }
    else {
      unint64_t v25 = v9 - v10;
    }
    unint64_t v34 = v9;
    __int16 v35 = 2048;
    unint64_t v36 = v10;
    __int16 v37 = 2048;
    unint64_t v38 = v25;
    __int16 v39 = 2048;
    double v40 = (double)v10 / (double)v9;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "Completed file blob migration. bytesIn %{bytes}llu bytesOut %{bytes}llu delta %{bytes}llu perc %{percent}f", buf, 0x2Au);
    _MBLog();
  }

  if (a3) {
    char v26 = v20 ^ 1;
  }
  else {
    char v26 = 1;
  }
  if ((v26 & 1) == 0 && v21) {
    *a3 = v21;
  }

  return v20 ^ 1u;
}

uint64_t sub_1000DD734(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B2C8, a3);
}

uint64_t sub_1000DD740(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B298, a3);
}

uint64_t sub_1000DD74C(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B2E0, a3);
}

uint64_t sub_1000DD758(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B2F8, a3);
}

uint64_t sub_1000DD764(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B238, a3);
}

uint64_t sub_1000DD770(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B310, a3);
}

uint64_t sub_1000DD77C(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B328, a3);
}

uint64_t sub_1000DD788(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B340, a3);
}

uint64_t sub_1000DD794(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B358, a3);
}

uint64_t sub_1000DD7A0(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B370, a3);
}

uint64_t sub_1000DD7AC(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B388, a3);
}

uint64_t sub_1000DD7B8(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"UPDATE FoundEncryptionKeys SET volumeType = %lu;",
  id v5 = 2);
  +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"UPDATE EncryptionKeys SET volumeType = %lu;",
    2,
  id v6 = v5);
  v10[1] = v6;
  id v7 = +[NSArray arrayWithObjects:v10 count:2];

  uint64_t v8 = sub_1000E9070(v4, v7, a3);
  return v8;
}

uint64_t sub_1000DD8B4(void *a1, uint64_t a2, void *a3)
{
  return sub_1000E9070(a1, &off_10043B3A0, a3);
}

id sub_1000DD8C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = (uint64_t (*)(id, uint64_t, id *))*((void *)&unk_100412CC8 + 3 * *(unsigned int *)(a1 + 56) + 1);
  uint64_t v6 = *(void *)(a1 + 32);
  id v15 = 0;
  char v7 = v5(v3, v6, &v15);
  id v8 = v15;
  id v9 = v15;
  if (v7)
  {
    id v10 = [v3 setUserVersion:*(unsigned int *)(a1 + 64)];
  }
  else
  {
    id v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = *(_DWORD *)(a1 + 60);
      int v13 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)buf = 67109634;
      int v17 = v12;
      __int16 v18 = 1024;
      int v19 = v13;
      __int16 v20 = 2114;
      id v21 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Can't migrate from version %d to %d: %{public}@", buf, 0x18u);
      _MBLog();
    }

    [*(id *)(a1 + 40) close:0];
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v8);
    id v10 = 0;
  }

  return v10;
}

void sub_1000DDD14(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DDD2C(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  char v7 = v2;
  if (v2)
  {
    if ([v2 execute:*(void *)(a1 + 40) args:**(void **)(a1 + 56)]) {
      goto LABEL_6;
    }
    uint64_t v3 = [v7 lastError];
  }
  else
  {
    uint64_t v3 = [*(id *)(a1 + 32) _invalidatedError];
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 8);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

LABEL_6:
  return _objc_release_x1();
}

void sub_1000DDF14(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000DDF2C(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  uint64_t v3 = v2;
  if (v2)
  {
    id v4 = [v2 fetch:*(void *)(a1 + 40) args:**(void **)(a1 + 64)];
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    id v22 = v4;
    id v5 = [v4 enumerateObjectsOfClass:objc_opt_class()];
    id v6 = [v5 countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v24;
LABEL_4:
      uint64_t v9 = 0;
      while (1)
      {
        if (*(void *)v24 != v8) {
          objc_enumerationMutation(v5);
        }
        id v10 = *(void **)(*((void *)&v23 + 1) + 8 * v9);
        int v12 = objc_opt_class();
        if ([v12 isSubclassOfClass:objc_opt_class()]) {
          [v10 setCache:*(void *)(a1 + 32)];
        }
        int v13 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
        if (!v13) {
          break;
        }
        if (v7 == (id)++v9)
        {
          id v7 = [v5 countByEnumeratingWithState:&v23 objects:v27 count:16];
          if (v7) {
            goto LABEL_4;
          }
          break;
        }
      }
    }

    unsigned int v14 = *(void **)(a1 + 32);
    id v15 = [v3 lastError];
    uint64_t v16 = [v14 _clientLastError:v15];
    uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
    __int16 v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;
  }
  else
  {
    uint64_t v19 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v20 = *(void *)(*(void *)(a1 + 56) + 8);
    id v21 = *(void **)(v20 + 40);
    *(void *)(v20 + 40) = v19;
  }
}

void sub_1000DE2D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000DE2F4(uint64_t a1)
{
  id v13 = *(id *)(*(void *)(a1 + 32) + 16);
  if (v13)
  {
    id v2 = [v13 fetchObjectOfClass:*(void *)(a1 + 64) sql:*(void *)(a1 + 40) args:**(void **)(a1 + 72)];
    uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
    id v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;

    id v5 = v13;
    if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)) {
      goto LABEL_6;
    }
    id v6 = *(void **)(a1 + 32);
    id v7 = [v13 lastError];
    uint64_t v8 = [v6 _clientLastError:v7];
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    id v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;
  }
  else
  {
    uint64_t v11 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 8);
    id v7 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;
  }

  id v5 = v13;
LABEL_6:
}

void sub_1000DEC70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000DEC94(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT (SELECT COUNT(*) FROM Files LIMIT 1) OR (SELECT COUNT(*) FROM Manifests LIMIT 1) OR (SELECT COUNT(*) FROM Snapshots LIMIT 1);"];
    if ([v3 next]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v3 unsignedIntAtIndex:0] != 0;
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000DEE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000DEEB8(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT (SELECT COUNT(*) from Files where manifestID NOT IN (SELECT manifestID from Manifests)) OR (SELECT COUNT(*) from Files where manifestID IN (SELECT manifestID from Manifests WHERE snapshotID NOT IN (SELECT snapshotID from Snapshots)))"];
    if ([v3 next]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v3 unsignedIntAtIndex:0] != 0;
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000DF798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DF7B0(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v5 = v4;
  if (*(void *)(a1 + 32)
    && ([v4 deviceUUID],
        uint64_t v6 = objc_claimAutoreleasedReturnValue(),
        unsigned int v7 = [v6 isEqualToString:*(void *)(a1 + 32)],
        v6,
        !v7))
  {
    uint64_t v8 = 1;
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    uint64_t v8 = 0;
  }

  return v8;
}

void sub_1000DF980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000DF9A4(uint64_t a1)
{
  id v11 = *(id *)(*(void *)(a1 + 32) + 16);
  if (v11)
  {
    id v2 = [*(id *)(a1 + 40) snapshotID];
    id v3 = [v11 fetch:@"SELECT SUM(size) FROM Files WHERE manifestID IN (SELECT manifestID FROM Manifests WHERE snapshotID = %@)", v2];

    if ([v3 next]) {
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedLongLongAtIndex:0];
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000DFDBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000DFDE0(uint64_t a1)
{
  id v11 = *(id *)(*(void *)(a1 + 32) + 16);
  if (v11)
  {
    id v2 = [*(id *)(a1 + 40) snapshotID];
    id v3 = [v11 fetch:@"SELECT COUNT(*) FROM Manifests WHERE snapshotID = %@", v2];

    if ([v3 next]) {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedIntAtIndex:0];
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E0058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000E007C(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*) FROM ManifestPages WHERE manifestID = %@", *(void *)(a1 + 40)];
    if ([v3 next]) {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedIntAtIndex:0];
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E0740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E0770(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(id *)(a1 + 32);
  objc_sync_enter(v4);
  id v5 = [objc_alloc((Class)NSString) initWithFormat:@"F:%@", v3];
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%@", buf, 0xCu);
      id v8 = v5;
      _MBLog();
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) ^= (unint64_t)+[MBDigest simpleChecksumForString:](MBDigest, "simpleChecksumForString:", v5, v8);

  objc_sync_exit(v4);
  return 1;
}

void sub_1000E08B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000E0BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E0BF0(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v14 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT Files.file FROM Manifests JOIN Files ON Files.manifestID = Manifests.manifestID WHERE Manifests.snapshotID = %@ORDER BY Files.domain", *(void *)(a1 + 40)];
    while ([v3 next])
    {
      id v5 = [v3 objectOfClass:objc_opt_class() atIndex:0];
      char v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();

      if ((v6 & 1) == 0) {
        goto LABEL_8;
      }
    }
    uint64_t v9 = *(void **)(a1 + 32);
    id v10 = [v14 lastError];
    uint64_t v11 = [v9 _clientLastError:v10];
    uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
    id v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;
  }
  else
  {
    uint64_t v7 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
    id v3 = *(id *)(v8 + 40);
    *(void *)(v8 + 40) = v7;
  }
LABEL_8:
}

void sub_1000E1114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000E1138(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT 1 FROM Files WHERE domain = %@ AND relativePath = %@ AND manifestID != %@ LIMIT 1", *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56)];
    if ([v3 next]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = [v3 unsignedIntAtIndex:0] != 0;
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 64) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E13DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000E1400(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*) FROM Files WHERE manifestID = %@", *(void *)(a1 + 40)];
    if ([v3 next])
    {
      do
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedIntAtIndex:0];
      while (([v3 next] & 1) != 0);
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E164C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000E1670(uint64_t a1)
{
  id v11 = *(id *)(*(void *)(a1 + 32) + 16);
  if (v11)
  {
    id v2 = [*(id *)(a1 + 40) manifestID];
    id v3 = [v11 fetch:@"SELECT COUNT(DISTINCT(SUBSTR(fileId, 38, 28))) FROM Files WHERE manifestID = %@", v2];

    if ([v3 next])
    {
      do
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedIntAtIndex:0];
      while (([v3 next] & 1) != 0);
    }
    id v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E199C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1000E19C0(uint64_t a1)
{
  id v12 = *(id *)(*(void *)(a1 + 32) + 16);
  if (v12)
  {
    uint64_t v2 = *(void *)(a1 + 64);
    id v3 = [*(id *)(a1 + 40) base64EncodedStringWithOptions:0];
    id v4 = [v12 fetch:@"SELECT COUNT(*) FROM RestoreFiles WHERE sourceDeviceInode = %llu AND signature = %@ AND volumeType = %lu", v2, v3, *(void *)(a1 + 72)];

    if ([v4 next])
    {
      do
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v4 unsignedIntAtIndex:0];
      while (([v4 next] & 1) != 0);
    }
    id v5 = *(void **)(a1 + 32);
    uint64_t v6 = [v12 lastError];
    uint64_t v7 = [v5 _clientLastError:v6];
    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = v7;
  }
  else
  {
    uint64_t v10 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
    id v4 = *(id *)(v11 + 40);
    *(void *)(v11 + 40) = v10;
  }
}

void sub_1000E1C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000E1C40(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) fileID];
  id v4 = [*(id *)(a1 + 40) manifest];
  id v5 = [v4 manifestID];
  uint64_t v6 = [v2 _executeSQL:@"INSERT OR IGNORE INTO CloudFilesPendingDelete (fileID, manifestID, file) VALUES (%@, %@, %@)", v3, v5, *(void *)(a1 + 40)];
  uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
}

void sub_1000E1E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000E1E50(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) fileID];
  id v4 = [*(id *)(a1 + 40) manifest];
  id v5 = [v4 manifestID];
  uint64_t v6 = [v2 _executeSQL:@"DELETE FROM CloudFilesPendingDelete where fileID=%@ AND manifestID=%@", v3, v5];
  uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)) {
    return 0;
  }
  if (([*(id *)(a1 + 40) deleted] & 1) != 0
    || ([*(id *)(a1 + 40) isDirectory] & 1) != 0
    || (id v10 = [*(id *)(a1 + 40) protectionClass],
        +[MBProtectionClassUtils canOpenWhenLocked:v10]))
  {
    long long v26 = *(void **)(a1 + 32);
    uint64_t v11 = [*(id *)(a1 + 40) fileID];
    id v12 = [*(id *)(a1 + 40) manifest];
    id v13 = [v12 manifestID];
    uint64_t v14 = [*(id *)(a1 + 40) domainName];
    uint64_t v15 = [*(id *)(a1 + 40) relativePath];
    uint64_t v16 = [*(id *)(a1 + 40) modified];
    uint64_t v17 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [*(id *)(a1 + 40) deleted]);
    __int16 v18 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 40) fileType]);
    uint64_t v19 = (void *)v15;
    [v26 _executeSQL:@"INSERT OR REPLACE INTO Files (fileID, manifestID, domain, relativePath, modified, deleted, fileType, file, size) VALUES (%@, %@, %@, %@, %@, %@, %@, %@, %llu)", v11, v13, v14, v15, v16, v17, v18, *(void *)(a1 + 40), objc_msgSend(*(id *)(a1 + 40), "size"), v24];
  }
  else
  {
    __int16 v27 = *(void **)(a1 + 32);
    uint64_t v11 = [*(id *)(a1 + 40) fileID];
    id v12 = [*(id *)(a1 + 40) manifest];
    id v13 = [v12 manifestID];
    uint64_t v14 = [*(id *)(a1 + 40) domainName];
    uint64_t v23 = [*(id *)(a1 + 40) relativePath];
    uint64_t v16 = [*(id *)(a1 + 40) modified];
    unsigned int v25 = v10;
    uint64_t v17 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [*(id *)(a1 + 40) deleted]);
    uint64_t v19 = (void *)v23;
    __int16 v18 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 40) fileType]);
    [v27 _executeSQL:@"INSERT OR REPLACE INTO Files (fileID, manifestID, domain, relativePath, modified, deleted, fileType, file, size, protectionClass) VALUES (%@, %@, %@, %@, %@, %@, %@, %@, %llu, %d)", v11, v13, v14, v23, v16, v17, v18, *(void *)(a1 + 40), objc_msgSend(*(id *)(a1 + 40), "size"), v25];
  uint64_t v20 = };
  uint64_t v21 = *(void *)(*(void *)(a1 + 48) + 8);
  id v22 = *(void **)(v21 + 40);
  *(void *)(v21 + 40) = v20;

  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
}

void sub_1000E228C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E22A4(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    id v4 = v2;
    id v12 = [v4 fetch:@"SELECT COUNT(*), SUM(Files.size) FROM CloudFilesPendingDelete JOIN Files ON Files.fileID = CloudFilesPendingDelete.fileID WHERE CloudFilesPendingDelete.manifestID = %@", v3];
    if ([v12 next])
    {
      [v12 unsignedIntAtIndex:0];
      [v12 unsignedLongLongAtIndex:1];
    }
    uint64_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = [v4 lastError];
    uint64_t v9 = [v7 _clientLastError:v8];
    uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 32) _invalidatedError];
    id v12 = 0;
    uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8);
    id v4 = *(id *)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
}

void sub_1000E26B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E26E0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 keybagUUIDString];

  if (v4)
  {
    uint64_t v5 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    uint64_t v6 = [v3 keybagUUIDString];
    [v5 addObject:v6];
  }
  return 1;
}

void sub_1000E2E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E2E20(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v19 = v2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 64)) {
      id v3 = [v2 fetch:@"SELECT relativePath, size, changeType, shouldCopy FROM FileChanges WHERE domain = %@ AND (changeType = %lu OR changeType = %lu OR (changeType = %lu AND NOT EXISTS (SELECT 1 FROM Files WHERE SUBSTR(manifestID, 0, 36) == (SELECT SUBSTR(value, 3, 36) FROM Properties WHERE key == %@) AND Files.domain = FileChanges.domain AND Files.relativePath = FileChanges.relativePath AND Files.deleted = 1)))", *(void *)(a1 + 40), 1, 2, 3, @"PendingSnapshotID"];
    }
    else {
      id v3 = [v2 fetch:@"SELECT relativePath, size, changeType, shouldCopy FROM FileChanges WHERE domain = %@", *(void *)(a1 + 40), v15, v16, v17, v18];
    }
    uint64_t v6 = v3;
    do
    {
      if (![v6 next]) {
        break;
      }
      uint64_t v8 = [v6 stringAtIndex:0];
      [v6 unsignedLongLongAtIndex:1];
      [v6 unsignedIntegerAtIndex:2];
      [v6 BOOLAtIndex:3];
      char v9 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    while ((v9 & 1) != 0);
    uint64_t v10 = *(void **)(a1 + 32);
    uint64_t v11 = [v19 lastError];
    uint64_t v12 = [v10 _clientLastError:v11];
    uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = v12;
  }
  else
  {
    uint64_t v4 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
}

void sub_1000E30F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E310C(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    id v4 = v2;
    id v12 = [v4 fetch:@"SELECT COUNT(*), SUM(size) FROM FileChanges WHERE domain = %@", v3];
    if ([v12 next])
    {
      [v12 unsignedIntAtIndex:0];
      [v12 unsignedLongLongAtIndex:1];
    }
    uint64_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = [v4 lastError];
    uint64_t v9 = [v7 _clientLastError:v8];
    uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 32) _invalidatedError];
    id v12 = 0;
    uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8);
    id v4 = *(id *)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
}

void sub_1000E3344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E335C(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 16);
  if (v2)
  {
    id v3 = v2;
    id v11 = [v3 fetch:@"SELECT COUNT(*), SUM(size) FROM FileChanges"];
    if ([v11 next])
    {
      [v11 unsignedIntAtIndex:0];
      [v11 unsignedLongLongAtIndex:1];
    }
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v7 = [v3 lastError];
    uint64_t v8 = [v6 _clientLastError:v7];
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v4 = [*(id *)(a1 + 32) _invalidatedError];
    id v11 = 0;
    uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
}

void sub_1000E358C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E35A4(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v12 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*), SUM(size) FROM FileChanges WHERE changeType != %lu AND changeType != %lu", 0, 3];
    if ([v3 next])
    {
      [v3 unsignedIntAtIndex:0];
      [v3 unsignedLongLongAtIndex:1];
    }
    id v6 = objc_msgSend(v12, "fetch:", @"SELECT COUNT(*) FROM FileChanges WHERE changeType = %lu", 3);

    if ([v6 next]) {
      [v6 unsignedIntAtIndex:0];
    }
    uint64_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = [v12 lastError];
    uint64_t v9 = [v7 _clientLastError:v8];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v4 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
    id v6 = *(id *)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
}

void sub_1000E38D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E38E8(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v12 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT domain, COUNT(*), SUM(size) FROM FileChanges WHERE changeType != %lu AND changeType != %lu GROUP BY domain", 0, 3];
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v12 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;

    if ([v3 next])
    {
      do
      {
        uint64_t v9 = [v3 stringAtIndex:0];
        [v3 unsignedIntAtIndex:1];
        [v3 unsignedLongLongAtIndex:2];
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
      while (([v3 next] & 1) != 0);
    }
  }
  else
  {
    uint64_t v10 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v11 + 40);
    *(void *)(v11 + 40) = v10;
  }
}

void sub_1000E3B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000E3BC0(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*) FROM FileChanges WHERE domain = %@ LIMIT 1", @"SkippedFilesDomain"];
    if ([v3 next]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v3 unsignedIntAtIndex:0] != 0;
    }
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E4268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1000E428C(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT count(*) from FoundEncryptionKeys WHERE key IS NULL AND inode = 0 AND volumeType = 0"];
    if ([v3 next]) {
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v3 unsignedLongLongAtIndex:0];
    }
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E47B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E47F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 encryptionKey];
  id v5 = [v3 inode];
  uint64_t v6 = (uint64_t)[v3 volumeType];
  id v7 = [v4 length];
  if (!v5)
  {
    uint64_t v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      id v18 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Found invalid inode for %@", buf, 0xCu);
      goto LABEL_9;
    }
LABEL_10:
    uint64_t v10 = 1;
    goto LABEL_18;
  }
  id v8 = v7;
  if (v6)
  {
    if (!v4 || !v7)
    {
      uint64_t v9 = MBGetDefaultLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218242;
        id v18 = v8;
        __int16 v19 = 2112;
        uint64_t v20 = (uint64_t)v3;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Missing or invalid encryption key(%ld) for %@", buf, 0x16u);
LABEL_9:
        _MBLog();
        goto LABEL_10;
      }
      goto LABEL_10;
    }
  }
  else
  {
    id v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412546;
      id v18 = v3;
      __int16 v19 = 2048;
      uint64_t v20 = 2;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Correcting invalid volumeType for %@ to %lu", buf, 0x16u);
      _MBLog();
    }

    uint64_t v6 = 2;
  }
  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) += v8;
  uint64_t v12 = [*(id *)(a1 + 32) _executeSQL:@"INSERT OR REPLACE INTO EncryptionKeys (inode, volumeType, key) VALUES (%llu, %lu, %@)", v5, v6, v4];
  uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v14 = *(void **)(v13 + 40);
  *(void *)(v13 + 40) = v12;

  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
  {
    uint64_t v10 = 1;
    goto LABEL_19;
  }
  uint64_t v9 = MBGetDefaultLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    *(_DWORD *)buf = 138412546;
    id v18 = v3;
    __int16 v19 = 2112;
    uint64_t v20 = v15;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to add %@ to the cached encryption keys table: %@", buf, 0x16u);
    _MBLog();
  }
  uint64_t v10 = 0;
LABEL_18:

LABEL_19:
  return v10;
}

BOOL sub_1000E4B10(uint64_t a1)
{
  uint64_t v1 = objc_msgSend(*(id *)(a1 + 32), "_enumerateObjectsOfClass:callback:format:", objc_opt_class(), *(void *)(a1 + 40), @"SELECT file FROM Files WHERE protectionClass = %d OR protectionClass = %d", 1, 2);
  BOOL v2 = v1 == 0;

  return v2;
}

void sub_1000E4CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000E4CE4(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT SUM(size) FROM Files WHERE domain = %@ AND manifestID IN (SELECT manifestID FROM Manifests WHERE snapshotID IN (SELECT snapshotID FROM Snapshots))", *(void *)(a1 + 40)];
    if ([v3 next]) {
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedLongLongAtIndex:0];
    }
    uint64_t v4 = *(void **)(a1 + 32);
    id v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    id v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E50B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000E50CC(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v3 = v2;
  if (v2)
  {
    id v4 = [v2 fetch:@"SELECT signature, COUNT(*), volumeType FROM RestoreFiles GROUP BY signature, volumeType"];
    if ([v4 next])
    {
      do
      {
        uint64_t v6 = [v4 stringAtIndex:0];
        uint64_t v7 = [*(id *)(a1 + 32) _executeSQL:@"INSERT OR REPLACE INTO HardlinkCloneFiles (signature, retainCount, volumeType) VALUES (%@, %llu, %lu)", v6, objc_msgSend(v4, "unsignedLongLongAtIndex:", 1), objc_msgSend(v4, "unsignedLongLongAtIndex:", 2)];
        uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
        uint64_t v9 = *(void **)(v8 + 40);
        *(void *)(v8 + 40) = v7;
      }
      while (([v4 next] & 1) != 0);
    }
  }
  else
  {
    uint64_t v10 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    id v4 = *(id *)(v11 + 40);
    *(void *)(v11 + 40) = v10;
  }

  return v3 != 0;
}

void sub_1000E53D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000E53F4(void *a1)
{
  id v2 = (void *)a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[8];
  uint64_t v5 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v5 + 40);
  uint64_t v6 = [v2 retainCountForSignature:v3 volumeType:v4 error:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  if (*(void *)(*(void *)(a1[6] + 8) + 40))
  {
    uint64_t v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = [(id)a1[5] base64EncodedStringWithOptions:0];
      uint64_t v9 = a1[8];
      *(_DWORD *)buf = 138412546;
      id v32 = v8;
      __int16 v33 = 2048;
      uint64_t v34 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch retain count for signature: %@(%lu)", buf, 0x16u);

      id v28 = [(id)a1[5] base64EncodedStringWithOptions:0];
      _MBLog();
    }
  }
  else
  {
    uint64_t v11 = (char *)[v6 unsignedLongLongValue];
    if (v11)
    {
      uint64_t v12 = +[NSNumber numberWithUnsignedLongLong:v11 - 1];
      uint64_t v13 = *(void *)(a1[7] + 8);
      uint64_t v14 = *(void **)(v13 + 40);
      *(void *)(v13 + 40) = v12;

      uint64_t v15 = *(void *)(*(void *)(a1[7] + 8) + 40);
      uint64_t v16 = (void *)a1[4];
      uint64_t v17 = [(id)a1[5] base64EncodedStringWithOptions:0];
      uint64_t v18 = [v16 _executeSQL:@"UPDATE HardlinkCloneFiles SET retainCount = %@ WHERE signature = %@ AND volumeType = %lu", v15, v17, a1[8]];
      uint64_t v19 = *(void *)(a1[6] + 8);
      uint64_t v20 = *(void **)(v19 + 40);
      *(void *)(v19 + 40) = v18;

      BOOL v10 = *(void *)(*(void *)(a1[6] + 8) + 40) == 0;
      goto LABEL_8;
    }
    id v22 = MBGetDefaultLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = [(id)a1[5] base64EncodedStringWithOptions:0];
      uint64_t v24 = a1[8];
      *(_DWORD *)buf = 138412546;
      id v32 = v23;
      __int16 v33 = 2048;
      uint64_t v34 = v24;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Not decrementing retain count for signature: %@(%lu)", buf, 0x16u);

      id v29 = [(id)a1[5] base64EncodedStringWithOptions:0];
      _MBLog();
    }
    uint64_t v25 = +[MBError errorWithErrno:22 format:@"Decrementing zero retain count."];
    uint64_t v26 = *(void *)(a1[6] + 8);
    __int16 v27 = *(void **)(v26 + 40);
    *(void *)(v26 + 40) = v25;
  }
  BOOL v10 = 0;
LABEL_8:

  return v10;
}

void sub_1000E5C48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 192), 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1000E5CA8(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v17 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT stashPath, stashedAssetIsDecrypted, decodedAssetPath FROM HardlinkCloneFiles WHERE signature = %@ AND volumeType = %lu", *(void *)(a1 + 40), *(void *)(a1 + 80)];
    if ([v3 next])
    {
      uint64_t v4 = [v3 stringAtIndex:0];
      uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8);
      uint64_t v6 = *(void **)(v5 + 40);
      *(void *)(v5 + 40) = v4;

      *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = [v3 BOOLAtIndex:1];
      uint64_t v7 = [v3 stringAtIndex:2];
      uint64_t v8 = *(void *)(*(void *)(a1 + 72) + 8);
      uint64_t v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;
    }
    BOOL v10 = *(void **)(a1 + 32);
    uint64_t v11 = [v17 lastError];
    uint64_t v12 = [v10 _clientLastError:v11];
    uint64_t v13 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = v12;
  }
  else
  {
    uint64_t v15 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v16 + 40);
    *(void *)(v16 + 40) = v15;
  }
}

void sub_1000E605C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000E6074(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) domainName];
  uint64_t v4 = [*(id *)(a1 + 40) relativePath];
  unsigned int v5 = [*(id *)(a1 + 40) hasAbsolutePath];
  if (v5)
  {
    uint64_t v6 = [*(id *)(a1 + 40) absolutePath];
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v7 = [*(id *)(a1 + 40) fileID];
  uint64_t v8 = [*(id *)(a1 + 40) signature];
  uint64_t v9 = [v8 base64EncodedStringWithOptions:0];
  uint64_t v10 = [v2 _executeSQL:@"INSERT OR REPLACE INTO RestoreFiles (domain, relativePath, absolutePath, fileID, restoreState, signature, sourceDeviceInode, volumeType) VALUES (%@, %@, %@, %@, %lu, %@, %llu, %lu)", v3, v4, v6, v7, 1, v9, objc_msgSend(*(id *)(a1 + 40), "sourceDeviceInode"), objc_msgSend(*(id *)(a1 + 40), "volumeType")];
  uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  if (v5) {
  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
  }
}

void sub_1000E6450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E6468(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v12 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT count(*) FROM RestoreFiles LIMIT 1"];
    if ([v3 next]) {
      id v4 = [v3 unsignedLongLongAtIndex:0];
    }
    else {
      id v4 = 0;
    }
    uint64_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = [v12 lastError];
    uint64_t v9 = [v7 _clientLastError:v8];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)) {
      (*(void (**)(void, BOOL))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v4 != 0);
    }
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
}

void sub_1000E6710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E6728(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v19 = v2;
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 72);
    uint64_t v5 = *(void *)(a1 + 64);
    if (*(unsigned char *)(a1 + 88)) {
      id v6 = [v2 fetch:@"SELECT file, RestoreFiles.priority, RestoreFiles.absolutePath FROM RestoreFiles JOIN Files on Files.fileID = RestoreFiles.fileID WHERE RestoreFiles.restoreState != %lu AND RestoreFiles.restoreState < %lu AND RestoreFiles.domain = %@ ORDER BY RestoreFiles.priority DESC, Files.relativePath ASC LIMIT %lu OFFSET %lu", v5, 12, v3, *(void *)(a1 + 80), v4];
    }
    else {
      id v6 = [v2 fetch:@"SELECT file, RestoreFiles.priority, RestoreFiles.absolutePath FROM RestoreFiles JOIN Files on Files.fileID = RestoreFiles.fileID WHERE RestoreFiles.restoreState = %lu AND RestoreFiles.domain = %@ ORDER BY RestoreFiles.priority DESC, Files.relativePath ASC LIMIT %lu OFFSET %lu", v5, v3, *(void *)(a1 + 80), v4, v18];
    }
    uint64_t v9 = v6;
    do
    {
      if (![v9 next]) {
        break;
      }
      uint64_t v10 = [v9 objectOfClass:objc_opt_class() atIndex:0];
      [v10 setCache:*(void *)(a1 + 32)];
      objc_msgSend(v10, "setPriority:", objc_msgSend(v9, "unsignedLongLongAtIndex:", 1));
      uint64_t v11 = [v9 stringAtIndex:2];
      if (v11) {
        [v10 setAbsolutePath:v11];
      }
      char v12 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    while ((v12 & 1) != 0);
    uint64_t v13 = *(void **)(a1 + 32);
    uint64_t v14 = [v19 lastError];
    uint64_t v15 = [v13 _clientLastError:v14];
    uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8);
    id v17 = *(void **)(v16 + 40);
    *(void *)(v16 + 40) = v15;
  }
  else
  {
    uint64_t v7 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = v7;
  }
}

void sub_1000E6D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E6D7C(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setAbsolutePath:*(void *)(a1 + 32)];

  return 1;
}

void sub_1000E6F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000E6F38(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT restoreState FROM RestoreFiles WHERE fileID = %@ LIMIT 1", *(void *)(a1 + 40)];
    if ([v3 next]) {
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = (int)[v3 intAtIndex:0];
    }
    id v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E7418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000E743C(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT safeHarbor FROM RestoreDomains WHERE domain = %@", *(void *)(a1 + 40)];
    if ([v3 next]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 BOOLAtIndex:0];
    }
    id v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E766C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E7684(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v12 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT state, agent FROM RestoreDomains WHERE domain = %@", *(void *)(a1 + 40)];
    if ([v3 next])
    {
      [v3 intAtIndex:0];
      id v4 = [v3 stringAtIndex:1];
    }
    else
    {
      id v4 = 0;
    }
    uint64_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = [v12 lastError];
    uint64_t v9 = [v7 _clientLastError:v8];
    uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
    id v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)) {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8);
    id v3 = *(id *)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
}

void sub_1000E790C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E7924(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*), SUM(F.size) FROM Files AS F, RestoreFiles AS RF WHERE F.fileID = RF.fileID AND RF.domain = %@ AND RF.restoreState < %lu", *(void *)(a1 + 40), 11];
    if ([v3 next])
    {
      [v3 unsignedLongLongAtIndex:0];
      [v3 unsignedLongLongAtIndex:1];
    }
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v7 = [v11 lastError];
    uint64_t v8 = [v6 _clientLastError:v7];
    uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)) {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
  }
  else
  {
    uint64_t v4 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8);
    id v3 = *(id *)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
}

void sub_1000E7B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E7BB4(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*), SUM(size) FROM Files WHERE fileID IN (SELECT fileID FROM RestoreFiles WHERE domain = %@)", *(void *)(a1 + 40)];
    if ([v3 next])
    {
      [v3 unsignedLongLongAtIndex:0];
      [v3 unsignedLongLongAtIndex:1];
    }
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v7 = [v11 lastError];
    uint64_t v8 = [v6 _clientLastError:v7];
    uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)) {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
  }
  else
  {
    uint64_t v4 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8);
    id v3 = *(id *)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
}

void sub_1000E7E5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000E7E80(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT state FROM Restores WHERE deviceUUID = %@ AND snapshotUUID = %@", *(void *)(a1 + 40), *(void *)(a1 + 48)];
    if ([v3 next]) {
      *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = (int)[v3 intAtIndex:0];
    }
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E81D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000E81FC(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT size FROM ScannedDomains WHERE domain = %@", *(void *)(a1 + 40)];
    if ([v3 next]) {
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedLongLongAtIndex:0];
    }
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E8438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E8450(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v12 = v2;
  if (v2)
  {
    id v3 = objc_msgSend(v2, "fetch:", @"SELECT DISTINCT(domain) FROM RestoreFiles WHERE restoreState == %lu", 12);
    if ([v3 next])
    {
      do
      {
        uint64_t v4 = [v3 stringAtIndex:0];
        if (v4) {
          [*(id *)(a1 + 40) addObject:v4];
        }
      }
      while (([v3 next] & 1) != 0);
    }
    uint64_t v5 = *(void **)(a1 + 32);
    uint64_t v6 = [v12 lastError];
    uint64_t v7 = [v5 _clientLastError:v6];
    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = v7;
  }
  else
  {
    uint64_t v10 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v11 + 40);
    *(void *)(v11 + 40) = v10;
  }
}

void sub_1000E868C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000E86BC(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v11 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*), SUM(F.size) FROM Files AS F, RestoreFiles AS RF WHERE F.fileID = RF.fileID AND RF.restoreState < %lu", 11];
    if ([v3 next])
    {
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v3 unsignedLongLongAtIndex:0];
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v3 unsignedLongLongAtIndex:1];
    }
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = [v11 lastError];
    uint64_t v6 = [v4 _clientLastError:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
    id v3 = *(id *)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
}

void sub_1000E8A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E8A94(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v15 = v2;
  if (v2)
  {
    id v3 = [v2 fetch:@"SELECT COUNT(*) as cnt, domain FROM RestoreFiles GROUP BY domain ORDER BY cnt DESC LIMIT %lu", *(void *)(a1 + 56)];
    if ([v3 next])
    {
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = [v3 stringAtIndex:1];

        id v6 = [v3 unsignedLongLongAtIndex:0];
        if (v4)
        {
          uint64_t v7 = +[NSNumber numberWithUnsignedLongLong:v6];
          [*(id *)(a1 + 40) setObject:v7 forKeyedSubscript:v4];
        }
      }
      while (([v3 next] & 1) != 0);
    }
    uint64_t v8 = *(void **)(a1 + 32);
    uint64_t v9 = [v15 lastError];
    uint64_t v10 = [v8 _clientLastError:v9];
    uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
    id v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;
  }
  else
  {
    uint64_t v13 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v14 + 40);
    *(void *)(v14 + 40) = v13;
  }
}

void sub_1000E8D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E8D40(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 16);
  id v15 = v2;
  if (v2)
  {
    id v3 = objc_msgSend(v2, "fetch:", @"SELECT SUM(size) as sum, RestoreFiles.domain FROM Files JOIN RestoreFiles ON Files.fileID = RestoreFiles.fileID GROUP BY RestoreFiles.domain ORDER BY sum DESC LIMIT %lu;",
           *(void *)(a1 + 56));
    if ([v3 next])
    {
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = [v3 stringAtIndex:1];

        id v6 = [v3 unsignedLongLongAtIndex:0];
        if (v4)
        {
          uint64_t v7 = +[NSNumber numberWithUnsignedLongLong:v6];
          [*(id *)(a1 + 40) setObject:v7 forKeyedSubscript:v4];
        }
      }
      while (([v3 next] & 1) != 0);
    }
    uint64_t v8 = *(void **)(a1 + 32);
    uint64_t v9 = [v15 lastError];
    uint64_t v10 = [v8 _clientLastError:v9];
    uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
    id v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;
  }
  else
  {
    uint64_t v13 = [*(id *)(a1 + 32) _invalidatedError];
    uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 8);
    id v3 = *(id *)(v14 + 40);
    *(void *)(v14 + 40) = v13;
  }
}

uint64_t sub_1000E9070(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (!a3) {
    __assert_rtn("_executeStatements", "MBCKCache.m", 789, "error");
  }
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v7 = v6;
  id v8 = [v7 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v20;
    while (2)
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v20 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void *)(*((void *)&v19 + 1) + 8 * i);
        if ((objc_msgSend(v5, "executeRaw:", v12, (void)v19) & 1) == 0)
        {
          uint64_t v16 = [v5 lastError];
          if (!v16) {
            __assert_rtn("_executeStatements", "MBCKCache.m", 796, "localError");
          }
          id v17 = (void *)v16;

          id v15 = v17;
          uint64_t v14 = 0;
          *a3 = v15;
          goto LABEL_13;
        }
      }
      id v9 = [v7 countByEnumeratingWithState:&v19 objects:v23 count:16];
      if (v9) {
        continue;
      }
      break;
    }
  }
  uint64_t v14 = 1;
  id v15 = v7;
LABEL_13:

  return v14;
}

void sub_1000EB2B4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000ED978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1000ED264);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000EE4B0(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    id v2 = MBGetDefaultLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      id v11 = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Removing the file at %@", buf, 0xCu);
      _MBLog();
    }

    id v3 = +[NSFileManager defaultManager];
    id v9 = 0;
    unsigned __int8 v4 = [v3 removeItemAtPath:v1 error:&v9];
    id v5 = v9;
    id v6 = v5;
    if ((v4 & 1) == 0)
    {
      id v7 = [v5 domain];
      if ([v7 isEqualToString:NSCocoaErrorDomain])
      {
        id v8 = [v6 code];

        if (v8 == (id)4) {
          goto LABEL_12;
        }
      }
      else
      {
      }
      id v3 = MBGetDefaultLog();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        id v11 = v1;
        __int16 v12 = 2112;
        uint64_t v13 = v6;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to remove the file at %@: %@", buf, 0x16u);
        _MBLog();
      }
    }

LABEL_12:
  }
}

void sub_1000EE684(id a1)
{
  qword_100482428 = +[NSSet setWithArray:&off_10043B3E8];
  _objc_release_x1();
}

void sub_1000EE818(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000EE9D4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000EEB10(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000EEFB8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id *sub_1000F04A0(id *result, uint64_t a2)
{
  if (a2) {
    return (id *)[result[4] refreshWithRecord:a2];
  }
  return result;
}

uint64_t sub_1000F04B4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F4308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

uint64_t sub_1000F4350(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000F4360(uint64_t a1)
{
}

void sub_1000F4368(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned __int8 v4 = *(void **)(a1 + 40);
  id v5 = a2;
  id v6 = [v4 encryptionKey];
  id v7 = [*(id *)(a1 + 40) size];
  id v8 = [*(id *)(a1 + 48) hardwareModel];
  uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v9 + 40);
  LOBYTE(v3) = [v5 decryptFileWithPath:v3 encryptionKey:v6 size:v7 hardwareModel:v8 error:&obj];

  objc_storeStrong((id *)(v9 + 40), obj);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v3;
}

void sub_1000F479C(id a1)
{
  id v1 = +[MBBehaviorOptions sharedOptions];
  byte_100482420 = [v1 validateSignatureOnRestoreWithDefaultValue:1];

  if (!byte_100482420)
  {
    id v2 = MBGetDefaultLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      if (byte_100482420) {
        uint64_t v3 = "YES";
      }
      else {
        uint64_t v3 = "NO";
      }
      *(_DWORD *)buf = 136315138;
      id v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ValidateSignatureOnRestore=%s", buf, 0xCu);
      _MBLog();
    }
  }
}

int64_t sub_1000F680C(id a1, id a2, id a3)
{
  return (int64_t)[a2 compare:a3 options:512];
}

void sub_1000F7F64(id a1)
{
  uint64_t v1 = objc_opt_new();
  id v2 = (void *)qword_100482440;
  qword_100482440 = v1;

  uint64_t v3 = (void *)qword_100482440;
  [v3 setUseMMCSEncryptionV2:&__kCFBooleanTrue];
}

void sub_1000F9C54(id a1)
{
  if (MBIsInternalInstall())
  {
    uint64_t v1 = +[MBBehaviorOptions sharedOptions];
    unsigned int v2 = [v1 validateFileEncodingWithDefaultValue:0xFFFFFFFFLL];

    if (v2 == -1) {
      BOOL v3 = arc4random_uniform(2u) == 0;
    }
    else {
      BOOL v3 = v2 != 0;
    }
    byte_100482421 = v3;
    unsigned __int8 v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (byte_100482421) {
        id v5 = "YES";
      }
      else {
        id v5 = "NO";
      }
      *(_DWORD *)buf = 136315138;
      id v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "ValidateFileEncoding=%s", buf, 0xCu);
      _MBLog();
    }
  }
}

void sub_1000F9DD8(id a1)
{
  uint64_t v1 = +[MBBehaviorOptions sharedOptions];
  [v1 SQLiteSpaceSavingsThresholdWithDefaultValue:0.5];
  double v3 = v2;

  BOOL v4 = v3 > 1.0 || v3 <= 0.0;
  double v5 = -1.0;
  if (!v4) {
    double v5 = v3;
  }
  qword_100482458 = *(void *)&v5;
  id v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v8 = qword_100482458;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "SQLiteSpaceSavingsThreshold=%.3f", buf, 0xCu);
    _MBLog();
  }
}

void sub_1000FB884(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1000FB8D4(uint64_t a1)
{
  if ([*(id *)(a1 + 32) _configureAppPlaceholderAtPath:*(void *)(a1 + 40) installType:*(void *)(a1 + 80) isDataSeparated:*(unsigned __int8 *)(a1 + 88) migratorCache:*(void *)(a1 + 48)])atomic_fetch_add((atomic_uint *volatile)(*(void *)(*(void *)(a1 + 72) + 8) + 24), 1u); {
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 64));
}

void sub_1000FE854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FE8B0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000FE8C0(uint64_t a1)
{
}

void sub_1000FE8C8(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000FF7A0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000FFA98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1000FFAB0(uint64_t a1, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1000FFD54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1000FFD84(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) containsObject:v3];
  if (v4)
  {
    [*(id *)(a1 + 32) removeObject:v3];
  }
  else
  {
    double v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Cache is out of date (missing %@)", buf, 0xCu);
      _MBLog();
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }

  return v4;
}

uint64_t sub_10010033C(uint64_t a1)
{
  double v2 = +[NSDate date];
  [v2 timeIntervalSinceReferenceDate];
  double v4 = v3;

  double v5 = [*(id *)(a1 + 32) cache];
  id v6 = [v5 removeAllFileChanges];

  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  id v7 = [*(id *)(a1 + 32) snapshots];
  id v8 = [v7 countByEnumeratingWithState:&v28 objects:v34 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v29;
    do
    {
      id v11 = 0;
      do
      {
        if (*(void *)v29 != v10) {
          objc_enumerationMutation(v7);
        }
        __int16 v12 = *(void **)(*((void *)&v28 + 1) + 8 * (void)v11);
        uint64_t v13 = [*(id *)(a1 + 32) cache];
        id v14 = [v13 addPendingSnapshot:v12];

        id v15 = [*(id *)(a1 + 32) cache];
        id v16 = [v15 commitSnapshot:v12];

        id v17 = [*(id *)(a1 + 32) cache];
        uint64_t v18 = [v12 snapshotID];
        id v19 = [v17 addSnapshotIntoFileChanges:v18];

        id v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v7 countByEnumeratingWithState:&v28 objects:v34 count:16];
    }
    while (v9);
  }

  long long v20 = [*(id *)(a1 + 32) cache];
  id v21 = [v20 removeDeletedFileChanges];

  long long v22 = [*(id *)(a1 + 32) cache];
  id v23 = [v22 removeAllOrphanedItems];

  +[NSDate timeIntervalSinceReferenceDate];
  double v25 = v24;
  uint64_t v26 = MBGetDefaultLog();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    double v33 = v25 - v4;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "FileChanges recreated in %0.3fs", buf, 0xCu);
    _MBLog();
  }

  return 1;
}

void sub_100100C98(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (*(unsigned char *)(a1 + 56) && [v8 count])
  {
    uint64_t v10 = MBGetDefaultLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Snapshot references appear out of date, refreshing device record and trying again", buf, 2u);
      _MBLog();
    }

    id v11 = *(void **)(a1 + 32);
    __int16 v12 = [*(id *)(a1 + 40) recordID];
    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472;
    v45[2] = sub_100101080;
    v45[3] = &unk_100413468;
    id v47 = *(id *)(a1 + 48);
    *(_OWORD *)id obja = *(_OWORD *)(a1 + 32);
    id v13 = obja[0];
    int8x16_t v46 = vextq_s8(*(int8x16_t *)obja, *(int8x16_t *)obja, 8uLL);
    [v11 fetchRecordWithID:v12 completion:v45];
  }
  else
  {
    id v36 = v9;
    id v37 = v8;
    if (!v9) {
      *(unsigned char *)(*(void *)(a1 + 40) + 90) = 1;
    }
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    id v38 = v7;
    id obj = v7;
    id v14 = [obj countByEnumeratingWithState:&v41 objects:v50 count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v42;
      id v17 = ATClientController_ptr;
      do
      {
        for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v42 != v16) {
            objc_enumerationMutation(obj);
          }
          id v19 = *(void **)(*((void *)&v41 + 1) + 8 * i);
          objc_msgSend(v19, "setDevice:", *(void *)(a1 + 40), v35);
          id v20 = objc_alloc((Class)v17[28]);
          id v21 = [v19 recordID];
          id v22 = [v20 initWithRecordID:v21 action:0];

          id v23 = [*(id *)(a1 + 40) snapshotRefs];
          id v24 = [v23 indexOfObject:v22];

          if (v24 != (id)0x7FFFFFFFFFFFFFFFLL)
          {
            double v25 = [*(id *)(a1 + 40) snapshotCommitDates];
            uint64_t v26 = v17;
            id v27 = [v25 count];

            BOOL v28 = v27 > v24;
            id v17 = v26;
            if (v28)
            {
              long long v29 = [*(id *)(a1 + 40) snapshotCommitDates];
              long long v30 = [v29 objectAtIndexedSubscript:v24];
              [v19 setCreated:v30];
            }
          }
          long long v31 = MBGetDefaultLog();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138412290;
            uint64_t v49 = v19;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "Fetched snapshot: %@", buf, 0xCu);
            __int16 v35 = v19;
            _MBLog();
          }
        }
        id v15 = [obj countByEnumeratingWithState:&v41 objects:v50 count:16];
      }
      while (v15);
    }

    uint64_t v32 = +[MBCKSnapshot sortedSnapshots:obj];
    uint64_t v33 = *(void *)(a1 + 40);
    uint64_t v34 = *(void **)(v33 + 112);
    *(void *)(v33 + 112) = v32;

    id v9 = v36;
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    id v8 = v37;
    id v7 = v38;
  }
}

id sub_100101080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    double v5 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
    return (id)v5();
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "refreshWithRecord:");
    id v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    return [v7 _fetchSnapshotsWithOperationTracker:v8 retry:0 completion:v9];
  }
}

void sub_1001011F8(id a1)
{
  double v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.backupd.fetchSnapshots", v3);
  double v2 = (void *)qword_100482468;
  qword_100482468 = (uint64_t)v1;
}

void sub_10010125C(uint64_t a1)
{
  if (![*(id *)(a1 + 32) hasFetchedSnapshots])
  {
    double v2 = [*(id *)(a1 + 32) snapshotRefs];
    id v3 = [v2 count];

    if (v3)
    {
      dispatch_suspend((dispatch_object_t)qword_100482468);
      double v4 = *(void **)(a1 + 32);
      uint64_t v5 = *(void *)(a1 + 40);
      uint64_t v6 = *(unsigned __int8 *)(a1 + 56);
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      void v8[2] = sub_100101380;
      v8[3] = &unk_1004134D8;
      id v9 = *(id *)(a1 + 48);
      [v4 _fetchSnapshotsWithOperationTracker:v5 retry:v6 completion:v8];

      return;
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 90) = 1;
  }
  id v7 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  v7();
}

void sub_100101380(uint64_t a1, void *a2)
{
  id v3 = qword_100482468;
  id v4 = a2;
  dispatch_resume(v3);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10010153C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100101554(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100101564(uint64_t a1)
{
}

void sub_10010156C(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100101BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

uint64_t sub_100101C54(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) keybagManager];
    unsigned __int8 v5 = [v4 hasKeybagWithUUID:v3];

    if ((v5 & 1) == 0) {
      [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObject:v3];
    }
  }

  return 1;
}

void sub_10010261C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_10010263C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  uint64_t v7[2] = sub_1001026F4;
  void v7[3] = &unk_100411380;
  uint64_t v6 = *(void **)(a1 + 32);
  id v8 = *(id *)(a1 + 40);
  id v9 = *(id *)(a1 + 48);
  [v6 handleSaveComplete:a2 withError:a3 completion:v7];
}

void sub_1001026F4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  unsigned __int8 v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = [*(id *)(a1 + 32) recordID];
      *(_DWORD *)buf = 138543618;
      id v11 = v6;
      __int16 v12 = 2112;
      id v13 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to save pending snapshot record %{public}@: %@", buf, 0x16u);

      id v8 = [*(id *)(a1 + 32) recordID];
      _MBLog();
    }
    unsigned __int8 v5 = *(id *)(a1 + 40);
    objc_sync_enter(v5);
    [*(id *)(a1 + 40) addObject:v3];
    objc_sync_exit(v5);
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = [*(id *)(a1 + 32) recordID];
    *(_DWORD *)buf = 138543362;
    id v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Saved snapshot record %{public}@", buf, 0xCu);

    id v9 = [*(id *)(a1 + 32) recordID];
    _MBLog();
  }
}

void sub_1001028BC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001028D8(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v8 = MBGetDefaultLog();
  id v9 = v8;
  if (v7)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) recordID];
      *(_DWORD *)buf = 138543618;
      id v15 = v10;
      __int16 v16 = 2112;
      id v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to save device record %{public}@: %@", buf, 0x16u);

      __int16 v12 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) recordID];
      _MBLog();
    }
    id v9 = *(id *)(a1 + 32);
    objc_sync_enter(v9);
    [*(id *)(a1 + 32) addObject:v7];
    objc_sync_exit(v9);
  }
  else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = [v6 recordID];
    *(_DWORD *)buf = 138543362;
    id v15 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Saved device record %{public}@", buf, 0xCu);

    id v13 = [v6 recordID];
    _MBLog();
  }
}

void sub_100102AD8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100102AF4(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v3 = [*(id *)(a1 + 32) lastObject];
  if (!v3) {
    id v3 = v4;
  }
  [*(id *)(a1 + 40) handleSaveComplete:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) withError:v3 completion:*(void *)(a1 + 48)];
}

void sub_100104114(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001054F0(id a1, NSString *a2, MBCKKeyBag *a3, BOOL *a4)
{
  unsigned __int8 v5 = a2;
  id v6 = a3;
  id v7 = MBGetDefaultLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    id v8 = [(MBCKKeyBag *)v6 keybagData];
    *(_DWORD *)buf = 138412546;
    id v11 = v5;
    __int16 v12 = 2048;
    id v13 = [v8 length];
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "=keybag ref= Fetched keybagUUID:%@ (%llu bytes)", buf, 0x16u);

    id v9 = [(MBCKKeyBag *)v6 keybagData];
    [v9 length];
    _MBLog();
  }
}

uint64_t sub_1001057F4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100105AC0(uint64_t a1, void *a2)
{
  id v3 = [a2 commitID];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

id sub_100105D9C(uint64_t a1, void *a2)
{
  id v3 = [a2 snapshotID];
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

uint64_t sub_100106A54(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = [*(id *)(a1 + 32) domainName];
  id v7 = (void *)v6;
  if (v6
    && ![v5 executeWithError:a3, @"INSERT OR IGNORE INTO PendingManifestIDToDomainName (manifestID, domainName) VALUES (%@, %@)", *(void *)(a1 + 40), v6 sql])
  {
    uint64_t v18 = 0;
  }
  else
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v8 = *(id *)(a1 + 48);
    id v9 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v9)
    {
      id v10 = v9;
      id v20 = v7;
      uint64_t v11 = *(void *)v22;
      while (2)
      {
        for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v22 != v11) {
            objc_enumerationMutation(v8);
          }
          id v13 = [*(id *)(*((void *)&v21 + 1) + 8 * i) recordID];
          id v14 = [v13 recordName];

          if (!v14) {
            __assert_rtn("-[MBCKRefreshManifestDomainCache _addReferences:forManifest:isPlaceholder:error:]_block_invoke", "MBCKRefreshManifestDomainCache.m", 139, "referenceID");
          }
          uint64_t v15 = +[MBCKFile fileIDFromRecordName:v14];
          if (!v15) {
            __assert_rtn("-[MBCKRefreshManifestDomainCache _addReferences:forManifest:isPlaceholder:error:]_block_invoke", "MBCKRefreshManifestDomainCache.m", 142, "fileID");
          }
          __int16 v16 = (void *)v15;
          uint64_t v17 = *(void *)(a1 + 40);
          if (*(unsigned char *)(a1 + 56))
          {
            if (([v5 executeWithError:a3, @"INSERT OR IGNORE INTO PendingPlaceholderIDToManifestID (referenceID, manifestID) VALUES (%@, %@)", v15, v17 sql] & 1) == 0)goto LABEL_17; {
          }
            }
          else if (![v5 executeWithError:a3, @"INSERT OR IGNORE INTO PendingFileIDToManifestID (referenceID, manifestID) VALUES (%@, %@)", v15, v17 sql])
          {
LABEL_17:

            uint64_t v18 = 0;
            goto LABEL_18;
          }
        }
        id v10 = [v8 countByEnumeratingWithState:&v21 objects:v25 count:16];
        if (v10) {
          continue;
        }
        break;
      }
      uint64_t v18 = 1;
LABEL_18:
      id v7 = v20;
    }
    else
    {
      uint64_t v18 = 1;
    }
  }
  return v18;
}

BOOL sub_100107140(id a1, PQLResultSet *a2, id *a3)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    id v5 = [(PQLResultSet *)v3 stringAtIndex:0];
    uint64_t v6 = [(PQLResultSet *)v3 stringAtIndex:1];
    *(_DWORD *)buf = 138412546;
    uint64_t v11 = v5;
    __int16 v12 = 2112;
    id v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "=domaincache= FileToManifest: %@ -> %@", buf, 0x16u);

    id v7 = [(PQLResultSet *)v3 stringAtIndex:0];
    id v9 = [(PQLResultSet *)v3 stringAtIndex:1];
    _MBLog();
  }
  return 1;
}

BOOL sub_10010727C(id a1, PQLResultSet *a2, id *a3)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    id v5 = [(PQLResultSet *)v3 stringAtIndex:0];
    uint64_t v6 = [(PQLResultSet *)v3 stringAtIndex:1];
    *(_DWORD *)buf = 138412546;
    uint64_t v11 = v5;
    __int16 v12 = 2112;
    id v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "=domaincache= PlaceholderToManifest: %@ -> %@", buf, 0x16u);

    id v7 = [(PQLResultSet *)v3 stringAtIndex:0];
    id v9 = [(PQLResultSet *)v3 stringAtIndex:1];
    _MBLog();
  }
  return 1;
}

BOOL sub_1001073B8(id a1, PQLResultSet *a2, id *a3)
{
  id v3 = a2;
  id v4 = MBGetDefaultLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    id v5 = [(PQLResultSet *)v3 stringAtIndex:0];
    uint64_t v6 = [(PQLResultSet *)v3 stringAtIndex:1];
    *(_DWORD *)buf = 138412546;
    uint64_t v11 = v5;
    __int16 v12 = 2112;
    id v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "=domaincache= ManifestToDomainName: %@ -> %@", buf, 0x16u);

    id v7 = [(PQLResultSet *)v3 stringAtIndex:0];
    id v9 = [(PQLResultSet *)v3 stringAtIndex:1];
    _MBLog();
  }
  return 1;
}

void sub_100107B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t sub_100107B70(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100107B80(uint64_t a1)
{
}

void sub_100107B88(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (!v9)
  {
    id v14 = (id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    uint64_t v15 = a3;
LABEL_8:
    objc_storeStrong(v14, v15);
    goto LABEL_9;
  }
  id v10 = MBGetDefaultLog();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    id v17 = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to fetch the account record: %@", buf, 0xCu);
    _MBLog();
  }

  if (!+[MBError isCKNotFoundError:v9])
  {
    id v14 = (id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    uint64_t v15 = a4;
    goto LABEL_8;
  }
  uint64_t v11 = +[MBError errorWithCode:204 format:@"Account record does not exist"];
  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
  id v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v11;

LABEL_9:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100108298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location, char a19)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1001082D4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  if (v6)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
    id v8 = [WeakRetained operationID];

    id v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      uint64_t v11 = v8;
      __int16 v12 = 2112;
      id v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Device delete operation %{public}@ failed with error: %@", buf, 0x16u);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a4);
  }
  else
  {
    [*(id *)(a1 + 32) removeDeviceForUUID:*(void *)(a1 + 40)];
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_100108644(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v18 = a3;
  id v8 = a4;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id v9 = [v7 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v20;
    do
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v20 != v11) {
          objc_enumerationMutation(v7);
        }
        id v13 = *(void **)(*((void *)&v19 + 1) + 8 * i);
        [v13 setHmacKey:*(void *)(*(void *)(a1 + 32) + 104)];
        id v14 = *(void **)(*(void *)(a1 + 32) + 72);
        uint64_t v15 = [v13 deviceUUID];
        [v14 setObject:v13 forKeyedSubscript:v15];
      }
      id v10 = [v7 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }
    while (v10);
  }
  __int16 v16 = (char *)[*(id *)(a1 + 40) count];
  id v17 = (char *)[v7 count];
  if (v16 == &v17[(void)[v18 count]])
  {

LABEL_11:
    id v8 = 0;
    *(unsigned char *)(*(void *)(a1 + 32) + 89) = 1;
    goto LABEL_12;
  }
  if (!v8) {
    goto LABEL_11;
  }
LABEL_12:
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10010894C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100108964(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_10010A70C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 stringAtIndex:0];
  id v5 = [v3 stringAtIndex:1];
  [v3 unsignedLongLongAtIndex:2];

  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  return v6;
}

uint64_t sub_10010A884(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 stringAtIndex:0];
  id v5 = [v3 stringAtIndex:1];

  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  return v6;
}

uint64_t sub_10010A9E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 stringAtIndex:0];
  [v3 BOOLAtIndex:1];

  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  return v5;
}

void sub_10010ACC0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010ACD4(id a1)
{
  qword_100482480 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___MBHelperServiceProtocol];
  _objc_release_x1();
}

void sub_10010AD1C(uint64_t a1)
{
  id obj = *(id *)(a1 + 32);
  objc_sync_enter(obj);
  uint64_t v1 = (void *)qword_100482478;
  qword_100482478 = 0;

  objc_sync_exit(obj);
}

id sub_10010AFF0(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _finishWithError:a2];
}

id sub_10010AFFC(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _finishWithError:a2];
}

void sub_10010B328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10010B350(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  double v2 = WeakRetained;
  if (WeakRetained)
  {
    id v3 = WeakRetained;
    objc_sync_enter(v3);
    id v4 = [v3 block];
    if (v4)
    {
      uint64_t v5 = MBGetDefaultLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        id v8 = v3;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Progress timer: %@", buf, 0xCu);
        _MBLog();
      }

      [v3 progress];
      v4[2](v4);
      uint64_t v6 = [v3 watchdog];
    }
    else
    {
      uint64_t v6 = 0;
    }

    objc_sync_exit(v3);
    [v6 resume];
  }
}

void sub_10010B490(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010B518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10010B52C(void *a1)
{
  id v1 = a1;
  double v2 = MBGetDefaultLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    id v4 = v1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Progress update: %@", buf, 0xCu);
    _MBLog();
  }
}

void sub_10010B870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10010B99C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010BAC4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010BC0C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010BDAC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010BF60(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010C114(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010C2E0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010C468(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010C51C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010C5A0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010C610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10010C734(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010C958(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010CA34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10010CAD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

BOOL sub_10010D50C(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = MBGetDefaultLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    id v18 = v5;
    __int16 v19 = 2112;
    id v20 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Using APFSIOC_MAKE_OBJECT_DATALESS to restore the com.apple.decmpfs xattr on %@: %@", buf, 0x16u);
    _MBLog();
  }

  if (v6)
  {
    id v8 = v6;
    v16[0] = [v8 bytes];
    v16[1] = [v8 length];
    id v9 = v5;
    int v10 = fsctl((const char *)[v9 fileSystemRepresentation], 0x80104A39uLL, v16, 0);
    BOOL v11 = v10 == 0;
    if (v10)
    {
      __int16 v12 = MBGetDefaultLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = *__error();
        *(_DWORD *)buf = 138412546;
        id v18 = v9;
        __int16 v19 = 1024;
        LODWORD(v20) = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "fsctl(APFSIOC_MAKE_OBJECT_DATALESS) failed at %@: %{errno}d", buf, 0x12u);
        __error();
        _MBLog();
      }

      if (a3)
      {
        *a3 = +[MBError errorWithCode:102 path:v9 format:@"set_dataless_attribute error"];
      }
    }
  }
  else
  {
    id v14 = MBGetDefaultLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Unexpected nil extended attribute com.apple.decmpfs for dataless file: %@", buf, 0xCu);
      _MBLog();
    }

    BOOL v11 = 1;
  }

  return v11;
}

id sub_10010F230(uint64_t a1, int a2, char *a3)
{
  memset(&v22, 0, sizeof(v22));
  if (fstatat(a2, a3, &v22, 32))
  {
    uint64_t v6 = *__error();
    if (v6 != 2)
    {
      id v7 = MBGetDefaultLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        id v8 = [*(id *)(a1 + 32) length];
        *(_DWORD *)buf = 136315650;
        long long v24 = a3;
        __int16 v25 = 2048;
        id v26 = v8;
        __int16 v27 = 1024;
        int v28 = v6;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "fstatat failed at %s (%ld): %{errno}d", buf, 0x1Cu);
        id v20 = [*(id *)(a1 + 32) length];
        uint64_t v21 = v6;
        __int16 v19 = a3;
        _MBLog();
      }

      uint64_t v9 = *(void *)(a1 + 32);
      CFStringRef v10 = @"fstatat error";
      uint64_t v11 = v6;
      goto LABEL_19;
    }
  }
  else
  {
    __int16 v12 = MBGetDefaultLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      MBNodeTypeString(v22.st_mode);
      int v13 = (char *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      long long v24 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Removing existing %@", buf, 0xCu);

      MBNodeTypeString(v22.st_mode);
      __int16 v19 = (char *)objc_claimAutoreleasedReturnValue();
      _MBLog();
    }
    if (unlinkat(a2, a3, 0) && *__error() != 2)
    {
      uint64_t v11 = *__error();
      uint64_t v9 = *(void *)(a1 + 32);
      CFStringRef v10 = @"Error removing existing item while restoring symbolic link";
      goto LABEL_19;
    }
  }
  id v14 = MBGetDefaultLog();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    uint64_t v15 = *(char **)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    long long v24 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Creating symbolic link: %@", buf, 0xCu);
    __int16 v19 = *(char **)(a1 + 40);
    _MBLog();
  }

  if ([*(id *)(a1 + 40) length]) {
    __int16 v16 = (const char *)[*(id *)(a1 + 40) fileSystemRepresentation];
  }
  else {
    __int16 v16 = "";
  }
  if (!symlinkat(v16, a2, a3))
  {
    id v17 = 0;
    goto LABEL_20;
  }
  uint64_t v11 = *__error();
  uint64_t v9 = *(void *)(a1 + 32);
  CFStringRef v10 = @"symlinkat error";
LABEL_19:
  id v17 = +[MBError errorWithErrno:path:format:](MBError, "errorWithErrno:path:format:", v11, v9, v10, v19, v20, v21);
LABEL_20:
  return v17;
}

id sub_10010F550(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 128))
  {
    uint64_t v4 = *(unsigned int *)(a1 + 60);
    uint64_t v5 = *(unsigned int *)(a1 + 64);
    uint64_t v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      int v29 = v4;
      __int16 v30 = 1024;
      LODWORD(v31) = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Restoring symbolic link ownership: %d:%d", buf, 0xEu);
      uint64_t v24 = v4;
      uint64_t v26 = v5;
      _MBLog();
    }

    if (fchown(a2, v4, v5))
    {
      uint64_t v7 = +[MBError posixErrorWithCode:102 path:*(void *)(a1 + 32) format:@"fchown error"];
LABEL_6:
      id v8 = (void *)v7;
      goto LABEL_31;
    }
    if ((*(_WORD *)(a1 + 124) & 0xF000) == 0xA000) {
      int v9 = 0;
    }
    else {
      int v9 = *(_DWORD *)(a1 + 68) & 0x80;
    }
    uint64_t v10 = v9 | *(_DWORD *)(a1 + 68) & 0x8040u;
    if (v10)
    {
      uint64_t v11 = MBGetDefaultLog();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67109120;
        int v29 = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Restoring symlink BSD flags: 0x%x", buf, 8u);
        uint64_t v24 = v10;
        _MBLog();
      }

      if (fchflags(a2, v10))
      {
        int v12 = *__error();
        int v13 = MBGetDefaultLog();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          uint64_t v14 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 67109634;
          int v29 = v10;
          __int16 v30 = 2112;
          uint64_t v31 = v14;
          __int16 v32 = 1024;
          int v33 = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to restore symlink BSD flags (0x%x) at %@: %{errno}d", buf, 0x18u);
          _MBLog();
        }

        uint64_t v7 = +[MBError errorWithCode:102 path:*(void *)(a1 + 32) format:@"fchflags error"];
        goto LABEL_6;
      }
    }
  }
  uint64_t v15 = objc_msgSend(*(id *)(a1 + 40), "extendedAttributes", v24, v26);
  if (!v15) {
    goto LABEL_22;
  }
  __int16 v16 = MBGetDefaultLog();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "Restoring symbolic link extended attributes", buf, 2u);
    _MBLog();
  }

  id v27 = 0;
  unsigned int v17 = +[MBExtendedAttributes setAttributes:v15 forFD:a2 error:&v27];
  id v18 = v27;
  __int16 v19 = v18;
  if (v17)
  {

    if (!*(unsigned char *)(a1 + 128)) {
      goto LABEL_27;
    }
LABEL_22:
    uint64_t v20 = *(_WORD *)(a1 + 124) & 0xFFF;
    uint64_t v21 = MBGetDefaultLog();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      int v29 = v20;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "Restoring symbolic link permissions: 0%3o", buf, 8u);
      uint64_t v25 = v20;
      _MBLog();
    }

    if (fchmod(a2, v20))
    {
      uint64_t v22 = +[MBError posixErrorWithCode:102 path:*(void *)(a1 + 32) format:@"fchmod error"];
    }
    else
    {
LABEL_27:
      uint64_t v22 = objc_msgSend(*(id *)(a1 + 40), "restoreLastModifiedWithFD:", a2, v25);
    }
    id v8 = (void *)v22;
    goto LABEL_30;
  }
  id v8 = +[MBError errorWithCode:102 error:*(void *)(a1 + 48) format:@"setxattr error"];

LABEL_30:
LABEL_31:
  return v8;
}

id sub_10010FD3C(uint64_t a1, int a2, char *a3)
{
  uint64_t v6 = (void *)(*(_WORD *)(a1 + 108) & 0xFFF);
  memset(&v26, 0, sizeof(v26));
  if (fstatat(a2, a3, &v26, 32))
  {
    if (*__error() != 2)
    {
      uint64_t v15 = *__error();
      __int16 v16 = MBGetDefaultLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        id v17 = [*(id *)(a1 + 32) length];
        *(_DWORD *)buf = 136315650;
        int v28 = a3;
        __int16 v29 = 2048;
        id v30 = v17;
        __int16 v31 = 1024;
        int v32 = v15;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "fstatat failed at %s (%ld): %{errno}d", buf, 0x1Cu);
        id v24 = [*(id *)(a1 + 32) length];
        uint64_t v25 = v15;
        long long v23 = a3;
        _MBLog();
      }

      uint64_t v9 = *(void *)(a1 + 32);
      CFStringRef v10 = @"fstatat error";
      uint64_t v18 = 101;
      goto LABEL_24;
    }
    uint64_t v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = *(char **)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      int v28 = v8;
      __int16 v29 = 1024;
      LODWORD(v30) = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Making directory at %@ (0%3o)", buf, 0x12u);
      long long v23 = *(char **)(a1 + 32);
      id v24 = v6;
      _MBLog();
    }

    if (mkpathat_np(a2, a3, (mode_t)v6))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      CFStringRef v10 = @"mkpathat_np error";
LABEL_23:
      uint64_t v18 = 102;
LABEL_24:
      uint64_t v21 = +[MBError posixErrorWithCode:path:format:](MBError, "posixErrorWithCode:path:format:", v18, v9, v10, v23, v24, v25);
      goto LABEL_26;
    }
  }
  else
  {
    int v11 = v26.st_mode & 0xF000;
    int v12 = MBGetDefaultLog();
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_INFO);
    if (v11 == 0x4000)
    {
      if (v13)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Directory already exists", buf, 2u);
        _MBLog();
      }

      uint64_t v14 = MBGetDefaultLog();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v2_Block_object_dispose(&STACK[0x250], 8) = v6;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Restoring directory permissions: 0%3o", buf, 8u);
        long long v23 = (char *)v6;
        _MBLog();
      }

      if (fchmodat(a2, a3, (mode_t)v6, 32))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        CFStringRef v10 = @"fchmodat error";
        goto LABEL_23;
      }
    }
    else
    {
      if (v13)
      {
        MBNodeTypeString(v26.st_mode);
        __int16 v19 = (char *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412290;
        int v28 = v19;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Removing existing object %@", buf, 0xCu);

        MBNodeTypeString(v26.st_mode);
        long long v23 = (char *)objc_claimAutoreleasedReturnValue();
        _MBLog();
      }
      unlinkat(a2, a3, 0);
      uint64_t v20 = MBGetDefaultLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v2_Block_object_dispose(&STACK[0x250], 8) = v6;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Making directory: 0%3o", buf, 8u);
        long long v23 = (char *)v6;
        _MBLog();
      }

      if (mkdirat(a2, a3, (mode_t)v6))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        CFStringRef v10 = @"mkdirat error";
        goto LABEL_23;
      }
    }
  }
  uint64_t v21 = 0;
LABEL_26:
  return v21;
}

id sub_10011019C(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 128))
  {
    uint64_t v4 = (void *)*(unsigned int *)(a1 + 60);
    uint64_t v5 = *(unsigned int *)(a1 + 64);
    uint64_t v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)id v38 = v4;
      *(_WORD *)&v38[4] = 1024;
      *(_DWORD *)&v38[6] = v5;
      *(_WORD *)&v38[10] = 2112;
      *(void *)&v38[12] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Restoring directory ownership: %d:%d at path %@", buf, 0x18u);
      uint64_t v33 = v5;
      uint64_t v34 = *(void *)(a1 + 32);
      id v32 = v4;
      _MBLog();
    }

    if (fchown(a2, (uid_t)v4, v5))
    {
      id v8 = +[MBError posixErrorWithCode:102 path:*(void *)(a1 + 32) format:@"fchown error"];
      goto LABEL_39;
    }
  }
  id v9 = [*(id *)(a1 + 32) fileSystemRepresentation];
  CFStringRef v10 = [*(id *)(a1 + 40) extendedAttributes];
  if (v10)
  {
    int v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      id v12 = [v10 count];
      uint64_t v13 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 134218242;
      *(void *)id v38 = v12;
      *(_WORD *)&v38[8] = 2112;
      *(void *)&v38[10] = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Restoring directory extended attributes (%ld) at path %@", buf, 0x16u);
      id v32 = [v10 count];
      uint64_t v33 = *(void *)(a1 + 32);
      _MBLog();
    }

    if ((*(unsigned char *)(a1 + 71) & 0x40) != 0)
    {
      uint64_t v14 = [v10 objectForKeyedSubscript:@"com.apple.decmpfs"];
      if (v14)
      {
        uint64_t v15 = MBGetDefaultLog();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Not re-applying the com.apple.decmpfs xattr yet.", buf, 2u);
          _MBLog();
        }

        id v16 = [v10 mutableCopy];
        [v16 removeObjectForKey:@"com.apple.decmpfs"];

        CFStringRef v10 = v16;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    id v36 = 0;
    unsigned int v17 = +[MBExtendedAttributes setAttributes:forPathFSR:error:](MBExtendedAttributes, "setAttributes:forPathFSR:error:", v10, v9, &v36, v32, v33, v34);
    id v18 = v36;
    __int16 v19 = v18;
    if (!v17)
    {
      id v8 = +[MBError errorWithCode:102 error:v18 format:@"setxattr error"];

      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (!*(unsigned char *)(a1 + 128)) {
    goto LABEL_34;
  }
  int v20 = *(_DWORD *)(a1 + 68);
  if ((*(_WORD *)(a1 + 124) & 0xF000) == 0xA000) {
    int v21 = 0;
  }
  else {
    int v21 = *(_DWORD *)(a1 + 68) & 0x80;
  }
  __uint32_t v22 = v21 | *(_DWORD *)(a1 + 68) & 0x8040;
  if (v22)
  {
    long long v23 = MBGetDefaultLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)id v38 = v22;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "Restoring directory BSD flags: 0x%x", buf, 8u);
      _MBLog();
    }

    if (fchflags(a2, v22))
    {
      int v24 = *__error();
      uint64_t v25 = MBGetDefaultLog();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        uint64_t v26 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)id v38 = v22;
        *(_WORD *)&v38[4] = 2112;
        *(void *)&v38[6] = v26;
        *(_WORD *)&v38[14] = 1024;
        *(_DWORD *)&v38[16] = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to restore directory BSD flags (0x%x) at %@: %{errno}d", buf, 0x18u);
        _MBLog();
      }

      uint64_t v27 = +[MBError errorWithCode:102 path:*(void *)(a1 + 32) format:@"fchflags error"];
LABEL_36:
      id v8 = (void *)v27;
      goto LABEL_38;
    }
    int v20 = *(_DWORD *)(a1 + 68);
  }
  if ((v20 & 0x40000000) == 0)
  {
LABEL_34:
    if (!*(unsigned char *)(a1 + 129))
    {
      id v8 = 0;
      goto LABEL_38;
    }
    uint64_t v27 = [*(id *)(a1 + 48) _setProtectionClassWithPathFSR:v9];
    goto LABEL_36;
  }
  int v28 = *(void **)(a1 + 32);
  id v35 = 0;
  BOOL v29 = sub_10010D50C(v28, v14, &v35);
  id v30 = v35;
  id v8 = v30;
  if (v29)
  {

    goto LABEL_34;
  }
LABEL_38:

LABEL_39:
  return v8;
}

void sub_1001118B0(uint64_t a1, void *a2, void *a3)
{
  id v7 = a3;
  uint64_t v5 = [a2 recordName];
  unsigned int v6 = [v5 isEqualToString:*(void *)(a1 + 32)];

  if (v6) {
    [*(id *)(a1 + 40) refreshWithRecord:v7];
  }
  [*(id *)(a1 + 40) _reportProgressOfSuccessfullyFetchedManifestPageRecord:v7 referenceFetchProgress:*(void *)(a1 + 48)];
}

void sub_10011193C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = [*(id *)(a1 + 32) domainName];
      *(_DWORD *)buf = 138412546;
      id v8 = v5;
      __int16 v9 = 2112;
      id v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error fetching manifest for domain %@: %@", buf, 0x16u);

      unsigned int v6 = [*(id *)(a1 + 32) domainName];
      _MBLog();
    }
  }
  (*(void (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v3);
}

void sub_100112068(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100112154(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 valueForKey:@"recordID"];
  uint64_t v5 = [v3 domainName];

  LOBYTE(v3) = +[MBDomain isAppPlaceholderName:v5];
  if ((v3 & 1) == 0) {
    [*(id *)(a1 + 32) addObject:v4];
  }

  return 1;
}

uint64_t sub_1001122C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 valueForKey:@"recordID"];
  uint64_t v5 = [v3 domainName];

  LODWORD(v3) = +[MBDomain isAppPlaceholderName:v5];
  if (v3) {
    [*(id *)(a1 + 32) addObject:v4];
  }

  return 1;
}

void sub_100113348(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100113364(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v6)
  {
    int v11 = [a1[4] debugContext];
    unsigned int v12 = [v11 isFlagSet:@"SimulateNetworkUnavailableErrorOnUpload"];

    if (!v12) {
      goto LABEL_7;
    }
    uint64_t v13 = +[MBError posixErrorWithCode:308 format:@"Simulated network unreachable error"];
    uint64_t v14 = [v13 userInfo];
    id v6 = +[NSError errorWithDomain:CKErrorDomain code:3 userInfo:v14];

    if (!v6)
    {
LABEL_7:
      id v15 = a1[5];
      id v85 = 0;
      unsigned __int8 v16 = [v15 validateEncryptionKeyWithError:&v85];
      id v17 = v85;
      if (v16)
      {
        if (MBIsInternalInstall())
        {
          unsigned int v84 = [a1[5] protectionClass];
          id v18 = [a1[5] relativePath];
          __int16 v19 = [a1[5] absolutePath];
          int v20 = [a1[5] domainName];
          int v21 = [v5 objectForKeyedSubscript:@"contents"];
          __uint32_t v22 = v21;
          if (v21)
          {
            long long v23 = [v21 signature];
            int v24 = v23;
            if (v23)
            {
              id v25 = [v23 length];
              uint64_t v26 = [v24 bytes];
              if (v25)
              {
                uint64_t v27 = v26;
                if (v26)
                {
                  uint64_t v82 = [v24 base64EncodedStringWithOptions:0];
                  int v28 = MBGetDefaultLog();
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
                  {
                    id v29 = [v22 size];
                    int v30 = *v27;
                    *(_DWORD *)buf = 138413570;
                    char v88 = v20;
                    if (v30 == 4) {
                      __int16 v31 = "v2";
                    }
                    else {
                      __int16 v31 = "v1";
                    }
                    __int16 v89 = 2112;
                    id v90 = v19;
                    __int16 v91 = 2048;
                    id v92 = v29;
                    __int16 v93 = 1024;
                    unsigned int v94 = v84;
                    __int16 v95 = 2080;
                    id v96 = v31;
                    __int16 v97 = 2112;
                    uint64_t v98 = v82;
                    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "Uploaded %@:%@, sz:%llu, pc:%d, MMCS%s sig:%@", buf, 0x3Au);
                    id v32 = [v22 size];
                    uint64_t v33 = "v1";
                    if (*v27 == 4) {
                      uint64_t v33 = "v2";
                    }
                    id v80 = v33;
                    id v81 = v82;
                    id v78 = v32;
                    uint64_t v79 = v84;
                    dispatch_time_t v74 = v20;
                    int v76 = v19;
                    _MBLog();
                  }
                }
              }
            }
          }
          uint64_t v34 = objc_msgSend(v5, "objectForKeyedSubscript:", @"resources", v74, v76, v78, v79, v80, v81);
          id v35 = v34;
          if (v34)
          {
            long long v83 = v19;
            id v36 = v18;
            id v37 = [v34 signature];
            id v38 = v37;
            if (v37)
            {
              id v39 = [v37 length];
              double v40 = [v38 bytes];
              if (v39)
              {
                long long v41 = v40;
                if (v40)
                {
                  long long v42 = MBGetDefaultLog();
                  if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
                  {
                    id v43 = [v35 size];
                    int v44 = *v41;
                    *(_DWORD *)buf = 138413314;
                    char v88 = v20;
                    if (v44 == 4) {
                      uint64_t v45 = "v2";
                    }
                    else {
                      uint64_t v45 = "v1";
                    }
                    __int16 v89 = 2112;
                    id v90 = v36;
                    __int16 v91 = 2048;
                    id v92 = v43;
                    __int16 v93 = 1024;
                    unsigned int v94 = v84;
                    __int16 v95 = 2080;
                    id v96 = v45;
                    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_INFO, "Uploaded xattrs for d:%@, rp:\"%@\", sz:%llu, pc:%d, MMCS%s", buf, 0x30u);
                    id v46 = [v35 size];
                    if (*v41 == 4) {
                      id v47 = "v2";
                    }
                    else {
                      id v47 = "v1";
                    }
                    uint64_t v79 = v84;
                    id v80 = v47;
                    int v76 = v36;
                    id v78 = v46;
                    dispatch_time_t v74 = v20;
                    _MBLog();
                  }
                }
              }
            }

            id v18 = v36;
            __int16 v19 = v83;
          }
        }
        if (objc_msgSend(a1[5], "isRegularFile", v74, v76, v78, v79, v80))
        {
          CFStringRef v48 = [a1[4] telemetry];
          objc_msgSend(v48, "countUploadedFileWithSize:", objc_msgSend(a1[5], "aggregateSize"));
        }
        uint64_t v49 = [a1[6] cache];
        uint64_t v50 = [v49 setFileStateToCompleted:a1[5]];

        id v51 = MBGetDefaultLog();
        id v52 = v51;
        if (v50)
        {
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            id v53 = a1[5];
            *(_DWORD *)buf = 138412546;
            char v88 = v53;
            __int16 v89 = 2112;
            id v90 = v50;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Failed to commit in flight file (%@) to cache: %@", buf, 0x16u);
            id v75 = a1[5];
            long long v77 = v50;
            _MBLog();
          }

          [a1[6] setFileUploadError:v50];
        }
        else
        {
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
          {
            id v73 = [a1[5] fileID];
            *(_DWORD *)buf = 138412290;
            char v88 = v73;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEBUG, "Committed file %@", buf, 0xCu);

            id v75 = [a1[5] fileID];
            _MBLog();
          }
        }
        objc_msgSend(a1[5], "cleanupAfterUpload", v75, v77);
      }
      else
      {
        id v57 = MBGetDefaultLog();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        {
          id v58 = a1[5];
          *(_DWORD *)buf = 138412546;
          char v88 = v58;
          __int16 v89 = 2112;
          id v90 = v17;
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "File encryption key doesn't check out after upload for %@: %@", buf, 0x16u);
          _MBLog();
        }

        uint64_t v50 = +[MBError errorWithCode:215 error:v17 format:@"Encryption key changed for file"];
        [a1[6] setFileUploadError:v50];
      }

      id v6 = 0;
      goto LABEL_68;
    }
  }
  if (+[MBError isCKPartialFailureError:v6]) {
    goto LABEL_3;
  }
  id v10 = [v6 domain];
  if (![CKErrorDomain isEqualToString:v10]) {
    goto LABEL_53;
  }
  id v54 = [v6 code];

  if (v54 == (id)17)
  {
LABEL_3:
    id v7 = [v6 userInfo];
    id v8 = [v7 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
    __int16 v9 = [v5 recordID];
    id v10 = [v8 objectForKeyedSubscript:v9];

    if ([v6 code] != (id)17)
    {
      id v55 = [v10 domain];
      if (([CKErrorDomain isEqualToString:v55] & 1) == 0)
      {

        goto LABEL_53;
      }
      id v56 = [v10 code];

      if (v56 != (id)17) {
        goto LABEL_53;
      }
    }
    [a1[5] confirmFileWasModifiedOnDisk];
LABEL_53:
  }
  char v59 = MBGetDefaultLog();
  if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
  {
    uint64_t v60 = [a1[5] domainName];
    id v61 = [a1[5] relativePath];
    *(_DWORD *)buf = 138412802;
    char v88 = v60;
    __int16 v89 = 2112;
    id v90 = v61;
    __int16 v91 = 2112;
    id v92 = v6;
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "Failed to upload %@:%@ (%@)", buf, 0x20u);

    uint64_t v62 = [a1[5] domainName];
    int v76 = [a1[5] relativePath];
    id v78 = v6;
    dispatch_time_t v74 = v62;
    _MBLog();
  }
  [a1[6] setFileUploadError:v6];
  if (+[MBError isAssetNotFoundError:v6])
  {
    id v63 = [a1[5] assetPath];
    long long v64 = [a1[7] snapshotPath];
    long long v65 = [a1[5] domain];
    long long v66 = [v65 volumeMountPoint];
    MBDiagnoseUnavailableiCloudBackupFile(v63, v64, v66, 2, (uint64_t)"open");
  }
  if (+[MBError isAssetNotAvailableError:](MBError, "isAssetNotAvailableError:", v6, v74, v76, v78))
  {
    char v67 = [a1[5] absolutePath];
    id v86 = 0;
    unsigned int v68 = +[MBProtectionClassUtils isContentUnavailableDueToCxExpiration:v67 error:&v86];
    id v17 = v86;

    if (v68 && v17)
    {
      [a1[6] setFileUploadError:v17];
    }
    else
    {
      long long v69 = [a1[5] assetPath];
      long long v70 = [a1[7] snapshotPath];
      long long v71 = [a1[5] domain];
      CFStringRef v72 = [v71 volumeMountPoint];
      MBDiagnoseUnavailableiCloudBackupFile(v69, v70, v72, 1, (uint64_t)"open");
    }
LABEL_68:
  }
}

void sub_100114218(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  id v5 = [v3 cache];
  id v6 = +[MBCKFile fileWithRecord:v4 cache:v5 manifest:*(void *)(a1 + 32)];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1001142B8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v5 || v6)
  {
    id v8 = MBGetDefaultLog();
    __int16 v9 = v8;
    if (v7)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 138543618;
        uint64_t v13 = v10;
        __int16 v14 = 2114;
        id v15 = v7;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "PrivilegedManifestDownload query (%{public}@) failed: %{public}@", buf, 0x16u);
LABEL_9:
        _MBLog();
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      uint64_t v13 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PrivilegedManifestDownload query (%{public}@) completed", buf, 0xCu);
      goto LABEL_9;
    }

    (*(void (**)(void, void *))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), v7);
    goto LABEL_11;
  }
  [*(id *)(a1 + 40) _queryManifestWithOperationTracker:*(void *)(a1 + 48) progress:*(void *)(a1 + 64) recordName:*(void *)(a1 + 32) cursor:v5 completion:*(void *)(a1 + 56)];
LABEL_11:
}

void sub_100114660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100114684(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100114694(uint64_t a1)
{
}

void sub_10011469C(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_100114840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100114858(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_100114B00(uint64_t a1, void *a2)
{
  id v3 = [a2 valueForKey:@"recordID"];
  [*(id *)(a1 + 32) addObject:v3];

  return 1;
}

void sub_100114C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100114C9C(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_100115554(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [objc_alloc((Class)NSString) initWithFormat:@"%@%@", @"F:", v3];

  id v5 = [objc_alloc((Class)CKRecordID) initWithRecordName:v4];
  [*(id *)(a1 + 32) addObject:v5];

  return 1;
}

void sub_1001155EC(uint64_t a1, void *a2, uint64_t a3)
{
  if (!a3)
  {
    id v4 = [a2 recordName];
    id v5 = [v4 substringFromIndex:objc_msgSend(@"M:", "length")];

    id v6 = [*(id *)(a1 + 32) cache];
    id v7 = [v6 deleteCloudFilePendingDeleteWithFileID:v5];
  }
  id v8 = *(NSObject **)(a1 + 40);
  dispatch_group_leave(v8);
}

void sub_100115688(id a1)
{
  id v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  attr = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_UTILITY, 0);

  dispatch_queue_t v2 = dispatch_queue_create("com.apple.backupd.deletePendingFiles", attr);
  id v3 = (void *)qword_100482498;
  qword_100482498 = (uint64_t)v2;
}

void sub_10011570C(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100115B54(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = MBGetDefaultLog();
  id v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      id v10 = v5;
      __int16 v11 = 2112;
      id v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to delete manifest page %{public}@: %@", buf, 0x16u);
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    id v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Deleted manifest page %{public}@", buf, 0xCu);
    goto LABEL_6;
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100115CA4(id a1)
{
  id v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  attr = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_UTILITY, 0);

  dispatch_queue_t v2 = dispatch_queue_create("com.apple.backupd.deletePendingManifests", attr);
  id v3 = (void *)qword_1004824A8;
  qword_1004824A8 = (uint64_t)v2;
}

void sub_100115D28(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100116044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_100116060(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if ([v5 count] || objc_msgSend(v6, "count"))
  {
    id v7 = [*(id *)(a1 + 32) _manifestRecordWithFiles:v5 placeholderFiles:v6 manifestIndex:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)];
    id v8 = [*(id *)(a1 + 32) cache];
    __int16 v9 = [*(id *)(a1 + 32) manifestID];
    id v10 = [v8 addManifestPage:v7 forManifestID:v9 pageIndex:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)];

    if (v10)
    {
      __int16 v11 = MBGetDefaultLog();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
        uint64_t v13 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 134218498;
        uint64_t v20 = v12;
        __int16 v21 = 2112;
        uint64_t v22 = v13;
        __int16 v23 = 2112;
        int v24 = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Unable to add manifestPage %lu for manifest: %@ : %@", buf, 0x20u);
        _MBLog();
      }

      __int16 v14 = +[MBCKManager sharedInstance];
      uint64_t v15 = *(void *)(a1 + 40);
      id v18 = 0;
      [v14 resetCacheWithAccount:v15 error:&v18];
      id v16 = v18;

      id v17 = +[NSAssertionHandler currentHandler];
      objc_msgSend(v17, "handleFailureInMethod:object:file:lineNumber:description:", *(void *)(a1 + 56), *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), *(void *)(a1 + 32), v10);
    }
    ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    [v5 removeAllObjects];
    [v6 removeAllObjects];
  }
}

uint64_t sub_1001162C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 valueForKey:@"recordID"];
  id v5 = [v3 domainName];

  LODWORD(v3) = +[MBDomain isAppPlaceholderName:v5];
  if (v3) {
    id v6 = *(void **)(a1 + 32);
  }
  else {
    id v6 = *(void **)(a1 + 40);
  }
  id v7 = [objc_alloc((Class)CKReference) initWithRecordID:v4 action:0];
  [v6 addObject:v7];

  id v8 = (char *)[*(id *)(a1 + 40) count];
  if (&v8[(void)[*(id *)(a1 + 32) count]] >= (char *)*(void *)(a1 + 56)) {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }

  return 1;
}

void sub_100116A8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_100116AC4(uint64_t a1, void *a2, void *a3)
{
  id v10 = a2;
  id v5 = a3;
  if (v10
    && ([v10 recordID],
        id v6 = objc_claimAutoreleasedReturnValue(),
        [v6 recordName],
        id v7 = objc_claimAutoreleasedReturnValue(),
        unsigned int v8 = [v7 hasSuffix:@":0"],
        v7,
        v6,
        !v5)
    && v8)
  {
    [*(id *)(a1 + 32) refreshWithRecord:v10];
  }
  else if (v5)
  {
    id v9 = *(id *)(a1 + 32);
    objc_sync_enter(v9);
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a3);
    objc_sync_exit(v9);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_100116BB8(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  attr = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_UTILITY, 0);

  dispatch_queue_t v2 = dispatch_queue_create("com.apple.backupd.saveManifests", attr);
  id v3 = (void *)qword_1004824B8;
  qword_1004824B8 = (uint64_t)v2;
}

uint64_t sub_100116C3C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_100116C50(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
  id v3 = MBGetDefaultLog();
  id v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 72);
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
      *(_DWORD *)buf = 134218498;
      uint64_t v16 = v6;
      __int16 v17 = 2112;
      uint64_t v18 = v5;
      __int16 v19 = 2112;
      uint64_t v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to save %lu manifest pages for %@: %@", buf, 0x20u);
      _MBLog();
    }

    (*(void (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), v8);
  }
  else
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = *(void *)(a1 + 72);
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 134218242;
      uint64_t v16 = v9;
      __int16 v17 = 2112;
      uint64_t v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Saved %lu manifest pages for %@", buf, 0x16u);
      _MBLog();
    }

    __int16 v11 = *(void **)(a1 + 40);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_100116E70;
    uint64_t v12[3] = &unk_100411330;
    void v12[4] = v11;
    id v13 = *(id *)(a1 + 48);
    id v14 = *(id *)(a1 + 56);
    [v11 saveToCacheWithCompletion:v12];
  }
}

void sub_100116E70(void *a1, void *a2)
{
  id v3 = (void *)a1[4];
  id v6 = a2;
  id v4 = [v3 cache];
  id v5 = [v4 deleteManifestPagesForManifestID:a1[5]];

  (*(void (**)(void))(a1[6] + 16))();
}

void sub_100117208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_100117234(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100117294(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1001172F4(void *a1)
{
  uint64_t v3 = *(void *)(a1[5] + 8);
  uint64_t v5 = *(void *)(v3 + 40);
  id v4 = (id *)(v3 + 40);
  if (!v5) {
    objc_storeStrong(v4, *(id *)(*(void *)(a1[6] + 8) + 40));
  }
  (*(void (**)(void))(a1[4] + 16))();
}

void sub_100117B30(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100117BEC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100117DE4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100118ACC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100118B78(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100118C10(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100118CF8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100118DA4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100118E44(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001197CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10011A16C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10011B004(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10011B4B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10011B74C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10011CA98(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

id sub_10011CB30(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) setUpWithError:a2];
}

id sub_10011CB3C(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) downloadWithError:a2];
}

uint64_t sub_10011CB48(uint64_t a1, void *a2)
{
  id v4 = *(void **)(a1 + 32);
  id v11 = 0;
  uint64_t v5 = (uint64_t)[v4 restoreAssetWithError:&v11];
  id v6 = v11;
  if ((v5 & 1) != 0
    || !+[MBError isError:v6 withCode:107])
  {
    if (a2) {
      *a2 = v6;
    }
  }
  else
  {
    uint64_t v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = [*(id *)(a1 + 32) file];
      *(_DWORD *)buf = 138412546;
      id v13 = v8;
      __int16 v14 = 2112;
      id v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Skipping restore for file:%@ for error:%@", buf, 0x16u);

      uint64_t v10 = [*(id *)(a1 + 32) file];
      _MBLog();
    }
    uint64_t v5 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }

  return v5;
}

id sub_10011CCAC(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) validateWithError:a2];
}

id sub_10011CCB8(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) setExtendedAttributesWithError:a2];
}

id sub_10011CCC4(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) setAttributesWithError:a2];
}

id sub_10011CCD0(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) setProtectionClassWithError:a2];
}

void sub_10011D480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10011D4A0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10011D4B0(uint64_t a1)
{
}

void sub_10011D4B8(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10011F2A4(id a1)
{
  uint64_t v1 = +[MBBehaviorOptions sharedOptions];
  int v2 = [v1 maxBatchSaveConcurrentModifyRecordsOperationsWithDefaultValue:6];

  if (v2 <= 1) {
    unsigned int v3 = 1;
  }
  else {
    unsigned int v3 = v2;
  }
  if (v2) {
    intptr_t v4 = v3;
  }
  else {
    intptr_t v4 = 0x7FFFFFFFLL;
  }
  qword_1004824D0 = (uint64_t)dispatch_semaphore_create(v4);
  _objc_release_x1();
}

void sub_10011F988(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10011FD20(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    [*(id *)(a1 + 40) uploadProgress];
    double v3 = 1.0 - v2;
    id v4 = [*(id *)(a1 + 40) assetSize];
    unint64_t v5 = (unint64_t)(v3
                          * (double)((unint64_t)v4
                                   + (unint64_t)[*(id *)(a1 + 40) recordSize]));
    id v6 = [*(id *)(a1 + 48) throughputEstimator];
    [v6 sampleUploadedBytes:v5];

    if (objc_opt_respondsToSelector())
    {
      uint64_t v7 = *(void **)(a1 + 56);
      uint64_t v8 = *(void *)(a1 + 64);
      [*(id *)(a1 + 40) uploadProgress];
      objc_msgSend(v7, "record:madeProgress:previousProgress:assetSize:recordSize:", v8, objc_msgSend(*(id *)(a1 + 40), "assetSize"), objc_msgSend(*(id *)(a1 + 40), "recordSize"), 1.0, v9);
    }
    [*(id *)(a1 + 40) setUploadProgress:1.0];
  }
  uint64_t v10 = *(void *)(a1 + 72);
  if (v10) {
    (*(void (**)(uint64_t, void, void))(v10 + 16))(v10, *(void *)(a1 + 64), *(void *)(a1 + 32));
  }
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    uint64_t v12 = *(void **)(a1 + 56);
    uint64_t v13 = *(void *)(a1 + 64);
    uint64_t v14 = *(void *)(a1 + 32);
    return (uint64_t)[v12 recordWasSaved:v13 withError:v14];
  }
  return result;
}

void sub_1001210EC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100121108(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1001213E4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_100121410(uint64_t a1, void *a2, double a3)
{
  id v5 = a2;
  id v6 = [v5 recordID];
  id v7 = *(id *)(a1 + 32);
  objc_sync_enter(v7);
  if (v6)
  {
    uint64_t v8 = [*(id *)(a1 + 32) saveInfosByRecordID];
    double v9 = [v8 objectForKeyedSubscript:v6];
  }
  else
  {
    double v9 = 0;
  }
  uint64_t v10 = [v9 delegate];
  objc_sync_exit(v7);

  id v11 = [*(id *)(a1 + 32) callbackQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10012162C;
  block[3] = &unk_100412AD8;
  double v26 = a3;
  id v12 = v9;
  id v22 = v12;
  id v13 = v10;
  id v23 = v13;
  id v14 = v5;
  uint64_t v15 = *(void *)(a1 + 32);
  id v24 = v14;
  uint64_t v25 = v15;
  dispatch_async(v11, block);

  if (objc_opt_respondsToSelector())
  {
    uint64_t v16 = [*(id *)(a1 + 32) callbackQueue];
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_100121758;
    v17[3] = &unk_100412AB0;
    id v18 = v13;
    id v19 = v14;
    double v20 = a3;
    dispatch_async(v16, v17);
  }
}

void sub_100121618(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10012162C(uint64_t a1)
{
  double v2 = *(double *)(a1 + 64);
  [*(id *)(a1 + 32) uploadProgress];
  double v3 = *(double *)(a1 + 64);
  id v4 = *(void **)(a1 + 32);
  if (v2 >= v5)
  {
    [v4 uploadProgress];
    double v9 = v3 - v8;
    id v10 = [*(id *)(a1 + 32) assetSize];
    double v7 = v9 * (double)((unint64_t)v10 + (unint64_t)[*(id *)(a1 + 32) recordSize]);
    if (objc_opt_respondsToSelector())
    {
      id v12 = *(void **)(a1 + 40);
      uint64_t v11 = *(void *)(a1 + 48);
      double v13 = *(double *)(a1 + 64);
      [*(id *)(a1 + 32) uploadProgress];
      objc_msgSend(v12, "record:madeProgress:previousProgress:assetSize:recordSize:", v11, objc_msgSend(*(id *)(a1 + 32), "assetSize"), objc_msgSend(*(id *)(a1 + 32), "recordSize"), v13, v14);
    }
  }
  else
  {
    id v6 = [v4 assetSize];
    double v7 = v3 * (double)((unint64_t)v6 + (unint64_t)[*(id *)(a1 + 32) recordSize]);
  }
  uint64_t v15 = [*(id *)(a1 + 56) throughputEstimator];
  [v15 sampleUploadedBytes:(unint64_t)v7];

  double v16 = *(double *)(a1 + 64);
  __int16 v17 = *(void **)(a1 + 32);
  return [v17 setUploadProgress:v16];
}

id sub_100121758(uint64_t a1)
{
  return _[*(id *)(a1 + 32) record:*(void *)(a1 + 40) madeProgress:*(double *)(a1 + 48)];
}

void sub_100121768(uint64_t a1, void *a2)
{
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v3 = a2;
  id v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v18;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v18 != v5) {
          objc_enumerationMutation(v3);
        }
        uint64_t v7 = *(void *)(*((void *)&v17 + 1) + 8 * (void)v6);
        id v8 = *(id *)(a1 + 32);
        objc_sync_enter(v8);
        double v9 = [*(id *)(a1 + 32) saveInfosByRecordID];
        id v10 = [v9 objectForKeyedSubscript:v7];

        uint64_t v11 = [v10 record];
        id v12 = [v10 delegate];
        objc_sync_exit(v8);

        if (v12 && (objc_opt_respondsToSelector() & 1) != 0)
        {
          double v13 = [*(id *)(a1 + 32) callbackQueue];
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1001219B4;
          block[3] = &unk_1004110B0;
          id v15 = v12;
          id v16 = v11;
          dispatch_async(v13, block);
        }
        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v4);
  }
}

void sub_100121998(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001219B4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) didSaveAssetsForRecord:*(void *)(a1 + 40)];
}

void sub_1001219C0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v14 = a2;
  id v7 = a3;
  id v8 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v10 = *(id *)(a1 + 32);
  objc_sync_enter(v10);
  if (v14)
  {
    uint64_t v11 = [*(id *)(a1 + 32) saveInfosByRecordID];
    id v12 = [v11 objectForKeyedSubscript:v14];

    if (v12)
    {
      [*(id *)(a1 + 32) _handleCompletionForSaveInfo:v12 operation:WeakRetained record:v7 saveInfos:*(void *)(a1 + 40) error:v8];
      if ([v12 state] == (id)3)
      {
        double v13 = [*(id *)(a1 + 32) saveInfosByRecordID];
        [v13 removeObjectForKey:v14];
      }
    }
  }
  else
  {
    id v12 = 0;
  }

  objc_sync_exit(v10);
}

void sub_100121AE8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100121FF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id obj)
{
}

void sub_100122424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id location)
{
  objc_destroyWeak(v30);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10012246C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained) {
    __assert_rtn("-[MBCKBatchSave _sendBatchSaveOperationForSaveInfos:savePolicy:batchSize:batchAssetsSize:]_block_invoke", "MBCKBatchSave.m", 538, "strongOp");
  }
  uint64_t v11 = WeakRetained;
  id v12 = [WeakRetained operationID];
  double v13 = MBGetDefaultLog();
  id v14 = v13;
  if (v9)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543874;
      long long v20 = v12;
      __int16 v21 = 2114;
      uint64_t v22 = v15;
      __int16 v23 = 2112;
      id v24 = v9;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Operation %{public}@/%{public}@ failed: %@", buf, 0x20u);
LABEL_7:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138543618;
    long long v20 = v12;
    __int16 v21 = 2114;
    uint64_t v22 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Operation %{public}@/%{public}@ completed", buf, 0x16u);
    goto LABEL_7;
  }

  [*(id *)(a1 + 32) _handleCompletionForSaveInfos:*(void *)(a1 + 40) operation:v11 savedRecords:v7 operationError:v9];
  atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(a1 + 32) + 8), 0xFFFFFFFF, memory_order_relaxed);
  long long v17 = [*(id *)(a1 + 32) saveSemaphore];
  dispatch_semaphore_signal(v17);

  long long v18 = [*(id *)(a1 + 32) saveGroup];
  dispatch_group_leave(v18);
}

id sub_100122698(uint64_t a1)
{
  atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(a1 + 32) + 8), 1u, memory_order_relaxed);
  [*(id *)(a1 + 40) addDatabaseOperation:*(void *)(a1 + 48) policy:*(void *)(a1 + 56)];
  id result = [*(id *)(a1 + 32) canceled];
  if (result)
  {
    id result = [*(id *)(a1 + 48) isCancelled];
    if ((result & 1) == 0)
    {
      id v3 = MBGetDefaultLog();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        id v4 = [*(id *)(a1 + 48) operationID];
        uint64_t v5 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 138543618;
        id v8 = v4;
        __int16 v9 = 2114;
        uint64_t v10 = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Canceling operation %{public}@ for %{public}@", buf, 0x16u);

        id v6 = [*(id *)(a1 + 48) operationID];
        _MBLog();
      }
      return [*(id *)(a1 + 48) cancel];
    }
  }
  return result;
}

void sub_100122CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id location)
{
  objc_destroyWeak(v35);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100122D34(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained) {
    __assert_rtn("-[MBCKBatchSave _scheduleBatchSaveOperationForSaveInfos:]_block_invoke", "MBCKBatchSave.m", 598, "strongTimer");
  }
  id v4 = *(id *)(a1 + 32);
  objc_sync_enter(v4);
  uint64_t v5 = [*(id *)(a1 + 32) timers];
  [v5 removeObject:WeakRetained];

  objc_sync_exit(v4);
  if (a2)
  {
    id v6 = +[MBError errorWithCode:202 format:@"Batch save canceled"];
    [*(id *)(a1 + 32) _handleCompletionForSaveInfos:*(void *)(a1 + 40) operation:0 savedRecords:0 operationError:v6];
    id v7 = [*(id *)(a1 + 32) saveSemaphore];
    dispatch_semaphore_signal(v7);
  }
  else
  {
    [*(id *)(a1 + 32) _sendBatchSaveOperationForSaveInfos:*(void *)(a1 + 40) savePolicy:*(void *)(a1 + 56) batchSize:*(void *)(a1 + 64) batchAssetsSize:*(void *)(a1 + 72)];
  }
  id v8 = [*(id *)(a1 + 32) saveGroup];
  dispatch_group_leave(v8);
}

void sub_100122E64(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001234B0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

int64_t sub_100123500(id a1, id a2, id a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 record];
  id v6 = [v5 recordID];
  id v7 = [v6 zoneID];

  id v8 = [v4 record];

  __int16 v9 = [v8 recordID];
  uint64_t v10 = [v9 zoneID];

  id v11 = [v7 compareToRecordZoneID:v10];
  return (int64_t)v11;
}

void sub_1001236A0(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) throughputEstimator];
  [v3 finishSampling];

  [*(id *)(a1 + 32) _finishBatchedSavesWithCompletion:*(void *)(a1 + 40)];
}

void sub_10012381C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100123830(id a1, MBOneShotTimer *a2, unint64_t a3, BOOL *a4)
{
}

void sub_100123964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012397C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10012398C(uint64_t a1)
{
}

void sub_100123994(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    uint64_t v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to upload modified assets: %@", buf, 0xCu);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id sub_100123DBC(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _finishXPCWithError:a2];
}

void sub_100124360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100124394(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001243A4(uint64_t a1)
{
}

void sub_1001243AC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;

  if (v6)
  {
    __int16 v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      id v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to get localized string from byte count: %{public}@", buf, 0xCu);
      _MBLog();
    }
  }
}

void sub_1001244A0(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = a3;
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(void **)(v4 + 16);
  *(void *)(v4 + 16) = 0;

  atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 32) + 8));
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 24));
}

void sub_1001247FC(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = a3;
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(void **)(v4 + 16);
  *(void *)(v4 + 16) = 0;

  atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 32) + 8));
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 32) + 24));
}

void sub_1001249A8(uint64_t a1)
{
  double v2 = MBGetDefaultLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    CFOptionFlags v3 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 134217984;
    CFOptionFlags v16 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Firing prompt attempt:(%llu)", buf, 0xCu);
    _MBLog();
  }

  CFOptionFlags responseFlags = 0;
  SInt32 error = -1;
  CFUserNotificationRef v4 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, &error, *(CFDictionaryRef *)(a1 + 32));
  if (error)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    +[MBError errorWithCode:1, @"CFUserNotificationCreate error:%d", error format];
    uint64_t v7 = LABEL_7:;
    (*(void (**)(uint64_t, void, void *))(v5 + 16))(v5, 0, v7);

    goto LABEL_8;
  }
  objc_storeStrong((id *)(*(void *)(a1 + 40) + 16), v4);
  atomic_store(1u, (unsigned __int8 *)(*(void *)(a1 + 40) + 10));
  uint64_t v6 = CFUserNotificationReceiveResponse(v4, 0.0, &responseFlags);
  SInt32 error = v6;
  atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 40) + 10));
  if (v6)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    +[MBError errorWithCode:1, @"CFUserNotificationReceiveResponse error:%d", v6 format];
    goto LABEL_7;
  }
  CFOptionFlags v8 = responseFlags & 3;
  __int16 v9 = MBGetDefaultLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134217984;
    CFOptionFlags v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Received response from prompt: (%lu)", buf, 0xCu);
    _MBLog();
  }

  unsigned __int8 v10 = atomic_load((unsigned __int8 *)(*(void *)(a1 + 40) + 9));
  if ((v10 & 1) != 0 || v8 != 3)
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48));
  }
  else
  {
    id v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      CFOptionFlags v12 = *(void *)(a1 + 64);
      *(_DWORD *)buf = 134217984;
      CFOptionFlags v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Retrying prompt after %lld seconds", buf, 0xCu);
      _MBLog();
    }

    [*(id *)(a1 + 40) _firePromptWithDict:*(void *)(a1 + 32) retryCount:*(void *)(a1 + 56) + 1 completion:*(void *)(a1 + 48)];
  }
LABEL_8:
}

void sub_100124DC8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100124DDC(id a1)
{
  qword_1004824E8 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___MBHelperServiceProtocol];
  _objc_release_x1();
}

void sub_100124E24(uint64_t a1)
{
  id obj = *(id *)(a1 + 32);
  objc_sync_enter(obj);
  uint64_t v1 = (void *)qword_1004824E0;
  qword_1004824E0 = 0;

  objc_sync_exit(obj);
}

void sub_100126778(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001267AC(uint64_t a1)
{
  qword_100482500 = (uint64_t)dispatch_semaphore_create(*(int *)(a1 + 32));
  return _objc_release_x1();
}

void sub_100126AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

id sub_100126B0C(uint64_t a1, uint64_t a2)
{
  id result = objc_retainBlock(*(id *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_100126B38(uint64_t a1)
{
}

void sub_100126B40(void *a1, void *a2, void *a3, void *a4)
{
  id v14 = a2;
  id v7 = a3;
  id v8 = a4;
  __int16 v9 = v8;
  uint64_t v10 = *(void *)(*(void *)(a1[5] + 8) + 40);
  if (v10)
  {
    if (v8)
    {
      (*(void (**)(uint64_t, id))(v10 + 16))(v10, v8);
LABEL_4:
      uint64_t v11 = *(void *)(a1[5] + 8);
      CFOptionFlags v12 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = 0;

      goto LABEL_5;
    }
    if (!v7)
    {
      double v13 = +[MBError errorWithCode:4, @"No record and no error was returned for record %@", v14 format];
      (*(void (**)(uint64_t, void *))(v10 + 16))(v10, v13);

      goto LABEL_4;
    }
    (*(void (**)(void))(a1[4] + 16))();
    if (!--*(void *)(*(void *)(a1[6] + 8) + 24))
    {
      (*(void (**)(void, void))(*(void *)(*(void *)(a1[5] + 8) + 40) + 16))(*(void *)(*(void *)(a1[5] + 8) + 40), 0);
      goto LABEL_4;
    }
  }
LABEL_5:
}

uint64_t sub_100126FF4(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void))(a1[7] + 16))(a1[7], a1[4], a1[5], a1[6]);
}

void sub_100127284(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001272A0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_100128360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id *location)
{
  _Block_object_dispose((const void *)(v15 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_1001283F0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
    __assert_rtn("-[MBCKBatchFetch _sendBatchFetchOperationForFetchInfos:]_block_invoke", "MBCKBatchFetch.m", 392, "!opFinished");
  }
  if (!v8) {
    __assert_rtn("-[MBCKBatchFetch _sendBatchFetchOperationForFetchInfos:]_block_invoke", "MBCKBatchFetch.m", 393, "recordID");
  }
  uint64_t v10 = v9;
  id v11 = *(id *)(a1 + 32);
  objc_sync_enter(v11);
  CFOptionFlags v12 = [*(id *)(a1 + 32) fetchInfosByRecordID];
  double v13 = [v12 objectForKeyedSubscript:v8];

  if (v13)
  {
    if ([*(id *)(a1 + 32) _handleCompletionForFetchInfo:v13 record:v7 error:v10])
    {
      id v14 = [*(id *)(a1 + 32) fetchInfosByRecordID];
      [v14 removeObjectForKey:v8];
    }
  }
  else if (MBIsInternalInstall())
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
    CFOptionFlags v16 = [WeakRetained operationID];

    long long v17 = MBGetDefaultLog();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      uint64_t v18 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138413058;
      long long v20 = v16;
      __int16 v21 = 2112;
      id v22 = v8;
      __int16 v23 = 2112;
      id v24 = v10;
      __int16 v25 = 2112;
      uint64_t v26 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Received unexpected completion for operationID:%@, recordID:%@, error:%@, fetchInfos:%@", buf, 0x2Au);
      _MBLog();
    }
  }
  objc_sync_exit(v11);
}

void sub_100128614(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100128640(uint64_t a1, void *a2, void *a3)
{
  id v46 = a2;
  id v5 = a3;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  uint64_t v49 = a1;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (!WeakRetained) {
    __assert_rtn("-[MBCKBatchFetch _sendBatchFetchOperationForFetchInfos:]_block_invoke", "MBCKBatchFetch.m", 409, "strongOp");
  }
  uint64_t v6 = MBGetDefaultLog();
  id v7 = v6;
  if (v5)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v8 = [WeakRetained operationID];
      id v9 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138543874;
      id v58 = v8;
      __int16 v59 = 2114;
      uint64_t v60 = v9;
      __int16 v61 = 2112;
      id v62 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Operation %{public}@/%{public}@ failed: %@", buf, 0x20u);

      uint64_t v10 = [WeakRetained operationID];
      long long v42 = *(void **)(a1 + 32);
      id v43 = v5;
      double v40 = v10;
      _MBLog();
LABEL_7:
    }
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = [WeakRetained operationID];
    CFOptionFlags v12 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 138543618;
    id v58 = v11;
    __int16 v59 = 2114;
    uint64_t v60 = v12;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Operation %{public}@/%{public}@ completed", buf, 0x16u);

    uint64_t v10 = [WeakRetained operationID];
    double v40 = v10;
    long long v42 = *(void **)(a1 + 32);
    _MBLog();
    goto LABEL_7;
  }

  id v50 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(*(id *)(a1 + 40), "count"));
  id v47 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(*(id *)(a1 + 40), "count"));
  id obj = *(id *)(a1 + 32);
  objc_sync_enter(obj);
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  id v13 = *(id *)(a1 + 40);
  id v14 = [v13 countByEnumeratingWithState:&v51 objects:v65 count:16];
  if (!v14)
  {

    goto LABEL_50;
  }
  LOBYTE(v15) = 0;
  uint64_t v16 = *(void *)v52;
  do
  {
    for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v52 != v16) {
        objc_enumerationMutation(v13);
      }
      uint64_t v18 = *(void **)(*((void *)&v51 + 1) + 8 * i);
      if (objc_msgSend(v18, "state", v40, v42, v43) == (id)3) {
        goto LABEL_14;
      }
      if ([v18 state] == (id)2)
      {
        if (!v5)
        {
          if (MBIsInternalInstall())
          {
            long long v20 = MBGetDefaultLog();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
            {
              __int16 v21 = v20;
              if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
              {
                uint64_t v45 = [WeakRetained operationID];
                id v22 = [v18 recordID];
                __int16 v23 = [v46 objectForKeyedSubscript:v22];
                uint64_t v24 = *(void *)(v49 + 40);
                *(_DWORD *)buf = 138413058;
                id v58 = v45;
                __int16 v59 = 2112;
                uint64_t v60 = v23;
                __int16 v61 = 2112;
                id v62 = v18;
                __int16 v63 = 2112;
                uint64_t v64 = v24;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "Received unexpected completion for operationID:%@, record:%@, fetchInfo:%@, fetchInfos:%@", buf, 0x2Au);
              }
              __int16 v25 = [WeakRetained operationID];
              uint64_t v26 = [v18 recordID];
              [v46 objectForKeyedSubscript:v26];
              long long v42 = v43 = v18;
              _MBLog();
            }
            v55[0] = @"operationID";
            uint64_t v27 = [WeakRetained operationID];
            v55[1] = @"recordID";
            v56[0] = v27;
            int v28 = [v18 recordID];
            v56[1] = v28;
            id v29 = +[NSDictionary dictionaryWithObjects:v56 forKeys:v55 count:2];

            if (!dword_1004824F8 && !atomic_fetch_add_explicit(&dword_1004824F8, 1u, memory_order_relaxed)) {
              _MBCreateDiagnosticReport(@"CKFetchRecordsOperation completed successfully without invoking perRecordCompletionBlock", v29);
            }
          }
          int v30 = MBGetDefaultLog();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            __int16 v31 = v30;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              id v32 = [WeakRetained operationID];
              *(_DWORD *)buf = 138412546;
              id v58 = v32;
              __int16 v59 = 2112;
              uint64_t v60 = v18;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Received unexpected completion for operationID:%@, fetchInfo:%@", buf, 0x16u);
            }
            long long v41 = [WeakRetained operationID];
            long long v42 = v18;
            _MBLog();
          }
          uint64_t v33 = [WeakRetained operationID];
          id v5 = +[MBError errorWithCode:304, @"Unexpected nil error for operation %@", v33 format];
        }
        if ([*(id *)(v49 + 32) _handleCompletionForFetchInfo:v18 record:0 error:v5])
        {
          uint64_t v34 = [v18 recordID];
          [v47 addObject:v34];

LABEL_14:
          [v50 addObject:v18];
          int v19 = 1;
          goto LABEL_36;
        }
      }
      if ([v18 state] == (id)1)
      {
        [v18 setState:0];
        [v18 setOperationError:v5];
      }
      int v19 = 0;
LABEL_36:
      if (!v5) {
        int v19 = 0;
      }
      if (v15) {
        int v15 = 1;
      }
      else {
        int v15 = v19;
      }
    }
    id v14 = [v13 countByEnumeratingWithState:&v51 objects:v65 count:16];
  }
  while (v14);

  if (v5) {
    int v35 = 0;
  }
  else {
    int v35 = v15;
  }
  if (v35 == 1) {
    __assert_rtn("-[MBCKBatchFetch _sendBatchFetchOperationForFetchInfos:]_block_invoke", "MBCKBatchFetch.m", 458, "!trackError || operationError");
  }
  if (v15) {
    [*(id *)(v49 + 32) setFetchError:v5];
  }
LABEL_50:
  id v36 = objc_msgSend(*(id *)(v49 + 32), "fetchInfosByRecordID", v40);
  [v36 removeObjectsForKeys:v47];

  id v37 = [*(id *)(v49 + 32) fetchInfos];
  [v37 removeObjectsInArray:v50];

  objc_sync_exit(obj);
  atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(v49 + 32) + 8), 0xFFFFFFFF, memory_order_relaxed);
  id v38 = [*(id *)(v49 + 32) fetchSemaphore];
  dispatch_semaphore_signal(v38);

  id v39 = [*(id *)(v49 + 32) fetchGroup];
  dispatch_group_leave(v39);
}

void sub_100128DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id obj)
{
}

uint64_t sub_100128E40(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100128E50(uint64_t a1)
{
}

void sub_100128E58(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  id v8 = a4;
  id v9 = a3;
  id v10 = a2;
  [v7 setObject:v9 forKeyedSubscript:v10];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100128F04(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
}

id sub_100128F20(uint64_t a1)
{
  atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(a1 + 32) + 8), 1u, memory_order_relaxed);
  [*(id *)(a1 + 40) addDatabaseOperation:*(void *)(a1 + 48) policy:*(void *)(a1 + 56)];
  id result = [*(id *)(a1 + 32) canceled];
  if (result)
  {
    id result = [*(id *)(a1 + 48) isCancelled];
    if ((result & 1) == 0)
    {
      CFOptionFlags v3 = MBGetDefaultLog();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        CFUserNotificationRef v4 = [*(id *)(a1 + 48) operationID];
        *(_DWORD *)buf = 138543362;
        id v7 = v4;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Canceling operation %{public}@", buf, 0xCu);

        id v5 = [*(id *)(a1 + 48) operationID];
        _MBLog();
      }
      return [*(id *)(a1 + 48) cancel];
    }
  }
  return result;
}

void sub_100129448(uint64_t a1)
{
  [*(id *)(a1 + 32) _sendBatchFetchOperationForFetchInfos:*(void *)(a1 + 40)];
  CFOptionFlags v3 = [*(id *)(a1 + 32) fetchGroup];
  dispatch_group_leave(v3);
}

void sub_1001299E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100129B14(uint64_t a1)
{
  [*(id *)(a1 + 32) _finishBatchedFetchesWithCompletion:*(void *)(a1 + 40)];
}

void sub_100129D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100129D2C(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to upload modified assets: %@", buf, 0xCu);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

CFStringRef MBStringForAssetType(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 3) {
    return @"unknown";
  }
  else {
    return off_100413DD0[a1 - 1];
  }
}

void sub_10012C30C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10012C328(uint64_t a1)
{
  return [*(id *)(a1 + 32) _cancelDisconnectTimer];
}

void sub_10012C330(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    id v4 = [*(id *)(a1 + 40) transferDrive];
    [v4 cleanUpReceivedFilesDirectory];

    id v5 = +[NSFileManager defaultManager];
    id v13 = 0;
    unsigned __int8 v6 = [v5 removeItemAtPath:@"/var/mobile/Library/Caches/Backup/RFReceiveTemp" error:&v13];
    id v7 = v13;

    if ((v6 & 1) == 0)
    {
      id v8 = MBGetDefaultLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        CFStringRef v15 = @"/var/mobile/Library/Caches/Backup/RFReceiveTemp";
        __int16 v16 = 2112;
        id v17 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to remove %@: %@", buf, 0x16u);
        CFStringRef v11 = @"/var/mobile/Library/Caches/Backup/RFReceiveTemp";
        id v12 = v7;
        _MBLog();
      }
    }
    uint64_t v3 = *(void *)(a1 + 32);
  }
  objc_msgSend(*(id *)(a1 + 40), "_sendDoneMessageWithError:", v3, v11, v12);
  id v9 = MBGetDefaultLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Invalidating the FT session", buf, 2u);
    _MBLog();
  }

  id v10 = [*(id *)(a1 + 40) fileTransferSession];
  [v10 invalidate];
}

void sub_10012C4FC(uint64_t a1)
{
  double v2 = [*(id *)(a1 + 32) transferDrive];
  [v2 cleanUpReceivedFilesDirectory];

  uint64_t v3 = [*(id *)(a1 + 32) completionHandler];

  if (v3)
  {
    id v4 = [*(id *)(a1 + 32) completionHandler];
    v4[2](v4, *(void *)(a1 + 40));

    [*(id *)(a1 + 32) setCompletionHandler:0];
  }
  id v5 = [*(id *)(a1 + 32) delegate];
  [*(id *)(a1 + 32) setDelegate:0];
  if (!v5) {
    __assert_rtn("-[MBTargetDeviceTransferEngine _finishWithError:]_block_invoke", "MBTargetDeviceTransferEngine.m", 205, "delegate");
  }
  unsigned __int8 v6 = [*(id *)(a1 + 32) connection];
  [v5 connection:v6 didFinishDeviceTransferWithError:*(void *)(a1 + 40)];

  if (*(void *)(a1 + 40))
  {
    id v7 = +[MBError loggableDescriptionForError:](MBError, "loggableDescriptionForError:");
    id v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = objc_opt_class();
      uint64_t v10 = *(void *)(a1 + 64);
      uint64_t v11 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138413058;
      uint64_t v16 = v9;
      __int16 v17 = 2048;
      uint64_t v18 = v10;
      __int16 v19 = 2114;
      long long v20 = v7;
      __int16 v21 = 2112;
      uint64_t v22 = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "========== %@ failed after %.3fs: %{public}@: %@", buf, 0x2Au);
      objc_opt_class();
      _MBLog();
    }
  }
  else
  {
    id v7 = MBGetDefaultLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = objc_opt_class();
      uint64_t v13 = *(void *)(a1 + 64);
      *(_DWORD *)buf = 138412546;
      uint64_t v16 = v12;
      __int16 v17 = 2048;
      uint64_t v18 = v13;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "========== %@ finished in %.3fs", buf, 0x16u);
      objc_opt_class();
      _MBLog();
    }
  }

  [*(id *)(a1 + 48) drop];
  id v14 = self;
}

void sub_10012C89C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10012CE00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10012CE2C(uint64_t a1)
{
  id WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v4 = WeakRetained;
    [WeakRetained _cancelDisconnectTimer];
    id WeakRetained = v4;
    unsigned __int8 v2 = atomic_load(v4 + 107);
    if (v2)
    {
      uint64_t v3 = +[MBError errorWithCode:15 format:@"Timed out"];
      [v4 _finishWithError:v3];

      id WeakRetained = v4;
    }
  }
}

void sub_10012DA14(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 112));
  _Unwind_Resume(a1);
}

void sub_10012DA50(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "FT session completion handler called: %@", buf, 0xCu);
      _MBLog();
    }

    [WeakRetained _finishWithError:v3];
  }
}

void sub_10012DB40(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      id v7 = v3;
      __int16 v8 = 2048;
      uint64_t v9 = (int)[v3 linkType];
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "FT session progress handler called with %@, linkType:%ld", buf, 0x16u);
      [v3 linkType];
      _MBLog();
    }

    [WeakRetained _handleFileTransferSessionProgress:v3];
  }
}

void sub_10012DC54(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  uint64_t v9 = a4;
  uint64_t v10 = MBGetDefaultLog();
  uint64_t v11 = v10;
  if (v8)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      uint64_t v14 = objc_opt_class();
      __int16 v15 = 2112;
      id v16 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to handle %@: %@", buf, 0x16u);
      objc_opt_class();
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v14 = (uint64_t)v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Received %@", buf, 0xCu);
    goto LABEL_6;
  }

  atomic_store(1u, (unsigned __int8 *)(*(void *)(a1 + 32) + 110));
  uint64_t v12 = objc_opt_new();
  v9[2](v9, v12, 0);

  [*(id *)(a1 + 32) cancel];
}

id sub_10012DE14(uint64_t a1)
{
  return _[*(id *)(a1 + 32) startListeningForFileTransfers];
}

void sub_10012E5B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012E5E4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10012E5F4(uint64_t a1)
{
}

void sub_10012E5FC(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  id v14 = *(id *)(v3 + 40);
  unsigned __int8 v4 = [v2 _handleCompletionWithError:&v14];
  objc_storeStrong((id *)(v3 + 40), v14);
  if (v4)
  {
    id v5 = [*(id *)(a1 + 32) peerInitResponse];
    if (v5)
    {
      unsigned __int8 v6 = dispatch_get_global_queue(17, 0);
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      void v10[2] = sub_10012E758;
      v10[3] = &unk_100413E98;
      void v10[4] = *(void *)(a1 + 32);
      long long v13 = *(_OWORD *)(a1 + 48);
      id v11 = v5;
      id v12 = *(id *)(a1 + 40);
      dispatch_async(v6, v10);
    }
    else
    {
      uint64_t v7 = +[MBError errorWithCode:1 format:@"nil init response"];
      uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
      uint64_t v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    }
  }
  else
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void sub_10012E758(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  uint64_t v7[2] = sub_10012E82C;
  void v7[3] = &unk_100413E70;
  uint64_t v9 = *(void *)(a1 + 64);
  void v7[4] = v3;
  id v8 = *(id *)(a1 + 40);
  uint64_t v4 = [v3 _perform:v7];
  uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8);
  unsigned __int8 v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

BOOL sub_10012E82C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a1 + 32) _requestPreflightWithSourceInfo:*(void *)(a1 + 40) error:a2];
  uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) != 0;
}

void sub_10012E888(uint64_t a1)
{
  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)
    && !*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
  {
    __assert_rtn("-[MBTargetDeviceTransferEngine startPreflightWithCompletion:]_block_invoke_4", "MBTargetDeviceTransferEngine.m", 531, "preflightResponse || error");
  }
  uint64_t v3 = MBFreeDiskSpace();
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  uint64_t v5 = MBGetDefaultLog();
  unsigned __int8 v6 = v5;
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      *(_DWORD *)buf = 134218242;
      uint64_t v40 = v3;
      __int16 v41 = 2112;
      id v42 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed preflight (freeDiskSpace:%llu): %@", buf, 0x16u);
      _MBLog();
    }

    (*(void (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0);
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v40 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished preflight (freeDiskSpace:%llu)", buf, 0xCu);
      uint64_t v31 = v3;
      _MBLog();
    }

    [*(id *)(a1 + 32) setPeerPreflightResponse:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
    id v8 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) uploadFileCount];
    id v9 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) uploadSize];
    id v10 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) uploadSizeExcludingHardlinksAndClones];
    if (v10) {
      id v11 = v10;
    }
    else {
      id v11 = v9;
    }
    id v12 = objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), "purgeableDiskSpace", v31);
    long long v13 = MBGetDefaultLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134219008;
      uint64_t v40 = (uint64_t)v8;
      __int16 v41 = 2048;
      id v42 = v9;
      __int16 v43 = 2048;
      id v44 = v11;
      __int16 v45 = 2048;
      id v46 = v12;
      __int16 v47 = 2048;
      uint64_t v48 = v3;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "uploadFileCount:%llu, uploadSize:%llu(%llu), sourcePurgeableSpaceSize:%llu, freeDiskSpace:%llu", buf, 0x34u);
      id v35 = v12;
      uint64_t v36 = v3;
      id v33 = v9;
      id v34 = v11;
      id v32 = v8;
      _MBLog();
    }

    id v14 = objc_opt_new();
    [v14 setSourceDeviceDataSize:v11];
    [v14 setTargetDeviceFreeSpaceSize:v3];
    [v14 setSourcePurgeableSpaceSize:v12];
    uint64_t v15 = *(void *)(*(void *)(a1 + 56) + 8);
    id v16 = *(void **)(v15 + 40);
    *(void *)(v15 + 40) = 0;

    __int16 v17 = *(void **)(a1 + 32);
    uint64_t v18 = *(void *)(*(void *)(a1 + 56) + 8);
    id obj = *(id *)(v18 + 40);
    unsigned __int8 v19 = [v17 _checkFreeDiskSpace:v3 preflightInfo:v14 error:&obj];
    objc_storeStrong((id *)(v18 + 40), obj);
    if ((v19 & 1) == 0)
    {
      uint64_t v20 = *(void *)(*(void *)(a1 + 56) + 8);
      __int16 v21 = *(void **)(v20 + 40);
      *(void *)(v20 + 40) = 0;
    }
    uint64_t v22 = objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), "propertiesData", v32, v33, v34, v35, v36);
    if (v22)
    {
      id v37 = 0;
      __int16 v23 = [[MBProperties alloc] initWithData:v22 error:&v37];
      uint64_t v24 = v37;
      __int16 v25 = MBGetDefaultLog();
      uint64_t v26 = v25;
      if (v23)
      {
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v40 = (uint64_t)v23;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Deserialized preflight properties: %@", buf, 0xCu);
          _MBLog();
        }

        uint64_t v26 = [(MBProperties *)v23 activeAppleID];
        uint64_t v27 = MBGetDefaultLog();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v40 = (uint64_t)v26;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Found activeAppleID: %@", buf, 0xCu);
          _MBLog();
        }

        int v28 = [(MBProperties *)v23 appleIDs];
        id v29 = MBGetDefaultLog();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v40 = (uint64_t)v28;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Found appleIDs: %@", buf, 0xCu);
          _MBLog();
        }

        [v14 setActiveAppleID:v26];
        [v14 setAppleIDs:v28];
      }
      else if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v40 = (uint64_t)v24;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to deserialize preflight properties: %@", buf, 0xCu);
        _MBLog();
      }
    }
    else
    {
      uint64_t v24 = MBGetDefaultLog();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = objc_opt_class();
        *(_DWORD *)buf = 138412290;
        uint64_t v40 = v30;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Not preflight properties found on %@", buf, 0xCu);
        objc_opt_class();
        _MBLog();
      }
    }

    [*(id *)(a1 + 32) setPeerPreflightInfo:v14];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40));
  }
}

void sub_10012F0E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10012F100(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  id v14 = *(id *)(v3 + 40);
  unsigned __int8 v4 = [v2 _handleCompletionWithError:&v14];
  objc_storeStrong((id *)(v3 + 40), v14);
  if (v4)
  {
    uint64_t v5 = [*(id *)(a1 + 32) peerInitResponse];
    if (v5)
    {
      unsigned __int8 v6 = dispatch_get_global_queue(17, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10012F250;
      block[3] = &unk_100411B38;
      void block[4] = *(void *)(a1 + 32);
      long long v11 = *(_OWORD *)(a1 + 40);
      id v7 = (id)v11;
      long long v13 = v11;
      dispatch_async(v6, block);
    }
    else
    {
      uint64_t v8 = +[MBError errorWithCode:1 format:@"nil init response"];
      uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
      id v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v8;

      dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    }
  }
  else
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void sub_10012F250(uint64_t a1)
{
  v13[0] = 0;
  v13[1] = v13;
  void v13[2] = 0x3032000000;
  v13[3] = sub_10012E5E4;
  _DWORD v13[4] = sub_10012E5F4;
  id v14 = 0;
  uint64_t v3 = *(void **)(a1 + 32);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_10012F3E4;
  uint64_t v12[3] = &unk_100413EC0;
  void v12[4] = v3;
  void v12[5] = v13;
  uint64_t v4 = [v3 _perform:v12];
  uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
  unsigned __int8 v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
    id v7 = *(void **)(a1 + 32);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10012F464;
    v11[3] = &unk_100413AE8;
    void v11[4] = v7;
    v11[5] = v13;
    uint64_t v8 = [v7 _perform:v11];
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    id v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  _Block_object_dispose(v13, 8);
}

void sub_10012F3CC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

BOOL sub_10012F3E4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = [v4 peerInitResponse];
  uint64_t v6 = [v4 _requestKeychainWithSourceInfo:v5 error:a2];
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) != 0;
}

id sub_10012F464(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _restoreKeychainWithKeychainTransferResponse:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) error:a2];
}

void sub_10012F47C(uint64_t a1)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  uint64_t v4 = MBGetDefaultLog();
  uint64_t v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
      *(_DWORD *)buf = 138412290;
      uint64_t v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed keychain transfer: %@", buf, 0xCu);
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished keychain transfer", buf, 2u);
    goto LABEL_6;
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_10012F89C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_10012F8C8(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  id v16 = *(id *)(v3 + 40);
  unsigned __int8 v4 = [v2 _handleCompletionWithError:&v16];
  objc_storeStrong((id *)(v3 + 40), v16);
  if (v4)
  {
    uint64_t v5 = [*(id *)(a1 + 32) peerInitResponse];
    if (v5)
    {
      uint64_t v6 = dispatch_get_global_queue(17, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10012FA20;
      block[3] = &unk_100413F10;
      uint64_t v7 = *(void *)(a1 + 56);
      void block[4] = *(void *)(a1 + 32);
      uint64_t v15 = v7;
      long long v12 = *(_OWORD *)(a1 + 40);
      id v8 = (id)v12;
      long long v14 = v12;
      dispatch_async(v6, block);
    }
    else
    {
      uint64_t v9 = +[MBError errorWithCode:1 format:@"nil init response"];
      uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
      long long v11 = *(void **)(v10 + 40);
      *(void *)(v10 + 40) = v9;

      dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    }
  }
  else
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void sub_10012FA20(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_10012FAD0;
  v8[3] = &unk_100413EC0;
  uint64_t v4 = *(void *)(a1 + 56);
  void v8[4] = v3;
  void v8[5] = v4;
  uint64_t v5 = [v3 _perform:v8];
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

BOOL sub_10012FAD0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = [v4 peerInitResponse];
  uint64_t v6 = [v4 _requestKeychainWithSourceInfo:v5 error:a2];
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) != 0;
}

void sub_10012FB50(uint64_t a1)
{
  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)
    && !*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
  {
    __assert_rtn("-[MBTargetDeviceTransferEngine startKeychainDataTransferWithCompletion:]_block_invoke_4", "MBTargetDeviceTransferEngine.m", 672, "keychainTransferResponse || error");
  }
  uint64_t v3 = MBFreeDiskSpace();
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  uint64_t v5 = MBGetDefaultLog();
  uint64_t v6 = v5;
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      *(_DWORD *)buf = 134218242;
      uint64_t v11 = v3;
      __int16 v12 = 2112;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed keychain data transfer (freeDiskSpace:%llu): %@", buf, 0x16u);
      _MBLog();
    }

    id v8 = 0;
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
      *(_DWORD *)buf = 134218242;
      uint64_t v11 = v3;
      __int16 v12 = 2112;
      uint64_t v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished keychain data transfer (freeDiskSpace:%llu): %@", buf, 0x16u);
      _MBLog();
    }

    [*(id *)(a1 + 32) setPeerKeychainTransferResponse:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
    id v8 = objc_opt_new();
    [*(id *)(a1 + 32) setPeerKeychainInfo:v8];
  }
  (*(void (**)(void, void *))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v8);
}

void sub_100130040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100130060(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  id obj = *(id *)(v3 + 40);
  unsigned __int8 v4 = [v2 _handleCompletionWithError:&obj];
  objc_storeStrong((id *)(v3 + 40), obj);
  if ((v4 & 1) == 0)
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    return;
  }
  uint64_t v5 = [*(id *)(a1 + 32) peerInitResponse];
  uint64_t v6 = [*(id *)(a1 + 32) peerKeychainTransferResponse];
  uint64_t v7 = [*(id *)(a1 + 32) peerKeychainInfo];
  id v8 = (void *)v7;
  if (!v5)
  {
    CFStringRef v14 = @"nil init response";
LABEL_13:
    uint64_t v15 = +[MBError errorWithCode:format:](MBError, "errorWithCode:format:", 1, v14, v21, v22);
    uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8);
    __int16 v17 = *(void **)(v16 + 40);
    *(void *)(v16 + 40) = v15;

    goto LABEL_14;
  }
  if (!v6)
  {
    CFStringRef v14 = @"nil keychain data transfer response";
    goto LABEL_13;
  }
  if (!v7)
  {
    CFStringRef v14 = @"nil keychain info";
    goto LABEL_13;
  }
  uint64_t v9 = [*(id *)(a1 + 48) uuid];
  uint64_t v10 = [v8 uuid];
  unsigned __int8 v11 = [v9 isEqualToString:v10];

  if ((v11 & 1) == 0)
  {
    __int16 v12 = MBGetDefaultLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138412546;
      uint64_t v29 = v13;
      __int16 v30 = 2112;
      uint64_t v31 = v8;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid keychain info: %@ != %@", buf, 0x16u);
      uint64_t v21 = *(void *)(a1 + 48);
      uint64_t v22 = v8;
      _MBLog();
    }

    CFStringRef v14 = @"Invalid keychain info";
    goto LABEL_13;
  }
LABEL_14:
  uint64_t v18 = *(void *)(a1 + 56);
  if (*(void *)(*(void *)(v18 + 8) + 40))
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
  else
  {
    unsigned __int8 v19 = dispatch_get_global_queue(17, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100130328;
    block[3] = &unk_100413F88;
    uint64_t v20 = *(void *)(a1 + 32);
    uint64_t v26 = v18;
    void block[4] = v20;
    id v24 = v6;
    id v25 = *(id *)(a1 + 40);
    dispatch_async(v19, block);
  }
}

void sub_100130328(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  uint64_t v7[2] = sub_1001303F4;
  void v7[3] = &unk_100413F60;
  void v7[4] = v3;
  id v8 = *(id *)(a1 + 40);
  uint64_t v4 = [v3 _perform:v7];
  uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

id sub_1001303F4(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _restoreKeychainWithKeychainTransferResponse:*(void *)(a1 + 40) error:a2];
}

void sub_100130404(uint64_t a1)
{
  uint64_t v3 = MBFreeDiskSpace();
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  uint64_t v5 = MBGetDefaultLog();
  uint64_t v6 = v5;
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
      *(_DWORD *)buf = 134218242;
      uint64_t v9 = v3;
      __int16 v10 = 2112;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed keychain data import (freeDiskSpace:%llu): %@", buf, 0x16u);
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished keychain data import (freeDiskSpace:%llu)", buf, 0xCu);
    goto LABEL_6;
  }

  (*(void (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
}

void sub_100130858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_100130878(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  id v15 = *(id *)(v3 + 40);
  unsigned __int8 v4 = [v2 _handleCompletionWithError:&v15];
  objc_storeStrong((id *)(v3 + 40), v15);
  if (v4)
  {
    [*(id *)(a1 + 32) _disableInfraWiFi];
    uint64_t v5 = dispatch_get_global_queue(17, 0);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    void v10[2] = sub_100130990;
    v10[3] = &unk_100413FD8;
    uint64_t v7 = *(void **)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    void v10[4] = *(void *)(a1 + 32);
    uint64_t v13 = v6;
    id v8 = v7;
    uint64_t v9 = *(void *)(a1 + 64);
    id v11 = v8;
    uint64_t v14 = v9;
    id v12 = *(id *)(a1 + 40);
    dispatch_async(v5, v10);
  }
  else
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void sub_100130990(uint64_t a1)
{
  uint64_t v3 = [*(id *)(a1 + 32) peerInitResponse];
  uint64_t v4 = [*(id *)(a1 + 32) peerPreflightInfo];
  uint64_t v5 = (void *)v4;
  if (!v3)
  {
    CFStringRef v14 = @"nil init response";
LABEL_12:
    uint64_t v17 = +[MBError errorWithCode:format:](MBError, "errorWithCode:format:", 1, v14, v29, v30);
    uint64_t v18 = *(void *)(*(void *)(a1 + 56) + 8);
    unsigned __int8 v19 = *(void **)(v18 + 40);
    *(void *)(v18 + 40) = v17;

    goto LABEL_13;
  }
  if (!v4)
  {
    CFStringRef v14 = @"nil preflight info";
    goto LABEL_12;
  }
  uint64_t v6 = [*(id *)(a1 + 40) uuid];
  uint64_t v7 = [v5 uuid];
  unsigned __int8 v8 = [v6 isEqualToString:v7];

  if ((v8 & 1) == 0)
  {
    id v15 = MBGetDefaultLog();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412546;
      uint64_t v38 = v16;
      __int16 v39 = 2112;
      uint64_t v40 = v5;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid preflight info: %@ != %@", buf, 0x16u);
      uint64_t v29 = *(void *)(a1 + 40);
      __int16 v30 = v5;
      _MBLog();
    }

    CFStringRef v14 = @"Invalid preflight info";
    goto LABEL_12;
  }
  uint64_t v9 = *(void **)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 64);
  id v36 = 0;
  unsigned __int8 v11 = [v9 _checkFreeDiskSpace:v10 preflightInfo:v5 error:&v36];
  id v12 = v36;
  id v13 = v36;
  if ((v11 & 1) == 0) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), v12);
  }

LABEL_13:
  if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  }
  else
  {
    uint64_t v20 = *(void **)(a1 + 32);
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472;
    void v33[2] = sub_100130CE8;
    v33[3] = &unk_100413FB0;
    v33[4] = v20;
    id v21 = v3;
    id v34 = v21;
    id v35 = v5;
    uint64_t v22 = [v20 _perform:v33];
    uint64_t v23 = *(void *)(*(void *)(a1 + 56) + 8);
    id v24 = *(void **)(v23 + 40);
    *(void *)(v23 + 40) = v22;

    if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
    {
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
    }
    else
    {
      id v25 = *(void **)(a1 + 32);
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472;
      v31[2] = sub_100130CFC;
      uint64_t v31[3] = &unk_100413F60;
      v31[4] = v25;
      id v32 = v21;
      uint64_t v26 = [v25 _perform:v31];
      uint64_t v27 = *(void *)(*(void *)(a1 + 56) + 8);
      int v28 = *(void **)(v27 + 40);
      *(void *)(v27 + 40) = v26;

      dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
    }
  }
}

id sub_100130CE8(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _requestBackupWithSourceInfo:*(void *)(a1 + 40) preflightInfo:*(void *)(a1 + 48) error:a2];
}

id sub_100130CFC(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) _restoreWithSourceInfo:*(void *)(a1 + 40) error:a2];
}

void sub_100130D0C(uint64_t a1)
{
  unint64_t v3 = MBFreeDiskSpace();
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  uint64_t v5 = MBGetDefaultLog();
  uint64_t v6 = v5;
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
      *(_DWORD *)buf = 134218242;
      unint64_t v14 = v3;
      __int16 v15 = 2112;
      uint64_t v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed data transfer (freeDiskSpace:%llu): %@", buf, 0x16u);
      unint64_t v10 = v3;
      uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    unint64_t v14 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished data transfer (freeDiskSpace:%llu)", buf, 0xCu);
    unint64_t v10 = v3;
    goto LABEL_6;
  }

  if (MBIsInternalInstall()
    && v3 >> 30 <= 6
    && !dword_100482510
    && !atomic_fetch_add_explicit(&dword_100482510, 1u, memory_order_relaxed))
  {
    unsigned __int8 v8 = MBGetDefaultLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      unint64_t v14 = v3;
      __int16 v15 = 2048;
      uint64_t v16 = 0x1C0000000;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "Unexpected free disk space left on target after transfer(%llu < %llu)", buf, 0x16u);
      unint64_t v10 = v3;
      uint64_t v11 = 0x1C0000000;
      _MBLog();
    }
  }
  uint64_t v9 = objc_msgSend(*(id *)(a1 + 32), "queue", v10, v11);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100130FBC;
  block[3] = &unk_100411128;
  void block[4] = *(void *)(a1 + 32);
  dispatch_async(v9, block);

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  [*(id *)(a1 + 32) _finishWithError:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
}

id sub_100130FBC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _enableInfraWiFi];
}

void sub_10013150C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100131524(uint64_t a1)
{
  unsigned __int8 v2 = objc_opt_new();
  id v6 = 0;
  unsigned __int8 v3 = [v2 holdWithError:&v6];
  id v4 = v6;
  if ((v3 & 1) == 0)
  {

    unsigned __int8 v2 = 0;
  }
  [*(id *)(a1 + 32) setDeviceLockAssertion:v2];

  return 1;
}

BOOL sub_1001315A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a1 + 32) _requestInitWithError:a2];
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) != 0;
}

id sub_10013175C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _start];
}

void sub_100131EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_100131F5C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned __int8 v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v12 = v5;

  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  unint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
  id v11 = v6;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100132574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1001325BC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned __int8 v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v12 = v5;

  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  unint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
  id v11 = v6;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100132B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_100132B88(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned __int8 v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v12 = v5;

  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  unint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
  id v11 = v6;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10013384C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *location, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  _Block_object_dispose((const void *)(v28 - 176), 8);
  objc_destroyWeak(location);
  objc_destroyWeak(&a28);
  _Unwind_Resume(a1);
}

void sub_1001338B4(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = WeakRetained;
  if (WeakRetained)
  {
    id v5 = [WeakRetained peerPreflightResponse];
    *(void *)(a2 + 16) = [v5 uploadFileCount];

    id v6 = [v4 peerPreflightResponse];
    *(void *)(a2 + 24) = [v6 uploadSize];

    uint64_t v7 = [v4 progressModel];
    long long v8 = *(_OWORD *)(a2 + 16);
    v9[0] = *(_OWORD *)a2;
    v9[1] = v8;
    [v7 updateTotalProgressWithPhase:3 transferInfo:v9];
  }
}

void sub_100133958(uint64_t a1, int a2, id obj)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), obj);
  id v5 = obj;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001344D8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = MBGetDefaultLog();
  long long v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      id v11 = v9;
      __int16 v12 = 2112;
      id v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to send %@: %@", buf, 0x16u);
      _MBLog();
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received %@", buf, 0xCu);
      _MBLog();
    }

    atomic_store(1u, (unsigned __int8 *)(*(void *)(a1 + 40) + 109));
    [*(id *)(a1 + 40) _stopTrackingPeerConnectionStatus];
  }
  atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 40) + 108));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_1001348E8(void *a1)
{
  uint64_t v3 = [[MBPeerRestoreProgressRequest alloc] initWithPercentage:a1[6]];
  dispatch_semaphore_t v4 = dispatch_semaphore_create(0);
  uint64_t v5 = a1[4];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_100134AB8;
  uint64_t v12[3] = &unk_1004140F0;
  id v6 = v3;
  uint64_t v7 = a1[5];
  id v13 = v6;
  uint64_t v14 = v7;
  long long v8 = v4;
  __int16 v15 = v8;
  +[MBPeerMessenger sendRequest:v6 session:v5 responseHandler:v12];
  dispatch_time_t v9 = dispatch_time(0, 30000000000);
  if (dispatch_semaphore_wait(v8, v9))
  {
    unint64_t v10 = MBGetDefaultLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = objc_opt_class();
      *(_DWORD *)buf = 138412290;
      uint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Timed out waiting for %@", buf, 0xCu);
      objc_opt_class();
      _MBLog();
    }
  }
}

void sub_100134AB8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = MBGetDefaultLog();
  long long v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      dispatch_time_t v9 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      id v11 = v9;
      __int16 v12 = 2112;
      id v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to send %@: %@", buf, 0x16u);
LABEL_6:
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Received %@", buf, 0xCu);
    goto LABEL_6;
  }

  atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 40) + 111));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_100134CFC(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) delegate];
  unsigned __int8 v2 = [*(id *)(a1 + 32) connection];
  [v3 connection:v2 didUpdateDeviceTransferProgress:*(void *)(a1 + 40)];
}

void sub_100136308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose((const void *)(v39 - 176), 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Unwind_Resume(a1);
}

id sub_100136368(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 deleted])
  {
    id v4 = 0;
    goto LABEL_26;
  }
  uint64_t v5 = [*(id *)(a1 + 32) parentEngine];
  if (!v5) {
    __assert_rtn("-[MBCKRestoreDomainEngine cleanUpAfterError:]_block_invoke", "MBCKRestoreDomainEngine.m", 107, "parentEngine");
  }
  id v6 = (void *)v5;
  [v3 setupWithDomain:*(void *)(a1 + 40)];
  uint64_t v7 = [*(id *)(a1 + 32) restorePolicy];
  id v26 = 0;
  unsigned __int8 v8 = [v7 shouldRestoreFile:v3 markFileAsSkipped:0 error:&v26];
  id v9 = v26;

  if ((v8 & 1) == 0)
  {
    if (v9)
    {
      if (+[MBError isError:v9 withCode:213])
      {
        id v4 = 0;
        id v13 = v9;
      }
      else
      {
        unsigned __int8 v19 = MBGetDefaultLog();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          id v28 = v3;
          __int16 v29 = 2112;
          id v30 = v9;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to determine if file %@ should be cleaned up after error: %@", buf, 0x16u);
          _MBLog();
        }

        id v13 = v9;
        id v4 = v13;
      }
    }
    else
    {
      id v13 = 0;
      id v4 = 0;
    }
    goto LABEL_25;
  }
  unint64_t v10 = [*(id *)(a1 + 32) restorePolicy];
  id v11 = [v10 destinationPathForRestorable:v3 safeHarborDir:0];

  id v25 = v9;
  unsigned __int8 v12 = [v3 removeFailedAssetFromDestination:v11 withError:&v25];
  id v13 = v25;

  if (v12)
  {
    if ([v3 isDirectory])
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8);
      uint64_t v15 = *(void *)(v14 + 24) + 1;
      *(void *)(v14 + 24) = v15;
      if (__ROR8__(0xD288CE703AFB7E91 * v15, 4) <= 0x68DB8BAC710CBuLL)
      {
        uint64_t v16 = MBGetDefaultLog();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = *(void **)(a1 + 48);
          uint64_t v18 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
          *(_DWORD *)buf = 134218242;
          id v28 = v18;
          __int16 v29 = 2114;
          id v30 = v17;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "=ckdomain-engine= Removed %llu dirs for %{public}@", buf, 0x16u);
LABEL_21:
          _MBLog();
          goto LABEL_22;
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v20 = *(void *)(*(void *)(a1 + 64) + 8);
      uint64_t v21 = *(void *)(v20 + 24) + 1;
      *(void *)(v20 + 24) = v21;
      if (__ROR8__(0xD288CE703AFB7E91 * v21, 4) <= 0x68DB8BAC710CBuLL)
      {
        uint64_t v16 = MBGetDefaultLog();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
          uint64_t v23 = *(void **)(a1 + 48);
          *(_DWORD *)buf = 134218242;
          id v28 = v22;
          __int16 v29 = 2114;
          id v30 = v23;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "=ckdomain-engine= Removed %llu files for %{public}@", buf, 0x16u);
          goto LABEL_21;
        }
LABEL_22:
      }
    }
    id v4 = 0;
    goto LABEL_24;
  }
  id v4 = v13;
LABEL_24:

LABEL_25:
LABEL_26:

  return v4;
}

uint64_t sub_100136758(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100136768(uint64_t a1)
{
}

BOOL sub_100136770(uint64_t a1)
{
  uint64_t v2 = (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
}

BOOL sub_1001367CC(uint64_t a1)
{
  uint64_t v2 = (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
}

void sub_100136AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100136AFC(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  return result;
}

id sub_100136E60(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) setUpWithError:a2];
}

id sub_100136E6C(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) restoreFilesWithError:a2];
}

id sub_100136E78(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) finalizeRestoredDomainWithError:a2];
}

void sub_100138160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose((const void *)(v65 - 208), 8);
  _Block_object_dispose(&a53, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose((const void *)(v65 - 176), 8);
  _Unwind_Resume(a1);
}

id sub_100138204(uint64_t a1, void *a2)
{
  id v52 = a2;
  uint64_t v3 = [*(id *)(a1 + 32) debugContext];
  unsigned int v4 = [v3 isFlagSet:@"SimulateProcessBatchErrorDuringDomainRestore"];

  if (v4)
  {
    uint64_t v5 = +[NSError errorWithDomain:CKErrorDomain code:4 userInfo:0];
  }
  else
  {
    id v53 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v52, "count"));
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    id v6 = v52;
    id v7 = [v6 countByEnumeratingWithState:&v86 objects:v102 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v87;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v87 != v8) {
            objc_enumerationMutation(v6);
          }
          uint64_t v10 = *(void *)(*((void *)&v86 + 1) + 8 * i);
          id v11 = objc_alloc((Class)CKRecordID);
          unsigned __int8 v12 = [*(id *)(a1 + 40) defaultZoneID];
          id v13 = [v11 initWithRecordName:v10 zoneID:v12];

          id v14 = [objc_alloc((Class)CKReference) initWithRecordID:v13 action:0];
          [v53 addObject:v14];
        }
        id v7 = [v6 countByEnumeratingWithState:&v86 objects:v102 count:16];
      }
      while (v7);
    }

    uint64_t v15 = +[NSPredicate predicateWithFormat:@"recordID IN %@", v53];
    id v16 = objc_alloc((Class)CKQuery);
    uint64_t v17 = +[MBCKModel privilegedQueryType];
    id v51 = [v16 initWithRecordType:v17 predicate:v15];

    id v18 = [objc_alloc((Class)CKQueryOperation) initWithQuery:v51];
    unsigned __int8 v19 = [*(id *)(a1 + 40) defaultZoneID];
    [v18 setZoneID:v19];

    uint64_t v20 = [*(id *)(a1 + 32) persona];
    LODWORD(v16) = [v20 shouldRestoreFilesSparse];

    if (v16)
    {
      uint64_t v21 = objc_opt_new();
      [v21 setSparseAware:&__kCFBooleanTrue];
      CFStringRef v100 = @"contents";
      unsigned __int8 v101 = v21;
      uint64_t v22 = +[NSDictionary dictionaryWithObjects:&v101 forKeys:&v100 count:1];
      [v18 setAssetTransferOptionsByKey:v22];
    }
    uint64_t v23 = objc_opt_new();
    objc_initWeak(&location, v18);
    uint64_t v81 = 0;
    uint64_t v82 = &v81;
    uint64_t v83 = 0x2020000000;
    uint64_t v84 = 0;
    uint64_t v77 = 0;
    id v78 = &v77;
    uint64_t v79 = 0x2020000000;
    uint64_t v80 = 0;
    uint64_t v73 = 0;
    dispatch_time_t v74 = (double *)&v73;
    uint64_t v75 = 0x2020000000;
    unint64_t v76 = 0xBFF0000000000000;
    dispatch_semaphore_t v24 = dispatch_semaphore_create(10);
    id v25 = dispatch_group_create();
    dispatch_group_enter(v25);
    v61[0] = _NSConcreteStackBlock;
    v61[1] = 3221225472;
    v61[2] = sub_100138A34;
    v61[3] = &unk_100414198;
    long long v69 = &v73;
    long long v70 = &v81;
    uint64_t v71 = *(void *)(a1 + 72);
    id v26 = v23;
    uint64_t v27 = *(void *)(a1 + 32);
    id v62 = v26;
    uint64_t v63 = v27;
    CFStringRef v72 = &v77;
    id v64 = *(id *)(a1 + 48);
    id v65 = *(id *)(a1 + 40);
    id v28 = v24;
    long long v66 = v28;
    __int16 v29 = v25;
    char v67 = v29;
    id v68 = *(id *)(a1 + 56);
    [v18 setRecordFetchedBlock:v61];
    v54[0] = _NSConcreteStackBlock;
    v54[1] = 3221225472;
    v54[2] = sub_100139094;
    v54[3] = &unk_1004141C0;
    objc_copyWeak(&v60, &location);
    id v30 = (void *)v15;
    __int16 v59 = &v81;
    id v55 = v6;
    id v56 = *(id *)(a1 + 64);
    id v31 = v26;
    id v57 = v31;
    id v32 = v29;
    id v58 = v32;
    [v18 setQueryCompletionBlock:v54];
    +[NSDate timeIntervalSinceReferenceDate];
    double v34 = v33;
    [*(id *)(a1 + 40) addDatabaseOperation:v18];
    MBGroupWaitForever();
    double v35 = v74[3];
    double v36 = -1.0;
    if (v34 >= v35) {
      double v37 = -1.0;
    }
    else {
      double v37 = v35 - v34;
    }
    if (v37 > 0.0) {
      double v36 = (double)(unint64_t)v78[3] / v37 / 1000000.0;
    }
    uint64_t v38 = MBGetDefaultLog();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      uint64_t v39 = *(void *)(a1 + 64);
      uint64_t v40 = (void *)v82[3];
      uint64_t v41 = v78[3];
      *(_DWORD *)buf = 138413314;
      uint64_t v91 = v39;
      __int16 v92 = 2048;
      id v93 = v40;
      __int16 v94 = 2048;
      uint64_t v95 = v41;
      __int16 v96 = 2048;
      double v97 = v37;
      __int16 v98 = 2048;
      double v99 = v36;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, "=ckdomain-engine= Finished download batch for %@ (%lu, %llu) in %.3fs at %.3fMB/s", buf, 0x34u);
      _MBLog();
    }

    if ([v31 count])
    {
      id v42 = MBGetDefaultLog();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        __int16 v43 = v42;
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          uint64_t v44 = *(void *)(a1 + 64);
          id v45 = [v53 count];
          uint64_t v46 = v78[3];
          *(_DWORD *)buf = 138413058;
          uint64_t v91 = v44;
          __int16 v92 = 2048;
          id v93 = v45;
          __int16 v94 = 2048;
          uint64_t v95 = v46;
          __int16 v96 = 2112;
          double v97 = *(double *)&v31;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to download batch for %@ (%lu, %llu): %@", buf, 0x2Au);
          id v30 = (void *)v15;
        }

        [v53 count];
        _MBLog();
      }

      uint64_t v5 = +[MBError errorWithErrors:v31];
    }
    else
    {
      uint64_t v47 = objc_opt_new();
      uint64_t v48 = *(void *)(*(void *)(a1 + 80) + 8);
      uint64_t v49 = *(void **)(v48 + 40);
      *(void *)(v48 + 40) = v47;

      uint64_t v5 = 0;
    }

    objc_destroyWeak(&v60);
    _Block_object_dispose(&v73, 8);
    _Block_object_dispose(&v77, 8);
    _Block_object_dispose(&v81, 8);
    objc_destroyWeak(&location);
  }
  return v5;
}

void sub_1001389BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,id location)
{
  objc_destroyWeak(v56);
  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a48, 8);
  _Block_object_dispose(&a52, 8);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100138A34(uint64_t a1, void *a2)
{
  id v3 = a2;
  +[NSDate timeIntervalSinceReferenceDate];
  *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = v4;
  ++*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
  uint64_t v5 = *(void **)(*(void *)(*(void *)(a1 + 104) + 8) + 40);
  id v6 = [v3 recordID];
  id v7 = [v6 recordName];
  uint64_t v8 = [v5 objectForKeyedSubscript:v7];

  id v9 = *(void **)(*(void *)(*(void *)(a1 + 104) + 8) + 40);
  uint64_t v10 = [v3 recordID];
  id v11 = [v10 recordName];
  [v9 removeObjectForKey:v11];

  if (!v8)
  {
    uint64_t v21 = MBGetDefaultLog();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      double v34 = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to find file to restore: %@", buf, 0xCu);
      _MBLog();
    }

    id v22 = *(id *)(a1 + 32);
    objc_sync_enter(v22);
    uint64_t v23 = *(void **)(a1 + 32);
    dispatch_semaphore_t v24 = +[MBError errorWithCode:4, @"Failed to find file to restore: %@", 0 format];
    [v23 addObject:v24];

    objc_sync_exit(v22);
    goto LABEL_12;
  }
  if (([*(id *)(a1 + 40) isCanceled] & 1) == 0)
  {
    [v8 refreshWithRecord:v3];
    unsigned __int8 v12 = (char *)[v8 size];
    id v13 = &v12[(void)[v8 resourcesSize]];
    *(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 24) += v13;
    uint64_t v14 = *(void *)(a1 + 48);
    uint64_t v15 = *(void *)(a1 + 56);
    id v16 = [*(id *)(a1 + 40) cache];
    uint64_t v17 = [*(id *)(a1 + 40) device];
    id v32 = 0;
    LOBYTE(v15) = [v8 stashAssetsToTemporaryDirectoryWithAccount:v14 operationTracker:v15 cache:v16 device:v17 error:&v32];
    id v18 = v32;

    if (v15)
    {
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 64), 0xFFFFFFFFFFFFFFFFLL);
      unsigned __int8 v19 = *(NSObject **)(a1 + 72);
      uint64_t v20 = *(NSObject **)(a1 + 80);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100138E34;
      block[3] = &unk_100412AD8;
      void block[4] = *(void *)(a1 + 40);
      id v28 = v8;
      id v29 = *(id *)(a1 + 32);
      id v31 = v13;
      id v30 = *(id *)(a1 + 64);
      dispatch_group_async(v19, v20, block);
    }
    else
    {
      id v25 = *(id *)(a1 + 32);
      objc_sync_enter(v25);
      [*(id *)(a1 + 32) addObject:v18];
      objc_sync_exit(v25);

      id v26 = MBGetDefaultLog();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        double v34 = v8;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to stash downloaded asset for file: %@", buf, 0xCu);
        _MBLog();
      }
    }
    id v22 = v18;
LABEL_12:
  }
}

void sub_100138E14(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100138E34(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) parentEngine];
  if (!v2) {
    __assert_rtn("-[MBCKRestoreDomainEngine restoreFilesWithError:]_block_invoke", "MBCKRestoreDomainEngine.m", 410, "parentEngine");
  }
  id v3 = [*(id *)(a1 + 32) restorePolicy];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = [*(id *)(a1 + 32) safeHarborDir];
  id v6 = [v3 destinationPathForRestorable:v4 safeHarborDir:v5];

  id v7 = [[MBCKRestoreFileEngine alloc] initWithRestoreEngine:v2 file:*(void *)(a1 + 40) destinationPath:v6 shouldSetProtectionClass:1];
  id v15 = 0;
  unsigned __int8 v8 = [(MBCKRestoreFileEngine *)v7 runWithError:&v15];
  id v9 = v15;
  if (v8)
  {
    id v10 = [v2 progressModel];
    [v10 finishedItem:*(void *)(a1 + 40) size:*(void *)(a1 + 64)];
  }
  else
  {
    id v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      unsigned __int8 v12 = [*(id *)(a1 + 40) fileTypeString];
      uint64_t v13 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138543874;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      uint64_t v19 = v13;
      __int16 v20 = 2112;
      id v21 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to restore %{public}@ %@: %@", buf, 0x20u);

      uint64_t v14 = [*(id *)(a1 + 40) fileTypeString];
      _MBLog();
    }
    id v10 = *(id *)(a1 + 48);
    objc_sync_enter(v10);
    [*(id *)(a1 + 48) addObject:v9];
    objc_sync_exit(v10);
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
}

void sub_100139078(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100139094(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  unsigned __int8 v8 = [WeakRetained operationID];

  if (v6) {
    goto LABEL_2;
  }
  id v12 = *(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  if (v12 == [*(id *)(a1 + 32) count])
  {
    id v6 = 0;
    goto LABEL_14;
  }
  +[MBError errorWithCode:format:](MBError, "errorWithCode:format:", 1, @"Batch file operation %@ fetched incorrect number of file records (%lu of %lu)", v8, *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), [*(id *)(a1 + 32) count]);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  if (MBIsInternalInstall()
    && !dword_100482514
    && !atomic_fetch_add_explicit(&dword_100482514, 1u, memory_order_relaxed))
  {
    uint64_t v13 = MBGetDefaultLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      id v15 = [*(id *)(a1 + 32) count];
      *(_DWORD *)buf = 138412802;
      uint64_t v17 = v8;
      __int16 v18 = 2048;
      uint64_t v19 = v14;
      __int16 v20 = 2048;
      id v21 = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "=ckdomain-engine= =ckdomain-engine= Operation %@ fetched an incorrect number of file records (%lu of %lu)", buf, 0x20u);
      [*(id *)(a1 + 32) count];
      _MBLog();
    }
  }
  if (v6)
  {
LABEL_2:
    id v9 = MBGetDefaultLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138543874;
      uint64_t v17 = v8;
      __int16 v18 = 2112;
      uint64_t v19 = v10;
      __int16 v20 = 2112;
      id v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Batch download operation %{public}@ for %@ failed: %@", buf, 0x20u);
      _MBLog();
    }

    id v11 = *(id *)(a1 + 48);
    objc_sync_enter(v11);
    [*(id *)(a1 + 48) addObject:v6];
    objc_sync_exit(v11);
  }
LABEL_14:
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
}

void sub_10013932C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100139348(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v5 + 40);
  unsigned __int8 v6 = [v4 handleCancelation:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  if ((v6 & 1) == 0)
  {
    if ([v3 deleted])
    {
      uint64_t v7 = 1;
      goto LABEL_51;
    }
    [v3 setupWithDomain:*(void *)(a1 + 40)];
    unsigned __int8 v8 = [*(id *)(a1 + 32) restorePolicy];
    id v50 = 0;
    unsigned __int8 v9 = [v8 shouldRestoreFile:v3 markFileAsSkipped:0 error:&v50];
    id v10 = v50;

    if ((v9 & 1) == 0)
    {
      if (([v3 isRegularFile] & 1) == 0)
      {
        uint64_t v19 = (char *)[v3 size];
        __int16 v20 = &v19[(void)[v3 resourcesSize]];
        id v21 = [*(id *)(a1 + 48) progressModel];
        [v21 finishedItem:v3 size:v20];
      }
      if (v10
        && (+[MBError isError:v10 withCode:213] & 1) == 0)
      {
        id v32 = MBGetDefaultLog();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          id v53 = v3;
          __int16 v54 = 2112;
          id v55 = v10;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to determine if file %@ should be restored: %@", buf, 0x16u);
          _MBLog();
        }

        uint64_t v33 = *(void *)(*(void *)(a1 + 64) + 8);
        id v17 = v10;
        uint64_t v7 = 0;
        uint64_t v13 = *(void **)(v33 + 40);
        *(void *)(v33 + 40) = v17;
        goto LABEL_49;
      }
      if (![v3 isDirectory])
      {
        uint64_t v7 = 1;
LABEL_50:

        goto LABEL_51;
      }
      id v22 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
      uint64_t v23 = [v3 fileID];
LABEL_48:
      uint64_t v13 = (void *)v23;
      objc_msgSend(v22, "addObject:", v23, v46, v47);
      uint64_t v7 = 1;
      id v17 = v10;
LABEL_49:

      id v10 = v17;
      goto LABEL_50;
    }
    if ([v3 downloaded]) {
      goto LABEL_7;
    }
    if ([v3 resourcesSize])
    {
LABEL_41:
      double v36 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
      double v37 = objc_msgSend(v3, "recordIDString", v46, v47, v48);
      [v36 setObject:v3 forKeyedSubscript:v37];

      if ((unint64_t)[*(id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40) count] >= *(void *)(a1 + 104)
        || *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) >= *(void *)(a1 + 112))
      {
        uint64_t v38 = (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
        uint64_t v39 = *(void *)(*(void *)(a1 + 64) + 8);
        uint64_t v40 = *(void **)(v39 + 40);
        *(void *)(v39 + 40) = v38;

        *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = 0;
        if (*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40))
        {
          uint64_t v7 = 0;
          goto LABEL_50;
        }
      }
      uint64_t v41 = MBGetDefaultLog();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
      {
        unsigned int v42 = [v3 downloaded];
        *(_DWORD *)buf = 138412546;
        id v53 = v3;
        __int16 v54 = 1024;
        LODWORD(v55) = v42;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_INFO, "=ckdomain-engine= Adding file to download batch: %@ (%d)", buf, 0x12u);
        id v46 = v3;
        unint64_t v47 = [v3 downloaded];
        _MBLog();
      }

      uint64_t v43 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
      id v44 = [v3 size];
      *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = (char *)[v3 resourcesSize]
                                                                  + (void)v44
                                                                  + v43;
      id v22 = *(void **)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
      uint64_t v23 = [v3 recordIDString];
      goto LABEL_48;
    }
    dispatch_semaphore_t v24 = +[NSFileManager defaultManager];
    id v25 = [*(id *)(a1 + 32) cache];
    id v26 = [v3 signature];
    uint64_t v27 = objc_msgSend(v25, "fileAssetMetadataForSignature:volumeType:", v26, objc_msgSend(v3, "volumeType"));

    id v28 = [v27 decodedAssetPath];
    uint64_t v29 = [v27 stashedAssetPath];
    id v30 = (void *)v29;
    if (v28)
    {
      if ([v24 fileExistsAtPath:v28])
      {
        id v31 = MBGetDefaultLog();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412546;
          id v53 = v3;
          __int16 v54 = 2112;
          id v55 = v28;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "=ckdomain-engine= Already decoded file contents for this file(%@), so don't download again: %@", buf, 0x16u);
          id v46 = v3;
          unint64_t v47 = (unint64_t)v28;
LABEL_35:
          _MBLog();
          goto LABEL_36;
        }
        goto LABEL_36;
      }
      if (!v30) {
        goto LABEL_37;
      }
    }
    else if (!v29)
    {
LABEL_40:

      goto LABEL_41;
    }
    if ([v24 fileExistsAtPath:v30])
    {
      id v31 = MBGetDefaultLog();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412546;
        id v53 = v3;
        __int16 v54 = 2112;
        id v55 = v30;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "=ckdomain-engine= Already stashed file contents for this file(%@), so don't download again: %@", buf, 0x16u);
        id v46 = v3;
        unint64_t v47 = (unint64_t)v30;
        goto LABEL_35;
      }
LABEL_36:

LABEL_7:
      id v11 = objc_msgSend(*(id *)(a1 + 32), "restorePolicy", v46, v47);
      id v12 = [*(id *)(a1 + 32) safeHarborDir];
      uint64_t v13 = [v11 destinationPathForRestorable:v3 safeHarborDir:v12];

      uint64_t v14 = -[MBCKRestoreFileEngine initWithRestoreEngine:file:destinationPath:shouldSetProtectionClass:]([MBCKRestoreFileEngine alloc], "initWithRestoreEngine:file:destinationPath:shouldSetProtectionClass:", *(void *)(a1 + 48), v3, v13, [v3 isDirectory] ^ 1);
      id v49 = v10;
      unsigned __int8 v15 = [(MBCKRestoreFileEngine *)v14 runWithError:&v49];
      id v16 = v49;
      id v17 = v49;

      if (v15)
      {
        if (([v3 isDirectory] & 1) == 0)
        {
          __int16 v18 = [*(id *)(a1 + 48) progressModel];
          [v18 finishedItem:v3];
        }
        uint64_t v7 = 1;
      }
      else
      {
        double v34 = MBGetDefaultLog();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          id v53 = v3;
          __int16 v54 = 2112;
          id v55 = v17;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to restore %@: %@", buf, 0x16u);
          _MBLog();
        }

        objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), v16);
        uint64_t v7 = 0;
      }
      goto LABEL_49;
    }
LABEL_37:
    double v35 = MBGetDefaultLog();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412802;
      id v53 = v3;
      __int16 v54 = 2112;
      id v55 = v28;
      __int16 v56 = 2112;
      id v57 = v30;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, "=ckdomain-engine= Had cached stash path or decoded path for this file(%@), but they were not on disk anymore: %@, %@", buf, 0x20u);
      unint64_t v47 = (unint64_t)v28;
      uint64_t v48 = v30;
      id v46 = v3;
      _MBLog();
    }

    goto LABEL_40;
  }
  uint64_t v7 = 0;
LABEL_51:

  return v7;
}

uint64_t sub_100139ADC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8);
  id obj = *(id *)(v5 + 40);
  unsigned __int8 v6 = [v4 handleCancelation:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  if (v6)
  {
    uint64_t v7 = 0;
  }
  else
  {
    unsigned __int8 v8 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    unsigned __int8 v9 = [v3 fileID];
    LOBYTE(v_Block_object_dispose(&STACK[0x250], 8) = [v8 containsObject:v9];

    if (v8)
    {
      uint64_t v7 = 1;
    }
    else
    {
      [v3 setupWithDomain:*(void *)(a1 + 40)];
      id v10 = (char *)[v3 size];
      id v11 = [v3 resourcesSize];
      id v12 = [*(id *)(a1 + 32) restorePolicy];
      uint64_t v13 = [*(id *)(a1 + 32) safeHarborDir];
      uint64_t v14 = [v12 destinationPathForRestorable:v3 safeHarborDir:v13];

      unsigned __int8 v15 = [[MBCKRestoreFileEngine alloc] initWithRestoreEngine:*(void *)(a1 + 48) file:v3 destinationPath:v14 shouldSetProtectionClass:1];
      id v24 = 0;
      uint64_t v7 = [(MBCKRestoreFileEngine *)v15 runWithError:&v24];
      id v16 = v24;
      if (v7)
      {
        id v17 = [*(id *)(a1 + 48) progressModel];
        [v17 finishedItem:v3 size:&v10[(void)v11]];
      }
      else
      {
        __int16 v18 = MBGetDefaultLog();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = [v3 fileTypeString];
          *(_DWORD *)buf = 138543874;
          uint64_t v27 = v19;
          __int16 v28 = 2112;
          id v29 = v3;
          __int16 v30 = 2112;
          id v31 = v16;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "=ckdomain-engine= Failed to restore %{public}@ %@: %@", buf, 0x20u);

          uint64_t v23 = [v3 fileTypeString];
          _MBLog();
        }
        uint64_t v20 = *(void *)(*(void *)(a1 + 56) + 8);
        id v21 = v16;
        id v17 = *(void **)(v20 + 40);
        *(void *)(v20 + 40) = v21;
      }
    }
  }

  return v7;
}

void sub_10013AE24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

id sub_10013AE88(void *a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1[4] + 32) shouldRestoreFile:v3 markFileAsSkipped:0 error:0])
  {
    ++*(void *)(*(void *)(a1[7] + 8) + 24);
    uint64_t v4 = (void *)a1[5];
    if (v4)
    {
      uint64_t v5 = [v3 absolutePath];
      unsigned __int8 v6 = [v4 stringByAppendingPathComponent:v5];
    }
    else
    {
      unsigned __int8 v6 = [*(id *)(a1[4] + 32) destinationPathForRestorable:v3 safeHarborDir:0];
    }
  }
  else
  {
    unsigned __int8 v6 = 0;
    ++*(void *)(*(void *)(a1[6] + 8) + 24);
  }

  return v6;
}

void sub_10013B454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

id sub_10013B490(void *a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1[4] + 32) shouldRestoreFile:v3 markFileAsSkipped:0 error:0])
  {
    ++*(void *)(*(void *)(a1[7] + 8) + 24);
    uint64_t v4 = (void *)a1[5];
    uint64_t v5 = [v3 relativePath];
    unsigned __int8 v6 = [v4 stringByAppendingPathComponent:v5];
  }
  else
  {
    unsigned __int8 v6 = 0;
    ++*(void *)(*(void *)(a1[6] + 8) + 24);
  }

  return v6;
}

void sub_10013B90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10013B92C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10013B93C(uint64_t a1)
{
}

id sub_10013B944(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v5 + 40);
  id v6 = [v4 _checkForCancellation:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
  if (v6)
  {
    uint64_t v7 = (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    unsigned __int8 v8 = MBGetDefaultLog();
    unsigned __int8 v9 = v8;
    if (v7)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        id v13 = v3;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "=verifier= Verifying item: %@", buf, 0xCu);
        _MBLog();
      }

      unsigned __int8 v9 = [*(id *)(a1 + 32) _verifyRestoreMetadataForFile:v3 localPath:v7 fileList:*(void *)(a1 + 40)];
      if (v9) {
        [*(id *)(a1 + 48) addObject:v9];
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      id v13 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "=verifier= Skipping item: %@", buf, 0xCu);
      _MBLog();
    }
  }
  return v6;
}

uint64_t sub_10013BFF0(uint64_t a1, uint64_t a2)
{
  return 1;
}

void sub_10013C8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10013C934(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    uint64_t v10 = MBGetDefaultLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      id v14 = v7;
      __int16 v15 = 2112;
      id v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "=verifier= Failed to fetch the device record:%@(%@)", buf, 0x16u);
      _MBLog();
    }

    id v11 = (id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    uint64_t v12 = a4;
  }
  else
  {
    id v11 = (id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    uint64_t v12 = a3;
  }
  objc_storeStrong(v11, v12);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10013D400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  _Block_object_dispose((const void *)(v36 - 176), 8);
  _Block_object_dispose(&a36, 8);
  _Unwind_Resume(a1);
}

void sub_10013D4B8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = [a3 baseRecordID];
  id v7 = +[MBDomainRecord recordIDFromBaseRecordID:v6 pageIndex:0];

  id v8 = MBFileListDBPath(*(void **)(a1 + 32), *(void *)(a1 + 40), v5);
  id v9 = MBGetDefaultLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    uint64_t v10 = [v7 recordName];
    *(_DWORD *)buf = 138412802;
    id v13 = v5;
    __int16 v14 = 2112;
    __int16 v15 = v10;
    __int16 v16 = 2112;
    id v17 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "=verifier= Fetched domain %@ with recordID %@ and stashed file list to %@", buf, 0x20u);

    id v11 = [v7 recordName];
    _MBLog();
  }
  [*(id *)(a1 + 48) setObject:v7 forKeyedSubscript:v5];
}

uint64_t sub_10013D634(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_10013D658(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) delegate];
  unsigned int v5 = [v4 shouldCancelVerification];

  if (!v5)
  {
    id v11 = [*(id *)(a1 + 40) domainForName:v3];
    uint64_t v12 = v11;
    if (!v11) {
      __assert_rtn("-[MBBackupSnapshotIntegrityVerifier _verifySnapshotAfterCommitWithPath:operationTracker:scanMode:enginePolicy:snapshotTracker:domainManager:deviceRecordID:hmacKey:backupAttemptSummary:error:]_block_invoke_2", "MBSnapshotIntegrityVerifier.m", 556, "domain");
    }
    if ([v11 isPlaceholderAppDomain])
    {
      uint64_t v13 = +[MBError errorWithCode:500, @"App placeholder domains should not exist in snapshot: %@", v3 format];
      uint64_t v14 = *(void *)(*(void *)(a1 + 96) + 8);
      __int16 v15 = *(void **)(v14 + 40);
      *(void *)(v14 + 40) = v13;

      __int16 v16 = MBGetDefaultLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        id v17 = *(void **)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
        *(_DWORD *)buf = 138412290;
        id v54 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "=verifier= Failed to verify due to snapshot format integrity violation: %@", buf, 0xCu);
        _MBLog();
      }
LABEL_22:
      char v10 = 0;
LABEL_36:

      goto LABEL_37;
    }
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = *(void *)(a1 + 56);
    uint64_t v20 = *(void *)(*(void *)(a1 + 96) + 8);
    id obj = *(id *)(v20 + 40);
    __int16 v16 = +[MBFileListDB openOrCreateDatabaseIn:v18 commitID:v19 domainName:v3 error:&obj];
    objc_storeStrong((id *)(v20 + 40), obj);
    if (!v16)
    {
      uint64_t v39 = MBGetDefaultLog();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        uint64_t v40 = *(void **)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
        *(_DWORD *)buf = 138412546;
        id v54 = v3;
        __int16 v55 = 2112;
        __int16 v56 = v40;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "=verifier= Failed to get file list for %@: %@", buf, 0x16u);
        _MBLog();
      }

      __int16 v16 = 0;
      goto LABEL_22;
    }
    [*(id *)(a1 + 32) setCurrentFileList:v16];
    id v21 = *(void **)(a1 + 64);
    id v22 = [v12 volumeMountPoint];
    uint64_t v23 = [v21 snapshotMountPointForVolumeMountPoint:v22];

    if (*(void *)(a1 + 64) && !v23) {
      __assert_rtn("-[MBBackupSnapshotIntegrityVerifier _verifySnapshotAfterCommitWithPath:operationTracker:scanMode:enginePolicy:snapshotTracker:domainManager:deviceRecordID:hmacKey:backupAttemptSummary:error:]_block_invoke", "MBSnapshotIntegrityVerifier.m", 573, "snapshotPathForDomain");
    }
    id v24 = [*(id *)(a1 + 72) objectForKeyedSubscript:v3];
    id v25 = MBGetDefaultLog();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      id v26 = v25;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v27 = [v24 recordName];
        __int16 v28 = [v16 path];
        *(_DWORD *)buf = 138412802;
        id v54 = v3;
        __int16 v55 = 2112;
        __int16 v56 = v27;
        __int16 v57 = 2112;
        id v58 = v28;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "=verifier= Starting verification for domain %@ with recordID %@ using fetched file list at %@", buf, 0x20u);
      }
      id v29 = [v24 recordName];
      id v49 = [v16 path];
      _MBLog();
    }
    __int16 v30 = [*(id *)(a1 + 32) scanner];
    uint64_t v31 = [v30 scanDomain:v12 snapshotMountPoint:v23];
    uint64_t v32 = *(void *)(*(void *)(a1 + 96) + 8);
    uint64_t v33 = *(void **)(v32 + 40);
    *(void *)(v32 + 40) = v31;

    if (*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40))
    {
      double v34 = MBGetDefaultLog();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        double v34 = v34;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          double v35 = [v24 recordName];
          uint64_t v36 = [v16 path];
          uint64_t v37 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
          *(_DWORD *)buf = 138413058;
          id v54 = v3;
          __int16 v55 = 2112;
          __int16 v56 = v35;
          __int16 v57 = 2112;
          id v58 = v36;
          __int16 v59 = 2112;
          uint64_t v60 = v37;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "=verifier= Failed to verify domain %@ with recordID %@ using fetched file list at %@: %@", buf, 0x2Au);
        }
        uint64_t v38 = [v24 recordName];
        id v50 = [v16 path];
        _MBLog();

LABEL_32:
        char v10 = 0;
LABEL_33:

LABEL_35:
        [*(id *)(a1 + 32) setCurrentFileList:0];
        [v16 close:0];
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v41 = *(void **)(a1 + 32);
      unsigned int v42 = [*(id *)(a1 + 80) assetIDPrefix];
      uint64_t v43 = *(void *)(*(void *)(a1 + 104) + 8) + 24;
      uint64_t v44 = *(void *)(a1 + 88);
      uint64_t v45 = *(void *)(*(void *)(a1 + 96) + 8);
      id v51 = *(id *)(v45 + 40);
      LOBYTE(v41) = [v41 _verifyAllAssetRecordIDsAreReferencedForDomain:v12 assetIDPrefix:v42 recordsDB:v44 totalVerifiedAssetRecordsCount:v43 error:&v51];
      objc_storeStrong((id *)(v45 + 40), v51);

      if (v41)
      {
        double v34 = MBGetDefaultLog();
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          char v10 = 1;
          goto LABEL_35;
        }
        double v34 = v34;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          id v46 = [v24 recordName];
          *(_DWORD *)buf = 138412546;
          id v54 = v3;
          __int16 v55 = 2112;
          __int16 v56 = v46;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "=verifier= Finished backup verification for domain %@ with recordID: %@", buf, 0x16u);
        }
        uint64_t v38 = [v24 recordName];
        _MBLog();
        char v10 = 1;
        goto LABEL_33;
      }
      double v34 = MBGetDefaultLog();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        double v34 = v34;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          unint64_t v47 = [*(id *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) description];
          *(_DWORD *)buf = 138412546;
          id v54 = v3;
          __int16 v55 = 2112;
          __int16 v56 = v47;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "=verifier= Failed to verify asset references exist for domain %@: %@", buf, 0x16u);
        }
        uint64_t v38 = [*(id *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) description];
        _MBLog();
        goto LABEL_32;
      }
    }
    char v10 = 0;
    goto LABEL_35;
  }
  id v6 = [*(id *)(a1 + 32) scanner];
  [v6 cancel];

  uint64_t v7 = [(id)objc_opt_class() _cancellationError];
  uint64_t v8 = *(void *)(*(void *)(a1 + 96) + 8);
  id v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;

  char v10 = 0;
LABEL_37:

  return v10 & 1;
}

void sub_10013DDE8(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x10013DD2CLL);
  }
  _Unwind_Resume(exc_buf);
}

void sub_10013DFBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_10013DFD4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  if (!v5) {
    __assert_rtn("-[MBBackupSnapshotIntegrityVerifier _verifyAllAssetRecordIDsAreReferencedForDomain:assetIDPrefix:recordsDB:totalVerifiedAssetRecordsCount:error:]_block_invoke", "MBSnapshotIntegrityVerifier.m", 615, "assetRecordIDSuffix");
  }
  if (!a3) {
    __assert_rtn("-[MBBackupSnapshotIntegrityVerifier _verifyAllAssetRecordIDsAreReferencedForDomain:assetIDPrefix:recordsDB:totalVerifiedAssetRecordsCount:error:]_block_invoke", "MBSnapshotIntegrityVerifier.m", 616, "innerError");
  }
  id v6 = v5;
  uint64_t v7 = +[MBAssetRecord recordIDFromAssetIDPrefix:*(void *)(a1 + 32) recordIDSuffix:v5];
  uint64_t v8 = *(void **)(a1 + 40);
  id v9 = [v7 recordName];
  id v10 = [v8 hasAssetReference:v9 error:a3];

  if (v10)
  {
    ++*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  }
  else
  {
    id v11 = [*(id *)(a1 + 48) name];
    uint64_t v12 = [v7 recordName];
    uint64_t v13 = +[NSString stringWithFormat:@"Missing server-side asset reference for domain %@, recordID %@", v11, v12];

    *a3 = +[MBError errorWithCode:500 description:v13];
    uint64_t v14 = [*(id *)(a1 + 56) attemptSummary];
    [v14 trackSnapshotVerificationFailure:v13];
  }
  return v10;
}

void sub_10013FEE0(id *a1, void *a2)
{
  id v3 = a2;
  id v4 = *a1;
  id v6 = v3;
  if (!*a1)
  {
    id v4 = +[NSMutableArray array];
    id v3 = v6;
    *a1 = v4;
  }
  id v5 = (*((void (**)(void))v3 + 2))();
  [v4 addObject:v5];
}

NSString *__cdecl sub_10013FF70(id a1)
{
  return (NSString *)@"mode";
}

NSString *__cdecl sub_10013FF7C(id a1)
{
  return (NSString *)@"userID";
}

NSString *__cdecl sub_10013FF88(id a1)
{
  return (NSString *)@"groupID";
}

NSString *sub_10013FF94(uint64_t a1)
{
  return +[NSString stringWithFormat:@"mode (0%o adjusted from 0%o)", *(unsigned __int16 *)(a1 + 100), *(unsigned __int16 *)(a1 + 172)];
}

NSString *sub_10013FFD4(uint64_t a1)
{
  return +[NSString stringWithFormat:@"userID (%d adjusted from %d)", *(unsigned int *)(a1 + 36), *(unsigned int *)(a1 + 108)];
}

NSString *sub_100140014(uint64_t a1)
{
  return +[NSString stringWithFormat:@"groupID (%d adjusted from %d)", *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 112)];
}

NSString *__cdecl sub_100140054(id a1)
{
  return (NSString *)@"birth";
}

NSString *__cdecl sub_100140060(id a1)
{
  return (NSString *)@"fileSize";
}

NSString *__cdecl sub_10014006C(id a1)
{
  return (NSString *)@"protectionClass";
}

NSString *__cdecl sub_100140078(id a1)
{
  return (NSString *)@"statusChanged";
}

NSString *__cdecl sub_100140084(id a1)
{
  return (NSString *)@"flags";
}

NSString *__cdecl sub_100140090(id a1)
{
  return (NSString *)@"inode";
}

NSString *__cdecl sub_10014009C(id a1)
{
  return (NSString *)@"genCount";
}

NSString *__cdecl sub_1001400A8(id a1)
{
  return (NSString *)@"protectionClass";
}

NSString *__cdecl sub_1001400B4(id a1)
{
  return (NSString *)@"linkTarget";
}

NSString *__cdecl sub_1001400C0(id a1)
{
  return (NSString *)@"linkTarget";
}

id sub_1001400CC(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

NSString *__cdecl sub_1001400D4(id a1)
{
  return (NSString *)@"hasXattrs";
}

NSString *__cdecl sub_1001400E0(id a1)
{
  return (NSString *)@"modified";
}

NSString *__cdecl sub_1001400EC(id a1)
{
  return (NSString *)@"statusChanged";
}

void sub_100140C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100140C8C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100140C9C(uint64_t a1)
{
}

void sub_100140CA4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    id v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to remove domain: %@", buf, 0xCu);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10014148C(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v10 = a2;
  id v7 = a3;
  uint64_t v8 = [*(id *)(*(void *)(a1 + 32) + 8) objectForKeyedSubscript:v10];
  if (!v8) {
    __assert_rtn("-[MBDomainReferenceConsolidator enumerateConsolidatedDomainNamesAndReference:]_block_invoke", "MBDomainReferenceConsolidator.m", 71, "reference");
  }
  id v9 = (void *)v8;
  *a4 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))() ^ 1;
}

void sub_1001424D4(uint64_t a1, void *a2, void *a3)
{
  id v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  id v6 = a2;
  objc_msgSend(v4, "manager:didScanBundleWithID:bytesUsed:", v5, v6, objc_msgSend(a3, "unsignedLongLongValue"));
}

void sub_100142540(void *a1, void *a2, void *a3)
{
  uint64_t v5 = (void *)a1[4];
  id v6 = a3;
  id v7 = a2;
  id v11 = [v5 _bundleIDForDomainName:v7];
  id v9 = (void *)a1[5];
  uint64_t v8 = a1[6];
  id v10 = [v6 unsignedLongLongValue];

  [v9 manager:v8 didScanDomainWithName:v7 forBundleID:v11 bytesUsed:v10];
}

void sub_1001425E8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  id v8 = [v5 _bundleIDForDomainName:v7];
  [*(id *)(a1 + 40) manager:*(void *)(a1 + 48) didScanFiles:v6 forDomainWithName:v7 bundleID:v8];
}

void sub_1001431CC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v10) {
          objc_enumerationMutation(v6);
        }
        uint64_t v12 = [*(id *)(*(void *)(a1 + 32) + 312) objectForKeyedSubscript:*(void *)(*((void *)&v14 + 1) + 8 * i)];
        v9 += (uint64_t)[v12 unsignedLongLongValue];
      }
      id v8 = [v6 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v13 = +[NSNumber numberWithUnsignedLongLong:v9];
  [*(id *)(a1 + 40) setObject:v13 forKeyedSubscript:v5];
}

int64_t sub_100143524(id a1, id a2, id a3)
{
  id v4 = a2;
  id v5 = a3;
  int v6 = sub_10008AC88(v4);
  if (v6 == sub_10008AC88(v5))
  {
    id v7 = [v4 name];
    id v8 = [v5 name];
    int64_t v9 = (int64_t)[v7 compare:v8];
  }
  else
  {
    unsigned int v10 = sub_10008AC88(v4);
    if (v10 >= sub_10008AC88(v5))
    {
      int v11 = sub_10008AC88(v4);
      int64_t v9 = v11 != sub_10008AC88(v5);
    }
    else
    {
      int64_t v9 = -1;
    }
  }

  return v9;
}

void sub_100143B50(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  MBDomainHMACForDomainName((uint64_t)v7, v5);
  id v13 = (id)objc_claimAutoreleasedReturnValue();
  id v8 = [*(id *)(a1 + 40) objectForKeyedSubscript:v13];
  int64_t v9 = [v8 quota];

  unsigned int v10 = [v6 unsignedLongLongValue];
  if ((uint64_t)v10 <= (uint64_t)v9) {
    int64_t v11 = 0;
  }
  else {
    int64_t v11 = v10 - v9;
  }
  uint64_t v12 = +[NSNumber numberWithLongLong:v11];
  [*(id *)(*(void *)(a1 + 48) + 312) setObject:v12 forKeyedSubscript:v7];
}

id sub_100144430(uint64_t a1)
{
  id v1 = objc_alloc_init(*(Class *)(a1 + 32));
  uint64_t v2 = (void *)qword_100482518;
  qword_100482518 = (uint64_t)v1;

  id v3 = +[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"];
  [(id)qword_100482518 setLocale:v3];

  id v4 = (void *)qword_100482518;
  return [v4 setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"];
}

void sub_100144880(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001449D0(uint64_t a1)
{
  [*(id *)(a1 + 32) timeout];
  double v3 = v2;
  id v4 = [*(id *)(a1 + 32) _fetchPluginFieldsFromDelegate];
  id v5 = *(id *)(*(void *)(a1 + 32) + 16);
  id v6 = [*(id *)(a1 + 32) lock];
  id v7 = [*(id *)(a1 + 32) account];
  id v14 = 0;
  unsigned __int8 v8 = [v6 saveLockWithAccount:v7 timeout:v4 pluginFields:&v14 error:v3];
  id v9 = v14;

  if (v8)
  {
    if (v5 && (objc_opt_respondsToSelector() & 1) != 0) {
      [v5 lockManagerDidAcquireLock:*(void *)(a1 + 32)];
    }
    unsigned int v10 = +[NSDate date];
    [*(id *)(a1 + 32) setLastAcquired:v10];

    [*(id *)(a1 + 32) setLastDuration:v3];
  }
  else
  {
    int64_t v11 = MBGetDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to renew lock: %@", buf, 0xCu);
      id v13 = v9;
      _MBLog();
    }

    if (v5 && (objc_opt_respondsToSelector() & 1) != 0) {
      [v5 lockManager:*(void *)(a1 + 32) failedToAcquireLockWithError:v9];
    }
  }
  uint64_t v12 = *(void **)(a1 + 32);
  objc_msgSend(v12, "renewInterval", v13);
  objc_msgSend(v12, "_scheduleTimerWithInterval:");
}

id sub_100144CA4(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  [v1 renewInterval];
  return objc_msgSend(v1, "_scheduleTimerWithInterval:");
}

id sub_100144DB4(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 32) invalidate];
}

void sub_1001450D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100145108(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100145118(uint64_t a1)
{
}

void sub_100145120(uint64_t a1)
{
  double v2 = [*(id *)(a1 + 32) _fetchPluginFieldsFromDelegate];
  double v3 = [*(id *)(a1 + 32) lock];
  id v4 = [*(id *)(a1 + 32) account];
  double v5 = *(double *)(a1 + 56);
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  id obj = *(id *)(v6 + 40);
  unsigned __int8 v7 = [v3 saveLockWithAccount:v4 timeout:v2 pluginFields:&obj error:v5];
  objc_storeStrong((id *)(v6 + 40), obj);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v7;
}

id sub_10014524C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _releaseLockAndScheduleRetries];
}

id sub_1001452C8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _releaseLockAndScheduleRetries];
}

void sub_100145D64(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100146170()
{
  uint64_t v0 = (objc_class *)objc_opt_class();
  id v5 = +[NSString stringWithFormat:@"%s.keybagIsLocking", class_getName(v0)];
  id v1 = (const char *)[v5 UTF8String];
  double v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v3 = dispatch_queue_create(v1, v2);
  id v4 = (void *)qword_100482530;
  qword_100482530 = (uint64_t)v3;
}

void sub_100146218(uint64_t a1)
{
  [*(id *)(a1 + 48) _findMissingEncryptionKeysWithAccount:*(void *)(a1 + 32) serviceManager:*(void *)(a1 + 40)];
}

id sub_100146260(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _exportKeychain];
}

void sub_100146268(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1001464E8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100146504(uint64_t a1)
{
  [*(id *)(a1 + 48) _findMissingEncryptionKeysWithAccount:*(void *)(a1 + 32) serviceManager:*(void *)(a1 + 40)];
}

void sub_100146634(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100146EA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  if (a2)
  {
    _Block_object_dispose(&a27, 8);
    _Block_object_dispose(&a31, 8);
    objc_begin_catch(exception_object);
    if (!a15) {
      JUMPOUT(0x100146E24);
    }
    JUMPOUT(0x100146E18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100147300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100147350(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100147360(uint64_t a1)
{
}

uint64_t sub_100147368(void *a1, void *a2)
{
  memset(&v43, 0, sizeof(v43));
  id v3 = a2;
  if (stat((const char *)[v3 fileSystemRepresentation], &v43))
  {
    id v4 = MBGetDefaultLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *__error();
      *(_DWORD *)buf = 138412546;
      __darwin_ino64_t v45 = (__darwin_ino64_t)v3;
      __int16 v46 = 1024;
      LODWORD(v47) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "=encryption key= Error getting inode number for %@: %{errno}d", buf, 0x12u);
      __error();
      _MBLog();
    }

    *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 0;
    uint64_t v6 = 1;
  }
  else
  {
    __darwin_ino64_t st_ino = v43.st_ino;
    uint64_t v8 = MBVolumeTypeFromPath();
    uint64_t v9 = *(void *)(a1[7] + 8);
    id obj = *(id *)(v9 + 40);
    unsigned int v10 = +[MBKeyBagFile keybagFileWithPath:v3 error:&obj];
    objc_storeStrong((id *)(v9 + 40), obj);
    if (v10)
    {
      uint64_t v11 = *(void *)(a1[7] + 8);
      id v41 = *(id *)(v11 + 40);
      uint64_t v12 = [v10 encryptionKeyWithError:&v41];
      objc_storeStrong((id *)(v11 + 40), v41);
      id v13 = MBGetDefaultLog();
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        if (v14)
        {
          id v15 = [v12 length];
          *(_DWORD *)buf = 134218754;
          __darwin_ino64_t v45 = (__darwin_ino64_t)v15;
          __int16 v46 = 2048;
          __darwin_ino64_t v47 = st_ino;
          __int16 v48 = 2048;
          uint64_t v49 = v8;
          __int16 v50 = 2112;
          id v51 = v3;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "=encryption key= Found encryption key (size: %tu) for inode:%lld volumeType:%lu at %@", buf, 0x2Au);
          uint64_t v37 = v8;
          id v38 = v3;
          id v34 = [v12 length];
          __darwin_ino64_t v35 = st_ino;
          _MBLog();
        }

        id v16 = *(void **)(*(void *)(a1[8] + 8) + 40);
        if (v16) {
          goto LABEL_11;
        }
        uint64_t v17 = *(void *)(a1[7] + 8);
        uint64_t v18 = *(void **)(v17 + 40);
        *(void *)(v17 + 40) = 0;

        uint64_t v19 = (void *)a1[4];
        uint64_t v20 = a1[5];
        uint64_t v21 = *(void *)(a1[7] + 8);
        id v40 = *(id *)(v21 + 40);
        uint64_t v22 = [v19 openCacheWithAccount:v20 accessType:1 error:&v40];
        objc_storeStrong((id *)(v21 + 40), v40);
        uint64_t v23 = *(void *)(a1[8] + 8);
        id v24 = *(void **)(v23 + 40);
        *(void *)(v23 + 40) = v22;

        id v16 = *(void **)(*(void *)(a1[8] + 8) + 40);
        if (v16)
        {
LABEL_11:
          uint64_t v25 = objc_msgSend(v16, "setFileEncryptionKey:forInodeNumber:volumeType:atPath:", v12, st_ino, v8, v3, v34, v35, v37, v38);
          uint64_t v26 = *(void *)(a1[7] + 8);
          uint64_t v27 = *(void **)(v26 + 40);
          *(void *)(v26 + 40) = v25;

          if (*(void *)(*(void *)(a1[7] + 8) + 40))
          {
            __int16 v28 = MBGetDefaultLog();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              id v29 = *(void **)(*(void *)(a1[7] + 8) + 40);
              *(_DWORD *)buf = 134218754;
              __darwin_ino64_t v45 = st_ino;
              __int16 v46 = 2048;
              __darwin_ino64_t v47 = v8;
              __int16 v48 = 2112;
              uint64_t v49 = (uint64_t)v3;
              __int16 v50 = 2112;
              id v51 = v29;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "=encryption key= Failed to set encryption key for inode:%lld volumeType:%lu at %@: %@", buf, 0x2Au);
              _MBLog();
            }

            *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 0;
          }
          uint64_t v6 = 1;
          *(unsigned char *)(*(void *)(a1[9] + 8) + 24) = 1;
        }
        else
        {
          uint64_t v6 = 0;
          *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 0;
        }
      }
      else
      {
        if (v14)
        {
          uint64_t v32 = +[MBError descriptionForError:*(void *)(*(void *)(a1[7] + 8) + 40)];
          *(_DWORD *)buf = 134218754;
          __darwin_ino64_t v45 = st_ino;
          __int16 v46 = 2048;
          __darwin_ino64_t v47 = v8;
          __int16 v48 = 2112;
          uint64_t v49 = (uint64_t)v3;
          __int16 v50 = 2112;
          id v51 = v32;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "=encryption key= Error getting encryption key for inode:%lld volumeType:%lu at %@: %@", buf, 0x2Au);

          uint64_t v39 = +[MBError descriptionForError:*(void *)(*(void *)(a1[7] + 8) + 40)];
          _MBLog();
        }
        *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 0;
        uint64_t v6 = 1;
      }
    }
    else
    {
      __int16 v30 = MBGetDefaultLog();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = +[MBError descriptionForError:*(void *)(*(void *)(a1[7] + 8) + 40)];
        *(_DWORD *)buf = 138412546;
        __darwin_ino64_t v45 = (__darwin_ino64_t)v3;
        __int16 v46 = 2112;
        __darwin_ino64_t v47 = (__darwin_ino64_t)v31;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "=encryption key= Error opening file to get encryption key %@: %@", buf, 0x16u);

        uint64_t v36 = +[MBError descriptionForError:*(void *)(*(void *)(a1[7] + 8) + 40)];
        _MBLog();
      }
      *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 0;
      uint64_t v6 = 1;
    }
  }
  return v6;
}

__CFString *sub_100149054(unint64_t a1)
{
  if (a1 >= 5) {
    __assert_rtn("MBStringForEncryptionKeySource", "MBCKEncryptionManager.m", 500, "0");
  }
  return off_1004146E8[a1];
}

id MBFetchEncryptionKeyForFile(void *a1, void *a2, void *a3, void *a4, unint64_t *a5, void *a6)
{
  id v9 = a1;
  id v92 = a2;
  id v93 = a3;
  id v94 = a4;
  uint64_t v91 = v9;
  unsigned int v10 = [v9 absolutePath];
  uint64_t v95 = +[MBEncryptionKeyReader encryptionKeyReaderForFileAtPath:v10 error:a6];

  uint64_t v11 = v95;
  if (!v95)
  {
    id v18 = 0;
    goto LABEL_67;
  }
  id v98 = 0;
  id v96 = v95;
  id v12 = v9;
  id v13 = v92;
  id v84 = v93;
  id v88 = v94;
  BOOL v14 = [v12 domain];
  long long v86 = [v14 name];

  id v15 = [v12 domain];
  uint64_t v83 = [v15 volumeMountPoint];

  id v85 = [v12 absolutePath];
  id v82 = [v12 inodeNumber];
  if (!v13) {
    goto LABEL_13;
  }
  id v101 = 0;
  unsigned int v16 = sub_100149D98(v13, v96, v88, &v101);
  id v17 = v101;
  if (!v16)
  {
    uint64_t v20 = MBGetDefaultLog();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      id v21 = [v13 length];
      *(_DWORD *)buf = 138413314;
      id v105 = v86;
      __int16 v106 = 2112;
      id v107 = v85;
      __int16 v108 = 2048;
      id v109 = v82;
      __int16 v110 = 2048;
      id v111 = v21;
      __int16 v112 = 2112;
      id v113 = v17;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "=encryption key= Could not validate existing encryption key for %@:%@ (inode:%llu) size:%llu: %@", buf, 0x34u);
      id v77 = [v13 length];
      id v78 = v17;
      id v75 = v85;
      id v76 = v82;
      id v74 = v86;
      _MBLog();
    }

    id v100 = 0;
    sub_100149E58((uint64_t)v13, v96, v88, &v100);
    id v18 = (id)objc_claimAutoreleasedReturnValue();
    id v22 = v100;
    uint64_t v23 = v22;
    if (v18)
    {

      unint64_t v19 = 2;
      goto LABEL_46;
    }
    id v24 = MBGetDefaultLog();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      id v25 = [v13 length];
      *(_DWORD *)buf = 138413314;
      id v105 = v86;
      __int16 v106 = 2112;
      id v107 = v85;
      __int16 v108 = 2048;
      id v109 = v82;
      __int16 v110 = 2048;
      id v111 = v25;
      __int16 v112 = 2112;
      id v113 = v23;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "=encryption key= Could not update existing encryption key for %@:%@ (inode:%llu) size:%llu: %@", buf, 0x34u);
      id v77 = [v13 length];
      id v78 = v23;
      id v75 = v85;
      id v76 = v82;
      id v74 = v86;
      _MBLog();
    }

LABEL_13:
    id v99 = 0;
    id v26 = v84;
    id v27 = v83;
    id v28 = v96;
    id v29 = v88;
    uint64_t v80 = v26;
    uint64_t v81 = v27;
    __int16 v30 = [v26 fetchEncryptionKeyForInode:v82 volumeMountPoint:v27 error:&v99];
    uint64_t v31 = v30;
    if (!v30)
    {
      id v32 = 0;
      goto LABEL_29;
    }
    if (sub_100149D98(v30, v28, v29, &v99))
    {
      id v32 = v31;
LABEL_29:

      id v17 = v99;
      if (v32)
      {
        id v18 = v32;
        unint64_t v19 = 3;
      }
      else
      {
        stat v43 = MBGetDefaultLog();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138413058;
          id v105 = v86;
          __int16 v106 = 2112;
          id v107 = v85;
          __int16 v108 = 2048;
          id v109 = v82;
          __int16 v110 = 2112;
          id v111 = v17;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_INFO, "=encryption key= Could not fetch encryption key for %@:%@ (inode:%llu) from the missed encryption key database: %@", buf, 0x2Au);
          id v76 = v82;
          id v77 = v17;
          id v74 = v86;
          id v75 = v85;
          _MBLog();
        }

        id v102 = 0;
        id v44 = v28;
        id v45 = v12;
        id v46 = v29;
        id v103 = 0;
        __darwin_ino64_t v47 = [v44 encryptionKeyWithError:&v103];
        id v48 = v103;
        uint64_t v49 = v48;
        if (!v47 || v48)
        {
          +[MBError errorWithCode:error:format:](MBError, "errorWithCode:error:format:", 209, v48, @"Failed to fetch encryption key from MKB cache for inode:%llu", objc_msgSend(v45, "inodeNumber", v74, v75, v76, v77, v78));
          id v18 = 0;
          id v102 = (id)objc_claimAutoreleasedReturnValue();
        }
        else if (sub_100149EFC(v47, v46, &v102))
        {
          id v18 = v47;
        }
        else
        {
          id v18 = 0;
        }

        id v50 = v102;
        if (v18)
        {
          id v51 = v18;
          unint64_t v19 = 4;
        }
        else
        {
          id v52 = MBGetDefaultLog();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138413058;
            id v105 = v86;
            __int16 v106 = 2112;
            id v107 = v85;
            __int16 v108 = 2048;
            id v109 = v82;
            __int16 v110 = 2112;
            id v111 = v50;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_INFO, "=encryption key= Could not fetch encryption key for %@:%@ (inode:%llu) from the MKB cache: %@", buf, 0x2Au);
            _MBLog();
          }

          id v98 = v50;
          [v80 markMissedEncryptionKeyForVolume:v81 inode:v82 error:&v98];
          unint64_t v19 = 0;
        }
      }
      goto LABEL_46;
    }
    id v103 = 0;
    uint64_t v33 = sub_100149E58((uint64_t)v31, v28, v29, &v103);
    id v34 = v103;
    __darwin_ino64_t v35 = v34;
    if (v33)
    {
      id v102 = v34;
      unsigned __int8 v36 = [v80 setFoundEncryptionKey:v33 forVolumeMountPoint:v81 inode:v82 error:&v102];
      id v37 = v102;

      if (v36)
      {
        id v38 = MBGetDefaultLog();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
        {
          id v39 = [v31 length];
          *(_DWORD *)buf = 134218240;
          id v105 = v82;
          __int16 v106 = 2048;
          id v107 = v39;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, "=encryption key= Updated key fetched from the missed encryption key DB (inode:%llu size:%llu)", buf, 0x16u);
          id v74 = v82;
          id v75 = [v31 length];
          _MBLog();
        }

        id v32 = v33;
        goto LABEL_28;
      }
      id v37 = v37;
      id v99 = v37;
      id v40 = MBGetDefaultLog();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        id v42 = [v31 length];
        *(_DWORD *)buf = 134218498;
        id v105 = v82;
        __int16 v106 = 2048;
        id v107 = v42;
        __int16 v108 = 2112;
        id v109 = v37;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "=encryption key= Failed to set updated encryption key in the missed encryption key DB (inode:%llu size:%llu): %@", buf, 0x20u);
        id v75 = [v31 length];
        id v76 = v37;
        id v74 = v82;
        _MBLog();
      }
    }
    else
    {
      id v37 = v34;
      id v99 = v37;
      id v40 = MBGetDefaultLog();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        id v41 = [v31 length];
        *(_DWORD *)buf = 134218498;
        id v105 = v82;
        __int16 v106 = 2048;
        id v107 = v41;
        __int16 v108 = 2112;
        id v109 = v37;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "=encryption key= Failed to update key fetched from the missed encryption key DB (inode:%llu size:%llu): %@", buf, 0x20u);
        id v75 = [v31 length];
        id v76 = v37;
        id v74 = v82;
        _MBLog();
      }
    }

    id v32 = 0;
LABEL_28:

    goto LABEL_29;
  }
  id v18 = v13;
  unint64_t v19 = 1;
LABEL_46:

  id v53 = v98;
  if (v18)
  {
    id v54 = MBGetDefaultLog();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v55 = v54;
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        id v90 = [v18 length];
        __int16 v56 = [v12 domain];
        __int16 v57 = [v12 absolutePath];
        id v58 = [v12 inodeNumber];
        __int16 v59 = sub_100149054(v19);
        *(_DWORD *)buf = 134219010;
        id v105 = v90;
        __int16 v106 = 2112;
        id v107 = v56;
        __int16 v108 = 2112;
        id v109 = v57;
        __int16 v110 = 2048;
        id v111 = v58;
        __int16 v112 = 2112;
        id v113 = v59;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "=encryption key= Fetched encryption key with size:%llu for %@:%@ (inode:%llu) from %@", buf, 0x34u);
      }
      [v18 length];
      uint64_t v60 = [v12 domain];
      __int16 v61 = [v12 absolutePath];
      [v12 inodeNumber];
      uint64_t v79 = sub_100149054(v19);
      _MBLog();
    }
    if (a5) {
      *a5 = v19;
    }
    id v62 = v18;
  }
  else
  {
    uint64_t v63 = MBGetDefaultLog();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      id v64 = v63;
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
      {
        id v65 = [v12 domain];
        long long v66 = [v12 absolutePath];
        id v67 = [v12 inodeNumber];
        *(_DWORD *)buf = 138413058;
        id v105 = v65;
        __int16 v106 = 2112;
        id v107 = v66;
        __int16 v108 = 2048;
        id v109 = v67;
        __int16 v110 = 2112;
        id v111 = v53;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "=encryption key= Failed to fetch encryption key for %@:%@ (inode:%llu): %@", buf, 0x2Au);
      }
      id v68 = [v12 domain];
      long long v69 = [v12 absolutePath];
      [v12 inodeNumber];
      _MBLog();
    }
    if (a5) {
      *a5 = 0;
    }
    if (a6) {
      *a6 = v53;
    }
  }

  id v97 = 0;
  unsigned __int8 v70 = [v96 closeWithError:&v97];
  id v71 = v97;
  if ((v70 & 1) == 0)
  {
    CFStringRef v72 = MBGetDefaultLog();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v105 = v71;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_FAULT, "=encryption key= Failed to close keybag file: %@", buf, 0xCu);
      _MBLog();
    }
  }
  uint64_t v11 = v95;
LABEL_67:

  return v18;
}

void sub_100149D34(_Unwind_Exception *exception_object)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

id sub_100149D98(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  if ([v8 validateEncryptionKey:v7 error:a4])
  {
    id v10 = sub_100149EFC(v7, v9, a4);
  }
  else if (a4)
  {
    +[MBError errorWithCode:209 format:@"Failed to validate existing encryption key"];
    id v10 = 0;
    *a4 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

id sub_100149E58(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = [v7 updatedEncryptionKeyForCurrentKey:a1 withError:a4];
  id v10 = v9;
  if (v9 && sub_100149D98(v9, v7, v8, a4)) {
    id v11 = v10;
  }
  else {
    id v11 = 0;
  }

  return v11;
}

id sub_100149EFC(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = MBKeybagUUIDForEncryptionKey(a1, a3);
  if (v6)
  {
    id v7 = +[MBCKKeyBag UUIDStringForKeyBagUUID:v6];
    id v8 = [v5 keybagManager];
    id v9 = [v8 hasKeybagWithUUID:v7];

    if ((v9 & 1) == 0)
    {
      id v10 = MBGetDefaultLog();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "=encryption key= Device record does not contain keybagUUID %@", buf, 0xCu);
        _MBLog();
      }

      if (a3)
      {
        *a3 = +[MBError errorWithCode:205, @"Device record does not contain keybagUUID %@", v6 format];
      }
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

uint64_t sub_10014A06C(void *a1, void *a2, uint64_t a3)
{
  memset(&v37, 0, 512);
  id v5 = a2;
  if (statfs((const char *)[v5 fileSystemRepresentation], &v37))
  {
    id v6 = +[MBError errorWithErrno:*__error() path:v5 format:@"stat() failed"];
LABEL_3:
    id v7 = 0;
    goto LABEL_6;
  }
  ssize_t v8 = fsgetpath(v36, 0x400uLL, &v37.f_fsid, a3);
  if (v8 < 0)
  {
    id v6 = +[MBError errorWithErrno:*__error() format:@"fsgetpath() failed"];
    uint64_t v23 = MBGetDefaultLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v24 = *__error();
      *(_DWORD *)buf = 138412802;
      id v31 = v5;
      __int16 v32 = 2048;
      uint64_t v33 = a3;
      __int16 v34 = 1024;
      int v35 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "=encryption key= fsgetpath() failed for volume %@ inode %llu: %{errno}d", buf, 0x1Cu);
      __error();
      _MBLog();
    }

    goto LABEL_3;
  }
  id v7 = [objc_alloc((Class)NSString) initWithBytes:v36 length:v8 - 1 encoding:4];
  id v6 = 0;
LABEL_6:

  id v9 = v6;
  id v10 = v9;
  if (v7)
  {
    id v28 = v9;
    id v11 = +[MBEncryptionKeyReader encryptionKeyReaderForFileAtPath:v7 error:&v28];
    id v12 = v28;

    if (!v11)
    {
      id v13 = MBGetDefaultLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v37.f_bsize = 138412802;
        *(void *)&v37.f_iosize = v7;
        WORD2(v37.f_blocks) = 2048;
        *(uint64_t *)((char *)&v37.f_blocks + 6) = a3;
        HIWORD(v37.f_bfree) = 2112;
        v37.f_bavail = (uint64_t)v12;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "=encryption key= Failed to create encryption key reader for %@ (inode:%llu): %@", (uint8_t *)&v37, 0x20u);
        _MBLog();
      }
      goto LABEL_31;
    }
    id v27 = v12;
    id v13 = [v11 encryptionKeyWithError:&v27];
    id v14 = v27;

    [v11 closeWithError:0];
    if (!v13)
    {
      unint64_t v19 = MBGetDefaultLog();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v37.f_bsize = 138412802;
        *(void *)&v37.f_iosize = v7;
        WORD2(v37.f_blocks) = 2048;
        *(uint64_t *)((char *)&v37.f_blocks + 6) = a3;
        HIWORD(v37.f_bfree) = 2112;
        v37.f_bavail = (uint64_t)v14;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "=encryption key= Failed to fetch encryption key for %@ (inode:%llu): %@", (uint8_t *)&v37, 0x20u);
        _MBLog();
      }
      goto LABEL_30;
    }
    id v15 = [v13 length];
    unsigned int v16 = (void *)a1[4];
    id v26 = v14;
    unsigned __int8 v17 = [v16 setFoundEncryptionKey:v13 forVolumeMountPoint:v5 inode:a3 error:&v26];
    id v18 = v26;

    if (v17)
    {
      ++*(void *)(*(void *)(a1[6] + 8) + 24);
      unint64_t v19 = MBGetDefaultLog();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v37.f_bsize = 134218754;
        *(void *)&v37.f_iosize = v15;
        WORD2(v37.f_blocks) = 2112;
        *(uint64_t *)((char *)&v37.f_blocks + 6) = (uint64_t)v5;
        HIWORD(v37.f_bfree) = 2048;
        v37.f_bavail = a3;
        LOWORD(v37.f_files) = 2112;
        *(uint64_t *)((char *)&v37.f_files + 2) = (uint64_t)v7;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "=encryption key= Found encryption key with size %lu for %@:%llu with resolved path %@", (uint8_t *)&v37, 0x2Au);
LABEL_28:
        _MBLog();
      }
    }
    else
    {
      unint64_t v19 = MBGetDefaultLog();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v37.f_bsize = 134218498;
        *(void *)&v37.f_iosize = v15;
        WORD2(v37.f_blocks) = 2112;
        *(uint64_t *)((char *)&v37.f_blocks + 6) = (uint64_t)v5;
        HIWORD(v37.f_bfree) = 2048;
        v37.f_bavail = a3;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "=encryption key= Failed to set found encryption key with size %lu for %@:%llu", (uint8_t *)&v37, 0x20u);
        goto LABEL_28;
      }
    }
    id v14 = v18;
LABEL_30:

    id v12 = v14;
LABEL_31:

LABEL_32:
    goto LABEL_33;
  }
  if (v9)
  {
    if (!+[MBError isError:v9 withCode:4])
    {
      id v12 = v10;
      goto LABEL_33;
    }
    uint64_t v20 = (void *)a1[4];
    id v29 = v10;
    unsigned __int8 v21 = [v20 removeMissedEncryptionKeysForVolume:v5 inode:a3 error:&v29];
    id v12 = v29;

    id v22 = MBGetDefaultLog();
    id v11 = v22;
    if ((v21 & 1) == 0)
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      {
        v37.f_bsize = 138412290;
        *(void *)&v37.f_iosize = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "=encryption key= Failed to remove missed encryption key: %@", (uint8_t *)&v37, 0xCu);
        _MBLog();
      }
      goto LABEL_32;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v37.f_bsize = 138412546;
      *(void *)&v37.f_iosize = v5;
      WORD2(v37.f_blocks) = 2048;
      *(uint64_t *)((char *)&v37.f_blocks + 6) = a3;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "=encryption key= Not fetching encryption key file no longer on disk %@:%llu", (uint8_t *)&v37, 0x16u);
      _MBLog();
    }

    ++*(void *)(*(void *)(a1[5] + 8) + 24);
  }
  else
  {
    id v12 = 0;
  }
LABEL_33:

  return 1;
}

id MBAllServicePlugins()
{
  uint64_t v0 = +[NSMutableArray array];
  int v1 = objc_alloc_init(MBAccountsPlugin);
  [v0 addObject:v1];

  double v2 = objc_alloc_init(MBAppleCarePlugin);
  [v0 addObject:v2];

  id v3 = objc_alloc_init(MBDataMigratorPlugin);
  [v0 addObject:v3];

  id v4 = objc_alloc_init(MBiTunesStorePlugin);
  [v0 addObject:v4];

  id v5 = objc_alloc_init(MBKeychainPlugin);
  [v0 addObject:v5];

  id v6 = objc_alloc_init(MBLockdownPlugin);
  [v0 addObject:v6];

  id v7 = objc_alloc_init(MBCKATCBundlesPlugin);
  [v0 addObject:v7];

  ssize_t v8 = objc_alloc_init(MBWiFiPlugin);
  [v0 addObject:v8];

  id v9 = objc_alloc_init(MBBooksPlugin);
  [v0 addObject:v9];

  id v10 = objc_alloc_init(MBCameraRollPlugin);
  [v0 addObject:v10];

  id v11 = objc_alloc_init(MBManateePlugin);
  [v0 addObject:v11];

  return v0;
}

id MBAllCKPlugins()
{
  uint64_t v0 = MBAllServicePlugins();
  id v1 = [v0 mutableCopy];

  double v2 = objc_alloc_init(MBCKSQLiteCopyPlugin);
  [v1 addObject:v2];

  id v3 = objc_alloc_init(MBCKAnalysisPlugin);
  [v1 addObject:v3];

  id v4 = objc_alloc_init(MBRestoreAppsPlugin);
  [v1 addObject:v4];

  id v5 = objc_alloc_init(MBiCloudDrivePlugin);
  [v1 addObject:v5];

  id v6 = objc_alloc_init(MBFileProviderPlugin);
  [v1 addObject:v6];

  return v1;
}

void sub_10014C828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10014C84C(uint64_t a1, void *a2)
{
  double v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained _handleAccountChangeNotification:v3];
}

void sub_10014CA2C(id a1, NSString *a2, MBCKContainer *a3, BOOL *a4)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = MBGetDefaultLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    id v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetching the CK account status for persona:%{public}@", buf, 0xCu);
    _MBLog();
  }

  ssize_t v8 = [(MBCKContainer *)v6 ckContainer];

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  void v10[2] = sub_10014CB80;
  v10[3] = &unk_100414788;
  id v11 = v5;
  id v9 = v5;
  [v8 accountStatusWithCompletionHandler:v10];
}

void sub_10014CB80(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138543874;
    uint64_t v10 = v7;
    __int16 v11 = 2048;
    uint64_t v12 = a2;
    __int16 v13 = 2112;
    id v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Fetched the CK account status for persona:%{public}@ (%ld): %@", buf, 0x20u);
    _MBLog();
  }

  if (a2 == 1)
  {
    ssize_t v8 = +[NSNotificationCenter defaultCenter];
    [v8 postNotificationName:@"MBAccountAvailableNotification" object:0];
  }
}

void sub_10014CFB8(id a1)
{
  id v1 = +[CKRecordZone defaultRecordZone];
  uint64_t v2 = [v1 zoneID];
  id v3 = (void *)qword_100482548;
  qword_100482548 = v2;

  if (!qword_100482548) {
    __assert_rtn("+[MBCKDatabaseManager defaultZoneID]_block_invoke", "MBCKDatabaseManager.m", 199, "sDefaultZoneID");
  }
}

void sub_10014D080(id a1)
{
  id v1 = [objc_alloc((Class)CKRecordZoneID) initWithZoneName:@"mbksync" ownerName:CKCurrentUserDefaultName];
  uint64_t v2 = (void *)qword_100482558;
  qword_100482558 = (uint64_t)v1;

  if (!qword_100482558) {
    __assert_rtn("+[MBCKDatabaseManager syncZoneID]_block_invoke", "MBCKDatabaseManager.m", 209, "sSyncZoneID");
  }
}

void sub_10014D270(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10014D2CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10014D7B0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10014D7D0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10014D7E0(uint64_t a1)
{
}

void sub_10014D7E8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (+[MBError isCKError:v6 withCode:2])
  {
    uint64_t v7 = [v6 userInfo];
    ssize_t v8 = [v7 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
    id v9 = [v8 objectForKeyedSubscript:*(void *)(a1 + 32)];
  }
  else
  {
    id v9 = 0;
  }
  if (+[MBError isCKNotFoundError:v6]
    || +[MBError isCKNotFoundError:v9])
  {
    uint64_t v10 = MBGetDefaultLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      uint64_t v31 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Sync zone %{public}@ doesn't exist - creating a new one", buf, 0xCu);
      _MBLog();
    }

    id v12 = [objc_alloc((Class)CKRecordZone) initWithZoneID:*(void *)(a1 + 32)];
    id v13 = objc_alloc((Class)CKModifyRecordZonesOperation);
    id v34 = v12;
    id v14 = +[NSArray arrayWithObjects:&v34 count:1];
    id v15 = [v13 initWithRecordZonesToSave:v14 recordZoneIDsToDelete:0];

    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    _OWORD v26[2] = sub_10014DBB8;
    v26[3] = &unk_1004147F0;
    id v16 = *(id *)(a1 + 32);
    uint64_t v17 = *(void *)(a1 + 96);
    id v27 = v16;
    uint64_t v29 = v17;
    id v28 = *(id *)(a1 + 40);
    [v15 setModifyRecordZonesCompletionBlock:v26];
    [*(id *)(a1 + 48) _configureCKOperation:v15 container:*(void *)(a1 + 56) policy:*(void *)(a1 + 64) operationGroup:*(void *)(a1 + 72) xpcActivity:*(void *)(a1 + 80)];
    [*(id *)(a1 + 88) addOperation:v15];
  }
  else
  {
    id v18 = MBGetDefaultLog();
    unint64_t v19 = v18;
    if (v6)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 138543618;
        uint64_t v31 = v20;
        __int16 v32 = 2112;
        id v33 = v6;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to fetch sync zone %{public}@: %@", buf, 0x16u);
        _MBLog();
      }

      uint64_t v21 = *(void *)(*(void *)(a1 + 96) + 8);
      id v22 = v6;
      unint64_t v19 = *(NSObject **)(v21 + 40);
      *(void *)(v21 + 40) = v22;
    }
    else if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = *(void *)(a1 + 32);
      int v24 = [v5 objectForKeyedSubscript:v23];
      *(_DWORD *)buf = 138543618;
      uint64_t v31 = v23;
      __int16 v32 = 2048;
      id v33 = [v24 capabilities];
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Sync zone %{public}@ already exists, capabilities:0x%lx", buf, 0x16u);

      id v25 = [v5 objectForKeyedSubscript:*(void *)(a1 + 32)];
      [v25 capabilities];
      _MBLog();
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void sub_10014DBB8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  id v6 = MBGetDefaultLog();
  uint64_t v7 = v6;
  if (v5)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543618;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      id v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create sync zone %{public}@: %@", buf, 0x16u);
      _MBLog();
    }

    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    id v10 = v5;
    uint64_t v7 = *(NSObject **)(v9 + 40);
    *(void *)(v9 + 40) = v10;
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138543362;
    uint64_t v13 = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Created sync zone %{public}@", buf, 0xCu);
    _MBLog();
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_10014DD24(void *a1)
{
  uint64_t v3 = *(void *)(*(void *)(a1[7] + 8) + 40);
  id v4 = objc_opt_class();
  uint64_t v5 = a1[5];
  if (v3) {
    [v4 _clearSyncZoneFetchedWithAccount:v5];
  }
  else {
    [v4 _cacheSyncZoneFetchedWithAccount:v5];
  }
  uint64_t v6 = a1[6];
  if (v6) {
    (*(void (**)(uint64_t, void))(v6 + 16))(v6, *(void *)(*(void *)(a1[7] + 8) + 40));
  }
}

void sub_10014E318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10014E33C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (!v9) {
    goto LABEL_26;
  }
  id v10 = v9;
  uint64_t v11 = [v9 domain];
  if (![v11 isEqualToString:CKErrorDomain])
  {

    goto LABEL_19;
  }
  id v12 = [v10 code];

  if (v12 != (id)2) {
    goto LABEL_19;
  }
  id v30 = v8;
  uint64_t v31 = a1;
  id v32 = v7;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  id obj = *(id *)(a1 + 32);
  id v13 = [obj countByEnumeratingWithState:&v34 objects:v42 count:16];
  if (!v13)
  {
    id v15 = 0;
    goto LABEL_23;
  }
  id v14 = v13;
  id v15 = 0;
  uint64_t v16 = *(void *)v35;
  do
  {
    for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v35 != v16) {
        objc_enumerationMutation(obj);
      }
      uint64_t v18 = *(void *)(*((void *)&v34 + 1) + 8 * i);
      unint64_t v19 = [v10 userInfo];
      uint64_t v20 = [v19 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
      uint64_t v21 = [v20 objectForKeyedSubscript:v18];

      id v22 = [v21 domain];
      if (![v22 isEqualToString:CKErrorDomain])
      {

        goto LABEL_15;
      }
      if ([v21 code] == (id)26)
      {
      }
      else
      {
        id v23 = [v21 code];

        if (v23 != (id)11) {
          goto LABEL_15;
        }
      }
      ++v15;
LABEL_15:
    }
    id v14 = [obj countByEnumeratingWithState:&v34 objects:v42 count:16];
  }
  while (v14);
LABEL_23:

  a1 = v31;
  BOOL v29 = v15 == [*(id *)(v31 + 32) count];
  id v7 = v32;
  id v8 = v30;
  if (!v29)
  {
LABEL_19:
    int v24 = MBGetDefaultLog();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      id v25 = *(void **)(a1 + 40);
      *(_DWORD *)buf = 138543618;
      id v39 = v25;
      __int16 v40 = 2114;
      id v41 = v10;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Operation %{public}@ failed to delete all CK zones: %{public}@", buf, 0x16u);
      _MBLog();
    }

    uint64_t v26 = *(void *)(*(void *)(a1 + 56) + 8);
    id v27 = v10;
    id v28 = *(NSObject **)(v26 + 40);
    *(void *)(v26 + 40) = v27;
    goto LABEL_29;
  }

LABEL_26:
  id v28 = MBGetDefaultLog();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    id v39 = v8;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Successfully deleted CK zones: %{public}@", buf, 0xCu);
    _MBLog();
  }
  id v27 = 0;
LABEL_29:

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_10014F944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10014F990(uint64_t a1, void *a2, void *a3)
{
  id v11 = a2;
  id v5 = a3;
  uint64_t v6 = v5;
  if (v5)
  {
    id v7 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    id v8 = v5;
  }
  else
  {
    id v7 = (void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    id v8 = v11;
  }
  id v9 = v8;
  uint64_t v10 = *v7;
  *id v7 = v9;

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10014FB2C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001500A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  objc_sync_exit(v10);
  _Unwind_Resume(a1);
}

void sub_1001500F4(uint64_t a1)
{
}

void sub_1001500FC(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1001501F8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001503C4(uint64_t a1)
{
  uint64_t v3 = [*(id *)(a1 + 32) _makeContainerForAccount:*(void *)(a1 + 40)];
  if (v3)
  {
    id v4 = +[MBCKOperationPolicy expensiveCellularPolicy];
    id v5 = [v4 operationGroupWithName:@"fetchConfiguration" processName:0];
    [*(id *)(a1 + 48) loadConfigurationWithContainer:v3 databaseManager:*(void *)(a1 + 32) policy:v4 operationGroup:v5 completion:*(void *)(a1 + 56)];
  }
  else
  {
    id v4 = +[MBError errorWithCode:1 format:@"nil container"];
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
}

void sub_100152A58(void *a1)
{
}

uint64_t sub_100152A9C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  objc_sync_enter(v2);
  if (([*(id *)(a1 + 32) isCanceled] & 1) != 0
    || (id v3 = (id)*(int *)(a1 + 40),
        [*(id *)(*(void *)(a1 + 32) + 136) softConsecutiveRetryLimit] == v3))
  {
    uint64_t v4 = 0;
  }
  else
  {
    [*(id *)(a1 + 32) disableCancel];
    objc_msgSend(*(id *)(*(void *)(a1 + 32) + 120), "forceRefreshForBackupUDID:", objc_msgSend(*(id *)(a1 + 32), "backupUDID"));
    uint64_t v4 = 1;
  }
  objc_sync_exit(v2);
  return v4;
}

void sub_100152B44(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10015322C(_Unwind_Exception *a1)
{
}

void sub_100153278(void *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x100153130);
  }
  JUMPOUT(0x100153270);
}

int64_t sub_100153298(id a1, id a2, id a3)
{
  if ([a2 isAppDomain])
  {
    if ([a2 isPlaceholderAppDomain]) {
      int v5 = 1;
    }
    else {
      int v5 = 2;
    }
  }
  else
  {
    int v5 = 0;
  }
  if ([a3 isAppDomain])
  {
    if ([a3 isPlaceholderAppDomain]) {
      int v6 = 1;
    }
    else {
      int v6 = 2;
    }
  }
  else
  {
    int v6 = 0;
  }
  if (v5 == v6)
  {
    id v7 = [a2 name];
    id v8 = [a3 name];
    return (int64_t)[v7 compare:v8];
  }
  else
  {
    if ([a2 isAppDomain])
    {
      if ([a2 isPlaceholderAppDomain]) {
        unsigned int v10 = 1;
      }
      else {
        unsigned int v10 = 2;
      }
    }
    else
    {
      unsigned int v10 = 0;
    }
    if ([a3 isAppDomain])
    {
      if ([a3 isPlaceholderAppDomain]) {
        unsigned int v11 = 1;
      }
      else {
        unsigned int v11 = 2;
      }
    }
    else
    {
      unsigned int v11 = 0;
    }
    if (v10 >= v11)
    {
      if ([a2 isAppDomain])
      {
        if ([a2 isPlaceholderAppDomain]) {
          int v12 = 1;
        }
        else {
          int v12 = 2;
        }
      }
      else
      {
        int v12 = 0;
      }
      if ([a3 isAppDomain])
      {
        if ([a3 isPlaceholderAppDomain]) {
          int v13 = 1;
        }
        else {
          int v13 = 2;
        }
      }
      else
      {
        int v13 = 0;
      }
      return v12 != v13;
    }
    else
    {
      return -1;
    }
  }
}

void sub_100153AA8(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x100153974);
  }
  _Unwind_Resume(exc_buf);
}

void sub_100154EA8(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x100154D5CLL);
  }
  _Unwind_Resume(exc_buf);
}

void MBPerformOnMBSCachePoolSerialQueue(void *a1)
{
  if (qword_100482580 != -1) {
    dispatch_once(&qword_100482580, &stru_1004149E0);
  }
  uint64_t v2 = qword_100482578;
  dispatch_assert_queue_not_V2((dispatch_queue_t)qword_100482578);
  dispatch_sync(v2, a1);
}

id MBPerformWithCache(uint64_t a1)
{
  id v2 = objc_msgSend(+[MBSCachePool sharedPool](MBSCachePool, "sharedPool"), "acquireCache");
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10015A0F0;
  v4[3] = &unk_100414928;
  void v4[4] = v2;
  v4[5] = a1;
  MBPerformOnMBSCachePoolSerialQueue(v4);
  return objc_msgSend(+[MBSCachePool sharedPool](MBSCachePool, "sharedPool"), "releaseCache:", v2);
}

id sub_10015A0F0(uint64_t a1)
{
  [*(id *)(a1 + 32) begin];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(void **)(a1 + 32);
  return [v2 end];
}

void sub_10015A180(id a1)
{
  qword_100482568 = objc_alloc_init(MBSCachePool);
}

void sub_10015A3AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10015A3CC(uint64_t a1, uint64_t a2)
{
}

void sub_10015A3DC(uint64_t a1)
{
}

uint64_t sub_10015A3E8(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) count])
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(*(void *)(a1 + 32) + 8) objectAtIndexedSubscript:0];
    [*(id *)(*(void *)(a1 + 32) + 8) removeObjectAtIndex:0];
    id v2 = MBGetDefaultLog();
    uint64_t result = os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    *(_DWORD *)buf = 134217984;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Re-using cache from pool: %p", buf, 0xCu);
  }
  else
  {
    int v5 = MBGetDefaultLog();
    uint64_t result = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Cache pool is empty", buf, 2u);
  }
  return _MBLog();
}

id sub_10015A5B8(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 8) count];
  id v3 = MBGetDefaultLog();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
  if ((unint64_t)v2 > 7)
  {
    if (v4)
    {
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 134217984;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Not adding to cache because pool is full: %p", buf, 0xCu);
      uint64_t v8 = *(void *)(a1 + 40);
      _MBLog();
    }
    return objc_msgSend(*(id *)(a1 + 32), "_closeCache:", *(void *)(a1 + 40), v8);
  }
  else
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 134217984;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Adding cache to pool: %p", buf, 0xCu);
      uint64_t v8 = *(void *)(a1 + 40);
      _MBLog();
    }
    objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "addObject:", *(void *)(a1 + 40), v8);

    return [*(id *)(a1 + 32) _scheduleDrain];
  }
}

id sub_10015A87C(uint64_t a1)
{
  [*(id *)(a1 + 32) open];
  id v2 = +[MBAppManager appManagerWithSettingsContext:objc_alloc_init(MBSettingsContext)];
  uint64_t v6 = 0;
  id v3 = +[MBPersona personalPersonaWithError:&v6];
  if (!v3) {
    __assert_rtn("-[MBSCachePool _openCache]_block_invoke", "MBSCachePool.m", 138, "personalPersona");
  }
  if (![(MBAppManager *)v2 loadAppsWithPersona:v3 safeHarbors:0 dataSeparatedBundleIDs:0 error:&v6])
  {
    id v5 = objc_alloc((Class)MBException);
    objc_exception_throw([v5 initWithCode:1, @"Error loading apps: %@", +[MBError descriptionForError:](MBError, "descriptionForError:", v6) format]);
  }
  return objc_msgSend(*(id *)(a1 + 32), "setDisabledDomainNames:restrictedDomainNames:", -[MBAppManager allDisabledDomainNames](v2, "allDisabledDomainNames"), -[MBAppManager allRestrictedDomainNames](v2, "allRestrictedDomainNames"));
}

id sub_10015ABC8(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _drain];
}

void sub_10015AD30(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_100482578 = (uint64_t)dispatch_queue_create("com.apple.backupd.MBSCachePool", v1);
}

id MBKeybagUUIDForEncryptionKey(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = MKBBackupCopyBackupKeyUUID();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = MBGetDefaultLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Failed to get UUID from encryption key %@", buf, 0xCu);
      _MBLog();
    }

    if (a2)
    {
      *a2 = +[MBKeyBag errorWithReturnCode:v5 description:@"MKBBackupCopyBackupKeyUUID error"];
    }
  }

  return 0;
}

NSURL *MBServiceConfigurationURL()
{
  CFStringRef v0 = (id)CFPreferencesCopyValue(@"ConfigurationURL", @"com.apple.MobileBackup", kMBMobileUserName, kCFPreferencesAnyHost);
  if (v0) {
    CFStringRef v1 = v0;
  }
  else {
    CFStringRef v1 = @"https://configuration.apple.com/configurations/internetservices/mobileme/mobilebackup/mobilebackup-1.0.plist";
  }
  id v2 = +[NSURL URLWithString:v1];
  if (!v2) {
    [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"NSURL *MBServiceConfigurationURL(void)"], @"MBServiceConfiguration.m", 22, @"Invalid configuration URL: %@", v1 file lineNumber description];
  }
  return v2;
}

MBError *MBNotifyPluginsBlock(void *a1, void *a2, SEL sel, uint64_t a4)
{
  Name = sel_getName(sel);
  uint64_t v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    id v46 = Name;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Starting to notify plugins of %{public}s", buf, 0xCu);
    id v33 = Name;
    _MBLog();
  }
  +[NSDate timeIntervalSinceReferenceDate];
  double v8 = v7;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  id v9 = [a2 countByEnumeratingWithState:&v41 objects:v51 count:16];
  if (v9)
  {
    id v10 = v9;
    unsigned int v11 = 0;
    uint64_t v12 = *(void *)v42;
    uint64_t v37 = *(void *)v42;
    while (2)
    {
      int v13 = 0;
      id v38 = v10;
      do
      {
        if (*(void *)v42 != v12) {
          objc_enumerationMutation(a2);
        }
        uint64_t v14 = *(void *)(*((void *)&v41 + 1) + 8 * (void)v13);
        if ([a1 isCanceled])
        {
          *(double *)&id v22 = COERCE_DOUBLE(+[MBError errorWithCode:202 description:@"Canceled"]);
LABEL_24:
          goto LABEL_25;
        }
        if (objc_opt_respondsToSelector())
        {
          uint64_t v16 = a1;
          uint64_t v17 = (objc_class *)objc_opt_class();
          uint64_t v18 = class_getName(v17);
          unint64_t v19 = MBGetDefaultLog();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            id v46 = v18;
            __int16 v47 = 2082;
            id v48 = Name;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Notifying %{public}s of %{public}s", buf, 0x16u);
            long long v34 = v18;
            long long v35 = Name;
            _MBLog();
          }
          +[NSDate timeIntervalSinceReferenceDate];
          double v21 = v20;
          *(double *)&id v22 = COERCE_DOUBLE((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, v14));
          +[NSDate timeIntervalSinceReferenceDate];
          if (*(double *)&v22 != 0.0)
          {
            id v27 = v22;
            id v28 = MBGetDefaultLog();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              id v46 = v18;
              __int16 v47 = 2082;
              id v48 = Name;
              __int16 v49 = 2112;
              double v50 = *(double *)&v22;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to notify %{public}s of %{public}s: %@", buf, 0x20u);
              long long v35 = Name;
              double v36 = *(double *)&v22;
              long long v34 = v18;
              _MBLog();
            }
            goto LABEL_24;
          }
          double v24 = v23;
          id v25 = MBGetDefaultLog();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            double v26 = v24 - v21;
            *(_DWORD *)buf = 136446722;
            id v46 = v18;
            __int16 v47 = 2082;
            id v48 = Name;
            __int16 v49 = 2048;
            double v50 = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Notified %{public}s of %{public}s in %0.3fs", buf, 0x20u);
            double v36 = v26;
            long long v34 = v18;
            long long v35 = Name;
            _MBLog();
          }
          ++v11;
          a1 = v16;
          uint64_t v12 = v37;
          id v10 = v38;
        }
        int v13 = (char *)v13 + 1;
      }
      while (v10 != v13);
      id v10 = [a2 countByEnumeratingWithState:&v41 objects:v51 count:16];
      if (v10) {
        continue;
      }
      break;
    }
  }
  else
  {
    unsigned int v11 = 0;
  }
  *(double *)&id v22 = 0.0;
LABEL_25:
  +[NSDate timeIntervalSinceReferenceDate];
  double v30 = v29;
  uint64_t v31 = MBGetDefaultLog();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134218498;
    id v46 = v11;
    __int16 v47 = 2082;
    id v48 = Name;
    __int16 v49 = 2048;
    double v50 = v30 - v8;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "Notified %lu plugins of %{public}s in %0.3fs", buf, 0x20u);
    _MBLog();
  }
  return v22;
}

MBError *MBNotifyPlugins(void *a1, void *a2, const char *a3, uint64_t a4)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  uint64_t v5[2] = sub_10015C540;
  v5[3] = &unk_100414A08;
  void v5[4] = a4;
  v5[5] = a3;
  return MBNotifyPluginsBlock(a1, a2, a3, (uint64_t)v5);
}

id sub_10015C540(uint64_t a1, void *a2)
{
  return [a2 performSelector:*(void *)(a1 + 40) withObject:*(void *)(a1 + 32)];
}

MBError *MBNotifyPlugins2(void *a1, void *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10015C5BC;
  void v6[3] = &unk_100414A30;
  v6[5] = a5;
  v6[6] = a3;
  void v6[4] = a4;
  return MBNotifyPluginsBlock(a1, a2, a3, (uint64_t)v6);
}

id sub_10015C5BC(void *a1, void *a2)
{
  return _[a2 performSelector:a1[6] withObject:a1[4] withObject:a1[5]];
}

void sub_10015D448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
}

void sub_10015D464(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (xpc_activity_get_state(v3))
    {
      if (xpc_activity_should_defer(v3))
      {
        BOOL v5 = xpc_activity_set_state(v3, 3);
        uint64_t v6 = MBGetDefaultLog();
        BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
        if (v5)
        {
          if (v7)
          {
            uint64_t v8 = *(void *)(a1 + 32);
            *(_DWORD *)buf = 138412290;
            uint64_t v34 = v8;
LABEL_19:
            _MBLog();
            goto LABEL_29;
          }
        }
        else if (v7)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 138412290;
          uint64_t v34 = v23;
          goto LABEL_19;
        }
        goto LABEL_29;
      }
      xpc_activity_state_t state = xpc_activity_get_state(v3);
      uint64_t v6 = xpc_activity_copy_criteria(v3);
      if (state == 2)
      {
        BOOL v15 = xpc_activity_set_state(v3, 5);
        uint64_t v16 = *(void *)(a1 + 32);
        uint64_t v17 = +[NSUUID UUID];
        uint64_t v18 = [v17 UUIDString];
        unint64_t v19 = +[NSString stringWithFormat:@"%@-%@", v16, v18];

        uint64_t v12 = v19;
        [v12 UTF8String];
        double v20 = (void *)os_transaction_create();
        double v21 = MBGetDefaultLog();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 138412546;
          uint64_t v34 = v22;
          __int16 v35 = 1024;
          LODWORD(v36) = v15;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "MBXPCTimer triggered. Updating to done so that it can be cleaned. success : %@ : %d", buf, 0x12u);
          _MBLog();
        }

        (*(void (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), WeakRetained);
        goto LABEL_28;
      }
      uint64_t v12 = MBGetDefaultLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 138412802;
        uint64_t v34 = v24;
        __int16 v35 = 2048;
        xpc_activity_state_t v36 = state;
        __int16 v37 = 2048;
        id v38 = v6;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "MBXPCTimer %@ changed to state %ld with criteria %p", buf, 0x20u);
        goto LABEL_22;
      }
    }
    else
    {
      [WeakRetained setActivity:v3];
      uint64_t v6 = xpc_activity_copy_criteria(v3);
      if (!v6)
      {
        id v25 = MBGetDefaultLog();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = *(void *)(a1 + 32);
          id v27 = [WeakRetained criteria];
          *(_DWORD *)buf = 138412546;
          uint64_t v34 = v26;
          __int16 v35 = 2112;
          xpc_activity_state_t v36 = (xpc_activity_state_t)v27;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "MBXPCTimer Check-in: %@, with criteria: %@", buf, 0x16u);

          uint64_t v31 = [WeakRetained criteria];
          _MBLog();
        }
        uint64_t v12 = [WeakRetained criteria];
        xpc_activity_set_criteria(v3, v12);
        goto LABEL_28;
      }
      id v10 = [WeakRetained criteria];
      BOOL v11 = xpc_equal(v10, v6);

      if (!v11)
      {
        id v28 = [WeakRetained criteria];
        xpc_activity_set_criteria(v3, v28);

        uint64_t v12 = MBGetDefaultLog();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = *(void *)(a1 + 32);
          double v30 = [WeakRetained criteria];
          *(_DWORD *)buf = 138412546;
          uint64_t v34 = v29;
          __int16 v35 = 2112;
          xpc_activity_state_t v36 = (xpc_activity_state_t)v30;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "MBXPCTimer Check-in: %@, with updating criteria: %@", buf, 0x16u);

          id v32 = [WeakRetained criteria];
          _MBLog();
        }
        goto LABEL_28;
      }
      uint64_t v12 = MBGetDefaultLog();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 138412546;
        uint64_t v34 = v13;
        __int16 v35 = 2112;
        xpc_activity_state_t v36 = (xpc_activity_state_t)v6;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "MBXPCTimer Check-in: %@, with existing criteria: %@", buf, 0x16u);
LABEL_22:
        _MBLog();
      }
    }
LABEL_28:

    goto LABEL_29;
  }
  uint64_t v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v34 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Self not available anymore for - %@", buf, 0xCu);
    goto LABEL_19;
  }
LABEL_29:
}

void sub_100160740(uint64_t a1)
{
  if (!sub_1001607D8(@"iCloud Backup Verification Failure", @"Could not verify the last backup")) {
    [*(id *)(a1 + 32) _fileTTR:@"iCloud Backup Verification Failure" classification:0 componentID:0 componentName:0 componentVersion:0 description:0 reproducibility:0 attachment:0];
  }
  id v2 = +[MBDaemon sharedDaemon];
  [v2 releaseWorkAssertion:*(void *)(a1 + 40)];
}

CFOptionFlags sub_1001607D8(void *a1, void *a2)
{
  id v3 = a2;
  v16[0] = kCFUserNotificationAlertHeaderKey;
  v16[1] = kCFUserNotificationAlertMessageKey;
  v17[0] = a1;
  v17[1] = v3;
  void v16[2] = kCFUserNotificationDefaultButtonTitleKey;
  void v16[3] = kCFUserNotificationAlternateButtonTitleKey;
  v17[2] = @"Open with Tap-to-Radar";
  v17[3] = @"Ignore";
  id v4 = a1;
  CFDictionaryRef v5 = +[NSDictionary dictionaryWithObjects:v17 forKeys:v16 count:4];

  uint64_t v6 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, 0, v5);
  BOOL v7 = MBGetDefaultLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412546;
    CFOptionFlags v13 = (CFOptionFlags)v3;
    __int16 v14 = 2048;
    BOOL v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "=ttr= Posted internal notification about %@ %p", buf, 0x16u);
    _MBLog();
  }

  CFOptionFlags responseFlags = 0;
  CFUserNotificationReceiveResponse(v6, 0.0, &responseFlags);
  CFOptionFlags v8 = responseFlags & 3;
  uint64_t v9 = MBGetDefaultLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134218240;
    CFOptionFlags v13 = v8;
    __int16 v14 = 2048;
    BOOL v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "=ttr= Received response (%lu) from internal notification %p", buf, 0x16u);
    _MBLog();
  }

  return v8;
}

void sub_100160AB0(uint64_t a1)
{
  if (!sub_1001607D8(@"iCloud Restore Failure", @"Lightrail restore failure")) {
    [*(id *)(a1 + 32) _fileTTR:@"Lightrail Restore Failure" classification:0 componentID:0 componentName:0 componentVersion:0 description:0 reproducibility:0 attachment:0];
  }
  id v2 = +[MBDaemon sharedDaemon];
  [v2 releaseWorkAssertion:*(void *)(a1 + 40)];
}

void sub_100160FE0(uint64_t a1)
{
  if (!sub_1001607D8(@"iCloud Backup", @"Lightrail Dry Restore Failure"))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    [*(id *)(a1 + 48) _fileTTR:@"Lightrail Dry Restore Failure" classification:@"Serious Bug" componentID:0 componentName:0 componentVersion:@"iCloud" description:*(void *)(a1 + 32) reproducibility:@"I Didn't Try" attachment:0];
  }
  id v3 = +[MBDaemon sharedDaemon];
  [v3 releaseWorkAssertion:*(void *)(a1 + 56)];
}

void sub_1001616A0(uint64_t a1)
{
  if (!sub_1001607D8(@"iCloud Restore Failure", @"Errors detected while background restoring")) {
    [*(id *)(a1 + 48) _fileTTR:@"Background Restore Failure" classification:0 componentID:0 componentName:0 componentVersion:0 description:*(void *)(a1 + 32) reproducibility:0 attachment:*(void *)(a1 + 40)];
  }
  id v2 = +[MBDaemon sharedDaemon];
  [v2 releaseWorkAssertion:*(void *)(a1 + 56)];
}

uint64_t sub_10016184C(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6)
{
  BOOL v11 = *(void **)(a1 + 32);
  uint64_t v12 = a5;
  id v13 = a4;
  id v14 = a3;
  [v11 addObject:v13];
  BOOL v15 = +[MBError dictionaryRepresentationForError:v14];

  uint64_t v16 = *(void **)(a1 + 40);
  v23[0] = v15;
  v22[0] = @"failure";
  v22[1] = @"count";
  uint64_t v17 = +[NSNumber numberWithUnsignedInteger:a2];
  v23[1] = v17;
  v23[2] = v13;
  void v22[2] = @"domainName";
  _OWORD v22[3] = @"rpath";
  CFStringRef v18 = &stru_100418BA8;
  if (v12) {
    CFStringRef v18 = v12;
  }
  v23[3] = v18;
  void v22[4] = @"inode";
  unint64_t v19 = +[NSNumber numberWithUnsignedLongLong:a6];
  v23[4] = v19;
  double v20 = +[NSDictionary dictionaryWithObjects:v23 forKeys:v22 count:5];
  [v16 addObject:v20];

  return 1;
}

BOOL WriteKeychainToDisk(uint64_t a1)
{
  CFStringRef v1 = (void *)__chkstk_darwin(a1);
  id v3 = v2;
  id v4 = v1;
  if (!v4) {
    __assert_rtn("WriteKeychainToDisk", "MBKeychainPlugin.m", 47, "path");
  }
  if (!v3) {
    __assert_rtn("WriteKeychainToDisk", "MBKeychainPlugin.m", 48, "errorPtr");
  }
  CFDictionaryRef v5 = v4;
  uint64_t v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)id v45 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Saving keychain data to %@", buf, 0xCu);
    _MBLog();
  }

  BOOL v7 = +[NSDate now];
  id v8 = [v5 stringByAppendingString:@".tmp"];
  uint64_t v9 = (const char *)[v8 fileSystemRepresentation];
  int v10 = open_dprotected_np(v9, 1538, 1, 0, 256);
  if (v10 < 0)
  {
    *id v3 = +[MBError errorWithErrno:*__error() path:v8 format:@"Error writing keychain temp file (open_dprotected_np)"];
    uint64_t v16 = MBGetDefaultLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = *v3;
      *(_DWORD *)buf = 138412290;
      *(void *)id v45 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "open_dprotected_np failed: %@", buf, 0xCu);
      _MBLog();
    }
    goto LABEL_29;
  }
  unlink(v9);
  if ((_SecKeychainWriteBackupToFileDescriptor() & 1) == 0)
  {
    CFStringRef v18 = [0 domain];
    if ([v18 isEqualToString:NSOSStatusErrorDomain])
    {
      BOOL v19 = [0 code] == (id)-36;

      if (v19) {
        uint64_t v20 = 106;
      }
      else {
        uint64_t v20 = 100;
      }
    }
    else
    {

      uint64_t v20 = 100;
    }
    *id v3 = +[MBError errorWithCode:v20 error:0 path:v8 format:@"Error writing keychain temp file"];
    id v14 = MBGetDefaultLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = *v3;
      *(_DWORD *)buf = 138412290;
      *(void *)id v45 = v21;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "_SecKeychainWriteBackupToFileDescriptor failed: %@", buf, 0xCu);
      _MBLog();
    }
    goto LABEL_24;
  }
  [v7 timeIntervalSinceNow];
  double v12 = v11;
  id v13 = MBGetDefaultLog();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)id v45 = v10;
    *(_WORD *)&void v45[4] = 2048;
    *(double *)&v45[6] = -v12;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Wrote keychain data to anonymous fd (%d) in %.3fs", buf, 0x12u);
    _MBLog();
  }

  if (lseek(v10, 0, 2) <= 0)
  {
    *id v3 = +[MBError errorWithErrno:*__error() path:v8 format:@"Keychain temp file contains no data"];
    id v14 = MBGetDefaultLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = *v3;
      *(_DWORD *)buf = 138412290;
      *(void *)id v45 = v22;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "_SecKeychainWriteBackupToFileDescriptor wrote no data: %@", buf, 0xCu);
      _MBLog();
    }
    goto LABEL_24;
  }
  if (lseek(v10, 0, 0))
  {
    *id v3 = +[MBError errorWithErrno:*__error() path:v8 format:@"lseek error"];
    id v14 = MBGetDefaultLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = *v3;
      *(_DWORD *)buf = 138412290;
      *(void *)id v45 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to seek to the beginning of the temp file: %@", buf, 0xCu);
      _MBLog();
    }
LABEL_24:

    int v23 = 1;
    goto LABEL_25;
  }
  id v28 = v5;
  uint64_t v29 = (const char *)[v28 fileSystemRepresentation];
  int v30 = open_dprotected_np(v29, 1537, 1, 0, 256);
  if (v30 <= 0)
  {
    *id v3 = +[MBError errorWithErrno:*__error() path:v28 format:@"Error opening keychain backup (open_dprotected_np)"];
    id v14 = MBGetDefaultLog();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v35 = *v3;
      *(_DWORD *)buf = 138412290;
      *(void *)id v45 = v35;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "open_dprotected_np failed: %@", buf, 0xCu);
      _MBLog();
    }
    goto LABEL_24;
  }
  bzero(buf, 0x1000uLL);
  do
  {
    ssize_t v31 = read(v10, buf, 0x1000uLL);
    if (v31 < 0)
    {
      *id v3 = +[MBError errorWithErrno:*__error() path:v8 format:@"failed reading keychain temp FD"];
      xpc_activity_state_t v36 = MBGetDefaultLog();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = *v3;
        *(_DWORD *)__int16 v40 = 138412290;
        *(void *)long long v41 = v37;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "reading keychain temp FD failed: %@", v40, 0xCu);
        _MBLog();
      }

      goto LABEL_49;
    }
    if (write(v30, buf, v31) < 0)
    {
      *id v3 = +[MBError errorWithErrno:*__error() path:v28 format:@"failed writing keychain backup file"];
      id v38 = MBGetDefaultLog();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        uint64_t v39 = *v3;
        *(_DWORD *)__int16 v40 = 138412290;
        *(void *)long long v41 = v39;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "writing keychain backup file failed: %@", v40, 0xCu);
        _MBLog();
      }

      unlink(v29);
LABEL_49:
      int v23 = 1;
      goto LABEL_50;
    }
  }
  while (v31);
  id v32 = MBGetDefaultLog();
  if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
  {
    id v33 = v32;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
    {
      [v7 timeIntervalSinceNow];
      *(_DWORD *)__int16 v40 = 67109634;
      *(_DWORD *)long long v41 = v10;
      *(_WORD *)&v41[4] = 2112;
      *(void *)&v41[6] = v28;
      __int16 v42 = 2048;
      double v43 = v12 - v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "Copied keychain data from anonymous fd (%d) to %@ in %.3fs", v40, 0x1Cu);
    }

    [v7 timeIntervalSinceNow];
    _MBLog();
  }

  int v23 = 0;
LABEL_50:
  close(v30);
LABEL_25:

  close(v10);
  if (!v23)
  {
    [v7 timeIntervalSinceNow];
    double v26 = v25;
    uint64_t v16 = MBGetDefaultLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412546;
      *(void *)id v45 = v5;
      *(_WORD *)&v45[8] = 2048;
      *(double *)&v45[10] = -v26;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "Exported keychain data to %@ in %.3fs", buf, 0x16u);
      _MBLog();
    }
LABEL_29:

    BOOL v24 = v10 >= 0;
    goto LABEL_30;
  }
  BOOL v24 = 0;
LABEL_30:

  return v24;
}

void sub_10016430C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1001642ACLL);
  }
  _Unwind_Resume(exception_object);
}

BOOL RestoreKeychainFromDisk(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a1;
  if (!v6) {
    __assert_rtn("RestoreKeychainFromDisk", "MBKeychainPlugin.m", 147, "path");
  }
  if (!a2) {
    __assert_rtn("RestoreKeychainFromDisk", "MBKeychainPlugin.m", 148, "keybagData");
  }
  if (!a4) {
    __assert_rtn("RestoreKeychainFromDisk", "MBKeychainPlugin.m", 149, "errorPtr");
  }
  BOOL v7 = v6;
  id v8 = MBGetDefaultLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)double v34 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Restoring keychain backup at %@", buf, 0xCu);
    id v28 = v7;
    _MBLog();
  }

  id v32 = 0;
  uint64_t v9 = +[MBKeychain allPasswordItemsForServices:&off_10043B418 error:&v32];
  id v10 = v32;
  double v11 = MBGetDefaultLog();
  double v12 = v11;
  if (v9)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v13 = [v9 count];
      id v14 = MBStringWithArray();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)double v34 = v13;
      *(_WORD *)&v34[4] = 2112;
      *(void *)&v34[6] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Preserving %d keychain items: %@", buf, 0x12u);

      id v15 = [v9 count];
      MBStringWithArray();
      v29 = id v28 = v15;
      _MBLog();
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)double v34 = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Unable to fetch keychain items: %@", buf, 0xCu);
    id v28 = v10;
    _MBLog();
  }

  id v31 = 0;
  unsigned int v16 = +[MBProtectionClassUtils getWithPath:v7 error:&v31];
  id v17 = v31;
  if (v16 == 1)
  {
    CFStringRef v18 = +[NSFileHandle fileHandleForReadingAtPath:v7];
    BOOL v19 = v18;
    BOOL v20 = v18 != 0;
    if (v18)
    {
      v30[1] = 0;
      [v18 fileDescriptor];
      char v21 = _SecKeychainRestoreBackupFromFileDescriptor();

      if ((v21 & 1) == 0)
      {
        uint64_t v22 = MBGetDefaultLog();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412546;
          *(void *)double v34 = v7;
          *(_WORD *)&v34[8] = 2112;
          *(void *)&v34[10] = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to restore keychain from %@: %@", buf, 0x16u);
          id v28 = v7;
          uint64_t v29 = 0;
          _MBLog();
        }

        *a4 = 0;
      }
      if (objc_msgSend(v9, "count", v28, v29))
      {
        v30[0] = 0;
        unsigned __int8 v23 = +[MBKeychain addAllPasswordItems:v9 error:v30];
        id v17 = v30[0];

        BOOL v24 = MBGetDefaultLog();
        double v25 = v24;
        if (v23)
        {
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v26 = [v9 count];
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)double v34 = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Added %d preserved keychain items to restored keychain", buf, 8u);
            [v9 count];
LABEL_29:
            _MBLog();
          }
        }
        else if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)double v34 = v17;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to add preserved password items to keychain: %@", buf, 0xCu);
          goto LABEL_29;
        }

        goto LABEL_31;
      }
      id v17 = 0;
    }
    else
    {
      *a4 = +[MBError errorWithCode:101 path:v7 format:@"Error reading keychain backup"];
    }
LABEL_31:

    goto LABEL_32;
  }
  if (v16 == 255) {
    +[MBError errorWithCode:101 error:v17 path:v7 format:@"Error getting keychain backup protection class"];
  }
  else {
    +[MBError errorWithCode:1, v7, @"Unexpected keychain backup protection class: %d", v16 path format];
  }
  BOOL v20 = 0;
  *a4 = (id)objc_claimAutoreleasedReturnValue();
LABEL_32:

  return v20;
}

id MBFetchBackupCKRecordsAndPopulateDB(void *a1, void *a2, uint64_t *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (!a3) {
    __assert_rtn("MBFetchBackupCKRecordsAndPopulateDB", "MBCKBackupRecordsFetch.m", 125, "error");
  }
  BOOL v7 = v6;
  id v8 = +[MBCKBackupRecordsDB openDatabaseIn:v6 readOnly:1 error:a3];
  id v9 = v8;
  if (v8)
  {
    id v10 = [v8 close:a3];
LABEL_46:

    goto LABEL_47;
  }
  double v11 = +[MBCKBackupRecordsDB openOrCreateDatabaseIn:v7 error:a3];
  if (v11)
  {
    id v9 = v11;
    id v50 = v5;
    double v12 = +[MBCKManager sharedInstance];
    __int16 v49 = [v12 openCacheWithAccount:v50 accessType:1 error:a3];
    if (!v49)
    {
      int v30 = 0;
LABEL_45:

      id v10 = (id)(v30 & [v9 close:a3]);
      goto LABEL_46;
    }
    id v48 = +[MBCKOperationPolicy expensiveCellularPolicy];
    [v48 setFetchAssets:0];
    unsigned int v13 = [v12 databaseManager];
    __int16 v47 = +[MBCKOperationTracker operationTrackerWithAccount:v50 databaseManager:v13 policy:v48 error:a3];

    if (!v47)
    {
      int v30 = 0;
LABEL_44:

      goto LABEL_45;
    }
    id v14 = [v48 operationGroupWithName:@"fetchCKBackupRecordsAndPopulateDB" processName:0];
    [v47 setCkOperationGroup:v14];

    id v15 = +[MBCKAccount fetchAccountWithOperationTracker:v47 cache:v49 error:a3];
    id v46 = v15;
    if (v15)
    {
      if (![v15 fetchDevicesWithOperationTracker:v47 error:a3])
      {
        int v30 = 0;
LABEL_43:

        goto LABEL_44;
      }
      unsigned int v16 = MBDeviceUUID();
      os_log_t oslog = [v46 deviceForUUID:v16];

      if ([oslog fetchSnapshotsWithOperationTracker:v47 error:a3])
      {
        uint64_t v67 = 0;
        id v68 = &v67;
        uint64_t v69 = 0x3032000000;
        unsigned __int8 v70 = sub_100166FF0;
        id v71 = sub_100167000;
        id v72 = 0;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        id obj = [oslog snapshots];
        id v37 = [obj countByEnumeratingWithState:&v63 objects:buf count:16];
        if (v37)
        {
          uint64_t v38 = *(void *)v64;
          while (2)
          {
            for (uint64_t i = 0; i != v37; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v64 != v38) {
                objc_enumerationMutation(obj);
              }
              id v17 = *(void **)(*((void *)&v63 + 1) + 8 * i);
              if (([v9 insertSnapshotRecord:v17 error:a3] & 1) == 0)
              {
                id v33 = MBGetDefaultLog();
                if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                {
                  log = v33;
                  if (os_log_type_enabled(&log->super, OS_LOG_TYPE_ERROR))
                  {
                    double v34 = [v17 recordIDString];
                    uint64_t v35 = *a3;
                    *(_DWORD *)id v74 = 138412546;
                    id v75 = v34;
                    __int16 v76 = 2112;
                    uint64_t v77 = v35;
                    _os_log_impl((void *)&_mh_execute_header, &log->super, OS_LOG_TYPE_ERROR, "Failed to insert snapshot record into MBCKBackupRecordsDB %@: %@", v74, 0x16u);
                  }
                  id v43 = [v17 recordIDString];
                  _MBLog();
LABEL_39:
                }
                else
                {
                }
                int v30 = 0;
                goto LABEL_41;
              }
              log = [[MBCKBatchFetch alloc] initWithOperationTracker:v47];
              long long v61 = 0u;
              long long v62 = 0u;
              long long v59 = 0u;
              long long v60 = 0u;
              CFStringRef v18 = [v17 modifiedDomainRecordReferences];
              id v19 = [v18 countByEnumeratingWithState:&v59 objects:v73 count:16];
              id v43 = v18;
              if (v19)
              {
                uint64_t v39 = *(void *)v60;
                do
                {
                  uint64_t v20 = 0;
                  id v36 = v19;
                  while (2)
                  {
                    if (*(void *)v60 != v39) {
                      objc_enumerationMutation(v43);
                    }
                    unint64_t v21 = 0;
                    uint64_t v40 = v20;
                    uint64_t v22 = *(void **)(*((void *)&v59 + 1) + 8 * v20);
                    while ((unint64_t)[v22 pageCount] > v21)
                    {
                      unsigned __int8 v23 = [v22 baseRecordID];
                      BOOL v24 = +[MBDomainRecord recordIDFromBaseRecordID:v23 pageIndex:v21];

                      double v25 = (void *)v68[5];
                      if (v25)
                      {
                        *a3 = (uint64_t)v25;

                        goto LABEL_39;
                      }
                      v54[0] = _NSConcreteStackBlock;
                      v54[1] = 3221225472;
                      v54[2] = sub_100167008;
                      v54[3] = &unk_100414B20;
                      id v58 = &v67;
                      id v55 = v9;
                      __int16 v56 = v17;
                      id v26 = v24;
                      id v57 = v26;
                      [(MBCKBatchFetch *)log fetchRecordWithID:v26 completion:v54];

                      ++v21;
                    }
                    uint64_t v20 = v40 + 1;
                    if ((id)(v40 + 1) != v36) {
                      continue;
                    }
                    break;
                  }
                  id v19 = [v43 countByEnumeratingWithState:&v59 objects:v73 count:16];
                }
                while (v19);
              }

              dispatch_semaphore_t v27 = dispatch_semaphore_create(0);
              v51[0] = _NSConcreteStackBlock;
              v51[1] = 3221225472;
              id v51[2] = sub_100167550;
              v51[3] = &unk_100410FC8;
              id v53 = &v67;
              id v28 = v27;
              id v52 = v28;
              [(MBCKBatchFetch *)log fetchRecordsWithCompletion:v51];
              dispatch_semaphore_wait(v28, 0xFFFFFFFFFFFFFFFFLL);
            }
            id v37 = [obj countByEnumeratingWithState:&v63 objects:buf count:16];
            if (v37) {
              continue;
            }
            break;
          }
        }

        uint64_t v29 = (void *)v68[5];
        if (v29)
        {
          int v30 = 0;
          *a3 = (uint64_t)v29;
        }
        else
        {
          int v30 = 1;
        }
LABEL_41:
        _Block_object_dispose(&v67, 8);

        goto LABEL_42;
      }
    }
    else
    {
      MBGetDefaultLog();
      os_log_t oslog = (os_log_t)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
      {
        uint64_t v31 = *a3;
        *(_DWORD *)buf = 138412290;
        uint64_t v79 = v31;
        _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_ERROR, "Failed to fetch account record: %@", buf, 0xCu);
        _MBLog();
      }
    }
    int v30 = 0;
LABEL_42:

    goto LABEL_43;
  }
  id v10 = 0;
LABEL_47:

  return v10;
}

void sub_100166FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

uint64_t sub_100166FF0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100167000(uint64_t a1)
{
}

void sub_100167008(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  if (!v8)
  {
    double v12 = +[MBDomainRecord domainRecordFromCKRecord:a3];
    unsigned int v13 = *(void **)(a1 + 32);
    id v14 = [*(id *)(a1 + 40) recordIDString];
    id v57 = 0;
    LOBYTE(v13) = [v13 insertDomainRecordForSnapshotID:v14 domain:v12 error:&v57];
    id v15 = v57;

    if (v13)
    {
      id v43 = v7;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v44 = v12;
      unsigned int v16 = [v12 addedOrModifiedAssets];
      id v17 = [v16 countByEnumeratingWithState:&v53 objects:v59 count:16];
      uint64_t v46 = a1;
      if (v17)
      {
        id v18 = v17;
        uint64_t v19 = *(void *)v54;
        id obj = v16;
LABEL_8:
        uint64_t v20 = 0;
        unint64_t v21 = v15;
        while (1)
        {
          if (*(void *)v54 != v19) {
            objc_enumerationMutation(obj);
          }
          uint64_t v22 = *(void **)(*((void *)&v53 + 1) + 8 * (void)v20);
          unsigned __int8 v23 = *(void **)(a1 + 32);
          BOOL v24 = [*(id *)(a1 + 48) recordName];
          double v25 = [v22 recordID];
          id v26 = [v25 recordName];
          id v52 = v21;
          unsigned __int8 v27 = [v23 insertAssetRecordReferenceForDomainRecordID:v24 assetRecordID:v26 isDeletedAsset:0 error:&v52];
          id v28 = v52;
          id v15 = v52;

          if ((v27 & 1) == 0) {
            break;
          }
          uint64_t v20 = (char *)v20 + 1;
          unint64_t v21 = v15;
          a1 = v46;
          if (v18 == v20)
          {
            unsigned int v16 = obj;
            id v18 = [obj countByEnumeratingWithState:&v53 objects:v59 count:16];
            if (v18) {
              goto LABEL_8;
            }
            goto LABEL_14;
          }
        }
        __int16 v42 = MBGetDefaultLog();
        id v7 = v43;
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }
LABEL_14:

      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      double v12 = v44;
      uint64_t v29 = [v44 deletedAssets];
      id v30 = [v29 countByEnumeratingWithState:&v48 objects:v58 count:16];
      if (v30)
      {
        id v31 = v30;
        uint64_t v32 = *(void *)v49;
        id obj = v29;
LABEL_16:
        id v33 = 0;
        double v34 = v15;
        while (1)
        {
          if (*(void *)v49 != v32) {
            objc_enumerationMutation(obj);
          }
          uint64_t v35 = *(void **)(*((void *)&v48 + 1) + 8 * (void)v33);
          id v36 = *(void **)(a1 + 32);
          id v37 = [*(id *)(a1 + 48) recordName];
          uint64_t v38 = [v35 recordID];
          uint64_t v39 = [v38 recordName];
          id v47 = v34;
          LOBYTE(v36) = [v36 insertAssetRecordReferenceForDomainRecordID:v37 assetRecordID:v39 isDeletedAsset:1 error:&v47];
          id v28 = v47;
          id v15 = v47;

          if ((v36 & 1) == 0) {
            break;
          }
          id v33 = (char *)v33 + 1;
          double v34 = v15;
          a1 = v46;
          if (v31 == v33)
          {
            uint64_t v29 = obj;
            id v31 = [obj countByEnumeratingWithState:&v48 objects:v58 count:16];
            if (v31) {
              goto LABEL_16;
            }
            id v8 = 0;
            id v7 = v43;
            double v12 = v44;
            goto LABEL_31;
          }
        }
        __int16 v42 = MBGetDefaultLog();
        id v7 = v43;
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          goto LABEL_30;
        }
LABEL_29:
        *(_DWORD *)buf = 138412546;
        id v61 = v43;
        __int16 v62 = 2112;
        id v63 = v15;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Failed to insert asset reference record into MBCKBackupRecordsDB %@: %@", buf, 0x16u);
        _MBLog();
LABEL_30:

        objc_storeStrong((id *)(*(void *)(*(void *)(v46 + 56) + 8) + 40), v28);
        id v8 = 0;
        double v12 = v44;
        uint64_t v29 = obj;
        goto LABEL_31;
      }
      id v8 = 0;
      id v7 = v43;
    }
    else
    {
      uint64_t v40 = MBGetDefaultLog();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        id v61 = v7;
        __int16 v62 = 2112;
        id v63 = v15;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Failed to insert domain record into MBCKBackupRecordsDB %@: %@", buf, 0x16u);
        _MBLog();
      }

      uint64_t v41 = *(void *)(*(void *)(a1 + 56) + 8);
      id v15 = v15;
      uint64_t v29 = *(void **)(v41 + 40);
      *(void *)(v41 + 40) = v15;
    }
LABEL_31:

    goto LABEL_32;
  }
  id v9 = MBGetDefaultLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412546;
    id v61 = v7;
    __int16 v62 = 2112;
    id v63 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to fetch recordID %@: %@", buf, 0x16u);
    _MBLog();
  }

  uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
  id v11 = v8;
  double v12 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v11;
LABEL_32:
}

void sub_100167550(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v5 = MBGetDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      id v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Batch fetch completion failure %@", buf, 0xCu);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id MBWriteRestoreAppsPlist(void *a1)
{
  id v51 = a1;
  id v57 = objc_alloc_init(MBIgnoredAccountsTracker);
  long long v54 = objc_opt_new();
  +[LSApplicationRecord enumeratorWithOptions:192];
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  id v1 = (id)objc_claimAutoreleasedReturnValue();
  id v2 = [v1 countByEnumeratingWithState:&v62 objects:v72 count:16];
  if (v2)
  {
    id v3 = v2;
    uint64_t v4 = *(void *)v63;
    uint64_t v5 = LSUserApplicationType;
    uint64_t v53 = _kCFBundleDisplayNameKey;
    uint64_t v52 = _kCFBundleShortVersionStringKey;
    uint64_t v58 = LSUserApplicationType;
    uint64_t v59 = *(void *)v63;
    id v56 = v1;
    do
    {
      id v6 = 0;
      id v60 = v3;
      do
      {
        if (*(void *)v63 != v4) {
          objc_enumerationMutation(v1);
        }
        id v7 = *(NSObject **)(*((void *)&v62 + 1) + 8 * (void)v6);
        id v9 = [v7 typeForInstallMachinery];
        if ([v9 isEqualToString:v5])
        {
          uint64_t v10 = objc_opt_new();
          id v11 = [v7 bundleIdentifier];
          double v12 = [v7 installType];
          if (v11)
          {
            unsigned int v13 = v12;
            if ([v7 isBeta])
            {
              id v14 = MBGetDefaultLog();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412546;
                uint64_t v67 = v11;
                __int16 v68 = 2048;
                uint64_t v69 = v13;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Skipping %@/%lu (beta)", buf, 0x16u);
                long long v48 = v11;
                long long v49 = v13;
                goto LABEL_13;
              }
              goto LABEL_25;
            }
            id v15 = [v7 applicationDSID];
            unsigned int v16 = +[NSNumber numberWithUnsignedLongLong:v15];
            unsigned __int8 v17 = [(MBIgnoredAccountsTracker *)v57 addAccountWithDSID:v16];

            if (v17)
            {
              uint64_t v18 = MBExcludedAppTypeFromAppRecord(v7);
              if (v18 != 2)
              {
                if (v18 == 1)
                {
                  id v14 = MBGetDefaultLog();
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 138412546;
                    uint64_t v67 = v11;
                    __int16 v68 = 2048;
                    uint64_t v69 = v13;
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Skipping %@/%lu (app clip)", buf, 0x16u);
                    long long v48 = v11;
                    long long v49 = v13;
                    goto LABEL_23;
                  }
LABEL_24:
                  id v1 = v56;
                  goto LABEL_25;
                }
                uint64_t v19 = [v7 applicationState];
                unsigned int v55 = [v19 isDowngraded];

                uint64_t v20 = [v7 compatibilityObject];
                id v14 = [v20 bundleExecutable];

                [v10 setObject:v9 forKeyedSubscript:@"ApplicationType"];
                unint64_t v21 = [v7 localizedName];
                [v10 setObject:v21 forKeyedSubscript:v53];

                [v10 setObject:v14 forKeyedSubscript:kCFBundleExecutableKey];
                [v10 setObject:v11 forKeyedSubscript:kCFBundleIdentifierKey];
                uint64_t v22 = [v7 localizedName];
                [v10 setObject:v22 forKeyedSubscript:kCFBundleNameKey];

                unsigned __int8 v23 = [v7 bundleVersion];
                [v10 setObject:v23 forKeyedSubscript:kCFBundleVersionKey];

                BOOL v24 = [v7 shortVersionString];
                [v10 setObject:v24 forKeyedSubscript:v52];

                double v25 = +[NSNumber numberWithUnsignedLongLong:v15];
                [v10 setObject:v25 forKeyedSubscript:@"ApplicationDSID"];

                id v26 = +[NSNumber numberWithBool:v55];
                [v10 setObject:v26 forKeyedSubscript:@"IsDemotedApp"];

                if ([v7 isLaunchProhibited])
                {
                  [v10 setObject:&__kCFBooleanTrue forKeyedSubscript:@"LSApplicationLaunchProhibited"];
                }
                else
                {
                  unsigned __int8 v27 = (void *)SBSCopyIconImagePNGDataForDisplayIdentifier();
                  if (!v27)
                  {
                    id v28 = MBGetDefaultLog();
                    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 138412290;
                      uint64_t v67 = v11;
                      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Failed to fetch the icon for %@", buf, 0xCu);
                      long long v48 = v11;
                      _MBLog();
                    }

                    unsigned __int8 v27 = +[NSData data];
                  }
                  objc_msgSend(v10, "setObject:forKeyedSubscript:", v27, @"PlaceholderIcon", v48, v49, v50);
                }
                uint64_t v29 = [v7 bundleContainerURL];
                id v30 = v29;
                if (v29)
                {
                  id v31 = [v29 URLByAppendingPathComponent:@"iTunesMetadata.plist"];
                  id v32 = sub_100168068(v31, @"iTunesMetadata", v10);

                  id v33 = [v7 URL];
                  if (v33)
                  {
                    long long v48 = v14;
                    +[NSString stringWithFormat:@"SC_Info/%@.sinf"];
                    uint64_t v35 = v34 = v30;
                    id v36 = [v33 URLByAppendingPathComponent:v35];
                    id v37 = sub_100168068(v36, @"ApplicationSINF", v10);

                    id v30 = v34;
                  }
                  else
                  {
                    id v36 = MBGetDefaultLog();
                    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 138412546;
                      uint64_t v67 = v11;
                      __int16 v68 = 2112;
                      uint64_t v69 = v7;
                      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "nil bundleURL for %@: %@", buf, 0x16u);
                      long long v48 = v11;
                      long long v49 = v7;
                      _MBLog();
                    }
                  }
                }
                else
                {
                  id v33 = MBGetDefaultLog();
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 138412546;
                    uint64_t v67 = v11;
                    __int16 v68 = 2112;
                    uint64_t v69 = v7;
                    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "nil bundleContainerURL for %@: %@", buf, 0x16u);
                    long long v48 = v11;
                    long long v49 = v7;
                    _MBLog();
                  }
                }
                id v3 = v60;

                [v54 setObject:v10 forKeyedSubscript:v11];
                id v1 = v56;
LABEL_26:

                uint64_t v5 = v58;
                uint64_t v4 = v59;
                goto LABEL_27;
              }
              id v14 = MBGetDefaultLog();
              if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_24;
              }
              *(_DWORD *)buf = 138412546;
              uint64_t v67 = v11;
              __int16 v68 = 2048;
              uint64_t v69 = v13;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Skipping %@/%lu (Swift Playgrounds app)", buf, 0x16u);
              long long v48 = v11;
              long long v49 = v13;
            }
            else
            {
              id v14 = MBGetDefaultLog();
              if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_24;
              }
              *(_DWORD *)buf = 138412802;
              uint64_t v67 = v11;
              __int16 v68 = 2048;
              uint64_t v69 = v13;
              __int16 v70 = 2048;
              id v71 = v15;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Skipping %@/%lu for account %llu", buf, 0x20u);
              long long v49 = v13;
              id v50 = v15;
              long long v48 = v11;
            }
LABEL_23:
            _MBLog();
            goto LABEL_24;
          }
          id v14 = MBGetDefaultLog();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            uint64_t v67 = v7;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "nil bundleID for app record: %@", buf, 0xCu);
            long long v48 = v7;
LABEL_13:
            _MBLog();
          }
LABEL_25:
          id v3 = v60;
          goto LABEL_26;
        }
LABEL_27:

        id v6 = (char *)v6 + 1;
      }
      while (v3 != v6);
      id v38 = [v1 countByEnumeratingWithState:&v62 objects:v72 count:16];
      id v3 = v38;
    }
    while (v38);
  }

  id v39 = [v54 copy];
  id v61 = 0;
  unsigned __int8 v40 = [v39 writeToURL:v51 error:&v61];
  id v41 = v61;
  __int16 v42 = MBGetDefaultLog();
  id v43 = v42;
  if (v40)
  {
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_INFO)) {
      goto LABEL_52;
    }
    long long v44 = [v51 path];
    *(_DWORD *)id v72 = 138412290;
    uint64_t v73 = v44;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_INFO, "Wrote restore apps plist to %@", v72, 0xCu);

    id v45 = [v51 path];
  }
  else
  {
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      goto LABEL_52;
    }
    uint64_t v46 = [v51 path];
    *(_DWORD *)id v72 = 138412546;
    uint64_t v73 = v46;
    __int16 v74 = 2112;
    id v75 = v41;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Failed to write the plist to %@: %@", v72, 0x16u);

    id v45 = [v51 path];
  }
  _MBLog();

LABEL_52:
  return v41;
}

id sub_100168068(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v16 = 0;
  id v8 = +[NSData dataWithContentsOfURL:v5 options:2 error:&v16];
  id v9 = v16;
  uint64_t v10 = v9;
  if (v8)
  {
    [v7 setObject:v8 forKeyedSubscript:v6];
LABEL_3:
    id v11 = 0;
    goto LABEL_12;
  }
  double v12 = [v9 domain];
  if ([v12 isEqualToString:NSCocoaErrorDomain])
  {
    id v13 = [v10 code];

    if (v13 == (id)260) {
      goto LABEL_3;
    }
  }
  else
  {
  }
  id v14 = MBGetDefaultLog();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412546;
    id v18 = v5;
    __int16 v19 = 2112;
    uint64_t v20 = v10;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get data from %@: %@", buf, 0x16u);
    _MBLog();
  }

  if (!v10) {
    __assert_rtn("FetchAndSetData", "LookupInstalledApps.m", 35, "error");
  }
  id v11 = v10;
LABEL_12:

  return v11;
}

uint64_t MBUploadAssetsForBackup(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10)
{
  id v17 = a1;
  id v18 = a2;
  id v99 = a3;
  id v100 = a4;
  id v101 = a5;
  id v94 = a6;
  id v95 = a7;
  id v93 = a8;
  long long v89 = v17;
  id v90 = a9;
  if (!v17) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 468, "domainManager");
  }
  id v88 = v18;
  if (!v18) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 469, "pendingSnapshotDatabase");
  }
  if (!v99) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 470, "snapshotDirectory");
  }
  if (!v100) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 471, "pendingCommitID");
  }
  if (!v101) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 472, "device");
  }
  if (!v95) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 473, "operationTracker");
  }
  if (!v94) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 476, "mountedSnapshotTracker");
  }
  __int16 v19 = [v101 pendingSnapshot];
  id v92 = [v19 progressModel];

  if (!v92) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 478, "progressModel");
  }
  if (!v93) {
    __assert_rtn("MBUploadAssetsForBackup", "MBUploadAssets.m", 479, "plugins");
  }
  uint64_t v91 = +[MBPendingSnapshotDB openOrCreateDatabaseIn:commitID:readonly:error:](MBPendingSnapshotDB, "openOrCreateDatabaseIn:commitID:readonly:error:", v99, v100, 1);
  LOBYTE(v20) = (_BYTE)v91;
  if (v91)
  {
    id v105 = v100;
    id v112 = v17;
    id v102 = v94;
    id v85 = v95;
    id v108 = v91;
    id v106 = v18;
    id v103 = v101;
    id v104 = v93;
    id v107 = v90;
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v22 = MBGetDefaultLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "=upload assets= Uploading modified assets", buf, 2u);
      _MBLog();
    }

    v140[0] = _NSConcreteStackBlock;
    v140[1] = 3221225472;
    v140[2] = sub_100169388;
    v140[3] = &unk_1004114C8;
    id v86 = (id)objc_opt_new();
    id v141 = v86;
    unsigned int v23 = [v108 enumerateDomainsRequiringAssetUpload:a10 block:v140];

    if (v23)
    {
      if ([v86 count])
      {
        uint64_t v136 = 0;
        id v137 = &v136;
        uint64_t v138 = 0x2020000000;
        uint64_t v139 = 0;
        uint64_t v132 = 0;
        __int16 v133 = &v132;
        uint64_t v134 = 0x2020000000;
        uint64_t v135 = 0;
        uint64_t v128 = 0;
        uint64_t v129 = &v128;
        uint64_t v130 = 0x2020000000;
        uint64_t v131 = 0;
        *(void *)&long long v144 = 0;
        *((void *)&v144 + 1) = &v144;
        uint64_t v145 = 0x3032000000;
        long long v146 = sub_1001693AC;
        id v147 = sub_1001693BC;
        id v148 = 0;
        id v98 = [[MBCKBatchSave alloc] initWithOperationTracker:v85];
        long long v127 = 0u;
        long long v125 = 0u;
        long long v126 = 0u;
        long long v124 = 0u;
        id obj = v86;
        id v97 = [obj countByEnumeratingWithState:&v124 objects:buf count:16];
        if (v97)
        {
          uint64_t v96 = *(void *)v125;
          while (2)
          {
            for (uint64_t i = 0; i != v97; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v125 != v96) {
                objc_enumerationMutation(obj);
              }
              double v24 = *(double *)(*((void *)&v124 + 1) + 8 * i);
              if (atomic_load((unint64_t *)v137 + 3))
              {
                long long v48 = MBGetDefaultLog();
                if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)id v149 = 138543362;
                  *(double *)&v149[4] = v24;
                  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "=upload assets= Not uploading changes for %{public}@ because of prior batch failures", v149, 0xCu);
                  double v80 = v24;
                  _MBLog();
                }

                goto LABEL_36;
              }
              if (([v112 containsDomainName:*(void *)(*((void *)&v124 + 1) + 8 * i)] & 1) == 0)__assert_rtn("_uploadModifiedAssets", "MBUploadAssets.m", 393, "[domainManager containsDomainName:domainName]"); {
              id v26 = [v112 domainForName:*(void *)&v24];
              }
              id v109 = v137;
              v115[0] = _NSConcreteStackBlock;
              v115[1] = 3221225472;
              CFStringRef v116 = sub_1001693C4;
              long long v117 = &unk_100414B48;
              long long v120 = &v144;
              id v121 = &v136;
              id v118 = v106;
              double v119 = v24;
              uint64_t v122 = &v132;
              long long v123 = &v128;
              id v27 = v26;
              id v28 = v105;
              id v29 = v102;
              id v111 = v98;
              id v30 = v103;
              id v31 = v104;
              id v32 = v107;
              id v33 = v115;
              id v34 = v108;
              double v35 = [v27 name];
              id v36 = MBGetDefaultLog();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)long long v159 = 138412290;
                *(double *)&v159[4] = v35;
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "=upload assets= Starting asset upload for %@", v159, 0xCu);
                double v80 = v35;
                _MBLog();
              }

              *(void *)id v149 = _NSConcreteStackBlock;
              *(void *)&v149[8] = 3221225472;
              *(void *)&v149[16] = sub_100169624;
              long long v150 = &unk_100414B70;
              uint64_t v158 = v109 + 3;
              *(void *)long long v159 = 0;
              id v110 = v29;
              *(void *)long long v151 = v110;
              id v37 = v27;
              *(void *)&v151[8] = v37;
              id v38 = *(id *)&v35;
              *(void *)&v151[16] = v38;
              id v39 = v28;
              id v152 = v39;
              id v40 = v30;
              id v153 = v40;
              id v41 = v31;
              id v154 = v41;
              id v42 = v32;
              id v155 = v42;
              id v43 = v111;
              long long v156 = v43;
              long long v44 = v33;
              id v157 = v44;
              [v34 enumerateAssetsPendingUploadForDomain:v38 error:v159 block:v149];

              id v45 = *(id *)v159;
              if (v45) {
                v116(v44, 0, 0, 0, v45);
              }
            }
            id v97 = [obj countByEnumeratingWithState:&v124 objects:buf count:16];
            if (v97) {
              continue;
            }
            break;
          }
        }
LABEL_36:

        *(void *)long long v159 = 0;
        unsigned __int8 v49 = [(MBCKBatchSave *)v98 finishWithError:v159];
        id v50 = *(void **)v159;
        double v51 = COERCE_DOUBLE(*(id *)v159);
        if ((v49 & 1) == 0)
        {
          uint64_t v52 = MBGetDefaultLog();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)id v149 = 138412290;
            *(double *)&v149[4] = v51;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_INFO, "=upload assets= Failed to save batch: %@", v149, 0xCu);
            double v80 = v51;
            _MBLog();
          }

          objc_storeStrong((id *)(*((void *)&v144 + 1) + 40), v50);
        }
        double v53 = CFAbsoluteTimeGetCurrent();
        unint64_t v54 = atomic_load((unint64_t *)v129 + 3);
        unint64_t v55 = atomic_load((unint64_t *)v129 + 3);
        double v56 = +[NSByteCountFormatter stringFromByteCount:v55 countStyle:0];
        double v57 = v53 - Current;
        uint64_t v58 = +[NSByteCountFormatter stringFromByteCount:(unint64_t)((double)v54 / v57) countStyle:0];
        uint64_t v59 = MBGetDefaultLog();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v60 = atomic_load((unint64_t *)v129 + 3);
          unint64_t v61 = atomic_load((unint64_t *)v133 + 3);
          *(_DWORD *)id v149 = 138413314;
          *(double *)&v149[4] = v56;
          *(_WORD *)&v149[12] = 2048;
          *(void *)&v149[14] = v60;
          *(_WORD *)&v149[22] = 2048;
          long long v150 = (void *)v61;
          *(_WORD *)long long v151 = 2048;
          *(double *)&v151[2] = v57;
          *(_WORD *)&v151[10] = 2112;
          *(void *)&v151[12] = v58;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "=upload assets= Finished uploading %@ (%lu bytes) for %lu assets in %.2fs, avg throughput: %@/s", v149, 0x34u);
          unint64_t v62 = atomic_load((unint64_t *)v129 + 3);
          unint64_t v63 = atomic_load((unint64_t *)v133 + 3);
          id v84 = v58;
          double v83 = v57;
          unint64_t v81 = v62;
          unint64_t v82 = v63;
          double v80 = v56;
          _MBLog();
        }

        [v107 setAssetUploadDuration:v57];
        unint64_t v64 = atomic_load((unint64_t *)v129 + 3);
        [v107 setUploadedAssetSize:v64];
        unint64_t v65 = atomic_load((unint64_t *)v133 + 3);
        [v107 setUploadedAssetCount:v65];
        unint64_t v66 = atomic_load((unint64_t *)v137 + 3);
        uint64_t v67 = *((void *)&v144 + 1);
        if (v66 && !*(void *)(*((void *)&v144 + 1) + 40)) {
          __assert_rtn("_uploadModifiedAssets", "MBUploadAssets.m", 436, "uploadError");
        }
        if (a10)
        {
          *a10 = *(id *)(*((void *)&v144 + 1) + 40);
          uint64_t v67 = *((void *)&v144 + 1);
        }
        BOOL v46 = *(void *)(v67 + 40) == 0;

        _Block_object_dispose(&v144, 8);
        _Block_object_dispose(&v128, 8);
        _Block_object_dispose(&v132, 8);
        _Block_object_dispose(&v136, 8);
      }
      else
      {
        id v47 = MBGetDefaultLog();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "=upload assets= Found 0 domains with assets to upload, finishing early", buf, 2u);
          _MBLog();
        }

        BOOL v46 = 1;
      }
    }
    else
    {
      BOOL v46 = 0;
    }

    if (v46)
    {
      id v68 = v107;
      id v69 = v105;
      id v70 = v99;
      id v71 = v106;
      id v72 = v108;
      double v73 = CFAbsoluteTimeGetCurrent();
      uint64_t v20 = MBGetDefaultLog();
      if (os_log_type_enabled((os_log_t)v20, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)v20, OS_LOG_TYPE_INFO, "=upload assets= Committing assets into file list", buf, 2u);
        _MBLog();
      }

      LODWORD(v20) = MBCommitUploadedAssetsIntoFileList(v72, v71, v70, v69, a10);
      if (v20)
      {
        double v74 = CFAbsoluteTimeGetCurrent() - v73;
        [v68 setUploadedAssetWriteDuration:v74];
        id v75 = MBGetDefaultLog();
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          double v143 = v74;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "=upload assets= Finished committing assets into file list in %.3fs", buf, 0xCu);
          double v80 = v74;
          _MBLog();
        }
      }
    }
    else
    {
      LOBYTE(v20) = 0;
    }
    id v114 = 0;
    unsigned __int8 v76 = objc_msgSend(v108, "close:", &v114, *(void *)&v80, v81, v82, *(void *)&v83, v84);
    id v77 = v114;
    id v78 = v77;
    if (v76)
    {
    }
    else
    {
      if (a10) {
        *a10 = v77;
      }
      uint64_t v20 = MBGetDefaultLog();
      if (os_log_type_enabled((os_log_t)v20, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v144) = 138412290;
        *(void *)((char *)&v144 + 4) = v78;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)v20, OS_LOG_TYPE_ERROR, "=upload assets= Failed to close readonly pending snapshot database: %@", (uint8_t *)&v144, 0xCu);
        _MBLog();
      }

      LOBYTE(v20) = 0;
    }
  }

  return v20 & 1;
}

void sub_1001692C8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a2)
  {
    _Block_object_dispose(&STACK[0x2E0], 8);
    _Block_object_dispose(&a68, 8);
    _Block_object_dispose(&a71, 8);
    _Block_object_dispose(&STACK[0x218], 8);
    objc_begin_catch(a1);
    JUMPOUT(0x100168FFCLL);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100169388(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_1001693AC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001693BC(uint64_t a1)
{
}

void sub_1001693C4(void *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  if (v11)
  {
    double v12 = MBGetDefaultLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      id v22 = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "=upload assets= Failed to upload asset: %@", buf, 0xCu);
      _MBLog();
    }

    objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), a5);
    atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1[7] + 8) + 24), 1uLL);
  }
  else
  {
    if (!a2) {
      __assert_rtn("_uploadModifiedAssets_block_invoke", "MBUploadAssets.m", 407, "inode != 0");
    }
    id v13 = (void *)a1[4];
    uint64_t v14 = a1[5];
    id v20 = 0;
    unsigned __int8 v15 = [v13 markUploadedAssetForDomain:v14 inode:a2 assetMetadata:v10 error:&v20];
    id v16 = v20;
    id v17 = v20;
    if (v15)
    {
      atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1[8] + 8) + 24), 1uLL);
      atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1[9] + 8) + 24), (unint64_t)[v10 assetSize]);
    }
    else
    {
      id v18 = MBGetDefaultLog();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        __int16 v19 = *(void **)(*(void *)(a1[6] + 8) + 40);
        *(_DWORD *)buf = 138412290;
        id v22 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "=upload assets= Failed to mark asset as uploaded: %@", buf, 0xCu);
        _MBLog();
      }

      atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1[7] + 8) + 24), 1uLL);
      objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), v16);
    }
  }
}

BOOL sub_100169624(uint64_t a1, void *a2, unsigned int a3, void *a4, id a5, uint64_t a6, void *a7)
{
  id v13 = a4;
  uint64_t v14 = v13;
  if (atomic_load(*(unint64_t **)(a1 + 104)))
  {
    id v16 = MBGetDefaultLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "=upload assets= Aborting upload of modified assets because of prior upload failures", buf, 2u);
      _MBLog();
    }
    BOOL v17 = 0;
    goto LABEL_47;
  }
  if (![v13 count]) {
    __assert_rtn("_uploadModifiedAssetsForDomain_block_invoke", "MBUploadAssets.m", 330, "relativePathsThatLinkToInode.count");
  }
  uint64_t v164 = a2;
  unsigned int v165 = a3;
  uint64_t v151 = a6;
  id v18 = [v14 firstObject];
  __int16 v19 = *(void **)(a1 + 32);
  id v20 = *(id *)(a1 + 40);
  id v21 = v19;
  id v22 = [v20 rootPath];
  unsigned int v23 = [v20 volumeMountPoint];
  double v24 = [v21 snapshotMountPointForVolumeMountPoint:v23];

  LODWORD(v21) = [v20 shouldBackupRelativePathFromLiveFileSystem:v18];
  if (v21)
  {

    double v24 = 0;
  }
  double v25 = MBSnapshotPathFromLivePath();
  id v26 = [v25 stringByAppendingPathComponent:v18];

  id v27 = *(void **)(a1 + 48);
  id v28 = v26;
  id v29 = v27;
  id v157 = v14;
  id v30 = v14;
  id v31 = v30;
  if (a5 == (id)1)
  {
    id v32 = MBGetDefaultLog();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138413058;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v28;
      *(_WORD *)&buf[22] = 2048;
      int v174 = v164;
      LOWORD(v175) = 1024;
      *(_DWORD *)((char *)&v175 + 2) = v165;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "=upload assets= Starting upload for %@:%@ (inode %llu, pc %d)", buf, 0x26u);
      uint64_t v130 = v164;
      uint64_t v131 = v165;
      id v126 = v29;
      id v129 = v28;
      _MBLog();
    }
  }
  else
  {
    id v32 = [v30 componentsJoinedByString:@"|"];
    if ([v31 count] < a5)
    {
      uint64_t v33 = [v32 stringByAppendingString:@"..."];

      id v32 = v33;
    }
    id v34 = MBGetDefaultLog();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138413570;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v28;
      *(_WORD *)&buf[22] = 2048;
      int v174 = v164;
      LOWORD(v175) = 1024;
      *(_DWORD *)((char *)&v175 + 2) = v165;
      HIWORD(v175) = 2048;
      id v176 = a5;
      LOWORD(v177) = 2112;
      *(void *)((char *)&v177 + 2) = v32;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "=upload assets= Starting upload for %@:%@ (inode %llu, pc %d, linked by %llu [%@])", buf, 0x3Au);
      id v132 = a5;
      __int16 v133 = v32;
      uint64_t v130 = v164;
      uint64_t v131 = v165;
      id v126 = v29;
      id v129 = v28;
      _MBLog();
    }
  }
  double v35 = *(void **)(a1 + 40);
  id v36 = *(void **)(a1 + 56);
  id v37 = *(void **)(a1 + 64);
  id v38 = *(void **)(a1 + 72);
  id v39 = *(void **)(a1 + 80);
  uint64_t v150 = a1;
  id v166 = 0;
  id v16 = v18;
  id v40 = v35;
  id v41 = v28;
  id v42 = v36;
  id v43 = v37;
  long long v44 = v40;
  id v156 = v43;
  id v162 = v38;
  id v160 = v39;
  uint64_t v158 = [v40 name];
  id v45 = v41;
  if (+[MBProtectionClassUtils canOpenWhenLocked:v165])
  {
    id v148 = v16;
    LOBYTE(v167) = 0;
    *(void *)&long long v169 = 0;
    unsigned int v46 = +[MBSQLiteFileHandle isSQLiteFileAtPath:v45 result:&v167 error:&v169];
    id v47 = (id)v169;
    long long v48 = v47;
    unsigned __int8 v49 = v164;
    if (v46)
    {
      if ((_BYTE)v167)
      {
        id v145 = v42;

        uint64_t v50 = [v45 pathExtension];
        double v51 = [v40 volumeMountPoint];
        +[NSString stringWithFormat:@"sqlite-%llu", v164];
        v53 = uint64_t v52 = v45;
        unint64_t v54 = +[MBTemporaryDirectory temporaryDirectoryOnSameVolumeAsPath:v51 identifiedBy:v53 error:&v166];

        long long v146 = (void *)v50;
        id v144 = v40;
        if (v54)
        {
          id v167 = 0;
          id v55 = v52;
          id v56 = v40;
          id v16 = v148;
          double v57 = v148;
          id v58 = v162;
          id v142 = v54;
          id v143 = v160;
          char v168 = 0;
          id v141 = v56;
          uint64_t v139 = v57;
          uint64_t v59 = v57;
          unint64_t v60 = v58;
          uint64_t v61 = MBCompactSQLiteFileForiCloudBackup(v55, v56, v59, v58, v142, &v168);
          id v45 = v52;
          id v140 = v55;
          id v147 = a7;
          id v137 = v54;
          uint64_t v138 = (void *)v61;
          if (v61)
          {
            unint64_t v62 = (void *)v61;
            id v153 = v52;
            if (v168) {
              objc_msgSend(v143, "setScrubbedSQLiteFileCount:", (char *)objc_msgSend(v143, "scrubbedSQLiteFileCount") + 1);
            }
            objc_msgSend(v143, "setCompactedSQLiteFileCount:", (char *)objc_msgSend(v143, "compactedSQLiteFileCount") + 1);
            id v63 = v55;
            id v64 = v62;
            uint64_t v136 = v60;
            id v65 = v60;
            long long v169 = 0u;
            long long v170 = 0u;
            long long v171 = 0u;
            long long v172 = 0u;
            id v66 = v65;
            id v67 = [v66 countByEnumeratingWithState:&v169 objects:buf count:16];
            if (v67)
            {
              id v68 = v67;
              uint64_t v69 = *(void *)v170;
              while (2)
              {
                for (uint64_t i = 0; i != v68; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v170 != v69) {
                    objc_enumerationMutation(v66);
                  }
                  id v71 = *(void **)(*((void *)&v169 + 1) + 8 * i);
                  if (objc_opt_respondsToSelector())
                  {
                    uint64_t v73 = [v71 backingUpSQLiteFileCopyAtPath:v63 temporaryPath:v64];
                    if (v73)
                    {
                      long long v117 = (void *)v73;

                      id v167 = v117;
                      unsigned int v152 = 0;
                      id v114 = 0;
                      id v16 = v148;
                      id v45 = v153;
                      id v42 = v145;
                      id v55 = v140;
                      CFStringRef v116 = v141;
                      uint64_t v115 = v142;
                      unint64_t v60 = v136;
                      id v113 = v137;
                      goto LABEL_59;
                    }
                  }
                }
                id v68 = [v66 countByEnumeratingWithState:&v169 objects:buf count:16];
                if (v68) {
                  continue;
                }
                break;
              }
            }

            id v74 = v64;
            id v135 = v142;
            id v75 = [v135 makeTemporaryFilePath];
            unsigned __int8 v76 = dispatch_group_create();
            id v77 = +[MBFileEncodingTask encodingTaskWithEncodingMethod:1];
            [v77 setSourcePath:v74];
            [v77 setDestinationPath:v75];
            [v77 setProtectionClass:v165];
            id v78 = +[MBBehaviorOptions sharedOptions];
            [v78 SQLiteSpaceSavingsThresholdWithDefaultValue:0.5];
            uint64_t v79 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
            [v77 setSpaceSavingsThreshold:v79];

            [v77 setGroup:v76];
            [v77 start];
            uint64_t v134 = v76;
            dispatch_group_wait(v76, 0xFFFFFFFFFFFFFFFFLL);
            double v80 = [v77 error];
            unint64_t v81 = v80;
            if (v80)
            {
              id v82 = v80;
              unlink((const char *)[v75 fileSystemRepresentation]);
              unsigned int v152 = 0;
              id v83 = 0;
              id v45 = v153;
              id v84 = v75;
              id v42 = v145;
              unint64_t v60 = v136;
            }
            else
            {
              id v84 = v75;
              id v42 = v145;
              unint64_t v60 = v136;
              if (![v77 compressionMethod]) {
                __assert_rtn("_compressFileAtPath", "MBUploadAssets.m", 126, "task.compressionMethod != MBFileEncodingMethodUnspecified");
              }
              unsigned int v152 = [v77 compressionMethod];
              id v83 = v84;
              id v45 = v153;
            }

            id v118 = v81;
            id v16 = v148;
            double v119 = v83;
            if (v83)
            {
              uint64_t v115 = v142;
              unlink((const char *)[v74 fileSystemRepresentation]);
              objc_msgSend(v143, "setCompressedSQLiteFileCount:", (char *)objc_msgSend(v143, "compressedSQLiteFileCount") + 1);
              long long v120 = v119;
              CFStringRef v116 = v141;
            }
            else
            {
              uint64_t v115 = v142;
              id v121 = MBGetDefaultLog();
              CFStringRef v116 = v141;
              if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412802;
                *(void *)&uint8_t buf[4] = v63;
                *(_WORD *)&buf[12] = 2112;
                *(void *)&buf[14] = v74;
                *(_WORD *)&buf[22] = 2112;
                int v174 = v118;
                _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_ERROR, "=upload assets= Could not compress SQLite database at %@, using compacted path instead %@: %@", buf, 0x20u);
                id v127 = v63;
                _MBLog();
              }

              unint64_t v60 = v136;
              long long v120 = v74;
            }
            id v122 = v120;

            id v114 = v122;
            id v113 = v137;
            id v55 = v140;
          }
          else
          {
            id v113 = v54;
            unsigned int v152 = 0;
            id v114 = 0;
            id v42 = v145;
            CFStringRef v116 = v141;
            uint64_t v115 = v142;
          }
LABEL_59:

          id v155 = v167;
          if (v114)
          {
            id v90 = v115;
            long long v123 = MBGetDefaultLog();
            if (os_log_type_enabled(v123, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 138413314;
              *(void *)&uint8_t buf[4] = v114;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v158;
              *(_WORD *)&buf[22] = 2112;
              int v174 = v140;
              LOWORD(v175) = 1024;
              *(_DWORD *)((char *)&v175 + 2) = v152;
              HIWORD(v175) = 2112;
              id v176 = v146;
              _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_INFO, "=upload assets= Uploading processed SQLite database at %@ instead of the original database at %@:%@ compression:%d ext:%@", buf, 0x30u);
              id v113 = v137;
              id v127 = v114;
              CFStringRef v116 = v141;
              _MBLog();
            }

            id v88 = v156;
            LOBYTE(v127) = v152;
            uint64_t v89 = +[MBAssetRecord assetRecordForDomain:v116 absolutePath:v114 extension:v146 inode:v164 protectionClass:v165 assetType:3 compressionMethod:v127 device:v156 commitID:v42 error:&v166];
            long long v124 = v155;
          }
          else
          {
            long long v125 = MBGetDefaultLog();
            long long v124 = v155;
            if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412802;
              *(void *)&uint8_t buf[4] = v158;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v140;
              *(_WORD *)&buf[22] = 2112;
              int v174 = v155;
              _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_ERROR, "=upload assets= Failed to process sqlite file %@:%@: %@", buf, 0x20u);
              uint64_t v115 = v142;
              _MBLog();
            }

            id v166 = v155;
            [v115 dispose];
            LOBYTE(v152) = 0;
            id v90 = 0;
            uint64_t v89 = 0;
            id v88 = v156;
          }

          a7 = v147;
        }
        else
        {
          LOBYTE(v152) = 0;
          id v90 = 0;
          uint64_t v89 = 0;
          id v16 = v148;
          id v45 = v52;
          id v42 = v145;
          id v88 = v156;
          id v113 = 0;
        }

        uint64_t v149 = 3;
        long long v87 = v146;
        long long v44 = v144;
        goto LABEL_40;
      }
    }
    else
    {
      id v86 = MBGetDefaultLog();
      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&uint8_t buf[4] = v45;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "=upload assets= Failed to determine whether %@ is a SQLite file", buf, 0xCu);
        id v126 = v45;
        _MBLog();
      }

      LOBYTE(v167) = 0;
    }

    uint64_t v85 = 1;
  }
  else
  {

    uint64_t v85 = 2;
    unsigned __int8 v49 = v164;
  }
  long long v87 = objc_msgSend(v45, "pathExtension", v126, v129, v130, v131, v132, v133);
  id v88 = v156;
  LOBYTE(v12_Block_object_dispose(&STACK[0x250], 8) = 0;
  uint64_t v149 = v85;
  uint64_t v89 = +[MBAssetRecord assetRecordForDomain:v44 absolutePath:v45 extension:v87 inode:v49 protectionClass:v165 assetType:v85 compressionMethod:v128 device:v156 commitID:v42 error:&v166];
  LOBYTE(v152) = 0;
  id v90 = 0;
LABEL_40:

  id v91 = v90;
  id v92 = v166;
  id v93 = v92;
  BOOL v17 = v89 != 0;
  id v94 = (void *)v89;
  uint64_t v163 = v91;
  if (v89)
  {
    id v95 = *(void **)(v150 + 64);
    id v159 = v92;
    long long v161 = (void *)v89;
    id v97 = *(void **)(v150 + 88);
    uint64_t v96 = *(void **)(v150 + 96);
    id v154 = v45;
    id v98 = *(id *)(v150 + 48);
    id v99 = v154;
    id v100 = v91;
    id v101 = v96;
    id v102 = v161;
    id v103 = v97;
    id v104 = [v95 pendingSnapshot];
    id v105 = [v104 progressModel];

    id v106 = [v102 asCKRecord];

    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_10016A568;
    int v174 = &unk_100414B98;
    id v175 = v100;
    id v176 = v98;
    char v180 = v165;
    uint64_t v178 = v164;
    uint64_t v179 = v149;
    char v181 = v152;
    *(void *)&long long v177 = v99;
    *((void *)&v177 + 1) = v101;
    id v107 = v101;
    id v108 = v99;
    id v109 = v98;
    id v110 = v100;
    [v103 saveRecord:v106 assetSize:v151 delegate:v105 completion:buf];

    id v93 = v159;
    uint64_t v14 = v157;

    id v94 = v161;
    id v45 = v154;
  }
  else
  {
    id v111 = MBGetDefaultLog();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = v93;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "=upload assets= Failed to create asset record: %@", buf, 0xCu);
      _MBLog();
    }

    uint64_t v14 = v157;
    if (a7) {
      *a7 = v93;
    }
  }

LABEL_47:
  return v17;
}

void sub_10016A568(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(void **)(a1 + 32);
  if (v7) {
    [v7 dispose];
  }
  id v8 = +[MBAssetRecord assetRecordFromCKRecord:v5];
  id v9 = v8;
  if (v6)
  {
    id v10 = MBGetDefaultLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = *(void **)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      os_log_t log = v5;
      id v72 = v6;
      uint64_t v13 = *(void *)(a1 + 64);
      int v14 = *(unsigned __int8 *)(a1 + 80);
      unsigned __int8 v15 = [v9 recordID];
      id v16 = [v15 recordName];
      BOOL v17 = MBStringForAssetType(*(void *)(a1 + 72));
      int v18 = *(char *)(a1 + 81);
      *(_DWORD *)buf = 138413826;
      id v74 = v11;
      __int16 v75 = 2112;
      uint64_t v76 = v12;
      __int16 v77 = 2048;
      uint64_t v78 = v13;
      __int16 v79 = 1024;
      *(_DWORD *)double v80 = v14;
      *(_WORD *)&v80[4] = 2112;
      *(void *)&v80[6] = v16;
      *(_WORD *)&v80[14] = 2112;
      *(void *)&v80[16] = v17;
      __int16 v81 = 1024;
      LODWORD(v82) = v18;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "=upload assets= Failed upload for %@:%@ (inode %llu, pc %d, recordID %@, type %@, compression %d)", buf, 0x40u);

      __int16 v19 = [v9 recordID];
      id v20 = [v19 recordName];
      id v56 = MBStringForAssetType(*(void *)(a1 + 72));
      id v5 = log;
      id v6 = v72;
      _MBLog();
    }
    (*(void (**)(void, void, void, void, id, uint64_t, uint64_t))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), 0, 0, 0, v6, v21, v22);
  }
  else
  {
    unsigned int v23 = [v8 contents];
    double v24 = [v23 signature];

    if (v24)
    {
      uint64_t v69 = v24;
      double v25 = [v9 recordIDSuffix];
      id v26 = [v9 contents];
      id v27 = [v26 signature];
      id v28 = [v9 contents];
      id v29 = +[MBAssetMetadata assetMetadataForUploadedRecordWithRecordIDSuffix:signature:size:type:compressionMethod:](MBAssetMetadata, "assetMetadataForUploadedRecordWithRecordIDSuffix:signature:size:type:compressionMethod:", v25, v27, [v28 size], *(void *)(a1 + 72), *(char *)(a1 + 81));

      id v30 = MBGetDefaultLog();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        id v31 = v5;
        id v32 = *(void **)(a1 + 40);
        uint64_t v62 = *(void *)(a1 + 48);
        uint64_t v64 = *(void *)(a1 + 64);
        id v67 = [v9 recordID];
        unint64_t v60 = [v67 recordName];
        uint64_t v33 = MBStringForAssetType((uint64_t)[v29 assetType]);
        unsigned int v59 = [v29 compressionMethod];
        id v65 = [v29 assetSignature];
        id v34 = [v65 base64EncodedStringWithOptions:0];
        id v35 = [v29 assetSize];
        id v36 = [v9 extension];
        *(_DWORD *)buf = 138414338;
        id v74 = v32;
        id v5 = v31;
        id v6 = 0;
        __int16 v75 = 2112;
        uint64_t v76 = v62;
        __int16 v77 = 2048;
        uint64_t v78 = v64;
        __int16 v79 = 2112;
        *(void *)double v80 = v60;
        *(_WORD *)&v80[8] = 2112;
        *(void *)&v80[10] = v33;
        *(_WORD *)&v80[18] = 1024;
        *(_DWORD *)&v80[20] = v59;
        __int16 v81 = 2112;
        id v82 = v34;
        __int16 v83 = 2048;
        id v84 = v35;
        __int16 v85 = 2112;
        id v86 = v36;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_INFO, "=upload assets= Finished upload for %@:%@ (inode %llu, recordID %@, type %@, compression %d, sig %@, sz %llu, ext %@)", buf, 0x58u);

        long long v66 = *(_OWORD *)(a1 + 40);
        id v68 = [v9 recordID];
        id v63 = [v68 recordName];
        uint64_t v61 = MBStringForAssetType((uint64_t)[v29 assetType]);
        [v29 compressionMethod];
        id v37 = [v29 assetSignature];
        id v38 = [v37 base64EncodedStringWithOptions:0];
        [v29 assetSize];
        id v58 = [v9 extension];
        uint64_t v55 = v66;
        _MBLog();
      }
      (*(void (**)(void, void, void, void *, void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 48), v29, 0, v39, v40, v41, v55);
      double v24 = v69;
    }
    else
    {
      id v42 = MBGetDefaultLog();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        id v43 = [v9 recordID];
        long long v44 = [v43 recordName];
        os_log_t loga = v5;
        uint64_t v45 = *(void *)(a1 + 40);
        uint64_t v46 = *(void *)(a1 + 48);
        int v47 = *(unsigned __int8 *)(a1 + 80);
        uint64_t v48 = *(void *)(a1 + 64);
        unsigned __int8 v49 = MBStringForAssetType(*(void *)(a1 + 72));
        int v50 = *(char *)(a1 + 81);
        *(_DWORD *)buf = 138413826;
        id v74 = v44;
        __int16 v75 = 2112;
        uint64_t v76 = v45;
        __int16 v77 = 2112;
        uint64_t v78 = v46;
        __int16 v79 = 2048;
        *(void *)double v80 = v48;
        *(_WORD *)&v80[8] = 1024;
        *(_DWORD *)&v80[10] = v47;
        *(_WORD *)&v80[14] = 2112;
        *(void *)&v80[16] = v49;
        __int16 v81 = 1024;
        LODWORD(v82) = v50;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "=upload assets= Uploaded recordID %@ for %@:%@ did not have a signature  (inode %llu, pc %d, type %@, compression %d)", buf, 0x40u);

        double v51 = [v9 recordID];
        uint64_t v52 = [v51 recordName];
        double v57 = MBStringForAssetType(*(void *)(a1 + 72));
        id v5 = loga;
        id v6 = 0;
        _MBLog();

        double v24 = 0;
      }

      id v29 = +[MBError errorWithCode:205 format:@"Uploaded asset does not contain a signature"];
      (*(void (**)(void, void, void, void, void *, uint64_t, uint64_t))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), 0, 0, 0, v29, v53, v54);
    }
  }
}

void sub_10016AFF4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[NSError errorWithDomain:@"MBMegaBackupEligibilityErrorDomain" code:1 userInfo:0];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

uint64_t sub_10016B070(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10016B088(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  id v6 = [v5 lastObject];

  if (v6)
  {
    id v7 = [v5 lastObject];
    [*(id *)(a1 + 32) setObject:v7 forKeyedSubscript:v8];
  }
}

void sub_10016B11C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = MBGetDefaultLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = +[NSNumber numberWithBool:a2];
    *(_DWORD *)buf = 138412546;
    id v20 = v7;
    __int16 v21 = 2112;
    id v22 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "saveAccount completed: %@: %@", buf, 0x16u);

    uint64_t v13 = +[NSNumber numberWithBool:a2];
    _MBLog();
  }
  if (a2)
  {
    unsigned int v8 = [*(id *)(a1 + 32) containsObject:ACAccountDataclassKeychainSync];
    id v9 = *(void **)(a1 + 40);
    if (v8)
    {
      uint64_t v10 = *(void *)(a1 + 48);
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      void v16[2] = sub_10016B368;
      void v16[3] = &unk_100414BE8;
      void v16[4] = v9;
      id v17 = *(id *)(a1 + 32);
      id v18 = *(id *)(a1 + 56);
      [v9 _enableKeychainSync:v10 completion:v16];

      id v11 = v17;
    }
    else
    {
      [*(id *)(a1 + 40) _saveEnabledSyncDataclasses:*(void *)(a1 + 32)];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10016B3D4;
      block[3] = &unk_100411B88;
      uint64_t v12 = *(NSObject **)(a1 + 48);
      id v15 = *(id *)(a1 + 56);
      dispatch_async(v12, block);
      id v11 = v15;
    }
  }
  else
  {
    (*(void (**)(void, void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), 0);
  }
}