void mlx::core::BitwiseBinary::eval_cpu(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  void v4[3];

  v3 = *a2;
  if (a2[1] - *a2 != 32) {
    mlx::core::BitwiseBinary::eval_cpu();
  }
  v4[0] = *a2;
  v4[1] = v3 + 16;
  v4[2] = a3;
  switch(*(_DWORD *)(a1 + 20))
  {
    case 0:
      mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::BitwiseAnd>((uint64_t)v4);
      break;
    case 1:
      mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::BitwiseOr>((uint64_t)v4);
      break;
    case 2:
      mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::BitwiseXor>((uint64_t)v4);
      break;
    case 3:
      mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::LeftShift>((uint64_t)v4);
      break;
    case 4:
      mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::RightShift>((uint64_t)v4);
      break;
    default:
      return;
  }
}

void mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::BitwiseAnd>(uint64_t a1)
{
  v1 = *(mlx::core::array **)(a1 + 16);
  switch(*(_DWORD *)(*(void *)v1 + 56))
  {
    case 0:
      v4 = *(uint64_t **)a1;
      v3 = *(uint64_t **)(a1 + 8);
      switch(binary_op_type)
      {
        case 0:
          if (**(unsigned char **)(*v4 + 152)) {
            BOOL v6 = **(unsigned char **)(*v3 + 152) == 0;
          }
          else {
            BOOL v6 = 1;
          }
          char v7 = !v6;
          **(unsigned char **)(*(void *)v1 + 152) = v7;
          goto LABEL_57;
        case 1:
          int v35 = *(_DWORD *)(*v3 + 160);
          if (v35 >= 1)
          {
            int v36 = **(unsigned __int8 **)(*v4 + 152);
            v37 = *(char **)(*(void *)v1 + 152);
            v38 = *(unsigned __int8 **)(*v3 + 152);
            unsigned int v39 = v35 + 1;
            do
            {
              int v41 = *v38++;
              int v40 = v41;
              if (v36) {
                BOOL v42 = v40 == 0;
              }
              else {
                BOOL v42 = 1;
              }
              char v43 = !v42;
              *v37++ = v43;
              --v39;
            }
            while (v39 > 1);
          }
          goto LABEL_57;
        case 2:
          int v44 = *(_DWORD *)(*v4 + 160);
          if (v44 >= 1)
          {
            int v45 = **(unsigned __int8 **)(*v3 + 152);
            v46 = *(char **)(*(void *)v1 + 152);
            v47 = *(unsigned __int8 **)(*v4 + 152);
            unsigned int v48 = v44 + 1;
            do
            {
              int v50 = *v47++;
              int v49 = v50;
              if (v45) {
                BOOL v51 = v49 == 0;
              }
              else {
                BOOL v51 = 1;
              }
              char v52 = !v51;
              *v46++ = v52;
              --v48;
            }
            while (v48 > 1);
          }
          goto LABEL_57;
        case 3:
          int v53 = *(_DWORD *)(*(void *)v1 + 48);
          if (v53 >= 1)
          {
            v54 = *(char **)(*(void *)v1 + 152);
            v55 = *(unsigned __int8 **)(*v3 + 152);
            v56 = *(unsigned __int8 **)(*v4 + 152);
            unsigned int v57 = v53 + 1;
            do
            {
              int v58 = *v56++;
              BOOL v6 = v58 == 0;
              int v60 = *v55++;
              int v59 = v60;
              char v62 = !v6 && v59 != 0;
              *v54++ = v62;
              --v57;
            }
            while (v57 > 1);
          }
          goto LABEL_57;
        default:
          v26 = *(void **)v1;
          v27 = (void *)*v4;
          v28 = *(int **)*v4;
          uint64_t v29 = (v27[1] - (void)v28) >> 2;
          uint64_t v30 = (v29 - 1);
          if ((int)v30 >= -1) {
            int v31 = -1;
          }
          else {
            int v31 = v29 - 1;
          }
          int v32 = v31 + 1;
          int v33 = v29 + 1;
          break;
      }
      while (1)
      {
        unsigned int v34 = v33 - 2;
        if (v33 - 2 < 0) {
          break;
        }
        --v33;
        if (*(void *)(v27[3] + 8 * v34) != *(void *)(v26[3] + 8 * v34)) {
          goto LABEL_203;
        }
      }
      int v33 = v32;
LABEL_203:
      v235 = (void *)*v3;
      v236 = *(int **)*v3;
      uint64_t v237 = (v235[1] - (void)v236) >> 2;
      uint64_t v238 = (v237 - 1);
      if ((int)v238 >= -1) {
        int v239 = -1;
      }
      else {
        int v239 = v237 - 1;
      }
      int v240 = v239 + 1;
      int v241 = v237 + 1;
      while (1)
      {
        unsigned int v242 = v241 - 2;
        if (v241 - 2 < 0) {
          break;
        }
        --v241;
        if (*(void *)(v235[3] + 8 * v242) != *(void *)(v26[3] + 8 * v242)) {
          goto LABEL_242;
        }
      }
      int v241 = v240;
LABEL_242:
      int v274 = v29 + 1;
      while (1)
      {
        unsigned int v275 = v274 - 2;
        if (v274 - 2 < 0) {
          break;
        }
        --v274;
        if (*(void *)(v27[3] + 8 * v275)) {
          goto LABEL_267;
        }
      }
      int v274 = v32;
LABEL_267:
      int v284 = v237 + 1;
      while (1)
      {
        unsigned int v285 = v284 - 2;
        if (v284 - 2 < 0) {
          break;
        }
        --v284;
        if (*(void *)(v235[3] + 8 * v285)) {
          goto LABEL_292;
        }
      }
      int v284 = v240;
LABEL_292:
      unint64_t v294 = (uint64_t)(v26[1] - *v26) >> 2;
      if (v33 <= v241) {
        int v295 = v241;
      }
      else {
        int v295 = v33;
      }
      if (v33 <= v284) {
        int v33 = v284;
      }
      if (v274 > v241) {
        int v241 = v274;
      }
      if (v294 > v241)
      {
        int v296 = 1;
      }
      else
      {
        int v241 = (uint64_t)(v26[1] - *v26) >> 2;
        int v296 = 4;
      }
      if (v294 > v33)
      {
        int v297 = 2;
      }
      else
      {
        int v33 = v241;
        int v297 = v296;
      }
      if (v294 > v295)
      {
        int v33 = v295;
        int v297 = 3;
      }
      uint64_t v1707 = v238;
      uint64_t v1722 = v30;
      if (!v33) {
        goto LABEL_309;
      }
      unint64_t v298 = *(void *)(v26[3] + 8 * (v33 - 1));
      if (v298 < 0x10) {
        goto LABEL_309;
      }
      uint64_t v1688 = *(void *)(v26[3] + 8 * (v33 - 1));
      switch(v297)
      {
        case 1:
          if (v33 == 2)
          {
            uint64_t v1258 = *v28;
            if (v1258)
            {
              uint64_t v1259 = 0;
              uint64_t v1260 = 0;
              uint64_t v1261 = 0;
              uint64_t v1262 = v27[19];
              uint64_t v1263 = v235[19];
              uint64_t v1264 = v26[19];
              unint64_t v1265 = v28[1];
              v1266 = (uint64_t *)v27[3];
              uint64_t v1267 = *v1266;
              uint64_t v1268 = v1266[1];
              v1269 = (uint64_t *)v235[3];
              uint64_t v1271 = *v1269;
              uint64_t v1270 = v1269[1];
              if (v1265 <= 1) {
                uint64_t v1272 = 1;
              }
              else {
                uint64_t v1272 = v28[1];
              }
              uint64_t v1273 = v1267 - v1268 * v1265;
              uint64_t v1274 = v1271 - v1270 * v236[1];
              do
              {
                if (v1265)
                {
                  uint64_t v1275 = 0;
                  uint64_t v1276 = v1263 + v1260;
                  do
                  {
                    if ((int)v298 >= 1)
                    {
                      uint64_t v1277 = 0;
                      int v1278 = *(unsigned __int8 *)(v1262 + v1261);
                      unsigned int v1279 = v298 + 1;
                      do
                      {
                        if (v1278) {
                          BOOL v1280 = *(unsigned char *)(v1276 + v1277) == 0;
                        }
                        else {
                          BOOL v1280 = 1;
                        }
                        char v1281 = !v1280;
                        *(unsigned char *)(v1264 + v1277) = v1281;
                        --v1279;
                        ++v1277;
                      }
                      while (v1279 > 1);
                    }
                    v1261 += v1268;
                    v1260 += v1270;
                    v1264 += (int)v298;
                    ++v1275;
                    v1276 += v1270;
                  }
                  while (v1275 != v1272);
                }
                v1261 += v1273;
                v1260 += v1274;
                ++v1259;
              }
              while (v1259 != v1258);
            }
          }
          else if (v33 == 1)
          {
            uint64_t v880 = *v28;
            if (v880)
            {
              uint64_t v881 = 0;
              uint64_t v882 = 0;
              uint64_t v883 = v27[19];
              uint64_t v884 = v235[19];
              uint64_t v885 = v26[19];
              uint64_t v886 = *(void *)v27[3];
              uint64_t v887 = *(void *)v235[3];
              do
              {
                if ((int)v298 >= 1)
                {
                  uint64_t v888 = 0;
                  int v889 = *(unsigned __int8 *)(v883 + v882);
                  unsigned int v890 = v298 + 1;
                  do
                  {
                    if (v889) {
                      BOOL v891 = *(unsigned char *)(v884 + v888) == 0;
                    }
                    else {
                      BOOL v891 = 1;
                    }
                    char v892 = !v891;
                    *(unsigned char *)(v885 + v888) = v892;
                    --v890;
                    ++v888;
                  }
                  while (v890 > 1);
                }
                v882 += v886;
                v885 += (int)v298;
                ++v881;
                v884 += v887;
              }
              while (v881 != v880);
            }
          }
          else
          {
            unint64_t v1660 = v26[6];
            if (v1660)
            {
              uint64_t v1282 = 0;
              uint64_t v1620 = v235[19];
              uint64_t v1632 = v27[19];
              uint64_t v1645 = (int)v298;
              unsigned int v1614 = v298 + 1;
              uint64_t v1283 = v26[19];
              do
              {
                uint64_t v1678 = v1282;
                uint64_t v1284 = 0;
                if ((v30 & 0x80000000) == 0)
                {
                  uint64_t v1285 = v27[3];
                  do
                  {
                    ldiv_t v1286 = ldiv((int)v1282, v28[v30]);
                    LODWORD(v1282) = v1286.quot;
                    v1284 += *(void *)(v1285 + 8 * v30--) * v1286.rem;
                  }
                  while (v30 != -1);
                }
                uint64_t v1287 = v1707;
                if ((v1707 & 0x80000000) != 0)
                {
                  LODWORD(v1288) = 0;
                }
                else
                {
                  uint64_t v1288 = 0;
                  uint64_t v1289 = v235[3];
                  int quot = v1678;
                  do
                  {
                    ldiv_t v1291 = ldiv(quot, v236[v1287]);
                    int quot = v1291.quot;
                    v1288 += *(void *)(v1289 + 8 * v1287--) * v1291.rem;
                  }
                  while (v1287 != -1);
                }
                if ((int)v1688 >= 1)
                {
                  uint64_t v1292 = 0;
                  int v1293 = *(unsigned __int8 *)(v1632 + (int)v1284);
                  unsigned int v1294 = v1614;
                  do
                  {
                    if (v1293) {
                      BOOL v1295 = *(unsigned char *)(v1620 + (int)v1288 + v1292) == 0;
                    }
                    else {
                      BOOL v1295 = 1;
                    }
                    char v1296 = !v1295;
                    *(unsigned char *)(v1283 + v1292) = v1296;
                    --v1294;
                    ++v1292;
                  }
                  while (v1294 > 1);
                }
                v1283 += v1645;
                uint64_t v1282 = v1678 + v1645;
                uint64_t v30 = v1722;
              }
              while (v1678 + v1645 < v1660);
            }
          }
          break;
        case 2:
          if (v33 == 2)
          {
            uint64_t v1297 = *v28;
            if (v1297)
            {
              uint64_t v1298 = 0;
              uint64_t v1299 = 0;
              uint64_t v1300 = 0;
              uint64_t v1301 = v27[19];
              uint64_t v1302 = v235[19];
              uint64_t v1303 = v26[19];
              unint64_t v1304 = v28[1];
              v1305 = (uint64_t *)v27[3];
              uint64_t v1306 = *v1305;
              uint64_t v1307 = v1305[1];
              v1308 = (uint64_t *)v235[3];
              uint64_t v1310 = *v1308;
              uint64_t v1309 = v1308[1];
              if (v1304 <= 1) {
                uint64_t v1311 = 1;
              }
              else {
                uint64_t v1311 = v28[1];
              }
              uint64_t v1312 = v1306 - v1307 * v1304;
              uint64_t v1313 = v1310 - v1309 * v236[1];
              do
              {
                if (v1304)
                {
                  uint64_t v1314 = 0;
                  uint64_t v1315 = v1301 + v1300;
                  do
                  {
                    if ((int)v298 >= 1)
                    {
                      uint64_t v1316 = 0;
                      int v1317 = *(unsigned __int8 *)(v1302 + v1299);
                      unsigned int v1318 = v298 + 1;
                      do
                      {
                        if (v1317) {
                          BOOL v1319 = *(unsigned char *)(v1315 + v1316) == 0;
                        }
                        else {
                          BOOL v1319 = 1;
                        }
                        char v1320 = !v1319;
                        *(unsigned char *)(v1303 + v1316) = v1320;
                        --v1318;
                        ++v1316;
                      }
                      while (v1318 > 1);
                    }
                    v1300 += v1307;
                    v1299 += v1309;
                    v1303 += (int)v298;
                    ++v1314;
                    v1315 += v1307;
                  }
                  while (v1314 != v1311);
                }
                v1300 += v1312;
                v1299 += v1313;
                ++v1298;
              }
              while (v1298 != v1297);
            }
          }
          else if (v33 == 1)
          {
            uint64_t v893 = *v28;
            if (v893)
            {
              uint64_t v894 = 0;
              uint64_t v895 = 0;
              uint64_t v896 = v27[19];
              uint64_t v897 = v235[19];
              uint64_t v898 = v26[19];
              uint64_t v899 = *(void *)v27[3];
              uint64_t v900 = *(void *)v235[3];
              do
              {
                if ((int)v298 >= 1)
                {
                  uint64_t v901 = 0;
                  int v902 = *(unsigned __int8 *)(v897 + v895);
                  unsigned int v903 = v298 + 1;
                  do
                  {
                    if (v902) {
                      BOOL v904 = *(unsigned char *)(v896 + v901) == 0;
                    }
                    else {
                      BOOL v904 = 1;
                    }
                    char v905 = !v904;
                    *(unsigned char *)(v898 + v901) = v905;
                    --v903;
                    ++v901;
                  }
                  while (v903 > 1);
                }
                v895 += v900;
                v898 += (int)v298;
                ++v894;
                v896 += v899;
              }
              while (v894 != v893);
            }
          }
          else
          {
            unint64_t v1661 = v26[6];
            if (v1661)
            {
              uint64_t v1321 = 0;
              uint64_t v1621 = v235[19];
              uint64_t v1633 = v27[19];
              uint64_t v1646 = (int)v298;
              unsigned int v1615 = v298 + 1;
              uint64_t v1322 = v26[19];
              do
              {
                uint64_t v1679 = v1321;
                uint64_t v1323 = 0;
                if ((v30 & 0x80000000) == 0)
                {
                  uint64_t v1324 = v27[3];
                  do
                  {
                    ldiv_t v1325 = ldiv((int)v1321, v28[v30]);
                    LODWORD(v1321) = v1325.quot;
                    v1323 += *(void *)(v1324 + 8 * v30--) * v1325.rem;
                  }
                  while (v30 != -1);
                }
                uint64_t v1326 = v1707;
                if ((v1707 & 0x80000000) != 0)
                {
                  LODWORD(v1327) = 0;
                }
                else
                {
                  uint64_t v1327 = 0;
                  uint64_t v1328 = v235[3];
                  int v1329 = v1679;
                  do
                  {
                    ldiv_t v1330 = ldiv(v1329, v236[v1326]);
                    int v1329 = v1330.quot;
                    v1327 += *(void *)(v1328 + 8 * v1326--) * v1330.rem;
                  }
                  while (v1326 != -1);
                }
                if ((int)v1688 >= 1)
                {
                  uint64_t v1331 = 0;
                  int v1332 = *(unsigned __int8 *)(v1621 + (int)v1327);
                  unsigned int v1333 = v1615;
                  do
                  {
                    if (v1332) {
                      BOOL v1334 = *(unsigned char *)(v1633 + (int)v1323 + v1331) == 0;
                    }
                    else {
                      BOOL v1334 = 1;
                    }
                    char v1335 = !v1334;
                    *(unsigned char *)(v1322 + v1331) = v1335;
                    --v1333;
                    ++v1331;
                  }
                  while (v1333 > 1);
                }
                v1322 += v1646;
                uint64_t v1321 = v1679 + v1646;
                uint64_t v30 = v1722;
              }
              while (v1679 + v1646 < v1661);
            }
          }
          break;
        case 3:
          if (v33 == 2)
          {
            uint64_t v1086 = *v28;
            if (v1086)
            {
              uint64_t v1087 = 0;
              uint64_t v1088 = 0;
              uint64_t v1089 = 0;
              uint64_t v1090 = v27[19];
              uint64_t v1091 = v235[19];
              uint64_t v1092 = v26[19];
              unint64_t v1093 = v28[1];
              v1094 = (uint64_t *)v27[3];
              uint64_t v1095 = *v1094;
              uint64_t v1096 = v1094[1];
              v1097 = (uint64_t *)v235[3];
              uint64_t v1099 = *v1097;
              uint64_t v1098 = v1097[1];
              if (v1093 <= 1) {
                uint64_t v1100 = 1;
              }
              else {
                uint64_t v1100 = v28[1];
              }
              uint64_t v1101 = v1095 - v1096 * v1093;
              uint64_t v1102 = v1099 - v1098 * v236[1];
              do
              {
                if (v1093)
                {
                  uint64_t v1103 = 0;
                  uint64_t v1104 = v1091 + v1088;
                  uint64_t v1105 = v1090 + v1089;
                  do
                  {
                    if ((int)v298 >= 1)
                    {
                      uint64_t v1106 = 0;
                      unsigned int v1107 = v298 + 1;
                      do
                      {
                        if (*(unsigned char *)(v1105 + v1106)) {
                          BOOL v1108 = *(unsigned char *)(v1104 + v1106) == 0;
                        }
                        else {
                          BOOL v1108 = 1;
                        }
                        char v1109 = !v1108;
                        *(unsigned char *)(v1092 + v1106) = v1109;
                        --v1107;
                        ++v1106;
                      }
                      while (v1107 > 1);
                    }
                    v1089 += v1096;
                    v1088 += v1098;
                    v1092 += (int)v298;
                    ++v1103;
                    v1104 += v1098;
                    v1105 += v1096;
                  }
                  while (v1103 != v1100);
                }
                v1089 += v1101;
                v1088 += v1102;
                ++v1087;
              }
              while (v1087 != v1086);
            }
          }
          else if (v33 == 1)
          {
            uint64_t v351 = *v28;
            if (v351)
            {
              uint64_t v352 = 0;
              uint64_t v353 = v27[19];
              uint64_t v354 = v235[19];
              uint64_t v355 = v26[19];
              uint64_t v356 = *(void *)v27[3];
              uint64_t v357 = *(void *)v235[3];
              do
              {
                if ((int)v298 >= 1)
                {
                  uint64_t v358 = 0;
                  unsigned int v359 = v298 + 1;
                  do
                  {
                    if (*(unsigned char *)(v353 + v358)) {
                      BOOL v360 = *(unsigned char *)(v354 + v358) == 0;
                    }
                    else {
                      BOOL v360 = 1;
                    }
                    char v361 = !v360;
                    *(unsigned char *)(v355 + v358) = v361;
                    --v359;
                    ++v358;
                  }
                  while (v359 > 1);
                }
                v355 += (int)v298;
                ++v352;
                v354 += v357;
                v353 += v356;
              }
              while (v352 != v351);
            }
          }
          else
          {
            unint64_t v1658 = v26[6];
            if (v1658)
            {
              uint64_t v1110 = 0;
              uint64_t v1616 = v235[19];
              uint64_t v1628 = v27[19];
              uint64_t v1643 = (int)v298;
              unsigned int v1613 = v298 + 1;
              uint64_t v1111 = v26[19];
              do
              {
                uint64_t v1673 = v1110;
                uint64_t v1112 = 0;
                if ((v30 & 0x80000000) == 0)
                {
                  uint64_t v1113 = v27[3];
                  for (uint64_t i = v30; i != -1; --i)
                  {
                    ldiv_t v1115 = ldiv((int)v1110, v28[i]);
                    LODWORD(v1110) = v1115.quot;
                    v1112 += *(void *)(v1113 + 8 * i) * v1115.rem;
                  }
                }
                uint64_t v1116 = v1707;
                if ((v1707 & 0x80000000) != 0)
                {
                  LODWORD(v1117) = 0;
                }
                else
                {
                  uint64_t v1117 = 0;
                  uint64_t v1118 = v235[3];
                  int v1119 = v1673;
                  do
                  {
                    ldiv_t v1120 = ldiv(v1119, v236[v1116]);
                    int v1119 = v1120.quot;
                    v1117 += *(void *)(v1118 + 8 * v1116--) * v1120.rem;
                  }
                  while (v1116 != -1);
                }
                uint64_t v30 = v1722;
                if ((int)v1688 >= 1)
                {
                  uint64_t v1121 = 0;
                  unsigned int v1122 = v1613;
                  do
                  {
                    if (*(unsigned char *)(v1628 + (int)v1112 + v1121)) {
                      BOOL v1123 = *(unsigned char *)(v1616 + (int)v1117 + v1121) == 0;
                    }
                    else {
                      BOOL v1123 = 1;
                    }
                    char v1124 = !v1123;
                    *(unsigned char *)(v1111 + v1121) = v1124;
                    --v1122;
                    ++v1121;
                  }
                  while (v1122 > 1);
                }
                v1111 += v1643;
                uint64_t v1110 = v1673 + v1643;
              }
              while (v1673 + v1643 < v1658);
            }
          }
          break;
        default:
LABEL_309:
          switch(v294)
          {
            case 1uLL:
              uint64_t v299 = v26[6];
              if (v299)
              {
                v300 = (unsigned char *)v27[19];
                v301 = (unsigned char *)v235[19];
                v302 = (char *)v26[19];
                uint64_t v303 = *(void *)v27[3];
                uint64_t v304 = *(void *)v235[3];
                do
                {
                  if (*v300) {
                    BOOL v305 = *v301 == 0;
                  }
                  else {
                    BOOL v305 = 1;
                  }
                  char v306 = !v305;
                  *v302++ = v306;
                  v301 += v304;
                  v300 += v303;
                  --v299;
                }
                while (v299);
              }
              break;
            case 2uLL:
              uint64_t v498 = *v28;
              if (v498)
              {
                uint64_t v499 = 0;
                uint64_t v500 = 0;
                uint64_t v501 = 0;
                uint64_t v502 = 0;
                uint64_t v503 = v27[19];
                uint64_t v504 = v235[19];
                uint64_t v505 = v26[19];
                unint64_t v506 = v28[1];
                v507 = (uint64_t *)v27[3];
                uint64_t v508 = *v507;
                uint64_t v509 = v507[1];
                v510 = (uint64_t *)v235[3];
                uint64_t v511 = *v510;
                uint64_t v512 = v510[1];
                uint64_t v513 = v511 - v512 * v236[1];
                if (v506 <= 1) {
                  uint64_t v514 = 1;
                }
                else {
                  uint64_t v514 = v28[1];
                }
                uint64_t v515 = v508 - v509 * v506;
                do
                {
                  if (v506)
                  {
                    uint64_t v516 = v500 + v514;
                    v517 = (char *)(v505 + v500);
                    uint64_t v518 = v514;
                    do
                    {
                      if (*(unsigned char *)(v503 + v502)) {
                        BOOL v519 = *(unsigned char *)(v504 + v501) == 0;
                      }
                      else {
                        BOOL v519 = 1;
                      }
                      char v520 = !v519;
                      *v517++ = v520;
                      v502 += v509;
                      v501 += v512;
                      --v518;
                    }
                    while (v518);
                    uint64_t v500 = v516;
                  }
                  v502 += v515;
                  v501 += v513;
                  ++v499;
                }
                while (v499 != v498);
              }
              break;
            case 3uLL:
              uint64_t v521 = *v28;
              if (v521)
              {
                uint64_t v522 = 0;
                uint64_t v523 = 0;
                uint64_t v524 = 0;
                uint64_t v525 = 0;
                uint64_t v526 = v27[19];
                uint64_t v527 = v235[19];
                uint64_t v528 = v26[19];
                unint64_t v529 = v28[1];
                v530 = (void *)v27[3];
                uint64_t v531 = v530[1];
                v532 = (void *)v235[3];
                uint64_t v533 = v532[1];
                uint64_t v534 = *v532 - v533 * v236[1];
                if (v529 <= 1) {
                  uint64_t v535 = 1;
                }
                else {
                  uint64_t v535 = v28[1];
                }
                unint64_t v536 = *v530 - v531 * v529;
                do
                {
                  if (v529)
                  {
                    uint64_t v537 = 0;
                    unint64_t v538 = v28[2];
                    uint64_t v539 = v530[2];
                    uint64_t v540 = v532[2];
                    if (v538 <= 1) {
                      uint64_t v541 = 1;
                    }
                    else {
                      uint64_t v541 = v28[2];
                    }
                    uint64_t v542 = v533 - v540 * v236[2];
                    do
                    {
                      uint64_t v543 = v541;
                      if (v538)
                      {
                        do
                        {
                          if (*(unsigned char *)(v526 + v525)) {
                            BOOL v544 = *(unsigned char *)(v527 + v524) == 0;
                          }
                          else {
                            BOOL v544 = 1;
                          }
                          char v545 = !v544;
                          *(unsigned char *)(v528 + v523++) = v545;
                          v525 += v539;
                          v524 += v540;
                          --v543;
                        }
                        while (v543);
                      }
                      v525 += v531 - v539 * v538;
                      v524 += v542;
                      ++v537;
                    }
                    while (v537 != v535);
                  }
                  v525 += v536;
                  v524 += v534;
                  ++v522;
                }
                while (v522 != v521);
              }
              break;
            case 4uLL:
              uint64_t v1727 = *v28;
              if (v1727)
              {
                uint64_t v546 = 0;
                uint64_t v547 = 0;
                uint64_t v548 = 0;
                uint64_t v549 = 0;
                uint64_t v550 = v27[19];
                uint64_t v551 = v235[19];
                uint64_t v552 = v26[19];
                unint64_t v553 = v28[1];
                v554 = (void *)v27[3];
                v555 = (void *)v235[3];
                uint64_t v1641 = v555[1];
                uint64_t v1650 = v554[1];
                uint64_t v1690 = *v555 - v1641 * v236[1];
                int v1712 = v28[1];
                if (v553 <= 1) {
                  uint64_t v556 = 1;
                }
                else {
                  uint64_t v556 = v28[1];
                }
                unint64_t v1665 = *v554 - v554[1] * v553;
                do
                {
                  if (v1712)
                  {
                    uint64_t v557 = 0;
                    unint64_t v558 = v28[2];
                    uint64_t v559 = v554[2];
                    uint64_t v560 = v555[2];
                    if (v558 <= 1) {
                      uint64_t v561 = 1;
                    }
                    else {
                      uint64_t v561 = v28[2];
                    }
                    uint64_t v562 = v1641 - v560 * v236[2];
                    do
                    {
                      if (v558)
                      {
                        uint64_t v563 = 0;
                        unint64_t v564 = v28[3];
                        uint64_t v565 = v554[3];
                        uint64_t v566 = v555[3];
                        if (v564 <= 1) {
                          uint64_t v567 = 1;
                        }
                        else {
                          uint64_t v567 = v28[3];
                        }
                        uint64_t v568 = v560 - v566 * v236[3];
                        do
                        {
                          uint64_t v569 = v567;
                          if (v564)
                          {
                            do
                            {
                              if (*(unsigned char *)(v550 + v549)) {
                                BOOL v570 = *(unsigned char *)(v551 + v548) == 0;
                              }
                              else {
                                BOOL v570 = 1;
                              }
                              char v571 = !v570;
                              *(unsigned char *)(v552 + v547++) = v571;
                              v549 += v565;
                              v548 += v566;
                              --v569;
                            }
                            while (v569);
                          }
                          v549 += v559 - v565 * v564;
                          v548 += v568;
                          ++v563;
                        }
                        while (v563 != v561);
                      }
                      v549 += v1650 - v559 * v558;
                      v548 += v562;
                      ++v557;
                    }
                    while (v557 != v556);
                  }
                  v549 += v1665;
                  v548 += v1690;
                  ++v546;
                }
                while (v546 != v1727);
              }
              break;
            default:
              uint64_t v1689 = v26[6];
              if (v1689)
              {
                uint64_t v485 = 0;
                uint64_t v1649 = v235[19];
                uint64_t v1664 = v27[19];
                uint64_t v1640 = v26[19];
                do
                {
                  uint64_t v486 = 0;
                  if ((v30 & 0x80000000) == 0)
                  {
                    uint64_t v487 = v27[3];
                    uint64_t v488 = v30;
                    int v489 = v485;
                    do
                    {
                      ldiv_t v490 = ldiv(v489, v28[v488]);
                      int v489 = v490.quot;
                      v486 += *(void *)(v487 + 8 * v488--) * v490.rem;
                    }
                    while (v488 != -1);
                  }
                  uint64_t v491 = v1707;
                  if ((v1707 & 0x80000000) != 0)
                  {
                    LODWORD(v492) = 0;
                  }
                  else
                  {
                    uint64_t v492 = 0;
                    uint64_t v493 = v235[3];
                    int v494 = v485;
                    do
                    {
                      ldiv_t v495 = ldiv(v494, v236[v491]);
                      int v494 = v495.quot;
                      v492 += *(void *)(v493 + 8 * v491--) * v495.rem;
                    }
                    while (v491 != -1);
                  }
                  if (*(unsigned char *)(v1664 + (int)v486)) {
                    BOOL v496 = *(unsigned char *)(v1649 + (int)v492) == 0;
                  }
                  else {
                    BOOL v496 = 1;
                  }
                  char v497 = !v496;
                  *(unsigned char *)(v1640 + v485++) = v497;
                  uint64_t v30 = v1722;
                }
                while (v485 != v1689);
              }
              break;
          }
          break;
      }
LABEL_57:
      v63 = *(uint64_t **)a1;
      v64 = *(uint64_t **)(a1 + 8);
      v65 = *(mlx::core::array **)(a1 + 16);
      switch(v66)
      {
        case 0:
          char v20 = **(unsigned char **)(*v64 + 152) & **(unsigned char **)(*v63 + 152);
          uint64_t v21 = *(void *)v65;
          goto LABEL_59;
        case 1:
          int v75 = *(_DWORD *)(*v64 + 160);
          if (v75 >= 1)
          {
            char v76 = **(unsigned char **)(*v63 + 152);
            v77 = *(unsigned char **)(*(void *)v65 + 152);
            v78 = *(char **)(*v64 + 152);
            unsigned int v79 = v75 + 1;
            do
            {
              char v80 = *v78++;
              *v77++ = v80 & v76;
              --v79;
            }
            while (v79 > 1);
          }
          return;
        case 2:
          int v81 = *(_DWORD *)(*v63 + 160);
          if (v81 >= 1)
          {
            char v82 = **(unsigned char **)(*v64 + 152);
            v83 = *(unsigned char **)(*(void *)v65 + 152);
            v84 = *(char **)(*v63 + 152);
            unsigned int v85 = v81 + 1;
            do
            {
              char v86 = *v84++;
              *v83++ = v86 & v82;
              --v85;
            }
            while (v85 > 1);
          }
          return;
        case 3:
          int v87 = *(_DWORD *)(*(void *)v65 + 48);
          if (v87 >= 1)
          {
            v88 = *(unsigned char **)(*(void *)v65 + 152);
            v89 = *(char **)(*v64 + 152);
            v90 = *(char **)(*v63 + 152);
            unsigned int v91 = v87 + 1;
            do
            {
              char v93 = *v90++;
              char v92 = v93;
              char v94 = *v89++;
              *v88++ = v94 & v92;
              --v91;
            }
            while (v91 > 1);
          }
          return;
        default:
          v67 = *(void **)v65;
          uint64_t v68 = *v63;
          v69 = *(int **)*v63;
          uint64_t v70 = (*(void *)(*v63 + 8) - (void)v69) >> 2;
          int v71 = v70 - 1;
          if ((int)v70 - 1 >= -1) {
            int v71 = -1;
          }
          int v72 = v71 + 1;
          int v73 = v70 + 1;
          break;
      }
      while (1)
      {
        unsigned int v74 = v73 - 2;
        if (v73 - 2 < 0) {
          break;
        }
        --v73;
        if (*(void *)(*(void *)(v68 + 24) + 8 * v74) != *(void *)(v67[3] + 8 * v74)) {
          goto LABEL_79;
        }
      }
      int v73 = v72;
LABEL_79:
      v95 = (int **)*v64;
      v96 = *(int **)*v64;
      uint64_t v97 = (*(void *)(*v64 + 8) - (void)v96) >> 2;
      int v98 = v97 - 1;
      if ((int)v97 - 1 >= -1) {
        int v98 = -1;
      }
      int v99 = v98 + 1;
      int v100 = v97 + 1;
      while (1)
      {
        unsigned int v101 = v100 - 2;
        if (v100 - 2 < 0) {
          break;
        }
        --v100;
        if (*(void *)&v95[3][2 * v101] != *(void *)(v67[3] + 8 * v101)) {
          goto LABEL_86;
        }
      }
      int v100 = v99;
LABEL_86:
      int v102 = v70 + 1;
      while (1)
      {
        unsigned int v103 = v102 - 2;
        if (v102 - 2 < 0) {
          break;
        }
        --v102;
        if (*(void *)(*(void *)(v68 + 24) + 8 * v103)) {
          goto LABEL_91;
        }
      }
      int v102 = v72;
LABEL_91:
      int v104 = v97 + 1;
      while (1)
      {
        int v105 = v104 - 2;
        if (v104 - 2 < 0) {
          break;
        }
        --v104;
        if (*(void *)&v95[3][2 * v105]) {
          goto LABEL_96;
        }
      }
      int v104 = v99;
LABEL_96:
      unint64_t v106 = (uint64_t)(v67[1] - *v67) >> 2;
      if (v73 <= v100) {
        int v107 = v100;
      }
      else {
        int v107 = v73;
      }
      if (v73 <= v104) {
        int v73 = v104;
      }
      if (v102 > v100) {
        int v100 = v102;
      }
      if (v106 > v100)
      {
        int v108 = 1;
      }
      else
      {
        int v100 = (uint64_t)(v67[1] - *v67) >> 2;
        int v108 = 4;
      }
      if (v106 > v73)
      {
        int v109 = 2;
      }
      else
      {
        int v73 = v100;
        int v109 = v108;
      }
      if (v106 > v107)
      {
        int v73 = v107;
        int v109 = 3;
      }
      v1721 = v65;
      if (!v73) {
        goto LABEL_113;
      }
      unint64_t v110 = *(void *)(v67[3] + 8 * (v73 - 1));
      if (v110 < 0x10) {
        goto LABEL_113;
      }
      switch(v109)
      {
        case 1:
          if (v73 == 2)
          {
            int v1022 = *v69;
            if (*v69)
            {
              unint64_t v1023 = 0;
              uint64_t v1024 = 0;
              uint64_t v1025 = 0;
              uint64_t v1026 = *(void *)(v68 + 152);
              v1027 = v95[19];
              uint64_t v1028 = v67[19];
              do
              {
                if (v69[1])
                {
                  unint64_t v1029 = 0;
                  do
                  {
                    if ((int)v110 >= 1)
                    {
                      uint64_t v1030 = 0;
                      char v1031 = *(unsigned char *)(v1026 + v1025);
                      unsigned int v1032 = v110 + 1;
                      do
                      {
                        *(unsigned char *)(v1028 + v1030) = *((unsigned char *)v1027 + v1024 + v1030) & v1031;
                        --v1032;
                        ++v1030;
                      }
                      while (v1032 > 1);
                      uint64_t v68 = *v63;
                      v95 = (int **)*v64;
                      v69 = *(int **)*v63;
                    }
                    v1033 = *(void **)(v68 + 24);
                    uint64_t v1034 = v1033[1];
                    v1025 += v1034;
                    v1024 += *((void *)v95[3] + 1);
                    v1028 += (int)v110;
                    ++v1029;
                    unint64_t v1035 = v69[1];
                  }
                  while (v1029 < v1035);
                  int v1022 = *v69;
                  v96 = *v95;
                }
                else
                {
                  unint64_t v1035 = 0;
                  v1033 = *(void **)(v68 + 24);
                  uint64_t v1034 = v1033[1];
                }
                uint64_t v1025 = *v1033 + v1025 - v1035 * v1034;
                uint64_t v1024 = *(void *)v95[3] + v1024 - *((void *)v95[3] + 1) * v96[1];
                ++v1023;
              }
              while (v1023 < v1022);
            }
          }
          else if (v73 == 1)
          {
            int v465 = *v69;
            if (*v69)
            {
              unint64_t v466 = 0;
              uint64_t v467 = 0;
              uint64_t v468 = 0;
              uint64_t v469 = *(void *)(v68 + 152);
              v470 = v95[19];
              uint64_t v471 = v67[19];
              do
              {
                if ((int)v110 >= 1)
                {
                  uint64_t v472 = 0;
                  char v473 = *(unsigned char *)(v469 + v468);
                  unsigned int v474 = v110 + 1;
                  do
                  {
                    *(unsigned char *)(v471 + v472) = *((unsigned char *)v470 + v467 + v472) & v473;
                    --v474;
                    ++v472;
                  }
                  while (v474 > 1);
                  uint64_t v68 = *v63;
                  v95 = (int **)*v64;
                  int v465 = **(_DWORD **)*v63;
                }
                v468 += **(void **)(v68 + 24);
                v467 += *(void *)v95[3];
                v471 += (int)v110;
                ++v466;
              }
              while (v466 < v465);
            }
          }
          else if (v67[6])
          {
            v1656 = v95[19];
            uint64_t v1671 = *(void *)(v68 + 152);
            unint64_t v1716 = 0;
            uint64_t v1036 = v67[19];
            do
            {
              uint64_t v1037 = *(void *)*v63;
              unint64_t v1038 = (unint64_t)(*(void *)(*v63 + 8) - v1037) >> 2;
              uint64_t v1039 = 0;
              uint64_t v1040 = (v1038 - 1);
              if ((int)v1038 - 1 >= 0)
              {
                uint64_t v1041 = *(void *)(*v63 + 24);
                int v1042 = v1716;
                do
                {
                  ldiv_t v1043 = ldiv(v1042, *(int *)(v1037 + 4 * v1040));
                  int v1042 = v1043.quot;
                  v1039 += *(void *)(v1041 + 8 * v1040--) * v1043.rem;
                }
                while (v1040 != -1);
              }
              uint64_t v1044 = *(void *)*v64;
              unint64_t v1045 = (unint64_t)(*(void *)(*v64 + 8) - v1044) >> 2;
              uint64_t v1046 = 0;
              uint64_t v1047 = (v1045 - 1);
              if ((int)v1045 - 1 >= 0)
              {
                uint64_t v1048 = *(void *)(*v64 + 24);
                int v1049 = v1716;
                do
                {
                  ldiv_t v1050 = ldiv(v1049, *(int *)(v1044 + 4 * v1047));
                  int v1049 = v1050.quot;
                  v1046 += *(void *)(v1048 + 8 * v1047--) * v1050.rem;
                }
                while (v1047 != -1);
              }
              if ((int)v110 >= 1)
              {
                uint64_t v1051 = 0;
                char v1052 = *(unsigned char *)(v1671 + (int)v1039);
                unsigned int v1053 = v110 + 1;
                do
                {
                  *(unsigned char *)(v1036 + v1051) = *((unsigned char *)v1656 + (int)v1046 + v1051) & v1052;
                  --v1053;
                  ++v1051;
                }
                while (v1053 > 1);
                v67 = *(void **)v1721;
              }
              v1036 += (int)v110;
              v1716 += (int)v110;
            }
            while (v1716 < v67[6]);
          }
          break;
        case 2:
          if (v73 == 2)
          {
            int v1054 = *v69;
            if (*v69)
            {
              unint64_t v1055 = 0;
              uint64_t v1056 = 0;
              uint64_t v1057 = 0;
              uint64_t v1058 = *(void *)(v68 + 152);
              v1059 = v95[19];
              uint64_t v1060 = v67[19];
              do
              {
                if (v69[1])
                {
                  unint64_t v1061 = 0;
                  do
                  {
                    if ((int)v110 >= 1)
                    {
                      uint64_t v1062 = 0;
                      char v1063 = *((unsigned char *)v1059 + v1056);
                      unsigned int v1064 = v110 + 1;
                      do
                      {
                        *(unsigned char *)(v1060 + v1062) = *(unsigned char *)(v1058 + v1057 + v1062) & v1063;
                        --v1064;
                        ++v1062;
                      }
                      while (v1064 > 1);
                      uint64_t v68 = *v63;
                      v95 = (int **)*v64;
                      v69 = *(int **)*v63;
                    }
                    v1065 = *(void **)(v68 + 24);
                    uint64_t v1066 = v1065[1];
                    v1057 += v1066;
                    v1056 += *((void *)v95[3] + 1);
                    v1060 += (int)v110;
                    ++v1061;
                    unint64_t v1067 = v69[1];
                  }
                  while (v1061 < v1067);
                  int v1054 = *v69;
                  v96 = *v95;
                }
                else
                {
                  unint64_t v1067 = 0;
                  v1065 = *(void **)(v68 + 24);
                  uint64_t v1066 = v1065[1];
                }
                uint64_t v1057 = *v1065 + v1057 - v1067 * v1066;
                uint64_t v1056 = *(void *)v95[3] + v1056 - *((void *)v95[3] + 1) * v96[1];
                ++v1055;
              }
              while (v1055 < v1054);
            }
          }
          else if (v73 == 1)
          {
            int v475 = *v69;
            if (*v69)
            {
              unint64_t v476 = 0;
              uint64_t v477 = 0;
              uint64_t v478 = 0;
              uint64_t v479 = *(void *)(v68 + 152);
              v480 = v95[19];
              uint64_t v481 = v67[19];
              do
              {
                if ((int)v110 >= 1)
                {
                  uint64_t v482 = 0;
                  char v483 = *((unsigned char *)v480 + v477);
                  unsigned int v484 = v110 + 1;
                  do
                  {
                    *(unsigned char *)(v481 + v482) = *(unsigned char *)(v479 + v478 + v482) & v483;
                    --v484;
                    ++v482;
                  }
                  while (v484 > 1);
                  uint64_t v68 = *v63;
                  v95 = (int **)*v64;
                  int v475 = **(_DWORD **)*v63;
                }
                v478 += **(void **)(v68 + 24);
                v477 += *(void *)v95[3];
                v481 += (int)v110;
                ++v476;
              }
              while (v476 < v475);
            }
          }
          else if (v67[6])
          {
            v1657 = v95[19];
            uint64_t v1672 = *(void *)(v68 + 152);
            unint64_t v1717 = 0;
            uint64_t v1068 = v67[19];
            do
            {
              uint64_t v1069 = *(void *)*v63;
              unint64_t v1070 = (unint64_t)(*(void *)(*v63 + 8) - v1069) >> 2;
              uint64_t v1071 = 0;
              uint64_t v1072 = (v1070 - 1);
              if ((int)v1070 - 1 >= 0)
              {
                uint64_t v1073 = *(void *)(*v63 + 24);
                int v1074 = v1717;
                do
                {
                  ldiv_t v1075 = ldiv(v1074, *(int *)(v1069 + 4 * v1072));
                  int v1074 = v1075.quot;
                  v1071 += *(void *)(v1073 + 8 * v1072--) * v1075.rem;
                }
                while (v1072 != -1);
              }
              uint64_t v1076 = *(void *)*v64;
              unint64_t v1077 = (unint64_t)(*(void *)(*v64 + 8) - v1076) >> 2;
              uint64_t v1078 = 0;
              uint64_t v1079 = (v1077 - 1);
              if ((int)v1077 - 1 >= 0)
              {
                uint64_t v1080 = *(void *)(*v64 + 24);
                int v1081 = v1717;
                do
                {
                  ldiv_t v1082 = ldiv(v1081, *(int *)(v1076 + 4 * v1079));
                  int v1081 = v1082.quot;
                  v1078 += *(void *)(v1080 + 8 * v1079--) * v1082.rem;
                }
                while (v1079 != -1);
              }
              if ((int)v110 >= 1)
              {
                uint64_t v1083 = 0;
                char v1084 = *((unsigned char *)v1657 + (int)v1078);
                unsigned int v1085 = v110 + 1;
                do
                {
                  *(unsigned char *)(v1068 + v1083) = *(unsigned char *)(v1672 + (int)v1071 + v1083) & v1084;
                  --v1085;
                  ++v1083;
                }
                while (v1085 > 1);
                v67 = *(void **)v1721;
              }
              v1068 += (int)v110;
              v1717 += (int)v110;
            }
            while (v1717 < v67[6]);
          }
          break;
        case 3:
          if (v73 == 2)
          {
            int v992 = *v69;
            if (*v69)
            {
              unint64_t v993 = 0;
              uint64_t v994 = 0;
              uint64_t v995 = 0;
              uint64_t v996 = *(void *)(v68 + 152);
              v997 = v95[19];
              uint64_t v998 = v67[19];
              do
              {
                if (v69[1])
                {
                  unint64_t v999 = 0;
                  do
                  {
                    if ((int)v110 >= 1)
                    {
                      uint64_t v1000 = 0;
                      unsigned int v1001 = v110 + 1;
                      do
                      {
                        *(unsigned char *)(v998 + v1000) = *((unsigned char *)v997 + v994 + v1000) & *(unsigned char *)(v996 + v995 + v1000);
                        --v1001;
                        ++v1000;
                      }
                      while (v1001 > 1);
                      uint64_t v68 = *v63;
                      v95 = (int **)*v64;
                      v69 = *(int **)*v63;
                    }
                    v1002 = *(void **)(v68 + 24);
                    uint64_t v1003 = v1002[1];
                    v995 += v1003;
                    v994 += *((void *)v95[3] + 1);
                    v998 += (int)v110;
                    ++v999;
                    unint64_t v1004 = v69[1];
                  }
                  while (v999 < v1004);
                  int v992 = *v69;
                  v96 = *v95;
                }
                else
                {
                  unint64_t v1004 = 0;
                  v1002 = *(void **)(v68 + 24);
                  uint64_t v1003 = v1002[1];
                }
                uint64_t v995 = *v1002 + v995 - v1004 * v1003;
                uint64_t v994 = *(void *)v95[3] + v994 - *((void *)v95[3] + 1) * v96[1];
                ++v993;
              }
              while (v993 < v992);
            }
          }
          else if (v73 == 1)
          {
            int v226 = *v69;
            if (*v69)
            {
              unint64_t v227 = 0;
              uint64_t v228 = 0;
              uint64_t v229 = 0;
              uint64_t v230 = *(void *)(v68 + 152);
              v231 = v95[19];
              uint64_t v232 = v67[19];
              do
              {
                if ((int)v110 >= 1)
                {
                  uint64_t v233 = 0;
                  unsigned int v234 = v110 + 1;
                  do
                  {
                    *(unsigned char *)(v232 + v233) = *((unsigned char *)v231 + v228 + v233) & *(unsigned char *)(v230 + v229 + v233);
                    --v234;
                    ++v233;
                  }
                  while (v234 > 1);
                  uint64_t v68 = *v63;
                  v95 = (int **)*v64;
                  int v226 = **(_DWORD **)*v63;
                }
                v229 += **(void **)(v68 + 24);
                v228 += *(void *)v95[3];
                v232 += (int)v110;
                ++v227;
              }
              while (v227 < v226);
            }
          }
          else if (v67[6])
          {
            v1655 = v95[19];
            uint64_t v1670 = *(void *)(v68 + 152);
            unint64_t v1715 = 0;
            uint64_t v1005 = v67[19];
            do
            {
              uint64_t v1006 = *(void *)*v63;
              unint64_t v1007 = (unint64_t)(*(void *)(*v63 + 8) - v1006) >> 2;
              uint64_t v1008 = 0;
              uint64_t v1009 = (v1007 - 1);
              if ((int)v1007 - 1 >= 0)
              {
                uint64_t v1010 = *(void *)(*v63 + 24);
                int v1011 = v1715;
                do
                {
                  ldiv_t v1012 = ldiv(v1011, *(int *)(v1006 + 4 * v1009));
                  int v1011 = v1012.quot;
                  v1008 += *(void *)(v1010 + 8 * v1009--) * v1012.rem;
                }
                while (v1009 != -1);
              }
              uint64_t v1013 = *(void *)*v64;
              unint64_t v1014 = (unint64_t)(*(void *)(*v64 + 8) - v1013) >> 2;
              uint64_t v1015 = 0;
              uint64_t v1016 = (v1014 - 1);
              if ((int)v1014 - 1 >= 0)
              {
                uint64_t v1017 = *(void *)(*v64 + 24);
                int v1018 = v1715;
                do
                {
                  ldiv_t v1019 = ldiv(v1018, *(int *)(v1013 + 4 * v1016));
                  int v1018 = v1019.quot;
                  v1015 += *(void *)(v1017 + 8 * v1016--) * v1019.rem;
                }
                while (v1016 != -1);
              }
              if ((int)v110 >= 1)
              {
                uint64_t v1020 = 0;
                unsigned int v1021 = v110 + 1;
                do
                {
                  *(unsigned char *)(v1005 + v1020) = *((unsigned char *)v1655 + (int)v1015 + v1020) & *(unsigned char *)(v1670
                                                                                                + (int)v1008
                                                                                                + v1020);
                  --v1021;
                  ++v1020;
                }
                while (v1021 > 1);
                v67 = *(void **)v1721;
              }
              v1005 += (int)v110;
              v1715 += (int)v110;
            }
            while (v1715 < v67[6]);
          }
          break;
        default:
LABEL_113:
          switch(v106)
          {
            case 1uLL:
              if (v67[6])
              {
                unint64_t v111 = 0;
                uint64_t v112 = 0;
                uint64_t v113 = 0;
                uint64_t v114 = *(void *)(v68 + 152);
                v115 = v95[19];
                uint64_t v116 = v67[19];
                do
                {
                  *(unsigned char *)(v116 + v111) = *((unsigned char *)v115 + v112) & *(unsigned char *)(v114 + v113);
                  v113 += **(void **)(*v63 + 24);
                  v112 += **(void **)(*v64 + 24);
                  ++v111;
                }
                while (v111 < *(void *)(*(void *)v65 + 48));
              }
              break;
            case 2uLL:
              int v415 = *v69;
              if (*v69)
              {
                unint64_t v416 = 0;
                uint64_t v417 = 0;
                uint64_t v418 = 0;
                uint64_t v419 = 0;
                uint64_t v420 = *(void *)(v68 + 152);
                v421 = v95[19];
                uint64_t v422 = v67[19];
                do
                {
                  if (v69[1])
                  {
                    unint64_t v423 = 0;
                    do
                    {
                      *(unsigned char *)(v422 + v417 + v423) = *((unsigned char *)v421 + v418) & *(unsigned char *)(v420 + v419);
                      uint64_t v68 = *v63;
                      v424 = *(void **)(*v63 + 24);
                      uint64_t v425 = v424[1];
                      v419 += v425;
                      v95 = (int **)*v64;
                      v426 = *(int **)(*v64 + 24);
                      uint64_t v427 = *((void *)v426 + 1);
                      v418 += v427;
                      ++v423;
                      v69 = *(int **)*v63;
                      unint64_t v428 = v69[1];
                    }
                    while (v423 < v428);
                    int v415 = *v69;
                    v96 = *v95;
                    v417 += v423;
                  }
                  else
                  {
                    unint64_t v428 = 0;
                    v424 = *(void **)(v68 + 24);
                    uint64_t v425 = v424[1];
                    v426 = v95[3];
                    uint64_t v427 = *((void *)v426 + 1);
                  }
                  uint64_t v419 = *v424 + v419 - v428 * v425;
                  uint64_t v418 = *(void *)v426 + v418 - v427 * v96[1];
                  ++v416;
                }
                while (v416 < v415);
              }
              break;
            case 3uLL:
              int v429 = *v69;
              if (*v69)
              {
                unint64_t v430 = 0;
                uint64_t v431 = 0;
                uint64_t v432 = 0;
                uint64_t v433 = 0;
                uint64_t v434 = *(void *)(v68 + 152);
                v435 = v95[19];
                uint64_t v436 = v67[19];
                do
                {
                  if (v69[1])
                  {
                    unint64_t v437 = 0;
                    do
                    {
                      if (v69[2])
                      {
                        unint64_t v438 = 0;
                        do
                        {
                          *(unsigned char *)(v436 + v431 + v438) = *((unsigned char *)v435 + v432) & *(unsigned char *)(v434 + v433);
                          uint64_t v68 = *v63;
                          v439 = *(void **)(*v63 + 24);
                          uint64_t v440 = v439[2];
                          v433 += v440;
                          v95 = (int **)*v64;
                          v441 = *(int **)(*v64 + 24);
                          uint64_t v442 = *((void *)v441 + 2);
                          v432 += v442;
                          ++v438;
                          v69 = *(int **)*v63;
                          unint64_t v443 = v69[2];
                        }
                        while (v438 < v443);
                        v96 = *v95;
                        v431 += v438;
                      }
                      else
                      {
                        unint64_t v443 = 0;
                        v439 = *(void **)(v68 + 24);
                        uint64_t v440 = v439[2];
                        v441 = v95[3];
                        uint64_t v442 = *((void *)v441 + 2);
                      }
                      uint64_t v444 = v439[1];
                      uint64_t v433 = v444 + v433 - v443 * v440;
                      uint64_t v432 = *((void *)v441 + 1) + v432 - v442 * v96[2];
                      ++v437;
                      unint64_t v445 = v69[1];
                    }
                    while (v437 < v445);
                    int v429 = *v69;
                  }
                  else
                  {
                    unint64_t v445 = 0;
                    v439 = *(void **)(v68 + 24);
                    uint64_t v444 = v439[1];
                  }
                  uint64_t v433 = *v439 + v433 - v445 * v444;
                  uint64_t v432 = *(void *)v95[3] + v432 - *((void *)v95[3] + 1) * v96[1];
                  ++v430;
                }
                while (v430 < v429);
              }
              break;
            case 4uLL:
              int v446 = *v69;
              if (*v69)
              {
                unint64_t v447 = 0;
                uint64_t v448 = 0;
                uint64_t v449 = 0;
                uint64_t v450 = 0;
                uint64_t v451 = *(void *)(v68 + 152);
                v452 = v95[19];
                uint64_t v453 = v67[19];
                do
                {
                  if (v69[1])
                  {
                    unint64_t v454 = 0;
                    do
                    {
                      if (v69[2])
                      {
                        unint64_t v455 = 0;
                        do
                        {
                          if (v69[3])
                          {
                            unint64_t v456 = 0;
                            do
                            {
                              *(unsigned char *)(v453 + v448 + v456) = *((unsigned char *)v452 + v449) & *(unsigned char *)(v451 + v450);
                              uint64_t v68 = *v63;
                              v457 = *(void **)(*v63 + 24);
                              uint64_t v458 = v457[3];
                              v450 += v458;
                              v95 = (int **)*v64;
                              v459 = *(int **)(*v64 + 24);
                              uint64_t v460 = *((void *)v459 + 3);
                              v449 += v460;
                              ++v456;
                              v69 = *(int **)*v63;
                              unint64_t v461 = v69[3];
                            }
                            while (v456 < v461);
                            v96 = *v95;
                            v448 += v456;
                          }
                          else
                          {
                            unint64_t v461 = 0;
                            v457 = *(void **)(v68 + 24);
                            uint64_t v458 = v457[3];
                            v459 = v95[3];
                            uint64_t v460 = *((void *)v459 + 3);
                          }
                          uint64_t v462 = v457[2];
                          uint64_t v450 = v462 + v450 - v461 * v458;
                          uint64_t v449 = *((void *)v459 + 2) + v449 - v460 * v96[3];
                          ++v455;
                          unint64_t v463 = v69[2];
                        }
                        while (v455 < v463);
                      }
                      else
                      {
                        unint64_t v463 = 0;
                        v457 = *(void **)(v68 + 24);
                        uint64_t v462 = v457[2];
                      }
                      uint64_t v450 = v457[1] + v450 - v463 * v462;
                      uint64_t v449 = *((void *)v95[3] + 1) + v449 - *((void *)v95[3] + 2) * v96[2];
                      ++v454;
                      unint64_t v464 = v69[1];
                    }
                    while (v454 < v464);
                    int v446 = *v69;
                  }
                  else
                  {
                    unint64_t v464 = 0;
                  }
                  uint64_t v450 = **(void **)(v68 + 24) + v450 - *(void *)(*(void *)(v68 + 24) + 8) * v464;
                  uint64_t v449 = *(void *)v95[3] + v449 - *((void *)v95[3] + 1) * v96[1];
                  ++v447;
                }
                while (v447 < v446);
              }
              break;
            default:
              if (v67[6])
              {
                unint64_t v398 = 0;
                uint64_t v1711 = *(void *)(v68 + 152);
                v399 = v95[19];
                uint64_t v400 = v67[19];
                do
                {
                  uint64_t v401 = *(void *)*v63;
                  unint64_t v402 = (unint64_t)(*(void *)(*v63 + 8) - v401) >> 2;
                  uint64_t v403 = 0;
                  uint64_t v404 = (v402 - 1);
                  if ((int)v402 - 1 >= 0)
                  {
                    uint64_t v405 = *(void *)(*v63 + 24);
                    int v406 = v398;
                    do
                    {
                      ldiv_t v407 = ldiv(v406, *(int *)(v401 + 4 * v404));
                      int v406 = v407.quot;
                      v403 += *(void *)(v405 + 8 * v404--) * v407.rem;
                    }
                    while (v404 != -1);
                  }
                  uint64_t v408 = *(void *)*v64;
                  unint64_t v409 = (unint64_t)(*(void *)(*v64 + 8) - v408) >> 2;
                  uint64_t v410 = 0;
                  uint64_t v411 = (v409 - 1);
                  if ((int)v409 - 1 >= 0)
                  {
                    uint64_t v412 = *(void *)(*v64 + 24);
                    int v413 = v398;
                    do
                    {
                      ldiv_t v414 = ldiv(v413, *(int *)(v408 + 4 * v411));
                      int v413 = v414.quot;
                      v410 += *(void *)(v412 + 8 * v411--) * v414.rem;
                    }
                    while (v411 != -1);
                  }
                  *(unsigned char *)(v400 + v398++) = *((unsigned char *)v399 + (int)v410) & *(unsigned char *)(v1711 + (int)v403);
                }
                while (v398 < *(void *)(*(void *)v1721 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 1:
      goto LABEL_57;
    case 2:
      v9 = *(uint64_t **)a1;
      v8 = *(uint64_t **)(a1 + 8);
      switch(v10)
      {
        case 0:
          goto LABEL_18;
        case 1:
          int v11 = *(_DWORD *)(*v8 + 160);
          if (v11 >= 1)
          {
            int v12 = **(_DWORD **)(*v9 + 152);
            v13 = *(int **)(*(void *)v1 + 152);
            v14 = *(int **)(*v8 + 152);
            unsigned int v15 = v11 + 1;
            do
            {
              int v16 = *v14++;
              *v13++ = v16 & v12;
              --v15;
            }
            while (v15 > 1);
          }
          return;
        case 2:
          int v126 = *(_DWORD *)(*v9 + 160);
          if (v126 >= 1)
          {
            int v127 = **(_DWORD **)(*v8 + 152);
            v128 = *(int **)(*(void *)v1 + 152);
            v129 = *(int **)(*v9 + 152);
            unsigned int v130 = v126 + 1;
            do
            {
              int v131 = *v129++;
              *v128++ = v131 & v127;
              --v130;
            }
            while (v130 > 1);
          }
          return;
        case 3:
          int v132 = *(_DWORD *)(*(void *)v1 + 48);
          if (v132 >= 1)
          {
            v133 = *(int **)(*(void *)v1 + 152);
            v134 = *(int **)(*v8 + 152);
            v135 = *(int **)(*v9 + 152);
            unsigned int v136 = v132 + 1;
            do
            {
              int v138 = *v135++;
              int v137 = v138;
              int v139 = *v134++;
              *v133++ = v139 & v137;
              --v136;
            }
            while (v136 > 1);
          }
          return;
        default:
          v117 = *(void **)v1;
          v118 = (void *)*v9;
          v119 = *(int **)*v9;
          uint64_t v120 = (v118[1] - (void)v119) >> 2;
          uint64_t v121 = (v120 - 1);
          if ((int)v121 >= -1) {
            int v122 = -1;
          }
          else {
            int v122 = v120 - 1;
          }
          int v123 = v122 + 1;
          int v124 = v120 + 1;
          break;
      }
      while (1)
      {
        unsigned int v125 = v124 - 2;
        if (v124 - 2 < 0) {
          break;
        }
        --v124;
        if (*(void *)(v118[3] + 8 * v125) != *(void *)(v117[3] + 8 * v125)) {
          goto LABEL_211;
        }
      }
      int v124 = v123;
LABEL_211:
      v243 = (void *)*v8;
      v244 = *(int **)*v8;
      uint64_t v245 = (v243[1] - (void)v244) >> 2;
      uint64_t v246 = (v245 - 1);
      if ((int)v246 >= -1) {
        int v247 = -1;
      }
      else {
        int v247 = v245 - 1;
      }
      int v248 = v247 + 1;
      int v249 = v245 + 1;
      while (1)
      {
        unsigned int v250 = v249 - 2;
        if (v249 - 2 < 0) {
          break;
        }
        --v249;
        if (*(void *)(v243[3] + 8 * v250) != *(void *)(v117[3] + 8 * v250)) {
          goto LABEL_247;
        }
      }
      int v249 = v248;
LABEL_247:
      int v276 = v120 + 1;
      while (1)
      {
        unsigned int v277 = v276 - 2;
        if (v276 - 2 < 0) {
          break;
        }
        --v276;
        if (*(void *)(v118[3] + 8 * v277)) {
          goto LABEL_272;
        }
      }
      int v276 = v123;
LABEL_272:
      int v286 = v245 + 1;
      while (1)
      {
        unsigned int v287 = v286 - 2;
        if (v286 - 2 < 0) {
          break;
        }
        --v286;
        if (*(void *)(v243[3] + 8 * v287)) {
          goto LABEL_321;
        }
      }
      int v286 = v248;
LABEL_321:
      unint64_t v307 = (uint64_t)(v117[1] - *v117) >> 2;
      if (v124 <= v249) {
        int v308 = v249;
      }
      else {
        int v308 = v124;
      }
      if (v124 <= v286) {
        int v124 = v286;
      }
      if (v276 > v249) {
        int v249 = v276;
      }
      if (v307 > v249)
      {
        int v309 = 1;
      }
      else
      {
        int v249 = (uint64_t)(v117[1] - *v117) >> 2;
        int v309 = 4;
      }
      if (v307 > v124)
      {
        int v310 = 2;
      }
      else
      {
        int v124 = v249;
        int v310 = v309;
      }
      if (v307 > v308)
      {
        int v124 = v308;
        int v310 = 3;
      }
      uint64_t v1708 = v246;
      uint64_t v1723 = v121;
      if (!v124) {
        goto LABEL_338;
      }
      unint64_t v311 = *(void *)(v117[3] + 8 * (v124 - 1));
      if (v311 < 0x10) {
        goto LABEL_338;
      }
      switch(v310)
      {
        case 1:
          if (v124 == 2)
          {
            int v1336 = *v119;
            if (*v119)
            {
              unint64_t v1337 = 0;
              uint64_t v1338 = 0;
              uint64_t v1339 = 0;
              uint64_t v1340 = v118[19];
              uint64_t v1341 = v243[19];
              uint64_t v1342 = v117[19];
              v1343 = (uint64_t *)v118[3];
              uint64_t v1344 = *v1343;
              uint64_t v1345 = v1343[1];
              v1346 = (uint64_t *)v243[3];
              uint64_t v1347 = *v1346;
              uint64_t v1348 = v1346[1];
              int v1349 = v119[1];
              int v1350 = v1349;
              do
              {
                if (v1350)
                {
                  unint64_t v1351 = 0;
                  uint64_t v1352 = v1341 + 4 * v1338;
                  do
                  {
                    if ((int)v311 >= 1)
                    {
                      uint64_t v1353 = 0;
                      int v1354 = *(_DWORD *)(v1340 + 4 * v1339);
                      unsigned int v1355 = v311 + 1;
                      do
                      {
                        *(_DWORD *)(v1342 + v1353) = *(_DWORD *)(v1352 + v1353) & v1354;
                        --v1355;
                        v1353 += 4;
                      }
                      while (v1355 > 1);
                      int v1349 = v119[1];
                    }
                    v1339 += v1345;
                    v1338 += v1348;
                    v1342 += 4 * (int)v311;
                    ++v1351;
                    v1352 += 4 * v1348;
                  }
                  while (v1351 < v1349);
                  uint64_t v1356 = v1349;
                  int v1336 = *v119;
                  int v1350 = v1349;
                }
                else
                {
                  uint64_t v1356 = 0;
                }
                uint64_t v1339 = v1339 + v1344 - v1356 * v1345;
                uint64_t v1338 = v1338 + v1347 - v1348 * v244[1];
                ++v1337;
              }
              while (v1337 < v1336);
            }
          }
          else if (v124 == 1)
          {
            int v906 = *v119;
            if (*v119)
            {
              unint64_t v907 = 0;
              uint64_t v908 = 0;
              uint64_t v909 = v118[19];
              uint64_t v910 = v243[19];
              uint64_t v911 = v117[19];
              uint64_t v912 = *(void *)v118[3];
              uint64_t v913 = 4 * *(void *)v243[3];
              do
              {
                if ((int)v311 >= 1)
                {
                  uint64_t v914 = 0;
                  int v915 = *(_DWORD *)(v909 + 4 * v908);
                  unsigned int v916 = v311 + 1;
                  do
                  {
                    *(_DWORD *)(v911 + v914) = *(_DWORD *)(v910 + v914) & v915;
                    --v916;
                    v914 += 4;
                  }
                  while (v916 > 1);
                  int v906 = *v119;
                }
                v908 += v912;
                ++v907;
                v911 += 4 * (int)v311;
                v910 += v913;
              }
              while (v907 < v906);
            }
          }
          else
          {
            unint64_t v1680 = v117[6];
            if (v1680)
            {
              unint64_t v1699 = 0;
              uint64_t v1622 = v243[19];
              uint64_t v1634 = v118[19];
              uint64_t v1357 = v117[19];
              do
              {
                uint64_t v1358 = 0;
                if ((v121 & 0x80000000) == 0)
                {
                  uint64_t v1359 = v118[3];
                  uint64_t v1360 = v121;
                  int v1361 = v1699;
                  do
                  {
                    ldiv_t v1362 = ldiv(v1361, v119[v1360]);
                    int v1361 = v1362.quot;
                    v1358 += *(void *)(v1359 + 8 * v1360--) * v1362.rem;
                  }
                  while (v1360 != -1);
                }
                uint64_t v1363 = v1708;
                if ((v1708 & 0x80000000) != 0)
                {
                  LODWORD(v1364) = 0;
                }
                else
                {
                  uint64_t v1364 = 0;
                  uint64_t v1365 = v243[3];
                  int v1366 = v1699;
                  do
                  {
                    ldiv_t v1367 = ldiv(v1366, v244[v1363]);
                    int v1366 = v1367.quot;
                    v1364 += *(void *)(v1365 + 8 * v1363--) * v1367.rem;
                  }
                  while (v1363 != -1);
                }
                uint64_t v121 = v1723;
                if ((int)v311 >= 1)
                {
                  uint64_t v1368 = 0;
                  int v1369 = *(_DWORD *)(v1634 + 4 * (int)v1358);
                  unsigned int v1370 = v311 + 1;
                  do
                  {
                    *(_DWORD *)(v1357 + v1368) = *(_DWORD *)(v1622 + 4 * (int)v1364 + v1368) & v1369;
                    --v1370;
                    v1368 += 4;
                  }
                  while (v1370 > 1);
                }
                v1357 += 4 * (int)v311;
                v1699 += (int)v311;
              }
              while (v1699 < v1680);
            }
          }
          break;
        case 2:
          if (v124 == 2)
          {
            int v1371 = *v119;
            if (*v119)
            {
              unint64_t v1372 = 0;
              uint64_t v1373 = 0;
              uint64_t v1374 = 0;
              uint64_t v1375 = v118[19];
              uint64_t v1376 = v243[19];
              uint64_t v1377 = v117[19];
              v1378 = (uint64_t *)v118[3];
              uint64_t v1379 = *v1378;
              uint64_t v1380 = v1378[1];
              v1381 = (uint64_t *)v243[3];
              uint64_t v1382 = *v1381;
              uint64_t v1383 = v1381[1];
              int v1384 = v119[1];
              int v1385 = v1384;
              do
              {
                if (v1385)
                {
                  unint64_t v1386 = 0;
                  uint64_t v1387 = v1375 + 4 * v1374;
                  do
                  {
                    if ((int)v311 >= 1)
                    {
                      uint64_t v1388 = 0;
                      int v1389 = *(_DWORD *)(v1376 + 4 * v1373);
                      unsigned int v1390 = v311 + 1;
                      do
                      {
                        *(_DWORD *)(v1377 + v1388) = *(_DWORD *)(v1387 + v1388) & v1389;
                        --v1390;
                        v1388 += 4;
                      }
                      while (v1390 > 1);
                      int v1384 = v119[1];
                    }
                    v1374 += v1380;
                    v1373 += v1383;
                    v1377 += 4 * (int)v311;
                    ++v1386;
                    v1387 += 4 * v1380;
                  }
                  while (v1386 < v1384);
                  uint64_t v1391 = v1384;
                  int v1371 = *v119;
                  int v1385 = v1384;
                }
                else
                {
                  uint64_t v1391 = 0;
                }
                uint64_t v1374 = v1374 + v1379 - v1391 * v1380;
                uint64_t v1373 = v1373 + v1382 - v1383 * v244[1];
                ++v1372;
              }
              while (v1372 < v1371);
            }
          }
          else if (v124 == 1)
          {
            int v917 = *v119;
            if (*v119)
            {
              unint64_t v918 = 0;
              uint64_t v919 = 0;
              uint64_t v920 = v118[19];
              uint64_t v921 = v243[19];
              uint64_t v922 = v117[19];
              uint64_t v923 = *(void *)v243[3];
              uint64_t v924 = 4 * *(void *)v118[3];
              do
              {
                if ((int)v311 >= 1)
                {
                  uint64_t v925 = 0;
                  int v926 = *(_DWORD *)(v921 + 4 * v919);
                  unsigned int v927 = v311 + 1;
                  do
                  {
                    *(_DWORD *)(v922 + v925) = *(_DWORD *)(v920 + v925) & v926;
                    --v927;
                    v925 += 4;
                  }
                  while (v927 > 1);
                  int v917 = *v119;
                }
                v919 += v923;
                ++v918;
                v922 += 4 * (int)v311;
                v920 += v924;
              }
              while (v918 < v917);
            }
          }
          else
          {
            unint64_t v1681 = v117[6];
            if (v1681)
            {
              unint64_t v1700 = 0;
              uint64_t v1623 = v243[19];
              uint64_t v1635 = v118[19];
              uint64_t v1392 = v117[19];
              do
              {
                uint64_t v1393 = 0;
                if ((v121 & 0x80000000) == 0)
                {
                  uint64_t v1394 = v118[3];
                  uint64_t v1395 = v121;
                  int v1396 = v1700;
                  do
                  {
                    ldiv_t v1397 = ldiv(v1396, v119[v1395]);
                    int v1396 = v1397.quot;
                    v1393 += *(void *)(v1394 + 8 * v1395--) * v1397.rem;
                  }
                  while (v1395 != -1);
                }
                uint64_t v1398 = v1708;
                if ((v1708 & 0x80000000) != 0)
                {
                  LODWORD(v1399) = 0;
                }
                else
                {
                  uint64_t v1399 = 0;
                  uint64_t v1400 = v243[3];
                  int v1401 = v1700;
                  do
                  {
                    ldiv_t v1402 = ldiv(v1401, v244[v1398]);
                    int v1401 = v1402.quot;
                    v1399 += *(void *)(v1400 + 8 * v1398--) * v1402.rem;
                  }
                  while (v1398 != -1);
                }
                uint64_t v121 = v1723;
                if ((int)v311 >= 1)
                {
                  uint64_t v1403 = 0;
                  int v1404 = *(_DWORD *)(v1623 + 4 * (int)v1399);
                  unsigned int v1405 = v311 + 1;
                  do
                  {
                    *(_DWORD *)(v1392 + v1403) = *(_DWORD *)(v1635 + 4 * (int)v1393 + v1403) & v1404;
                    --v1405;
                    v1403 += 4;
                  }
                  while (v1405 > 1);
                }
                v1392 += 4 * (int)v311;
                v1700 += (int)v311;
              }
              while (v1700 < v1681);
            }
          }
          break;
        case 3:
          if (v124 == 2)
          {
            int v1125 = *v119;
            if (*v119)
            {
              unint64_t v1126 = 0;
              uint64_t v1127 = 0;
              uint64_t v1128 = 0;
              uint64_t v1129 = v118[19];
              uint64_t v1130 = v243[19];
              uint64_t v1131 = v117[19];
              v1132 = (uint64_t *)v118[3];
              uint64_t v1133 = *v1132;
              uint64_t v1134 = v1132[1];
              v1135 = (uint64_t *)v243[3];
              uint64_t v1136 = *v1135;
              uint64_t v1137 = v1135[1];
              int v1138 = v119[1];
              int v1139 = v1138;
              do
              {
                if (v1139)
                {
                  unint64_t v1140 = 0;
                  uint64_t v1141 = v1130 + 4 * v1127;
                  uint64_t v1142 = v1129 + 4 * v1128;
                  do
                  {
                    if ((int)v311 >= 1)
                    {
                      uint64_t v1143 = 0;
                      unsigned int v1144 = v311 + 1;
                      do
                      {
                        *(_DWORD *)(v1131 + v1143) = *(_DWORD *)(v1141 + v1143) & *(_DWORD *)(v1142 + v1143);
                        --v1144;
                        v1143 += 4;
                      }
                      while (v1144 > 1);
                      int v1138 = v119[1];
                    }
                    v1128 += v1134;
                    v1127 += v1137;
                    v1131 += 4 * (int)v311;
                    ++v1140;
                    v1141 += 4 * v1137;
                    v1142 += 4 * v1134;
                  }
                  while (v1140 < v1138);
                  uint64_t v1145 = v1138;
                  int v1125 = *v119;
                  int v1139 = v1138;
                }
                else
                {
                  uint64_t v1145 = 0;
                }
                uint64_t v1128 = v1128 + v1133 - v1145 * v1134;
                uint64_t v1127 = v1127 + v1136 - v1137 * v244[1];
                ++v1126;
              }
              while (v1126 < v1125);
            }
          }
          else if (v124 == 1)
          {
            int v362 = *v119;
            if (*v119)
            {
              unint64_t v363 = 0;
              uint64_t v364 = v118[19];
              uint64_t v365 = v243[19];
              uint64_t v366 = v117[19];
              uint64_t v367 = 4 * *(void *)v243[3];
              uint64_t v368 = 4 * *(void *)v118[3];
              do
              {
                if ((int)v311 >= 1)
                {
                  uint64_t v369 = 0;
                  unsigned int v370 = v311 + 1;
                  do
                  {
                    *(_DWORD *)(v366 + v369) = *(_DWORD *)(v365 + v369) & *(_DWORD *)(v364 + v369);
                    --v370;
                    v369 += 4;
                  }
                  while (v370 > 1);
                  int v362 = *v119;
                }
                ++v363;
                v366 += 4 * (int)v311;
                v365 += v367;
                v364 += v368;
              }
              while (v363 < v362);
            }
          }
          else
          {
            unint64_t v1674 = v117[6];
            if (v1674)
            {
              unint64_t v1695 = 0;
              uint64_t v1617 = v243[19];
              uint64_t v1629 = v118[19];
              uint64_t v1146 = v117[19];
              do
              {
                uint64_t v1147 = 0;
                if ((v121 & 0x80000000) == 0)
                {
                  uint64_t v1148 = v118[3];
                  uint64_t v1149 = v121;
                  int v1150 = v1695;
                  do
                  {
                    ldiv_t v1151 = ldiv(v1150, v119[v1149]);
                    int v1150 = v1151.quot;
                    v1147 += *(void *)(v1148 + 8 * v1149--) * v1151.rem;
                  }
                  while (v1149 != -1);
                }
                uint64_t v1152 = v1708;
                if ((v1708 & 0x80000000) != 0)
                {
                  LODWORD(v1153) = 0;
                }
                else
                {
                  uint64_t v1153 = 0;
                  uint64_t v1154 = v243[3];
                  int v1155 = v1695;
                  do
                  {
                    ldiv_t v1156 = ldiv(v1155, v244[v1152]);
                    int v1155 = v1156.quot;
                    v1153 += *(void *)(v1154 + 8 * v1152--) * v1156.rem;
                  }
                  while (v1152 != -1);
                }
                uint64_t v121 = v1723;
                if ((int)v311 >= 1)
                {
                  uint64_t v1157 = 0;
                  unsigned int v1158 = v311 + 1;
                  do
                  {
                    *(_DWORD *)(v1146 + v1157) = *(_DWORD *)(v1617 + 4 * (int)v1153 + v1157) & *(_DWORD *)(v1629 + 4 * (int)v1147 + v1157);
                    --v1158;
                    v1157 += 4;
                  }
                  while (v1158 > 1);
                }
                v1146 += 4 * (int)v311;
                v1695 += (int)v311;
              }
              while (v1695 < v1674);
            }
          }
          break;
        default:
LABEL_338:
          switch(v307)
          {
            case 1uLL:
              uint64_t v312 = v117[6];
              if (v312)
              {
                v313 = (_DWORD *)v118[19];
                v314 = (_DWORD *)v243[19];
                v315 = (int *)v117[19];
                uint64_t v316 = 4 * *(void *)v243[3];
                uint64_t v317 = 4 * *(void *)v118[3];
                do
                {
                  *v315++ = *v314 & *v313;
                  v314 = (_DWORD *)((char *)v314 + v316);
                  v313 = (_DWORD *)((char *)v313 + v317);
                  --v312;
                }
                while (v312);
              }
              break;
            case 2uLL:
              int v584 = *v119;
              if (*v119)
              {
                unint64_t v585 = 0;
                uint64_t v586 = 0;
                uint64_t v587 = 0;
                uint64_t v588 = 0;
                uint64_t v589 = v118[19];
                uint64_t v590 = v243[19];
                uint64_t v591 = v117[19];
                v592 = (uint64_t *)v118[3];
                uint64_t v593 = *v592;
                uint64_t v594 = v592[1];
                v595 = (uint64_t *)v243[3];
                uint64_t v597 = *v595;
                uint64_t v596 = v595[1];
                int v598 = v119[1];
                do
                {
                  if (v598)
                  {
                    for (unint64_t j = 0; j < v598; ++j)
                    {
                      *(_DWORD *)(v591 + 4 * v586 + 4 * j) = *(_DWORD *)(v590 + 4 * v587) & *(_DWORD *)(v589 + 4 * v588);
                      v588 += v594;
                      v587 += v596;
                      int v598 = v119[1];
                    }
                    uint64_t v600 = v598;
                    int v584 = *v119;
                    v586 += j;
                  }
                  else
                  {
                    uint64_t v600 = 0;
                  }
                  uint64_t v588 = v588 + v593 - v600 * v594;
                  uint64_t v587 = v587 + v597 - v596 * v244[1];
                  ++v585;
                }
                while (v585 < v584);
              }
              break;
            case 3uLL:
              int v601 = *v119;
              if (*v119)
              {
                unint64_t v602 = 0;
                uint64_t v603 = 0;
                uint64_t v604 = 0;
                uint64_t v605 = 0;
                uint64_t v606 = v118[19];
                uint64_t v607 = v243[19];
                uint64_t v608 = v117[19];
                v609 = (uint64_t *)v118[3];
                uint64_t v610 = *v609;
                uint64_t v611 = v609[1];
                v612 = (uint64_t *)v243[3];
                uint64_t v613 = *v612;
                uint64_t v614 = v612[1];
                int v615 = v119[1];
                int v616 = v615;
                do
                {
                  if (v616)
                  {
                    unint64_t v617 = 0;
                    uint64_t v618 = v609[2];
                    uint64_t v619 = v612[2];
                    int v620 = v119[2];
                    do
                    {
                      if (v620)
                      {
                        for (unint64_t k = 0; k < v620; ++k)
                        {
                          *(_DWORD *)(v608 + 4 * v603 + 4 * k) = *(_DWORD *)(v607 + 4 * v604) & *(_DWORD *)(v606 + 4 * v605);
                          v605 += v618;
                          v604 += v619;
                          int v620 = v119[2];
                        }
                        uint64_t v622 = v620;
                        int v615 = v119[1];
                        v603 += k;
                      }
                      else
                      {
                        uint64_t v622 = 0;
                      }
                      uint64_t v605 = v605 + v611 - v622 * v618;
                      uint64_t v604 = v604 + v614 - v619 * v244[2];
                      ++v617;
                    }
                    while (v617 < v615);
                    uint64_t v623 = v615;
                    int v601 = *v119;
                    int v616 = v615;
                  }
                  else
                  {
                    uint64_t v623 = 0;
                  }
                  uint64_t v605 = v605 + v610 - v623 * v611;
                  uint64_t v604 = v604 + v613 - v614 * v244[1];
                  ++v602;
                }
                while (v602 < v601);
              }
              break;
            case 4uLL:
              int v624 = *v119;
              if (*v119)
              {
                unint64_t v625 = 0;
                uint64_t v626 = 0;
                uint64_t v627 = 0;
                uint64_t v628 = 0;
                uint64_t v629 = v118[19];
                uint64_t v630 = v243[19];
                uint64_t v631 = v117[19];
                v632 = (uint64_t *)v118[3];
                uint64_t v633 = *v632;
                uint64_t v634 = v632[1];
                v635 = (uint64_t *)v243[3];
                uint64_t v636 = *v635;
                uint64_t v637 = v635[1];
                int v638 = v119[1];
                int v639 = v638;
                do
                {
                  if (v639)
                  {
                    unint64_t v640 = 0;
                    uint64_t v641 = v632[2];
                    uint64_t v642 = v635[2];
                    int v643 = v119[2];
                    int v644 = v643;
                    do
                    {
                      if (v644)
                      {
                        unint64_t v645 = 0;
                        uint64_t v646 = v632[3];
                        uint64_t v647 = v635[3];
                        int v648 = v119[3];
                        do
                        {
                          if (v648)
                          {
                            for (unint64_t m = 0; m < v648; ++m)
                            {
                              *(_DWORD *)(v631 + 4 * v626 + 4 * m) = *(_DWORD *)(v630 + 4 * v627) & *(_DWORD *)(v629 + 4 * v628);
                              v628 += v646;
                              v627 += v647;
                              int v648 = v119[3];
                            }
                            uint64_t v650 = v648;
                            int v643 = v119[2];
                            v626 += m;
                          }
                          else
                          {
                            uint64_t v650 = 0;
                          }
                          uint64_t v628 = v628 + v641 - v650 * v646;
                          uint64_t v627 = v627 + v642 - v647 * v244[3];
                          ++v645;
                        }
                        while (v645 < v643);
                        uint64_t v651 = v643;
                        int v638 = v119[1];
                        int v644 = v643;
                      }
                      else
                      {
                        uint64_t v651 = 0;
                      }
                      uint64_t v628 = v628 + v634 - v651 * v641;
                      uint64_t v627 = v627 + v637 - v642 * v244[2];
                      ++v640;
                    }
                    while (v640 < v638);
                    uint64_t v652 = v638;
                    int v624 = *v119;
                    int v639 = v638;
                  }
                  else
                  {
                    uint64_t v652 = 0;
                  }
                  uint64_t v628 = v628 + v633 - v652 * v634;
                  uint64_t v627 = v627 + v636 - v637 * v244[1];
                  ++v625;
                }
                while (v625 < v624);
              }
              break;
            default:
              uint64_t v572 = v117[6];
              if (v572)
              {
                uint64_t v573 = 0;
                uint64_t v1666 = v243[19];
                uint64_t v1691 = v118[19];
                uint64_t v1651 = v117[19];
                do
                {
                  uint64_t v574 = 0;
                  if ((v121 & 0x80000000) == 0)
                  {
                    uint64_t v575 = v118[3];
                    uint64_t v576 = v121;
                    int v577 = v573;
                    do
                    {
                      ldiv_t v578 = ldiv(v577, v119[v576]);
                      int v577 = v578.quot;
                      v574 += *(void *)(v575 + 8 * v576--) * v578.rem;
                    }
                    while (v576 != -1);
                  }
                  uint64_t v579 = v1708;
                  if ((v1708 & 0x80000000) != 0)
                  {
                    LODWORD(v580) = 0;
                  }
                  else
                  {
                    uint64_t v580 = 0;
                    uint64_t v581 = v243[3];
                    int v582 = v573;
                    do
                    {
                      ldiv_t v583 = ldiv(v582, v244[v579]);
                      int v582 = v583.quot;
                      v580 += *(void *)(v581 + 8 * v579--) * v583.rem;
                    }
                    while (v579 != -1);
                  }
                  *(_DWORD *)(v1651 + 4 * v573++) = *(_DWORD *)(v1666 + 4 * (int)v580) & *(_DWORD *)(v1691 + 4 * (int)v574);
                  uint64_t v121 = v1723;
                }
                while (v573 != v572);
              }
              break;
          }
          break;
      }
      return;
    case 3:
      v17 = *(uint64_t **)a1;
      v18 = *(uint64_t **)(a1 + 8);
      switch(v19)
      {
        case 0:
          char v20 = **(unsigned char **)(*v18 + 152) & **(unsigned char **)(*v17 + 152);
          uint64_t v21 = *(void *)v1;
LABEL_59:
          **(unsigned char **)(v21 + 152) = v20;
          return;
        case 1:
          int v148 = *(_DWORD *)(*v18 + 160);
          if (v148 >= 1)
          {
            char v149 = **(unsigned char **)(*v17 + 152);
            v150 = *(unsigned char **)(*(void *)v1 + 152);
            v151 = *(char **)(*v18 + 152);
            unsigned int v152 = v148 + 1;
            do
            {
              char v153 = *v151++;
              *v150++ = v153 & v149;
              --v152;
            }
            while (v152 > 1);
          }
          return;
        case 2:
          int v154 = *(_DWORD *)(*v17 + 160);
          if (v154 >= 1)
          {
            char v155 = **(unsigned char **)(*v18 + 152);
            v156 = *(unsigned char **)(*(void *)v1 + 152);
            v157 = *(char **)(*v17 + 152);
            unsigned int v158 = v154 + 1;
            do
            {
              char v159 = *v157++;
              *v156++ = v159 & v155;
              --v158;
            }
            while (v158 > 1);
          }
          return;
        case 3:
          int v160 = *(_DWORD *)(*(void *)v1 + 48);
          if (v160 >= 1)
          {
            v161 = *(unsigned char **)(*(void *)v1 + 152);
            v162 = *(char **)(*v18 + 152);
            v163 = *(char **)(*v17 + 152);
            unsigned int v164 = v160 + 1;
            do
            {
              char v166 = *v163++;
              char v165 = v166;
              char v167 = *v162++;
              *v161++ = v167 & v165;
              --v164;
            }
            while (v164 > 1);
          }
          return;
        default:
          v140 = *(void **)v1;
          uint64_t v141 = *v17;
          v142 = *(int **)*v17;
          uint64_t v143 = (*(void *)(*v17 + 8) - (void)v142) >> 2;
          int v144 = v143 - 1;
          if ((int)v143 - 1 >= -1) {
            int v144 = -1;
          }
          int v145 = v144 + 1;
          int v146 = v143 + 1;
          break;
      }
      while (1)
      {
        unsigned int v147 = v146 - 2;
        if (v146 - 2 < 0) {
          break;
        }
        --v146;
        if (*(void *)(*(void *)(v141 + 24) + 8 * v147) != *(void *)(v140[3] + 8 * v147)) {
          goto LABEL_219;
        }
      }
      int v146 = v145;
LABEL_219:
      v251 = (int **)*v18;
      v252 = *(int **)*v18;
      uint64_t v253 = (*(void *)(*v18 + 8) - (void)v252) >> 2;
      int v254 = v253 - 1;
      if ((int)v253 - 1 >= -1) {
        int v254 = -1;
      }
      int v255 = v254 + 1;
      int v256 = v253 + 1;
      while (1)
      {
        unsigned int v257 = v256 - 2;
        if (v256 - 2 < 0) {
          break;
        }
        --v256;
        if (*(void *)&v251[3][2 * v257] != *(void *)(v140[3] + 8 * v257)) {
          goto LABEL_252;
        }
      }
      int v256 = v255;
LABEL_252:
      int v278 = v143 + 1;
      while (1)
      {
        unsigned int v279 = v278 - 2;
        if (v278 - 2 < 0) {
          break;
        }
        --v278;
        if (*(void *)(*(void *)(v141 + 24) + 8 * v279)) {
          goto LABEL_277;
        }
      }
      int v278 = v145;
LABEL_277:
      int v288 = v253 + 1;
      while (1)
      {
        int v289 = v288 - 2;
        if (v288 - 2 < 0) {
          break;
        }
        --v288;
        if (*(void *)&v251[3][2 * v289]) {
          goto LABEL_344;
        }
      }
      int v288 = v255;
LABEL_344:
      unint64_t v318 = (uint64_t)(v140[1] - *v140) >> 2;
      if (v146 <= v256) {
        int v319 = v256;
      }
      else {
        int v319 = v146;
      }
      if (v146 <= v288) {
        int v146 = v288;
      }
      if (v278 > v256) {
        int v256 = v278;
      }
      if (v318 > v256)
      {
        int v320 = 1;
      }
      else
      {
        int v256 = (uint64_t)(v140[1] - *v140) >> 2;
        int v320 = 4;
      }
      if (v318 > v146)
      {
        int v321 = 2;
      }
      else
      {
        int v146 = v256;
        int v321 = v320;
      }
      if (v318 > v319)
      {
        int v146 = v319;
        int v321 = 3;
      }
      if (!v146) {
        goto LABEL_361;
      }
      unint64_t v322 = *(void *)(v140[3] + 8 * (v146 - 1));
      if (v322 < 0x10) {
        goto LABEL_361;
      }
      uint64_t v1726 = *(void *)(v140[3] + 8 * (v146 - 1));
      switch(v321)
      {
        case 1:
          if (v146 == 2)
          {
            int v1406 = *v142;
            if (*v142)
            {
              unint64_t v1407 = 0;
              uint64_t v1408 = 0;
              uint64_t v1409 = 0;
              uint64_t v1410 = *(void *)(v141 + 152);
              v1411 = v251[19];
              uint64_t v1412 = v140[19];
              do
              {
                if (v142[1])
                {
                  unint64_t v1413 = 0;
                  do
                  {
                    if ((int)v322 >= 1)
                    {
                      uint64_t v1414 = 0;
                      char v1415 = *(unsigned char *)(v1410 + v1409);
                      unsigned int v1416 = v322 + 1;
                      do
                      {
                        *(unsigned char *)(v1412 + v1414) = *((unsigned char *)v1411 + v1408 + v1414) & v1415;
                        --v1416;
                        ++v1414;
                      }
                      while (v1416 > 1);
                      uint64_t v141 = *v17;
                      v251 = (int **)*v18;
                      v142 = *(int **)*v17;
                    }
                    v1417 = *(void **)(v141 + 24);
                    uint64_t v1418 = v1417[1];
                    v1409 += v1418;
                    v1408 += *((void *)v251[3] + 1);
                    v1412 += (int)v322;
                    ++v1413;
                    unint64_t v1419 = v142[1];
                  }
                  while (v1413 < v1419);
                  int v1406 = *v142;
                  v252 = *v251;
                }
                else
                {
                  unint64_t v1419 = 0;
                  v1417 = *(void **)(v141 + 24);
                  uint64_t v1418 = v1417[1];
                }
                uint64_t v1409 = *v1417 + v1409 - v1419 * v1418;
                uint64_t v1408 = *(void *)v251[3] + v1408 - *((void *)v251[3] + 1) * v252[1];
                ++v1407;
              }
              while (v1407 < v1406);
            }
          }
          else if (v146 == 1)
          {
            int v928 = *v142;
            if (*v142)
            {
              unint64_t v929 = 0;
              uint64_t v930 = 0;
              uint64_t v931 = 0;
              uint64_t v932 = *(void *)(v141 + 152);
              v933 = v251[19];
              uint64_t v934 = v140[19];
              do
              {
                if ((int)v322 >= 1)
                {
                  uint64_t v935 = 0;
                  char v936 = *(unsigned char *)(v932 + v931);
                  unsigned int v937 = v322 + 1;
                  do
                  {
                    *(unsigned char *)(v934 + v935) = *((unsigned char *)v933 + v930 + v935) & v936;
                    --v937;
                    ++v935;
                  }
                  while (v937 > 1);
                  uint64_t v141 = *v17;
                  v251 = (int **)*v18;
                  int v928 = **(_DWORD **)*v17;
                }
                v931 += **(void **)(v141 + 24);
                v930 += *(void *)v251[3];
                v934 += (int)v322;
                ++v929;
              }
              while (v929 < v928);
            }
          }
          else if (v140[6])
          {
            v1662 = v251[19];
            uint64_t v1682 = *(void *)(v141 + 152);
            uint64_t v1701 = (int)v322;
            unint64_t v1719 = 0;
            unsigned int v1647 = v322 + 1;
            uint64_t v1420 = v140[19];
            do
            {
              uint64_t v1421 = *(void *)*v17;
              unint64_t v1422 = (unint64_t)(*(void *)(*v17 + 8) - v1421) >> 2;
              uint64_t v1423 = 0;
              uint64_t v1424 = (v1422 - 1);
              if ((int)v1422 - 1 >= 0)
              {
                uint64_t v1425 = *(void *)(*v17 + 24);
                int v1426 = v1719;
                do
                {
                  ldiv_t v1427 = ldiv(v1426, *(int *)(v1421 + 4 * v1424));
                  int v1426 = v1427.quot;
                  v1423 += *(void *)(v1425 + 8 * v1424--) * v1427.rem;
                }
                while (v1424 != -1);
              }
              uint64_t v1428 = *(void *)*v18;
              unint64_t v1429 = (unint64_t)(*(void *)(*v18 + 8) - v1428) >> 2;
              uint64_t v1430 = 0;
              uint64_t v1431 = (v1429 - 1);
              if ((int)v1429 - 1 >= 0)
              {
                uint64_t v1432 = *(void *)(*v18 + 24);
                int v1433 = v1719;
                do
                {
                  ldiv_t v1434 = ldiv(v1433, *(int *)(v1428 + 4 * v1431));
                  int v1433 = v1434.quot;
                  v1430 += *(void *)(v1432 + 8 * v1431--) * v1434.rem;
                }
                while (v1431 != -1);
              }
              if ((int)v1726 >= 1)
              {
                uint64_t v1435 = 0;
                char v1436 = *(unsigned char *)(v1682 + (int)v1423);
                unsigned int v1437 = v1647;
                do
                {
                  *(unsigned char *)(v1420 + v1435) = *((unsigned char *)v1662 + (int)v1430 + v1435) & v1436;
                  --v1437;
                  ++v1435;
                }
                while (v1437 > 1);
                v140 = *(void **)v1;
              }
              v1420 += v1701;
              v1719 += v1701;
            }
            while (v1719 < v140[6]);
          }
          break;
        case 2:
          if (v146 == 2)
          {
            int v1438 = *v142;
            if (*v142)
            {
              unint64_t v1439 = 0;
              uint64_t v1440 = 0;
              uint64_t v1441 = 0;
              uint64_t v1442 = *(void *)(v141 + 152);
              v1443 = v251[19];
              uint64_t v1444 = v140[19];
              do
              {
                if (v142[1])
                {
                  unint64_t v1445 = 0;
                  do
                  {
                    if ((int)v322 >= 1)
                    {
                      uint64_t v1446 = 0;
                      char v1447 = *((unsigned char *)v1443 + v1440);
                      unsigned int v1448 = v322 + 1;
                      do
                      {
                        *(unsigned char *)(v1444 + v1446) = *(unsigned char *)(v1442 + v1441 + v1446) & v1447;
                        --v1448;
                        ++v1446;
                      }
                      while (v1448 > 1);
                      uint64_t v141 = *v17;
                      v251 = (int **)*v18;
                      v142 = *(int **)*v17;
                    }
                    v1449 = *(void **)(v141 + 24);
                    uint64_t v1450 = v1449[1];
                    v1441 += v1450;
                    v1440 += *((void *)v251[3] + 1);
                    v1444 += (int)v322;
                    ++v1445;
                    unint64_t v1451 = v142[1];
                  }
                  while (v1445 < v1451);
                  int v1438 = *v142;
                  v252 = *v251;
                }
                else
                {
                  unint64_t v1451 = 0;
                  v1449 = *(void **)(v141 + 24);
                  uint64_t v1450 = v1449[1];
                }
                uint64_t v1441 = *v1449 + v1441 - v1451 * v1450;
                uint64_t v1440 = *(void *)v251[3] + v1440 - *((void *)v251[3] + 1) * v252[1];
                ++v1439;
              }
              while (v1439 < v1438);
            }
          }
          else if (v146 == 1)
          {
            int v938 = *v142;
            if (*v142)
            {
              unint64_t v939 = 0;
              uint64_t v940 = 0;
              uint64_t v941 = 0;
              uint64_t v942 = *(void *)(v141 + 152);
              v943 = v251[19];
              uint64_t v944 = v140[19];
              do
              {
                if ((int)v322 >= 1)
                {
                  uint64_t v945 = 0;
                  char v946 = *((unsigned char *)v943 + v940);
                  unsigned int v947 = v322 + 1;
                  do
                  {
                    *(unsigned char *)(v944 + v945) = *(unsigned char *)(v942 + v941 + v945) & v946;
                    --v947;
                    ++v945;
                  }
                  while (v947 > 1);
                  uint64_t v141 = *v17;
                  v251 = (int **)*v18;
                  int v938 = **(_DWORD **)*v17;
                }
                v941 += **(void **)(v141 + 24);
                v940 += *(void *)v251[3];
                v944 += (int)v322;
                ++v939;
              }
              while (v939 < v938);
            }
          }
          else if (v140[6])
          {
            v1663 = v251[19];
            uint64_t v1683 = *(void *)(v141 + 152);
            uint64_t v1702 = (int)v322;
            unint64_t v1720 = 0;
            unsigned int v1648 = v322 + 1;
            uint64_t v1452 = v140[19];
            do
            {
              uint64_t v1453 = *(void *)*v17;
              unint64_t v1454 = (unint64_t)(*(void *)(*v17 + 8) - v1453) >> 2;
              uint64_t v1455 = 0;
              uint64_t v1456 = (v1454 - 1);
              if ((int)v1454 - 1 >= 0)
              {
                uint64_t v1457 = *(void *)(*v17 + 24);
                int v1458 = v1720;
                do
                {
                  ldiv_t v1459 = ldiv(v1458, *(int *)(v1453 + 4 * v1456));
                  int v1458 = v1459.quot;
                  v1455 += *(void *)(v1457 + 8 * v1456--) * v1459.rem;
                }
                while (v1456 != -1);
              }
              uint64_t v1460 = *(void *)*v18;
              unint64_t v1461 = (unint64_t)(*(void *)(*v18 + 8) - v1460) >> 2;
              uint64_t v1462 = 0;
              uint64_t v1463 = (v1461 - 1);
              if ((int)v1461 - 1 >= 0)
              {
                uint64_t v1464 = *(void *)(*v18 + 24);
                int v1465 = v1720;
                do
                {
                  ldiv_t v1466 = ldiv(v1465, *(int *)(v1460 + 4 * v1463));
                  int v1465 = v1466.quot;
                  v1462 += *(void *)(v1464 + 8 * v1463--) * v1466.rem;
                }
                while (v1463 != -1);
              }
              if ((int)v1726 >= 1)
              {
                uint64_t v1467 = 0;
                char v1468 = *((unsigned char *)v1663 + (int)v1462);
                unsigned int v1469 = v1648;
                do
                {
                  *(unsigned char *)(v1452 + v1467) = *(unsigned char *)(v1683 + (int)v1455 + v1467) & v1468;
                  --v1469;
                  ++v1467;
                }
                while (v1469 > 1);
                v140 = *(void **)v1;
              }
              v1452 += v1702;
              v1720 += v1702;
            }
            while (v1720 < v140[6]);
          }
          break;
        case 3:
          if (v146 == 2)
          {
            int v1159 = *v142;
            if (*v142)
            {
              unint64_t v1160 = 0;
              uint64_t v1161 = 0;
              uint64_t v1162 = 0;
              uint64_t v1163 = *(void *)(v141 + 152);
              v1164 = v251[19];
              uint64_t v1165 = v140[19];
              do
              {
                if (v142[1])
                {
                  unint64_t v1166 = 0;
                  do
                  {
                    if ((int)v322 >= 1)
                    {
                      uint64_t v1167 = 0;
                      unsigned int v1168 = v322 + 1;
                      do
                      {
                        *(unsigned char *)(v1165 + v1167) = *((unsigned char *)v1164 + v1161 + v1167) & *(unsigned char *)(v1163 + v1162 + v1167);
                        --v1168;
                        ++v1167;
                      }
                      while (v1168 > 1);
                      uint64_t v141 = *v17;
                      v251 = (int **)*v18;
                      v142 = *(int **)*v17;
                    }
                    v1169 = *(void **)(v141 + 24);
                    uint64_t v1170 = v1169[1];
                    v1162 += v1170;
                    v1161 += *((void *)v251[3] + 1);
                    v1165 += (int)v322;
                    ++v1166;
                    unint64_t v1171 = v142[1];
                  }
                  while (v1166 < v1171);
                  int v1159 = *v142;
                  v252 = *v251;
                }
                else
                {
                  unint64_t v1171 = 0;
                  v1169 = *(void **)(v141 + 24);
                  uint64_t v1170 = v1169[1];
                }
                uint64_t v1162 = *v1169 + v1162 - v1171 * v1170;
                uint64_t v1161 = *(void *)v251[3] + v1161 - *((void *)v251[3] + 1) * v252[1];
                ++v1160;
              }
              while (v1160 < v1159);
            }
          }
          else if (v146 == 1)
          {
            int v371 = *v142;
            if (*v142)
            {
              unint64_t v372 = 0;
              uint64_t v373 = 0;
              uint64_t v374 = 0;
              uint64_t v375 = *(void *)(v141 + 152);
              v376 = v251[19];
              uint64_t v377 = v140[19];
              do
              {
                if ((int)v322 >= 1)
                {
                  uint64_t v378 = 0;
                  unsigned int v379 = v322 + 1;
                  do
                  {
                    *(unsigned char *)(v377 + v378) = *((unsigned char *)v376 + v373 + v378) & *(unsigned char *)(v375 + v374 + v378);
                    --v379;
                    ++v378;
                  }
                  while (v379 > 1);
                  uint64_t v141 = *v17;
                  v251 = (int **)*v18;
                  int v371 = **(_DWORD **)*v17;
                }
                v374 += **(void **)(v141 + 24);
                v373 += *(void *)v251[3];
                v377 += (int)v322;
                ++v372;
              }
              while (v372 < v371);
            }
          }
          else if (v140[6])
          {
            v1659 = v251[19];
            uint64_t v1675 = *(void *)(v141 + 152);
            uint64_t v1696 = (int)v322;
            unint64_t v1718 = 0;
            unsigned int v1644 = v322 + 1;
            uint64_t v1172 = v140[19];
            do
            {
              uint64_t v1173 = *(void *)*v17;
              unint64_t v1174 = (unint64_t)(*(void *)(*v17 + 8) - v1173) >> 2;
              uint64_t v1175 = 0;
              uint64_t v1176 = (v1174 - 1);
              if ((int)v1174 - 1 >= 0)
              {
                uint64_t v1177 = *(void *)(*v17 + 24);
                int v1178 = v1718;
                do
                {
                  ldiv_t v1179 = ldiv(v1178, *(int *)(v1173 + 4 * v1176));
                  int v1178 = v1179.quot;
                  v1175 += *(void *)(v1177 + 8 * v1176--) * v1179.rem;
                }
                while (v1176 != -1);
              }
              uint64_t v1180 = *(void *)*v18;
              unint64_t v1181 = (unint64_t)(*(void *)(*v18 + 8) - v1180) >> 2;
              uint64_t v1182 = 0;
              uint64_t v1183 = (v1181 - 1);
              if ((int)v1181 - 1 >= 0)
              {
                uint64_t v1184 = *(void *)(*v18 + 24);
                int v1185 = v1718;
                do
                {
                  ldiv_t v1186 = ldiv(v1185, *(int *)(v1180 + 4 * v1183));
                  int v1185 = v1186.quot;
                  v1182 += *(void *)(v1184 + 8 * v1183--) * v1186.rem;
                }
                while (v1183 != -1);
              }
              if ((int)v1726 >= 1)
              {
                uint64_t v1187 = 0;
                unsigned int v1188 = v1644;
                do
                {
                  *(unsigned char *)(v1172 + v1187) = *((unsigned char *)v1659 + (int)v1182 + v1187) & *(unsigned char *)(v1675
                                                                                                + (int)v1175
                                                                                                + v1187);
                  --v1188;
                  ++v1187;
                }
                while (v1188 > 1);
                v140 = *(void **)v1;
              }
              v1172 += v1696;
              v1718 += v1696;
            }
            while (v1718 < v140[6]);
          }
          break;
        default:
LABEL_361:
          switch(v318)
          {
            case 1uLL:
              if (v140[6])
              {
                unint64_t v323 = 0;
                uint64_t v324 = 0;
                uint64_t v325 = 0;
                uint64_t v326 = *(void *)(v141 + 152);
                v327 = v251[19];
                uint64_t v328 = v140[19];
                do
                {
                  *(unsigned char *)(v328 + v323) = *((unsigned char *)v327 + v324) & *(unsigned char *)(v326 + v325);
                  v325 += **(void **)(*v17 + 24);
                  v324 += **(void **)(*v18 + 24);
                  ++v323;
                }
                while (v323 < *(void *)(*(void *)v1 + 48));
              }
              break;
            case 2uLL:
              int v669 = *v142;
              if (*v142)
              {
                unint64_t v670 = 0;
                uint64_t v671 = 0;
                uint64_t v672 = 0;
                uint64_t v673 = 0;
                uint64_t v674 = *(void *)(v141 + 152);
                v675 = v251[19];
                uint64_t v676 = v140[19];
                do
                {
                  if (v142[1])
                  {
                    unint64_t v677 = 0;
                    do
                    {
                      *(unsigned char *)(v676 + v671 + v677) = *((unsigned char *)v675 + v672) & *(unsigned char *)(v674 + v673);
                      uint64_t v141 = *v17;
                      v678 = *(void **)(*v17 + 24);
                      uint64_t v679 = v678[1];
                      v673 += v679;
                      v251 = (int **)*v18;
                      v680 = *(int **)(*v18 + 24);
                      uint64_t v681 = *((void *)v680 + 1);
                      v672 += v681;
                      ++v677;
                      v142 = *(int **)*v17;
                      unint64_t v682 = v142[1];
                    }
                    while (v677 < v682);
                    int v669 = *v142;
                    v252 = *v251;
                    v671 += v677;
                  }
                  else
                  {
                    unint64_t v682 = 0;
                    v678 = *(void **)(v141 + 24);
                    uint64_t v679 = v678[1];
                    v680 = v251[3];
                    uint64_t v681 = *((void *)v680 + 1);
                  }
                  uint64_t v673 = *v678 + v673 - v682 * v679;
                  uint64_t v672 = *(void *)v680 + v672 - v681 * v252[1];
                  ++v670;
                }
                while (v670 < v669);
              }
              break;
            case 3uLL:
              int v683 = *v142;
              if (*v142)
              {
                unint64_t v684 = 0;
                uint64_t v685 = 0;
                uint64_t v686 = 0;
                uint64_t v687 = 0;
                uint64_t v688 = *(void *)(v141 + 152);
                v689 = v251[19];
                uint64_t v690 = v140[19];
                do
                {
                  if (v142[1])
                  {
                    unint64_t v691 = 0;
                    do
                    {
                      if (v142[2])
                      {
                        unint64_t v692 = 0;
                        do
                        {
                          *(unsigned char *)(v690 + v685 + v692) = *((unsigned char *)v689 + v686) & *(unsigned char *)(v688 + v687);
                          uint64_t v141 = *v17;
                          v693 = *(void **)(*v17 + 24);
                          uint64_t v694 = v693[2];
                          v687 += v694;
                          v251 = (int **)*v18;
                          v695 = *(int **)(*v18 + 24);
                          uint64_t v696 = *((void *)v695 + 2);
                          v686 += v696;
                          ++v692;
                          v142 = *(int **)*v17;
                          unint64_t v697 = v142[2];
                        }
                        while (v692 < v697);
                        v252 = *v251;
                        v685 += v692;
                      }
                      else
                      {
                        unint64_t v697 = 0;
                        v693 = *(void **)(v141 + 24);
                        uint64_t v694 = v693[2];
                        v695 = v251[3];
                        uint64_t v696 = *((void *)v695 + 2);
                      }
                      uint64_t v698 = v693[1];
                      uint64_t v687 = v698 + v687 - v697 * v694;
                      uint64_t v686 = *((void *)v695 + 1) + v686 - v696 * v252[2];
                      ++v691;
                      unint64_t v699 = v142[1];
                    }
                    while (v691 < v699);
                    int v683 = *v142;
                  }
                  else
                  {
                    unint64_t v699 = 0;
                    v693 = *(void **)(v141 + 24);
                    uint64_t v698 = v693[1];
                  }
                  uint64_t v687 = *v693 + v687 - v699 * v698;
                  uint64_t v686 = *(void *)v251[3] + v686 - *((void *)v251[3] + 1) * v252[1];
                  ++v684;
                }
                while (v684 < v683);
              }
              break;
            case 4uLL:
              int v700 = *v142;
              if (*v142)
              {
                unint64_t v701 = 0;
                uint64_t v702 = 0;
                uint64_t v703 = 0;
                uint64_t v704 = 0;
                uint64_t v705 = *(void *)(v141 + 152);
                v706 = v251[19];
                uint64_t v707 = v140[19];
                do
                {
                  if (v142[1])
                  {
                    unint64_t v708 = 0;
                    do
                    {
                      if (v142[2])
                      {
                        unint64_t v709 = 0;
                        do
                        {
                          if (v142[3])
                          {
                            unint64_t v710 = 0;
                            do
                            {
                              *(unsigned char *)(v707 + v702 + v710) = *((unsigned char *)v706 + v703) & *(unsigned char *)(v705 + v704);
                              uint64_t v141 = *v17;
                              v711 = *(void **)(*v17 + 24);
                              uint64_t v712 = v711[3];
                              v704 += v712;
                              v251 = (int **)*v18;
                              v713 = *(int **)(*v18 + 24);
                              uint64_t v714 = *((void *)v713 + 3);
                              v703 += v714;
                              ++v710;
                              v142 = *(int **)*v17;
                              unint64_t v715 = v142[3];
                            }
                            while (v710 < v715);
                            v252 = *v251;
                            v702 += v710;
                          }
                          else
                          {
                            unint64_t v715 = 0;
                            v711 = *(void **)(v141 + 24);
                            uint64_t v712 = v711[3];
                            v713 = v251[3];
                            uint64_t v714 = *((void *)v713 + 3);
                          }
                          uint64_t v716 = v711[2];
                          uint64_t v704 = v716 + v704 - v715 * v712;
                          uint64_t v703 = *((void *)v713 + 2) + v703 - v714 * v252[3];
                          ++v709;
                          unint64_t v717 = v142[2];
                        }
                        while (v709 < v717);
                      }
                      else
                      {
                        unint64_t v717 = 0;
                        v711 = *(void **)(v141 + 24);
                        uint64_t v716 = v711[2];
                      }
                      uint64_t v704 = v711[1] + v704 - v717 * v716;
                      uint64_t v703 = *((void *)v251[3] + 1) + v703 - *((void *)v251[3] + 2) * v252[2];
                      ++v708;
                      unint64_t v718 = v142[1];
                    }
                    while (v708 < v718);
                    int v700 = *v142;
                  }
                  else
                  {
                    unint64_t v718 = 0;
                  }
                  uint64_t v704 = **(void **)(v141 + 24) + v704 - *(void *)(*(void *)(v141 + 24) + 8) * v718;
                  uint64_t v703 = *(void *)v251[3] + v703 - *((void *)v251[3] + 1) * v252[1];
                  ++v701;
                }
                while (v701 < v700);
              }
              break;
            default:
              if (v140[6])
              {
                unint64_t v653 = 0;
                v1713 = v251[19];
                uint64_t v1728 = *(void *)(v141 + 152);
                uint64_t v654 = v140[19];
                do
                {
                  uint64_t v655 = *(void *)*v17;
                  unint64_t v656 = (unint64_t)(*(void *)(*v17 + 8) - v655) >> 2;
                  uint64_t v657 = 0;
                  uint64_t v658 = (v656 - 1);
                  if ((int)v656 - 1 >= 0)
                  {
                    uint64_t v659 = *(void *)(*v17 + 24);
                    int v660 = v653;
                    do
                    {
                      ldiv_t v661 = ldiv(v660, *(int *)(v655 + 4 * v658));
                      int v660 = v661.quot;
                      v657 += *(void *)(v659 + 8 * v658--) * v661.rem;
                    }
                    while (v658 != -1);
                  }
                  uint64_t v662 = *(void *)*v18;
                  unint64_t v663 = (unint64_t)(*(void *)(*v18 + 8) - v662) >> 2;
                  uint64_t v664 = 0;
                  uint64_t v665 = (v663 - 1);
                  if ((int)v663 - 1 >= 0)
                  {
                    uint64_t v666 = *(void *)(*v18 + 24);
                    int v667 = v653;
                    do
                    {
                      ldiv_t v668 = ldiv(v667, *(int *)(v662 + 4 * v665));
                      int v667 = v668.quot;
                      v664 += *(void *)(v666 + 8 * v665--) * v668.rem;
                    }
                    while (v665 != -1);
                  }
                  *(unsigned char *)(v654 + v653++) = *((unsigned char *)v1713 + (int)v664) & *(unsigned char *)(v1728 + (int)v657);
                }
                while (v653 < *(void *)(*(void *)v1 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 4:
      v9 = *(uint64_t **)a1;
      v8 = *(uint64_t **)(a1 + 8);
      switch(v22)
      {
        case 0:
LABEL_18:
          **(_DWORD **)(*(void *)v1 + 152) = **(_DWORD **)(*v8 + 152) & **(_DWORD **)(*v9 + 152);
          return;
        case 1:
          int v177 = *(_DWORD *)(*v8 + 160);
          if (v177 >= 1)
          {
            int v178 = **(_DWORD **)(*v9 + 152);
            v179 = *(int **)(*(void *)v1 + 152);
            v180 = *(int **)(*v8 + 152);
            unsigned int v181 = v177 + 1;
            do
            {
              int v182 = *v180++;
              *v179++ = v182 & v178;
              --v181;
            }
            while (v181 > 1);
          }
          return;
        case 2:
          int v183 = *(_DWORD *)(*v9 + 160);
          if (v183 >= 1)
          {
            int v184 = **(_DWORD **)(*v8 + 152);
            v185 = *(int **)(*(void *)v1 + 152);
            v186 = *(int **)(*v9 + 152);
            unsigned int v187 = v183 + 1;
            do
            {
              int v188 = *v186++;
              *v185++ = v188 & v184;
              --v187;
            }
            while (v187 > 1);
          }
          return;
        case 3:
          int v189 = *(_DWORD *)(*(void *)v1 + 48);
          if (v189 >= 1)
          {
            v190 = *(int **)(*(void *)v1 + 152);
            v191 = *(int **)(*v8 + 152);
            v192 = *(int **)(*v9 + 152);
            unsigned int v193 = v189 + 1;
            do
            {
              int v195 = *v192++;
              int v194 = v195;
              int v196 = *v191++;
              *v190++ = v196 & v194;
              --v193;
            }
            while (v193 > 1);
          }
          return;
        default:
          v168 = *(void **)v1;
          v169 = (void *)*v9;
          v170 = *(int **)*v9;
          uint64_t v171 = (v169[1] - (void)v170) >> 2;
          uint64_t v172 = (v171 - 1);
          if ((int)v172 >= -1) {
            int v173 = -1;
          }
          else {
            int v173 = v171 - 1;
          }
          int v174 = v173 + 1;
          int v175 = v171 + 1;
          break;
      }
      while (1)
      {
        unsigned int v176 = v175 - 2;
        if (v175 - 2 < 0) {
          break;
        }
        --v175;
        if (*(void *)(v169[3] + 8 * v176) != *(void *)(v168[3] + 8 * v176)) {
          goto LABEL_226;
        }
      }
      int v175 = v174;
LABEL_226:
      v258 = (void *)*v8;
      v259 = *(int **)*v8;
      uint64_t v260 = (v258[1] - (void)v259) >> 2;
      uint64_t v261 = (v260 - 1);
      if ((int)v261 >= -1) {
        int v262 = -1;
      }
      else {
        int v262 = v260 - 1;
      }
      int v263 = v262 + 1;
      int v264 = v260 + 1;
      while (1)
      {
        unsigned int v265 = v264 - 2;
        if (v264 - 2 < 0) {
          break;
        }
        --v264;
        if (*(void *)(v258[3] + 8 * v265) != *(void *)(v168[3] + 8 * v265)) {
          goto LABEL_257;
        }
      }
      int v264 = v263;
LABEL_257:
      int v280 = v171 + 1;
      while (1)
      {
        unsigned int v281 = v280 - 2;
        if (v280 - 2 < 0) {
          break;
        }
        --v280;
        if (*(void *)(v169[3] + 8 * v281)) {
          goto LABEL_282;
        }
      }
      int v280 = v174;
LABEL_282:
      int v290 = v260 + 1;
      while (1)
      {
        unsigned int v291 = v290 - 2;
        if (v290 - 2 < 0) {
          break;
        }
        --v290;
        if (*(void *)(v258[3] + 8 * v291)) {
          goto LABEL_367;
        }
      }
      int v290 = v263;
LABEL_367:
      unint64_t v329 = (uint64_t)(v168[1] - *v168) >> 2;
      if (v175 <= v264) {
        int v330 = v264;
      }
      else {
        int v330 = v175;
      }
      if (v175 <= v290) {
        int v175 = v290;
      }
      if (v280 > v264) {
        int v264 = v280;
      }
      if (v329 > v264)
      {
        int v331 = 1;
      }
      else
      {
        int v264 = (uint64_t)(v168[1] - *v168) >> 2;
        int v331 = 4;
      }
      if (v329 > v175)
      {
        int v332 = 2;
      }
      else
      {
        int v175 = v264;
        int v332 = v331;
      }
      if (v329 > v330)
      {
        int v175 = v330;
        int v332 = 3;
      }
      uint64_t v1709 = v261;
      uint64_t v1724 = v172;
      if (!v175) {
        goto LABEL_384;
      }
      unint64_t v333 = *(void *)(v168[3] + 8 * (v175 - 1));
      if (v333 < 0x10) {
        goto LABEL_384;
      }
      switch(v332)
      {
        case 1:
          if (v175 == 2)
          {
            int v1470 = *v170;
            if (*v170)
            {
              unint64_t v1471 = 0;
              uint64_t v1472 = 0;
              uint64_t v1473 = 0;
              uint64_t v1474 = v169[19];
              uint64_t v1475 = v258[19];
              uint64_t v1476 = v168[19];
              v1477 = (uint64_t *)v169[3];
              uint64_t v1478 = *v1477;
              uint64_t v1479 = v1477[1];
              v1480 = (uint64_t *)v258[3];
              uint64_t v1481 = *v1480;
              uint64_t v1482 = v1480[1];
              int v1483 = v170[1];
              int v1484 = v1483;
              do
              {
                if (v1484)
                {
                  unint64_t v1485 = 0;
                  uint64_t v1486 = v1475 + 4 * v1472;
                  do
                  {
                    if ((int)v333 >= 1)
                    {
                      uint64_t v1487 = 0;
                      int v1488 = *(_DWORD *)(v1474 + 4 * v1473);
                      unsigned int v1489 = v333 + 1;
                      do
                      {
                        *(_DWORD *)(v1476 + v1487) = *(_DWORD *)(v1486 + v1487) & v1488;
                        --v1489;
                        v1487 += 4;
                      }
                      while (v1489 > 1);
                      int v1483 = v170[1];
                    }
                    v1473 += v1479;
                    v1472 += v1482;
                    v1476 += 4 * (int)v333;
                    ++v1485;
                    v1486 += 4 * v1482;
                  }
                  while (v1485 < v1483);
                  uint64_t v1490 = v1483;
                  int v1470 = *v170;
                  int v1484 = v1483;
                }
                else
                {
                  uint64_t v1490 = 0;
                }
                uint64_t v1473 = v1473 + v1478 - v1490 * v1479;
                uint64_t v1472 = v1472 + v1481 - v1482 * v259[1];
                ++v1471;
              }
              while (v1471 < v1470);
            }
          }
          else if (v175 == 1)
          {
            int v948 = *v170;
            if (*v170)
            {
              unint64_t v949 = 0;
              uint64_t v950 = 0;
              uint64_t v951 = v169[19];
              uint64_t v952 = v258[19];
              uint64_t v953 = v168[19];
              uint64_t v954 = *(void *)v169[3];
              uint64_t v955 = 4 * *(void *)v258[3];
              do
              {
                if ((int)v333 >= 1)
                {
                  uint64_t v956 = 0;
                  int v957 = *(_DWORD *)(v951 + 4 * v950);
                  unsigned int v958 = v333 + 1;
                  do
                  {
                    *(_DWORD *)(v953 + v956) = *(_DWORD *)(v952 + v956) & v957;
                    --v958;
                    v956 += 4;
                  }
                  while (v958 > 1);
                  int v948 = *v170;
                }
                v950 += v954;
                ++v949;
                v953 += 4 * (int)v333;
                v952 += v955;
              }
              while (v949 < v948);
            }
          }
          else
          {
            unint64_t v1684 = v168[6];
            if (v1684)
            {
              unint64_t v1703 = 0;
              uint64_t v1624 = v258[19];
              uint64_t v1636 = v169[19];
              uint64_t v1491 = v168[19];
              do
              {
                uint64_t v1492 = 0;
                if ((v172 & 0x80000000) == 0)
                {
                  uint64_t v1493 = v169[3];
                  uint64_t v1494 = v172;
                  int v1495 = v1703;
                  do
                  {
                    ldiv_t v1496 = ldiv(v1495, v170[v1494]);
                    int v1495 = v1496.quot;
                    v1492 += *(void *)(v1493 + 8 * v1494--) * v1496.rem;
                  }
                  while (v1494 != -1);
                }
                uint64_t v1497 = v1709;
                if ((v1709 & 0x80000000) != 0)
                {
                  LODWORD(v1498) = 0;
                }
                else
                {
                  uint64_t v1498 = 0;
                  uint64_t v1499 = v258[3];
                  int v1500 = v1703;
                  do
                  {
                    ldiv_t v1501 = ldiv(v1500, v259[v1497]);
                    int v1500 = v1501.quot;
                    v1498 += *(void *)(v1499 + 8 * v1497--) * v1501.rem;
                  }
                  while (v1497 != -1);
                }
                uint64_t v172 = v1724;
                if ((int)v333 >= 1)
                {
                  uint64_t v1502 = 0;
                  int v1503 = *(_DWORD *)(v1636 + 4 * (int)v1492);
                  unsigned int v1504 = v333 + 1;
                  do
                  {
                    *(_DWORD *)(v1491 + v1502) = *(_DWORD *)(v1624 + 4 * (int)v1498 + v1502) & v1503;
                    --v1504;
                    v1502 += 4;
                  }
                  while (v1504 > 1);
                }
                v1491 += 4 * (int)v333;
                v1703 += (int)v333;
              }
              while (v1703 < v1684);
            }
          }
          break;
        case 2:
          if (v175 == 2)
          {
            int v1505 = *v170;
            if (*v170)
            {
              unint64_t v1506 = 0;
              uint64_t v1507 = 0;
              uint64_t v1508 = 0;
              uint64_t v1509 = v169[19];
              uint64_t v1510 = v258[19];
              uint64_t v1511 = v168[19];
              v1512 = (uint64_t *)v169[3];
              uint64_t v1513 = *v1512;
              uint64_t v1514 = v1512[1];
              v1515 = (uint64_t *)v258[3];
              uint64_t v1516 = *v1515;
              uint64_t v1517 = v1515[1];
              int v1518 = v170[1];
              int v1519 = v1518;
              do
              {
                if (v1519)
                {
                  unint64_t v1520 = 0;
                  uint64_t v1521 = v1509 + 4 * v1508;
                  do
                  {
                    if ((int)v333 >= 1)
                    {
                      uint64_t v1522 = 0;
                      int v1523 = *(_DWORD *)(v1510 + 4 * v1507);
                      unsigned int v1524 = v333 + 1;
                      do
                      {
                        *(_DWORD *)(v1511 + v1522) = *(_DWORD *)(v1521 + v1522) & v1523;
                        --v1524;
                        v1522 += 4;
                      }
                      while (v1524 > 1);
                      int v1518 = v170[1];
                    }
                    v1508 += v1514;
                    v1507 += v1517;
                    v1511 += 4 * (int)v333;
                    ++v1520;
                    v1521 += 4 * v1514;
                  }
                  while (v1520 < v1518);
                  uint64_t v1525 = v1518;
                  int v1505 = *v170;
                  int v1519 = v1518;
                }
                else
                {
                  uint64_t v1525 = 0;
                }
                uint64_t v1508 = v1508 + v1513 - v1525 * v1514;
                uint64_t v1507 = v1507 + v1516 - v1517 * v259[1];
                ++v1506;
              }
              while (v1506 < v1505);
            }
          }
          else if (v175 == 1)
          {
            int v959 = *v170;
            if (*v170)
            {
              unint64_t v960 = 0;
              uint64_t v961 = 0;
              uint64_t v962 = v169[19];
              uint64_t v963 = v258[19];
              uint64_t v964 = v168[19];
              uint64_t v965 = *(void *)v258[3];
              uint64_t v966 = 4 * *(void *)v169[3];
              do
              {
                if ((int)v333 >= 1)
                {
                  uint64_t v967 = 0;
                  int v968 = *(_DWORD *)(v963 + 4 * v961);
                  unsigned int v969 = v333 + 1;
                  do
                  {
                    *(_DWORD *)(v964 + v967) = *(_DWORD *)(v962 + v967) & v968;
                    --v969;
                    v967 += 4;
                  }
                  while (v969 > 1);
                  int v959 = *v170;
                }
                v961 += v965;
                ++v960;
                v964 += 4 * (int)v333;
                v962 += v966;
              }
              while (v960 < v959);
            }
          }
          else
          {
            unint64_t v1685 = v168[6];
            if (v1685)
            {
              unint64_t v1704 = 0;
              uint64_t v1625 = v258[19];
              uint64_t v1637 = v169[19];
              uint64_t v1526 = v168[19];
              do
              {
                uint64_t v1527 = 0;
                if ((v172 & 0x80000000) == 0)
                {
                  uint64_t v1528 = v169[3];
                  uint64_t v1529 = v172;
                  int v1530 = v1704;
                  do
                  {
                    ldiv_t v1531 = ldiv(v1530, v170[v1529]);
                    int v1530 = v1531.quot;
                    v1527 += *(void *)(v1528 + 8 * v1529--) * v1531.rem;
                  }
                  while (v1529 != -1);
                }
                uint64_t v1532 = v1709;
                if ((v1709 & 0x80000000) != 0)
                {
                  LODWORD(v1533) = 0;
                }
                else
                {
                  uint64_t v1533 = 0;
                  uint64_t v1534 = v258[3];
                  int v1535 = v1704;
                  do
                  {
                    ldiv_t v1536 = ldiv(v1535, v259[v1532]);
                    int v1535 = v1536.quot;
                    v1533 += *(void *)(v1534 + 8 * v1532--) * v1536.rem;
                  }
                  while (v1532 != -1);
                }
                uint64_t v172 = v1724;
                if ((int)v333 >= 1)
                {
                  uint64_t v1537 = 0;
                  int v1538 = *(_DWORD *)(v1625 + 4 * (int)v1533);
                  unsigned int v1539 = v333 + 1;
                  do
                  {
                    *(_DWORD *)(v1526 + v1537) = *(_DWORD *)(v1637 + 4 * (int)v1527 + v1537) & v1538;
                    --v1539;
                    v1537 += 4;
                  }
                  while (v1539 > 1);
                }
                v1526 += 4 * (int)v333;
                v1704 += (int)v333;
              }
              while (v1704 < v1685);
            }
          }
          break;
        case 3:
          if (v175 == 2)
          {
            int v1189 = *v170;
            if (*v170)
            {
              unint64_t v1190 = 0;
              uint64_t v1191 = 0;
              uint64_t v1192 = 0;
              uint64_t v1193 = v169[19];
              uint64_t v1194 = v258[19];
              uint64_t v1195 = v168[19];
              v1196 = (uint64_t *)v169[3];
              uint64_t v1197 = *v1196;
              uint64_t v1198 = v1196[1];
              v1199 = (uint64_t *)v258[3];
              uint64_t v1200 = *v1199;
              uint64_t v1201 = v1199[1];
              int v1202 = v170[1];
              int v1203 = v1202;
              do
              {
                if (v1203)
                {
                  unint64_t v1204 = 0;
                  uint64_t v1205 = v1194 + 4 * v1191;
                  uint64_t v1206 = v1193 + 4 * v1192;
                  do
                  {
                    if ((int)v333 >= 1)
                    {
                      uint64_t v1207 = 0;
                      unsigned int v1208 = v333 + 1;
                      do
                      {
                        *(_DWORD *)(v1195 + v1207) = *(_DWORD *)(v1205 + v1207) & *(_DWORD *)(v1206 + v1207);
                        --v1208;
                        v1207 += 4;
                      }
                      while (v1208 > 1);
                      int v1202 = v170[1];
                    }
                    v1192 += v1198;
                    v1191 += v1201;
                    v1195 += 4 * (int)v333;
                    ++v1204;
                    v1205 += 4 * v1201;
                    v1206 += 4 * v1198;
                  }
                  while (v1204 < v1202);
                  uint64_t v1209 = v1202;
                  int v1189 = *v170;
                  int v1203 = v1202;
                }
                else
                {
                  uint64_t v1209 = 0;
                }
                uint64_t v1192 = v1192 + v1197 - v1209 * v1198;
                uint64_t v1191 = v1191 + v1200 - v1201 * v259[1];
                ++v1190;
              }
              while (v1190 < v1189);
            }
          }
          else if (v175 == 1)
          {
            int v380 = *v170;
            if (*v170)
            {
              unint64_t v381 = 0;
              uint64_t v382 = v169[19];
              uint64_t v383 = v258[19];
              uint64_t v384 = v168[19];
              uint64_t v385 = 4 * *(void *)v258[3];
              uint64_t v386 = 4 * *(void *)v169[3];
              do
              {
                if ((int)v333 >= 1)
                {
                  uint64_t v387 = 0;
                  unsigned int v388 = v333 + 1;
                  do
                  {
                    *(_DWORD *)(v384 + v387) = *(_DWORD *)(v383 + v387) & *(_DWORD *)(v382 + v387);
                    --v388;
                    v387 += 4;
                  }
                  while (v388 > 1);
                  int v380 = *v170;
                }
                ++v381;
                v384 += 4 * (int)v333;
                v383 += v385;
                v382 += v386;
              }
              while (v381 < v380);
            }
          }
          else
          {
            unint64_t v1676 = v168[6];
            if (v1676)
            {
              unint64_t v1697 = 0;
              uint64_t v1618 = v258[19];
              uint64_t v1630 = v169[19];
              uint64_t v1210 = v168[19];
              do
              {
                uint64_t v1211 = 0;
                if ((v172 & 0x80000000) == 0)
                {
                  uint64_t v1212 = v169[3];
                  uint64_t v1213 = v172;
                  int v1214 = v1697;
                  do
                  {
                    ldiv_t v1215 = ldiv(v1214, v170[v1213]);
                    int v1214 = v1215.quot;
                    v1211 += *(void *)(v1212 + 8 * v1213--) * v1215.rem;
                  }
                  while (v1213 != -1);
                }
                uint64_t v1216 = v1709;
                if ((v1709 & 0x80000000) != 0)
                {
                  LODWORD(v1217) = 0;
                }
                else
                {
                  uint64_t v1217 = 0;
                  uint64_t v1218 = v258[3];
                  int v1219 = v1697;
                  do
                  {
                    ldiv_t v1220 = ldiv(v1219, v259[v1216]);
                    int v1219 = v1220.quot;
                    v1217 += *(void *)(v1218 + 8 * v1216--) * v1220.rem;
                  }
                  while (v1216 != -1);
                }
                uint64_t v172 = v1724;
                if ((int)v333 >= 1)
                {
                  uint64_t v1221 = 0;
                  unsigned int v1222 = v333 + 1;
                  do
                  {
                    *(_DWORD *)(v1210 + v1221) = *(_DWORD *)(v1618 + 4 * (int)v1217 + v1221) & *(_DWORD *)(v1630 + 4 * (int)v1211 + v1221);
                    --v1222;
                    v1221 += 4;
                  }
                  while (v1222 > 1);
                }
                v1210 += 4 * (int)v333;
                v1697 += (int)v333;
              }
              while (v1697 < v1676);
            }
          }
          break;
        default:
LABEL_384:
          switch(v329)
          {
            case 1uLL:
              uint64_t v334 = v168[6];
              if (v334)
              {
                v335 = (_DWORD *)v169[19];
                v336 = (_DWORD *)v258[19];
                v337 = (int *)v168[19];
                uint64_t v338 = 4 * *(void *)v258[3];
                uint64_t v339 = 4 * *(void *)v169[3];
                do
                {
                  *v337++ = *v336 & *v335;
                  v336 = (_DWORD *)((char *)v336 + v338);
                  v335 = (_DWORD *)((char *)v335 + v339);
                  --v334;
                }
                while (v334);
              }
              break;
            case 2uLL:
              int v731 = *v170;
              if (*v170)
              {
                unint64_t v732 = 0;
                uint64_t v733 = 0;
                uint64_t v734 = 0;
                uint64_t v735 = 0;
                uint64_t v736 = v169[19];
                uint64_t v737 = v258[19];
                uint64_t v738 = v168[19];
                v739 = (uint64_t *)v169[3];
                uint64_t v740 = *v739;
                uint64_t v741 = v739[1];
                v742 = (uint64_t *)v258[3];
                uint64_t v744 = *v742;
                uint64_t v743 = v742[1];
                int v745 = v170[1];
                do
                {
                  if (v745)
                  {
                    for (unint64_t n = 0; n < v745; ++n)
                    {
                      *(_DWORD *)(v738 + 4 * v733 + 4 * n) = *(_DWORD *)(v737 + 4 * v734) & *(_DWORD *)(v736 + 4 * v735);
                      v735 += v741;
                      v734 += v743;
                      int v745 = v170[1];
                    }
                    uint64_t v747 = v745;
                    int v731 = *v170;
                    v733 += n;
                  }
                  else
                  {
                    uint64_t v747 = 0;
                  }
                  uint64_t v735 = v735 + v740 - v747 * v741;
                  uint64_t v734 = v734 + v744 - v743 * v259[1];
                  ++v732;
                }
                while (v732 < v731);
              }
              break;
            case 3uLL:
              int v748 = *v170;
              if (*v170)
              {
                unint64_t v749 = 0;
                uint64_t v750 = 0;
                uint64_t v751 = 0;
                uint64_t v752 = 0;
                uint64_t v753 = v169[19];
                uint64_t v754 = v258[19];
                uint64_t v755 = v168[19];
                v756 = (uint64_t *)v169[3];
                uint64_t v757 = *v756;
                uint64_t v758 = v756[1];
                v759 = (uint64_t *)v258[3];
                uint64_t v760 = *v759;
                uint64_t v761 = v759[1];
                int v762 = v170[1];
                int v763 = v762;
                do
                {
                  if (v763)
                  {
                    unint64_t v764 = 0;
                    uint64_t v765 = v756[2];
                    uint64_t v766 = v759[2];
                    int v767 = v170[2];
                    do
                    {
                      if (v767)
                      {
                        for (unint64_t ii = 0; ii < v767; ++ii)
                        {
                          *(_DWORD *)(v755 + 4 * v750 + 4 * ii) = *(_DWORD *)(v754 + 4 * v751) & *(_DWORD *)(v753 + 4 * v752);
                          v752 += v765;
                          v751 += v766;
                          int v767 = v170[2];
                        }
                        uint64_t v769 = v767;
                        int v762 = v170[1];
                        v750 += ii;
                      }
                      else
                      {
                        uint64_t v769 = 0;
                      }
                      uint64_t v752 = v752 + v758 - v769 * v765;
                      uint64_t v751 = v751 + v761 - v766 * v259[2];
                      ++v764;
                    }
                    while (v764 < v762);
                    uint64_t v770 = v762;
                    int v748 = *v170;
                    int v763 = v762;
                  }
                  else
                  {
                    uint64_t v770 = 0;
                  }
                  uint64_t v752 = v752 + v757 - v770 * v758;
                  uint64_t v751 = v751 + v760 - v761 * v259[1];
                  ++v749;
                }
                while (v749 < v748);
              }
              break;
            case 4uLL:
              int v771 = *v170;
              if (*v170)
              {
                unint64_t v772 = 0;
                uint64_t v773 = 0;
                uint64_t v774 = 0;
                uint64_t v775 = 0;
                uint64_t v776 = v169[19];
                uint64_t v777 = v258[19];
                uint64_t v778 = v168[19];
                v779 = (uint64_t *)v169[3];
                uint64_t v780 = *v779;
                uint64_t v781 = v779[1];
                v782 = (uint64_t *)v258[3];
                uint64_t v783 = *v782;
                uint64_t v784 = v782[1];
                int v785 = v170[1];
                int v786 = v785;
                do
                {
                  if (v786)
                  {
                    unint64_t v787 = 0;
                    uint64_t v788 = v779[2];
                    uint64_t v789 = v782[2];
                    int v790 = v170[2];
                    int v791 = v790;
                    do
                    {
                      if (v791)
                      {
                        unint64_t v792 = 0;
                        uint64_t v793 = v779[3];
                        uint64_t v794 = v782[3];
                        int v795 = v170[3];
                        do
                        {
                          if (v795)
                          {
                            for (junint64_t j = 0; jj < v795; ++jj)
                            {
                              *(_DWORD *)(v778 + 4 * v773 + 4 * jj) = *(_DWORD *)(v777 + 4 * v774) & *(_DWORD *)(v776 + 4 * v775);
                              v775 += v793;
                              v774 += v794;
                              int v795 = v170[3];
                            }
                            uint64_t v797 = v795;
                            int v790 = v170[2];
                            v773 += jj;
                          }
                          else
                          {
                            uint64_t v797 = 0;
                          }
                          uint64_t v775 = v775 + v788 - v797 * v793;
                          uint64_t v774 = v774 + v789 - v794 * v259[3];
                          ++v792;
                        }
                        while (v792 < v790);
                        uint64_t v798 = v790;
                        int v785 = v170[1];
                        int v791 = v790;
                      }
                      else
                      {
                        uint64_t v798 = 0;
                      }
                      uint64_t v775 = v775 + v781 - v798 * v788;
                      uint64_t v774 = v774 + v784 - v789 * v259[2];
                      ++v787;
                    }
                    while (v787 < v785);
                    uint64_t v799 = v785;
                    int v771 = *v170;
                    int v786 = v785;
                  }
                  else
                  {
                    uint64_t v799 = 0;
                  }
                  uint64_t v775 = v775 + v780 - v799 * v781;
                  uint64_t v774 = v774 + v783 - v784 * v259[1];
                  ++v772;
                }
                while (v772 < v771);
              }
              break;
            default:
              uint64_t v719 = v168[6];
              if (v719)
              {
                uint64_t v720 = 0;
                uint64_t v1667 = v258[19];
                uint64_t v1692 = v169[19];
                uint64_t v1652 = v168[19];
                do
                {
                  uint64_t v721 = 0;
                  if ((v172 & 0x80000000) == 0)
                  {
                    uint64_t v722 = v169[3];
                    uint64_t v723 = v172;
                    int v724 = v720;
                    do
                    {
                      ldiv_t v725 = ldiv(v724, v170[v723]);
                      int v724 = v725.quot;
                      v721 += *(void *)(v722 + 8 * v723--) * v725.rem;
                    }
                    while (v723 != -1);
                  }
                  uint64_t v726 = v1709;
                  if ((v1709 & 0x80000000) != 0)
                  {
                    LODWORD(v727) = 0;
                  }
                  else
                  {
                    uint64_t v727 = 0;
                    uint64_t v728 = v258[3];
                    int v729 = v720;
                    do
                    {
                      ldiv_t v730 = ldiv(v729, v259[v726]);
                      int v729 = v730.quot;
                      v727 += *(void *)(v728 + 8 * v726--) * v730.rem;
                    }
                    while (v726 != -1);
                  }
                  *(_DWORD *)(v1652 + 4 * v720++) = *(_DWORD *)(v1667 + 4 * (int)v727) & *(_DWORD *)(v1692 + 4 * (int)v721);
                  uint64_t v172 = v1724;
                }
                while (v720 != v719);
              }
              break;
          }
          break;
      }
      return;
    case 5:
      v24 = *(uint64_t **)a1;
      v23 = *(uint64_t **)(a1 + 8);
      switch(v25)
      {
        case 0:
          **(void **)(*(void *)v1 + 152) = **(void **)(*v23 + 152) & **(void **)(*v24 + 152);
          return;
        case 1:
          int v206 = *(_DWORD *)(*v23 + 160);
          if (v206 >= 1)
          {
            uint64_t v207 = **(void **)(*v24 + 152);
            v208 = *(uint64_t **)(*(void *)v1 + 152);
            v209 = *(uint64_t **)(*v23 + 152);
            unsigned int v210 = v206 + 1;
            do
            {
              uint64_t v211 = *v209++;
              *v208++ = v211 & v207;
              --v210;
            }
            while (v210 > 1);
          }
          return;
        case 2:
          int v212 = *(_DWORD *)(*v24 + 160);
          if (v212 >= 1)
          {
            uint64_t v213 = **(void **)(*v23 + 152);
            v214 = *(uint64_t **)(*(void *)v1 + 152);
            v215 = *(uint64_t **)(*v24 + 152);
            unsigned int v216 = v212 + 1;
            do
            {
              uint64_t v217 = *v215++;
              *v214++ = v217 & v213;
              --v216;
            }
            while (v216 > 1);
          }
          return;
        case 3:
          int v218 = *(_DWORD *)(*(void *)v1 + 48);
          if (v218 >= 1)
          {
            v219 = *(uint64_t **)(*(void *)v1 + 152);
            v220 = *(uint64_t **)(*v23 + 152);
            v221 = *(uint64_t **)(*v24 + 152);
            unsigned int v222 = v218 + 1;
            do
            {
              uint64_t v224 = *v221++;
              uint64_t v223 = v224;
              uint64_t v225 = *v220++;
              *v219++ = v225 & v223;
              --v222;
            }
            while (v222 > 1);
          }
          return;
        default:
          v197 = *(void **)v1;
          v198 = (void *)*v24;
          v199 = *(int **)*v24;
          uint64_t v200 = (v198[1] - (void)v199) >> 2;
          uint64_t v201 = (v200 - 1);
          if ((int)v201 >= -1) {
            int v202 = -1;
          }
          else {
            int v202 = v200 - 1;
          }
          int v203 = v202 + 1;
          int v204 = v200 + 1;
          break;
      }
      break;
    default:
      exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x25A2B1470](exception, "[BitwiseBinary::eval_cpu] Type not supported");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  while (1)
  {
    unsigned int v205 = v204 - 2;
    if (v204 - 2 < 0) {
      break;
    }
    --v204;
    if (*(void *)(v198[3] + 8 * v205) != *(void *)(v197[3] + 8 * v205)) {
      goto LABEL_234;
    }
  }
  int v204 = v203;
LABEL_234:
  v266 = (void *)*v23;
  v267 = *(int **)*v23;
  uint64_t v268 = (v266[1] - (void)v267) >> 2;
  uint64_t v269 = (v268 - 1);
  if ((int)v269 >= -1) {
    int v270 = -1;
  }
  else {
    int v270 = v268 - 1;
  }
  int v271 = v270 + 1;
  int v272 = v268 + 1;
  while (1)
  {
    unsigned int v273 = v272 - 2;
    if (v272 - 2 < 0) {
      break;
    }
    --v272;
    if (*(void *)(v266[3] + 8 * v273) != *(void *)(v197[3] + 8 * v273)) {
      goto LABEL_262;
    }
  }
  int v272 = v271;
LABEL_262:
  int v282 = v200 + 1;
  while (1)
  {
    unsigned int v283 = v282 - 2;
    if (v282 - 2 < 0) {
      break;
    }
    --v282;
    if (*(void *)(v198[3] + 8 * v283)) {
      goto LABEL_287;
    }
  }
  int v282 = v203;
LABEL_287:
  int v292 = v268 + 1;
  while (1)
  {
    unsigned int v293 = v292 - 2;
    if (v292 - 2 < 0) {
      break;
    }
    --v292;
    if (*(void *)(v266[3] + 8 * v293)) {
      goto LABEL_390;
    }
  }
  int v292 = v271;
LABEL_390:
  unint64_t v340 = (uint64_t)(v197[1] - *v197) >> 2;
  if (v204 <= v272) {
    int v341 = v272;
  }
  else {
    int v341 = v204;
  }
  if (v204 <= v292) {
    int v204 = v292;
  }
  if (v282 > v272) {
    int v272 = v282;
  }
  if (v340 > v272)
  {
    int v342 = 1;
  }
  else
  {
    int v272 = (uint64_t)(v197[1] - *v197) >> 2;
    int v342 = 4;
  }
  if (v340 > v204)
  {
    int v343 = 2;
  }
  else
  {
    int v204 = v272;
    int v343 = v342;
  }
  if (v340 > v341)
  {
    int v204 = v341;
    int v343 = 3;
  }
  uint64_t v1710 = v269;
  uint64_t v1725 = v201;
  if (!v204) {
    goto LABEL_407;
  }
  unint64_t v344 = *(void *)(v197[3] + 8 * (v204 - 1));
  if (v344 < 0x10) {
    goto LABEL_407;
  }
  switch(v343)
  {
    case 1:
      if (v204 == 2)
      {
        uint64_t v1540 = *v199;
        if (v1540)
        {
          uint64_t v1541 = 0;
          uint64_t v1542 = 0;
          uint64_t v1543 = 0;
          uint64_t v1544 = v198[19];
          uint64_t v1545 = v266[19];
          uint64_t v1546 = v197[19];
          unint64_t v1547 = v199[1];
          v1548 = (uint64_t *)v198[3];
          uint64_t v1549 = *v1548;
          uint64_t v1550 = v1548[1];
          v1551 = (uint64_t *)v266[3];
          uint64_t v1552 = *v1551;
          uint64_t v1553 = v1551[1];
          if (v1547 <= 1) {
            uint64_t v1554 = 1;
          }
          else {
            uint64_t v1554 = v199[1];
          }
          uint64_t v1555 = v1549 - v1550 * v1547;
          uint64_t v1556 = v1552 - v1553 * v267[1];
          do
          {
            if (v1547)
            {
              uint64_t v1557 = 0;
              uint64_t v1558 = v1545 + 8 * v1542;
              do
              {
                if ((int)v344 >= 1)
                {
                  uint64_t v1559 = 0;
                  uint64_t v1560 = *(void *)(v1544 + 8 * v1543);
                  unsigned int v1561 = v344 + 1;
                  do
                  {
                    *(void *)(v1546 + v1559) = *(void *)(v1558 + v1559) & v1560;
                    --v1561;
                    v1559 += 8;
                  }
                  while (v1561 > 1);
                }
                v1543 += v1550;
                v1542 += v1553;
                v1546 += 8 * (int)v344;
                ++v1557;
                v1558 += 8 * v1553;
              }
              while (v1557 != v1554);
            }
            v1543 += v1555;
            v1542 += v1556;
            ++v1541;
          }
          while (v1541 != v1540);
        }
      }
      else if (v204 == 1)
      {
        uint64_t v970 = *v199;
        if (v970)
        {
          uint64_t v971 = 0;
          uint64_t v972 = 0;
          uint64_t v973 = v198[19];
          uint64_t v974 = v266[19];
          uint64_t v975 = v197[19];
          uint64_t v976 = *(void *)v198[3];
          uint64_t v977 = 8 * *(void *)v266[3];
          do
          {
            if ((int)v344 >= 1)
            {
              uint64_t v978 = 0;
              uint64_t v979 = *(void *)(v973 + 8 * v972);
              unsigned int v980 = v344 + 1;
              do
              {
                *(void *)(v975 + v978) = *(void *)(v974 + v978) & v979;
                --v980;
                v978 += 8;
              }
              while (v980 > 1);
            }
            v972 += v976;
            ++v971;
            v975 += 8 * (int)v344;
            v974 += v977;
          }
          while (v971 != v970);
        }
      }
      else
      {
        unint64_t v1686 = v197[6];
        if (v1686)
        {
          unint64_t v1705 = 0;
          uint64_t v1626 = v266[19];
          uint64_t v1638 = v198[19];
          uint64_t v1562 = v197[19];
          do
          {
            uint64_t v1563 = 0;
            if ((v201 & 0x80000000) == 0)
            {
              uint64_t v1564 = v198[3];
              uint64_t v1565 = v201;
              int v1566 = v1705;
              do
              {
                ldiv_t v1567 = ldiv(v1566, v199[v1565]);
                int v1566 = v1567.quot;
                v1563 += *(void *)(v1564 + 8 * v1565--) * v1567.rem;
              }
              while (v1565 != -1);
            }
            uint64_t v1568 = v1710;
            if ((v1710 & 0x80000000) != 0)
            {
              LODWORD(v1569) = 0;
            }
            else
            {
              uint64_t v1569 = 0;
              uint64_t v1570 = v266[3];
              int v1571 = v1705;
              do
              {
                ldiv_t v1572 = ldiv(v1571, v267[v1568]);
                int v1571 = v1572.quot;
                v1569 += *(void *)(v1570 + 8 * v1568--) * v1572.rem;
              }
              while (v1568 != -1);
            }
            uint64_t v201 = v1725;
            if ((int)v344 >= 1)
            {
              uint64_t v1573 = 0;
              uint64_t v1574 = *(void *)(v1638 + 8 * (int)v1563);
              unsigned int v1575 = v344 + 1;
              do
              {
                *(void *)(v1562 + v1573) = *(void *)(v1626 + 8 * (int)v1569 + v1573) & v1574;
                --v1575;
                v1573 += 8;
              }
              while (v1575 > 1);
            }
            v1562 += 8 * (int)v344;
            v1705 += (int)v344;
          }
          while (v1705 < v1686);
        }
      }
      break;
    case 2:
      if (v204 == 2)
      {
        uint64_t v1576 = *v199;
        if (v1576)
        {
          uint64_t v1577 = 0;
          uint64_t v1578 = 0;
          uint64_t v1579 = 0;
          uint64_t v1580 = v198[19];
          uint64_t v1581 = v266[19];
          uint64_t v1582 = v197[19];
          unint64_t v1583 = v199[1];
          v1584 = (uint64_t *)v198[3];
          uint64_t v1585 = *v1584;
          uint64_t v1586 = v1584[1];
          v1587 = (uint64_t *)v266[3];
          uint64_t v1588 = *v1587;
          uint64_t v1589 = v1587[1];
          if (v1583 <= 1) {
            uint64_t v1590 = 1;
          }
          else {
            uint64_t v1590 = v199[1];
          }
          uint64_t v1591 = v1585 - v1586 * v1583;
          uint64_t v1592 = v1588 - v1589 * v267[1];
          do
          {
            if (v1583)
            {
              uint64_t v1593 = 0;
              uint64_t v1594 = v1580 + 8 * v1579;
              do
              {
                if ((int)v344 >= 1)
                {
                  uint64_t v1595 = 0;
                  uint64_t v1596 = *(void *)(v1581 + 8 * v1578);
                  unsigned int v1597 = v344 + 1;
                  do
                  {
                    *(void *)(v1582 + v1595) = *(void *)(v1594 + v1595) & v1596;
                    --v1597;
                    v1595 += 8;
                  }
                  while (v1597 > 1);
                }
                v1579 += v1586;
                v1578 += v1589;
                v1582 += 8 * (int)v344;
                ++v1593;
                v1594 += 8 * v1586;
              }
              while (v1593 != v1590);
            }
            v1579 += v1591;
            v1578 += v1592;
            ++v1577;
          }
          while (v1577 != v1576);
        }
      }
      else if (v204 == 1)
      {
        uint64_t v981 = *v199;
        if (v981)
        {
          uint64_t v982 = 0;
          uint64_t v983 = 0;
          uint64_t v984 = v198[19];
          uint64_t v985 = v266[19];
          uint64_t v986 = v197[19];
          uint64_t v987 = *(void *)v266[3];
          uint64_t v988 = 8 * *(void *)v198[3];
          do
          {
            if ((int)v344 >= 1)
            {
              uint64_t v989 = 0;
              uint64_t v990 = *(void *)(v985 + 8 * v983);
              unsigned int v991 = v344 + 1;
              do
              {
                *(void *)(v986 + v989) = *(void *)(v984 + v989) & v990;
                --v991;
                v989 += 8;
              }
              while (v991 > 1);
            }
            v983 += v987;
            ++v982;
            v986 += 8 * (int)v344;
            v984 += v988;
          }
          while (v982 != v981);
        }
      }
      else
      {
        unint64_t v1687 = v197[6];
        if (v1687)
        {
          unint64_t v1706 = 0;
          uint64_t v1627 = v266[19];
          uint64_t v1639 = v198[19];
          uint64_t v1598 = v197[19];
          do
          {
            uint64_t v1599 = 0;
            if ((v201 & 0x80000000) == 0)
            {
              uint64_t v1600 = v198[3];
              uint64_t v1601 = v201;
              int v1602 = v1706;
              do
              {
                ldiv_t v1603 = ldiv(v1602, v199[v1601]);
                int v1602 = v1603.quot;
                v1599 += *(void *)(v1600 + 8 * v1601--) * v1603.rem;
              }
              while (v1601 != -1);
            }
            uint64_t v1604 = v1710;
            if ((v1710 & 0x80000000) != 0)
            {
              LODWORD(v1605) = 0;
            }
            else
            {
              uint64_t v1605 = 0;
              uint64_t v1606 = v266[3];
              int v1607 = v1706;
              do
              {
                ldiv_t v1608 = ldiv(v1607, v267[v1604]);
                int v1607 = v1608.quot;
                v1605 += *(void *)(v1606 + 8 * v1604--) * v1608.rem;
              }
              while (v1604 != -1);
            }
            uint64_t v201 = v1725;
            if ((int)v344 >= 1)
            {
              uint64_t v1609 = 0;
              uint64_t v1610 = *(void *)(v1627 + 8 * (int)v1605);
              unsigned int v1611 = v344 + 1;
              do
              {
                *(void *)(v1598 + v1609) = *(void *)(v1639 + 8 * (int)v1599 + v1609) & v1610;
                --v1611;
                v1609 += 8;
              }
              while (v1611 > 1);
            }
            v1598 += 8 * (int)v344;
            v1706 += (int)v344;
          }
          while (v1706 < v1687);
        }
      }
      break;
    case 3:
      if (v204 == 2)
      {
        uint64_t v1223 = *v199;
        if (v1223)
        {
          uint64_t v1224 = 0;
          uint64_t v1225 = 0;
          uint64_t v1226 = 0;
          uint64_t v1227 = v198[19];
          uint64_t v1228 = v266[19];
          uint64_t v1229 = v197[19];
          unint64_t v1230 = v199[1];
          v1231 = (uint64_t *)v198[3];
          uint64_t v1232 = *v1231;
          uint64_t v1233 = v1231[1];
          v1234 = (uint64_t *)v266[3];
          uint64_t v1235 = *v1234;
          uint64_t v1236 = v1234[1];
          if (v1230 <= 1) {
            uint64_t v1237 = 1;
          }
          else {
            uint64_t v1237 = v199[1];
          }
          uint64_t v1238 = v1232 - v1233 * v1230;
          uint64_t v1239 = v1235 - v1236 * v267[1];
          do
          {
            if (v1230)
            {
              uint64_t v1240 = 0;
              uint64_t v1241 = v1228 + 8 * v1225;
              uint64_t v1242 = v1227 + 8 * v1226;
              do
              {
                if ((int)v344 >= 1)
                {
                  uint64_t v1243 = 0;
                  unsigned int v1244 = v344 + 1;
                  do
                  {
                    *(void *)(v1229 + v1243) = *(void *)(v1241 + v1243) & *(void *)(v1242 + v1243);
                    --v1244;
                    v1243 += 8;
                  }
                  while (v1244 > 1);
                }
                v1226 += v1233;
                v1225 += v1236;
                v1229 += 8 * (int)v344;
                ++v1240;
                v1241 += 8 * v1236;
                v1242 += 8 * v1233;
              }
              while (v1240 != v1237);
            }
            v1226 += v1238;
            v1225 += v1239;
            ++v1224;
          }
          while (v1224 != v1223);
        }
      }
      else if (v204 == 1)
      {
        uint64_t v389 = *v199;
        if (v389)
        {
          uint64_t v390 = 0;
          uint64_t v391 = v198[19];
          uint64_t v392 = v266[19];
          uint64_t v393 = v197[19];
          uint64_t v394 = 8 * *(void *)v266[3];
          uint64_t v395 = 8 * *(void *)v198[3];
          do
          {
            if ((int)v344 >= 1)
            {
              uint64_t v396 = 0;
              unsigned int v397 = v344 + 1;
              do
              {
                *(void *)(v393 + v396) = *(void *)(v392 + v396) & *(void *)(v391 + v396);
                --v397;
                v396 += 8;
              }
              while (v397 > 1);
            }
            ++v390;
            v393 += 8 * (int)v344;
            v392 += v394;
            v391 += v395;
          }
          while (v390 != v389);
        }
      }
      else
      {
        unint64_t v1677 = v197[6];
        if (v1677)
        {
          unint64_t v1698 = 0;
          uint64_t v1619 = v266[19];
          uint64_t v1631 = v198[19];
          uint64_t v1245 = v197[19];
          do
          {
            uint64_t v1246 = 0;
            if ((v201 & 0x80000000) == 0)
            {
              uint64_t v1247 = v198[3];
              uint64_t v1248 = v201;
              int v1249 = v1698;
              do
              {
                ldiv_t v1250 = ldiv(v1249, v199[v1248]);
                int v1249 = v1250.quot;
                v1246 += *(void *)(v1247 + 8 * v1248--) * v1250.rem;
              }
              while (v1248 != -1);
            }
            uint64_t v1251 = v1710;
            if ((v1710 & 0x80000000) != 0)
            {
              LODWORD(v1252) = 0;
            }
            else
            {
              uint64_t v1252 = 0;
              uint64_t v1253 = v266[3];
              int v1254 = v1698;
              do
              {
                ldiv_t v1255 = ldiv(v1254, v267[v1251]);
                int v1254 = v1255.quot;
                v1252 += *(void *)(v1253 + 8 * v1251--) * v1255.rem;
              }
              while (v1251 != -1);
            }
            uint64_t v201 = v1725;
            if ((int)v344 >= 1)
            {
              uint64_t v1256 = 0;
              unsigned int v1257 = v344 + 1;
              do
              {
                *(void *)(v1245 + v1256) = *(void *)(v1619 + 8 * (int)v1252 + v1256) & *(void *)(v1631 + 8 * (int)v1246 + v1256);
                --v1257;
                v1256 += 8;
              }
              while (v1257 > 1);
            }
            v1245 += 8 * (int)v344;
            v1698 += (int)v344;
          }
          while (v1698 < v1677);
        }
      }
      break;
    default:
LABEL_407:
      switch(v340)
      {
        case 1uLL:
          uint64_t v345 = v197[6];
          if (v345)
          {
            v346 = (void *)v198[19];
            v347 = (void *)v266[19];
            v348 = (void *)v197[19];
            uint64_t v349 = 8 * *(void *)v266[3];
            uint64_t v350 = 8 * *(void *)v198[3];
            do
            {
              *v348++ = *v347 & *v346;
              v347 = (void *)((char *)v347 + v349);
              v346 = (void *)((char *)v346 + v350);
              --v345;
            }
            while (v345);
          }
          break;
        case 2uLL:
          uint64_t v812 = *v199;
          if (v812)
          {
            uint64_t v813 = 0;
            uint64_t v814 = 0;
            uint64_t v815 = 0;
            uint64_t v816 = 0;
            uint64_t v817 = v198[19];
            uint64_t v818 = v266[19];
            uint64_t v819 = v197[19];
            unint64_t v820 = v199[1];
            v821 = (uint64_t *)v198[3];
            uint64_t v822 = *v821;
            uint64_t v823 = v821[1];
            v824 = (uint64_t *)v266[3];
            uint64_t v825 = *v824;
            uint64_t v826 = v824[1];
            uint64_t v827 = v825 - v826 * v267[1];
            if (v820 <= 1) {
              uint64_t v828 = 1;
            }
            else {
              uint64_t v828 = v199[1];
            }
            uint64_t v829 = v822 - v823 * v820;
            do
            {
              if (v820)
              {
                uint64_t v830 = v814 + v828;
                v831 = (void *)(v819 + 8 * v814);
                uint64_t v832 = v828;
                do
                {
                  *v831++ = *(void *)(v818 + 8 * v815) & *(void *)(v817 + 8 * v816);
                  v816 += v823;
                  v815 += v826;
                  --v832;
                }
                while (v832);
                uint64_t v814 = v830;
              }
              v816 += v829;
              v815 += v827;
              ++v813;
            }
            while (v813 != v812);
          }
          break;
        case 3uLL:
          uint64_t v833 = *v199;
          if (v833)
          {
            uint64_t v834 = 0;
            uint64_t v835 = 0;
            uint64_t v836 = 0;
            uint64_t v837 = 0;
            uint64_t v838 = v198[19];
            uint64_t v839 = v266[19];
            uint64_t v840 = v197[19];
            unint64_t v841 = v199[1];
            v842 = (void *)v198[3];
            uint64_t v843 = v842[1];
            v844 = (void *)v266[3];
            uint64_t v845 = v844[1];
            uint64_t v846 = *v844 - v845 * v267[1];
            if (v841 <= 1) {
              uint64_t v847 = 1;
            }
            else {
              uint64_t v847 = v199[1];
            }
            unint64_t v848 = *v842 - v843 * v841;
            do
            {
              if (v841)
              {
                uint64_t v849 = 0;
                unint64_t v850 = v199[2];
                uint64_t v851 = v842[2];
                uint64_t v852 = v844[2];
                if (v850 <= 1) {
                  uint64_t v853 = 1;
                }
                else {
                  uint64_t v853 = v199[2];
                }
                uint64_t v854 = v845 - v852 * v267[2];
                do
                {
                  uint64_t v855 = v853;
                  if (v850)
                  {
                    do
                    {
                      *(void *)(v840 + 8 * v835++) = *(void *)(v839 + 8 * v836) & *(void *)(v838 + 8 * v837);
                      v837 += v851;
                      v836 += v852;
                      --v855;
                    }
                    while (v855);
                  }
                  v837 += v843 - v851 * v850;
                  v836 += v854;
                  ++v849;
                }
                while (v849 != v847);
              }
              v837 += v848;
              v836 += v846;
              ++v834;
            }
            while (v834 != v833);
          }
          break;
        case 4uLL:
          uint64_t v1729 = *v199;
          if (v1729)
          {
            uint64_t v856 = 0;
            uint64_t v857 = 0;
            uint64_t v858 = 0;
            uint64_t v859 = 0;
            uint64_t v860 = v198[19];
            uint64_t v861 = v266[19];
            uint64_t v862 = v197[19];
            unint64_t v863 = v199[1];
            v864 = (void *)v198[3];
            v865 = (void *)v266[3];
            uint64_t v1642 = v865[1];
            uint64_t v1654 = v864[1];
            uint64_t v1694 = *v865 - v1642 * v267[1];
            int v1714 = v199[1];
            if (v863 <= 1) {
              uint64_t v866 = 1;
            }
            else {
              uint64_t v866 = v199[1];
            }
            unint64_t v1669 = *v864 - v864[1] * v863;
            do
            {
              if (v1714)
              {
                uint64_t v867 = 0;
                unint64_t v868 = v199[2];
                uint64_t v869 = v864[2];
                uint64_t v870 = v865[2];
                if (v868 <= 1) {
                  uint64_t v871 = 1;
                }
                else {
                  uint64_t v871 = v199[2];
                }
                uint64_t v872 = v1642 - v870 * v267[2];
                do
                {
                  if (v868)
                  {
                    uint64_t v873 = 0;
                    unint64_t v874 = v199[3];
                    uint64_t v875 = v864[3];
                    uint64_t v876 = v865[3];
                    if (v874 <= 1) {
                      uint64_t v877 = 1;
                    }
                    else {
                      uint64_t v877 = v199[3];
                    }
                    uint64_t v878 = v870 - v876 * v267[3];
                    do
                    {
                      uint64_t v879 = v877;
                      if (v874)
                      {
                        do
                        {
                          *(void *)(v862 + 8 * v857++) = *(void *)(v861 + 8 * v858) & *(void *)(v860 + 8 * v859);
                          v859 += v875;
                          v858 += v876;
                          --v879;
                        }
                        while (v879);
                      }
                      v859 += v869 - v875 * v874;
                      v858 += v878;
                      ++v873;
                    }
                    while (v873 != v871);
                  }
                  v859 += v1654 - v869 * v868;
                  v858 += v872;
                  ++v867;
                }
                while (v867 != v866);
              }
              v859 += v1669;
              v858 += v1694;
              ++v856;
            }
            while (v856 != v1729);
          }
          break;
        default:
          uint64_t v800 = v197[6];
          if (v800)
          {
            uint64_t v801 = 0;
            uint64_t v1668 = v266[19];
            uint64_t v1693 = v198[19];
            uint64_t v1653 = v197[19];
            do
            {
              uint64_t v802 = 0;
              if ((v201 & 0x80000000) == 0)
              {
                uint64_t v803 = v198[3];
                uint64_t v804 = v201;
                int v805 = v801;
                do
                {
                  ldiv_t v806 = ldiv(v805, v199[v804]);
                  int v805 = v806.quot;
                  v802 += *(void *)(v803 + 8 * v804--) * v806.rem;
                }
                while (v804 != -1);
              }
              uint64_t v807 = v1710;
              if ((v1710 & 0x80000000) != 0)
              {
                LODWORD(v808) = 0;
              }
              else
              {
                uint64_t v808 = 0;
                uint64_t v809 = v266[3];
                int v810 = v801;
                do
                {
                  ldiv_t v811 = ldiv(v810, v267[v807]);
                  int v810 = v811.quot;
                  v808 += *(void *)(v809 + 8 * v807--) * v811.rem;
                }
                while (v807 != -1);
              }
              *(void *)(v1653 + 8 * v801++) = *(void *)(v1668 + 8 * (int)v808) & *(void *)(v1693
                                                                                                 + 8 * (int)v802);
              uint64_t v201 = v1725;
            }
            while (v801 != v800);
          }
          break;
      }
      return;
  }
}

void sub_256E54E38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::BitwiseOr>(uint64_t a1)
{
  v1 = *(mlx::core::array **)(a1 + 16);
  uint64_t v2 = a1;
  switch(*(_DWORD *)(*(void *)v1 + 56))
  {
    case 0:
      v4 = *(uint64_t **)a1;
      v3 = *(uint64_t **)(a1 + 8);
      switch(binary_op_type)
      {
        case 0:
          **(unsigned char **)(*(void *)v1 + 152) = **(unsigned char **)(*v3 + 152) | **(unsigned char **)(*v4 + 152);
          goto LABEL_33;
        case 1:
          int v33 = *(_DWORD *)(*v3 + 160);
          if (v33 >= 1)
          {
            char v34 = **(unsigned char **)(*v4 + 152);
            int v35 = *(unsigned char **)(*(void *)v1 + 152);
            int v36 = *(char **)(*v3 + 152);
            unsigned int v37 = v33 + 1;
            do
            {
              char v38 = *v36++;
              *v35++ = v38 | v34;
              --v37;
            }
            while (v37 > 1);
          }
          goto LABEL_33;
        case 2:
          int v39 = *(_DWORD *)(*v4 + 160);
          if (v39 >= 1)
          {
            char v40 = **(unsigned char **)(*v3 + 152);
            int v41 = *(unsigned char **)(*(void *)v1 + 152);
            BOOL v42 = *(char **)(*v4 + 152);
            unsigned int v43 = v39 + 1;
            do
            {
              char v44 = *v42++;
              *v41++ = v44 | v40;
              --v43;
            }
            while (v43 > 1);
          }
          goto LABEL_33;
        case 3:
          int v45 = *(_DWORD *)(*(void *)v1 + 48);
          if (v45 >= 1)
          {
            v46 = *(unsigned char **)(*(void *)v1 + 152);
            v47 = *(char **)(*v3 + 152);
            unsigned int v48 = *(char **)(*v4 + 152);
            unsigned int v49 = v45 + 1;
            do
            {
              char v51 = *v48++;
              char v50 = v51;
              char v52 = *v47++;
              *v46++ = v52 | v50;
              --v49;
            }
            while (v49 > 1);
          }
          goto LABEL_33;
        default:
          v24 = *(void **)v1;
          int v25 = (void *)*v4;
          v26 = *(int **)*v4;
          uint64_t v27 = (v25[1] - (void)v26) >> 2;
          uint64_t v28 = (v27 - 1);
          if ((int)v28 >= -1) {
            int v29 = -1;
          }
          else {
            int v29 = v27 - 1;
          }
          int v30 = v29 + 1;
          int v31 = v27 + 1;
          break;
      }
      while (1)
      {
        unsigned int v32 = v31 - 2;
        if (v31 - 2 < 0) {
          break;
        }
        --v31;
        if (*(void *)(v25[3] + 8 * v32) != *(void *)(v24[3] + 8 * v32)) {
          goto LABEL_179;
        }
      }
      int v31 = v30;
LABEL_179:
      uint64_t v225 = (void *)*v3;
      int v226 = *(int **)*v3;
      uint64_t v227 = (v225[1] - (void)v226) >> 2;
      uint64_t v228 = (v227 - 1);
      if ((int)v228 >= -1) {
        int v229 = -1;
      }
      else {
        int v229 = v227 - 1;
      }
      int v230 = v229 + 1;
      int v231 = v227 + 1;
      while (1)
      {
        unsigned int v232 = v231 - 2;
        if (v231 - 2 < 0) {
          break;
        }
        --v231;
        if (*(void *)(v225[3] + 8 * v232) != *(void *)(v24[3] + 8 * v232)) {
          goto LABEL_218;
        }
      }
      int v231 = v230;
LABEL_218:
      int v264 = v27 + 1;
      while (1)
      {
        unsigned int v265 = v264 - 2;
        if (v264 - 2 < 0) {
          break;
        }
        --v264;
        if (*(void *)(v25[3] + 8 * v265)) {
          goto LABEL_243;
        }
      }
      int v264 = v30;
LABEL_243:
      int v274 = v227 + 1;
      while (1)
      {
        unsigned int v275 = v274 - 2;
        if (v274 - 2 < 0) {
          break;
        }
        --v274;
        if (*(void *)(v225[3] + 8 * v275)) {
          goto LABEL_268;
        }
      }
      int v274 = v230;
LABEL_268:
      unint64_t v284 = (uint64_t)(v24[1] - *v24) >> 2;
      if (v31 <= v231) {
        int v285 = v231;
      }
      else {
        int v285 = v31;
      }
      if (v31 <= v274) {
        int v31 = v274;
      }
      if (v264 > v231) {
        int v231 = v264;
      }
      if (v284 > v231)
      {
        int v286 = 1;
      }
      else
      {
        int v231 = (uint64_t)(v24[1] - *v24) >> 2;
        int v286 = 4;
      }
      if (v284 > v31)
      {
        int v287 = 2;
      }
      else
      {
        int v31 = v231;
        int v287 = v286;
      }
      if (v284 > v285)
      {
        int v31 = v285;
        int v287 = 3;
      }
      uint64_t v1670 = v228;
      uint64_t v1685 = v28;
      if (!v31) {
        goto LABEL_285;
      }
      unint64_t v288 = *(void *)(v24[3] + 8 * (v31 - 1));
      if (v288 < 0x10) {
        goto LABEL_285;
      }
      uint64_t v1651 = *(void *)(v24[3] + 8 * (v31 - 1));
      switch(v287)
      {
        case 1:
          if (v31 == 2)
          {
            uint64_t v1228 = *v26;
            if (v1228)
            {
              uint64_t v1229 = 0;
              uint64_t v1230 = 0;
              uint64_t v1231 = 0;
              uint64_t v1232 = v25[19];
              uint64_t v1233 = v225[19];
              uint64_t v1234 = v24[19];
              unint64_t v1235 = v26[1];
              uint64_t v1236 = (uint64_t *)v25[3];
              uint64_t v1237 = *v1236;
              uint64_t v1238 = v1236[1];
              uint64_t v1239 = (uint64_t *)v225[3];
              uint64_t v1241 = *v1239;
              uint64_t v1240 = v1239[1];
              if (v1235 <= 1) {
                uint64_t v1242 = 1;
              }
              else {
                uint64_t v1242 = v26[1];
              }
              uint64_t v1243 = v1237 - v1238 * v1235;
              uint64_t v1244 = v1241 - v1240 * v226[1];
              do
              {
                if (v1235)
                {
                  uint64_t v1245 = 0;
                  uint64_t v1246 = v1233 + v1230;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1247 = 0;
                      char v1248 = *(unsigned char *)(v1232 + v1231);
                      unsigned int v1249 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1234 + v1247) = *(unsigned char *)(v1246 + v1247) | v1248;
                        --v1249;
                        ++v1247;
                      }
                      while (v1249 > 1);
                    }
                    v1231 += v1238;
                    v1230 += v1240;
                    v1234 += (int)v288;
                    ++v1245;
                    v1246 += v1240;
                  }
                  while (v1245 != v1242);
                }
                v1231 += v1243;
                v1230 += v1244;
                ++v1229;
              }
              while (v1229 != v1228);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v858 = *v26;
            if (v858)
            {
              uint64_t v859 = 0;
              uint64_t v860 = 0;
              uint64_t v861 = v25[19];
              uint64_t v862 = v225[19];
              uint64_t v863 = v24[19];
              uint64_t v864 = *(void *)v25[3];
              uint64_t v865 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v866 = 0;
                  char v867 = *(unsigned char *)(v861 + v860);
                  unsigned int v868 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v863 + v866) = *(unsigned char *)(v862 + v866) | v867;
                    --v868;
                    ++v866;
                  }
                  while (v868 > 1);
                }
                v860 += v864;
                v863 += (int)v288;
                ++v859;
                v862 += v865;
              }
              while (v859 != v858);
            }
          }
          else
          {
            unint64_t v1612 = v24[6];
            if (v1612)
            {
              uint64_t v1250 = 0;
              uint64_t v1579 = v225[19];
              uint64_t v1585 = v25[19];
              uint64_t v1599 = (int)v288;
              unsigned int v1576 = v288 + 1;
              uint64_t v1251 = v24[19];
              do
              {
                uint64_t v1627 = v1250;
                uint64_t v1252 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1253 = v25[3];
                  do
                  {
                    ldiv_t v1254 = ldiv((int)v1250, v26[v28]);
                    LODWORD(v1250) = v1254.quot;
                    v1252 += *(void *)(v1253 + 8 * v28--) * v1254.rem;
                  }
                  while (v28 != -1);
                }
                uint64_t v1255 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1256) = 0;
                }
                else
                {
                  uint64_t v1256 = 0;
                  uint64_t v1257 = v225[3];
                  int quot = v1627;
                  do
                  {
                    ldiv_t v1259 = ldiv(quot, v226[v1255]);
                    int quot = v1259.quot;
                    v1256 += *(void *)(v1257 + 8 * v1255--) * v1259.rem;
                  }
                  while (v1255 != -1);
                }
                if ((int)v1651 >= 1)
                {
                  uint64_t v1260 = 0;
                  char v1261 = *(unsigned char *)(v1585 + (int)v1252);
                  unsigned int v1262 = v1576;
                  do
                  {
                    *(unsigned char *)(v1251 + v1260) = *(unsigned char *)(v1579 + (int)v1256 + v1260) | v1261;
                    --v1262;
                    ++v1260;
                  }
                  while (v1262 > 1);
                }
                v1251 += v1599;
                uint64_t v1250 = v1627 + v1599;
                uint64_t v28 = v1685;
              }
              while (v1627 + v1599 < v1612);
            }
          }
          break;
        case 2:
          if (v31 == 2)
          {
            uint64_t v1263 = *v26;
            if (v1263)
            {
              uint64_t v1264 = 0;
              uint64_t v1265 = 0;
              uint64_t v1266 = 0;
              uint64_t v1267 = v25[19];
              uint64_t v1268 = v225[19];
              uint64_t v1269 = v24[19];
              unint64_t v1270 = v26[1];
              uint64_t v1271 = (uint64_t *)v25[3];
              uint64_t v1272 = *v1271;
              uint64_t v1273 = v1271[1];
              uint64_t v1274 = (uint64_t *)v225[3];
              uint64_t v1276 = *v1274;
              uint64_t v1275 = v1274[1];
              if (v1270 <= 1) {
                uint64_t v1277 = 1;
              }
              else {
                uint64_t v1277 = v26[1];
              }
              uint64_t v1278 = v1272 - v1273 * v1270;
              uint64_t v1279 = v1276 - v1275 * v226[1];
              do
              {
                if (v1270)
                {
                  uint64_t v1280 = 0;
                  uint64_t v1281 = v1267 + v1266;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1282 = 0;
                      char v1283 = *(unsigned char *)(v1268 + v1265);
                      unsigned int v1284 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1269 + v1282) = *(unsigned char *)(v1281 + v1282) | v1283;
                        --v1284;
                        ++v1282;
                      }
                      while (v1284 > 1);
                    }
                    v1266 += v1273;
                    v1265 += v1275;
                    v1269 += (int)v288;
                    ++v1280;
                    v1281 += v1273;
                  }
                  while (v1280 != v1277);
                }
                v1266 += v1278;
                v1265 += v1279;
                ++v1264;
              }
              while (v1264 != v1263);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v869 = *v26;
            if (v869)
            {
              uint64_t v870 = 0;
              uint64_t v871 = 0;
              uint64_t v872 = v25[19];
              uint64_t v873 = v225[19];
              uint64_t v874 = v24[19];
              uint64_t v875 = *(void *)v25[3];
              uint64_t v876 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v877 = 0;
                  char v878 = *(unsigned char *)(v873 + v871);
                  unsigned int v879 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v874 + v877) = *(unsigned char *)(v872 + v877) | v878;
                    --v879;
                    ++v877;
                  }
                  while (v879 > 1);
                }
                v871 += v876;
                v874 += (int)v288;
                ++v870;
                v872 += v875;
              }
              while (v870 != v869);
            }
          }
          else
          {
            unint64_t v1613 = v24[6];
            if (v1613)
            {
              uint64_t v1285 = 0;
              uint64_t v1580 = v225[19];
              uint64_t v1586 = v25[19];
              uint64_t v1600 = (int)v288;
              unsigned int v1577 = v288 + 1;
              uint64_t v1286 = v24[19];
              do
              {
                uint64_t v1628 = v1285;
                uint64_t v1287 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1288 = v25[3];
                  do
                  {
                    ldiv_t v1289 = ldiv((int)v1285, v26[v28]);
                    LODWORD(v1285) = v1289.quot;
                    v1287 += *(void *)(v1288 + 8 * v28--) * v1289.rem;
                  }
                  while (v28 != -1);
                }
                uint64_t v1290 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1291) = 0;
                }
                else
                {
                  uint64_t v1291 = 0;
                  uint64_t v1292 = v225[3];
                  int v1293 = v1628;
                  do
                  {
                    ldiv_t v1294 = ldiv(v1293, v226[v1290]);
                    int v1293 = v1294.quot;
                    v1291 += *(void *)(v1292 + 8 * v1290--) * v1294.rem;
                  }
                  while (v1290 != -1);
                }
                if ((int)v1651 >= 1)
                {
                  uint64_t v1295 = 0;
                  char v1296 = *(unsigned char *)(v1580 + (int)v1291);
                  unsigned int v1297 = v1577;
                  do
                  {
                    *(unsigned char *)(v1286 + v1295) = *(unsigned char *)(v1586 + (int)v1287 + v1295) | v1296;
                    --v1297;
                    ++v1295;
                  }
                  while (v1297 > 1);
                }
                v1286 += v1600;
                uint64_t v1285 = v1628 + v1600;
                uint64_t v28 = v1685;
              }
              while (v1628 + v1600 < v1613);
            }
          }
          break;
        case 3:
          if (v31 == 2)
          {
            uint64_t v1060 = *v26;
            if (v1060)
            {
              uint64_t v1061 = 0;
              uint64_t v1062 = 0;
              uint64_t v1063 = 0;
              uint64_t v1064 = v25[19];
              uint64_t v1065 = v225[19];
              uint64_t v1066 = v24[19];
              unint64_t v1067 = v26[1];
              uint64_t v1068 = (uint64_t *)v25[3];
              uint64_t v1069 = *v1068;
              uint64_t v1070 = v1068[1];
              uint64_t v1071 = (uint64_t *)v225[3];
              uint64_t v1073 = *v1071;
              uint64_t v1072 = v1071[1];
              if (v1067 <= 1) {
                uint64_t v1074 = 1;
              }
              else {
                uint64_t v1074 = v26[1];
              }
              uint64_t v1075 = v1069 - v1070 * v1067;
              uint64_t v1076 = v1073 - v1072 * v226[1];
              do
              {
                if (v1067)
                {
                  uint64_t v1077 = 0;
                  uint64_t v1078 = v1065 + v1062;
                  uint64_t v1079 = v1064 + v1063;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1080 = 0;
                      unsigned int v1081 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1066 + v1080) = *(unsigned char *)(v1078 + v1080) | *(unsigned char *)(v1079 + v1080);
                        --v1081;
                        ++v1080;
                      }
                      while (v1081 > 1);
                    }
                    v1063 += v1070;
                    v1062 += v1072;
                    v1066 += (int)v288;
                    ++v1077;
                    v1078 += v1072;
                    v1079 += v1070;
                  }
                  while (v1077 != v1074);
                }
                v1063 += v1075;
                v1062 += v1076;
                ++v1061;
              }
              while (v1061 != v1060);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v339 = *v26;
            if (v339)
            {
              uint64_t v340 = 0;
              uint64_t v341 = v25[19];
              uint64_t v342 = v225[19];
              uint64_t v343 = v24[19];
              uint64_t v344 = *(void *)v25[3];
              uint64_t v345 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v346 = 0;
                  unsigned int v347 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v343 + v346) = *(unsigned char *)(v342 + v346) | *(unsigned char *)(v341 + v346);
                    --v347;
                    ++v346;
                  }
                  while (v347 > 1);
                }
                v343 += (int)v288;
                ++v340;
                v342 += v345;
                v341 += v344;
              }
              while (v340 != v339);
            }
          }
          else
          {
            unint64_t v1610 = v24[6];
            if (v1610)
            {
              uint64_t v1082 = 0;
              uint64_t v1578 = v225[19];
              uint64_t v1581 = v25[19];
              uint64_t v1595 = (int)v288;
              unsigned int v1575 = v288 + 1;
              uint64_t v1083 = v24[19];
              do
              {
                uint64_t v1625 = v1082;
                uint64_t v1084 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1085 = v25[3];
                  for (uint64_t i = v28; i != -1; --i)
                  {
                    ldiv_t v1087 = ldiv((int)v1082, v26[i]);
                    LODWORD(v1082) = v1087.quot;
                    v1084 += *(void *)(v1085 + 8 * i) * v1087.rem;
                  }
                }
                uint64_t v1088 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1089) = 0;
                }
                else
                {
                  uint64_t v1089 = 0;
                  uint64_t v1090 = v225[3];
                  int v1091 = v1625;
                  do
                  {
                    ldiv_t v1092 = ldiv(v1091, v226[v1088]);
                    int v1091 = v1092.quot;
                    v1089 += *(void *)(v1090 + 8 * v1088--) * v1092.rem;
                  }
                  while (v1088 != -1);
                }
                uint64_t v28 = v1685;
                if ((int)v1651 >= 1)
                {
                  uint64_t v1093 = 0;
                  unsigned int v1094 = v1575;
                  do
                  {
                    *(unsigned char *)(v1083 + v1093) = *(unsigned char *)(v1578 + (int)v1089 + v1093) | *(unsigned char *)(v1581
                                                                                                  + (int)v1084
                                                                                                  + v1093);
                    --v1094;
                    ++v1093;
                  }
                  while (v1094 > 1);
                }
                v1083 += v1595;
                uint64_t v1082 = v1625 + v1595;
              }
              while (v1625 + v1595 < v1610);
            }
          }
          break;
        default:
LABEL_285:
          switch(v284)
          {
            case 1uLL:
              uint64_t v289 = v24[6];
              if (v289)
              {
                int v290 = (unsigned char *)v25[19];
                unsigned int v291 = (unsigned char *)v225[19];
                int v292 = (unsigned char *)v24[19];
                uint64_t v293 = *(void *)v25[3];
                uint64_t v294 = *(void *)v225[3];
                do
                {
                  *v292++ = *v291 | *v290;
                  v291 += v294;
                  v290 += v293;
                  --v289;
                }
                while (v289);
              }
              break;
            case 2uLL:
              uint64_t v482 = *v26;
              if (v482)
              {
                uint64_t v483 = 0;
                uint64_t v484 = 0;
                uint64_t v485 = 0;
                uint64_t v486 = 0;
                uint64_t v487 = v25[19];
                uint64_t v488 = v225[19];
                uint64_t v489 = v24[19];
                unint64_t v490 = v26[1];
                uint64_t v491 = (uint64_t *)v25[3];
                uint64_t v492 = *v491;
                uint64_t v493 = v491[1];
                int v494 = (uint64_t *)v225[3];
                uint64_t v495 = *v494;
                uint64_t v496 = v494[1];
                uint64_t v497 = v495 - v496 * v226[1];
                if (v490 <= 1) {
                  uint64_t v498 = 1;
                }
                else {
                  uint64_t v498 = v26[1];
                }
                uint64_t v499 = v492 - v493 * v490;
                do
                {
                  if (v490)
                  {
                    uint64_t v500 = v484 + v498;
                    uint64_t v501 = (unsigned char *)(v489 + v484);
                    uint64_t v502 = v498;
                    do
                    {
                      *v501++ = *(unsigned char *)(v488 + v485) | *(unsigned char *)(v487 + v486);
                      v486 += v493;
                      v485 += v496;
                      --v502;
                    }
                    while (v502);
                    uint64_t v484 = v500;
                  }
                  v486 += v499;
                  v485 += v497;
                  ++v483;
                }
                while (v483 != v482);
              }
              break;
            case 3uLL:
              uint64_t v503 = *v26;
              if (v503)
              {
                uint64_t v504 = 0;
                uint64_t v505 = 0;
                uint64_t v506 = 0;
                uint64_t v507 = 0;
                uint64_t v508 = v25[19];
                uint64_t v509 = v225[19];
                uint64_t v510 = v24[19];
                unint64_t v511 = v26[1];
                uint64_t v512 = (void *)v25[3];
                uint64_t v513 = v512[1];
                uint64_t v514 = (void *)v225[3];
                uint64_t v515 = v514[1];
                uint64_t v516 = *v514 - v515 * v226[1];
                if (v511 <= 1) {
                  uint64_t v517 = 1;
                }
                else {
                  uint64_t v517 = v26[1];
                }
                unint64_t v518 = *v512 - v513 * v511;
                do
                {
                  if (v511)
                  {
                    uint64_t v519 = 0;
                    unint64_t v520 = v26[2];
                    uint64_t v521 = v512[2];
                    uint64_t v522 = v514[2];
                    if (v520 <= 1) {
                      uint64_t v523 = 1;
                    }
                    else {
                      uint64_t v523 = v26[2];
                    }
                    uint64_t v524 = v515 - v522 * v226[2];
                    do
                    {
                      uint64_t v525 = v523;
                      if (v520)
                      {
                        do
                        {
                          *(unsigned char *)(v510 + v505++) = *(unsigned char *)(v509 + v506) | *(unsigned char *)(v508 + v507);
                          v507 += v521;
                          v506 += v522;
                          --v525;
                        }
                        while (v525);
                      }
                      v507 += v513 - v521 * v520;
                      v506 += v524;
                      ++v519;
                    }
                    while (v519 != v517);
                  }
                  v507 += v518;
                  v506 += v516;
                  ++v504;
                }
                while (v504 != v503);
              }
              break;
            case 4uLL:
              uint64_t v1690 = *v26;
              if (v1690)
              {
                uint64_t v526 = 0;
                uint64_t v527 = 0;
                uint64_t v528 = 0;
                uint64_t v529 = 0;
                uint64_t v530 = v25[19];
                uint64_t v531 = v225[19];
                uint64_t v532 = v24[19];
                unint64_t v533 = v26[1];
                uint64_t v534 = (void *)v25[3];
                uint64_t v535 = (void *)v225[3];
                uint64_t v1594 = v535[1];
                uint64_t v1608 = v534[1];
                uint64_t v1653 = *v535 - v1594 * v226[1];
                int v1675 = v26[1];
                if (v533 <= 1) {
                  uint64_t v536 = 1;
                }
                else {
                  uint64_t v536 = v26[1];
                }
                unint64_t v1617 = *v534 - v534[1] * v533;
                uint64_t v1631 = v2;
                do
                {
                  if (v1675)
                  {
                    uint64_t v537 = 0;
                    unint64_t v538 = v26[2];
                    uint64_t v539 = v534[2];
                    uint64_t v540 = v535[2];
                    if (v538 <= 1) {
                      uint64_t v541 = 1;
                    }
                    else {
                      uint64_t v541 = v26[2];
                    }
                    uint64_t v542 = v1594 - v540 * v226[2];
                    do
                    {
                      if (v538)
                      {
                        uint64_t v543 = 0;
                        unint64_t v544 = v26[3];
                        uint64_t v545 = v534[3];
                        uint64_t v546 = v535[3];
                        if (v544 <= 1) {
                          uint64_t v547 = 1;
                        }
                        else {
                          uint64_t v547 = v26[3];
                        }
                        uint64_t v548 = v540 - v546 * v226[3];
                        do
                        {
                          uint64_t v549 = v547;
                          if (v544)
                          {
                            do
                            {
                              *(unsigned char *)(v532 + v527++) = *(unsigned char *)(v531 + v528) | *(unsigned char *)(v530 + v529);
                              v529 += v545;
                              v528 += v546;
                              --v549;
                            }
                            while (v549);
                          }
                          v529 += v539 - v545 * v544;
                          v528 += v548;
                          ++v543;
                        }
                        while (v543 != v541);
                      }
                      v529 += v1608 - v539 * v538;
                      v528 += v542;
                      ++v537;
                    }
                    while (v537 != v536);
                  }
                  uint64_t v2 = v1631;
                  v529 += v1617;
                  v528 += v1653;
                  ++v526;
                }
                while (v526 != v1690);
              }
              break;
            default:
              uint64_t v1652 = v24[6];
              if (v1652)
              {
                uint64_t v471 = 0;
                uint64_t v1607 = v225[19];
                uint64_t v1616 = v25[19];
                uint64_t v1593 = v24[19];
                do
                {
                  uint64_t v472 = 0;
                  if ((v28 & 0x80000000) == 0)
                  {
                    uint64_t v473 = v25[3];
                    uint64_t v474 = v28;
                    int v475 = v471;
                    do
                    {
                      ldiv_t v476 = ldiv(v475, v26[v474]);
                      int v475 = v476.quot;
                      v472 += *(void *)(v473 + 8 * v474--) * v476.rem;
                    }
                    while (v474 != -1);
                  }
                  uint64_t v477 = v1670;
                  if ((v1670 & 0x80000000) != 0)
                  {
                    LODWORD(v478) = 0;
                  }
                  else
                  {
                    uint64_t v478 = 0;
                    uint64_t v479 = v225[3];
                    int v480 = v471;
                    do
                    {
                      ldiv_t v481 = ldiv(v480, v226[v477]);
                      int v480 = v481.quot;
                      v478 += *(void *)(v479 + 8 * v477--) * v481.rem;
                    }
                    while (v477 != -1);
                  }
                  *(unsigned char *)(v1593 + v471++) = *(unsigned char *)(v1607 + (int)v478) | *(unsigned char *)(v1616 + (int)v472);
                  uint64_t v28 = v1685;
                }
                while (v471 != v1652);
              }
              break;
          }
          break;
      }
LABEL_33:
      int v53 = *(uint64_t **)v2;
      v54 = *(uint64_t **)(v2 + 8);
      v55 = *(mlx::core::array **)(v2 + 16);
      switch(v56)
      {
        case 0:
          char v18 = **(unsigned char **)(*v54 + 152) | **(unsigned char **)(*v53 + 152);
          uint64_t v19 = *(void *)v55;
          goto LABEL_35;
        case 1:
          int v65 = *(_DWORD *)(*v54 + 160);
          if (v65 >= 1)
          {
            char v66 = **(unsigned char **)(*v53 + 152);
            v67 = *(unsigned char **)(*(void *)v55 + 152);
            uint64_t v68 = *(char **)(*v54 + 152);
            unsigned int v69 = v65 + 1;
            do
            {
              char v70 = *v68++;
              *v67++ = v70 | v66;
              --v69;
            }
            while (v69 > 1);
          }
          return;
        case 2:
          int v71 = *(_DWORD *)(*v53 + 160);
          if (v71 >= 1)
          {
            char v72 = **(unsigned char **)(*v54 + 152);
            int v73 = *(unsigned char **)(*(void *)v55 + 152);
            unsigned int v74 = *(char **)(*v53 + 152);
            unsigned int v75 = v71 + 1;
            do
            {
              char v76 = *v74++;
              *v73++ = v76 | v72;
              --v75;
            }
            while (v75 > 1);
          }
          return;
        case 3:
          int v77 = *(_DWORD *)(*(void *)v55 + 48);
          if (v77 >= 1)
          {
            v78 = *(unsigned char **)(*(void *)v55 + 152);
            unsigned int v79 = *(char **)(*v54 + 152);
            char v80 = *(char **)(*v53 + 152);
            unsigned int v81 = v77 + 1;
            do
            {
              char v83 = *v80++;
              char v82 = v83;
              char v84 = *v79++;
              *v78++ = v84 | v82;
              --v81;
            }
            while (v81 > 1);
          }
          return;
        default:
          unsigned int v57 = *(void **)v55;
          uint64_t v58 = *v53;
          int v59 = *(int **)*v53;
          uint64_t v60 = (*(void *)(*v53 + 8) - (void)v59) >> 2;
          int v61 = v60 - 1;
          if ((int)v60 - 1 >= -1) {
            int v61 = -1;
          }
          int v62 = v61 + 1;
          int v63 = v60 + 1;
          break;
      }
      while (1)
      {
        unsigned int v64 = v63 - 2;
        if (v63 - 2 < 0) {
          break;
        }
        --v63;
        if (*(void *)(*(void *)(v58 + 24) + 8 * v64) != *(void *)(v57[3] + 8 * v64)) {
          goto LABEL_55;
        }
      }
      int v63 = v62;
LABEL_55:
      unsigned int v85 = (int **)*v54;
      char v86 = *(int **)*v54;
      uint64_t v87 = (*(void *)(*v54 + 8) - (void)v86) >> 2;
      int v88 = v87 - 1;
      if ((int)v87 - 1 >= -1) {
        int v88 = -1;
      }
      int v89 = v88 + 1;
      int v90 = v87 + 1;
      while (1)
      {
        unsigned int v91 = v90 - 2;
        if (v90 - 2 < 0) {
          break;
        }
        --v90;
        if (*(void *)&v85[3][2 * v91] != *(void *)(v57[3] + 8 * v91)) {
          goto LABEL_62;
        }
      }
      int v90 = v89;
LABEL_62:
      int v92 = v60 + 1;
      while (1)
      {
        unsigned int v93 = v92 - 2;
        if (v92 - 2 < 0) {
          break;
        }
        --v92;
        if (*(void *)(*(void *)(v58 + 24) + 8 * v93)) {
          goto LABEL_67;
        }
      }
      int v92 = v62;
LABEL_67:
      int v94 = v87 + 1;
      while (1)
      {
        int v95 = v94 - 2;
        if (v94 - 2 < 0) {
          break;
        }
        --v94;
        if (*(void *)&v85[3][2 * v95]) {
          goto LABEL_72;
        }
      }
      int v94 = v89;
LABEL_72:
      unint64_t v96 = (uint64_t)(v57[1] - *v57) >> 2;
      if (v63 <= v90) {
        int v97 = v90;
      }
      else {
        int v97 = v63;
      }
      if (v63 <= v94) {
        int v63 = v94;
      }
      if (v92 > v90) {
        int v90 = v92;
      }
      if (v96 > v90)
      {
        int v98 = 1;
      }
      else
      {
        int v90 = (uint64_t)(v57[1] - *v57) >> 2;
        int v98 = 4;
      }
      if (v96 > v63)
      {
        int v99 = 2;
      }
      else
      {
        int v63 = v90;
        int v99 = v98;
      }
      if (v96 > v97)
      {
        int v63 = v97;
        int v99 = 3;
      }
      unint64_t v1684 = v55;
      if (!v63) {
        goto LABEL_89;
      }
      unint64_t v100 = *(void *)(v57[3] + 8 * (v63 - 1));
      if (v100 < 0x10) {
        goto LABEL_89;
      }
      switch(v99)
      {
        case 1:
          if (v63 == 2)
          {
            int v996 = *v59;
            if (*v59)
            {
              unint64_t v997 = 0;
              uint64_t v998 = 0;
              uint64_t v999 = 0;
              uint64_t v1000 = *(void *)(v58 + 152);
              unsigned int v1001 = v85[19];
              uint64_t v1002 = v57[19];
              do
              {
                if (v59[1])
                {
                  unint64_t v1003 = 0;
                  do
                  {
                    if ((int)v100 >= 1)
                    {
                      uint64_t v1004 = 0;
                      char v1005 = *(unsigned char *)(v1000 + v999);
                      unsigned int v1006 = v100 + 1;
                      do
                      {
                        *(unsigned char *)(v1002 + v1004) = *((unsigned char *)v1001 + v998 + v1004) | v1005;
                        --v1006;
                        ++v1004;
                      }
                      while (v1006 > 1);
                      uint64_t v58 = *v53;
                      unsigned int v85 = (int **)*v54;
                      int v59 = *(int **)*v53;
                    }
                    unint64_t v1007 = *(void **)(v58 + 24);
                    uint64_t v1008 = v1007[1];
                    v999 += v1008;
                    v998 += *((void *)v85[3] + 1);
                    v1002 += (int)v100;
                    ++v1003;
                    unint64_t v1009 = v59[1];
                  }
                  while (v1003 < v1009);
                  int v996 = *v59;
                  char v86 = *v85;
                }
                else
                {
                  unint64_t v1009 = 0;
                  unint64_t v1007 = *(void **)(v58 + 24);
                  uint64_t v1008 = v1007[1];
                }
                uint64_t v999 = *v1007 + v999 - v1009 * v1008;
                uint64_t v998 = *(void *)v85[3] + v998 - *((void *)v85[3] + 1) * v86[1];
                ++v997;
              }
              while (v997 < v996);
            }
          }
          else if (v63 == 1)
          {
            int v451 = *v59;
            if (*v59)
            {
              unint64_t v452 = 0;
              uint64_t v453 = 0;
              uint64_t v454 = 0;
              uint64_t v455 = *(void *)(v58 + 152);
              unint64_t v456 = v85[19];
              uint64_t v457 = v57[19];
              do
              {
                if ((int)v100 >= 1)
                {
                  uint64_t v458 = 0;
                  char v459 = *(unsigned char *)(v455 + v454);
                  unsigned int v460 = v100 + 1;
                  do
                  {
                    *(unsigned char *)(v457 + v458) = *((unsigned char *)v456 + v453 + v458) | v459;
                    --v460;
                    ++v458;
                  }
                  while (v460 > 1);
                  uint64_t v58 = *v53;
                  unsigned int v85 = (int **)*v54;
                  int v451 = **(_DWORD **)*v53;
                }
                v454 += **(void **)(v58 + 24);
                v453 += *(void *)v85[3];
                v457 += (int)v100;
                ++v452;
              }
              while (v452 < v451);
            }
          }
          else if (v57[6])
          {
            uint64_t v1623 = v85[19];
            uint64_t v1637 = *(void *)(v58 + 152);
            unint64_t v1679 = 0;
            uint64_t v1010 = v57[19];
            do
            {
              uint64_t v1011 = *(void *)*v53;
              unint64_t v1012 = (unint64_t)(*(void *)(*v53 + 8) - v1011) >> 2;
              uint64_t v1013 = 0;
              uint64_t v1014 = (v1012 - 1);
              if ((int)v1012 - 1 >= 0)
              {
                uint64_t v1015 = *(void *)(*v53 + 24);
                int v1016 = v1679;
                do
                {
                  ldiv_t v1017 = ldiv(v1016, *(int *)(v1011 + 4 * v1014));
                  int v1016 = v1017.quot;
                  v1013 += *(void *)(v1015 + 8 * v1014--) * v1017.rem;
                }
                while (v1014 != -1);
              }
              uint64_t v1018 = *(void *)*v54;
              unint64_t v1019 = (unint64_t)(*(void *)(*v54 + 8) - v1018) >> 2;
              uint64_t v1020 = 0;
              uint64_t v1021 = (v1019 - 1);
              if ((int)v1019 - 1 >= 0)
              {
                uint64_t v1022 = *(void *)(*v54 + 24);
                int v1023 = v1679;
                do
                {
                  ldiv_t v1024 = ldiv(v1023, *(int *)(v1018 + 4 * v1021));
                  int v1023 = v1024.quot;
                  v1020 += *(void *)(v1022 + 8 * v1021--) * v1024.rem;
                }
                while (v1021 != -1);
              }
              if ((int)v100 >= 1)
              {
                uint64_t v1025 = 0;
                char v1026 = *(unsigned char *)(v1637 + (int)v1013);
                unsigned int v1027 = v100 + 1;
                do
                {
                  *(unsigned char *)(v1010 + v1025) = *((unsigned char *)v1623 + (int)v1020 + v1025) | v1026;
                  --v1027;
                  ++v1025;
                }
                while (v1027 > 1);
                unsigned int v57 = *(void **)v1684;
              }
              v1010 += (int)v100;
              v1679 += (int)v100;
            }
            while (v1679 < v57[6]);
          }
          break;
        case 2:
          if (v63 == 2)
          {
            int v1028 = *v59;
            if (*v59)
            {
              unint64_t v1029 = 0;
              uint64_t v1030 = 0;
              uint64_t v1031 = 0;
              uint64_t v1032 = *(void *)(v58 + 152);
              v1033 = v85[19];
              uint64_t v1034 = v57[19];
              do
              {
                if (v59[1])
                {
                  unint64_t v1035 = 0;
                  do
                  {
                    if ((int)v100 >= 1)
                    {
                      uint64_t v1036 = 0;
                      char v1037 = *((unsigned char *)v1033 + v1030);
                      unsigned int v1038 = v100 + 1;
                      do
                      {
                        *(unsigned char *)(v1034 + v1036) = *(unsigned char *)(v1032 + v1031 + v1036) | v1037;
                        --v1038;
                        ++v1036;
                      }
                      while (v1038 > 1);
                      uint64_t v58 = *v53;
                      unsigned int v85 = (int **)*v54;
                      int v59 = *(int **)*v53;
                    }
                    uint64_t v1039 = *(void **)(v58 + 24);
                    uint64_t v1040 = v1039[1];
                    v1031 += v1040;
                    v1030 += *((void *)v85[3] + 1);
                    v1034 += (int)v100;
                    ++v1035;
                    unint64_t v1041 = v59[1];
                  }
                  while (v1035 < v1041);
                  int v1028 = *v59;
                  char v86 = *v85;
                }
                else
                {
                  unint64_t v1041 = 0;
                  uint64_t v1039 = *(void **)(v58 + 24);
                  uint64_t v1040 = v1039[1];
                }
                uint64_t v1031 = *v1039 + v1031 - v1041 * v1040;
                uint64_t v1030 = *(void *)v85[3] + v1030 - *((void *)v85[3] + 1) * v86[1];
                ++v1029;
              }
              while (v1029 < v1028);
            }
          }
          else if (v63 == 1)
          {
            int v461 = *v59;
            if (*v59)
            {
              unint64_t v462 = 0;
              uint64_t v463 = 0;
              uint64_t v464 = 0;
              uint64_t v465 = *(void *)(v58 + 152);
              unint64_t v466 = v85[19];
              uint64_t v467 = v57[19];
              do
              {
                if ((int)v100 >= 1)
                {
                  uint64_t v468 = 0;
                  char v469 = *((unsigned char *)v466 + v463);
                  unsigned int v470 = v100 + 1;
                  do
                  {
                    *(unsigned char *)(v467 + v468) = *(unsigned char *)(v465 + v464 + v468) | v469;
                    --v470;
                    ++v468;
                  }
                  while (v470 > 1);
                  uint64_t v58 = *v53;
                  unsigned int v85 = (int **)*v54;
                  int v461 = **(_DWORD **)*v53;
                }
                v464 += **(void **)(v58 + 24);
                v463 += *(void *)v85[3];
                v467 += (int)v100;
                ++v462;
              }
              while (v462 < v461);
            }
          }
          else if (v57[6])
          {
            uint64_t v1624 = v85[19];
            uint64_t v1638 = *(void *)(v58 + 152);
            unint64_t v1680 = 0;
            uint64_t v1042 = v57[19];
            do
            {
              uint64_t v1043 = *(void *)*v53;
              unint64_t v1044 = (unint64_t)(*(void *)(*v53 + 8) - v1043) >> 2;
              uint64_t v1045 = 0;
              uint64_t v1046 = (v1044 - 1);
              if ((int)v1044 - 1 >= 0)
              {
                uint64_t v1047 = *(void *)(*v53 + 24);
                int v1048 = v1680;
                do
                {
                  ldiv_t v1049 = ldiv(v1048, *(int *)(v1043 + 4 * v1046));
                  int v1048 = v1049.quot;
                  v1045 += *(void *)(v1047 + 8 * v1046--) * v1049.rem;
                }
                while (v1046 != -1);
              }
              uint64_t v1050 = *(void *)*v54;
              unint64_t v1051 = (unint64_t)(*(void *)(*v54 + 8) - v1050) >> 2;
              uint64_t v1052 = 0;
              uint64_t v1053 = (v1051 - 1);
              if ((int)v1051 - 1 >= 0)
              {
                uint64_t v1054 = *(void *)(*v54 + 24);
                int v1055 = v1680;
                do
                {
                  ldiv_t v1056 = ldiv(v1055, *(int *)(v1050 + 4 * v1053));
                  int v1055 = v1056.quot;
                  v1052 += *(void *)(v1054 + 8 * v1053--) * v1056.rem;
                }
                while (v1053 != -1);
              }
              if ((int)v100 >= 1)
              {
                uint64_t v1057 = 0;
                char v1058 = *((unsigned char *)v1624 + (int)v1052);
                unsigned int v1059 = v100 + 1;
                do
                {
                  *(unsigned char *)(v1042 + v1057) = *(unsigned char *)(v1638 + (int)v1045 + v1057) | v1058;
                  --v1059;
                  ++v1057;
                }
                while (v1059 > 1);
                unsigned int v57 = *(void **)v1684;
              }
              v1042 += (int)v100;
              v1680 += (int)v100;
            }
            while (v1680 < v57[6]);
          }
          break;
        case 3:
          if (v63 == 2)
          {
            int v966 = *v59;
            if (*v59)
            {
              unint64_t v967 = 0;
              uint64_t v968 = 0;
              uint64_t v969 = 0;
              uint64_t v970 = *(void *)(v58 + 152);
              uint64_t v971 = v85[19];
              uint64_t v972 = v57[19];
              do
              {
                if (v59[1])
                {
                  unint64_t v973 = 0;
                  do
                  {
                    if ((int)v100 >= 1)
                    {
                      uint64_t v974 = 0;
                      unsigned int v975 = v100 + 1;
                      do
                      {
                        *(unsigned char *)(v972 + v974) = *((unsigned char *)v971 + v968 + v974) | *(unsigned char *)(v970 + v969 + v974);
                        --v975;
                        ++v974;
                      }
                      while (v975 > 1);
                      uint64_t v58 = *v53;
                      unsigned int v85 = (int **)*v54;
                      int v59 = *(int **)*v53;
                    }
                    uint64_t v976 = *(void **)(v58 + 24);
                    uint64_t v977 = v976[1];
                    v969 += v977;
                    v968 += *((void *)v85[3] + 1);
                    v972 += (int)v100;
                    ++v973;
                    unint64_t v978 = v59[1];
                  }
                  while (v973 < v978);
                  int v966 = *v59;
                  char v86 = *v85;
                }
                else
                {
                  unint64_t v978 = 0;
                  uint64_t v976 = *(void **)(v58 + 24);
                  uint64_t v977 = v976[1];
                }
                uint64_t v969 = *v976 + v969 - v978 * v977;
                uint64_t v968 = *(void *)v85[3] + v968 - *((void *)v85[3] + 1) * v86[1];
                ++v967;
              }
              while (v967 < v966);
            }
          }
          else if (v63 == 1)
          {
            int v216 = *v59;
            if (*v59)
            {
              unint64_t v217 = 0;
              uint64_t v218 = 0;
              uint64_t v219 = 0;
              uint64_t v220 = *(void *)(v58 + 152);
              v221 = v85[19];
              uint64_t v222 = v57[19];
              do
              {
                if ((int)v100 >= 1)
                {
                  uint64_t v223 = 0;
                  unsigned int v224 = v100 + 1;
                  do
                  {
                    *(unsigned char *)(v222 + v223) = *((unsigned char *)v221 + v218 + v223) | *(unsigned char *)(v220 + v219 + v223);
                    --v224;
                    ++v223;
                  }
                  while (v224 > 1);
                  uint64_t v58 = *v53;
                  unsigned int v85 = (int **)*v54;
                  int v216 = **(_DWORD **)*v53;
                }
                v219 += **(void **)(v58 + 24);
                v218 += *(void *)v85[3];
                v222 += (int)v100;
                ++v217;
              }
              while (v217 < v216);
            }
          }
          else if (v57[6])
          {
            uint64_t v1622 = v85[19];
            uint64_t v1636 = *(void *)(v58 + 152);
            unint64_t v1678 = 0;
            uint64_t v979 = v57[19];
            do
            {
              uint64_t v980 = *(void *)*v53;
              unint64_t v981 = (unint64_t)(*(void *)(*v53 + 8) - v980) >> 2;
              uint64_t v982 = 0;
              uint64_t v983 = (v981 - 1);
              if ((int)v981 - 1 >= 0)
              {
                uint64_t v984 = *(void *)(*v53 + 24);
                int v985 = v1678;
                do
                {
                  ldiv_t v986 = ldiv(v985, *(int *)(v980 + 4 * v983));
                  int v985 = v986.quot;
                  v982 += *(void *)(v984 + 8 * v983--) * v986.rem;
                }
                while (v983 != -1);
              }
              uint64_t v987 = *(void *)*v54;
              unint64_t v988 = (unint64_t)(*(void *)(*v54 + 8) - v987) >> 2;
              uint64_t v989 = 0;
              uint64_t v990 = (v988 - 1);
              if ((int)v988 - 1 >= 0)
              {
                uint64_t v991 = *(void *)(*v54 + 24);
                int v992 = v1678;
                do
                {
                  ldiv_t v993 = ldiv(v992, *(int *)(v987 + 4 * v990));
                  int v992 = v993.quot;
                  v989 += *(void *)(v991 + 8 * v990--) * v993.rem;
                }
                while (v990 != -1);
              }
              if ((int)v100 >= 1)
              {
                uint64_t v994 = 0;
                unsigned int v995 = v100 + 1;
                do
                {
                  *(unsigned char *)(v979 + v994) = *((unsigned char *)v1622 + (int)v989 + v994) | *(unsigned char *)(v1636 + (int)v982 + v994);
                  --v995;
                  ++v994;
                }
                while (v995 > 1);
                unsigned int v57 = *(void **)v1684;
              }
              v979 += (int)v100;
              v1678 += (int)v100;
            }
            while (v1678 < v57[6]);
          }
          break;
        default:
LABEL_89:
          switch(v96)
          {
            case 1uLL:
              if (v57[6])
              {
                unint64_t v101 = 0;
                uint64_t v102 = 0;
                uint64_t v103 = 0;
                uint64_t v104 = *(void *)(v58 + 152);
                int v105 = v85[19];
                uint64_t v106 = v57[19];
                do
                {
                  *(unsigned char *)(v106 + v101) = *((unsigned char *)v105 + v102) | *(unsigned char *)(v104 + v103);
                  v103 += **(void **)(*v53 + 24);
                  v102 += **(void **)(*v54 + 24);
                  ++v101;
                }
                while (v101 < *(void *)(*(void *)v55 + 48));
              }
              break;
            case 2uLL:
              int v401 = *v59;
              if (*v59)
              {
                unint64_t v402 = 0;
                uint64_t v403 = 0;
                uint64_t v404 = 0;
                uint64_t v405 = 0;
                uint64_t v406 = *(void *)(v58 + 152);
                ldiv_t v407 = v85[19];
                uint64_t v408 = v57[19];
                do
                {
                  if (v59[1])
                  {
                    unint64_t v409 = 0;
                    do
                    {
                      *(unsigned char *)(v408 + v403 + v409) = *((unsigned char *)v407 + v404) | *(unsigned char *)(v406 + v405);
                      uint64_t v58 = *v53;
                      uint64_t v410 = *(void **)(*v53 + 24);
                      uint64_t v411 = v410[1];
                      v405 += v411;
                      unsigned int v85 = (int **)*v54;
                      uint64_t v412 = *(int **)(*v54 + 24);
                      uint64_t v413 = *((void *)v412 + 1);
                      v404 += v413;
                      ++v409;
                      int v59 = *(int **)*v53;
                      unint64_t v414 = v59[1];
                    }
                    while (v409 < v414);
                    int v401 = *v59;
                    char v86 = *v85;
                    v403 += v409;
                  }
                  else
                  {
                    unint64_t v414 = 0;
                    uint64_t v410 = *(void **)(v58 + 24);
                    uint64_t v411 = v410[1];
                    uint64_t v412 = v85[3];
                    uint64_t v413 = *((void *)v412 + 1);
                  }
                  uint64_t v405 = *v410 + v405 - v414 * v411;
                  uint64_t v404 = *(void *)v412 + v404 - v413 * v86[1];
                  ++v402;
                }
                while (v402 < v401);
              }
              break;
            case 3uLL:
              int v415 = *v59;
              if (*v59)
              {
                unint64_t v416 = 0;
                uint64_t v417 = 0;
                uint64_t v418 = 0;
                uint64_t v419 = 0;
                uint64_t v420 = *(void *)(v58 + 152);
                v421 = v85[19];
                uint64_t v422 = v57[19];
                do
                {
                  if (v59[1])
                  {
                    unint64_t v423 = 0;
                    do
                    {
                      if (v59[2])
                      {
                        unint64_t v424 = 0;
                        do
                        {
                          *(unsigned char *)(v422 + v417 + v424) = *((unsigned char *)v421 + v418) | *(unsigned char *)(v420 + v419);
                          uint64_t v58 = *v53;
                          uint64_t v425 = *(void **)(*v53 + 24);
                          uint64_t v426 = v425[2];
                          v419 += v426;
                          unsigned int v85 = (int **)*v54;
                          uint64_t v427 = *(int **)(*v54 + 24);
                          uint64_t v428 = *((void *)v427 + 2);
                          v418 += v428;
                          ++v424;
                          int v59 = *(int **)*v53;
                          unint64_t v429 = v59[2];
                        }
                        while (v424 < v429);
                        char v86 = *v85;
                        v417 += v424;
                      }
                      else
                      {
                        unint64_t v429 = 0;
                        uint64_t v425 = *(void **)(v58 + 24);
                        uint64_t v426 = v425[2];
                        uint64_t v427 = v85[3];
                        uint64_t v428 = *((void *)v427 + 2);
                      }
                      uint64_t v430 = v425[1];
                      uint64_t v419 = v430 + v419 - v429 * v426;
                      uint64_t v418 = *((void *)v427 + 1) + v418 - v428 * v86[2];
                      ++v423;
                      unint64_t v431 = v59[1];
                    }
                    while (v423 < v431);
                    int v415 = *v59;
                  }
                  else
                  {
                    unint64_t v431 = 0;
                    uint64_t v425 = *(void **)(v58 + 24);
                    uint64_t v430 = v425[1];
                  }
                  uint64_t v419 = *v425 + v419 - v431 * v430;
                  uint64_t v418 = *(void *)v85[3] + v418 - *((void *)v85[3] + 1) * v86[1];
                  ++v416;
                }
                while (v416 < v415);
              }
              break;
            case 4uLL:
              int v432 = *v59;
              if (*v59)
              {
                unint64_t v433 = 0;
                uint64_t v434 = 0;
                uint64_t v435 = 0;
                uint64_t v436 = 0;
                uint64_t v437 = *(void *)(v58 + 152);
                unint64_t v438 = v85[19];
                uint64_t v439 = v57[19];
                do
                {
                  if (v59[1])
                  {
                    unint64_t v440 = 0;
                    do
                    {
                      if (v59[2])
                      {
                        unint64_t v441 = 0;
                        do
                        {
                          if (v59[3])
                          {
                            unint64_t v442 = 0;
                            do
                            {
                              *(unsigned char *)(v439 + v434 + v442) = *((unsigned char *)v438 + v435) | *(unsigned char *)(v437 + v436);
                              uint64_t v58 = *v53;
                              unint64_t v443 = *(void **)(*v53 + 24);
                              uint64_t v444 = v443[3];
                              v436 += v444;
                              unsigned int v85 = (int **)*v54;
                              unint64_t v445 = *(int **)(*v54 + 24);
                              uint64_t v446 = *((void *)v445 + 3);
                              v435 += v446;
                              ++v442;
                              int v59 = *(int **)*v53;
                              unint64_t v447 = v59[3];
                            }
                            while (v442 < v447);
                            char v86 = *v85;
                            v434 += v442;
                          }
                          else
                          {
                            unint64_t v447 = 0;
                            unint64_t v443 = *(void **)(v58 + 24);
                            uint64_t v444 = v443[3];
                            unint64_t v445 = v85[3];
                            uint64_t v446 = *((void *)v445 + 3);
                          }
                          uint64_t v448 = v443[2];
                          uint64_t v436 = v448 + v436 - v447 * v444;
                          uint64_t v435 = *((void *)v445 + 2) + v435 - v446 * v86[3];
                          ++v441;
                          unint64_t v449 = v59[2];
                        }
                        while (v441 < v449);
                      }
                      else
                      {
                        unint64_t v449 = 0;
                        unint64_t v443 = *(void **)(v58 + 24);
                        uint64_t v448 = v443[2];
                      }
                      uint64_t v436 = v443[1] + v436 - v449 * v448;
                      uint64_t v435 = *((void *)v85[3] + 1) + v435 - *((void *)v85[3] + 2) * v86[2];
                      ++v440;
                      unint64_t v450 = v59[1];
                    }
                    while (v440 < v450);
                    int v432 = *v59;
                  }
                  else
                  {
                    unint64_t v450 = 0;
                  }
                  uint64_t v436 = **(void **)(v58 + 24) + v436 - *(void *)(*(void *)(v58 + 24) + 8) * v450;
                  uint64_t v435 = *(void *)v85[3] + v435 - *((void *)v85[3] + 1) * v86[1];
                  ++v433;
                }
                while (v433 < v432);
              }
              break;
            default:
              if (v57[6])
              {
                unint64_t v384 = 0;
                uint64_t v1674 = *(void *)(v58 + 152);
                uint64_t v385 = v85[19];
                uint64_t v386 = v57[19];
                do
                {
                  uint64_t v387 = *(void *)*v53;
                  unint64_t v388 = (unint64_t)(*(void *)(*v53 + 8) - v387) >> 2;
                  uint64_t v389 = 0;
                  uint64_t v390 = (v388 - 1);
                  if ((int)v388 - 1 >= 0)
                  {
                    uint64_t v391 = *(void *)(*v53 + 24);
                    int v392 = v384;
                    do
                    {
                      ldiv_t v393 = ldiv(v392, *(int *)(v387 + 4 * v390));
                      int v392 = v393.quot;
                      v389 += *(void *)(v391 + 8 * v390--) * v393.rem;
                    }
                    while (v390 != -1);
                  }
                  uint64_t v394 = *(void *)*v54;
                  unint64_t v395 = (unint64_t)(*(void *)(*v54 + 8) - v394) >> 2;
                  uint64_t v396 = 0;
                  uint64_t v397 = (v395 - 1);
                  if ((int)v395 - 1 >= 0)
                  {
                    uint64_t v398 = *(void *)(*v54 + 24);
                    int v399 = v384;
                    do
                    {
                      ldiv_t v400 = ldiv(v399, *(int *)(v394 + 4 * v397));
                      int v399 = v400.quot;
                      v396 += *(void *)(v398 + 8 * v397--) * v400.rem;
                    }
                    while (v397 != -1);
                  }
                  *(unsigned char *)(v386 + v384++) = *((unsigned char *)v385 + (int)v396) | *(unsigned char *)(v1674 + (int)v389);
                }
                while (v384 < *(void *)(*(void *)v1684 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 1:
      goto LABEL_33;
    case 2:
      char v7 = *(uint64_t **)a1;
      BOOL v6 = *(uint64_t **)(a1 + 8);
      switch(v8)
      {
        case 0:
          goto LABEL_12;
        case 1:
          int v9 = *(_DWORD *)(*v6 + 160);
          if (v9 >= 1)
          {
            int v10 = **(_DWORD **)(*v7 + 152);
            int v11 = *(int **)(*(void *)v1 + 152);
            int v12 = *(int **)(*v6 + 152);
            unsigned int v13 = v9 + 1;
            do
            {
              int v14 = *v12++;
              *v11++ = v14 | v10;
              --v13;
            }
            while (v13 > 1);
          }
          return;
        case 2:
          int v116 = *(_DWORD *)(*v7 + 160);
          if (v116 >= 1)
          {
            int v117 = **(_DWORD **)(*v6 + 152);
            v118 = *(int **)(*(void *)v1 + 152);
            v119 = *(int **)(*v7 + 152);
            unsigned int v120 = v116 + 1;
            do
            {
              int v121 = *v119++;
              *v118++ = v121 | v117;
              --v120;
            }
            while (v120 > 1);
          }
          return;
        case 3:
          int v122 = *(_DWORD *)(*(void *)v1 + 48);
          if (v122 >= 1)
          {
            int v123 = *(int **)(*(void *)v1 + 152);
            int v124 = *(int **)(*v6 + 152);
            unsigned int v125 = *(int **)(*v7 + 152);
            unsigned int v126 = v122 + 1;
            do
            {
              int v128 = *v125++;
              int v127 = v128;
              int v129 = *v124++;
              *v123++ = v129 | v127;
              --v126;
            }
            while (v126 > 1);
          }
          return;
        default:
          int v107 = *(void **)v1;
          int v108 = (void *)*v7;
          int v109 = *(int **)*v7;
          uint64_t v110 = (v108[1] - (void)v109) >> 2;
          uint64_t v111 = (v110 - 1);
          if ((int)v111 >= -1) {
            int v112 = -1;
          }
          else {
            int v112 = v110 - 1;
          }
          int v113 = v112 + 1;
          int v114 = v110 + 1;
          break;
      }
      while (1)
      {
        unsigned int v115 = v114 - 2;
        if (v114 - 2 < 0) {
          break;
        }
        --v114;
        if (*(void *)(v108[3] + 8 * v115) != *(void *)(v107[3] + 8 * v115)) {
          goto LABEL_187;
        }
      }
      int v114 = v113;
LABEL_187:
      uint64_t v233 = (void *)*v6;
      unsigned int v234 = *(int **)*v6;
      uint64_t v235 = (v233[1] - (void)v234) >> 2;
      uint64_t v236 = (v235 - 1);
      if ((int)v236 >= -1) {
        int v237 = -1;
      }
      else {
        int v237 = v235 - 1;
      }
      int v238 = v237 + 1;
      int v239 = v235 + 1;
      while (1)
      {
        unsigned int v240 = v239 - 2;
        if (v239 - 2 < 0) {
          break;
        }
        --v239;
        if (*(void *)(v233[3] + 8 * v240) != *(void *)(v107[3] + 8 * v240)) {
          goto LABEL_223;
        }
      }
      int v239 = v238;
LABEL_223:
      int v266 = v110 + 1;
      while (1)
      {
        unsigned int v267 = v266 - 2;
        if (v266 - 2 < 0) {
          break;
        }
        --v266;
        if (*(void *)(v108[3] + 8 * v267)) {
          goto LABEL_248;
        }
      }
      int v266 = v113;
LABEL_248:
      int v276 = v235 + 1;
      while (1)
      {
        unsigned int v277 = v276 - 2;
        if (v276 - 2 < 0) {
          break;
        }
        --v276;
        if (*(void *)(v233[3] + 8 * v277)) {
          goto LABEL_291;
        }
      }
      int v276 = v238;
LABEL_291:
      unint64_t v295 = (uint64_t)(v107[1] - *v107) >> 2;
      if (v114 <= v239) {
        int v296 = v239;
      }
      else {
        int v296 = v114;
      }
      if (v114 <= v276) {
        int v114 = v276;
      }
      if (v266 > v239) {
        int v239 = v266;
      }
      if (v295 > v239)
      {
        int v297 = 1;
      }
      else
      {
        int v239 = (uint64_t)(v107[1] - *v107) >> 2;
        int v297 = 4;
      }
      if (v295 > v114)
      {
        int v298 = 2;
      }
      else
      {
        int v114 = v239;
        int v298 = v297;
      }
      if (v295 > v296)
      {
        int v114 = v296;
        int v298 = 3;
      }
      uint64_t v1671 = v236;
      uint64_t v1686 = v111;
      if (!v114) {
        goto LABEL_308;
      }
      unint64_t v299 = *(void *)(v107[3] + 8 * (v114 - 1));
      if (v299 < 0x10) {
        goto LABEL_308;
      }
      switch(v298)
      {
        case 1:
          if (v114 == 2)
          {
            int v1298 = *v109;
            if (*v109)
            {
              unint64_t v1299 = 0;
              uint64_t v1300 = 0;
              uint64_t v1301 = 0;
              uint64_t v1302 = v108[19];
              uint64_t v1303 = v233[19];
              uint64_t v1304 = v107[19];
              v1305 = (uint64_t *)v108[3];
              uint64_t v1306 = *v1305;
              uint64_t v1307 = v1305[1];
              v1308 = (uint64_t *)v233[3];
              uint64_t v1309 = *v1308;
              uint64_t v1310 = v1308[1];
              int v1311 = v109[1];
              int v1312 = v1311;
              do
              {
                if (v1312)
                {
                  unint64_t v1313 = 0;
                  uint64_t v1314 = v1303 + 4 * v1300;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1315 = 0;
                      int v1316 = *(_DWORD *)(v1302 + 4 * v1301);
                      unsigned int v1317 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1304 + v1315) = *(_DWORD *)(v1314 + v1315) | v1316;
                        --v1317;
                        v1315 += 4;
                      }
                      while (v1317 > 1);
                      int v1311 = v109[1];
                    }
                    v1301 += v1307;
                    v1300 += v1310;
                    v1304 += 4 * (int)v299;
                    ++v1313;
                    v1314 += 4 * v1310;
                  }
                  while (v1313 < v1311);
                  uint64_t v1318 = v1311;
                  int v1298 = *v109;
                  int v1312 = v1311;
                }
                else
                {
                  uint64_t v1318 = 0;
                }
                uint64_t v1301 = v1301 + v1306 - v1318 * v1307;
                uint64_t v1300 = v1300 + v1309 - v1310 * v234[1];
                ++v1299;
              }
              while (v1299 < v1298);
            }
          }
          else if (v114 == 1)
          {
            int v880 = *v109;
            if (*v109)
            {
              unint64_t v881 = 0;
              uint64_t v882 = 0;
              uint64_t v883 = v108[19];
              uint64_t v884 = v233[19];
              uint64_t v885 = v107[19];
              uint64_t v886 = *(void *)v108[3];
              uint64_t v887 = 4 * *(void *)v233[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v888 = 0;
                  int v889 = *(_DWORD *)(v883 + 4 * v882);
                  unsigned int v890 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v885 + v888) = *(_DWORD *)(v884 + v888) | v889;
                    --v890;
                    v888 += 4;
                  }
                  while (v890 > 1);
                  int v880 = *v109;
                }
                v882 += v886;
                ++v881;
                v885 += 4 * (int)v299;
                v884 += v887;
              }
              while (v881 < v880);
            }
          }
          else
          {
            unint64_t v1643 = v107[6];
            if (v1643)
            {
              unint64_t v1662 = 0;
              uint64_t v1587 = v233[19];
              uint64_t v1601 = v108[19];
              uint64_t v1319 = v107[19];
              do
              {
                uint64_t v1320 = 0;
                if ((v111 & 0x80000000) == 0)
                {
                  uint64_t v1321 = v108[3];
                  uint64_t v1322 = v111;
                  int v1323 = v1662;
                  do
                  {
                    ldiv_t v1324 = ldiv(v1323, v109[v1322]);
                    int v1323 = v1324.quot;
                    v1320 += *(void *)(v1321 + 8 * v1322--) * v1324.rem;
                  }
                  while (v1322 != -1);
                }
                uint64_t v1325 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1326) = 0;
                }
                else
                {
                  uint64_t v1326 = 0;
                  uint64_t v1327 = v233[3];
                  int v1328 = v1662;
                  do
                  {
                    ldiv_t v1329 = ldiv(v1328, v234[v1325]);
                    int v1328 = v1329.quot;
                    v1326 += *(void *)(v1327 + 8 * v1325--) * v1329.rem;
                  }
                  while (v1325 != -1);
                }
                uint64_t v111 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1330 = 0;
                  int v1331 = *(_DWORD *)(v1601 + 4 * (int)v1320);
                  unsigned int v1332 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1319 + v1330) = *(_DWORD *)(v1587 + 4 * (int)v1326 + v1330) | v1331;
                    --v1332;
                    v1330 += 4;
                  }
                  while (v1332 > 1);
                }
                v1319 += 4 * (int)v299;
                v1662 += (int)v299;
              }
              while (v1662 < v1643);
            }
          }
          break;
        case 2:
          if (v114 == 2)
          {
            int v1333 = *v109;
            if (*v109)
            {
              unint64_t v1334 = 0;
              uint64_t v1335 = 0;
              uint64_t v1336 = 0;
              uint64_t v1337 = v108[19];
              uint64_t v1338 = v233[19];
              uint64_t v1339 = v107[19];
              uint64_t v1340 = (uint64_t *)v108[3];
              uint64_t v1341 = *v1340;
              uint64_t v1342 = v1340[1];
              v1343 = (uint64_t *)v233[3];
              uint64_t v1344 = *v1343;
              uint64_t v1345 = v1343[1];
              int v1346 = v109[1];
              int v1347 = v1346;
              do
              {
                if (v1347)
                {
                  unint64_t v1348 = 0;
                  uint64_t v1349 = v1337 + 4 * v1336;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1350 = 0;
                      int v1351 = *(_DWORD *)(v1338 + 4 * v1335);
                      unsigned int v1352 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1339 + v1350) = *(_DWORD *)(v1349 + v1350) | v1351;
                        --v1352;
                        v1350 += 4;
                      }
                      while (v1352 > 1);
                      int v1346 = v109[1];
                    }
                    v1336 += v1342;
                    v1335 += v1345;
                    v1339 += 4 * (int)v299;
                    ++v1348;
                    v1349 += 4 * v1342;
                  }
                  while (v1348 < v1346);
                  uint64_t v1353 = v1346;
                  int v1333 = *v109;
                  int v1347 = v1346;
                }
                else
                {
                  uint64_t v1353 = 0;
                }
                uint64_t v1336 = v1336 + v1341 - v1353 * v1342;
                uint64_t v1335 = v1335 + v1344 - v1345 * v234[1];
                ++v1334;
              }
              while (v1334 < v1333);
            }
          }
          else if (v114 == 1)
          {
            int v891 = *v109;
            if (*v109)
            {
              unint64_t v892 = 0;
              uint64_t v893 = 0;
              uint64_t v894 = v108[19];
              uint64_t v895 = v233[19];
              uint64_t v896 = v107[19];
              uint64_t v897 = *(void *)v233[3];
              uint64_t v898 = 4 * *(void *)v108[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v899 = 0;
                  int v900 = *(_DWORD *)(v895 + 4 * v893);
                  unsigned int v901 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v896 + v899) = *(_DWORD *)(v894 + v899) | v900;
                    --v901;
                    v899 += 4;
                  }
                  while (v901 > 1);
                  int v891 = *v109;
                }
                v893 += v897;
                ++v892;
                v896 += 4 * (int)v299;
                v894 += v898;
              }
              while (v892 < v891);
            }
          }
          else
          {
            unint64_t v1644 = v107[6];
            if (v1644)
            {
              unint64_t v1663 = 0;
              uint64_t v1588 = v233[19];
              uint64_t v1602 = v108[19];
              uint64_t v1354 = v107[19];
              do
              {
                uint64_t v1355 = 0;
                if ((v111 & 0x80000000) == 0)
                {
                  uint64_t v1356 = v108[3];
                  uint64_t v1357 = v111;
                  int v1358 = v1663;
                  do
                  {
                    ldiv_t v1359 = ldiv(v1358, v109[v1357]);
                    int v1358 = v1359.quot;
                    v1355 += *(void *)(v1356 + 8 * v1357--) * v1359.rem;
                  }
                  while (v1357 != -1);
                }
                uint64_t v1360 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1361) = 0;
                }
                else
                {
                  uint64_t v1361 = 0;
                  uint64_t v1362 = v233[3];
                  int v1363 = v1663;
                  do
                  {
                    ldiv_t v1364 = ldiv(v1363, v234[v1360]);
                    int v1363 = v1364.quot;
                    v1361 += *(void *)(v1362 + 8 * v1360--) * v1364.rem;
                  }
                  while (v1360 != -1);
                }
                uint64_t v111 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1365 = 0;
                  int v1366 = *(_DWORD *)(v1588 + 4 * (int)v1361);
                  unsigned int v1367 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1354 + v1365) = *(_DWORD *)(v1602 + 4 * (int)v1355 + v1365) | v1366;
                    --v1367;
                    v1365 += 4;
                  }
                  while (v1367 > 1);
                }
                v1354 += 4 * (int)v299;
                v1663 += (int)v299;
              }
              while (v1663 < v1644);
            }
          }
          break;
        case 3:
          if (v114 == 2)
          {
            int v1095 = *v109;
            if (*v109)
            {
              unint64_t v1096 = 0;
              uint64_t v1097 = 0;
              uint64_t v1098 = 0;
              uint64_t v1099 = v108[19];
              uint64_t v1100 = v233[19];
              uint64_t v1101 = v107[19];
              uint64_t v1102 = (uint64_t *)v108[3];
              uint64_t v1103 = *v1102;
              uint64_t v1104 = v1102[1];
              uint64_t v1105 = (uint64_t *)v233[3];
              uint64_t v1106 = *v1105;
              uint64_t v1107 = v1105[1];
              int v1108 = v109[1];
              int v1109 = v1108;
              do
              {
                if (v1109)
                {
                  unint64_t v1110 = 0;
                  uint64_t v1111 = v1100 + 4 * v1097;
                  uint64_t v1112 = v1099 + 4 * v1098;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1113 = 0;
                      unsigned int v1114 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1101 + v1113) = *(_DWORD *)(v1111 + v1113) | *(_DWORD *)(v1112 + v1113);
                        --v1114;
                        v1113 += 4;
                      }
                      while (v1114 > 1);
                      int v1108 = v109[1];
                    }
                    v1098 += v1104;
                    v1097 += v1107;
                    v1101 += 4 * (int)v299;
                    ++v1110;
                    v1111 += 4 * v1107;
                    v1112 += 4 * v1104;
                  }
                  while (v1110 < v1108);
                  uint64_t v1115 = v1108;
                  int v1095 = *v109;
                  int v1109 = v1108;
                }
                else
                {
                  uint64_t v1115 = 0;
                }
                uint64_t v1098 = v1098 + v1103 - v1115 * v1104;
                uint64_t v1097 = v1097 + v1106 - v1107 * v234[1];
                ++v1096;
              }
              while (v1096 < v1095);
            }
          }
          else if (v114 == 1)
          {
            int v348 = *v109;
            if (*v109)
            {
              unint64_t v349 = 0;
              uint64_t v350 = v108[19];
              uint64_t v351 = v233[19];
              uint64_t v352 = v107[19];
              uint64_t v353 = 4 * *(void *)v233[3];
              uint64_t v354 = 4 * *(void *)v108[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v355 = 0;
                  unsigned int v356 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v352 + v355) = *(_DWORD *)(v351 + v355) | *(_DWORD *)(v350 + v355);
                    --v356;
                    v355 += 4;
                  }
                  while (v356 > 1);
                  int v348 = *v109;
                }
                ++v349;
                v352 += 4 * (int)v299;
                v351 += v353;
                v350 += v354;
              }
              while (v349 < v348);
            }
          }
          else
          {
            unint64_t v1639 = v107[6];
            if (v1639)
            {
              unint64_t v1658 = 0;
              uint64_t v1582 = v233[19];
              uint64_t v1596 = v108[19];
              uint64_t v1116 = v107[19];
              do
              {
                uint64_t v1117 = 0;
                if ((v111 & 0x80000000) == 0)
                {
                  uint64_t v1118 = v108[3];
                  uint64_t v1119 = v111;
                  int v1120 = v1658;
                  do
                  {
                    ldiv_t v1121 = ldiv(v1120, v109[v1119]);
                    int v1120 = v1121.quot;
                    v1117 += *(void *)(v1118 + 8 * v1119--) * v1121.rem;
                  }
                  while (v1119 != -1);
                }
                uint64_t v1122 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1123) = 0;
                }
                else
                {
                  uint64_t v1123 = 0;
                  uint64_t v1124 = v233[3];
                  int v1125 = v1658;
                  do
                  {
                    ldiv_t v1126 = ldiv(v1125, v234[v1122]);
                    int v1125 = v1126.quot;
                    v1123 += *(void *)(v1124 + 8 * v1122--) * v1126.rem;
                  }
                  while (v1122 != -1);
                }
                uint64_t v111 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1127 = 0;
                  unsigned int v1128 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1116 + v1127) = *(_DWORD *)(v1582 + 4 * (int)v1123 + v1127) | *(_DWORD *)(v1596 + 4 * (int)v1117 + v1127);
                    --v1128;
                    v1127 += 4;
                  }
                  while (v1128 > 1);
                }
                v1116 += 4 * (int)v299;
                v1658 += (int)v299;
              }
              while (v1658 < v1639);
            }
          }
          break;
        default:
LABEL_308:
          switch(v295)
          {
            case 1uLL:
              uint64_t v300 = v107[6];
              if (v300)
              {
                v301 = (_DWORD *)v108[19];
                v302 = (_DWORD *)v233[19];
                uint64_t v303 = (int *)v107[19];
                uint64_t v304 = 4 * *(void *)v233[3];
                uint64_t v305 = 4 * *(void *)v108[3];
                do
                {
                  *v303++ = *v302 | *v301;
                  v302 = (_DWORD *)((char *)v302 + v304);
                  v301 = (_DWORD *)((char *)v301 + v305);
                  --v300;
                }
                while (v300);
              }
              break;
            case 2uLL:
              int v562 = *v109;
              if (*v109)
              {
                unint64_t v563 = 0;
                uint64_t v564 = 0;
                uint64_t v565 = 0;
                uint64_t v566 = 0;
                uint64_t v567 = v108[19];
                uint64_t v568 = v233[19];
                uint64_t v569 = v107[19];
                BOOL v570 = (uint64_t *)v108[3];
                uint64_t v571 = *v570;
                uint64_t v572 = v570[1];
                uint64_t v573 = (uint64_t *)v233[3];
                uint64_t v575 = *v573;
                uint64_t v574 = v573[1];
                int v576 = v109[1];
                do
                {
                  if (v576)
                  {
                    for (unint64_t j = 0; j < v576; ++j)
                    {
                      *(_DWORD *)(v569 + 4 * v564 + 4 * j) = *(_DWORD *)(v568 + 4 * v565) | *(_DWORD *)(v567 + 4 * v566);
                      v566 += v572;
                      v565 += v574;
                      int v576 = v109[1];
                    }
                    uint64_t v578 = v576;
                    int v562 = *v109;
                    v564 += j;
                  }
                  else
                  {
                    uint64_t v578 = 0;
                  }
                  uint64_t v566 = v566 + v571 - v578 * v572;
                  uint64_t v565 = v565 + v575 - v574 * v234[1];
                  ++v563;
                }
                while (v563 < v562);
              }
              break;
            case 3uLL:
              int v579 = *v109;
              if (*v109)
              {
                unint64_t v580 = 0;
                uint64_t v581 = 0;
                uint64_t v582 = 0;
                uint64_t v583 = 0;
                uint64_t v584 = v108[19];
                uint64_t v585 = v233[19];
                uint64_t v586 = v107[19];
                uint64_t v587 = (uint64_t *)v108[3];
                uint64_t v588 = *v587;
                uint64_t v589 = v587[1];
                uint64_t v590 = (uint64_t *)v233[3];
                uint64_t v591 = *v590;
                uint64_t v592 = v590[1];
                int v593 = v109[1];
                int v594 = v593;
                do
                {
                  if (v594)
                  {
                    unint64_t v595 = 0;
                    uint64_t v596 = v587[2];
                    uint64_t v597 = v590[2];
                    int v598 = v109[2];
                    do
                    {
                      if (v598)
                      {
                        for (unint64_t k = 0; k < v598; ++k)
                        {
                          *(_DWORD *)(v586 + 4 * v581 + 4 * k) = *(_DWORD *)(v585 + 4 * v582) | *(_DWORD *)(v584 + 4 * v583);
                          v583 += v596;
                          v582 += v597;
                          int v598 = v109[2];
                        }
                        uint64_t v600 = v598;
                        int v593 = v109[1];
                        v581 += k;
                      }
                      else
                      {
                        uint64_t v600 = 0;
                      }
                      uint64_t v583 = v583 + v589 - v600 * v596;
                      uint64_t v582 = v582 + v592 - v597 * v234[2];
                      ++v595;
                    }
                    while (v595 < v593);
                    uint64_t v601 = v593;
                    int v579 = *v109;
                    int v594 = v593;
                  }
                  else
                  {
                    uint64_t v601 = 0;
                  }
                  uint64_t v583 = v583 + v588 - v601 * v589;
                  uint64_t v582 = v582 + v591 - v592 * v234[1];
                  ++v580;
                }
                while (v580 < v579);
              }
              break;
            case 4uLL:
              int v602 = *v109;
              if (*v109)
              {
                unint64_t v603 = 0;
                uint64_t v604 = 0;
                uint64_t v605 = 0;
                uint64_t v606 = 0;
                uint64_t v607 = v108[19];
                uint64_t v608 = v233[19];
                uint64_t v609 = v107[19];
                uint64_t v610 = (uint64_t *)v108[3];
                uint64_t v611 = *v610;
                uint64_t v612 = v610[1];
                uint64_t v613 = (uint64_t *)v233[3];
                uint64_t v614 = *v613;
                uint64_t v615 = v613[1];
                int v616 = v109[1];
                int v617 = v616;
                do
                {
                  if (v617)
                  {
                    unint64_t v618 = 0;
                    uint64_t v619 = v610[2];
                    uint64_t v620 = v613[2];
                    int v621 = v109[2];
                    int v622 = v621;
                    do
                    {
                      if (v622)
                      {
                        unint64_t v623 = 0;
                        uint64_t v624 = v610[3];
                        uint64_t v625 = v613[3];
                        int v626 = v109[3];
                        do
                        {
                          if (v626)
                          {
                            for (unint64_t m = 0; m < v626; ++m)
                            {
                              *(_DWORD *)(v609 + 4 * v604 + 4 * m) = *(_DWORD *)(v608 + 4 * v605) | *(_DWORD *)(v607 + 4 * v606);
                              v606 += v624;
                              v605 += v625;
                              int v626 = v109[3];
                            }
                            uint64_t v628 = v626;
                            int v621 = v109[2];
                            v604 += m;
                          }
                          else
                          {
                            uint64_t v628 = 0;
                          }
                          uint64_t v606 = v606 + v619 - v628 * v624;
                          uint64_t v605 = v605 + v620 - v625 * v234[3];
                          ++v623;
                        }
                        while (v623 < v621);
                        uint64_t v629 = v621;
                        int v616 = v109[1];
                        int v622 = v621;
                      }
                      else
                      {
                        uint64_t v629 = 0;
                      }
                      uint64_t v606 = v606 + v612 - v629 * v619;
                      uint64_t v605 = v605 + v615 - v620 * v234[2];
                      ++v618;
                    }
                    while (v618 < v616);
                    uint64_t v630 = v616;
                    int v602 = *v109;
                    int v617 = v616;
                  }
                  else
                  {
                    uint64_t v630 = 0;
                  }
                  uint64_t v606 = v606 + v611 - v630 * v612;
                  uint64_t v605 = v605 + v614 - v615 * v234[1];
                  ++v603;
                }
                while (v603 < v602);
              }
              break;
            default:
              uint64_t v550 = v107[6];
              if (v550)
              {
                uint64_t v551 = 0;
                uint64_t v1632 = v233[19];
                uint64_t v1654 = v108[19];
                uint64_t v1618 = v107[19];
                do
                {
                  uint64_t v552 = 0;
                  if ((v111 & 0x80000000) == 0)
                  {
                    uint64_t v553 = v108[3];
                    uint64_t v554 = v111;
                    int v555 = v551;
                    do
                    {
                      ldiv_t v556 = ldiv(v555, v109[v554]);
                      int v555 = v556.quot;
                      v552 += *(void *)(v553 + 8 * v554--) * v556.rem;
                    }
                    while (v554 != -1);
                  }
                  uint64_t v557 = v1671;
                  if ((v1671 & 0x80000000) != 0)
                  {
                    LODWORD(v558) = 0;
                  }
                  else
                  {
                    uint64_t v558 = 0;
                    uint64_t v559 = v233[3];
                    int v560 = v551;
                    do
                    {
                      ldiv_t v561 = ldiv(v560, v234[v557]);
                      int v560 = v561.quot;
                      v558 += *(void *)(v559 + 8 * v557--) * v561.rem;
                    }
                    while (v557 != -1);
                  }
                  *(_DWORD *)(v1618 + 4 * v551++) = *(_DWORD *)(v1632 + 4 * (int)v558) | *(_DWORD *)(v1654 + 4 * (int)v552);
                  uint64_t v111 = v1686;
                }
                while (v551 != v550);
              }
              break;
          }
          break;
      }
      return;
    case 3:
      unsigned int v15 = *(uint64_t **)a1;
      int v16 = *(uint64_t **)(a1 + 8);
      switch(v17)
      {
        case 0:
          char v18 = **(unsigned char **)(*v16 + 152) | **(unsigned char **)(*v15 + 152);
          uint64_t v19 = *(void *)v1;
LABEL_35:
          **(unsigned char **)(v19 + 152) = v18;
          return;
        case 1:
          int v138 = *(_DWORD *)(*v16 + 160);
          if (v138 >= 1)
          {
            char v139 = **(unsigned char **)(*v15 + 152);
            v140 = *(unsigned char **)(*(void *)v1 + 152);
            uint64_t v141 = *(char **)(*v16 + 152);
            unsigned int v142 = v138 + 1;
            do
            {
              char v143 = *v141++;
              *v140++ = v143 | v139;
              --v142;
            }
            while (v142 > 1);
          }
          return;
        case 2:
          int v144 = *(_DWORD *)(*v15 + 160);
          if (v144 >= 1)
          {
            char v145 = **(unsigned char **)(*v16 + 152);
            int v146 = *(unsigned char **)(*(void *)v1 + 152);
            unsigned int v147 = *(char **)(*v15 + 152);
            unsigned int v148 = v144 + 1;
            do
            {
              char v149 = *v147++;
              *v146++ = v149 | v145;
              --v148;
            }
            while (v148 > 1);
          }
          return;
        case 3:
          int v150 = *(_DWORD *)(*(void *)v1 + 48);
          if (v150 >= 1)
          {
            v151 = *(unsigned char **)(*(void *)v1 + 152);
            unsigned int v152 = *(char **)(*v16 + 152);
            char v153 = *(char **)(*v15 + 152);
            unsigned int v154 = v150 + 1;
            do
            {
              char v156 = *v153++;
              char v155 = v156;
              char v157 = *v152++;
              *v151++ = v157 | v155;
              --v154;
            }
            while (v154 > 1);
          }
          return;
        default:
          unsigned int v130 = *(void **)v1;
          uint64_t v131 = *v15;
          int v132 = *(int **)*v15;
          uint64_t v133 = (*(void *)(*v15 + 8) - (void)v132) >> 2;
          int v134 = v133 - 1;
          if ((int)v133 - 1 >= -1) {
            int v134 = -1;
          }
          int v135 = v134 + 1;
          int v136 = v133 + 1;
          break;
      }
      while (1)
      {
        unsigned int v137 = v136 - 2;
        if (v136 - 2 < 0) {
          break;
        }
        --v136;
        if (*(void *)(*(void *)(v131 + 24) + 8 * v137) != *(void *)(v130[3] + 8 * v137)) {
          goto LABEL_195;
        }
      }
      int v136 = v135;
LABEL_195:
      int v241 = (int **)*v16;
      unsigned int v242 = *(int **)*v16;
      uint64_t v243 = (*(void *)(*v16 + 8) - (void)v242) >> 2;
      int v244 = v243 - 1;
      if ((int)v243 - 1 >= -1) {
        int v244 = -1;
      }
      int v245 = v244 + 1;
      int v246 = v243 + 1;
      while (1)
      {
        unsigned int v247 = v246 - 2;
        if (v246 - 2 < 0) {
          break;
        }
        --v246;
        if (*(void *)&v241[3][2 * v247] != *(void *)(v130[3] + 8 * v247)) {
          goto LABEL_228;
        }
      }
      int v246 = v245;
LABEL_228:
      int v268 = v133 + 1;
      while (1)
      {
        unsigned int v269 = v268 - 2;
        if (v268 - 2 < 0) {
          break;
        }
        --v268;
        if (*(void *)(*(void *)(v131 + 24) + 8 * v269)) {
          goto LABEL_253;
        }
      }
      int v268 = v135;
LABEL_253:
      int v278 = v243 + 1;
      while (1)
      {
        int v279 = v278 - 2;
        if (v278 - 2 < 0) {
          break;
        }
        --v278;
        if (*(void *)&v241[3][2 * v279]) {
          goto LABEL_314;
        }
      }
      int v278 = v245;
LABEL_314:
      unint64_t v306 = (uint64_t)(v130[1] - *v130) >> 2;
      if (v136 <= v246) {
        int v307 = v246;
      }
      else {
        int v307 = v136;
      }
      if (v136 <= v278) {
        int v136 = v278;
      }
      if (v268 > v246) {
        int v246 = v268;
      }
      if (v306 > v246)
      {
        int v308 = 1;
      }
      else
      {
        int v246 = (uint64_t)(v130[1] - *v130) >> 2;
        int v308 = 4;
      }
      if (v306 > v136)
      {
        int v309 = 2;
      }
      else
      {
        int v136 = v246;
        int v309 = v308;
      }
      if (v306 > v307)
      {
        int v136 = v307;
        int v309 = 3;
      }
      if (!v136) {
        goto LABEL_331;
      }
      unint64_t v310 = *(void *)(v130[3] + 8 * (v136 - 1));
      if (v310 < 0x10) {
        goto LABEL_331;
      }
      uint64_t v1689 = *(void *)(v130[3] + 8 * (v136 - 1));
      switch(v309)
      {
        case 1:
          if (v136 == 2)
          {
            int v1368 = *v132;
            if (*v132)
            {
              unint64_t v1369 = 0;
              uint64_t v1370 = 0;
              uint64_t v1371 = 0;
              uint64_t v1372 = *(void *)(v131 + 152);
              uint64_t v1373 = v241[19];
              uint64_t v1374 = v130[19];
              do
              {
                if (v132[1])
                {
                  unint64_t v1375 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1376 = 0;
                      char v1377 = *(unsigned char *)(v1372 + v1371);
                      unsigned int v1378 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1374 + v1376) = *((unsigned char *)v1373 + v1370 + v1376) | v1377;
                        --v1378;
                        ++v1376;
                      }
                      while (v1378 > 1);
                      uint64_t v131 = *v15;
                      int v241 = (int **)*v16;
                      int v132 = *(int **)*v15;
                    }
                    uint64_t v1379 = *(void **)(v131 + 24);
                    uint64_t v1380 = v1379[1];
                    v1371 += v1380;
                    v1370 += *((void *)v241[3] + 1);
                    v1374 += (int)v310;
                    ++v1375;
                    unint64_t v1381 = v132[1];
                  }
                  while (v1375 < v1381);
                  int v1368 = *v132;
                  unsigned int v242 = *v241;
                }
                else
                {
                  unint64_t v1381 = 0;
                  uint64_t v1379 = *(void **)(v131 + 24);
                  uint64_t v1380 = v1379[1];
                }
                uint64_t v1371 = *v1379 + v1371 - v1381 * v1380;
                uint64_t v1370 = *(void *)v241[3] + v1370 - *((void *)v241[3] + 1) * v242[1];
                ++v1369;
              }
              while (v1369 < v1368);
            }
          }
          else if (v136 == 1)
          {
            int v902 = *v132;
            if (*v132)
            {
              unint64_t v903 = 0;
              uint64_t v904 = 0;
              uint64_t v905 = 0;
              uint64_t v906 = *(void *)(v131 + 152);
              unint64_t v907 = v241[19];
              uint64_t v908 = v130[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v909 = 0;
                  char v910 = *(unsigned char *)(v906 + v905);
                  unsigned int v911 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v908 + v909) = *((unsigned char *)v907 + v904 + v909) | v910;
                    --v911;
                    ++v909;
                  }
                  while (v911 > 1);
                  uint64_t v131 = *v15;
                  int v241 = (int **)*v16;
                  int v902 = **(_DWORD **)*v15;
                }
                v905 += **(void **)(v131 + 24);
                v904 += *(void *)v241[3];
                v908 += (int)v310;
                ++v903;
              }
              while (v903 < v902);
            }
          }
          else if (v130[6])
          {
            uint64_t v1629 = v241[19];
            uint64_t v1645 = *(void *)(v131 + 152);
            uint64_t v1664 = (int)v310;
            unint64_t v1682 = 0;
            unsigned int v1614 = v310 + 1;
            uint64_t v1382 = v130[19];
            do
            {
              uint64_t v1383 = *(void *)*v15;
              unint64_t v1384 = (unint64_t)(*(void *)(*v15 + 8) - v1383) >> 2;
              uint64_t v1385 = 0;
              uint64_t v1386 = (v1384 - 1);
              if ((int)v1384 - 1 >= 0)
              {
                uint64_t v1387 = *(void *)(*v15 + 24);
                int v1388 = v1682;
                do
                {
                  ldiv_t v1389 = ldiv(v1388, *(int *)(v1383 + 4 * v1386));
                  int v1388 = v1389.quot;
                  v1385 += *(void *)(v1387 + 8 * v1386--) * v1389.rem;
                }
                while (v1386 != -1);
              }
              uint64_t v1390 = *(void *)*v16;
              unint64_t v1391 = (unint64_t)(*(void *)(*v16 + 8) - v1390) >> 2;
              uint64_t v1392 = 0;
              uint64_t v1393 = (v1391 - 1);
              if ((int)v1391 - 1 >= 0)
              {
                uint64_t v1394 = *(void *)(*v16 + 24);
                int v1395 = v1682;
                do
                {
                  ldiv_t v1396 = ldiv(v1395, *(int *)(v1390 + 4 * v1393));
                  int v1395 = v1396.quot;
                  v1392 += *(void *)(v1394 + 8 * v1393--) * v1396.rem;
                }
                while (v1393 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1397 = 0;
                char v1398 = *(unsigned char *)(v1645 + (int)v1385);
                unsigned int v1399 = v1614;
                do
                {
                  *(unsigned char *)(v1382 + v1397) = *((unsigned char *)v1629 + (int)v1392 + v1397) | v1398;
                  --v1399;
                  ++v1397;
                }
                while (v1399 > 1);
                unsigned int v130 = *(void **)v1;
              }
              v1382 += v1664;
              v1682 += v1664;
            }
            while (v1682 < v130[6]);
          }
          break;
        case 2:
          if (v136 == 2)
          {
            int v1400 = *v132;
            if (*v132)
            {
              unint64_t v1401 = 0;
              uint64_t v1402 = 0;
              uint64_t v1403 = 0;
              uint64_t v1404 = *(void *)(v131 + 152);
              unsigned int v1405 = v241[19];
              uint64_t v1406 = v130[19];
              do
              {
                if (v132[1])
                {
                  unint64_t v1407 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1408 = 0;
                      char v1409 = *((unsigned char *)v1405 + v1402);
                      unsigned int v1410 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1406 + v1408) = *(unsigned char *)(v1404 + v1403 + v1408) | v1409;
                        --v1410;
                        ++v1408;
                      }
                      while (v1410 > 1);
                      uint64_t v131 = *v15;
                      int v241 = (int **)*v16;
                      int v132 = *(int **)*v15;
                    }
                    v1411 = *(void **)(v131 + 24);
                    uint64_t v1412 = v1411[1];
                    v1403 += v1412;
                    v1402 += *((void *)v241[3] + 1);
                    v1406 += (int)v310;
                    ++v1407;
                    unint64_t v1413 = v132[1];
                  }
                  while (v1407 < v1413);
                  int v1400 = *v132;
                  unsigned int v242 = *v241;
                }
                else
                {
                  unint64_t v1413 = 0;
                  v1411 = *(void **)(v131 + 24);
                  uint64_t v1412 = v1411[1];
                }
                uint64_t v1403 = *v1411 + v1403 - v1413 * v1412;
                uint64_t v1402 = *(void *)v241[3] + v1402 - *((void *)v241[3] + 1) * v242[1];
                ++v1401;
              }
              while (v1401 < v1400);
            }
          }
          else if (v136 == 1)
          {
            int v912 = *v132;
            if (*v132)
            {
              unint64_t v913 = 0;
              uint64_t v914 = 0;
              uint64_t v915 = 0;
              uint64_t v916 = *(void *)(v131 + 152);
              int v917 = v241[19];
              uint64_t v918 = v130[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v919 = 0;
                  char v920 = *((unsigned char *)v917 + v914);
                  unsigned int v921 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v918 + v919) = *(unsigned char *)(v916 + v915 + v919) | v920;
                    --v921;
                    ++v919;
                  }
                  while (v921 > 1);
                  uint64_t v131 = *v15;
                  int v241 = (int **)*v16;
                  int v912 = **(_DWORD **)*v15;
                }
                v915 += **(void **)(v131 + 24);
                v914 += *(void *)v241[3];
                v918 += (int)v310;
                ++v913;
              }
              while (v913 < v912);
            }
          }
          else if (v130[6])
          {
            uint64_t v1630 = v241[19];
            uint64_t v1646 = *(void *)(v131 + 152);
            uint64_t v1665 = (int)v310;
            unint64_t v1683 = 0;
            unsigned int v1615 = v310 + 1;
            uint64_t v1414 = v130[19];
            do
            {
              uint64_t v1415 = *(void *)*v15;
              unint64_t v1416 = (unint64_t)(*(void *)(*v15 + 8) - v1415) >> 2;
              uint64_t v1417 = 0;
              uint64_t v1418 = (v1416 - 1);
              if ((int)v1416 - 1 >= 0)
              {
                uint64_t v1419 = *(void *)(*v15 + 24);
                int v1420 = v1683;
                do
                {
                  ldiv_t v1421 = ldiv(v1420, *(int *)(v1415 + 4 * v1418));
                  int v1420 = v1421.quot;
                  v1417 += *(void *)(v1419 + 8 * v1418--) * v1421.rem;
                }
                while (v1418 != -1);
              }
              uint64_t v1422 = *(void *)*v16;
              unint64_t v1423 = (unint64_t)(*(void *)(*v16 + 8) - v1422) >> 2;
              uint64_t v1424 = 0;
              uint64_t v1425 = (v1423 - 1);
              if ((int)v1423 - 1 >= 0)
              {
                uint64_t v1426 = *(void *)(*v16 + 24);
                int v1427 = v1683;
                do
                {
                  ldiv_t v1428 = ldiv(v1427, *(int *)(v1422 + 4 * v1425));
                  int v1427 = v1428.quot;
                  v1424 += *(void *)(v1426 + 8 * v1425--) * v1428.rem;
                }
                while (v1425 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1429 = 0;
                char v1430 = *((unsigned char *)v1630 + (int)v1424);
                unsigned int v1431 = v1615;
                do
                {
                  *(unsigned char *)(v1414 + v1429) = *(unsigned char *)(v1646 + (int)v1417 + v1429) | v1430;
                  --v1431;
                  ++v1429;
                }
                while (v1431 > 1);
                unsigned int v130 = *(void **)v1;
              }
              v1414 += v1665;
              v1683 += v1665;
            }
            while (v1683 < v130[6]);
          }
          break;
        case 3:
          if (v136 == 2)
          {
            int v1129 = *v132;
            if (*v132)
            {
              unint64_t v1130 = 0;
              uint64_t v1131 = 0;
              uint64_t v1132 = 0;
              uint64_t v1133 = *(void *)(v131 + 152);
              uint64_t v1134 = v241[19];
              uint64_t v1135 = v130[19];
              do
              {
                if (v132[1])
                {
                  unint64_t v1136 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1137 = 0;
                      unsigned int v1138 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1135 + v1137) = *((unsigned char *)v1134 + v1131 + v1137) | *(unsigned char *)(v1133 + v1132 + v1137);
                        --v1138;
                        ++v1137;
                      }
                      while (v1138 > 1);
                      uint64_t v131 = *v15;
                      int v241 = (int **)*v16;
                      int v132 = *(int **)*v15;
                    }
                    int v1139 = *(void **)(v131 + 24);
                    uint64_t v1140 = v1139[1];
                    v1132 += v1140;
                    v1131 += *((void *)v241[3] + 1);
                    v1135 += (int)v310;
                    ++v1136;
                    unint64_t v1141 = v132[1];
                  }
                  while (v1136 < v1141);
                  int v1129 = *v132;
                  unsigned int v242 = *v241;
                }
                else
                {
                  unint64_t v1141 = 0;
                  int v1139 = *(void **)(v131 + 24);
                  uint64_t v1140 = v1139[1];
                }
                uint64_t v1132 = *v1139 + v1132 - v1141 * v1140;
                uint64_t v1131 = *(void *)v241[3] + v1131 - *((void *)v241[3] + 1) * v242[1];
                ++v1130;
              }
              while (v1130 < v1129);
            }
          }
          else if (v136 == 1)
          {
            int v357 = *v132;
            if (*v132)
            {
              unint64_t v358 = 0;
              uint64_t v359 = 0;
              uint64_t v360 = 0;
              uint64_t v361 = *(void *)(v131 + 152);
              int v362 = v241[19];
              uint64_t v363 = v130[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v364 = 0;
                  unsigned int v365 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v363 + v364) = *((unsigned char *)v362 + v359 + v364) | *(unsigned char *)(v361 + v360 + v364);
                    --v365;
                    ++v364;
                  }
                  while (v365 > 1);
                  uint64_t v131 = *v15;
                  int v241 = (int **)*v16;
                  int v357 = **(_DWORD **)*v15;
                }
                v360 += **(void **)(v131 + 24);
                v359 += *(void *)v241[3];
                v363 += (int)v310;
                ++v358;
              }
              while (v358 < v357);
            }
          }
          else if (v130[6])
          {
            uint64_t v1626 = v241[19];
            uint64_t v1640 = *(void *)(v131 + 152);
            uint64_t v1659 = (int)v310;
            unint64_t v1681 = 0;
            unsigned int v1611 = v310 + 1;
            uint64_t v1142 = v130[19];
            do
            {
              uint64_t v1143 = *(void *)*v15;
              unint64_t v1144 = (unint64_t)(*(void *)(*v15 + 8) - v1143) >> 2;
              uint64_t v1145 = 0;
              uint64_t v1146 = (v1144 - 1);
              if ((int)v1144 - 1 >= 0)
              {
                uint64_t v1147 = *(void *)(*v15 + 24);
                int v1148 = v1681;
                do
                {
                  ldiv_t v1149 = ldiv(v1148, *(int *)(v1143 + 4 * v1146));
                  int v1148 = v1149.quot;
                  v1145 += *(void *)(v1147 + 8 * v1146--) * v1149.rem;
                }
                while (v1146 != -1);
              }
              uint64_t v1150 = *(void *)*v16;
              unint64_t v1151 = (unint64_t)(*(void *)(*v16 + 8) - v1150) >> 2;
              uint64_t v1152 = 0;
              uint64_t v1153 = (v1151 - 1);
              if ((int)v1151 - 1 >= 0)
              {
                uint64_t v1154 = *(void *)(*v16 + 24);
                int v1155 = v1681;
                do
                {
                  ldiv_t v1156 = ldiv(v1155, *(int *)(v1150 + 4 * v1153));
                  int v1155 = v1156.quot;
                  v1152 += *(void *)(v1154 + 8 * v1153--) * v1156.rem;
                }
                while (v1153 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1157 = 0;
                unsigned int v1158 = v1611;
                do
                {
                  *(unsigned char *)(v1142 + v1157) = *((unsigned char *)v1626 + (int)v1152 + v1157) | *(unsigned char *)(v1640
                                                                                                + (int)v1145
                                                                                                + v1157);
                  --v1158;
                  ++v1157;
                }
                while (v1158 > 1);
                unsigned int v130 = *(void **)v1;
              }
              v1142 += v1659;
              v1681 += v1659;
            }
            while (v1681 < v130[6]);
          }
          break;
        default:
LABEL_331:
          switch(v306)
          {
            case 1uLL:
              if (v130[6])
              {
                unint64_t v311 = 0;
                uint64_t v312 = 0;
                uint64_t v313 = 0;
                uint64_t v314 = *(void *)(v131 + 152);
                v315 = v241[19];
                uint64_t v316 = v130[19];
                do
                {
                  *(unsigned char *)(v316 + v311) = *((unsigned char *)v315 + v312) | *(unsigned char *)(v314 + v313);
                  v313 += **(void **)(*v15 + 24);
                  v312 += **(void **)(*v16 + 24);
                  ++v311;
                }
                while (v311 < *(void *)(*(void *)v1 + 48));
              }
              break;
            case 2uLL:
              int v647 = *v132;
              if (*v132)
              {
                unint64_t v648 = 0;
                uint64_t v649 = 0;
                uint64_t v650 = 0;
                uint64_t v651 = 0;
                uint64_t v652 = *(void *)(v131 + 152);
                unint64_t v653 = v241[19];
                uint64_t v654 = v130[19];
                do
                {
                  if (v132[1])
                  {
                    unint64_t v655 = 0;
                    do
                    {
                      *(unsigned char *)(v654 + v649 + v655) = *((unsigned char *)v653 + v650) | *(unsigned char *)(v652 + v651);
                      uint64_t v131 = *v15;
                      unint64_t v656 = *(void **)(*v15 + 24);
                      uint64_t v657 = v656[1];
                      v651 += v657;
                      int v241 = (int **)*v16;
                      uint64_t v658 = *(int **)(*v16 + 24);
                      uint64_t v659 = *((void *)v658 + 1);
                      v650 += v659;
                      ++v655;
                      int v132 = *(int **)*v15;
                      unint64_t v660 = v132[1];
                    }
                    while (v655 < v660);
                    int v647 = *v132;
                    unsigned int v242 = *v241;
                    v649 += v655;
                  }
                  else
                  {
                    unint64_t v660 = 0;
                    unint64_t v656 = *(void **)(v131 + 24);
                    uint64_t v657 = v656[1];
                    uint64_t v658 = v241[3];
                    uint64_t v659 = *((void *)v658 + 1);
                  }
                  uint64_t v651 = *v656 + v651 - v660 * v657;
                  uint64_t v650 = *(void *)v658 + v650 - v659 * v242[1];
                  ++v648;
                }
                while (v648 < v647);
              }
              break;
            case 3uLL:
              int v661 = *v132;
              if (*v132)
              {
                unint64_t v662 = 0;
                uint64_t v663 = 0;
                uint64_t v664 = 0;
                uint64_t v665 = 0;
                uint64_t v666 = *(void *)(v131 + 152);
                int v667 = v241[19];
                uint64_t v668 = v130[19];
                do
                {
                  if (v132[1])
                  {
                    unint64_t v669 = 0;
                    do
                    {
                      if (v132[2])
                      {
                        unint64_t v670 = 0;
                        do
                        {
                          *(unsigned char *)(v668 + v663 + v670) = *((unsigned char *)v667 + v664) | *(unsigned char *)(v666 + v665);
                          uint64_t v131 = *v15;
                          uint64_t v671 = *(void **)(*v15 + 24);
                          uint64_t v672 = v671[2];
                          v665 += v672;
                          int v241 = (int **)*v16;
                          uint64_t v673 = *(int **)(*v16 + 24);
                          uint64_t v674 = *((void *)v673 + 2);
                          v664 += v674;
                          ++v670;
                          int v132 = *(int **)*v15;
                          unint64_t v675 = v132[2];
                        }
                        while (v670 < v675);
                        unsigned int v242 = *v241;
                        v663 += v670;
                      }
                      else
                      {
                        unint64_t v675 = 0;
                        uint64_t v671 = *(void **)(v131 + 24);
                        uint64_t v672 = v671[2];
                        uint64_t v673 = v241[3];
                        uint64_t v674 = *((void *)v673 + 2);
                      }
                      uint64_t v676 = v671[1];
                      uint64_t v665 = v676 + v665 - v675 * v672;
                      uint64_t v664 = *((void *)v673 + 1) + v664 - v674 * v242[2];
                      ++v669;
                      unint64_t v677 = v132[1];
                    }
                    while (v669 < v677);
                    int v661 = *v132;
                  }
                  else
                  {
                    unint64_t v677 = 0;
                    uint64_t v671 = *(void **)(v131 + 24);
                    uint64_t v676 = v671[1];
                  }
                  uint64_t v665 = *v671 + v665 - v677 * v676;
                  uint64_t v664 = *(void *)v241[3] + v664 - *((void *)v241[3] + 1) * v242[1];
                  ++v662;
                }
                while (v662 < v661);
              }
              break;
            case 4uLL:
              int v678 = *v132;
              if (*v132)
              {
                unint64_t v679 = 0;
                uint64_t v680 = 0;
                uint64_t v681 = 0;
                uint64_t v682 = 0;
                uint64_t v683 = *(void *)(v131 + 152);
                unint64_t v684 = v241[19];
                uint64_t v685 = v130[19];
                do
                {
                  if (v132[1])
                  {
                    unint64_t v686 = 0;
                    do
                    {
                      if (v132[2])
                      {
                        unint64_t v687 = 0;
                        do
                        {
                          if (v132[3])
                          {
                            unint64_t v688 = 0;
                            do
                            {
                              *(unsigned char *)(v685 + v680 + v688) = *((unsigned char *)v684 + v681) | *(unsigned char *)(v683 + v682);
                              uint64_t v131 = *v15;
                              v689 = *(void **)(*v15 + 24);
                              uint64_t v690 = v689[3];
                              v682 += v690;
                              int v241 = (int **)*v16;
                              unint64_t v691 = *(int **)(*v16 + 24);
                              uint64_t v692 = *((void *)v691 + 3);
                              v681 += v692;
                              ++v688;
                              int v132 = *(int **)*v15;
                              unint64_t v693 = v132[3];
                            }
                            while (v688 < v693);
                            unsigned int v242 = *v241;
                            v680 += v688;
                          }
                          else
                          {
                            unint64_t v693 = 0;
                            v689 = *(void **)(v131 + 24);
                            uint64_t v690 = v689[3];
                            unint64_t v691 = v241[3];
                            uint64_t v692 = *((void *)v691 + 3);
                          }
                          uint64_t v694 = v689[2];
                          uint64_t v682 = v694 + v682 - v693 * v690;
                          uint64_t v681 = *((void *)v691 + 2) + v681 - v692 * v242[3];
                          ++v687;
                          unint64_t v695 = v132[2];
                        }
                        while (v687 < v695);
                      }
                      else
                      {
                        unint64_t v695 = 0;
                        v689 = *(void **)(v131 + 24);
                        uint64_t v694 = v689[2];
                      }
                      uint64_t v682 = v689[1] + v682 - v695 * v694;
                      uint64_t v681 = *((void *)v241[3] + 1) + v681 - *((void *)v241[3] + 2) * v242[2];
                      ++v686;
                      unint64_t v696 = v132[1];
                    }
                    while (v686 < v696);
                    int v678 = *v132;
                  }
                  else
                  {
                    unint64_t v696 = 0;
                  }
                  uint64_t v682 = **(void **)(v131 + 24) + v682 - *(void *)(*(void *)(v131 + 24) + 8) * v696;
                  uint64_t v681 = *(void *)v241[3] + v681 - *((void *)v241[3] + 1) * v242[1];
                  ++v679;
                }
                while (v679 < v678);
              }
              break;
            default:
              if (v130[6])
              {
                unint64_t v631 = 0;
                unint64_t v1676 = v241[19];
                uint64_t v1691 = *(void *)(v131 + 152);
                uint64_t v632 = v130[19];
                do
                {
                  uint64_t v633 = *(void *)*v15;
                  unint64_t v634 = (unint64_t)(*(void *)(*v15 + 8) - v633) >> 2;
                  uint64_t v635 = 0;
                  uint64_t v636 = (v634 - 1);
                  if ((int)v634 - 1 >= 0)
                  {
                    uint64_t v637 = *(void *)(*v15 + 24);
                    int v638 = v631;
                    do
                    {
                      ldiv_t v639 = ldiv(v638, *(int *)(v633 + 4 * v636));
                      int v638 = v639.quot;
                      v635 += *(void *)(v637 + 8 * v636--) * v639.rem;
                    }
                    while (v636 != -1);
                  }
                  uint64_t v640 = *(void *)*v16;
                  unint64_t v641 = (unint64_t)(*(void *)(*v16 + 8) - v640) >> 2;
                  uint64_t v642 = 0;
                  uint64_t v643 = (v641 - 1);
                  if ((int)v641 - 1 >= 0)
                  {
                    uint64_t v644 = *(void *)(*v16 + 24);
                    int v645 = v631;
                    do
                    {
                      ldiv_t v646 = ldiv(v645, *(int *)(v640 + 4 * v643));
                      int v645 = v646.quot;
                      v642 += *(void *)(v644 + 8 * v643--) * v646.rem;
                    }
                    while (v643 != -1);
                  }
                  *(unsigned char *)(v632 + v631++) = *((unsigned char *)v1676 + (int)v642) | *(unsigned char *)(v1691 + (int)v635);
                }
                while (v631 < *(void *)(*(void *)v1 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 4:
      char v7 = *(uint64_t **)a1;
      BOOL v6 = *(uint64_t **)(a1 + 8);
      switch(v20)
      {
        case 0:
LABEL_12:
          **(_DWORD **)(*(void *)v1 + 152) = **(_DWORD **)(*v6 + 152) | **(_DWORD **)(*v7 + 152);
          return;
        case 1:
          int v167 = *(_DWORD *)(*v6 + 160);
          if (v167 >= 1)
          {
            int v168 = **(_DWORD **)(*v7 + 152);
            v169 = *(int **)(*(void *)v1 + 152);
            v170 = *(int **)(*v6 + 152);
            unsigned int v171 = v167 + 1;
            do
            {
              int v172 = *v170++;
              *v169++ = v172 | v168;
              --v171;
            }
            while (v171 > 1);
          }
          return;
        case 2:
          int v173 = *(_DWORD *)(*v7 + 160);
          if (v173 >= 1)
          {
            int v174 = **(_DWORD **)(*v6 + 152);
            int v175 = *(int **)(*(void *)v1 + 152);
            unsigned int v176 = *(int **)(*v7 + 152);
            unsigned int v177 = v173 + 1;
            do
            {
              int v178 = *v176++;
              *v175++ = v178 | v174;
              --v177;
            }
            while (v177 > 1);
          }
          return;
        case 3:
          int v179 = *(_DWORD *)(*(void *)v1 + 48);
          if (v179 >= 1)
          {
            v180 = *(int **)(*(void *)v1 + 152);
            unsigned int v181 = *(int **)(*v6 + 152);
            int v182 = *(int **)(*v7 + 152);
            unsigned int v183 = v179 + 1;
            do
            {
              int v185 = *v182++;
              int v184 = v185;
              int v186 = *v181++;
              *v180++ = v186 | v184;
              --v183;
            }
            while (v183 > 1);
          }
          return;
        default:
          unsigned int v158 = *(void **)v1;
          char v159 = (void *)*v7;
          int v160 = *(int **)*v7;
          uint64_t v161 = (v159[1] - (void)v160) >> 2;
          uint64_t v162 = (v161 - 1);
          if ((int)v162 >= -1) {
            int v163 = -1;
          }
          else {
            int v163 = v161 - 1;
          }
          int v164 = v163 + 1;
          int v165 = v161 + 1;
          break;
      }
      while (1)
      {
        unsigned int v166 = v165 - 2;
        if (v165 - 2 < 0) {
          break;
        }
        --v165;
        if (*(void *)(v159[3] + 8 * v166) != *(void *)(v158[3] + 8 * v166)) {
          goto LABEL_202;
        }
      }
      int v165 = v164;
LABEL_202:
      int v248 = (void *)*v6;
      int v249 = *(int **)*v6;
      uint64_t v250 = (v248[1] - (void)v249) >> 2;
      uint64_t v251 = (v250 - 1);
      if ((int)v251 >= -1) {
        int v252 = -1;
      }
      else {
        int v252 = v250 - 1;
      }
      int v253 = v252 + 1;
      int v254 = v250 + 1;
      while (1)
      {
        unsigned int v255 = v254 - 2;
        if (v254 - 2 < 0) {
          break;
        }
        --v254;
        if (*(void *)(v248[3] + 8 * v255) != *(void *)(v158[3] + 8 * v255)) {
          goto LABEL_233;
        }
      }
      int v254 = v253;
LABEL_233:
      int v270 = v161 + 1;
      while (1)
      {
        unsigned int v271 = v270 - 2;
        if (v270 - 2 < 0) {
          break;
        }
        --v270;
        if (*(void *)(v159[3] + 8 * v271)) {
          goto LABEL_258;
        }
      }
      int v270 = v164;
LABEL_258:
      int v280 = v250 + 1;
      while (1)
      {
        unsigned int v281 = v280 - 2;
        if (v280 - 2 < 0) {
          break;
        }
        --v280;
        if (*(void *)(v248[3] + 8 * v281)) {
          goto LABEL_337;
        }
      }
      int v280 = v253;
LABEL_337:
      unint64_t v317 = (uint64_t)(v158[1] - *v158) >> 2;
      if (v165 <= v254) {
        int v318 = v254;
      }
      else {
        int v318 = v165;
      }
      if (v165 <= v280) {
        int v165 = v280;
      }
      if (v270 > v254) {
        int v254 = v270;
      }
      if (v317 > v254)
      {
        int v319 = 1;
      }
      else
      {
        int v254 = (uint64_t)(v158[1] - *v158) >> 2;
        int v319 = 4;
      }
      if (v317 > v165)
      {
        int v320 = 2;
      }
      else
      {
        int v165 = v254;
        int v320 = v319;
      }
      if (v317 > v318)
      {
        int v165 = v318;
        int v320 = 3;
      }
      uint64_t v1672 = v251;
      uint64_t v1687 = v162;
      if (!v165) {
        goto LABEL_354;
      }
      unint64_t v321 = *(void *)(v158[3] + 8 * (v165 - 1));
      if (v321 < 0x10) {
        goto LABEL_354;
      }
      switch(v320)
      {
        case 1:
          if (v165 == 2)
          {
            int v1432 = *v160;
            if (*v160)
            {
              unint64_t v1433 = 0;
              uint64_t v1434 = 0;
              uint64_t v1435 = 0;
              uint64_t v1436 = v159[19];
              uint64_t v1437 = v248[19];
              uint64_t v1438 = v158[19];
              unint64_t v1439 = (uint64_t *)v159[3];
              uint64_t v1440 = *v1439;
              uint64_t v1441 = v1439[1];
              uint64_t v1442 = (uint64_t *)v248[3];
              uint64_t v1443 = *v1442;
              uint64_t v1444 = v1442[1];
              int v1445 = v160[1];
              int v1446 = v1445;
              do
              {
                if (v1446)
                {
                  unint64_t v1447 = 0;
                  uint64_t v1448 = v1437 + 4 * v1434;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1449 = 0;
                      int v1450 = *(_DWORD *)(v1436 + 4 * v1435);
                      unsigned int v1451 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1438 + v1449) = *(_DWORD *)(v1448 + v1449) | v1450;
                        --v1451;
                        v1449 += 4;
                      }
                      while (v1451 > 1);
                      int v1445 = v160[1];
                    }
                    v1435 += v1441;
                    v1434 += v1444;
                    v1438 += 4 * (int)v321;
                    ++v1447;
                    v1448 += 4 * v1444;
                  }
                  while (v1447 < v1445);
                  uint64_t v1452 = v1445;
                  int v1432 = *v160;
                  int v1446 = v1445;
                }
                else
                {
                  uint64_t v1452 = 0;
                }
                uint64_t v1435 = v1435 + v1440 - v1452 * v1441;
                uint64_t v1434 = v1434 + v1443 - v1444 * v249[1];
                ++v1433;
              }
              while (v1433 < v1432);
            }
          }
          else if (v165 == 1)
          {
            int v922 = *v160;
            if (*v160)
            {
              unint64_t v923 = 0;
              uint64_t v924 = 0;
              uint64_t v925 = v159[19];
              uint64_t v926 = v248[19];
              uint64_t v927 = v158[19];
              uint64_t v928 = *(void *)v159[3];
              uint64_t v929 = 4 * *(void *)v248[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v930 = 0;
                  int v931 = *(_DWORD *)(v925 + 4 * v924);
                  unsigned int v932 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v927 + v930) = *(_DWORD *)(v926 + v930) | v931;
                    --v932;
                    v930 += 4;
                  }
                  while (v932 > 1);
                  int v922 = *v160;
                }
                v924 += v928;
                ++v923;
                v927 += 4 * (int)v321;
                v926 += v929;
              }
              while (v923 < v922);
            }
          }
          else
          {
            unint64_t v1647 = v158[6];
            if (v1647)
            {
              unint64_t v1666 = 0;
              uint64_t v1589 = v248[19];
              uint64_t v1603 = v159[19];
              uint64_t v1453 = v158[19];
              do
              {
                uint64_t v1454 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1455 = v159[3];
                  uint64_t v1456 = v162;
                  int v1457 = v1666;
                  do
                  {
                    ldiv_t v1458 = ldiv(v1457, v160[v1456]);
                    int v1457 = v1458.quot;
                    v1454 += *(void *)(v1455 + 8 * v1456--) * v1458.rem;
                  }
                  while (v1456 != -1);
                }
                uint64_t v1459 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1460) = 0;
                }
                else
                {
                  uint64_t v1460 = 0;
                  uint64_t v1461 = v248[3];
                  int v1462 = v1666;
                  do
                  {
                    ldiv_t v1463 = ldiv(v1462, v249[v1459]);
                    int v1462 = v1463.quot;
                    v1460 += *(void *)(v1461 + 8 * v1459--) * v1463.rem;
                  }
                  while (v1459 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1464 = 0;
                  int v1465 = *(_DWORD *)(v1603 + 4 * (int)v1454);
                  unsigned int v1466 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1453 + v1464) = *(_DWORD *)(v1589 + 4 * (int)v1460 + v1464) | v1465;
                    --v1466;
                    v1464 += 4;
                  }
                  while (v1466 > 1);
                }
                v1453 += 4 * (int)v321;
                v1666 += (int)v321;
              }
              while (v1666 < v1647);
            }
          }
          break;
        case 2:
          if (v165 == 2)
          {
            int v1467 = *v160;
            if (*v160)
            {
              unint64_t v1468 = 0;
              uint64_t v1469 = 0;
              uint64_t v1470 = 0;
              uint64_t v1471 = v159[19];
              uint64_t v1472 = v248[19];
              uint64_t v1473 = v158[19];
              uint64_t v1474 = (uint64_t *)v159[3];
              uint64_t v1475 = *v1474;
              uint64_t v1476 = v1474[1];
              v1477 = (uint64_t *)v248[3];
              uint64_t v1478 = *v1477;
              uint64_t v1479 = v1477[1];
              int v1480 = v160[1];
              int v1481 = v1480;
              do
              {
                if (v1481)
                {
                  unint64_t v1482 = 0;
                  uint64_t v1483 = v1471 + 4 * v1470;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1484 = 0;
                      int v1485 = *(_DWORD *)(v1472 + 4 * v1469);
                      unsigned int v1486 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1473 + v1484) = *(_DWORD *)(v1483 + v1484) | v1485;
                        --v1486;
                        v1484 += 4;
                      }
                      while (v1486 > 1);
                      int v1480 = v160[1];
                    }
                    v1470 += v1476;
                    v1469 += v1479;
                    v1473 += 4 * (int)v321;
                    ++v1482;
                    v1483 += 4 * v1476;
                  }
                  while (v1482 < v1480);
                  uint64_t v1487 = v1480;
                  int v1467 = *v160;
                  int v1481 = v1480;
                }
                else
                {
                  uint64_t v1487 = 0;
                }
                uint64_t v1470 = v1470 + v1475 - v1487 * v1476;
                uint64_t v1469 = v1469 + v1478 - v1479 * v249[1];
                ++v1468;
              }
              while (v1468 < v1467);
            }
          }
          else if (v165 == 1)
          {
            int v933 = *v160;
            if (*v160)
            {
              unint64_t v934 = 0;
              uint64_t v935 = 0;
              uint64_t v936 = v159[19];
              uint64_t v937 = v248[19];
              uint64_t v938 = v158[19];
              uint64_t v939 = *(void *)v248[3];
              uint64_t v940 = 4 * *(void *)v159[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v941 = 0;
                  int v942 = *(_DWORD *)(v937 + 4 * v935);
                  unsigned int v943 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v938 + v941) = *(_DWORD *)(v936 + v941) | v942;
                    --v943;
                    v941 += 4;
                  }
                  while (v943 > 1);
                  int v933 = *v160;
                }
                v935 += v939;
                ++v934;
                v938 += 4 * (int)v321;
                v936 += v940;
              }
              while (v934 < v933);
            }
          }
          else
          {
            unint64_t v1648 = v158[6];
            if (v1648)
            {
              unint64_t v1667 = 0;
              uint64_t v1590 = v248[19];
              uint64_t v1604 = v159[19];
              uint64_t v1488 = v158[19];
              do
              {
                uint64_t v1489 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1490 = v159[3];
                  uint64_t v1491 = v162;
                  int v1492 = v1667;
                  do
                  {
                    ldiv_t v1493 = ldiv(v1492, v160[v1491]);
                    int v1492 = v1493.quot;
                    v1489 += *(void *)(v1490 + 8 * v1491--) * v1493.rem;
                  }
                  while (v1491 != -1);
                }
                uint64_t v1494 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1495) = 0;
                }
                else
                {
                  uint64_t v1495 = 0;
                  uint64_t v1496 = v248[3];
                  int v1497 = v1667;
                  do
                  {
                    ldiv_t v1498 = ldiv(v1497, v249[v1494]);
                    int v1497 = v1498.quot;
                    v1495 += *(void *)(v1496 + 8 * v1494--) * v1498.rem;
                  }
                  while (v1494 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1499 = 0;
                  int v1500 = *(_DWORD *)(v1590 + 4 * (int)v1495);
                  unsigned int v1501 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1488 + v1499) = *(_DWORD *)(v1604 + 4 * (int)v1489 + v1499) | v1500;
                    --v1501;
                    v1499 += 4;
                  }
                  while (v1501 > 1);
                }
                v1488 += 4 * (int)v321;
                v1667 += (int)v321;
              }
              while (v1667 < v1648);
            }
          }
          break;
        case 3:
          if (v165 == 2)
          {
            int v1159 = *v160;
            if (*v160)
            {
              unint64_t v1160 = 0;
              uint64_t v1161 = 0;
              uint64_t v1162 = 0;
              uint64_t v1163 = v159[19];
              uint64_t v1164 = v248[19];
              uint64_t v1165 = v158[19];
              unint64_t v1166 = (uint64_t *)v159[3];
              uint64_t v1167 = *v1166;
              uint64_t v1168 = v1166[1];
              v1169 = (uint64_t *)v248[3];
              uint64_t v1170 = *v1169;
              uint64_t v1171 = v1169[1];
              int v1172 = v160[1];
              int v1173 = v1172;
              do
              {
                if (v1173)
                {
                  unint64_t v1174 = 0;
                  uint64_t v1175 = v1164 + 4 * v1161;
                  uint64_t v1176 = v1163 + 4 * v1162;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1177 = 0;
                      unsigned int v1178 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1165 + v1177) = *(_DWORD *)(v1175 + v1177) | *(_DWORD *)(v1176 + v1177);
                        --v1178;
                        v1177 += 4;
                      }
                      while (v1178 > 1);
                      int v1172 = v160[1];
                    }
                    v1162 += v1168;
                    v1161 += v1171;
                    v1165 += 4 * (int)v321;
                    ++v1174;
                    v1175 += 4 * v1171;
                    v1176 += 4 * v1168;
                  }
                  while (v1174 < v1172);
                  uint64_t v1179 = v1172;
                  int v1159 = *v160;
                  int v1173 = v1172;
                }
                else
                {
                  uint64_t v1179 = 0;
                }
                uint64_t v1162 = v1162 + v1167 - v1179 * v1168;
                uint64_t v1161 = v1161 + v1170 - v1171 * v249[1];
                ++v1160;
              }
              while (v1160 < v1159);
            }
          }
          else if (v165 == 1)
          {
            int v366 = *v160;
            if (*v160)
            {
              unint64_t v367 = 0;
              uint64_t v368 = v159[19];
              uint64_t v369 = v248[19];
              uint64_t v370 = v158[19];
              uint64_t v371 = 4 * *(void *)v248[3];
              uint64_t v372 = 4 * *(void *)v159[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v373 = 0;
                  unsigned int v374 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v370 + v373) = *(_DWORD *)(v369 + v373) | *(_DWORD *)(v368 + v373);
                    --v374;
                    v373 += 4;
                  }
                  while (v374 > 1);
                  int v366 = *v160;
                }
                ++v367;
                v370 += 4 * (int)v321;
                v369 += v371;
                v368 += v372;
              }
              while (v367 < v366);
            }
          }
          else
          {
            unint64_t v1641 = v158[6];
            if (v1641)
            {
              unint64_t v1660 = 0;
              uint64_t v1583 = v248[19];
              uint64_t v1597 = v159[19];
              uint64_t v1180 = v158[19];
              do
              {
                uint64_t v1181 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1182 = v159[3];
                  uint64_t v1183 = v162;
                  int v1184 = v1660;
                  do
                  {
                    ldiv_t v1185 = ldiv(v1184, v160[v1183]);
                    int v1184 = v1185.quot;
                    v1181 += *(void *)(v1182 + 8 * v1183--) * v1185.rem;
                  }
                  while (v1183 != -1);
                }
                uint64_t v1186 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1187) = 0;
                }
                else
                {
                  uint64_t v1187 = 0;
                  uint64_t v1188 = v248[3];
                  int v1189 = v1660;
                  do
                  {
                    ldiv_t v1190 = ldiv(v1189, v249[v1186]);
                    int v1189 = v1190.quot;
                    v1187 += *(void *)(v1188 + 8 * v1186--) * v1190.rem;
                  }
                  while (v1186 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1191 = 0;
                  unsigned int v1192 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1180 + v1191) = *(_DWORD *)(v1583 + 4 * (int)v1187 + v1191) | *(_DWORD *)(v1597 + 4 * (int)v1181 + v1191);
                    --v1192;
                    v1191 += 4;
                  }
                  while (v1192 > 1);
                }
                v1180 += 4 * (int)v321;
                v1660 += (int)v321;
              }
              while (v1660 < v1641);
            }
          }
          break;
        default:
LABEL_354:
          switch(v317)
          {
            case 1uLL:
              uint64_t v322 = v158[6];
              if (v322)
              {
                unint64_t v323 = (_DWORD *)v159[19];
                uint64_t v324 = (_DWORD *)v248[19];
                uint64_t v325 = (int *)v158[19];
                uint64_t v326 = 4 * *(void *)v248[3];
                uint64_t v327 = 4 * *(void *)v159[3];
                do
                {
                  *v325++ = *v324 | *v323;
                  uint64_t v324 = (_DWORD *)((char *)v324 + v326);
                  unint64_t v323 = (_DWORD *)((char *)v323 + v327);
                  --v322;
                }
                while (v322);
              }
              break;
            case 2uLL:
              int v709 = *v160;
              if (*v160)
              {
                unint64_t v710 = 0;
                uint64_t v711 = 0;
                uint64_t v712 = 0;
                uint64_t v713 = 0;
                uint64_t v714 = v159[19];
                uint64_t v715 = v248[19];
                uint64_t v716 = v158[19];
                unint64_t v717 = (uint64_t *)v159[3];
                uint64_t v718 = *v717;
                uint64_t v719 = v717[1];
                uint64_t v720 = (uint64_t *)v248[3];
                uint64_t v722 = *v720;
                uint64_t v721 = v720[1];
                int v723 = v160[1];
                do
                {
                  if (v723)
                  {
                    for (unint64_t n = 0; n < v723; ++n)
                    {
                      *(_DWORD *)(v716 + 4 * v711 + 4 * n) = *(_DWORD *)(v715 + 4 * v712) | *(_DWORD *)(v714 + 4 * v713);
                      v713 += v719;
                      v712 += v721;
                      int v723 = v160[1];
                    }
                    uint64_t v725 = v723;
                    int v709 = *v160;
                    v711 += n;
                  }
                  else
                  {
                    uint64_t v725 = 0;
                  }
                  uint64_t v713 = v713 + v718 - v725 * v719;
                  uint64_t v712 = v712 + v722 - v721 * v249[1];
                  ++v710;
                }
                while (v710 < v709);
              }
              break;
            case 3uLL:
              int v726 = *v160;
              if (*v160)
              {
                unint64_t v727 = 0;
                uint64_t v728 = 0;
                uint64_t v729 = 0;
                uint64_t v730 = 0;
                uint64_t v731 = v159[19];
                uint64_t v732 = v248[19];
                uint64_t v733 = v158[19];
                uint64_t v734 = (uint64_t *)v159[3];
                uint64_t v735 = *v734;
                uint64_t v736 = v734[1];
                uint64_t v737 = (uint64_t *)v248[3];
                uint64_t v738 = *v737;
                uint64_t v739 = v737[1];
                int v740 = v160[1];
                int v741 = v740;
                do
                {
                  if (v741)
                  {
                    unint64_t v742 = 0;
                    uint64_t v743 = v734[2];
                    uint64_t v744 = v737[2];
                    int v745 = v160[2];
                    do
                    {
                      if (v745)
                      {
                        for (unint64_t ii = 0; ii < v745; ++ii)
                        {
                          *(_DWORD *)(v733 + 4 * v728 + 4 * ii) = *(_DWORD *)(v732 + 4 * v729) | *(_DWORD *)(v731 + 4 * v730);
                          v730 += v743;
                          v729 += v744;
                          int v745 = v160[2];
                        }
                        uint64_t v747 = v745;
                        int v740 = v160[1];
                        v728 += ii;
                      }
                      else
                      {
                        uint64_t v747 = 0;
                      }
                      uint64_t v730 = v730 + v736 - v747 * v743;
                      uint64_t v729 = v729 + v739 - v744 * v249[2];
                      ++v742;
                    }
                    while (v742 < v740);
                    uint64_t v748 = v740;
                    int v726 = *v160;
                    int v741 = v740;
                  }
                  else
                  {
                    uint64_t v748 = 0;
                  }
                  uint64_t v730 = v730 + v735 - v748 * v736;
                  uint64_t v729 = v729 + v738 - v739 * v249[1];
                  ++v727;
                }
                while (v727 < v726);
              }
              break;
            case 4uLL:
              int v749 = *v160;
              if (*v160)
              {
                unint64_t v750 = 0;
                uint64_t v751 = 0;
                uint64_t v752 = 0;
                uint64_t v753 = 0;
                uint64_t v754 = v159[19];
                uint64_t v755 = v248[19];
                uint64_t v756 = v158[19];
                uint64_t v757 = (uint64_t *)v159[3];
                uint64_t v758 = *v757;
                uint64_t v759 = v757[1];
                uint64_t v760 = (uint64_t *)v248[3];
                uint64_t v761 = *v760;
                uint64_t v762 = v760[1];
                int v763 = v160[1];
                int v764 = v763;
                do
                {
                  if (v764)
                  {
                    unint64_t v765 = 0;
                    uint64_t v766 = v757[2];
                    uint64_t v767 = v760[2];
                    int v768 = v160[2];
                    int v769 = v768;
                    do
                    {
                      if (v769)
                      {
                        unint64_t v770 = 0;
                        uint64_t v771 = v757[3];
                        uint64_t v772 = v760[3];
                        int v773 = v160[3];
                        do
                        {
                          if (v773)
                          {
                            for (junint64_t j = 0; jj < v773; ++jj)
                            {
                              *(_DWORD *)(v756 + 4 * v751 + 4 * jj) = *(_DWORD *)(v755 + 4 * v752) | *(_DWORD *)(v754 + 4 * v753);
                              v753 += v771;
                              v752 += v772;
                              int v773 = v160[3];
                            }
                            uint64_t v775 = v773;
                            int v768 = v160[2];
                            v751 += jj;
                          }
                          else
                          {
                            uint64_t v775 = 0;
                          }
                          uint64_t v753 = v753 + v766 - v775 * v771;
                          uint64_t v752 = v752 + v767 - v772 * v249[3];
                          ++v770;
                        }
                        while (v770 < v768);
                        uint64_t v776 = v768;
                        int v763 = v160[1];
                        int v769 = v768;
                      }
                      else
                      {
                        uint64_t v776 = 0;
                      }
                      uint64_t v753 = v753 + v759 - v776 * v766;
                      uint64_t v752 = v752 + v762 - v767 * v249[2];
                      ++v765;
                    }
                    while (v765 < v763);
                    uint64_t v777 = v763;
                    int v749 = *v160;
                    int v764 = v763;
                  }
                  else
                  {
                    uint64_t v777 = 0;
                  }
                  uint64_t v753 = v753 + v758 - v777 * v759;
                  uint64_t v752 = v752 + v761 - v762 * v249[1];
                  ++v750;
                }
                while (v750 < v749);
              }
              break;
            default:
              uint64_t v697 = v158[6];
              if (v697)
              {
                uint64_t v698 = 0;
                uint64_t v1633 = v248[19];
                uint64_t v1655 = v159[19];
                uint64_t v1619 = v158[19];
                do
                {
                  uint64_t v699 = 0;
                  if ((v162 & 0x80000000) == 0)
                  {
                    uint64_t v700 = v159[3];
                    uint64_t v701 = v162;
                    int v702 = v698;
                    do
                    {
                      ldiv_t v703 = ldiv(v702, v160[v701]);
                      int v702 = v703.quot;
                      v699 += *(void *)(v700 + 8 * v701--) * v703.rem;
                    }
                    while (v701 != -1);
                  }
                  uint64_t v704 = v1672;
                  if ((v1672 & 0x80000000) != 0)
                  {
                    LODWORD(v705) = 0;
                  }
                  else
                  {
                    uint64_t v705 = 0;
                    uint64_t v706 = v248[3];
                    int v707 = v698;
                    do
                    {
                      ldiv_t v708 = ldiv(v707, v249[v704]);
                      int v707 = v708.quot;
                      v705 += *(void *)(v706 + 8 * v704--) * v708.rem;
                    }
                    while (v704 != -1);
                  }
                  *(_DWORD *)(v1619 + 4 * v698++) = *(_DWORD *)(v1633 + 4 * (int)v705) | *(_DWORD *)(v1655 + 4 * (int)v699);
                  uint64_t v162 = v1687;
                }
                while (v698 != v697);
              }
              break;
          }
          break;
      }
      return;
    case 5:
      int v22 = *(uint64_t **)a1;
      uint64_t v21 = *(uint64_t **)(a1 + 8);
      switch(v23)
      {
        case 0:
          **(void **)(*(void *)v1 + 152) = **(void **)(*v21 + 152) | **(void **)(*v22 + 152);
          return;
        case 1:
          int v196 = *(_DWORD *)(*v21 + 160);
          if (v196 >= 1)
          {
            uint64_t v197 = **(void **)(*v22 + 152);
            v198 = *(uint64_t **)(*(void *)v1 + 152);
            v199 = *(uint64_t **)(*v21 + 152);
            unsigned int v200 = v196 + 1;
            do
            {
              uint64_t v201 = *v199++;
              *v198++ = v201 | v197;
              --v200;
            }
            while (v200 > 1);
          }
          return;
        case 2:
          int v202 = *(_DWORD *)(*v22 + 160);
          if (v202 >= 1)
          {
            uint64_t v203 = **(void **)(*v21 + 152);
            int v204 = *(uint64_t **)(*(void *)v1 + 152);
            unsigned int v205 = *(uint64_t **)(*v22 + 152);
            unsigned int v206 = v202 + 1;
            do
            {
              uint64_t v207 = *v205++;
              *v204++ = v207 | v203;
              --v206;
            }
            while (v206 > 1);
          }
          return;
        case 3:
          int v208 = *(_DWORD *)(*(void *)v1 + 48);
          if (v208 >= 1)
          {
            v209 = *(uint64_t **)(*(void *)v1 + 152);
            unsigned int v210 = *(uint64_t **)(*v21 + 152);
            uint64_t v211 = *(uint64_t **)(*v22 + 152);
            unsigned int v212 = v208 + 1;
            do
            {
              uint64_t v214 = *v211++;
              uint64_t v213 = v214;
              uint64_t v215 = *v210++;
              *v209++ = v215 | v213;
              --v212;
            }
            while (v212 > 1);
          }
          return;
        default:
          unsigned int v187 = *(void **)v1;
          int v188 = (void *)*v22;
          int v189 = *(int **)*v22;
          uint64_t v190 = (v188[1] - (void)v189) >> 2;
          uint64_t v191 = (v190 - 1);
          if ((int)v191 >= -1) {
            int v192 = -1;
          }
          else {
            int v192 = v190 - 1;
          }
          int v193 = v192 + 1;
          int v194 = v190 + 1;
          break;
      }
      break;
    default:
      exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x25A2B1470](exception, "[BitwiseBinary::eval_cpu] Type not supported");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  while (1)
  {
    unsigned int v195 = v194 - 2;
    if (v194 - 2 < 0) {
      break;
    }
    --v194;
    if (*(void *)(v188[3] + 8 * v195) != *(void *)(v187[3] + 8 * v195)) {
      goto LABEL_210;
    }
  }
  int v194 = v193;
LABEL_210:
  int v256 = (void *)*v21;
  unsigned int v257 = *(int **)*v21;
  uint64_t v258 = (v256[1] - (void)v257) >> 2;
  uint64_t v259 = (v258 - 1);
  if ((int)v259 >= -1) {
    int v260 = -1;
  }
  else {
    int v260 = v258 - 1;
  }
  int v261 = v260 + 1;
  int v262 = v258 + 1;
  while (1)
  {
    unsigned int v263 = v262 - 2;
    if (v262 - 2 < 0) {
      break;
    }
    --v262;
    if (*(void *)(v256[3] + 8 * v263) != *(void *)(v187[3] + 8 * v263)) {
      goto LABEL_238;
    }
  }
  int v262 = v261;
LABEL_238:
  int v272 = v190 + 1;
  while (1)
  {
    unsigned int v273 = v272 - 2;
    if (v272 - 2 < 0) {
      break;
    }
    --v272;
    if (*(void *)(v188[3] + 8 * v273)) {
      goto LABEL_263;
    }
  }
  int v272 = v193;
LABEL_263:
  int v282 = v258 + 1;
  while (1)
  {
    unsigned int v283 = v282 - 2;
    if (v282 - 2 < 0) {
      break;
    }
    --v282;
    if (*(void *)(v256[3] + 8 * v283)) {
      goto LABEL_360;
    }
  }
  int v282 = v261;
LABEL_360:
  unint64_t v328 = (uint64_t)(v187[1] - *v187) >> 2;
  if (v194 <= v262) {
    int v329 = v262;
  }
  else {
    int v329 = v194;
  }
  if (v194 <= v282) {
    int v194 = v282;
  }
  if (v272 > v262) {
    int v262 = v272;
  }
  if (v328 > v262)
  {
    int v330 = 1;
  }
  else
  {
    int v262 = (uint64_t)(v187[1] - *v187) >> 2;
    int v330 = 4;
  }
  if (v328 > v194)
  {
    int v331 = 2;
  }
  else
  {
    int v194 = v262;
    int v331 = v330;
  }
  if (v328 > v329)
  {
    int v194 = v329;
    int v331 = 3;
  }
  uint64_t v1673 = v259;
  uint64_t v1688 = v191;
  if (!v194) {
    goto LABEL_377;
  }
  unint64_t v332 = *(void *)(v187[3] + 8 * (v194 - 1));
  if (v332 < 0x10) {
    goto LABEL_377;
  }
  switch(v331)
  {
    case 1:
      if (v194 == 2)
      {
        uint64_t v1502 = *v189;
        if (v1502)
        {
          uint64_t v1503 = 0;
          uint64_t v1504 = 0;
          uint64_t v1505 = 0;
          uint64_t v1506 = v188[19];
          uint64_t v1507 = v256[19];
          uint64_t v1508 = v187[19];
          unint64_t v1509 = v189[1];
          uint64_t v1510 = (uint64_t *)v188[3];
          uint64_t v1511 = *v1510;
          uint64_t v1512 = v1510[1];
          uint64_t v1513 = (uint64_t *)v256[3];
          uint64_t v1514 = *v1513;
          uint64_t v1515 = v1513[1];
          if (v1509 <= 1) {
            uint64_t v1516 = 1;
          }
          else {
            uint64_t v1516 = v189[1];
          }
          uint64_t v1517 = v1511 - v1512 * v1509;
          uint64_t v1518 = v1514 - v1515 * v257[1];
          do
          {
            if (v1509)
            {
              uint64_t v1519 = 0;
              uint64_t v1520 = v1507 + 8 * v1504;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1521 = 0;
                  uint64_t v1522 = *(void *)(v1506 + 8 * v1505);
                  unsigned int v1523 = v332 + 1;
                  do
                  {
                    *(void *)(v1508 + v1521) = *(void *)(v1520 + v1521) | v1522;
                    --v1523;
                    v1521 += 8;
                  }
                  while (v1523 > 1);
                }
                v1505 += v1512;
                v1504 += v1515;
                v1508 += 8 * (int)v332;
                ++v1519;
                v1520 += 8 * v1515;
              }
              while (v1519 != v1516);
            }
            v1505 += v1517;
            v1504 += v1518;
            ++v1503;
          }
          while (v1503 != v1502);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v944 = *v189;
        if (v944)
        {
          uint64_t v945 = 0;
          uint64_t v946 = 0;
          uint64_t v947 = v188[19];
          uint64_t v948 = v256[19];
          uint64_t v949 = v187[19];
          uint64_t v950 = *(void *)v188[3];
          uint64_t v951 = 8 * *(void *)v256[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v952 = 0;
              uint64_t v953 = *(void *)(v947 + 8 * v946);
              unsigned int v954 = v332 + 1;
              do
              {
                *(void *)(v949 + v952) = *(void *)(v948 + v952) | v953;
                --v954;
                v952 += 8;
              }
              while (v954 > 1);
            }
            v946 += v950;
            ++v945;
            v949 += 8 * (int)v332;
            v948 += v951;
          }
          while (v945 != v944);
        }
      }
      else
      {
        unint64_t v1649 = v187[6];
        if (v1649)
        {
          unint64_t v1668 = 0;
          uint64_t v1591 = v256[19];
          uint64_t v1605 = v188[19];
          uint64_t v1524 = v187[19];
          do
          {
            uint64_t v1525 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1526 = v188[3];
              uint64_t v1527 = v191;
              int v1528 = v1668;
              do
              {
                ldiv_t v1529 = ldiv(v1528, v189[v1527]);
                int v1528 = v1529.quot;
                v1525 += *(void *)(v1526 + 8 * v1527--) * v1529.rem;
              }
              while (v1527 != -1);
            }
            uint64_t v1530 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1531) = 0;
            }
            else
            {
              uint64_t v1531 = 0;
              uint64_t v1532 = v256[3];
              int v1533 = v1668;
              do
              {
                ldiv_t v1534 = ldiv(v1533, v257[v1530]);
                int v1533 = v1534.quot;
                v1531 += *(void *)(v1532 + 8 * v1530--) * v1534.rem;
              }
              while (v1530 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1535 = 0;
              uint64_t v1536 = *(void *)(v1605 + 8 * (int)v1525);
              unsigned int v1537 = v332 + 1;
              do
              {
                *(void *)(v1524 + v1535) = *(void *)(v1591 + 8 * (int)v1531 + v1535) | v1536;
                --v1537;
                v1535 += 8;
              }
              while (v1537 > 1);
            }
            v1524 += 8 * (int)v332;
            v1668 += (int)v332;
          }
          while (v1668 < v1649);
        }
      }
      break;
    case 2:
      if (v194 == 2)
      {
        uint64_t v1538 = *v189;
        if (v1538)
        {
          uint64_t v1539 = 0;
          uint64_t v1540 = 0;
          uint64_t v1541 = 0;
          uint64_t v1542 = v188[19];
          uint64_t v1543 = v256[19];
          uint64_t v1544 = v187[19];
          unint64_t v1545 = v189[1];
          uint64_t v1546 = (uint64_t *)v188[3];
          uint64_t v1547 = *v1546;
          uint64_t v1548 = v1546[1];
          uint64_t v1549 = (uint64_t *)v256[3];
          uint64_t v1550 = *v1549;
          uint64_t v1551 = v1549[1];
          if (v1545 <= 1) {
            uint64_t v1552 = 1;
          }
          else {
            uint64_t v1552 = v189[1];
          }
          uint64_t v1553 = v1547 - v1548 * v1545;
          uint64_t v1554 = v1550 - v1551 * v257[1];
          do
          {
            if (v1545)
            {
              uint64_t v1555 = 0;
              uint64_t v1556 = v1542 + 8 * v1541;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1557 = 0;
                  uint64_t v1558 = *(void *)(v1543 + 8 * v1540);
                  unsigned int v1559 = v332 + 1;
                  do
                  {
                    *(void *)(v1544 + v1557) = *(void *)(v1556 + v1557) | v1558;
                    --v1559;
                    v1557 += 8;
                  }
                  while (v1559 > 1);
                }
                v1541 += v1548;
                v1540 += v1551;
                v1544 += 8 * (int)v332;
                ++v1555;
                v1556 += 8 * v1548;
              }
              while (v1555 != v1552);
            }
            v1541 += v1553;
            v1540 += v1554;
            ++v1539;
          }
          while (v1539 != v1538);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v955 = *v189;
        if (v955)
        {
          uint64_t v956 = 0;
          uint64_t v957 = 0;
          uint64_t v958 = v188[19];
          uint64_t v959 = v256[19];
          uint64_t v960 = v187[19];
          uint64_t v961 = *(void *)v256[3];
          uint64_t v962 = 8 * *(void *)v188[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v963 = 0;
              uint64_t v964 = *(void *)(v959 + 8 * v957);
              unsigned int v965 = v332 + 1;
              do
              {
                *(void *)(v960 + v963) = *(void *)(v958 + v963) | v964;
                --v965;
                v963 += 8;
              }
              while (v965 > 1);
            }
            v957 += v961;
            ++v956;
            v960 += 8 * (int)v332;
            v958 += v962;
          }
          while (v956 != v955);
        }
      }
      else
      {
        unint64_t v1650 = v187[6];
        if (v1650)
        {
          unint64_t v1669 = 0;
          uint64_t v1592 = v256[19];
          uint64_t v1606 = v188[19];
          uint64_t v1560 = v187[19];
          do
          {
            uint64_t v1561 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1562 = v188[3];
              uint64_t v1563 = v191;
              int v1564 = v1669;
              do
              {
                ldiv_t v1565 = ldiv(v1564, v189[v1563]);
                int v1564 = v1565.quot;
                v1561 += *(void *)(v1562 + 8 * v1563--) * v1565.rem;
              }
              while (v1563 != -1);
            }
            uint64_t v1566 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1567) = 0;
            }
            else
            {
              uint64_t v1567 = 0;
              uint64_t v1568 = v256[3];
              int v1569 = v1669;
              do
              {
                ldiv_t v1570 = ldiv(v1569, v257[v1566]);
                int v1569 = v1570.quot;
                v1567 += *(void *)(v1568 + 8 * v1566--) * v1570.rem;
              }
              while (v1566 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1571 = 0;
              uint64_t v1572 = *(void *)(v1592 + 8 * (int)v1567);
              unsigned int v1573 = v332 + 1;
              do
              {
                *(void *)(v1560 + v1571) = *(void *)(v1606 + 8 * (int)v1561 + v1571) | v1572;
                --v1573;
                v1571 += 8;
              }
              while (v1573 > 1);
            }
            v1560 += 8 * (int)v332;
            v1669 += (int)v332;
          }
          while (v1669 < v1650);
        }
      }
      break;
    case 3:
      if (v194 == 2)
      {
        uint64_t v1193 = *v189;
        if (v1193)
        {
          uint64_t v1194 = 0;
          uint64_t v1195 = 0;
          uint64_t v1196 = 0;
          uint64_t v1197 = v188[19];
          uint64_t v1198 = v256[19];
          uint64_t v1199 = v187[19];
          unint64_t v1200 = v189[1];
          uint64_t v1201 = (uint64_t *)v188[3];
          uint64_t v1202 = *v1201;
          uint64_t v1203 = v1201[1];
          unint64_t v1204 = (uint64_t *)v256[3];
          uint64_t v1205 = *v1204;
          uint64_t v1206 = v1204[1];
          if (v1200 <= 1) {
            uint64_t v1207 = 1;
          }
          else {
            uint64_t v1207 = v189[1];
          }
          uint64_t v1208 = v1202 - v1203 * v1200;
          uint64_t v1209 = v1205 - v1206 * v257[1];
          do
          {
            if (v1200)
            {
              uint64_t v1210 = 0;
              uint64_t v1211 = v1198 + 8 * v1195;
              uint64_t v1212 = v1197 + 8 * v1196;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1213 = 0;
                  unsigned int v1214 = v332 + 1;
                  do
                  {
                    *(void *)(v1199 + v1213) = *(void *)(v1211 + v1213) | *(void *)(v1212 + v1213);
                    --v1214;
                    v1213 += 8;
                  }
                  while (v1214 > 1);
                }
                v1196 += v1203;
                v1195 += v1206;
                v1199 += 8 * (int)v332;
                ++v1210;
                v1211 += 8 * v1206;
                v1212 += 8 * v1203;
              }
              while (v1210 != v1207);
            }
            v1196 += v1208;
            v1195 += v1209;
            ++v1194;
          }
          while (v1194 != v1193);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v375 = *v189;
        if (v375)
        {
          uint64_t v376 = 0;
          uint64_t v377 = v188[19];
          uint64_t v378 = v256[19];
          uint64_t v379 = v187[19];
          uint64_t v380 = 8 * *(void *)v256[3];
          uint64_t v381 = 8 * *(void *)v188[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v382 = 0;
              unsigned int v383 = v332 + 1;
              do
              {
                *(void *)(v379 + v382) = *(void *)(v378 + v382) | *(void *)(v377 + v382);
                --v383;
                v382 += 8;
              }
              while (v383 > 1);
            }
            ++v376;
            v379 += 8 * (int)v332;
            v378 += v380;
            v377 += v381;
          }
          while (v376 != v375);
        }
      }
      else
      {
        unint64_t v1642 = v187[6];
        if (v1642)
        {
          unint64_t v1661 = 0;
          uint64_t v1584 = v256[19];
          uint64_t v1598 = v188[19];
          uint64_t v1215 = v187[19];
          do
          {
            uint64_t v1216 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1217 = v188[3];
              uint64_t v1218 = v191;
              int v1219 = v1661;
              do
              {
                ldiv_t v1220 = ldiv(v1219, v189[v1218]);
                int v1219 = v1220.quot;
                v1216 += *(void *)(v1217 + 8 * v1218--) * v1220.rem;
              }
              while (v1218 != -1);
            }
            uint64_t v1221 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1222) = 0;
            }
            else
            {
              uint64_t v1222 = 0;
              uint64_t v1223 = v256[3];
              int v1224 = v1661;
              do
              {
                ldiv_t v1225 = ldiv(v1224, v257[v1221]);
                int v1224 = v1225.quot;
                v1222 += *(void *)(v1223 + 8 * v1221--) * v1225.rem;
              }
              while (v1221 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1226 = 0;
              unsigned int v1227 = v332 + 1;
              do
              {
                *(void *)(v1215 + v1226) = *(void *)(v1584 + 8 * (int)v1222 + v1226) | *(void *)(v1598 + 8 * (int)v1216 + v1226);
                --v1227;
                v1226 += 8;
              }
              while (v1227 > 1);
            }
            v1215 += 8 * (int)v332;
            v1661 += (int)v332;
          }
          while (v1661 < v1642);
        }
      }
      break;
    default:
LABEL_377:
      switch(v328)
      {
        case 1uLL:
          uint64_t v333 = v187[6];
          if (v333)
          {
            uint64_t v334 = (void *)v188[19];
            v335 = (void *)v256[19];
            v336 = (void *)v187[19];
            uint64_t v337 = 8 * *(void *)v256[3];
            uint64_t v338 = 8 * *(void *)v188[3];
            do
            {
              *v336++ = *v335 | *v334;
              v335 = (void *)((char *)v335 + v337);
              uint64_t v334 = (void *)((char *)v334 + v338);
              --v333;
            }
            while (v333);
          }
          break;
        case 2uLL:
          uint64_t v790 = *v189;
          if (v790)
          {
            uint64_t v791 = 0;
            uint64_t v792 = 0;
            uint64_t v793 = 0;
            uint64_t v794 = 0;
            uint64_t v795 = v188[19];
            uint64_t v796 = v256[19];
            uint64_t v797 = v187[19];
            unint64_t v798 = v189[1];
            uint64_t v799 = (uint64_t *)v188[3];
            uint64_t v800 = *v799;
            uint64_t v801 = v799[1];
            uint64_t v802 = (uint64_t *)v256[3];
            uint64_t v803 = *v802;
            uint64_t v804 = v802[1];
            uint64_t v805 = v803 - v804 * v257[1];
            if (v798 <= 1) {
              uint64_t v806 = 1;
            }
            else {
              uint64_t v806 = v189[1];
            }
            uint64_t v807 = v800 - v801 * v798;
            do
            {
              if (v798)
              {
                uint64_t v808 = v792 + v806;
                uint64_t v809 = (void *)(v797 + 8 * v792);
                uint64_t v810 = v806;
                do
                {
                  *v809++ = *(void *)(v796 + 8 * v793) | *(void *)(v795 + 8 * v794);
                  v794 += v801;
                  v793 += v804;
                  --v810;
                }
                while (v810);
                uint64_t v792 = v808;
              }
              v794 += v807;
              v793 += v805;
              ++v791;
            }
            while (v791 != v790);
          }
          break;
        case 3uLL:
          uint64_t v811 = *v189;
          if (v811)
          {
            uint64_t v812 = 0;
            uint64_t v813 = 0;
            uint64_t v814 = 0;
            uint64_t v815 = 0;
            uint64_t v816 = v188[19];
            uint64_t v817 = v256[19];
            uint64_t v818 = v187[19];
            unint64_t v819 = v189[1];
            unint64_t v820 = (void *)v188[3];
            uint64_t v821 = v820[1];
            uint64_t v822 = (void *)v256[3];
            uint64_t v823 = v822[1];
            uint64_t v824 = *v822 - v823 * v257[1];
            if (v819 <= 1) {
              uint64_t v825 = 1;
            }
            else {
              uint64_t v825 = v189[1];
            }
            unint64_t v826 = *v820 - v821 * v819;
            do
            {
              if (v819)
              {
                uint64_t v827 = 0;
                unint64_t v828 = v189[2];
                uint64_t v829 = v820[2];
                uint64_t v830 = v822[2];
                if (v828 <= 1) {
                  uint64_t v831 = 1;
                }
                else {
                  uint64_t v831 = v189[2];
                }
                uint64_t v832 = v823 - v830 * v257[2];
                do
                {
                  uint64_t v833 = v831;
                  if (v828)
                  {
                    do
                    {
                      *(void *)(v818 + 8 * v813++) = *(void *)(v817 + 8 * v814) | *(void *)(v816 + 8 * v815);
                      v815 += v829;
                      v814 += v830;
                      --v833;
                    }
                    while (v833);
                  }
                  v815 += v821 - v829 * v828;
                  v814 += v832;
                  ++v827;
                }
                while (v827 != v825);
              }
              v815 += v826;
              v814 += v824;
              ++v812;
            }
            while (v812 != v811);
          }
          break;
        case 4uLL:
          uint64_t v1692 = *v189;
          if (v1692)
          {
            uint64_t v834 = 0;
            uint64_t v835 = 0;
            uint64_t v836 = 0;
            uint64_t v837 = 0;
            uint64_t v838 = v188[19];
            uint64_t v839 = v256[19];
            uint64_t v840 = v187[19];
            unint64_t v841 = v189[1];
            v842 = (void *)v188[3];
            uint64_t v843 = (void *)v256[3];
            uint64_t v1609 = v843[1];
            uint64_t v1621 = v842[1];
            uint64_t v1657 = *v843 - v1609 * v257[1];
            int v1677 = v189[1];
            if (v841 <= 1) {
              uint64_t v844 = 1;
            }
            else {
              uint64_t v844 = v189[1];
            }
            unint64_t v1635 = *v842 - v842[1] * v841;
            do
            {
              if (v1677)
              {
                uint64_t v845 = 0;
                unint64_t v846 = v189[2];
                uint64_t v847 = v842[2];
                uint64_t v848 = v843[2];
                if (v846 <= 1) {
                  uint64_t v849 = 1;
                }
                else {
                  uint64_t v849 = v189[2];
                }
                uint64_t v850 = v1609 - v848 * v257[2];
                do
                {
                  if (v846)
                  {
                    uint64_t v851 = 0;
                    unint64_t v852 = v189[3];
                    uint64_t v853 = v842[3];
                    uint64_t v854 = v843[3];
                    if (v852 <= 1) {
                      uint64_t v855 = 1;
                    }
                    else {
                      uint64_t v855 = v189[3];
                    }
                    uint64_t v856 = v848 - v854 * v257[3];
                    do
                    {
                      uint64_t v857 = v855;
                      if (v852)
                      {
                        do
                        {
                          *(void *)(v840 + 8 * v835++) = *(void *)(v839 + 8 * v836) | *(void *)(v838 + 8 * v837);
                          v837 += v853;
                          v836 += v854;
                          --v857;
                        }
                        while (v857);
                      }
                      v837 += v847 - v853 * v852;
                      v836 += v856;
                      ++v851;
                    }
                    while (v851 != v849);
                  }
                  v837 += v1621 - v847 * v846;
                  v836 += v850;
                  ++v845;
                }
                while (v845 != v844);
              }
              v837 += v1635;
              v836 += v1657;
              ++v834;
            }
            while (v834 != v1692);
          }
          break;
        default:
          uint64_t v778 = v187[6];
          if (v778)
          {
            uint64_t v779 = 0;
            uint64_t v1634 = v256[19];
            uint64_t v1656 = v188[19];
            uint64_t v1620 = v187[19];
            do
            {
              uint64_t v780 = 0;
              if ((v191 & 0x80000000) == 0)
              {
                uint64_t v781 = v188[3];
                uint64_t v782 = v191;
                int v783 = v779;
                do
                {
                  ldiv_t v784 = ldiv(v783, v189[v782]);
                  int v783 = v784.quot;
                  v780 += *(void *)(v781 + 8 * v782--) * v784.rem;
                }
                while (v782 != -1);
              }
              uint64_t v785 = v1673;
              if ((v1673 & 0x80000000) != 0)
              {
                LODWORD(v786) = 0;
              }
              else
              {
                uint64_t v786 = 0;
                uint64_t v787 = v256[3];
                int v788 = v779;
                do
                {
                  ldiv_t v789 = ldiv(v788, v257[v785]);
                  int v788 = v789.quot;
                  v786 += *(void *)(v787 + 8 * v785--) * v789.rem;
                }
                while (v785 != -1);
              }
              *(void *)(v1620 + 8 * v779++) = *(void *)(v1634 + 8 * (int)v786) | *(void *)(v1656
                                                                                                 + 8 * (int)v780);
              uint64_t v191 = v1688;
            }
            while (v779 != v778);
          }
          break;
      }
      return;
  }
}

void sub_256E5A704(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::BitwiseXor>(uint64_t a1)
{
  v1 = *(mlx::core::array **)(a1 + 16);
  uint64_t v2 = a1;
  switch(*(_DWORD *)(*(void *)v1 + 56))
  {
    case 0:
      v4 = *(uint64_t **)a1;
      v3 = *(uint64_t **)(a1 + 8);
      switch(binary_op_type)
      {
        case 0:
          **(unsigned char **)(*(void *)v1 + 152) = (**(unsigned char **)(*v4 + 152) != 0) ^ (**(unsigned char **)(*v3 + 152) != 0);
          goto LABEL_33;
        case 1:
          int v33 = *(_DWORD *)(*v3 + 160);
          if (v33 >= 1)
          {
            int v34 = **(unsigned __int8 **)(*v4 + 152);
            int v35 = *(unsigned char **)(*(void *)v1 + 152);
            int v36 = *(unsigned __int8 **)(*v3 + 152);
            unsigned int v37 = v33 + 1;
            do
            {
              int v38 = *v36++;
              *v35++ = (v34 != 0) ^ (v38 != 0);
              --v37;
            }
            while (v37 > 1);
          }
          goto LABEL_33;
        case 2:
          int v39 = *(_DWORD *)(*v4 + 160);
          if (v39 >= 1)
          {
            int v40 = **(unsigned __int8 **)(*v3 + 152);
            int v41 = *(unsigned char **)(*(void *)v1 + 152);
            BOOL v42 = *(unsigned __int8 **)(*v4 + 152);
            unsigned int v43 = v39 + 1;
            do
            {
              int v44 = *v42++;
              *v41++ = (v40 != 0) ^ (v44 != 0);
              --v43;
            }
            while (v43 > 1);
          }
          goto LABEL_33;
        case 3:
          int v45 = *(_DWORD *)(*(void *)v1 + 48);
          if (v45 >= 1)
          {
            v46 = *(unsigned char **)(*(void *)v1 + 152);
            v47 = *(unsigned __int8 **)(*v3 + 152);
            unsigned int v48 = *(unsigned __int8 **)(*v4 + 152);
            unsigned int v49 = v45 + 1;
            do
            {
              int v50 = *v48++;
              BOOL v51 = v50 != 0;
              int v52 = *v47++;
              *v46++ = v51 ^ (v52 != 0);
              --v49;
            }
            while (v49 > 1);
          }
          goto LABEL_33;
        default:
          v24 = *(void **)v1;
          int v25 = (void *)*v4;
          v26 = *(int **)*v4;
          uint64_t v27 = (v25[1] - (void)v26) >> 2;
          uint64_t v28 = (v27 - 1);
          if ((int)v28 >= -1) {
            int v29 = -1;
          }
          else {
            int v29 = v27 - 1;
          }
          int v30 = v29 + 1;
          int v31 = v27 + 1;
          break;
      }
      while (1)
      {
        unsigned int v32 = v31 - 2;
        if (v31 - 2 < 0) {
          break;
        }
        --v31;
        if (*(void *)(v25[3] + 8 * v32) != *(void *)(v24[3] + 8 * v32)) {
          goto LABEL_179;
        }
      }
      int v31 = v30;
LABEL_179:
      uint64_t v225 = (void *)*v3;
      int v226 = *(int **)*v3;
      uint64_t v227 = (v225[1] - (void)v226) >> 2;
      uint64_t v228 = (v227 - 1);
      if ((int)v228 >= -1) {
        int v229 = -1;
      }
      else {
        int v229 = v227 - 1;
      }
      int v230 = v229 + 1;
      int v231 = v227 + 1;
      while (1)
      {
        unsigned int v232 = v231 - 2;
        if (v231 - 2 < 0) {
          break;
        }
        --v231;
        if (*(void *)(v225[3] + 8 * v232) != *(void *)(v24[3] + 8 * v232)) {
          goto LABEL_218;
        }
      }
      int v231 = v230;
LABEL_218:
      int v264 = v27 + 1;
      while (1)
      {
        unsigned int v265 = v264 - 2;
        if (v264 - 2 < 0) {
          break;
        }
        --v264;
        if (*(void *)(v25[3] + 8 * v265)) {
          goto LABEL_243;
        }
      }
      int v264 = v30;
LABEL_243:
      int v274 = v227 + 1;
      while (1)
      {
        unsigned int v275 = v274 - 2;
        if (v274 - 2 < 0) {
          break;
        }
        --v274;
        if (*(void *)(v225[3] + 8 * v275)) {
          goto LABEL_268;
        }
      }
      int v274 = v230;
LABEL_268:
      unint64_t v284 = (uint64_t)(v24[1] - *v24) >> 2;
      if (v31 <= v231) {
        int v285 = v231;
      }
      else {
        int v285 = v31;
      }
      if (v31 <= v274) {
        int v31 = v274;
      }
      if (v264 > v231) {
        int v231 = v264;
      }
      if (v284 > v231)
      {
        int v286 = 1;
      }
      else
      {
        int v231 = (uint64_t)(v24[1] - *v24) >> 2;
        int v286 = 4;
      }
      if (v284 > v31)
      {
        int v287 = 2;
      }
      else
      {
        int v31 = v231;
        int v287 = v286;
      }
      if (v284 > v285)
      {
        int v31 = v285;
        int v287 = 3;
      }
      uint64_t v1670 = v228;
      uint64_t v1685 = v28;
      if (!v31) {
        goto LABEL_285;
      }
      unint64_t v288 = *(void *)(v24[3] + 8 * (v31 - 1));
      if (v288 < 0x10) {
        goto LABEL_285;
      }
      uint64_t v1651 = *(void *)(v24[3] + 8 * (v31 - 1));
      switch(v287)
      {
        case 1:
          if (v31 == 2)
          {
            uint64_t v1228 = *v26;
            if (v1228)
            {
              uint64_t v1229 = 0;
              uint64_t v1230 = 0;
              uint64_t v1231 = 0;
              uint64_t v1232 = v25[19];
              uint64_t v1233 = v225[19];
              uint64_t v1234 = v24[19];
              unint64_t v1235 = v26[1];
              uint64_t v1236 = (uint64_t *)v25[3];
              uint64_t v1237 = *v1236;
              uint64_t v1238 = v1236[1];
              uint64_t v1239 = (uint64_t *)v225[3];
              uint64_t v1241 = *v1239;
              uint64_t v1240 = v1239[1];
              if (v1235 <= 1) {
                uint64_t v1242 = 1;
              }
              else {
                uint64_t v1242 = v26[1];
              }
              uint64_t v1243 = v1237 - v1238 * v1235;
              uint64_t v1244 = v1241 - v1240 * v226[1];
              do
              {
                if (v1235)
                {
                  uint64_t v1245 = 0;
                  uint64_t v1246 = v1233 + v1230;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1247 = 0;
                      int v1248 = *(unsigned __int8 *)(v1232 + v1231);
                      unsigned int v1249 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1234 + v1247) = (v1248 != 0) ^ (*(unsigned char *)(v1246 + v1247) != 0);
                        --v1249;
                        ++v1247;
                      }
                      while (v1249 > 1);
                    }
                    v1231 += v1238;
                    v1230 += v1240;
                    v1234 += (int)v288;
                    ++v1245;
                    v1246 += v1240;
                  }
                  while (v1245 != v1242);
                }
                v1231 += v1243;
                v1230 += v1244;
                ++v1229;
              }
              while (v1229 != v1228);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v858 = *v26;
            if (v858)
            {
              uint64_t v859 = 0;
              uint64_t v860 = 0;
              uint64_t v861 = v25[19];
              uint64_t v862 = v225[19];
              uint64_t v863 = v24[19];
              uint64_t v864 = *(void *)v25[3];
              uint64_t v865 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v866 = 0;
                  int v867 = *(unsigned __int8 *)(v861 + v860);
                  unsigned int v868 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v863 + v866) = (v867 != 0) ^ (*(unsigned char *)(v862 + v866) != 0);
                    --v868;
                    ++v866;
                  }
                  while (v868 > 1);
                }
                v860 += v864;
                v863 += (int)v288;
                ++v859;
                v862 += v865;
              }
              while (v859 != v858);
            }
          }
          else
          {
            unint64_t v1612 = v24[6];
            if (v1612)
            {
              uint64_t v1250 = 0;
              uint64_t v1579 = v225[19];
              uint64_t v1585 = v25[19];
              uint64_t v1599 = (int)v288;
              unsigned int v1576 = v288 + 1;
              uint64_t v1251 = v24[19];
              do
              {
                uint64_t v1627 = v1250;
                uint64_t v1252 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1253 = v25[3];
                  do
                  {
                    ldiv_t v1254 = ldiv((int)v1250, v26[v28]);
                    LODWORD(v1250) = v1254.quot;
                    v1252 += *(void *)(v1253 + 8 * v28--) * v1254.rem;
                  }
                  while (v28 != -1);
                }
                uint64_t v1255 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1256) = 0;
                }
                else
                {
                  uint64_t v1256 = 0;
                  uint64_t v1257 = v225[3];
                  int quot = v1627;
                  do
                  {
                    ldiv_t v1259 = ldiv(quot, v226[v1255]);
                    int quot = v1259.quot;
                    v1256 += *(void *)(v1257 + 8 * v1255--) * v1259.rem;
                  }
                  while (v1255 != -1);
                }
                if ((int)v1651 >= 1)
                {
                  uint64_t v1260 = 0;
                  int v1261 = *(unsigned __int8 *)(v1585 + (int)v1252);
                  unsigned int v1262 = v1576;
                  do
                  {
                    *(unsigned char *)(v1251 + v1260) = (v1261 != 0) ^ (*(unsigned char *)(v1579 + (int)v1256 + v1260) != 0);
                    --v1262;
                    ++v1260;
                  }
                  while (v1262 > 1);
                }
                v1251 += v1599;
                uint64_t v1250 = v1627 + v1599;
                uint64_t v28 = v1685;
              }
              while (v1627 + v1599 < v1612);
            }
          }
          break;
        case 2:
          if (v31 == 2)
          {
            uint64_t v1263 = *v26;
            if (v1263)
            {
              uint64_t v1264 = 0;
              uint64_t v1265 = 0;
              uint64_t v1266 = 0;
              uint64_t v1267 = v25[19];
              uint64_t v1268 = v225[19];
              uint64_t v1269 = v24[19];
              unint64_t v1270 = v26[1];
              uint64_t v1271 = (uint64_t *)v25[3];
              uint64_t v1272 = *v1271;
              uint64_t v1273 = v1271[1];
              uint64_t v1274 = (uint64_t *)v225[3];
              uint64_t v1276 = *v1274;
              uint64_t v1275 = v1274[1];
              if (v1270 <= 1) {
                uint64_t v1277 = 1;
              }
              else {
                uint64_t v1277 = v26[1];
              }
              uint64_t v1278 = v1272 - v1273 * v1270;
              uint64_t v1279 = v1276 - v1275 * v226[1];
              do
              {
                if (v1270)
                {
                  uint64_t v1280 = 0;
                  uint64_t v1281 = v1267 + v1266;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1282 = 0;
                      int v1283 = *(unsigned __int8 *)(v1268 + v1265);
                      unsigned int v1284 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1269 + v1282) = (v1283 != 0) ^ (*(unsigned char *)(v1281 + v1282) != 0);
                        --v1284;
                        ++v1282;
                      }
                      while (v1284 > 1);
                    }
                    v1266 += v1273;
                    v1265 += v1275;
                    v1269 += (int)v288;
                    ++v1280;
                    v1281 += v1273;
                  }
                  while (v1280 != v1277);
                }
                v1266 += v1278;
                v1265 += v1279;
                ++v1264;
              }
              while (v1264 != v1263);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v869 = *v26;
            if (v869)
            {
              uint64_t v870 = 0;
              uint64_t v871 = 0;
              uint64_t v872 = v25[19];
              uint64_t v873 = v225[19];
              uint64_t v874 = v24[19];
              uint64_t v875 = *(void *)v25[3];
              uint64_t v876 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v877 = 0;
                  int v878 = *(unsigned __int8 *)(v873 + v871);
                  unsigned int v879 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v874 + v877) = (v878 != 0) ^ (*(unsigned char *)(v872 + v877) != 0);
                    --v879;
                    ++v877;
                  }
                  while (v879 > 1);
                }
                v871 += v876;
                v874 += (int)v288;
                ++v870;
                v872 += v875;
              }
              while (v870 != v869);
            }
          }
          else
          {
            unint64_t v1613 = v24[6];
            if (v1613)
            {
              uint64_t v1285 = 0;
              uint64_t v1580 = v225[19];
              uint64_t v1586 = v25[19];
              uint64_t v1600 = (int)v288;
              unsigned int v1577 = v288 + 1;
              uint64_t v1286 = v24[19];
              do
              {
                uint64_t v1628 = v1285;
                uint64_t v1287 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1288 = v25[3];
                  do
                  {
                    ldiv_t v1289 = ldiv((int)v1285, v26[v28]);
                    LODWORD(v1285) = v1289.quot;
                    v1287 += *(void *)(v1288 + 8 * v28--) * v1289.rem;
                  }
                  while (v28 != -1);
                }
                uint64_t v1290 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1291) = 0;
                }
                else
                {
                  uint64_t v1291 = 0;
                  uint64_t v1292 = v225[3];
                  int v1293 = v1628;
                  do
                  {
                    ldiv_t v1294 = ldiv(v1293, v226[v1290]);
                    int v1293 = v1294.quot;
                    v1291 += *(void *)(v1292 + 8 * v1290--) * v1294.rem;
                  }
                  while (v1290 != -1);
                }
                if ((int)v1651 >= 1)
                {
                  uint64_t v1295 = 0;
                  int v1296 = *(unsigned __int8 *)(v1580 + (int)v1291);
                  unsigned int v1297 = v1577;
                  do
                  {
                    *(unsigned char *)(v1286 + v1295) = (v1296 != 0) ^ (*(unsigned char *)(v1586 + (int)v1287 + v1295) != 0);
                    --v1297;
                    ++v1295;
                  }
                  while (v1297 > 1);
                }
                v1286 += v1600;
                uint64_t v1285 = v1628 + v1600;
                uint64_t v28 = v1685;
              }
              while (v1628 + v1600 < v1613);
            }
          }
          break;
        case 3:
          if (v31 == 2)
          {
            uint64_t v1060 = *v26;
            if (v1060)
            {
              uint64_t v1061 = 0;
              uint64_t v1062 = 0;
              uint64_t v1063 = 0;
              uint64_t v1064 = v25[19];
              uint64_t v1065 = v225[19];
              uint64_t v1066 = v24[19];
              unint64_t v1067 = v26[1];
              uint64_t v1068 = (uint64_t *)v25[3];
              uint64_t v1069 = *v1068;
              uint64_t v1070 = v1068[1];
              uint64_t v1071 = (uint64_t *)v225[3];
              uint64_t v1073 = *v1071;
              uint64_t v1072 = v1071[1];
              if (v1067 <= 1) {
                uint64_t v1074 = 1;
              }
              else {
                uint64_t v1074 = v26[1];
              }
              uint64_t v1075 = v1069 - v1070 * v1067;
              uint64_t v1076 = v1073 - v1072 * v226[1];
              do
              {
                if (v1067)
                {
                  uint64_t v1077 = 0;
                  uint64_t v1078 = v1065 + v1062;
                  uint64_t v1079 = v1064 + v1063;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1080 = 0;
                      unsigned int v1081 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1066 + v1080) = (*(unsigned char *)(v1079 + v1080) != 0) ^ (*(unsigned char *)(v1078 + v1080) != 0);
                        --v1081;
                        ++v1080;
                      }
                      while (v1081 > 1);
                    }
                    v1063 += v1070;
                    v1062 += v1072;
                    v1066 += (int)v288;
                    ++v1077;
                    v1078 += v1072;
                    v1079 += v1070;
                  }
                  while (v1077 != v1074);
                }
                v1063 += v1075;
                v1062 += v1076;
                ++v1061;
              }
              while (v1061 != v1060);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v339 = *v26;
            if (v339)
            {
              uint64_t v340 = 0;
              uint64_t v341 = v25[19];
              uint64_t v342 = v225[19];
              uint64_t v343 = v24[19];
              uint64_t v344 = *(void *)v25[3];
              uint64_t v345 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v346 = 0;
                  unsigned int v347 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v343 + v346) = (*(unsigned char *)(v341 + v346) != 0) ^ (*(unsigned char *)(v342 + v346) != 0);
                    --v347;
                    ++v346;
                  }
                  while (v347 > 1);
                }
                v343 += (int)v288;
                ++v340;
                v342 += v345;
                v341 += v344;
              }
              while (v340 != v339);
            }
          }
          else
          {
            unint64_t v1610 = v24[6];
            if (v1610)
            {
              uint64_t v1082 = 0;
              uint64_t v1578 = v225[19];
              uint64_t v1581 = v25[19];
              uint64_t v1595 = (int)v288;
              unsigned int v1575 = v288 + 1;
              uint64_t v1083 = v24[19];
              do
              {
                uint64_t v1625 = v1082;
                uint64_t v1084 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1085 = v25[3];
                  for (uint64_t i = v28; i != -1; --i)
                  {
                    ldiv_t v1087 = ldiv((int)v1082, v26[i]);
                    LODWORD(v1082) = v1087.quot;
                    v1084 += *(void *)(v1085 + 8 * i) * v1087.rem;
                  }
                }
                uint64_t v1088 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1089) = 0;
                }
                else
                {
                  uint64_t v1089 = 0;
                  uint64_t v1090 = v225[3];
                  int v1091 = v1625;
                  do
                  {
                    ldiv_t v1092 = ldiv(v1091, v226[v1088]);
                    int v1091 = v1092.quot;
                    v1089 += *(void *)(v1090 + 8 * v1088--) * v1092.rem;
                  }
                  while (v1088 != -1);
                }
                uint64_t v28 = v1685;
                if ((int)v1651 >= 1)
                {
                  uint64_t v1093 = 0;
                  unsigned int v1094 = v1575;
                  do
                  {
                    *(unsigned char *)(v1083 + v1093) = (*(unsigned char *)(v1581 + (int)v1084 + v1093) != 0) ^ (*(unsigned char *)(v1578 + (int)v1089 + v1093) != 0);
                    --v1094;
                    ++v1093;
                  }
                  while (v1094 > 1);
                }
                v1083 += v1595;
                uint64_t v1082 = v1625 + v1595;
              }
              while (v1625 + v1595 < v1610);
            }
          }
          break;
        default:
LABEL_285:
          switch(v284)
          {
            case 1uLL:
              uint64_t v289 = v24[6];
              if (v289)
              {
                int v290 = (unsigned char *)v25[19];
                unsigned int v291 = (unsigned char *)v225[19];
                int v292 = (unsigned char *)v24[19];
                uint64_t v293 = *(void *)v25[3];
                uint64_t v294 = *(void *)v225[3];
                do
                {
                  *v292++ = (*v290 != 0) ^ (*v291 != 0);
                  v291 += v294;
                  v290 += v293;
                  --v289;
                }
                while (v289);
              }
              break;
            case 2uLL:
              uint64_t v482 = *v26;
              if (v482)
              {
                uint64_t v483 = 0;
                uint64_t v484 = 0;
                uint64_t v485 = 0;
                uint64_t v486 = 0;
                uint64_t v487 = v25[19];
                uint64_t v488 = v225[19];
                uint64_t v489 = v24[19];
                unint64_t v490 = v26[1];
                uint64_t v491 = (uint64_t *)v25[3];
                uint64_t v492 = *v491;
                uint64_t v493 = v491[1];
                int v494 = (uint64_t *)v225[3];
                uint64_t v495 = *v494;
                uint64_t v496 = v494[1];
                uint64_t v497 = v495 - v496 * v226[1];
                if (v490 <= 1) {
                  uint64_t v498 = 1;
                }
                else {
                  uint64_t v498 = v26[1];
                }
                uint64_t v499 = v492 - v493 * v490;
                do
                {
                  if (v490)
                  {
                    uint64_t v500 = v484 + v498;
                    uint64_t v501 = (unsigned char *)(v489 + v484);
                    uint64_t v502 = v498;
                    do
                    {
                      *v501++ = (*(unsigned char *)(v487 + v486) != 0) ^ (*(unsigned char *)(v488 + v485) != 0);
                      v486 += v493;
                      v485 += v496;
                      --v502;
                    }
                    while (v502);
                    uint64_t v484 = v500;
                  }
                  v486 += v499;
                  v485 += v497;
                  ++v483;
                }
                while (v483 != v482);
              }
              break;
            case 3uLL:
              uint64_t v503 = *v26;
              if (v503)
              {
                uint64_t v504 = 0;
                uint64_t v505 = 0;
                uint64_t v506 = 0;
                uint64_t v507 = 0;
                uint64_t v508 = v25[19];
                uint64_t v509 = v225[19];
                uint64_t v510 = v24[19];
                unint64_t v511 = v26[1];
                uint64_t v512 = (void *)v25[3];
                uint64_t v513 = v512[1];
                uint64_t v514 = (void *)v225[3];
                uint64_t v515 = v514[1];
                uint64_t v516 = *v514 - v515 * v226[1];
                if (v511 <= 1) {
                  uint64_t v517 = 1;
                }
                else {
                  uint64_t v517 = v26[1];
                }
                unint64_t v518 = *v512 - v513 * v511;
                do
                {
                  if (v511)
                  {
                    uint64_t v519 = 0;
                    unint64_t v520 = v26[2];
                    uint64_t v521 = v512[2];
                    uint64_t v522 = v514[2];
                    if (v520 <= 1) {
                      uint64_t v523 = 1;
                    }
                    else {
                      uint64_t v523 = v26[2];
                    }
                    uint64_t v524 = v515 - v522 * v226[2];
                    do
                    {
                      uint64_t v525 = v523;
                      if (v520)
                      {
                        do
                        {
                          *(unsigned char *)(v510 + v505++) = (*(unsigned char *)(v508 + v507) != 0) ^ (*(unsigned char *)(v509 + v506) != 0);
                          v507 += v521;
                          v506 += v522;
                          --v525;
                        }
                        while (v525);
                      }
                      v507 += v513 - v521 * v520;
                      v506 += v524;
                      ++v519;
                    }
                    while (v519 != v517);
                  }
                  v507 += v518;
                  v506 += v516;
                  ++v504;
                }
                while (v504 != v503);
              }
              break;
            case 4uLL:
              uint64_t v1690 = *v26;
              if (v1690)
              {
                uint64_t v526 = 0;
                uint64_t v527 = 0;
                uint64_t v528 = 0;
                uint64_t v529 = 0;
                uint64_t v530 = v25[19];
                uint64_t v531 = v225[19];
                uint64_t v532 = v24[19];
                unint64_t v533 = v26[1];
                uint64_t v534 = (void *)v25[3];
                uint64_t v535 = (void *)v225[3];
                uint64_t v1594 = v535[1];
                uint64_t v1608 = v534[1];
                uint64_t v1653 = *v535 - v1594 * v226[1];
                int v1675 = v26[1];
                if (v533 <= 1) {
                  uint64_t v536 = 1;
                }
                else {
                  uint64_t v536 = v26[1];
                }
                unint64_t v1617 = *v534 - v534[1] * v533;
                uint64_t v1631 = v2;
                do
                {
                  if (v1675)
                  {
                    uint64_t v537 = 0;
                    unint64_t v538 = v26[2];
                    uint64_t v539 = v534[2];
                    uint64_t v540 = v535[2];
                    if (v538 <= 1) {
                      uint64_t v541 = 1;
                    }
                    else {
                      uint64_t v541 = v26[2];
                    }
                    uint64_t v542 = v1594 - v540 * v226[2];
                    do
                    {
                      if (v538)
                      {
                        uint64_t v543 = 0;
                        unint64_t v544 = v26[3];
                        uint64_t v545 = v534[3];
                        uint64_t v546 = v535[3];
                        if (v544 <= 1) {
                          uint64_t v547 = 1;
                        }
                        else {
                          uint64_t v547 = v26[3];
                        }
                        uint64_t v548 = v540 - v546 * v226[3];
                        do
                        {
                          uint64_t v549 = v547;
                          if (v544)
                          {
                            do
                            {
                              *(unsigned char *)(v532 + v527++) = (*(unsigned char *)(v530 + v529) != 0) ^ (*(unsigned char *)(v531 + v528) != 0);
                              v529 += v545;
                              v528 += v546;
                              --v549;
                            }
                            while (v549);
                          }
                          v529 += v539 - v545 * v544;
                          v528 += v548;
                          ++v543;
                        }
                        while (v543 != v541);
                      }
                      v529 += v1608 - v539 * v538;
                      v528 += v542;
                      ++v537;
                    }
                    while (v537 != v536);
                  }
                  uint64_t v2 = v1631;
                  v529 += v1617;
                  v528 += v1653;
                  ++v526;
                }
                while (v526 != v1690);
              }
              break;
            default:
              uint64_t v1652 = v24[6];
              if (v1652)
              {
                uint64_t v471 = 0;
                uint64_t v1607 = v225[19];
                uint64_t v1616 = v25[19];
                uint64_t v1593 = v24[19];
                do
                {
                  uint64_t v472 = 0;
                  if ((v28 & 0x80000000) == 0)
                  {
                    uint64_t v473 = v25[3];
                    uint64_t v474 = v28;
                    int v475 = v471;
                    do
                    {
                      ldiv_t v476 = ldiv(v475, v26[v474]);
                      int v475 = v476.quot;
                      v472 += *(void *)(v473 + 8 * v474--) * v476.rem;
                    }
                    while (v474 != -1);
                  }
                  uint64_t v477 = v1670;
                  if ((v1670 & 0x80000000) != 0)
                  {
                    LODWORD(v478) = 0;
                  }
                  else
                  {
                    uint64_t v478 = 0;
                    uint64_t v479 = v225[3];
                    int v480 = v471;
                    do
                    {
                      ldiv_t v481 = ldiv(v480, v226[v477]);
                      int v480 = v481.quot;
                      v478 += *(void *)(v479 + 8 * v477--) * v481.rem;
                    }
                    while (v477 != -1);
                  }
                  *(unsigned char *)(v1593 + v471++) = (*(unsigned char *)(v1616 + (int)v472) != 0) ^ (*(unsigned char *)(v1607 + (int)v478) != 0);
                  uint64_t v28 = v1685;
                }
                while (v471 != v1652);
              }
              break;
          }
          break;
      }
LABEL_33:
      int v53 = *(uint64_t **)v2;
      v54 = *(uint64_t **)(v2 + 8);
      v55 = *(mlx::core::array **)(v2 + 16);
      switch(v56)
      {
        case 0:
          char v18 = **(unsigned char **)(*v54 + 152) ^ **(unsigned char **)(*v53 + 152);
          uint64_t v19 = *(void *)v55;
          goto LABEL_35;
        case 1:
          int v65 = *(_DWORD *)(*v54 + 160);
          if (v65 >= 1)
          {
            char v66 = **(unsigned char **)(*v53 + 152);
            v67 = *(unsigned char **)(*(void *)v55 + 152);
            uint64_t v68 = *(char **)(*v54 + 152);
            unsigned int v69 = v65 + 1;
            do
            {
              char v70 = *v68++;
              *v67++ = v70 ^ v66;
              --v69;
            }
            while (v69 > 1);
          }
          return;
        case 2:
          int v71 = *(_DWORD *)(*v53 + 160);
          if (v71 >= 1)
          {
            char v72 = **(unsigned char **)(*v54 + 152);
            int v73 = *(unsigned char **)(*(void *)v55 + 152);
            unsigned int v74 = *(char **)(*v53 + 152);
            unsigned int v75 = v71 + 1;
            do
            {
              char v76 = *v74++;
              *v73++ = v76 ^ v72;
              --v75;
            }
            while (v75 > 1);
          }
          return;
        case 3:
          int v77 = *(_DWORD *)(*(void *)v55 + 48);
          if (v77 >= 1)
          {
            v78 = *(unsigned char **)(*(void *)v55 + 152);
            unsigned int v79 = *(char **)(*v54 + 152);
            char v80 = *(char **)(*v53 + 152);
            unsigned int v81 = v77 + 1;
            do
            {
              char v83 = *v80++;
              char v82 = v83;
              char v84 = *v79++;
              *v78++ = v84 ^ v82;
              --v81;
            }
            while (v81 > 1);
          }
          return;
        default:
          unsigned int v57 = *(void **)v55;
          uint64_t v58 = *v53;
          int v59 = *(int **)*v53;
          uint64_t v60 = (*(void *)(*v53 + 8) - (void)v59) >> 2;
          int v61 = v60 - 1;
          if ((int)v60 - 1 >= -1) {
            int v61 = -1;
          }
          int v62 = v61 + 1;
          int v63 = v60 + 1;
          break;
      }
      while (1)
      {
        unsigned int v64 = v63 - 2;
        if (v63 - 2 < 0) {
          break;
        }
        --v63;
        if (*(void *)(*(void *)(v58 + 24) + 8 * v64) != *(void *)(v57[3] + 8 * v64)) {
          goto LABEL_55;
        }
      }
      int v63 = v62;
LABEL_55:
      unsigned int v85 = (int **)*v54;
      char v86 = *(int **)*v54;
      uint64_t v87 = (*(void *)(*v54 + 8) - (void)v86) >> 2;
      int v88 = v87 - 1;
      if ((int)v87 - 1 >= -1) {
        int v88 = -1;
      }
      int v89 = v88 + 1;
      int v90 = v87 + 1;
      while (1)
      {
        unsigned int v91 = v90 - 2;
        if (v90 - 2 < 0) {
          break;
        }
        --v90;
        if (*(void *)&v85[3][2 * v91] != *(void *)(v57[3] + 8 * v91)) {
          goto LABEL_62;
        }
      }
      int v90 = v89;
LABEL_62:
      int v92 = v60 + 1;
      while (1)
      {
        unsigned int v93 = v92 - 2;
        if (v92 - 2 < 0) {
          break;
        }
        --v92;
        if (*(void *)(*(void *)(v58 + 24) + 8 * v93)) {
          goto LABEL_67;
        }
      }
      int v92 = v62;
LABEL_67:
      int v94 = v87 + 1;
      while (1)
      {
        int v95 = v94 - 2;
        if (v94 - 2 < 0) {
          break;
        }
        --v94;
        if (*(void *)&v85[3][2 * v95]) {
          goto LABEL_72;
        }
      }
      int v94 = v89;
LABEL_72:
      unint64_t v96 = (uint64_t)(v57[1] - *v57) >> 2;
      if (v63 <= v90) {
        int v97 = v90;
      }
      else {
        int v97 = v63;
      }
      if (v63 <= v94) {
        int v63 = v94;
      }
      if (v92 > v90) {
        int v90 = v92;
      }
      if (v96 > v90)
      {
        int v98 = 1;
      }
      else
      {
        int v90 = (uint64_t)(v57[1] - *v57) >> 2;
        int v98 = 4;
      }
      if (v96 > v63)
      {
        int v99 = 2;
      }
      else
      {
        int v63 = v90;
        int v99 = v98;
      }
      if (v96 > v97)
      {
        int v63 = v97;
        int v99 = 3;
      }
      unint64_t v1684 = v55;
      if (!v63) {
        goto LABEL_89;
      }
      unint64_t v100 = *(void *)(v57[3] + 8 * (v63 - 1));
      if (v100 < 0x10) {
        goto LABEL_89;
      }
      switch(v99)
      {
        case 1:
          if (v63 == 2)
          {
            int v996 = *v59;
            if (*v59)
            {
              unint64_t v997 = 0;
              uint64_t v998 = 0;
              uint64_t v999 = 0;
              uint64_t v1000 = *(void *)(v58 + 152);
              unsigned int v1001 = v85[19];
              uint64_t v1002 = v57[19];
              do
              {
                if (v59[1])
                {
                  unint64_t v1003 = 0;
                  do
                  {
                    if ((int)v100 >= 1)
                    {
                      uint64_t v1004 = 0;
                      char v1005 = *(unsigned char *)(v1000 + v999);
                      unsigned int v1006 = v100 + 1;
                      do
                      {
                        *(unsigned char *)(v1002 + v1004) = *((unsigned char *)v1001 + v998 + v1004) ^ v1005;
                        --v1006;
                        ++v1004;
                      }
                      while (v1006 > 1);
                      uint64_t v58 = *v53;
                      unsigned int v85 = (int **)*v54;
                      int v59 = *(int **)*v53;
                    }
                    unint64_t v1007 = *(void **)(v58 + 24);
                    uint64_t v1008 = v1007[1];
                    v999 += v1008;
                    v998 += *((void *)v85[3] + 1);
                    v1002 += (int)v100;
                    ++v1003;
                    unint64_t v1009 = v59[1];
                  }
                  while (v1003 < v1009);
                  int v996 = *v59;
                  char v86 = *v85;
                }
                else
                {
                  unint64_t v1009 = 0;
                  unint64_t v1007 = *(void **)(v58 + 24);
                  uint64_t v1008 = v1007[1];
                }
                uint64_t v999 = *v1007 + v999 - v1009 * v1008;
                uint64_t v998 = *(void *)v85[3] + v998 - *((void *)v85[3] + 1) * v86[1];
                ++v997;
              }
              while (v997 < v996);
            }
          }
          else if (v63 == 1)
          {
            int v451 = *v59;
            if (*v59)
            {
              unint64_t v452 = 0;
              uint64_t v453 = 0;
              uint64_t v454 = 0;
              uint64_t v455 = *(void *)(v58 + 152);
              unint64_t v456 = v85[19];
              uint64_t v457 = v57[19];
              do
              {
                if ((int)v100 >= 1)
                {
                  uint64_t v458 = 0;
                  char v459 = *(unsigned char *)(v455 + v454);
                  unsigned int v460 = v100 + 1;
                  do
                  {
                    *(unsigned char *)(v457 + v458) = *((unsigned char *)v456 + v453 + v458) ^ v459;
                    --v460;
                    ++v458;
                  }
                  while (v460 > 1);
                  uint64_t v58 = *v53;
                  unsigned int v85 = (int **)*v54;
                  int v451 = **(_DWORD **)*v53;
                }
                v454 += **(void **)(v58 + 24);
                v453 += *(void *)v85[3];
                v457 += (int)v100;
                ++v452;
              }
              while (v452 < v451);
            }
          }
          else if (v57[6])
          {
            uint64_t v1623 = v85[19];
            uint64_t v1637 = *(void *)(v58 + 152);
            unint64_t v1679 = 0;
            uint64_t v1010 = v57[19];
            do
            {
              uint64_t v1011 = *(void *)*v53;
              unint64_t v1012 = (unint64_t)(*(void *)(*v53 + 8) - v1011) >> 2;
              uint64_t v1013 = 0;
              uint64_t v1014 = (v1012 - 1);
              if ((int)v1012 - 1 >= 0)
              {
                uint64_t v1015 = *(void *)(*v53 + 24);
                int v1016 = v1679;
                do
                {
                  ldiv_t v1017 = ldiv(v1016, *(int *)(v1011 + 4 * v1014));
                  int v1016 = v1017.quot;
                  v1013 += *(void *)(v1015 + 8 * v1014--) * v1017.rem;
                }
                while (v1014 != -1);
              }
              uint64_t v1018 = *(void *)*v54;
              unint64_t v1019 = (unint64_t)(*(void *)(*v54 + 8) - v1018) >> 2;
              uint64_t v1020 = 0;
              uint64_t v1021 = (v1019 - 1);
              if ((int)v1019 - 1 >= 0)
              {
                uint64_t v1022 = *(void *)(*v54 + 24);
                int v1023 = v1679;
                do
                {
                  ldiv_t v1024 = ldiv(v1023, *(int *)(v1018 + 4 * v1021));
                  int v1023 = v1024.quot;
                  v1020 += *(void *)(v1022 + 8 * v1021--) * v1024.rem;
                }
                while (v1021 != -1);
              }
              if ((int)v100 >= 1)
              {
                uint64_t v1025 = 0;
                char v1026 = *(unsigned char *)(v1637 + (int)v1013);
                unsigned int v1027 = v100 + 1;
                do
                {
                  *(unsigned char *)(v1010 + v1025) = *((unsigned char *)v1623 + (int)v1020 + v1025) ^ v1026;
                  --v1027;
                  ++v1025;
                }
                while (v1027 > 1);
                unsigned int v57 = *(void **)v1684;
              }
              v1010 += (int)v100;
              v1679 += (int)v100;
            }
            while (v1679 < v57[6]);
          }
          break;
        case 2:
          if (v63 == 2)
          {
            int v1028 = *v59;
            if (*v59)
            {
              unint64_t v1029 = 0;
              uint64_t v1030 = 0;
              uint64_t v1031 = 0;
              uint64_t v1032 = *(void *)(v58 + 152);
              v1033 = v85[19];
              uint64_t v1034 = v57[19];
              do
              {
                if (v59[1])
                {
                  unint64_t v1035 = 0;
                  do
                  {
                    if ((int)v100 >= 1)
                    {
                      uint64_t v1036 = 0;
                      char v1037 = *((unsigned char *)v1033 + v1030);
                      unsigned int v1038 = v100 + 1;
                      do
                      {
                        *(unsigned char *)(v1034 + v1036) = *(unsigned char *)(v1032 + v1031 + v1036) ^ v1037;
                        --v1038;
                        ++v1036;
                      }
                      while (v1038 > 1);
                      uint64_t v58 = *v53;
                      unsigned int v85 = (int **)*v54;
                      int v59 = *(int **)*v53;
                    }
                    uint64_t v1039 = *(void **)(v58 + 24);
                    uint64_t v1040 = v1039[1];
                    v1031 += v1040;
                    v1030 += *((void *)v85[3] + 1);
                    v1034 += (int)v100;
                    ++v1035;
                    unint64_t v1041 = v59[1];
                  }
                  while (v1035 < v1041);
                  int v1028 = *v59;
                  char v86 = *v85;
                }
                else
                {
                  unint64_t v1041 = 0;
                  uint64_t v1039 = *(void **)(v58 + 24);
                  uint64_t v1040 = v1039[1];
                }
                uint64_t v1031 = *v1039 + v1031 - v1041 * v1040;
                uint64_t v1030 = *(void *)v85[3] + v1030 - *((void *)v85[3] + 1) * v86[1];
                ++v1029;
              }
              while (v1029 < v1028);
            }
          }
          else if (v63 == 1)
          {
            int v461 = *v59;
            if (*v59)
            {
              unint64_t v462 = 0;
              uint64_t v463 = 0;
              uint64_t v464 = 0;
              uint64_t v465 = *(void *)(v58 + 152);
              unint64_t v466 = v85[19];
              uint64_t v467 = v57[19];
              do
              {
                if ((int)v100 >= 1)
                {
                  uint64_t v468 = 0;
                  char v469 = *((unsigned char *)v466 + v463);
                  unsigned int v470 = v100 + 1;
                  do
                  {
                    *(unsigned char *)(v467 + v468) = *(unsigned char *)(v465 + v464 + v468) ^ v469;
                    --v470;
                    ++v468;
                  }
                  while (v470 > 1);
                  uint64_t v58 = *v53;
                  unsigned int v85 = (int **)*v54;
                  int v461 = **(_DWORD **)*v53;
                }
                v464 += **(void **)(v58 + 24);
                v463 += *(void *)v85[3];
                v467 += (int)v100;
                ++v462;
              }
              while (v462 < v461);
            }
          }
          else if (v57[6])
          {
            uint64_t v1624 = v85[19];
            uint64_t v1638 = *(void *)(v58 + 152);
            unint64_t v1680 = 0;
            uint64_t v1042 = v57[19];
            do
            {
              uint64_t v1043 = *(void *)*v53;
              unint64_t v1044 = (unint64_t)(*(void *)(*v53 + 8) - v1043) >> 2;
              uint64_t v1045 = 0;
              uint64_t v1046 = (v1044 - 1);
              if ((int)v1044 - 1 >= 0)
              {
                uint64_t v1047 = *(void *)(*v53 + 24);
                int v1048 = v1680;
                do
                {
                  ldiv_t v1049 = ldiv(v1048, *(int *)(v1043 + 4 * v1046));
                  int v1048 = v1049.quot;
                  v1045 += *(void *)(v1047 + 8 * v1046--) * v1049.rem;
                }
                while (v1046 != -1);
              }
              uint64_t v1050 = *(void *)*v54;
              unint64_t v1051 = (unint64_t)(*(void *)(*v54 + 8) - v1050) >> 2;
              uint64_t v1052 = 0;
              uint64_t v1053 = (v1051 - 1);
              if ((int)v1051 - 1 >= 0)
              {
                uint64_t v1054 = *(void *)(*v54 + 24);
                int v1055 = v1680;
                do
                {
                  ldiv_t v1056 = ldiv(v1055, *(int *)(v1050 + 4 * v1053));
                  int v1055 = v1056.quot;
                  v1052 += *(void *)(v1054 + 8 * v1053--) * v1056.rem;
                }
                while (v1053 != -1);
              }
              if ((int)v100 >= 1)
              {
                uint64_t v1057 = 0;
                char v1058 = *((unsigned char *)v1624 + (int)v1052);
                unsigned int v1059 = v100 + 1;
                do
                {
                  *(unsigned char *)(v1042 + v1057) = *(unsigned char *)(v1638 + (int)v1045 + v1057) ^ v1058;
                  --v1059;
                  ++v1057;
                }
                while (v1059 > 1);
                unsigned int v57 = *(void **)v1684;
              }
              v1042 += (int)v100;
              v1680 += (int)v100;
            }
            while (v1680 < v57[6]);
          }
          break;
        case 3:
          if (v63 == 2)
          {
            int v966 = *v59;
            if (*v59)
            {
              unint64_t v967 = 0;
              uint64_t v968 = 0;
              uint64_t v969 = 0;
              uint64_t v970 = *(void *)(v58 + 152);
              uint64_t v971 = v85[19];
              uint64_t v972 = v57[19];
              do
              {
                if (v59[1])
                {
                  unint64_t v973 = 0;
                  do
                  {
                    if ((int)v100 >= 1)
                    {
                      uint64_t v974 = 0;
                      unsigned int v975 = v100 + 1;
                      do
                      {
                        *(unsigned char *)(v972 + v974) = *((unsigned char *)v971 + v968 + v974) ^ *(unsigned char *)(v970 + v969 + v974);
                        --v975;
                        ++v974;
                      }
                      while (v975 > 1);
                      uint64_t v58 = *v53;
                      unsigned int v85 = (int **)*v54;
                      int v59 = *(int **)*v53;
                    }
                    uint64_t v976 = *(void **)(v58 + 24);
                    uint64_t v977 = v976[1];
                    v969 += v977;
                    v968 += *((void *)v85[3] + 1);
                    v972 += (int)v100;
                    ++v973;
                    unint64_t v978 = v59[1];
                  }
                  while (v973 < v978);
                  int v966 = *v59;
                  char v86 = *v85;
                }
                else
                {
                  unint64_t v978 = 0;
                  uint64_t v976 = *(void **)(v58 + 24);
                  uint64_t v977 = v976[1];
                }
                uint64_t v969 = *v976 + v969 - v978 * v977;
                uint64_t v968 = *(void *)v85[3] + v968 - *((void *)v85[3] + 1) * v86[1];
                ++v967;
              }
              while (v967 < v966);
            }
          }
          else if (v63 == 1)
          {
            int v216 = *v59;
            if (*v59)
            {
              unint64_t v217 = 0;
              uint64_t v218 = 0;
              uint64_t v219 = 0;
              uint64_t v220 = *(void *)(v58 + 152);
              v221 = v85[19];
              uint64_t v222 = v57[19];
              do
              {
                if ((int)v100 >= 1)
                {
                  uint64_t v223 = 0;
                  unsigned int v224 = v100 + 1;
                  do
                  {
                    *(unsigned char *)(v222 + v223) = *((unsigned char *)v221 + v218 + v223) ^ *(unsigned char *)(v220 + v219 + v223);
                    --v224;
                    ++v223;
                  }
                  while (v224 > 1);
                  uint64_t v58 = *v53;
                  unsigned int v85 = (int **)*v54;
                  int v216 = **(_DWORD **)*v53;
                }
                v219 += **(void **)(v58 + 24);
                v218 += *(void *)v85[3];
                v222 += (int)v100;
                ++v217;
              }
              while (v217 < v216);
            }
          }
          else if (v57[6])
          {
            uint64_t v1622 = v85[19];
            uint64_t v1636 = *(void *)(v58 + 152);
            unint64_t v1678 = 0;
            uint64_t v979 = v57[19];
            do
            {
              uint64_t v980 = *(void *)*v53;
              unint64_t v981 = (unint64_t)(*(void *)(*v53 + 8) - v980) >> 2;
              uint64_t v982 = 0;
              uint64_t v983 = (v981 - 1);
              if ((int)v981 - 1 >= 0)
              {
                uint64_t v984 = *(void *)(*v53 + 24);
                int v985 = v1678;
                do
                {
                  ldiv_t v986 = ldiv(v985, *(int *)(v980 + 4 * v983));
                  int v985 = v986.quot;
                  v982 += *(void *)(v984 + 8 * v983--) * v986.rem;
                }
                while (v983 != -1);
              }
              uint64_t v987 = *(void *)*v54;
              unint64_t v988 = (unint64_t)(*(void *)(*v54 + 8) - v987) >> 2;
              uint64_t v989 = 0;
              uint64_t v990 = (v988 - 1);
              if ((int)v988 - 1 >= 0)
              {
                uint64_t v991 = *(void *)(*v54 + 24);
                int v992 = v1678;
                do
                {
                  ldiv_t v993 = ldiv(v992, *(int *)(v987 + 4 * v990));
                  int v992 = v993.quot;
                  v989 += *(void *)(v991 + 8 * v990--) * v993.rem;
                }
                while (v990 != -1);
              }
              if ((int)v100 >= 1)
              {
                uint64_t v994 = 0;
                unsigned int v995 = v100 + 1;
                do
                {
                  *(unsigned char *)(v979 + v994) = *((unsigned char *)v1622 + (int)v989 + v994) ^ *(unsigned char *)(v1636 + (int)v982 + v994);
                  --v995;
                  ++v994;
                }
                while (v995 > 1);
                unsigned int v57 = *(void **)v1684;
              }
              v979 += (int)v100;
              v1678 += (int)v100;
            }
            while (v1678 < v57[6]);
          }
          break;
        default:
LABEL_89:
          switch(v96)
          {
            case 1uLL:
              if (v57[6])
              {
                unint64_t v101 = 0;
                uint64_t v102 = 0;
                uint64_t v103 = 0;
                uint64_t v104 = *(void *)(v58 + 152);
                int v105 = v85[19];
                uint64_t v106 = v57[19];
                do
                {
                  *(unsigned char *)(v106 + v101) = *((unsigned char *)v105 + v102) ^ *(unsigned char *)(v104 + v103);
                  v103 += **(void **)(*v53 + 24);
                  v102 += **(void **)(*v54 + 24);
                  ++v101;
                }
                while (v101 < *(void *)(*(void *)v55 + 48));
              }
              break;
            case 2uLL:
              int v401 = *v59;
              if (*v59)
              {
                unint64_t v402 = 0;
                uint64_t v403 = 0;
                uint64_t v404 = 0;
                uint64_t v405 = 0;
                uint64_t v406 = *(void *)(v58 + 152);
                ldiv_t v407 = v85[19];
                uint64_t v408 = v57[19];
                do
                {
                  if (v59[1])
                  {
                    unint64_t v409 = 0;
                    do
                    {
                      *(unsigned char *)(v408 + v403 + v409) = *((unsigned char *)v407 + v404) ^ *(unsigned char *)(v406 + v405);
                      uint64_t v58 = *v53;
                      uint64_t v410 = *(void **)(*v53 + 24);
                      uint64_t v411 = v410[1];
                      v405 += v411;
                      unsigned int v85 = (int **)*v54;
                      uint64_t v412 = *(int **)(*v54 + 24);
                      uint64_t v413 = *((void *)v412 + 1);
                      v404 += v413;
                      ++v409;
                      int v59 = *(int **)*v53;
                      unint64_t v414 = v59[1];
                    }
                    while (v409 < v414);
                    int v401 = *v59;
                    char v86 = *v85;
                    v403 += v409;
                  }
                  else
                  {
                    unint64_t v414 = 0;
                    uint64_t v410 = *(void **)(v58 + 24);
                    uint64_t v411 = v410[1];
                    uint64_t v412 = v85[3];
                    uint64_t v413 = *((void *)v412 + 1);
                  }
                  uint64_t v405 = *v410 + v405 - v414 * v411;
                  uint64_t v404 = *(void *)v412 + v404 - v413 * v86[1];
                  ++v402;
                }
                while (v402 < v401);
              }
              break;
            case 3uLL:
              int v415 = *v59;
              if (*v59)
              {
                unint64_t v416 = 0;
                uint64_t v417 = 0;
                uint64_t v418 = 0;
                uint64_t v419 = 0;
                uint64_t v420 = *(void *)(v58 + 152);
                v421 = v85[19];
                uint64_t v422 = v57[19];
                do
                {
                  if (v59[1])
                  {
                    unint64_t v423 = 0;
                    do
                    {
                      if (v59[2])
                      {
                        unint64_t v424 = 0;
                        do
                        {
                          *(unsigned char *)(v422 + v417 + v424) = *((unsigned char *)v421 + v418) ^ *(unsigned char *)(v420 + v419);
                          uint64_t v58 = *v53;
                          uint64_t v425 = *(void **)(*v53 + 24);
                          uint64_t v426 = v425[2];
                          v419 += v426;
                          unsigned int v85 = (int **)*v54;
                          uint64_t v427 = *(int **)(*v54 + 24);
                          uint64_t v428 = *((void *)v427 + 2);
                          v418 += v428;
                          ++v424;
                          int v59 = *(int **)*v53;
                          unint64_t v429 = v59[2];
                        }
                        while (v424 < v429);
                        char v86 = *v85;
                        v417 += v424;
                      }
                      else
                      {
                        unint64_t v429 = 0;
                        uint64_t v425 = *(void **)(v58 + 24);
                        uint64_t v426 = v425[2];
                        uint64_t v427 = v85[3];
                        uint64_t v428 = *((void *)v427 + 2);
                      }
                      uint64_t v430 = v425[1];
                      uint64_t v419 = v430 + v419 - v429 * v426;
                      uint64_t v418 = *((void *)v427 + 1) + v418 - v428 * v86[2];
                      ++v423;
                      unint64_t v431 = v59[1];
                    }
                    while (v423 < v431);
                    int v415 = *v59;
                  }
                  else
                  {
                    unint64_t v431 = 0;
                    uint64_t v425 = *(void **)(v58 + 24);
                    uint64_t v430 = v425[1];
                  }
                  uint64_t v419 = *v425 + v419 - v431 * v430;
                  uint64_t v418 = *(void *)v85[3] + v418 - *((void *)v85[3] + 1) * v86[1];
                  ++v416;
                }
                while (v416 < v415);
              }
              break;
            case 4uLL:
              int v432 = *v59;
              if (*v59)
              {
                unint64_t v433 = 0;
                uint64_t v434 = 0;
                uint64_t v435 = 0;
                uint64_t v436 = 0;
                uint64_t v437 = *(void *)(v58 + 152);
                unint64_t v438 = v85[19];
                uint64_t v439 = v57[19];
                do
                {
                  if (v59[1])
                  {
                    unint64_t v440 = 0;
                    do
                    {
                      if (v59[2])
                      {
                        unint64_t v441 = 0;
                        do
                        {
                          if (v59[3])
                          {
                            unint64_t v442 = 0;
                            do
                            {
                              *(unsigned char *)(v439 + v434 + v442) = *((unsigned char *)v438 + v435) ^ *(unsigned char *)(v437 + v436);
                              uint64_t v58 = *v53;
                              unint64_t v443 = *(void **)(*v53 + 24);
                              uint64_t v444 = v443[3];
                              v436 += v444;
                              unsigned int v85 = (int **)*v54;
                              unint64_t v445 = *(int **)(*v54 + 24);
                              uint64_t v446 = *((void *)v445 + 3);
                              v435 += v446;
                              ++v442;
                              int v59 = *(int **)*v53;
                              unint64_t v447 = v59[3];
                            }
                            while (v442 < v447);
                            char v86 = *v85;
                            v434 += v442;
                          }
                          else
                          {
                            unint64_t v447 = 0;
                            unint64_t v443 = *(void **)(v58 + 24);
                            uint64_t v444 = v443[3];
                            unint64_t v445 = v85[3];
                            uint64_t v446 = *((void *)v445 + 3);
                          }
                          uint64_t v448 = v443[2];
                          uint64_t v436 = v448 + v436 - v447 * v444;
                          uint64_t v435 = *((void *)v445 + 2) + v435 - v446 * v86[3];
                          ++v441;
                          unint64_t v449 = v59[2];
                        }
                        while (v441 < v449);
                      }
                      else
                      {
                        unint64_t v449 = 0;
                        unint64_t v443 = *(void **)(v58 + 24);
                        uint64_t v448 = v443[2];
                      }
                      uint64_t v436 = v443[1] + v436 - v449 * v448;
                      uint64_t v435 = *((void *)v85[3] + 1) + v435 - *((void *)v85[3] + 2) * v86[2];
                      ++v440;
                      unint64_t v450 = v59[1];
                    }
                    while (v440 < v450);
                    int v432 = *v59;
                  }
                  else
                  {
                    unint64_t v450 = 0;
                  }
                  uint64_t v436 = **(void **)(v58 + 24) + v436 - *(void *)(*(void *)(v58 + 24) + 8) * v450;
                  uint64_t v435 = *(void *)v85[3] + v435 - *((void *)v85[3] + 1) * v86[1];
                  ++v433;
                }
                while (v433 < v432);
              }
              break;
            default:
              if (v57[6])
              {
                unint64_t v384 = 0;
                uint64_t v1674 = *(void *)(v58 + 152);
                uint64_t v385 = v85[19];
                uint64_t v386 = v57[19];
                do
                {
                  uint64_t v387 = *(void *)*v53;
                  unint64_t v388 = (unint64_t)(*(void *)(*v53 + 8) - v387) >> 2;
                  uint64_t v389 = 0;
                  uint64_t v390 = (v388 - 1);
                  if ((int)v388 - 1 >= 0)
                  {
                    uint64_t v391 = *(void *)(*v53 + 24);
                    int v392 = v384;
                    do
                    {
                      ldiv_t v393 = ldiv(v392, *(int *)(v387 + 4 * v390));
                      int v392 = v393.quot;
                      v389 += *(void *)(v391 + 8 * v390--) * v393.rem;
                    }
                    while (v390 != -1);
                  }
                  uint64_t v394 = *(void *)*v54;
                  unint64_t v395 = (unint64_t)(*(void *)(*v54 + 8) - v394) >> 2;
                  uint64_t v396 = 0;
                  uint64_t v397 = (v395 - 1);
                  if ((int)v395 - 1 >= 0)
                  {
                    uint64_t v398 = *(void *)(*v54 + 24);
                    int v399 = v384;
                    do
                    {
                      ldiv_t v400 = ldiv(v399, *(int *)(v394 + 4 * v397));
                      int v399 = v400.quot;
                      v396 += *(void *)(v398 + 8 * v397--) * v400.rem;
                    }
                    while (v397 != -1);
                  }
                  *(unsigned char *)(v386 + v384++) = *((unsigned char *)v385 + (int)v396) ^ *(unsigned char *)(v1674 + (int)v389);
                }
                while (v384 < *(void *)(*(void *)v1684 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 1:
      goto LABEL_33;
    case 2:
      char v7 = *(uint64_t **)a1;
      BOOL v6 = *(uint64_t **)(a1 + 8);
      switch(v8)
      {
        case 0:
          goto LABEL_12;
        case 1:
          int v9 = *(_DWORD *)(*v6 + 160);
          if (v9 >= 1)
          {
            int v10 = **(_DWORD **)(*v7 + 152);
            int v11 = *(int **)(*(void *)v1 + 152);
            int v12 = *(int **)(*v6 + 152);
            unsigned int v13 = v9 + 1;
            do
            {
              int v14 = *v12++;
              *v11++ = v14 ^ v10;
              --v13;
            }
            while (v13 > 1);
          }
          return;
        case 2:
          int v116 = *(_DWORD *)(*v7 + 160);
          if (v116 >= 1)
          {
            int v117 = **(_DWORD **)(*v6 + 152);
            v118 = *(int **)(*(void *)v1 + 152);
            v119 = *(int **)(*v7 + 152);
            unsigned int v120 = v116 + 1;
            do
            {
              int v121 = *v119++;
              *v118++ = v121 ^ v117;
              --v120;
            }
            while (v120 > 1);
          }
          return;
        case 3:
          int v122 = *(_DWORD *)(*(void *)v1 + 48);
          if (v122 >= 1)
          {
            int v123 = *(int **)(*(void *)v1 + 152);
            int v124 = *(int **)(*v6 + 152);
            unsigned int v125 = *(int **)(*v7 + 152);
            unsigned int v126 = v122 + 1;
            do
            {
              int v128 = *v125++;
              int v127 = v128;
              int v129 = *v124++;
              *v123++ = v129 ^ v127;
              --v126;
            }
            while (v126 > 1);
          }
          return;
        default:
          int v107 = *(void **)v1;
          int v108 = (void *)*v7;
          int v109 = *(int **)*v7;
          uint64_t v110 = (v108[1] - (void)v109) >> 2;
          uint64_t v111 = (v110 - 1);
          if ((int)v111 >= -1) {
            int v112 = -1;
          }
          else {
            int v112 = v110 - 1;
          }
          int v113 = v112 + 1;
          int v114 = v110 + 1;
          break;
      }
      while (1)
      {
        unsigned int v115 = v114 - 2;
        if (v114 - 2 < 0) {
          break;
        }
        --v114;
        if (*(void *)(v108[3] + 8 * v115) != *(void *)(v107[3] + 8 * v115)) {
          goto LABEL_187;
        }
      }
      int v114 = v113;
LABEL_187:
      uint64_t v233 = (void *)*v6;
      unsigned int v234 = *(int **)*v6;
      uint64_t v235 = (v233[1] - (void)v234) >> 2;
      uint64_t v236 = (v235 - 1);
      if ((int)v236 >= -1) {
        int v237 = -1;
      }
      else {
        int v237 = v235 - 1;
      }
      int v238 = v237 + 1;
      int v239 = v235 + 1;
      while (1)
      {
        unsigned int v240 = v239 - 2;
        if (v239 - 2 < 0) {
          break;
        }
        --v239;
        if (*(void *)(v233[3] + 8 * v240) != *(void *)(v107[3] + 8 * v240)) {
          goto LABEL_223;
        }
      }
      int v239 = v238;
LABEL_223:
      int v266 = v110 + 1;
      while (1)
      {
        unsigned int v267 = v266 - 2;
        if (v266 - 2 < 0) {
          break;
        }
        --v266;
        if (*(void *)(v108[3] + 8 * v267)) {
          goto LABEL_248;
        }
      }
      int v266 = v113;
LABEL_248:
      int v276 = v235 + 1;
      while (1)
      {
        unsigned int v277 = v276 - 2;
        if (v276 - 2 < 0) {
          break;
        }
        --v276;
        if (*(void *)(v233[3] + 8 * v277)) {
          goto LABEL_291;
        }
      }
      int v276 = v238;
LABEL_291:
      unint64_t v295 = (uint64_t)(v107[1] - *v107) >> 2;
      if (v114 <= v239) {
        int v296 = v239;
      }
      else {
        int v296 = v114;
      }
      if (v114 <= v276) {
        int v114 = v276;
      }
      if (v266 > v239) {
        int v239 = v266;
      }
      if (v295 > v239)
      {
        int v297 = 1;
      }
      else
      {
        int v239 = (uint64_t)(v107[1] - *v107) >> 2;
        int v297 = 4;
      }
      if (v295 > v114)
      {
        int v298 = 2;
      }
      else
      {
        int v114 = v239;
        int v298 = v297;
      }
      if (v295 > v296)
      {
        int v114 = v296;
        int v298 = 3;
      }
      uint64_t v1671 = v236;
      uint64_t v1686 = v111;
      if (!v114) {
        goto LABEL_308;
      }
      unint64_t v299 = *(void *)(v107[3] + 8 * (v114 - 1));
      if (v299 < 0x10) {
        goto LABEL_308;
      }
      switch(v298)
      {
        case 1:
          if (v114 == 2)
          {
            int v1298 = *v109;
            if (*v109)
            {
              unint64_t v1299 = 0;
              uint64_t v1300 = 0;
              uint64_t v1301 = 0;
              uint64_t v1302 = v108[19];
              uint64_t v1303 = v233[19];
              uint64_t v1304 = v107[19];
              v1305 = (uint64_t *)v108[3];
              uint64_t v1306 = *v1305;
              uint64_t v1307 = v1305[1];
              v1308 = (uint64_t *)v233[3];
              uint64_t v1309 = *v1308;
              uint64_t v1310 = v1308[1];
              int v1311 = v109[1];
              int v1312 = v1311;
              do
              {
                if (v1312)
                {
                  unint64_t v1313 = 0;
                  uint64_t v1314 = v1303 + 4 * v1300;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1315 = 0;
                      int v1316 = *(_DWORD *)(v1302 + 4 * v1301);
                      unsigned int v1317 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1304 + v1315) = *(_DWORD *)(v1314 + v1315) ^ v1316;
                        --v1317;
                        v1315 += 4;
                      }
                      while (v1317 > 1);
                      int v1311 = v109[1];
                    }
                    v1301 += v1307;
                    v1300 += v1310;
                    v1304 += 4 * (int)v299;
                    ++v1313;
                    v1314 += 4 * v1310;
                  }
                  while (v1313 < v1311);
                  uint64_t v1318 = v1311;
                  int v1298 = *v109;
                  int v1312 = v1311;
                }
                else
                {
                  uint64_t v1318 = 0;
                }
                uint64_t v1301 = v1301 + v1306 - v1318 * v1307;
                uint64_t v1300 = v1300 + v1309 - v1310 * v234[1];
                ++v1299;
              }
              while (v1299 < v1298);
            }
          }
          else if (v114 == 1)
          {
            int v880 = *v109;
            if (*v109)
            {
              unint64_t v881 = 0;
              uint64_t v882 = 0;
              uint64_t v883 = v108[19];
              uint64_t v884 = v233[19];
              uint64_t v885 = v107[19];
              uint64_t v886 = *(void *)v108[3];
              uint64_t v887 = 4 * *(void *)v233[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v888 = 0;
                  int v889 = *(_DWORD *)(v883 + 4 * v882);
                  unsigned int v890 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v885 + v888) = *(_DWORD *)(v884 + v888) ^ v889;
                    --v890;
                    v888 += 4;
                  }
                  while (v890 > 1);
                  int v880 = *v109;
                }
                v882 += v886;
                ++v881;
                v885 += 4 * (int)v299;
                v884 += v887;
              }
              while (v881 < v880);
            }
          }
          else
          {
            unint64_t v1643 = v107[6];
            if (v1643)
            {
              unint64_t v1662 = 0;
              uint64_t v1587 = v233[19];
              uint64_t v1601 = v108[19];
              uint64_t v1319 = v107[19];
              do
              {
                uint64_t v1320 = 0;
                if ((v111 & 0x80000000) == 0)
                {
                  uint64_t v1321 = v108[3];
                  uint64_t v1322 = v111;
                  int v1323 = v1662;
                  do
                  {
                    ldiv_t v1324 = ldiv(v1323, v109[v1322]);
                    int v1323 = v1324.quot;
                    v1320 += *(void *)(v1321 + 8 * v1322--) * v1324.rem;
                  }
                  while (v1322 != -1);
                }
                uint64_t v1325 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1326) = 0;
                }
                else
                {
                  uint64_t v1326 = 0;
                  uint64_t v1327 = v233[3];
                  int v1328 = v1662;
                  do
                  {
                    ldiv_t v1329 = ldiv(v1328, v234[v1325]);
                    int v1328 = v1329.quot;
                    v1326 += *(void *)(v1327 + 8 * v1325--) * v1329.rem;
                  }
                  while (v1325 != -1);
                }
                uint64_t v111 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1330 = 0;
                  int v1331 = *(_DWORD *)(v1601 + 4 * (int)v1320);
                  unsigned int v1332 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1319 + v1330) = *(_DWORD *)(v1587 + 4 * (int)v1326 + v1330) ^ v1331;
                    --v1332;
                    v1330 += 4;
                  }
                  while (v1332 > 1);
                }
                v1319 += 4 * (int)v299;
                v1662 += (int)v299;
              }
              while (v1662 < v1643);
            }
          }
          break;
        case 2:
          if (v114 == 2)
          {
            int v1333 = *v109;
            if (*v109)
            {
              unint64_t v1334 = 0;
              uint64_t v1335 = 0;
              uint64_t v1336 = 0;
              uint64_t v1337 = v108[19];
              uint64_t v1338 = v233[19];
              uint64_t v1339 = v107[19];
              uint64_t v1340 = (uint64_t *)v108[3];
              uint64_t v1341 = *v1340;
              uint64_t v1342 = v1340[1];
              v1343 = (uint64_t *)v233[3];
              uint64_t v1344 = *v1343;
              uint64_t v1345 = v1343[1];
              int v1346 = v109[1];
              int v1347 = v1346;
              do
              {
                if (v1347)
                {
                  unint64_t v1348 = 0;
                  uint64_t v1349 = v1337 + 4 * v1336;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1350 = 0;
                      int v1351 = *(_DWORD *)(v1338 + 4 * v1335);
                      unsigned int v1352 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1339 + v1350) = *(_DWORD *)(v1349 + v1350) ^ v1351;
                        --v1352;
                        v1350 += 4;
                      }
                      while (v1352 > 1);
                      int v1346 = v109[1];
                    }
                    v1336 += v1342;
                    v1335 += v1345;
                    v1339 += 4 * (int)v299;
                    ++v1348;
                    v1349 += 4 * v1342;
                  }
                  while (v1348 < v1346);
                  uint64_t v1353 = v1346;
                  int v1333 = *v109;
                  int v1347 = v1346;
                }
                else
                {
                  uint64_t v1353 = 0;
                }
                uint64_t v1336 = v1336 + v1341 - v1353 * v1342;
                uint64_t v1335 = v1335 + v1344 - v1345 * v234[1];
                ++v1334;
              }
              while (v1334 < v1333);
            }
          }
          else if (v114 == 1)
          {
            int v891 = *v109;
            if (*v109)
            {
              unint64_t v892 = 0;
              uint64_t v893 = 0;
              uint64_t v894 = v108[19];
              uint64_t v895 = v233[19];
              uint64_t v896 = v107[19];
              uint64_t v897 = *(void *)v233[3];
              uint64_t v898 = 4 * *(void *)v108[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v899 = 0;
                  int v900 = *(_DWORD *)(v895 + 4 * v893);
                  unsigned int v901 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v896 + v899) = *(_DWORD *)(v894 + v899) ^ v900;
                    --v901;
                    v899 += 4;
                  }
                  while (v901 > 1);
                  int v891 = *v109;
                }
                v893 += v897;
                ++v892;
                v896 += 4 * (int)v299;
                v894 += v898;
              }
              while (v892 < v891);
            }
          }
          else
          {
            unint64_t v1644 = v107[6];
            if (v1644)
            {
              unint64_t v1663 = 0;
              uint64_t v1588 = v233[19];
              uint64_t v1602 = v108[19];
              uint64_t v1354 = v107[19];
              do
              {
                uint64_t v1355 = 0;
                if ((v111 & 0x80000000) == 0)
                {
                  uint64_t v1356 = v108[3];
                  uint64_t v1357 = v111;
                  int v1358 = v1663;
                  do
                  {
                    ldiv_t v1359 = ldiv(v1358, v109[v1357]);
                    int v1358 = v1359.quot;
                    v1355 += *(void *)(v1356 + 8 * v1357--) * v1359.rem;
                  }
                  while (v1357 != -1);
                }
                uint64_t v1360 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1361) = 0;
                }
                else
                {
                  uint64_t v1361 = 0;
                  uint64_t v1362 = v233[3];
                  int v1363 = v1663;
                  do
                  {
                    ldiv_t v1364 = ldiv(v1363, v234[v1360]);
                    int v1363 = v1364.quot;
                    v1361 += *(void *)(v1362 + 8 * v1360--) * v1364.rem;
                  }
                  while (v1360 != -1);
                }
                uint64_t v111 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1365 = 0;
                  int v1366 = *(_DWORD *)(v1588 + 4 * (int)v1361);
                  unsigned int v1367 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1354 + v1365) = *(_DWORD *)(v1602 + 4 * (int)v1355 + v1365) ^ v1366;
                    --v1367;
                    v1365 += 4;
                  }
                  while (v1367 > 1);
                }
                v1354 += 4 * (int)v299;
                v1663 += (int)v299;
              }
              while (v1663 < v1644);
            }
          }
          break;
        case 3:
          if (v114 == 2)
          {
            int v1095 = *v109;
            if (*v109)
            {
              unint64_t v1096 = 0;
              uint64_t v1097 = 0;
              uint64_t v1098 = 0;
              uint64_t v1099 = v108[19];
              uint64_t v1100 = v233[19];
              uint64_t v1101 = v107[19];
              uint64_t v1102 = (uint64_t *)v108[3];
              uint64_t v1103 = *v1102;
              uint64_t v1104 = v1102[1];
              uint64_t v1105 = (uint64_t *)v233[3];
              uint64_t v1106 = *v1105;
              uint64_t v1107 = v1105[1];
              int v1108 = v109[1];
              int v1109 = v1108;
              do
              {
                if (v1109)
                {
                  unint64_t v1110 = 0;
                  uint64_t v1111 = v1100 + 4 * v1097;
                  uint64_t v1112 = v1099 + 4 * v1098;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1113 = 0;
                      unsigned int v1114 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1101 + v1113) = *(_DWORD *)(v1111 + v1113) ^ *(_DWORD *)(v1112 + v1113);
                        --v1114;
                        v1113 += 4;
                      }
                      while (v1114 > 1);
                      int v1108 = v109[1];
                    }
                    v1098 += v1104;
                    v1097 += v1107;
                    v1101 += 4 * (int)v299;
                    ++v1110;
                    v1111 += 4 * v1107;
                    v1112 += 4 * v1104;
                  }
                  while (v1110 < v1108);
                  uint64_t v1115 = v1108;
                  int v1095 = *v109;
                  int v1109 = v1108;
                }
                else
                {
                  uint64_t v1115 = 0;
                }
                uint64_t v1098 = v1098 + v1103 - v1115 * v1104;
                uint64_t v1097 = v1097 + v1106 - v1107 * v234[1];
                ++v1096;
              }
              while (v1096 < v1095);
            }
          }
          else if (v114 == 1)
          {
            int v348 = *v109;
            if (*v109)
            {
              unint64_t v349 = 0;
              uint64_t v350 = v108[19];
              uint64_t v351 = v233[19];
              uint64_t v352 = v107[19];
              uint64_t v353 = 4 * *(void *)v233[3];
              uint64_t v354 = 4 * *(void *)v108[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v355 = 0;
                  unsigned int v356 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v352 + v355) = *(_DWORD *)(v351 + v355) ^ *(_DWORD *)(v350 + v355);
                    --v356;
                    v355 += 4;
                  }
                  while (v356 > 1);
                  int v348 = *v109;
                }
                ++v349;
                v352 += 4 * (int)v299;
                v351 += v353;
                v350 += v354;
              }
              while (v349 < v348);
            }
          }
          else
          {
            unint64_t v1639 = v107[6];
            if (v1639)
            {
              unint64_t v1658 = 0;
              uint64_t v1582 = v233[19];
              uint64_t v1596 = v108[19];
              uint64_t v1116 = v107[19];
              do
              {
                uint64_t v1117 = 0;
                if ((v111 & 0x80000000) == 0)
                {
                  uint64_t v1118 = v108[3];
                  uint64_t v1119 = v111;
                  int v1120 = v1658;
                  do
                  {
                    ldiv_t v1121 = ldiv(v1120, v109[v1119]);
                    int v1120 = v1121.quot;
                    v1117 += *(void *)(v1118 + 8 * v1119--) * v1121.rem;
                  }
                  while (v1119 != -1);
                }
                uint64_t v1122 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1123) = 0;
                }
                else
                {
                  uint64_t v1123 = 0;
                  uint64_t v1124 = v233[3];
                  int v1125 = v1658;
                  do
                  {
                    ldiv_t v1126 = ldiv(v1125, v234[v1122]);
                    int v1125 = v1126.quot;
                    v1123 += *(void *)(v1124 + 8 * v1122--) * v1126.rem;
                  }
                  while (v1122 != -1);
                }
                uint64_t v111 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1127 = 0;
                  unsigned int v1128 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1116 + v1127) = *(_DWORD *)(v1582 + 4 * (int)v1123 + v1127) ^ *(_DWORD *)(v1596 + 4 * (int)v1117 + v1127);
                    --v1128;
                    v1127 += 4;
                  }
                  while (v1128 > 1);
                }
                v1116 += 4 * (int)v299;
                v1658 += (int)v299;
              }
              while (v1658 < v1639);
            }
          }
          break;
        default:
LABEL_308:
          switch(v295)
          {
            case 1uLL:
              uint64_t v300 = v107[6];
              if (v300)
              {
                v301 = (_DWORD *)v108[19];
                v302 = (_DWORD *)v233[19];
                uint64_t v303 = (int *)v107[19];
                uint64_t v304 = 4 * *(void *)v233[3];
                uint64_t v305 = 4 * *(void *)v108[3];
                do
                {
                  *v303++ = *v302 ^ *v301;
                  v302 = (_DWORD *)((char *)v302 + v304);
                  v301 = (_DWORD *)((char *)v301 + v305);
                  --v300;
                }
                while (v300);
              }
              break;
            case 2uLL:
              int v562 = *v109;
              if (*v109)
              {
                unint64_t v563 = 0;
                uint64_t v564 = 0;
                uint64_t v565 = 0;
                uint64_t v566 = 0;
                uint64_t v567 = v108[19];
                uint64_t v568 = v233[19];
                uint64_t v569 = v107[19];
                BOOL v570 = (uint64_t *)v108[3];
                uint64_t v571 = *v570;
                uint64_t v572 = v570[1];
                uint64_t v573 = (uint64_t *)v233[3];
                uint64_t v575 = *v573;
                uint64_t v574 = v573[1];
                int v576 = v109[1];
                do
                {
                  if (v576)
                  {
                    for (unint64_t j = 0; j < v576; ++j)
                    {
                      *(_DWORD *)(v569 + 4 * v564 + 4 * j) = *(_DWORD *)(v568 + 4 * v565) ^ *(_DWORD *)(v567 + 4 * v566);
                      v566 += v572;
                      v565 += v574;
                      int v576 = v109[1];
                    }
                    uint64_t v578 = v576;
                    int v562 = *v109;
                    v564 += j;
                  }
                  else
                  {
                    uint64_t v578 = 0;
                  }
                  uint64_t v566 = v566 + v571 - v578 * v572;
                  uint64_t v565 = v565 + v575 - v574 * v234[1];
                  ++v563;
                }
                while (v563 < v562);
              }
              break;
            case 3uLL:
              int v579 = *v109;
              if (*v109)
              {
                unint64_t v580 = 0;
                uint64_t v581 = 0;
                uint64_t v582 = 0;
                uint64_t v583 = 0;
                uint64_t v584 = v108[19];
                uint64_t v585 = v233[19];
                uint64_t v586 = v107[19];
                uint64_t v587 = (uint64_t *)v108[3];
                uint64_t v588 = *v587;
                uint64_t v589 = v587[1];
                uint64_t v590 = (uint64_t *)v233[3];
                uint64_t v591 = *v590;
                uint64_t v592 = v590[1];
                int v593 = v109[1];
                int v594 = v593;
                do
                {
                  if (v594)
                  {
                    unint64_t v595 = 0;
                    uint64_t v596 = v587[2];
                    uint64_t v597 = v590[2];
                    int v598 = v109[2];
                    do
                    {
                      if (v598)
                      {
                        for (unint64_t k = 0; k < v598; ++k)
                        {
                          *(_DWORD *)(v586 + 4 * v581 + 4 * k) = *(_DWORD *)(v585 + 4 * v582) ^ *(_DWORD *)(v584 + 4 * v583);
                          v583 += v596;
                          v582 += v597;
                          int v598 = v109[2];
                        }
                        uint64_t v600 = v598;
                        int v593 = v109[1];
                        v581 += k;
                      }
                      else
                      {
                        uint64_t v600 = 0;
                      }
                      uint64_t v583 = v583 + v589 - v600 * v596;
                      uint64_t v582 = v582 + v592 - v597 * v234[2];
                      ++v595;
                    }
                    while (v595 < v593);
                    uint64_t v601 = v593;
                    int v579 = *v109;
                    int v594 = v593;
                  }
                  else
                  {
                    uint64_t v601 = 0;
                  }
                  uint64_t v583 = v583 + v588 - v601 * v589;
                  uint64_t v582 = v582 + v591 - v592 * v234[1];
                  ++v580;
                }
                while (v580 < v579);
              }
              break;
            case 4uLL:
              int v602 = *v109;
              if (*v109)
              {
                unint64_t v603 = 0;
                uint64_t v604 = 0;
                uint64_t v605 = 0;
                uint64_t v606 = 0;
                uint64_t v607 = v108[19];
                uint64_t v608 = v233[19];
                uint64_t v609 = v107[19];
                uint64_t v610 = (uint64_t *)v108[3];
                uint64_t v611 = *v610;
                uint64_t v612 = v610[1];
                uint64_t v613 = (uint64_t *)v233[3];
                uint64_t v614 = *v613;
                uint64_t v615 = v613[1];
                int v616 = v109[1];
                int v617 = v616;
                do
                {
                  if (v617)
                  {
                    unint64_t v618 = 0;
                    uint64_t v619 = v610[2];
                    uint64_t v620 = v613[2];
                    int v621 = v109[2];
                    int v622 = v621;
                    do
                    {
                      if (v622)
                      {
                        unint64_t v623 = 0;
                        uint64_t v624 = v610[3];
                        uint64_t v625 = v613[3];
                        int v626 = v109[3];
                        do
                        {
                          if (v626)
                          {
                            for (unint64_t m = 0; m < v626; ++m)
                            {
                              *(_DWORD *)(v609 + 4 * v604 + 4 * m) = *(_DWORD *)(v608 + 4 * v605) ^ *(_DWORD *)(v607 + 4 * v606);
                              v606 += v624;
                              v605 += v625;
                              int v626 = v109[3];
                            }
                            uint64_t v628 = v626;
                            int v621 = v109[2];
                            v604 += m;
                          }
                          else
                          {
                            uint64_t v628 = 0;
                          }
                          uint64_t v606 = v606 + v619 - v628 * v624;
                          uint64_t v605 = v605 + v620 - v625 * v234[3];
                          ++v623;
                        }
                        while (v623 < v621);
                        uint64_t v629 = v621;
                        int v616 = v109[1];
                        int v622 = v621;
                      }
                      else
                      {
                        uint64_t v629 = 0;
                      }
                      uint64_t v606 = v606 + v612 - v629 * v619;
                      uint64_t v605 = v605 + v615 - v620 * v234[2];
                      ++v618;
                    }
                    while (v618 < v616);
                    uint64_t v630 = v616;
                    int v602 = *v109;
                    int v617 = v616;
                  }
                  else
                  {
                    uint64_t v630 = 0;
                  }
                  uint64_t v606 = v606 + v611 - v630 * v612;
                  uint64_t v605 = v605 + v614 - v615 * v234[1];
                  ++v603;
                }
                while (v603 < v602);
              }
              break;
            default:
              uint64_t v550 = v107[6];
              if (v550)
              {
                uint64_t v551 = 0;
                uint64_t v1632 = v233[19];
                uint64_t v1654 = v108[19];
                uint64_t v1618 = v107[19];
                do
                {
                  uint64_t v552 = 0;
                  if ((v111 & 0x80000000) == 0)
                  {
                    uint64_t v553 = v108[3];
                    uint64_t v554 = v111;
                    int v555 = v551;
                    do
                    {
                      ldiv_t v556 = ldiv(v555, v109[v554]);
                      int v555 = v556.quot;
                      v552 += *(void *)(v553 + 8 * v554--) * v556.rem;
                    }
                    while (v554 != -1);
                  }
                  uint64_t v557 = v1671;
                  if ((v1671 & 0x80000000) != 0)
                  {
                    LODWORD(v558) = 0;
                  }
                  else
                  {
                    uint64_t v558 = 0;
                    uint64_t v559 = v233[3];
                    int v560 = v551;
                    do
                    {
                      ldiv_t v561 = ldiv(v560, v234[v557]);
                      int v560 = v561.quot;
                      v558 += *(void *)(v559 + 8 * v557--) * v561.rem;
                    }
                    while (v557 != -1);
                  }
                  *(_DWORD *)(v1618 + 4 * v551++) = *(_DWORD *)(v1632 + 4 * (int)v558) ^ *(_DWORD *)(v1654 + 4 * (int)v552);
                  uint64_t v111 = v1686;
                }
                while (v551 != v550);
              }
              break;
          }
          break;
      }
      return;
    case 3:
      unsigned int v15 = *(uint64_t **)a1;
      int v16 = *(uint64_t **)(a1 + 8);
      switch(v17)
      {
        case 0:
          char v18 = **(unsigned char **)(*v16 + 152) ^ **(unsigned char **)(*v15 + 152);
          uint64_t v19 = *(void *)v1;
LABEL_35:
          **(unsigned char **)(v19 + 152) = v18;
          return;
        case 1:
          int v138 = *(_DWORD *)(*v16 + 160);
          if (v138 >= 1)
          {
            char v139 = **(unsigned char **)(*v15 + 152);
            v140 = *(unsigned char **)(*(void *)v1 + 152);
            uint64_t v141 = *(char **)(*v16 + 152);
            unsigned int v142 = v138 + 1;
            do
            {
              char v143 = *v141++;
              *v140++ = v143 ^ v139;
              --v142;
            }
            while (v142 > 1);
          }
          return;
        case 2:
          int v144 = *(_DWORD *)(*v15 + 160);
          if (v144 >= 1)
          {
            char v145 = **(unsigned char **)(*v16 + 152);
            int v146 = *(unsigned char **)(*(void *)v1 + 152);
            unsigned int v147 = *(char **)(*v15 + 152);
            unsigned int v148 = v144 + 1;
            do
            {
              char v149 = *v147++;
              *v146++ = v149 ^ v145;
              --v148;
            }
            while (v148 > 1);
          }
          return;
        case 3:
          int v150 = *(_DWORD *)(*(void *)v1 + 48);
          if (v150 >= 1)
          {
            v151 = *(unsigned char **)(*(void *)v1 + 152);
            unsigned int v152 = *(char **)(*v16 + 152);
            char v153 = *(char **)(*v15 + 152);
            unsigned int v154 = v150 + 1;
            do
            {
              char v156 = *v153++;
              char v155 = v156;
              char v157 = *v152++;
              *v151++ = v157 ^ v155;
              --v154;
            }
            while (v154 > 1);
          }
          return;
        default:
          unsigned int v130 = *(void **)v1;
          uint64_t v131 = *v15;
          int v132 = *(int **)*v15;
          uint64_t v133 = (*(void *)(*v15 + 8) - (void)v132) >> 2;
          int v134 = v133 - 1;
          if ((int)v133 - 1 >= -1) {
            int v134 = -1;
          }
          int v135 = v134 + 1;
          int v136 = v133 + 1;
          break;
      }
      while (1)
      {
        unsigned int v137 = v136 - 2;
        if (v136 - 2 < 0) {
          break;
        }
        --v136;
        if (*(void *)(*(void *)(v131 + 24) + 8 * v137) != *(void *)(v130[3] + 8 * v137)) {
          goto LABEL_195;
        }
      }
      int v136 = v135;
LABEL_195:
      int v241 = (int **)*v16;
      unsigned int v242 = *(int **)*v16;
      uint64_t v243 = (*(void *)(*v16 + 8) - (void)v242) >> 2;
      int v244 = v243 - 1;
      if ((int)v243 - 1 >= -1) {
        int v244 = -1;
      }
      int v245 = v244 + 1;
      int v246 = v243 + 1;
      while (1)
      {
        unsigned int v247 = v246 - 2;
        if (v246 - 2 < 0) {
          break;
        }
        --v246;
        if (*(void *)&v241[3][2 * v247] != *(void *)(v130[3] + 8 * v247)) {
          goto LABEL_228;
        }
      }
      int v246 = v245;
LABEL_228:
      int v268 = v133 + 1;
      while (1)
      {
        unsigned int v269 = v268 - 2;
        if (v268 - 2 < 0) {
          break;
        }
        --v268;
        if (*(void *)(*(void *)(v131 + 24) + 8 * v269)) {
          goto LABEL_253;
        }
      }
      int v268 = v135;
LABEL_253:
      int v278 = v243 + 1;
      while (1)
      {
        int v279 = v278 - 2;
        if (v278 - 2 < 0) {
          break;
        }
        --v278;
        if (*(void *)&v241[3][2 * v279]) {
          goto LABEL_314;
        }
      }
      int v278 = v245;
LABEL_314:
      unint64_t v306 = (uint64_t)(v130[1] - *v130) >> 2;
      if (v136 <= v246) {
        int v307 = v246;
      }
      else {
        int v307 = v136;
      }
      if (v136 <= v278) {
        int v136 = v278;
      }
      if (v268 > v246) {
        int v246 = v268;
      }
      if (v306 > v246)
      {
        int v308 = 1;
      }
      else
      {
        int v246 = (uint64_t)(v130[1] - *v130) >> 2;
        int v308 = 4;
      }
      if (v306 > v136)
      {
        int v309 = 2;
      }
      else
      {
        int v136 = v246;
        int v309 = v308;
      }
      if (v306 > v307)
      {
        int v136 = v307;
        int v309 = 3;
      }
      if (!v136) {
        goto LABEL_331;
      }
      unint64_t v310 = *(void *)(v130[3] + 8 * (v136 - 1));
      if (v310 < 0x10) {
        goto LABEL_331;
      }
      uint64_t v1689 = *(void *)(v130[3] + 8 * (v136 - 1));
      switch(v309)
      {
        case 1:
          if (v136 == 2)
          {
            int v1368 = *v132;
            if (*v132)
            {
              unint64_t v1369 = 0;
              uint64_t v1370 = 0;
              uint64_t v1371 = 0;
              uint64_t v1372 = *(void *)(v131 + 152);
              uint64_t v1373 = v241[19];
              uint64_t v1374 = v130[19];
              do
              {
                if (v132[1])
                {
                  unint64_t v1375 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1376 = 0;
                      char v1377 = *(unsigned char *)(v1372 + v1371);
                      unsigned int v1378 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1374 + v1376) = *((unsigned char *)v1373 + v1370 + v1376) ^ v1377;
                        --v1378;
                        ++v1376;
                      }
                      while (v1378 > 1);
                      uint64_t v131 = *v15;
                      int v241 = (int **)*v16;
                      int v132 = *(int **)*v15;
                    }
                    uint64_t v1379 = *(void **)(v131 + 24);
                    uint64_t v1380 = v1379[1];
                    v1371 += v1380;
                    v1370 += *((void *)v241[3] + 1);
                    v1374 += (int)v310;
                    ++v1375;
                    unint64_t v1381 = v132[1];
                  }
                  while (v1375 < v1381);
                  int v1368 = *v132;
                  unsigned int v242 = *v241;
                }
                else
                {
                  unint64_t v1381 = 0;
                  uint64_t v1379 = *(void **)(v131 + 24);
                  uint64_t v1380 = v1379[1];
                }
                uint64_t v1371 = *v1379 + v1371 - v1381 * v1380;
                uint64_t v1370 = *(void *)v241[3] + v1370 - *((void *)v241[3] + 1) * v242[1];
                ++v1369;
              }
              while (v1369 < v1368);
            }
          }
          else if (v136 == 1)
          {
            int v902 = *v132;
            if (*v132)
            {
              unint64_t v903 = 0;
              uint64_t v904 = 0;
              uint64_t v905 = 0;
              uint64_t v906 = *(void *)(v131 + 152);
              unint64_t v907 = v241[19];
              uint64_t v908 = v130[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v909 = 0;
                  char v910 = *(unsigned char *)(v906 + v905);
                  unsigned int v911 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v908 + v909) = *((unsigned char *)v907 + v904 + v909) ^ v910;
                    --v911;
                    ++v909;
                  }
                  while (v911 > 1);
                  uint64_t v131 = *v15;
                  int v241 = (int **)*v16;
                  int v902 = **(_DWORD **)*v15;
                }
                v905 += **(void **)(v131 + 24);
                v904 += *(void *)v241[3];
                v908 += (int)v310;
                ++v903;
              }
              while (v903 < v902);
            }
          }
          else if (v130[6])
          {
            uint64_t v1629 = v241[19];
            uint64_t v1645 = *(void *)(v131 + 152);
            uint64_t v1664 = (int)v310;
            unint64_t v1682 = 0;
            unsigned int v1614 = v310 + 1;
            uint64_t v1382 = v130[19];
            do
            {
              uint64_t v1383 = *(void *)*v15;
              unint64_t v1384 = (unint64_t)(*(void *)(*v15 + 8) - v1383) >> 2;
              uint64_t v1385 = 0;
              uint64_t v1386 = (v1384 - 1);
              if ((int)v1384 - 1 >= 0)
              {
                uint64_t v1387 = *(void *)(*v15 + 24);
                int v1388 = v1682;
                do
                {
                  ldiv_t v1389 = ldiv(v1388, *(int *)(v1383 + 4 * v1386));
                  int v1388 = v1389.quot;
                  v1385 += *(void *)(v1387 + 8 * v1386--) * v1389.rem;
                }
                while (v1386 != -1);
              }
              uint64_t v1390 = *(void *)*v16;
              unint64_t v1391 = (unint64_t)(*(void *)(*v16 + 8) - v1390) >> 2;
              uint64_t v1392 = 0;
              uint64_t v1393 = (v1391 - 1);
              if ((int)v1391 - 1 >= 0)
              {
                uint64_t v1394 = *(void *)(*v16 + 24);
                int v1395 = v1682;
                do
                {
                  ldiv_t v1396 = ldiv(v1395, *(int *)(v1390 + 4 * v1393));
                  int v1395 = v1396.quot;
                  v1392 += *(void *)(v1394 + 8 * v1393--) * v1396.rem;
                }
                while (v1393 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1397 = 0;
                char v1398 = *(unsigned char *)(v1645 + (int)v1385);
                unsigned int v1399 = v1614;
                do
                {
                  *(unsigned char *)(v1382 + v1397) = *((unsigned char *)v1629 + (int)v1392 + v1397) ^ v1398;
                  --v1399;
                  ++v1397;
                }
                while (v1399 > 1);
                unsigned int v130 = *(void **)v1;
              }
              v1382 += v1664;
              v1682 += v1664;
            }
            while (v1682 < v130[6]);
          }
          break;
        case 2:
          if (v136 == 2)
          {
            int v1400 = *v132;
            if (*v132)
            {
              unint64_t v1401 = 0;
              uint64_t v1402 = 0;
              uint64_t v1403 = 0;
              uint64_t v1404 = *(void *)(v131 + 152);
              unsigned int v1405 = v241[19];
              uint64_t v1406 = v130[19];
              do
              {
                if (v132[1])
                {
                  unint64_t v1407 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1408 = 0;
                      char v1409 = *((unsigned char *)v1405 + v1402);
                      unsigned int v1410 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1406 + v1408) = *(unsigned char *)(v1404 + v1403 + v1408) ^ v1409;
                        --v1410;
                        ++v1408;
                      }
                      while (v1410 > 1);
                      uint64_t v131 = *v15;
                      int v241 = (int **)*v16;
                      int v132 = *(int **)*v15;
                    }
                    v1411 = *(void **)(v131 + 24);
                    uint64_t v1412 = v1411[1];
                    v1403 += v1412;
                    v1402 += *((void *)v241[3] + 1);
                    v1406 += (int)v310;
                    ++v1407;
                    unint64_t v1413 = v132[1];
                  }
                  while (v1407 < v1413);
                  int v1400 = *v132;
                  unsigned int v242 = *v241;
                }
                else
                {
                  unint64_t v1413 = 0;
                  v1411 = *(void **)(v131 + 24);
                  uint64_t v1412 = v1411[1];
                }
                uint64_t v1403 = *v1411 + v1403 - v1413 * v1412;
                uint64_t v1402 = *(void *)v241[3] + v1402 - *((void *)v241[3] + 1) * v242[1];
                ++v1401;
              }
              while (v1401 < v1400);
            }
          }
          else if (v136 == 1)
          {
            int v912 = *v132;
            if (*v132)
            {
              unint64_t v913 = 0;
              uint64_t v914 = 0;
              uint64_t v915 = 0;
              uint64_t v916 = *(void *)(v131 + 152);
              int v917 = v241[19];
              uint64_t v918 = v130[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v919 = 0;
                  char v920 = *((unsigned char *)v917 + v914);
                  unsigned int v921 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v918 + v919) = *(unsigned char *)(v916 + v915 + v919) ^ v920;
                    --v921;
                    ++v919;
                  }
                  while (v921 > 1);
                  uint64_t v131 = *v15;
                  int v241 = (int **)*v16;
                  int v912 = **(_DWORD **)*v15;
                }
                v915 += **(void **)(v131 + 24);
                v914 += *(void *)v241[3];
                v918 += (int)v310;
                ++v913;
              }
              while (v913 < v912);
            }
          }
          else if (v130[6])
          {
            uint64_t v1630 = v241[19];
            uint64_t v1646 = *(void *)(v131 + 152);
            uint64_t v1665 = (int)v310;
            unint64_t v1683 = 0;
            unsigned int v1615 = v310 + 1;
            uint64_t v1414 = v130[19];
            do
            {
              uint64_t v1415 = *(void *)*v15;
              unint64_t v1416 = (unint64_t)(*(void *)(*v15 + 8) - v1415) >> 2;
              uint64_t v1417 = 0;
              uint64_t v1418 = (v1416 - 1);
              if ((int)v1416 - 1 >= 0)
              {
                uint64_t v1419 = *(void *)(*v15 + 24);
                int v1420 = v1683;
                do
                {
                  ldiv_t v1421 = ldiv(v1420, *(int *)(v1415 + 4 * v1418));
                  int v1420 = v1421.quot;
                  v1417 += *(void *)(v1419 + 8 * v1418--) * v1421.rem;
                }
                while (v1418 != -1);
              }
              uint64_t v1422 = *(void *)*v16;
              unint64_t v1423 = (unint64_t)(*(void *)(*v16 + 8) - v1422) >> 2;
              uint64_t v1424 = 0;
              uint64_t v1425 = (v1423 - 1);
              if ((int)v1423 - 1 >= 0)
              {
                uint64_t v1426 = *(void *)(*v16 + 24);
                int v1427 = v1683;
                do
                {
                  ldiv_t v1428 = ldiv(v1427, *(int *)(v1422 + 4 * v1425));
                  int v1427 = v1428.quot;
                  v1424 += *(void *)(v1426 + 8 * v1425--) * v1428.rem;
                }
                while (v1425 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1429 = 0;
                char v1430 = *((unsigned char *)v1630 + (int)v1424);
                unsigned int v1431 = v1615;
                do
                {
                  *(unsigned char *)(v1414 + v1429) = *(unsigned char *)(v1646 + (int)v1417 + v1429) ^ v1430;
                  --v1431;
                  ++v1429;
                }
                while (v1431 > 1);
                unsigned int v130 = *(void **)v1;
              }
              v1414 += v1665;
              v1683 += v1665;
            }
            while (v1683 < v130[6]);
          }
          break;
        case 3:
          if (v136 == 2)
          {
            int v1129 = *v132;
            if (*v132)
            {
              unint64_t v1130 = 0;
              uint64_t v1131 = 0;
              uint64_t v1132 = 0;
              uint64_t v1133 = *(void *)(v131 + 152);
              uint64_t v1134 = v241[19];
              uint64_t v1135 = v130[19];
              do
              {
                if (v132[1])
                {
                  unint64_t v1136 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1137 = 0;
                      unsigned int v1138 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1135 + v1137) = *((unsigned char *)v1134 + v1131 + v1137) ^ *(unsigned char *)(v1133 + v1132 + v1137);
                        --v1138;
                        ++v1137;
                      }
                      while (v1138 > 1);
                      uint64_t v131 = *v15;
                      int v241 = (int **)*v16;
                      int v132 = *(int **)*v15;
                    }
                    int v1139 = *(void **)(v131 + 24);
                    uint64_t v1140 = v1139[1];
                    v1132 += v1140;
                    v1131 += *((void *)v241[3] + 1);
                    v1135 += (int)v310;
                    ++v1136;
                    unint64_t v1141 = v132[1];
                  }
                  while (v1136 < v1141);
                  int v1129 = *v132;
                  unsigned int v242 = *v241;
                }
                else
                {
                  unint64_t v1141 = 0;
                  int v1139 = *(void **)(v131 + 24);
                  uint64_t v1140 = v1139[1];
                }
                uint64_t v1132 = *v1139 + v1132 - v1141 * v1140;
                uint64_t v1131 = *(void *)v241[3] + v1131 - *((void *)v241[3] + 1) * v242[1];
                ++v1130;
              }
              while (v1130 < v1129);
            }
          }
          else if (v136 == 1)
          {
            int v357 = *v132;
            if (*v132)
            {
              unint64_t v358 = 0;
              uint64_t v359 = 0;
              uint64_t v360 = 0;
              uint64_t v361 = *(void *)(v131 + 152);
              int v362 = v241[19];
              uint64_t v363 = v130[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v364 = 0;
                  unsigned int v365 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v363 + v364) = *((unsigned char *)v362 + v359 + v364) ^ *(unsigned char *)(v361 + v360 + v364);
                    --v365;
                    ++v364;
                  }
                  while (v365 > 1);
                  uint64_t v131 = *v15;
                  int v241 = (int **)*v16;
                  int v357 = **(_DWORD **)*v15;
                }
                v360 += **(void **)(v131 + 24);
                v359 += *(void *)v241[3];
                v363 += (int)v310;
                ++v358;
              }
              while (v358 < v357);
            }
          }
          else if (v130[6])
          {
            uint64_t v1626 = v241[19];
            uint64_t v1640 = *(void *)(v131 + 152);
            uint64_t v1659 = (int)v310;
            unint64_t v1681 = 0;
            unsigned int v1611 = v310 + 1;
            uint64_t v1142 = v130[19];
            do
            {
              uint64_t v1143 = *(void *)*v15;
              unint64_t v1144 = (unint64_t)(*(void *)(*v15 + 8) - v1143) >> 2;
              uint64_t v1145 = 0;
              uint64_t v1146 = (v1144 - 1);
              if ((int)v1144 - 1 >= 0)
              {
                uint64_t v1147 = *(void *)(*v15 + 24);
                int v1148 = v1681;
                do
                {
                  ldiv_t v1149 = ldiv(v1148, *(int *)(v1143 + 4 * v1146));
                  int v1148 = v1149.quot;
                  v1145 += *(void *)(v1147 + 8 * v1146--) * v1149.rem;
                }
                while (v1146 != -1);
              }
              uint64_t v1150 = *(void *)*v16;
              unint64_t v1151 = (unint64_t)(*(void *)(*v16 + 8) - v1150) >> 2;
              uint64_t v1152 = 0;
              uint64_t v1153 = (v1151 - 1);
              if ((int)v1151 - 1 >= 0)
              {
                uint64_t v1154 = *(void *)(*v16 + 24);
                int v1155 = v1681;
                do
                {
                  ldiv_t v1156 = ldiv(v1155, *(int *)(v1150 + 4 * v1153));
                  int v1155 = v1156.quot;
                  v1152 += *(void *)(v1154 + 8 * v1153--) * v1156.rem;
                }
                while (v1153 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1157 = 0;
                unsigned int v1158 = v1611;
                do
                {
                  *(unsigned char *)(v1142 + v1157) = *((unsigned char *)v1626 + (int)v1152 + v1157) ^ *(unsigned char *)(v1640
                                                                                                + (int)v1145
                                                                                                + v1157);
                  --v1158;
                  ++v1157;
                }
                while (v1158 > 1);
                unsigned int v130 = *(void **)v1;
              }
              v1142 += v1659;
              v1681 += v1659;
            }
            while (v1681 < v130[6]);
          }
          break;
        default:
LABEL_331:
          switch(v306)
          {
            case 1uLL:
              if (v130[6])
              {
                unint64_t v311 = 0;
                uint64_t v312 = 0;
                uint64_t v313 = 0;
                uint64_t v314 = *(void *)(v131 + 152);
                v315 = v241[19];
                uint64_t v316 = v130[19];
                do
                {
                  *(unsigned char *)(v316 + v311) = *((unsigned char *)v315 + v312) ^ *(unsigned char *)(v314 + v313);
                  v313 += **(void **)(*v15 + 24);
                  v312 += **(void **)(*v16 + 24);
                  ++v311;
                }
                while (v311 < *(void *)(*(void *)v1 + 48));
              }
              break;
            case 2uLL:
              int v647 = *v132;
              if (*v132)
              {
                unint64_t v648 = 0;
                uint64_t v649 = 0;
                uint64_t v650 = 0;
                uint64_t v651 = 0;
                uint64_t v652 = *(void *)(v131 + 152);
                unint64_t v653 = v241[19];
                uint64_t v654 = v130[19];
                do
                {
                  if (v132[1])
                  {
                    unint64_t v655 = 0;
                    do
                    {
                      *(unsigned char *)(v654 + v649 + v655) = *((unsigned char *)v653 + v650) ^ *(unsigned char *)(v652 + v651);
                      uint64_t v131 = *v15;
                      unint64_t v656 = *(void **)(*v15 + 24);
                      uint64_t v657 = v656[1];
                      v651 += v657;
                      int v241 = (int **)*v16;
                      uint64_t v658 = *(int **)(*v16 + 24);
                      uint64_t v659 = *((void *)v658 + 1);
                      v650 += v659;
                      ++v655;
                      int v132 = *(int **)*v15;
                      unint64_t v660 = v132[1];
                    }
                    while (v655 < v660);
                    int v647 = *v132;
                    unsigned int v242 = *v241;
                    v649 += v655;
                  }
                  else
                  {
                    unint64_t v660 = 0;
                    unint64_t v656 = *(void **)(v131 + 24);
                    uint64_t v657 = v656[1];
                    uint64_t v658 = v241[3];
                    uint64_t v659 = *((void *)v658 + 1);
                  }
                  uint64_t v651 = *v656 + v651 - v660 * v657;
                  uint64_t v650 = *(void *)v658 + v650 - v659 * v242[1];
                  ++v648;
                }
                while (v648 < v647);
              }
              break;
            case 3uLL:
              int v661 = *v132;
              if (*v132)
              {
                unint64_t v662 = 0;
                uint64_t v663 = 0;
                uint64_t v664 = 0;
                uint64_t v665 = 0;
                uint64_t v666 = *(void *)(v131 + 152);
                int v667 = v241[19];
                uint64_t v668 = v130[19];
                do
                {
                  if (v132[1])
                  {
                    unint64_t v669 = 0;
                    do
                    {
                      if (v132[2])
                      {
                        unint64_t v670 = 0;
                        do
                        {
                          *(unsigned char *)(v668 + v663 + v670) = *((unsigned char *)v667 + v664) ^ *(unsigned char *)(v666 + v665);
                          uint64_t v131 = *v15;
                          uint64_t v671 = *(void **)(*v15 + 24);
                          uint64_t v672 = v671[2];
                          v665 += v672;
                          int v241 = (int **)*v16;
                          uint64_t v673 = *(int **)(*v16 + 24);
                          uint64_t v674 = *((void *)v673 + 2);
                          v664 += v674;
                          ++v670;
                          int v132 = *(int **)*v15;
                          unint64_t v675 = v132[2];
                        }
                        while (v670 < v675);
                        unsigned int v242 = *v241;
                        v663 += v670;
                      }
                      else
                      {
                        unint64_t v675 = 0;
                        uint64_t v671 = *(void **)(v131 + 24);
                        uint64_t v672 = v671[2];
                        uint64_t v673 = v241[3];
                        uint64_t v674 = *((void *)v673 + 2);
                      }
                      uint64_t v676 = v671[1];
                      uint64_t v665 = v676 + v665 - v675 * v672;
                      uint64_t v664 = *((void *)v673 + 1) + v664 - v674 * v242[2];
                      ++v669;
                      unint64_t v677 = v132[1];
                    }
                    while (v669 < v677);
                    int v661 = *v132;
                  }
                  else
                  {
                    unint64_t v677 = 0;
                    uint64_t v671 = *(void **)(v131 + 24);
                    uint64_t v676 = v671[1];
                  }
                  uint64_t v665 = *v671 + v665 - v677 * v676;
                  uint64_t v664 = *(void *)v241[3] + v664 - *((void *)v241[3] + 1) * v242[1];
                  ++v662;
                }
                while (v662 < v661);
              }
              break;
            case 4uLL:
              int v678 = *v132;
              if (*v132)
              {
                unint64_t v679 = 0;
                uint64_t v680 = 0;
                uint64_t v681 = 0;
                uint64_t v682 = 0;
                uint64_t v683 = *(void *)(v131 + 152);
                unint64_t v684 = v241[19];
                uint64_t v685 = v130[19];
                do
                {
                  if (v132[1])
                  {
                    unint64_t v686 = 0;
                    do
                    {
                      if (v132[2])
                      {
                        unint64_t v687 = 0;
                        do
                        {
                          if (v132[3])
                          {
                            unint64_t v688 = 0;
                            do
                            {
                              *(unsigned char *)(v685 + v680 + v688) = *((unsigned char *)v684 + v681) ^ *(unsigned char *)(v683 + v682);
                              uint64_t v131 = *v15;
                              v689 = *(void **)(*v15 + 24);
                              uint64_t v690 = v689[3];
                              v682 += v690;
                              int v241 = (int **)*v16;
                              unint64_t v691 = *(int **)(*v16 + 24);
                              uint64_t v692 = *((void *)v691 + 3);
                              v681 += v692;
                              ++v688;
                              int v132 = *(int **)*v15;
                              unint64_t v693 = v132[3];
                            }
                            while (v688 < v693);
                            unsigned int v242 = *v241;
                            v680 += v688;
                          }
                          else
                          {
                            unint64_t v693 = 0;
                            v689 = *(void **)(v131 + 24);
                            uint64_t v690 = v689[3];
                            unint64_t v691 = v241[3];
                            uint64_t v692 = *((void *)v691 + 3);
                          }
                          uint64_t v694 = v689[2];
                          uint64_t v682 = v694 + v682 - v693 * v690;
                          uint64_t v681 = *((void *)v691 + 2) + v681 - v692 * v242[3];
                          ++v687;
                          unint64_t v695 = v132[2];
                        }
                        while (v687 < v695);
                      }
                      else
                      {
                        unint64_t v695 = 0;
                        v689 = *(void **)(v131 + 24);
                        uint64_t v694 = v689[2];
                      }
                      uint64_t v682 = v689[1] + v682 - v695 * v694;
                      uint64_t v681 = *((void *)v241[3] + 1) + v681 - *((void *)v241[3] + 2) * v242[2];
                      ++v686;
                      unint64_t v696 = v132[1];
                    }
                    while (v686 < v696);
                    int v678 = *v132;
                  }
                  else
                  {
                    unint64_t v696 = 0;
                  }
                  uint64_t v682 = **(void **)(v131 + 24) + v682 - *(void *)(*(void *)(v131 + 24) + 8) * v696;
                  uint64_t v681 = *(void *)v241[3] + v681 - *((void *)v241[3] + 1) * v242[1];
                  ++v679;
                }
                while (v679 < v678);
              }
              break;
            default:
              if (v130[6])
              {
                unint64_t v631 = 0;
                unint64_t v1676 = v241[19];
                uint64_t v1691 = *(void *)(v131 + 152);
                uint64_t v632 = v130[19];
                do
                {
                  uint64_t v633 = *(void *)*v15;
                  unint64_t v634 = (unint64_t)(*(void *)(*v15 + 8) - v633) >> 2;
                  uint64_t v635 = 0;
                  uint64_t v636 = (v634 - 1);
                  if ((int)v634 - 1 >= 0)
                  {
                    uint64_t v637 = *(void *)(*v15 + 24);
                    int v638 = v631;
                    do
                    {
                      ldiv_t v639 = ldiv(v638, *(int *)(v633 + 4 * v636));
                      int v638 = v639.quot;
                      v635 += *(void *)(v637 + 8 * v636--) * v639.rem;
                    }
                    while (v636 != -1);
                  }
                  uint64_t v640 = *(void *)*v16;
                  unint64_t v641 = (unint64_t)(*(void *)(*v16 + 8) - v640) >> 2;
                  uint64_t v642 = 0;
                  uint64_t v643 = (v641 - 1);
                  if ((int)v641 - 1 >= 0)
                  {
                    uint64_t v644 = *(void *)(*v16 + 24);
                    int v645 = v631;
                    do
                    {
                      ldiv_t v646 = ldiv(v645, *(int *)(v640 + 4 * v643));
                      int v645 = v646.quot;
                      v642 += *(void *)(v644 + 8 * v643--) * v646.rem;
                    }
                    while (v643 != -1);
                  }
                  *(unsigned char *)(v632 + v631++) = *((unsigned char *)v1676 + (int)v642) ^ *(unsigned char *)(v1691 + (int)v635);
                }
                while (v631 < *(void *)(*(void *)v1 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 4:
      char v7 = *(uint64_t **)a1;
      BOOL v6 = *(uint64_t **)(a1 + 8);
      switch(v20)
      {
        case 0:
LABEL_12:
          **(_DWORD **)(*(void *)v1 + 152) = **(_DWORD **)(*v6 + 152) ^ **(_DWORD **)(*v7 + 152);
          return;
        case 1:
          int v167 = *(_DWORD *)(*v6 + 160);
          if (v167 >= 1)
          {
            int v168 = **(_DWORD **)(*v7 + 152);
            v169 = *(int **)(*(void *)v1 + 152);
            v170 = *(int **)(*v6 + 152);
            unsigned int v171 = v167 + 1;
            do
            {
              int v172 = *v170++;
              *v169++ = v172 ^ v168;
              --v171;
            }
            while (v171 > 1);
          }
          return;
        case 2:
          int v173 = *(_DWORD *)(*v7 + 160);
          if (v173 >= 1)
          {
            int v174 = **(_DWORD **)(*v6 + 152);
            int v175 = *(int **)(*(void *)v1 + 152);
            unsigned int v176 = *(int **)(*v7 + 152);
            unsigned int v177 = v173 + 1;
            do
            {
              int v178 = *v176++;
              *v175++ = v178 ^ v174;
              --v177;
            }
            while (v177 > 1);
          }
          return;
        case 3:
          int v179 = *(_DWORD *)(*(void *)v1 + 48);
          if (v179 >= 1)
          {
            v180 = *(int **)(*(void *)v1 + 152);
            unsigned int v181 = *(int **)(*v6 + 152);
            int v182 = *(int **)(*v7 + 152);
            unsigned int v183 = v179 + 1;
            do
            {
              int v185 = *v182++;
              int v184 = v185;
              int v186 = *v181++;
              *v180++ = v186 ^ v184;
              --v183;
            }
            while (v183 > 1);
          }
          return;
        default:
          unsigned int v158 = *(void **)v1;
          char v159 = (void *)*v7;
          int v160 = *(int **)*v7;
          uint64_t v161 = (v159[1] - (void)v160) >> 2;
          uint64_t v162 = (v161 - 1);
          if ((int)v162 >= -1) {
            int v163 = -1;
          }
          else {
            int v163 = v161 - 1;
          }
          int v164 = v163 + 1;
          int v165 = v161 + 1;
          break;
      }
      while (1)
      {
        unsigned int v166 = v165 - 2;
        if (v165 - 2 < 0) {
          break;
        }
        --v165;
        if (*(void *)(v159[3] + 8 * v166) != *(void *)(v158[3] + 8 * v166)) {
          goto LABEL_202;
        }
      }
      int v165 = v164;
LABEL_202:
      int v248 = (void *)*v6;
      int v249 = *(int **)*v6;
      uint64_t v250 = (v248[1] - (void)v249) >> 2;
      uint64_t v251 = (v250 - 1);
      if ((int)v251 >= -1) {
        int v252 = -1;
      }
      else {
        int v252 = v250 - 1;
      }
      int v253 = v252 + 1;
      int v254 = v250 + 1;
      while (1)
      {
        unsigned int v255 = v254 - 2;
        if (v254 - 2 < 0) {
          break;
        }
        --v254;
        if (*(void *)(v248[3] + 8 * v255) != *(void *)(v158[3] + 8 * v255)) {
          goto LABEL_233;
        }
      }
      int v254 = v253;
LABEL_233:
      int v270 = v161 + 1;
      while (1)
      {
        unsigned int v271 = v270 - 2;
        if (v270 - 2 < 0) {
          break;
        }
        --v270;
        if (*(void *)(v159[3] + 8 * v271)) {
          goto LABEL_258;
        }
      }
      int v270 = v164;
LABEL_258:
      int v280 = v250 + 1;
      while (1)
      {
        unsigned int v281 = v280 - 2;
        if (v280 - 2 < 0) {
          break;
        }
        --v280;
        if (*(void *)(v248[3] + 8 * v281)) {
          goto LABEL_337;
        }
      }
      int v280 = v253;
LABEL_337:
      unint64_t v317 = (uint64_t)(v158[1] - *v158) >> 2;
      if (v165 <= v254) {
        int v318 = v254;
      }
      else {
        int v318 = v165;
      }
      if (v165 <= v280) {
        int v165 = v280;
      }
      if (v270 > v254) {
        int v254 = v270;
      }
      if (v317 > v254)
      {
        int v319 = 1;
      }
      else
      {
        int v254 = (uint64_t)(v158[1] - *v158) >> 2;
        int v319 = 4;
      }
      if (v317 > v165)
      {
        int v320 = 2;
      }
      else
      {
        int v165 = v254;
        int v320 = v319;
      }
      if (v317 > v318)
      {
        int v165 = v318;
        int v320 = 3;
      }
      uint64_t v1672 = v251;
      uint64_t v1687 = v162;
      if (!v165) {
        goto LABEL_354;
      }
      unint64_t v321 = *(void *)(v158[3] + 8 * (v165 - 1));
      if (v321 < 0x10) {
        goto LABEL_354;
      }
      switch(v320)
      {
        case 1:
          if (v165 == 2)
          {
            int v1432 = *v160;
            if (*v160)
            {
              unint64_t v1433 = 0;
              uint64_t v1434 = 0;
              uint64_t v1435 = 0;
              uint64_t v1436 = v159[19];
              uint64_t v1437 = v248[19];
              uint64_t v1438 = v158[19];
              unint64_t v1439 = (uint64_t *)v159[3];
              uint64_t v1440 = *v1439;
              uint64_t v1441 = v1439[1];
              uint64_t v1442 = (uint64_t *)v248[3];
              uint64_t v1443 = *v1442;
              uint64_t v1444 = v1442[1];
              int v1445 = v160[1];
              int v1446 = v1445;
              do
              {
                if (v1446)
                {
                  unint64_t v1447 = 0;
                  uint64_t v1448 = v1437 + 4 * v1434;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1449 = 0;
                      int v1450 = *(_DWORD *)(v1436 + 4 * v1435);
                      unsigned int v1451 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1438 + v1449) = *(_DWORD *)(v1448 + v1449) ^ v1450;
                        --v1451;
                        v1449 += 4;
                      }
                      while (v1451 > 1);
                      int v1445 = v160[1];
                    }
                    v1435 += v1441;
                    v1434 += v1444;
                    v1438 += 4 * (int)v321;
                    ++v1447;
                    v1448 += 4 * v1444;
                  }
                  while (v1447 < v1445);
                  uint64_t v1452 = v1445;
                  int v1432 = *v160;
                  int v1446 = v1445;
                }
                else
                {
                  uint64_t v1452 = 0;
                }
                uint64_t v1435 = v1435 + v1440 - v1452 * v1441;
                uint64_t v1434 = v1434 + v1443 - v1444 * v249[1];
                ++v1433;
              }
              while (v1433 < v1432);
            }
          }
          else if (v165 == 1)
          {
            int v922 = *v160;
            if (*v160)
            {
              unint64_t v923 = 0;
              uint64_t v924 = 0;
              uint64_t v925 = v159[19];
              uint64_t v926 = v248[19];
              uint64_t v927 = v158[19];
              uint64_t v928 = *(void *)v159[3];
              uint64_t v929 = 4 * *(void *)v248[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v930 = 0;
                  int v931 = *(_DWORD *)(v925 + 4 * v924);
                  unsigned int v932 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v927 + v930) = *(_DWORD *)(v926 + v930) ^ v931;
                    --v932;
                    v930 += 4;
                  }
                  while (v932 > 1);
                  int v922 = *v160;
                }
                v924 += v928;
                ++v923;
                v927 += 4 * (int)v321;
                v926 += v929;
              }
              while (v923 < v922);
            }
          }
          else
          {
            unint64_t v1647 = v158[6];
            if (v1647)
            {
              unint64_t v1666 = 0;
              uint64_t v1589 = v248[19];
              uint64_t v1603 = v159[19];
              uint64_t v1453 = v158[19];
              do
              {
                uint64_t v1454 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1455 = v159[3];
                  uint64_t v1456 = v162;
                  int v1457 = v1666;
                  do
                  {
                    ldiv_t v1458 = ldiv(v1457, v160[v1456]);
                    int v1457 = v1458.quot;
                    v1454 += *(void *)(v1455 + 8 * v1456--) * v1458.rem;
                  }
                  while (v1456 != -1);
                }
                uint64_t v1459 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1460) = 0;
                }
                else
                {
                  uint64_t v1460 = 0;
                  uint64_t v1461 = v248[3];
                  int v1462 = v1666;
                  do
                  {
                    ldiv_t v1463 = ldiv(v1462, v249[v1459]);
                    int v1462 = v1463.quot;
                    v1460 += *(void *)(v1461 + 8 * v1459--) * v1463.rem;
                  }
                  while (v1459 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1464 = 0;
                  int v1465 = *(_DWORD *)(v1603 + 4 * (int)v1454);
                  unsigned int v1466 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1453 + v1464) = *(_DWORD *)(v1589 + 4 * (int)v1460 + v1464) ^ v1465;
                    --v1466;
                    v1464 += 4;
                  }
                  while (v1466 > 1);
                }
                v1453 += 4 * (int)v321;
                v1666 += (int)v321;
              }
              while (v1666 < v1647);
            }
          }
          break;
        case 2:
          if (v165 == 2)
          {
            int v1467 = *v160;
            if (*v160)
            {
              unint64_t v1468 = 0;
              uint64_t v1469 = 0;
              uint64_t v1470 = 0;
              uint64_t v1471 = v159[19];
              uint64_t v1472 = v248[19];
              uint64_t v1473 = v158[19];
              uint64_t v1474 = (uint64_t *)v159[3];
              uint64_t v1475 = *v1474;
              uint64_t v1476 = v1474[1];
              v1477 = (uint64_t *)v248[3];
              uint64_t v1478 = *v1477;
              uint64_t v1479 = v1477[1];
              int v1480 = v160[1];
              int v1481 = v1480;
              do
              {
                if (v1481)
                {
                  unint64_t v1482 = 0;
                  uint64_t v1483 = v1471 + 4 * v1470;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1484 = 0;
                      int v1485 = *(_DWORD *)(v1472 + 4 * v1469);
                      unsigned int v1486 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1473 + v1484) = *(_DWORD *)(v1483 + v1484) ^ v1485;
                        --v1486;
                        v1484 += 4;
                      }
                      while (v1486 > 1);
                      int v1480 = v160[1];
                    }
                    v1470 += v1476;
                    v1469 += v1479;
                    v1473 += 4 * (int)v321;
                    ++v1482;
                    v1483 += 4 * v1476;
                  }
                  while (v1482 < v1480);
                  uint64_t v1487 = v1480;
                  int v1467 = *v160;
                  int v1481 = v1480;
                }
                else
                {
                  uint64_t v1487 = 0;
                }
                uint64_t v1470 = v1470 + v1475 - v1487 * v1476;
                uint64_t v1469 = v1469 + v1478 - v1479 * v249[1];
                ++v1468;
              }
              while (v1468 < v1467);
            }
          }
          else if (v165 == 1)
          {
            int v933 = *v160;
            if (*v160)
            {
              unint64_t v934 = 0;
              uint64_t v935 = 0;
              uint64_t v936 = v159[19];
              uint64_t v937 = v248[19];
              uint64_t v938 = v158[19];
              uint64_t v939 = *(void *)v248[3];
              uint64_t v940 = 4 * *(void *)v159[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v941 = 0;
                  int v942 = *(_DWORD *)(v937 + 4 * v935);
                  unsigned int v943 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v938 + v941) = *(_DWORD *)(v936 + v941) ^ v942;
                    --v943;
                    v941 += 4;
                  }
                  while (v943 > 1);
                  int v933 = *v160;
                }
                v935 += v939;
                ++v934;
                v938 += 4 * (int)v321;
                v936 += v940;
              }
              while (v934 < v933);
            }
          }
          else
          {
            unint64_t v1648 = v158[6];
            if (v1648)
            {
              unint64_t v1667 = 0;
              uint64_t v1590 = v248[19];
              uint64_t v1604 = v159[19];
              uint64_t v1488 = v158[19];
              do
              {
                uint64_t v1489 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1490 = v159[3];
                  uint64_t v1491 = v162;
                  int v1492 = v1667;
                  do
                  {
                    ldiv_t v1493 = ldiv(v1492, v160[v1491]);
                    int v1492 = v1493.quot;
                    v1489 += *(void *)(v1490 + 8 * v1491--) * v1493.rem;
                  }
                  while (v1491 != -1);
                }
                uint64_t v1494 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1495) = 0;
                }
                else
                {
                  uint64_t v1495 = 0;
                  uint64_t v1496 = v248[3];
                  int v1497 = v1667;
                  do
                  {
                    ldiv_t v1498 = ldiv(v1497, v249[v1494]);
                    int v1497 = v1498.quot;
                    v1495 += *(void *)(v1496 + 8 * v1494--) * v1498.rem;
                  }
                  while (v1494 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1499 = 0;
                  int v1500 = *(_DWORD *)(v1590 + 4 * (int)v1495);
                  unsigned int v1501 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1488 + v1499) = *(_DWORD *)(v1604 + 4 * (int)v1489 + v1499) ^ v1500;
                    --v1501;
                    v1499 += 4;
                  }
                  while (v1501 > 1);
                }
                v1488 += 4 * (int)v321;
                v1667 += (int)v321;
              }
              while (v1667 < v1648);
            }
          }
          break;
        case 3:
          if (v165 == 2)
          {
            int v1159 = *v160;
            if (*v160)
            {
              unint64_t v1160 = 0;
              uint64_t v1161 = 0;
              uint64_t v1162 = 0;
              uint64_t v1163 = v159[19];
              uint64_t v1164 = v248[19];
              uint64_t v1165 = v158[19];
              unint64_t v1166 = (uint64_t *)v159[3];
              uint64_t v1167 = *v1166;
              uint64_t v1168 = v1166[1];
              v1169 = (uint64_t *)v248[3];
              uint64_t v1170 = *v1169;
              uint64_t v1171 = v1169[1];
              int v1172 = v160[1];
              int v1173 = v1172;
              do
              {
                if (v1173)
                {
                  unint64_t v1174 = 0;
                  uint64_t v1175 = v1164 + 4 * v1161;
                  uint64_t v1176 = v1163 + 4 * v1162;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1177 = 0;
                      unsigned int v1178 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1165 + v1177) = *(_DWORD *)(v1175 + v1177) ^ *(_DWORD *)(v1176 + v1177);
                        --v1178;
                        v1177 += 4;
                      }
                      while (v1178 > 1);
                      int v1172 = v160[1];
                    }
                    v1162 += v1168;
                    v1161 += v1171;
                    v1165 += 4 * (int)v321;
                    ++v1174;
                    v1175 += 4 * v1171;
                    v1176 += 4 * v1168;
                  }
                  while (v1174 < v1172);
                  uint64_t v1179 = v1172;
                  int v1159 = *v160;
                  int v1173 = v1172;
                }
                else
                {
                  uint64_t v1179 = 0;
                }
                uint64_t v1162 = v1162 + v1167 - v1179 * v1168;
                uint64_t v1161 = v1161 + v1170 - v1171 * v249[1];
                ++v1160;
              }
              while (v1160 < v1159);
            }
          }
          else if (v165 == 1)
          {
            int v366 = *v160;
            if (*v160)
            {
              unint64_t v367 = 0;
              uint64_t v368 = v159[19];
              uint64_t v369 = v248[19];
              uint64_t v370 = v158[19];
              uint64_t v371 = 4 * *(void *)v248[3];
              uint64_t v372 = 4 * *(void *)v159[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v373 = 0;
                  unsigned int v374 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v370 + v373) = *(_DWORD *)(v369 + v373) ^ *(_DWORD *)(v368 + v373);
                    --v374;
                    v373 += 4;
                  }
                  while (v374 > 1);
                  int v366 = *v160;
                }
                ++v367;
                v370 += 4 * (int)v321;
                v369 += v371;
                v368 += v372;
              }
              while (v367 < v366);
            }
          }
          else
          {
            unint64_t v1641 = v158[6];
            if (v1641)
            {
              unint64_t v1660 = 0;
              uint64_t v1583 = v248[19];
              uint64_t v1597 = v159[19];
              uint64_t v1180 = v158[19];
              do
              {
                uint64_t v1181 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1182 = v159[3];
                  uint64_t v1183 = v162;
                  int v1184 = v1660;
                  do
                  {
                    ldiv_t v1185 = ldiv(v1184, v160[v1183]);
                    int v1184 = v1185.quot;
                    v1181 += *(void *)(v1182 + 8 * v1183--) * v1185.rem;
                  }
                  while (v1183 != -1);
                }
                uint64_t v1186 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1187) = 0;
                }
                else
                {
                  uint64_t v1187 = 0;
                  uint64_t v1188 = v248[3];
                  int v1189 = v1660;
                  do
                  {
                    ldiv_t v1190 = ldiv(v1189, v249[v1186]);
                    int v1189 = v1190.quot;
                    v1187 += *(void *)(v1188 + 8 * v1186--) * v1190.rem;
                  }
                  while (v1186 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1191 = 0;
                  unsigned int v1192 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1180 + v1191) = *(_DWORD *)(v1583 + 4 * (int)v1187 + v1191) ^ *(_DWORD *)(v1597 + 4 * (int)v1181 + v1191);
                    --v1192;
                    v1191 += 4;
                  }
                  while (v1192 > 1);
                }
                v1180 += 4 * (int)v321;
                v1660 += (int)v321;
              }
              while (v1660 < v1641);
            }
          }
          break;
        default:
LABEL_354:
          switch(v317)
          {
            case 1uLL:
              uint64_t v322 = v158[6];
              if (v322)
              {
                unint64_t v323 = (_DWORD *)v159[19];
                uint64_t v324 = (_DWORD *)v248[19];
                uint64_t v325 = (int *)v158[19];
                uint64_t v326 = 4 * *(void *)v248[3];
                uint64_t v327 = 4 * *(void *)v159[3];
                do
                {
                  *v325++ = *v324 ^ *v323;
                  uint64_t v324 = (_DWORD *)((char *)v324 + v326);
                  unint64_t v323 = (_DWORD *)((char *)v323 + v327);
                  --v322;
                }
                while (v322);
              }
              break;
            case 2uLL:
              int v709 = *v160;
              if (*v160)
              {
                unint64_t v710 = 0;
                uint64_t v711 = 0;
                uint64_t v712 = 0;
                uint64_t v713 = 0;
                uint64_t v714 = v159[19];
                uint64_t v715 = v248[19];
                uint64_t v716 = v158[19];
                unint64_t v717 = (uint64_t *)v159[3];
                uint64_t v718 = *v717;
                uint64_t v719 = v717[1];
                uint64_t v720 = (uint64_t *)v248[3];
                uint64_t v722 = *v720;
                uint64_t v721 = v720[1];
                int v723 = v160[1];
                do
                {
                  if (v723)
                  {
                    for (unint64_t n = 0; n < v723; ++n)
                    {
                      *(_DWORD *)(v716 + 4 * v711 + 4 * n) = *(_DWORD *)(v715 + 4 * v712) ^ *(_DWORD *)(v714 + 4 * v713);
                      v713 += v719;
                      v712 += v721;
                      int v723 = v160[1];
                    }
                    uint64_t v725 = v723;
                    int v709 = *v160;
                    v711 += n;
                  }
                  else
                  {
                    uint64_t v725 = 0;
                  }
                  uint64_t v713 = v713 + v718 - v725 * v719;
                  uint64_t v712 = v712 + v722 - v721 * v249[1];
                  ++v710;
                }
                while (v710 < v709);
              }
              break;
            case 3uLL:
              int v726 = *v160;
              if (*v160)
              {
                unint64_t v727 = 0;
                uint64_t v728 = 0;
                uint64_t v729 = 0;
                uint64_t v730 = 0;
                uint64_t v731 = v159[19];
                uint64_t v732 = v248[19];
                uint64_t v733 = v158[19];
                uint64_t v734 = (uint64_t *)v159[3];
                uint64_t v735 = *v734;
                uint64_t v736 = v734[1];
                uint64_t v737 = (uint64_t *)v248[3];
                uint64_t v738 = *v737;
                uint64_t v739 = v737[1];
                int v740 = v160[1];
                int v741 = v740;
                do
                {
                  if (v741)
                  {
                    unint64_t v742 = 0;
                    uint64_t v743 = v734[2];
                    uint64_t v744 = v737[2];
                    int v745 = v160[2];
                    do
                    {
                      if (v745)
                      {
                        for (unint64_t ii = 0; ii < v745; ++ii)
                        {
                          *(_DWORD *)(v733 + 4 * v728 + 4 * ii) = *(_DWORD *)(v732 + 4 * v729) ^ *(_DWORD *)(v731 + 4 * v730);
                          v730 += v743;
                          v729 += v744;
                          int v745 = v160[2];
                        }
                        uint64_t v747 = v745;
                        int v740 = v160[1];
                        v728 += ii;
                      }
                      else
                      {
                        uint64_t v747 = 0;
                      }
                      uint64_t v730 = v730 + v736 - v747 * v743;
                      uint64_t v729 = v729 + v739 - v744 * v249[2];
                      ++v742;
                    }
                    while (v742 < v740);
                    uint64_t v748 = v740;
                    int v726 = *v160;
                    int v741 = v740;
                  }
                  else
                  {
                    uint64_t v748 = 0;
                  }
                  uint64_t v730 = v730 + v735 - v748 * v736;
                  uint64_t v729 = v729 + v738 - v739 * v249[1];
                  ++v727;
                }
                while (v727 < v726);
              }
              break;
            case 4uLL:
              int v749 = *v160;
              if (*v160)
              {
                unint64_t v750 = 0;
                uint64_t v751 = 0;
                uint64_t v752 = 0;
                uint64_t v753 = 0;
                uint64_t v754 = v159[19];
                uint64_t v755 = v248[19];
                uint64_t v756 = v158[19];
                uint64_t v757 = (uint64_t *)v159[3];
                uint64_t v758 = *v757;
                uint64_t v759 = v757[1];
                uint64_t v760 = (uint64_t *)v248[3];
                uint64_t v761 = *v760;
                uint64_t v762 = v760[1];
                int v763 = v160[1];
                int v764 = v763;
                do
                {
                  if (v764)
                  {
                    unint64_t v765 = 0;
                    uint64_t v766 = v757[2];
                    uint64_t v767 = v760[2];
                    int v768 = v160[2];
                    int v769 = v768;
                    do
                    {
                      if (v769)
                      {
                        unint64_t v770 = 0;
                        uint64_t v771 = v757[3];
                        uint64_t v772 = v760[3];
                        int v773 = v160[3];
                        do
                        {
                          if (v773)
                          {
                            for (junint64_t j = 0; jj < v773; ++jj)
                            {
                              *(_DWORD *)(v756 + 4 * v751 + 4 * jj) = *(_DWORD *)(v755 + 4 * v752) ^ *(_DWORD *)(v754 + 4 * v753);
                              v753 += v771;
                              v752 += v772;
                              int v773 = v160[3];
                            }
                            uint64_t v775 = v773;
                            int v768 = v160[2];
                            v751 += jj;
                          }
                          else
                          {
                            uint64_t v775 = 0;
                          }
                          uint64_t v753 = v753 + v766 - v775 * v771;
                          uint64_t v752 = v752 + v767 - v772 * v249[3];
                          ++v770;
                        }
                        while (v770 < v768);
                        uint64_t v776 = v768;
                        int v763 = v160[1];
                        int v769 = v768;
                      }
                      else
                      {
                        uint64_t v776 = 0;
                      }
                      uint64_t v753 = v753 + v759 - v776 * v766;
                      uint64_t v752 = v752 + v762 - v767 * v249[2];
                      ++v765;
                    }
                    while (v765 < v763);
                    uint64_t v777 = v763;
                    int v749 = *v160;
                    int v764 = v763;
                  }
                  else
                  {
                    uint64_t v777 = 0;
                  }
                  uint64_t v753 = v753 + v758 - v777 * v759;
                  uint64_t v752 = v752 + v761 - v762 * v249[1];
                  ++v750;
                }
                while (v750 < v749);
              }
              break;
            default:
              uint64_t v697 = v158[6];
              if (v697)
              {
                uint64_t v698 = 0;
                uint64_t v1633 = v248[19];
                uint64_t v1655 = v159[19];
                uint64_t v1619 = v158[19];
                do
                {
                  uint64_t v699 = 0;
                  if ((v162 & 0x80000000) == 0)
                  {
                    uint64_t v700 = v159[3];
                    uint64_t v701 = v162;
                    int v702 = v698;
                    do
                    {
                      ldiv_t v703 = ldiv(v702, v160[v701]);
                      int v702 = v703.quot;
                      v699 += *(void *)(v700 + 8 * v701--) * v703.rem;
                    }
                    while (v701 != -1);
                  }
                  uint64_t v704 = v1672;
                  if ((v1672 & 0x80000000) != 0)
                  {
                    LODWORD(v705) = 0;
                  }
                  else
                  {
                    uint64_t v705 = 0;
                    uint64_t v706 = v248[3];
                    int v707 = v698;
                    do
                    {
                      ldiv_t v708 = ldiv(v707, v249[v704]);
                      int v707 = v708.quot;
                      v705 += *(void *)(v706 + 8 * v704--) * v708.rem;
                    }
                    while (v704 != -1);
                  }
                  *(_DWORD *)(v1619 + 4 * v698++) = *(_DWORD *)(v1633 + 4 * (int)v705) ^ *(_DWORD *)(v1655 + 4 * (int)v699);
                  uint64_t v162 = v1687;
                }
                while (v698 != v697);
              }
              break;
          }
          break;
      }
      return;
    case 5:
      int v22 = *(uint64_t **)a1;
      uint64_t v21 = *(uint64_t **)(a1 + 8);
      switch(v23)
      {
        case 0:
          **(void **)(*(void *)v1 + 152) = **(void **)(*v21 + 152) ^ **(void **)(*v22 + 152);
          return;
        case 1:
          int v196 = *(_DWORD *)(*v21 + 160);
          if (v196 >= 1)
          {
            uint64_t v197 = **(void **)(*v22 + 152);
            v198 = *(uint64_t **)(*(void *)v1 + 152);
            v199 = *(uint64_t **)(*v21 + 152);
            unsigned int v200 = v196 + 1;
            do
            {
              uint64_t v201 = *v199++;
              *v198++ = v201 ^ v197;
              --v200;
            }
            while (v200 > 1);
          }
          return;
        case 2:
          int v202 = *(_DWORD *)(*v22 + 160);
          if (v202 >= 1)
          {
            uint64_t v203 = **(void **)(*v21 + 152);
            int v204 = *(uint64_t **)(*(void *)v1 + 152);
            unsigned int v205 = *(uint64_t **)(*v22 + 152);
            unsigned int v206 = v202 + 1;
            do
            {
              uint64_t v207 = *v205++;
              *v204++ = v207 ^ v203;
              --v206;
            }
            while (v206 > 1);
          }
          return;
        case 3:
          int v208 = *(_DWORD *)(*(void *)v1 + 48);
          if (v208 >= 1)
          {
            v209 = *(uint64_t **)(*(void *)v1 + 152);
            unsigned int v210 = *(uint64_t **)(*v21 + 152);
            uint64_t v211 = *(uint64_t **)(*v22 + 152);
            unsigned int v212 = v208 + 1;
            do
            {
              uint64_t v214 = *v211++;
              uint64_t v213 = v214;
              uint64_t v215 = *v210++;
              *v209++ = v215 ^ v213;
              --v212;
            }
            while (v212 > 1);
          }
          return;
        default:
          unsigned int v187 = *(void **)v1;
          int v188 = (void *)*v22;
          int v189 = *(int **)*v22;
          uint64_t v190 = (v188[1] - (void)v189) >> 2;
          uint64_t v191 = (v190 - 1);
          if ((int)v191 >= -1) {
            int v192 = -1;
          }
          else {
            int v192 = v190 - 1;
          }
          int v193 = v192 + 1;
          int v194 = v190 + 1;
          break;
      }
      break;
    default:
      exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x25A2B1470](exception, "[BitwiseBinary::eval_cpu] Type not supported");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  while (1)
  {
    unsigned int v195 = v194 - 2;
    if (v194 - 2 < 0) {
      break;
    }
    --v194;
    if (*(void *)(v188[3] + 8 * v195) != *(void *)(v187[3] + 8 * v195)) {
      goto LABEL_210;
    }
  }
  int v194 = v193;
LABEL_210:
  int v256 = (void *)*v21;
  unsigned int v257 = *(int **)*v21;
  uint64_t v258 = (v256[1] - (void)v257) >> 2;
  uint64_t v259 = (v258 - 1);
  if ((int)v259 >= -1) {
    int v260 = -1;
  }
  else {
    int v260 = v258 - 1;
  }
  int v261 = v260 + 1;
  int v262 = v258 + 1;
  while (1)
  {
    unsigned int v263 = v262 - 2;
    if (v262 - 2 < 0) {
      break;
    }
    --v262;
    if (*(void *)(v256[3] + 8 * v263) != *(void *)(v187[3] + 8 * v263)) {
      goto LABEL_238;
    }
  }
  int v262 = v261;
LABEL_238:
  int v272 = v190 + 1;
  while (1)
  {
    unsigned int v273 = v272 - 2;
    if (v272 - 2 < 0) {
      break;
    }
    --v272;
    if (*(void *)(v188[3] + 8 * v273)) {
      goto LABEL_263;
    }
  }
  int v272 = v193;
LABEL_263:
  int v282 = v258 + 1;
  while (1)
  {
    unsigned int v283 = v282 - 2;
    if (v282 - 2 < 0) {
      break;
    }
    --v282;
    if (*(void *)(v256[3] + 8 * v283)) {
      goto LABEL_360;
    }
  }
  int v282 = v261;
LABEL_360:
  unint64_t v328 = (uint64_t)(v187[1] - *v187) >> 2;
  if (v194 <= v262) {
    int v329 = v262;
  }
  else {
    int v329 = v194;
  }
  if (v194 <= v282) {
    int v194 = v282;
  }
  if (v272 > v262) {
    int v262 = v272;
  }
  if (v328 > v262)
  {
    int v330 = 1;
  }
  else
  {
    int v262 = (uint64_t)(v187[1] - *v187) >> 2;
    int v330 = 4;
  }
  if (v328 > v194)
  {
    int v331 = 2;
  }
  else
  {
    int v194 = v262;
    int v331 = v330;
  }
  if (v328 > v329)
  {
    int v194 = v329;
    int v331 = 3;
  }
  uint64_t v1673 = v259;
  uint64_t v1688 = v191;
  if (!v194) {
    goto LABEL_377;
  }
  unint64_t v332 = *(void *)(v187[3] + 8 * (v194 - 1));
  if (v332 < 0x10) {
    goto LABEL_377;
  }
  switch(v331)
  {
    case 1:
      if (v194 == 2)
      {
        uint64_t v1502 = *v189;
        if (v1502)
        {
          uint64_t v1503 = 0;
          uint64_t v1504 = 0;
          uint64_t v1505 = 0;
          uint64_t v1506 = v188[19];
          uint64_t v1507 = v256[19];
          uint64_t v1508 = v187[19];
          unint64_t v1509 = v189[1];
          uint64_t v1510 = (uint64_t *)v188[3];
          uint64_t v1511 = *v1510;
          uint64_t v1512 = v1510[1];
          uint64_t v1513 = (uint64_t *)v256[3];
          uint64_t v1514 = *v1513;
          uint64_t v1515 = v1513[1];
          if (v1509 <= 1) {
            uint64_t v1516 = 1;
          }
          else {
            uint64_t v1516 = v189[1];
          }
          uint64_t v1517 = v1511 - v1512 * v1509;
          uint64_t v1518 = v1514 - v1515 * v257[1];
          do
          {
            if (v1509)
            {
              uint64_t v1519 = 0;
              uint64_t v1520 = v1507 + 8 * v1504;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1521 = 0;
                  uint64_t v1522 = *(void *)(v1506 + 8 * v1505);
                  unsigned int v1523 = v332 + 1;
                  do
                  {
                    *(void *)(v1508 + v1521) = *(void *)(v1520 + v1521) ^ v1522;
                    --v1523;
                    v1521 += 8;
                  }
                  while (v1523 > 1);
                }
                v1505 += v1512;
                v1504 += v1515;
                v1508 += 8 * (int)v332;
                ++v1519;
                v1520 += 8 * v1515;
              }
              while (v1519 != v1516);
            }
            v1505 += v1517;
            v1504 += v1518;
            ++v1503;
          }
          while (v1503 != v1502);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v944 = *v189;
        if (v944)
        {
          uint64_t v945 = 0;
          uint64_t v946 = 0;
          uint64_t v947 = v188[19];
          uint64_t v948 = v256[19];
          uint64_t v949 = v187[19];
          uint64_t v950 = *(void *)v188[3];
          uint64_t v951 = 8 * *(void *)v256[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v952 = 0;
              uint64_t v953 = *(void *)(v947 + 8 * v946);
              unsigned int v954 = v332 + 1;
              do
              {
                *(void *)(v949 + v952) = *(void *)(v948 + v952) ^ v953;
                --v954;
                v952 += 8;
              }
              while (v954 > 1);
            }
            v946 += v950;
            ++v945;
            v949 += 8 * (int)v332;
            v948 += v951;
          }
          while (v945 != v944);
        }
      }
      else
      {
        unint64_t v1649 = v187[6];
        if (v1649)
        {
          unint64_t v1668 = 0;
          uint64_t v1591 = v256[19];
          uint64_t v1605 = v188[19];
          uint64_t v1524 = v187[19];
          do
          {
            uint64_t v1525 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1526 = v188[3];
              uint64_t v1527 = v191;
              int v1528 = v1668;
              do
              {
                ldiv_t v1529 = ldiv(v1528, v189[v1527]);
                int v1528 = v1529.quot;
                v1525 += *(void *)(v1526 + 8 * v1527--) * v1529.rem;
              }
              while (v1527 != -1);
            }
            uint64_t v1530 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1531) = 0;
            }
            else
            {
              uint64_t v1531 = 0;
              uint64_t v1532 = v256[3];
              int v1533 = v1668;
              do
              {
                ldiv_t v1534 = ldiv(v1533, v257[v1530]);
                int v1533 = v1534.quot;
                v1531 += *(void *)(v1532 + 8 * v1530--) * v1534.rem;
              }
              while (v1530 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1535 = 0;
              uint64_t v1536 = *(void *)(v1605 + 8 * (int)v1525);
              unsigned int v1537 = v332 + 1;
              do
              {
                *(void *)(v1524 + v1535) = *(void *)(v1591 + 8 * (int)v1531 + v1535) ^ v1536;
                --v1537;
                v1535 += 8;
              }
              while (v1537 > 1);
            }
            v1524 += 8 * (int)v332;
            v1668 += (int)v332;
          }
          while (v1668 < v1649);
        }
      }
      break;
    case 2:
      if (v194 == 2)
      {
        uint64_t v1538 = *v189;
        if (v1538)
        {
          uint64_t v1539 = 0;
          uint64_t v1540 = 0;
          uint64_t v1541 = 0;
          uint64_t v1542 = v188[19];
          uint64_t v1543 = v256[19];
          uint64_t v1544 = v187[19];
          unint64_t v1545 = v189[1];
          uint64_t v1546 = (uint64_t *)v188[3];
          uint64_t v1547 = *v1546;
          uint64_t v1548 = v1546[1];
          uint64_t v1549 = (uint64_t *)v256[3];
          uint64_t v1550 = *v1549;
          uint64_t v1551 = v1549[1];
          if (v1545 <= 1) {
            uint64_t v1552 = 1;
          }
          else {
            uint64_t v1552 = v189[1];
          }
          uint64_t v1553 = v1547 - v1548 * v1545;
          uint64_t v1554 = v1550 - v1551 * v257[1];
          do
          {
            if (v1545)
            {
              uint64_t v1555 = 0;
              uint64_t v1556 = v1542 + 8 * v1541;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1557 = 0;
                  uint64_t v1558 = *(void *)(v1543 + 8 * v1540);
                  unsigned int v1559 = v332 + 1;
                  do
                  {
                    *(void *)(v1544 + v1557) = *(void *)(v1556 + v1557) ^ v1558;
                    --v1559;
                    v1557 += 8;
                  }
                  while (v1559 > 1);
                }
                v1541 += v1548;
                v1540 += v1551;
                v1544 += 8 * (int)v332;
                ++v1555;
                v1556 += 8 * v1548;
              }
              while (v1555 != v1552);
            }
            v1541 += v1553;
            v1540 += v1554;
            ++v1539;
          }
          while (v1539 != v1538);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v955 = *v189;
        if (v955)
        {
          uint64_t v956 = 0;
          uint64_t v957 = 0;
          uint64_t v958 = v188[19];
          uint64_t v959 = v256[19];
          uint64_t v960 = v187[19];
          uint64_t v961 = *(void *)v256[3];
          uint64_t v962 = 8 * *(void *)v188[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v963 = 0;
              uint64_t v964 = *(void *)(v959 + 8 * v957);
              unsigned int v965 = v332 + 1;
              do
              {
                *(void *)(v960 + v963) = *(void *)(v958 + v963) ^ v964;
                --v965;
                v963 += 8;
              }
              while (v965 > 1);
            }
            v957 += v961;
            ++v956;
            v960 += 8 * (int)v332;
            v958 += v962;
          }
          while (v956 != v955);
        }
      }
      else
      {
        unint64_t v1650 = v187[6];
        if (v1650)
        {
          unint64_t v1669 = 0;
          uint64_t v1592 = v256[19];
          uint64_t v1606 = v188[19];
          uint64_t v1560 = v187[19];
          do
          {
            uint64_t v1561 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1562 = v188[3];
              uint64_t v1563 = v191;
              int v1564 = v1669;
              do
              {
                ldiv_t v1565 = ldiv(v1564, v189[v1563]);
                int v1564 = v1565.quot;
                v1561 += *(void *)(v1562 + 8 * v1563--) * v1565.rem;
              }
              while (v1563 != -1);
            }
            uint64_t v1566 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1567) = 0;
            }
            else
            {
              uint64_t v1567 = 0;
              uint64_t v1568 = v256[3];
              int v1569 = v1669;
              do
              {
                ldiv_t v1570 = ldiv(v1569, v257[v1566]);
                int v1569 = v1570.quot;
                v1567 += *(void *)(v1568 + 8 * v1566--) * v1570.rem;
              }
              while (v1566 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1571 = 0;
              uint64_t v1572 = *(void *)(v1592 + 8 * (int)v1567);
              unsigned int v1573 = v332 + 1;
              do
              {
                *(void *)(v1560 + v1571) = *(void *)(v1606 + 8 * (int)v1561 + v1571) ^ v1572;
                --v1573;
                v1571 += 8;
              }
              while (v1573 > 1);
            }
            v1560 += 8 * (int)v332;
            v1669 += (int)v332;
          }
          while (v1669 < v1650);
        }
      }
      break;
    case 3:
      if (v194 == 2)
      {
        uint64_t v1193 = *v189;
        if (v1193)
        {
          uint64_t v1194 = 0;
          uint64_t v1195 = 0;
          uint64_t v1196 = 0;
          uint64_t v1197 = v188[19];
          uint64_t v1198 = v256[19];
          uint64_t v1199 = v187[19];
          unint64_t v1200 = v189[1];
          uint64_t v1201 = (uint64_t *)v188[3];
          uint64_t v1202 = *v1201;
          uint64_t v1203 = v1201[1];
          unint64_t v1204 = (uint64_t *)v256[3];
          uint64_t v1205 = *v1204;
          uint64_t v1206 = v1204[1];
          if (v1200 <= 1) {
            uint64_t v1207 = 1;
          }
          else {
            uint64_t v1207 = v189[1];
          }
          uint64_t v1208 = v1202 - v1203 * v1200;
          uint64_t v1209 = v1205 - v1206 * v257[1];
          do
          {
            if (v1200)
            {
              uint64_t v1210 = 0;
              uint64_t v1211 = v1198 + 8 * v1195;
              uint64_t v1212 = v1197 + 8 * v1196;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1213 = 0;
                  unsigned int v1214 = v332 + 1;
                  do
                  {
                    *(void *)(v1199 + v1213) = *(void *)(v1211 + v1213) ^ *(void *)(v1212 + v1213);
                    --v1214;
                    v1213 += 8;
                  }
                  while (v1214 > 1);
                }
                v1196 += v1203;
                v1195 += v1206;
                v1199 += 8 * (int)v332;
                ++v1210;
                v1211 += 8 * v1206;
                v1212 += 8 * v1203;
              }
              while (v1210 != v1207);
            }
            v1196 += v1208;
            v1195 += v1209;
            ++v1194;
          }
          while (v1194 != v1193);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v375 = *v189;
        if (v375)
        {
          uint64_t v376 = 0;
          uint64_t v377 = v188[19];
          uint64_t v378 = v256[19];
          uint64_t v379 = v187[19];
          uint64_t v380 = 8 * *(void *)v256[3];
          uint64_t v381 = 8 * *(void *)v188[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v382 = 0;
              unsigned int v383 = v332 + 1;
              do
              {
                *(void *)(v379 + v382) = *(void *)(v378 + v382) ^ *(void *)(v377 + v382);
                --v383;
                v382 += 8;
              }
              while (v383 > 1);
            }
            ++v376;
            v379 += 8 * (int)v332;
            v378 += v380;
            v377 += v381;
          }
          while (v376 != v375);
        }
      }
      else
      {
        unint64_t v1642 = v187[6];
        if (v1642)
        {
          unint64_t v1661 = 0;
          uint64_t v1584 = v256[19];
          uint64_t v1598 = v188[19];
          uint64_t v1215 = v187[19];
          do
          {
            uint64_t v1216 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1217 = v188[3];
              uint64_t v1218 = v191;
              int v1219 = v1661;
              do
              {
                ldiv_t v1220 = ldiv(v1219, v189[v1218]);
                int v1219 = v1220.quot;
                v1216 += *(void *)(v1217 + 8 * v1218--) * v1220.rem;
              }
              while (v1218 != -1);
            }
            uint64_t v1221 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1222) = 0;
            }
            else
            {
              uint64_t v1222 = 0;
              uint64_t v1223 = v256[3];
              int v1224 = v1661;
              do
              {
                ldiv_t v1225 = ldiv(v1224, v257[v1221]);
                int v1224 = v1225.quot;
                v1222 += *(void *)(v1223 + 8 * v1221--) * v1225.rem;
              }
              while (v1221 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1226 = 0;
              unsigned int v1227 = v332 + 1;
              do
              {
                *(void *)(v1215 + v1226) = *(void *)(v1584 + 8 * (int)v1222 + v1226) ^ *(void *)(v1598 + 8 * (int)v1216 + v1226);
                --v1227;
                v1226 += 8;
              }
              while (v1227 > 1);
            }
            v1215 += 8 * (int)v332;
            v1661 += (int)v332;
          }
          while (v1661 < v1642);
        }
      }
      break;
    default:
LABEL_377:
      switch(v328)
      {
        case 1uLL:
          uint64_t v333 = v187[6];
          if (v333)
          {
            uint64_t v334 = (void *)v188[19];
            v335 = (void *)v256[19];
            v336 = (void *)v187[19];
            uint64_t v337 = 8 * *(void *)v256[3];
            uint64_t v338 = 8 * *(void *)v188[3];
            do
            {
              *v336++ = *v335 ^ *v334;
              v335 = (void *)((char *)v335 + v337);
              uint64_t v334 = (void *)((char *)v334 + v338);
              --v333;
            }
            while (v333);
          }
          break;
        case 2uLL:
          uint64_t v790 = *v189;
          if (v790)
          {
            uint64_t v791 = 0;
            uint64_t v792 = 0;
            uint64_t v793 = 0;
            uint64_t v794 = 0;
            uint64_t v795 = v188[19];
            uint64_t v796 = v256[19];
            uint64_t v797 = v187[19];
            unint64_t v798 = v189[1];
            uint64_t v799 = (uint64_t *)v188[3];
            uint64_t v800 = *v799;
            uint64_t v801 = v799[1];
            uint64_t v802 = (uint64_t *)v256[3];
            uint64_t v803 = *v802;
            uint64_t v804 = v802[1];
            uint64_t v805 = v803 - v804 * v257[1];
            if (v798 <= 1) {
              uint64_t v806 = 1;
            }
            else {
              uint64_t v806 = v189[1];
            }
            uint64_t v807 = v800 - v801 * v798;
            do
            {
              if (v798)
              {
                uint64_t v808 = v792 + v806;
                uint64_t v809 = (void *)(v797 + 8 * v792);
                uint64_t v810 = v806;
                do
                {
                  *v809++ = *(void *)(v796 + 8 * v793) ^ *(void *)(v795 + 8 * v794);
                  v794 += v801;
                  v793 += v804;
                  --v810;
                }
                while (v810);
                uint64_t v792 = v808;
              }
              v794 += v807;
              v793 += v805;
              ++v791;
            }
            while (v791 != v790);
          }
          break;
        case 3uLL:
          uint64_t v811 = *v189;
          if (v811)
          {
            uint64_t v812 = 0;
            uint64_t v813 = 0;
            uint64_t v814 = 0;
            uint64_t v815 = 0;
            uint64_t v816 = v188[19];
            uint64_t v817 = v256[19];
            uint64_t v818 = v187[19];
            unint64_t v819 = v189[1];
            unint64_t v820 = (void *)v188[3];
            uint64_t v821 = v820[1];
            uint64_t v822 = (void *)v256[3];
            uint64_t v823 = v822[1];
            uint64_t v824 = *v822 - v823 * v257[1];
            if (v819 <= 1) {
              uint64_t v825 = 1;
            }
            else {
              uint64_t v825 = v189[1];
            }
            unint64_t v826 = *v820 - v821 * v819;
            do
            {
              if (v819)
              {
                uint64_t v827 = 0;
                unint64_t v828 = v189[2];
                uint64_t v829 = v820[2];
                uint64_t v830 = v822[2];
                if (v828 <= 1) {
                  uint64_t v831 = 1;
                }
                else {
                  uint64_t v831 = v189[2];
                }
                uint64_t v832 = v823 - v830 * v257[2];
                do
                {
                  uint64_t v833 = v831;
                  if (v828)
                  {
                    do
                    {
                      *(void *)(v818 + 8 * v813++) = *(void *)(v817 + 8 * v814) ^ *(void *)(v816 + 8 * v815);
                      v815 += v829;
                      v814 += v830;
                      --v833;
                    }
                    while (v833);
                  }
                  v815 += v821 - v829 * v828;
                  v814 += v832;
                  ++v827;
                }
                while (v827 != v825);
              }
              v815 += v826;
              v814 += v824;
              ++v812;
            }
            while (v812 != v811);
          }
          break;
        case 4uLL:
          uint64_t v1692 = *v189;
          if (v1692)
          {
            uint64_t v834 = 0;
            uint64_t v835 = 0;
            uint64_t v836 = 0;
            uint64_t v837 = 0;
            uint64_t v838 = v188[19];
            uint64_t v839 = v256[19];
            uint64_t v840 = v187[19];
            unint64_t v841 = v189[1];
            v842 = (void *)v188[3];
            uint64_t v843 = (void *)v256[3];
            uint64_t v1609 = v843[1];
            uint64_t v1621 = v842[1];
            uint64_t v1657 = *v843 - v1609 * v257[1];
            int v1677 = v189[1];
            if (v841 <= 1) {
              uint64_t v844 = 1;
            }
            else {
              uint64_t v844 = v189[1];
            }
            unint64_t v1635 = *v842 - v842[1] * v841;
            do
            {
              if (v1677)
              {
                uint64_t v845 = 0;
                unint64_t v846 = v189[2];
                uint64_t v847 = v842[2];
                uint64_t v848 = v843[2];
                if (v846 <= 1) {
                  uint64_t v849 = 1;
                }
                else {
                  uint64_t v849 = v189[2];
                }
                uint64_t v850 = v1609 - v848 * v257[2];
                do
                {
                  if (v846)
                  {
                    uint64_t v851 = 0;
                    unint64_t v852 = v189[3];
                    uint64_t v853 = v842[3];
                    uint64_t v854 = v843[3];
                    if (v852 <= 1) {
                      uint64_t v855 = 1;
                    }
                    else {
                      uint64_t v855 = v189[3];
                    }
                    uint64_t v856 = v848 - v854 * v257[3];
                    do
                    {
                      uint64_t v857 = v855;
                      if (v852)
                      {
                        do
                        {
                          *(void *)(v840 + 8 * v835++) = *(void *)(v839 + 8 * v836) ^ *(void *)(v838 + 8 * v837);
                          v837 += v853;
                          v836 += v854;
                          --v857;
                        }
                        while (v857);
                      }
                      v837 += v847 - v853 * v852;
                      v836 += v856;
                      ++v851;
                    }
                    while (v851 != v849);
                  }
                  v837 += v1621 - v847 * v846;
                  v836 += v850;
                  ++v845;
                }
                while (v845 != v844);
              }
              v837 += v1635;
              v836 += v1657;
              ++v834;
            }
            while (v834 != v1692);
          }
          break;
        default:
          uint64_t v778 = v187[6];
          if (v778)
          {
            uint64_t v779 = 0;
            uint64_t v1634 = v256[19];
            uint64_t v1656 = v188[19];
            uint64_t v1620 = v187[19];
            do
            {
              uint64_t v780 = 0;
              if ((v191 & 0x80000000) == 0)
              {
                uint64_t v781 = v188[3];
                uint64_t v782 = v191;
                int v783 = v779;
                do
                {
                  ldiv_t v784 = ldiv(v783, v189[v782]);
                  int v783 = v784.quot;
                  v780 += *(void *)(v781 + 8 * v782--) * v784.rem;
                }
                while (v782 != -1);
              }
              uint64_t v785 = v1673;
              if ((v1673 & 0x80000000) != 0)
              {
                LODWORD(v786) = 0;
              }
              else
              {
                uint64_t v786 = 0;
                uint64_t v787 = v256[3];
                int v788 = v779;
                do
                {
                  ldiv_t v789 = ldiv(v788, v257[v785]);
                  int v788 = v789.quot;
                  v786 += *(void *)(v787 + 8 * v785--) * v789.rem;
                }
                while (v785 != -1);
              }
              *(void *)(v1620 + 8 * v779++) = *(void *)(v1634 + 8 * (int)v786) ^ *(void *)(v1656
                                                                                                 + 8 * (int)v780);
              uint64_t v191 = v1688;
            }
            while (v779 != v778);
          }
          break;
      }
      return;
  }
}

void sub_256E600F0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::LeftShift>(uint64_t a1)
{
  v1 = *(mlx::core::array **)(a1 + 16);
  switch(*(_DWORD *)(*(void *)v1 + 56))
  {
    case 0:
      v4 = *(uint64_t **)a1;
      v3 = *(uint64_t **)(a1 + 8);
      switch(binary_op_type)
      {
        case 0:
          **(unsigned char **)(*(void *)v1 + 152) = **(unsigned char **)(*v4 + 152);
          goto LABEL_31;
        case 1:
          if ((int)*(void *)(*v3 + 160) >= 1) {
            memset(*(void **)(*(void *)v1 + 152), **(unsigned __int8 **)(*v4 + 152), *(void *)(*v3 + 160));
          }
          goto LABEL_31;
        case 2:
          int v33 = *(_DWORD *)(*v4 + 160);
          if (v33 >= 1)
          {
            int v34 = *(unsigned char **)(*(void *)v1 + 152);
            int v35 = *(char **)(*v4 + 152);
            unsigned int v36 = v33 + 1;
            do
            {
              char v37 = *v35++;
              *v34++ = v37;
              --v36;
            }
            while (v36 > 1);
          }
          goto LABEL_31;
        case 3:
          int v38 = *(_DWORD *)(*(void *)v1 + 48);
          if (v38 >= 1)
          {
            int v39 = *(unsigned char **)(*(void *)v1 + 152);
            int v40 = *(char **)(*v4 + 152);
            unsigned int v41 = v38 + 1;
            do
            {
              char v42 = *v40++;
              *v39++ = v42;
              --v41;
            }
            while (v41 > 1);
          }
          goto LABEL_31;
        default:
          v24 = *(void **)v1;
          uint64_t v25 = *v4;
          v26 = *(int **)*v4;
          uint64_t v27 = (*(void *)(*v4 + 8) - (void)v26) >> 2;
          uint64_t v28 = (v27 - 1);
          if ((int)v28 >= -1) {
            int v29 = -1;
          }
          else {
            int v29 = v27 - 1;
          }
          int v30 = v29 + 1;
          int v31 = v27 + 1;
          break;
      }
      while (1)
      {
        unsigned int v32 = v31 - 2;
        if (v31 - 2 < 0) {
          break;
        }
        --v31;
        if (*(void *)(*(void *)(v25 + 24) + 8 * v32) != *(void *)(v24[3] + 8 * v32)) {
          goto LABEL_177;
        }
      }
      int v31 = v30;
LABEL_177:
      uint64_t v215 = *v3;
      uint64_t v216 = (*(void *)(*v3 + 8) - *(void *)*v3) >> 2;
      int v217 = v216 - 1;
      if ((int)v216 - 1 >= -1) {
        int v217 = -1;
      }
      int v218 = v217 + 1;
      int v219 = v216 + 1;
      while (1)
      {
        unsigned int v220 = v219 - 2;
        if (v219 - 2 < 0) {
          break;
        }
        --v219;
        if (*(void *)(*(void *)(v215 + 24) + 8 * v220) != *(void *)(v24[3] + 8 * v220)) {
          goto LABEL_215;
        }
      }
      int v219 = v218;
LABEL_215:
      int v252 = v27 + 1;
      while (1)
      {
        unsigned int v253 = v252 - 2;
        if (v252 - 2 < 0) {
          break;
        }
        --v252;
        if (*(void *)(*(void *)(v25 + 24) + 8 * v253)) {
          goto LABEL_240;
        }
      }
      int v252 = v30;
LABEL_240:
      int v262 = v216 + 1;
      while (1)
      {
        unsigned int v263 = v262 - 2;
        if (v262 - 2 < 0) {
          break;
        }
        --v262;
        if (*(void *)(*(void *)(v215 + 24) + 8 * v263)) {
          goto LABEL_265;
        }
      }
      int v262 = v218;
LABEL_265:
      unint64_t v272 = (uint64_t)(v24[1] - *v24) >> 2;
      if (v31 <= v219) {
        int v273 = v219;
      }
      else {
        int v273 = v31;
      }
      if (v31 <= v262) {
        int v31 = v262;
      }
      if (v252 > v219) {
        int v219 = v252;
      }
      if (v272 > v219)
      {
        int v274 = 1;
      }
      else
      {
        int v219 = (uint64_t)(v24[1] - *v24) >> 2;
        int v274 = 4;
      }
      if (v272 > v31)
      {
        int v275 = 2;
      }
      else
      {
        int v31 = v219;
        int v275 = v274;
      }
      if (v272 > v273)
      {
        int v31 = v273;
        int v275 = 3;
      }
      uint64_t v1574 = v28;
      if (!v31) {
        goto LABEL_282;
      }
      unint64_t v276 = *(void *)(v24[3] + 8 * (v31 - 1));
      if (v276 < 0x10) {
        goto LABEL_282;
      }
      switch(v275)
      {
        case 1:
          if (v31 == 2)
          {
            uint64_t v1581 = *v26;
            if (v1581)
            {
              uint64_t v1169 = 0;
              uint64_t v1170 = 0;
              uint64_t v1171 = *(void *)(v25 + 152);
              int v1172 = (char *)v24[19];
              unint64_t v1173 = v26[1];
              unint64_t v1174 = *(uint64_t **)(v25 + 24);
              uint64_t v1175 = *v1174;
              uint64_t v1176 = v1174[1];
              if (v1173 <= 1) {
                uint64_t v1177 = 1;
              }
              else {
                uint64_t v1177 = v26[1];
              }
              uint64_t v1546 = v1177;
              int v1568 = v26[1];
              uint64_t v1528 = v1175 - v1176 * v1173;
              do
              {
                uint64_t v1178 = v1546;
                if (v1568)
                {
                  do
                  {
                    if ((int)v276 >= 1) {
                      memset(v1172, *(unsigned __int8 *)(v1171 + v1170), v276);
                    }
                    v1170 += v1176;
                    v1172 += (int)v276;
                    --v1178;
                  }
                  while (v1178);
                }
                v1170 += v1528;
                ++v1169;
              }
              while (v1169 != v1581);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v822 = *v26;
            if (v822)
            {
              uint64_t v823 = *(unsigned __int8 **)(v25 + 152);
              uint64_t v824 = (char *)v24[19];
              uint64_t v825 = **(void **)(v25 + 24);
              do
              {
                if ((int)v276 >= 1) {
                  memset(v824, *v823, v276);
                }
                v824 += (int)v276;
                v823 += v825;
                --v822;
              }
              while (v822);
            }
          }
          else
          {
            unint64_t v1569 = v24[6];
            if (v1569)
            {
              unint64_t v1179 = 0;
              uint64_t v1180 = (char *)v24[19];
              uint64_t v1547 = *(void *)(v25 + 152);
              do
              {
                uint64_t v1181 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1182 = *(void *)(v25 + 24);
                  int quot = v1179;
                  do
                  {
                    ldiv_t v1184 = ldiv(quot, v26[v28]);
                    int quot = v1184.quot;
                    v1181 += *(void *)(v1182 + 8 * v28--) * v1184.rem;
                  }
                  while (v28 != -1);
                }
                if ((int)v276 >= 1) {
                  memset(v1180, *(unsigned __int8 *)(v1547 + (int)v1181), v276);
                }
                v1180 += (int)v276;
                v1179 += (int)v276;
                uint64_t v28 = v1574;
              }
              while (v1179 < v1569);
            }
          }
          break;
        case 2:
          if (v31 == 2)
          {
            uint64_t v1185 = *v26;
            if (v1185)
            {
              uint64_t v1186 = 0;
              uint64_t v1187 = 0;
              uint64_t v1188 = *(void *)(v25 + 152);
              uint64_t v1189 = v24[19];
              unint64_t v1190 = v26[1];
              uint64_t v1191 = *(uint64_t **)(v25 + 24);
              uint64_t v1193 = *v1191;
              uint64_t v1192 = v1191[1];
              if (v1190 <= 1) {
                uint64_t v1194 = 1;
              }
              else {
                uint64_t v1194 = v26[1];
              }
              uint64_t v1195 = v1193 - v1192 * v1190;
              do
              {
                if (v1190)
                {
                  uint64_t v1196 = 0;
                  uint64_t v1197 = v1188 + v1187;
                  do
                  {
                    if ((int)v276 >= 1)
                    {
                      uint64_t v1198 = 0;
                      unsigned int v1199 = v276 + 1;
                      do
                      {
                        *(unsigned char *)(v1189 + v1198) = *(unsigned char *)(v1197 + v1198);
                        --v1199;
                        ++v1198;
                      }
                      while (v1199 > 1);
                    }
                    v1187 += v1192;
                    v1189 += (int)v276;
                    ++v1196;
                    v1197 += v1192;
                  }
                  while (v1196 != v1194);
                }
                v1187 += v1195;
                ++v1186;
              }
              while (v1186 != v1185);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v826 = *v26;
            if (v826)
            {
              uint64_t v827 = 0;
              uint64_t v828 = *(void *)(v25 + 152);
              uint64_t v829 = v24[19];
              uint64_t v830 = **(void **)(v25 + 24);
              do
              {
                if ((int)v276 >= 1)
                {
                  uint64_t v831 = 0;
                  unsigned int v832 = v276 + 1;
                  do
                  {
                    *(unsigned char *)(v829 + v831) = *(unsigned char *)(v828 + v831);
                    --v832;
                    ++v831;
                  }
                  while (v832 > 1);
                }
                v829 += (int)v276;
                ++v827;
                v828 += v830;
              }
              while (v827 != v826);
            }
          }
          else
          {
            unint64_t v1570 = v24[6];
            if (v1570)
            {
              unint64_t v1200 = 0;
              uint64_t v1548 = *(void *)(v25 + 152);
              uint64_t v1201 = v24[19];
              do
              {
                uint64_t v1202 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1203 = *(void *)(v25 + 24);
                  int v1204 = v1200;
                  do
                  {
                    ldiv_t v1205 = ldiv(v1204, v26[v28]);
                    int v1204 = v1205.quot;
                    v1202 += *(void *)(v1203 + 8 * v28--) * v1205.rem;
                  }
                  while (v28 != -1);
                }
                if ((int)v276 >= 1)
                {
                  uint64_t v1206 = 0;
                  unsigned int v1207 = v276 + 1;
                  do
                  {
                    *(unsigned char *)(v1201 + v1206) = *(unsigned char *)(v1548 + (int)v1202 + v1206);
                    --v1207;
                    ++v1206;
                  }
                  while (v1207 > 1);
                }
                v1201 += (int)v276;
                v1200 += (int)v276;
                uint64_t v28 = v1574;
              }
              while (v1200 < v1570);
            }
          }
          break;
        case 3:
          if (v31 == 2)
          {
            uint64_t v1013 = *v26;
            if (v1013)
            {
              uint64_t v1014 = 0;
              uint64_t v1015 = 0;
              uint64_t v1016 = *(void *)(v25 + 152);
              uint64_t v1017 = v24[19];
              unint64_t v1018 = v26[1];
              unint64_t v1019 = *(uint64_t **)(v25 + 24);
              uint64_t v1021 = *v1019;
              uint64_t v1020 = v1019[1];
              if (v1018 <= 1) {
                uint64_t v1022 = 1;
              }
              else {
                uint64_t v1022 = v26[1];
              }
              uint64_t v1023 = v1021 - v1020 * v1018;
              do
              {
                if (v1018)
                {
                  uint64_t v1024 = 0;
                  uint64_t v1025 = v1016 + v1015;
                  do
                  {
                    if ((int)v276 >= 1)
                    {
                      uint64_t v1026 = 0;
                      unsigned int v1027 = v276 + 1;
                      do
                      {
                        *(unsigned char *)(v1017 + v1026) = *(unsigned char *)(v1025 + v1026);
                        --v1027;
                        ++v1026;
                      }
                      while (v1027 > 1);
                    }
                    v1015 += v1020;
                    v1017 += (int)v276;
                    ++v1024;
                    v1025 += v1020;
                  }
                  while (v1024 != v1022);
                }
                v1015 += v1023;
                ++v1014;
              }
              while (v1014 != v1013);
            }
          }
          else if (v31 == 1)
          {
            uint64_t v325 = *v26;
            if (v325)
            {
              uint64_t v326 = 0;
              uint64_t v327 = *(void *)(v25 + 152);
              uint64_t v328 = v24[19];
              uint64_t v329 = **(void **)(v25 + 24);
              do
              {
                if ((int)v276 >= 1)
                {
                  uint64_t v330 = 0;
                  unsigned int v331 = v276 + 1;
                  do
                  {
                    *(unsigned char *)(v328 + v330) = *(unsigned char *)(v327 + v330);
                    --v331;
                    ++v330;
                  }
                  while (v331 > 1);
                }
                v328 += (int)v276;
                ++v326;
                v327 += v329;
              }
              while (v326 != v325);
            }
          }
          else
          {
            unint64_t v1566 = v24[6];
            if (v1566)
            {
              unint64_t v1028 = 0;
              uint64_t v1541 = *(void *)(v25 + 152);
              uint64_t v1029 = v24[19];
              do
              {
                uint64_t v1030 = 0;
                if ((v28 & 0x80000000) == 0)
                {
                  uint64_t v1031 = *(void *)(v25 + 24);
                  int v1032 = v1028;
                  do
                  {
                    ldiv_t v1033 = ldiv(v1032, v26[v28]);
                    int v1032 = v1033.quot;
                    v1030 += *(void *)(v1031 + 8 * v28--) * v1033.rem;
                  }
                  while (v28 != -1);
                }
                if ((int)v276 >= 1)
                {
                  uint64_t v1034 = 0;
                  unsigned int v1035 = v276 + 1;
                  do
                  {
                    *(unsigned char *)(v1029 + v1034) = *(unsigned char *)(v1541 + (int)v1030 + v1034);
                    --v1035;
                    ++v1034;
                  }
                  while (v1035 > 1);
                }
                v1029 += (int)v276;
                v1028 += (int)v276;
                uint64_t v28 = v1574;
              }
              while (v1028 < v1566);
            }
          }
          break;
        default:
LABEL_282:
          switch(v272)
          {
            case 1uLL:
              uint64_t v277 = v24[6];
              if (v277)
              {
                int v278 = *(unsigned char **)(v25 + 152);
                int v279 = (unsigned char *)v24[19];
                uint64_t v280 = **(void **)(v25 + 24);
                do
                {
                  *v279++ = *v278;
                  v278 += v280;
                  --v277;
                }
                while (v277);
              }
              break;
            case 2uLL:
              uint64_t v463 = *v26;
              if (v463)
              {
                uint64_t v464 = 0;
                uint64_t v465 = 0;
                uint64_t v466 = 0;
                uint64_t v467 = *(void *)(v25 + 152);
                uint64_t v468 = v24[19];
                unint64_t v469 = v26[1];
                unsigned int v470 = *(uint64_t **)(v25 + 24);
                uint64_t v472 = *v470;
                uint64_t v471 = v470[1];
                if (v469 <= 1) {
                  uint64_t v473 = 1;
                }
                else {
                  uint64_t v473 = v26[1];
                }
                uint64_t v474 = v472 - v471 * v469;
                do
                {
                  if (v469)
                  {
                    uint64_t v475 = v465 + v473;
                    ldiv_t v476 = (unsigned char *)(v468 + v465);
                    uint64_t v477 = v473;
                    do
                    {
                      *v476++ = *(unsigned char *)(v467 + v466);
                      v466 += v471;
                      --v477;
                    }
                    while (v477);
                    uint64_t v465 = v475;
                  }
                  v466 += v474;
                  ++v464;
                }
                while (v464 != v463);
              }
              break;
            case 3uLL:
              uint64_t v478 = *v26;
              if (v478)
              {
                uint64_t v479 = 0;
                uint64_t v480 = 0;
                uint64_t v481 = 0;
                uint64_t v482 = *(void *)(v25 + 152);
                uint64_t v483 = v24[19];
                unint64_t v484 = v26[1];
                uint64_t v485 = *(void **)(v25 + 24);
                uint64_t v486 = v485[1];
                if (v484 <= 1) {
                  uint64_t v487 = 1;
                }
                else {
                  uint64_t v487 = v26[1];
                }
                unint64_t v488 = *v485 - v486 * v484;
                do
                {
                  if (v484)
                  {
                    uint64_t v489 = 0;
                    unint64_t v490 = v26[2];
                    uint64_t v491 = v485[2];
                    if (v490 <= 1) {
                      uint64_t v492 = 1;
                    }
                    else {
                      uint64_t v492 = v26[2];
                    }
                    do
                    {
                      uint64_t v493 = v492;
                      if (v490)
                      {
                        do
                        {
                          *(unsigned char *)(v483 + v480++) = *(unsigned char *)(v482 + v481);
                          v481 += v491;
                          --v493;
                        }
                        while (v493);
                      }
                      v481 += v486 - v491 * v490;
                      ++v489;
                    }
                    while (v489 != v487);
                  }
                  v481 += v488;
                  ++v479;
                }
                while (v479 != v478);
              }
              break;
            case 4uLL:
              uint64_t v494 = *v26;
              if (v494)
              {
                uint64_t v495 = 0;
                uint64_t v496 = 0;
                uint64_t v497 = 0;
                uint64_t v498 = *(void *)(v25 + 152);
                uint64_t v499 = v24[19];
                unint64_t v500 = v26[1];
                uint64_t v501 = *(void **)(v25 + 24);
                uint64_t v502 = v501[1];
                if (v500 <= 1) {
                  uint64_t v503 = 1;
                }
                else {
                  uint64_t v503 = v26[1];
                }
                unint64_t v504 = *v501 - v502 * v500;
                do
                {
                  if (v500)
                  {
                    uint64_t v505 = 0;
                    unint64_t v506 = v26[2];
                    uint64_t v507 = v501[2];
                    if (v506 <= 1) {
                      uint64_t v508 = 1;
                    }
                    else {
                      uint64_t v508 = v26[2];
                    }
                    do
                    {
                      if (v506)
                      {
                        uint64_t v509 = 0;
                        unint64_t v510 = v26[3];
                        uint64_t v511 = v501[3];
                        if (v510 <= 1) {
                          uint64_t v512 = 1;
                        }
                        else {
                          uint64_t v512 = v26[3];
                        }
                        do
                        {
                          uint64_t v513 = v512;
                          if (v510)
                          {
                            do
                            {
                              *(unsigned char *)(v499 + v496++) = *(unsigned char *)(v498 + v497);
                              v497 += v511;
                              --v513;
                            }
                            while (v513);
                          }
                          v497 += v507 - v511 * v510;
                          ++v509;
                        }
                        while (v509 != v508);
                      }
                      v497 += v502 - v507 * v506;
                      ++v505;
                    }
                    while (v505 != v503);
                  }
                  v497 += v504;
                  ++v495;
                }
                while (v495 != v494);
              }
              break;
            default:
              uint64_t v455 = v24[6];
              if (v455)
              {
                uint64_t v456 = 0;
                uint64_t v457 = *(void *)(v25 + 152);
                uint64_t v458 = v24[19];
                do
                {
                  uint64_t v459 = 0;
                  if ((v28 & 0x80000000) == 0)
                  {
                    uint64_t v460 = *(void *)(v25 + 24);
                    int v461 = v456;
                    do
                    {
                      ldiv_t v462 = ldiv(v461, v26[v28]);
                      int v461 = v462.quot;
                      v459 += *(void *)(v460 + 8 * v28--) * v462.rem;
                    }
                    while (v28 != -1);
                  }
                  *(unsigned char *)(v458 + v456++) = *(unsigned char *)(v457 + (int)v459);
                  uint64_t v28 = v1574;
                }
                while (v456 != v455);
              }
              break;
          }
          break;
      }
LABEL_31:
      unsigned int v43 = *(uint64_t **)a1;
      int v44 = *(uint64_t **)(a1 + 8);
      int v45 = *(mlx::core::array **)(a1 + 16);
      switch(v46)
      {
        case 0:
          int v18 = **(unsigned __int8 **)(*v43 + 152) << **(unsigned char **)(*v44 + 152);
          uint64_t v19 = *(void *)v45;
          goto LABEL_33;
        case 1:
          int v55 = *(_DWORD *)(*v44 + 160);
          if (v55 >= 1)
          {
            int v56 = *(unsigned char **)(*(void *)v45 + 152);
            unsigned int v57 = *(char **)(*v44 + 152);
            int v58 = **(unsigned __int8 **)(*v43 + 152);
            unsigned int v59 = v55 + 1;
            do
            {
              char v60 = *v57++;
              *v56++ = v58 << v60;
              --v59;
            }
            while (v59 > 1);
          }
          return;
        case 2:
          int v61 = *(_DWORD *)(*v43 + 160);
          if (v61 >= 1)
          {
            int v62 = *(unsigned char **)(*(void *)v45 + 152);
            int v63 = *(unsigned __int8 **)(*v43 + 152);
            char v64 = **(unsigned char **)(*v44 + 152);
            unsigned int v65 = v61 + 1;
            do
            {
              int v66 = *v63++;
              *v62++ = v66 << v64;
              --v65;
            }
            while (v65 > 1);
          }
          return;
        case 3:
          int v67 = *(_DWORD *)(*(void *)v45 + 48);
          if (v67 >= 1)
          {
            uint64_t v68 = *(unsigned char **)(*(void *)v45 + 152);
            unsigned int v69 = *(char **)(*v44 + 152);
            char v70 = *(unsigned __int8 **)(*v43 + 152);
            unsigned int v71 = v67 + 1;
            do
            {
              char v73 = *v69++;
              char v72 = v73;
              int v74 = *v70++;
              *v68++ = v74 << v72;
              --v71;
            }
            while (v71 > 1);
          }
          return;
        default:
          v47 = *(void **)v45;
          uint64_t v48 = *v43;
          unsigned int v49 = *(int **)*v43;
          uint64_t v50 = (*(void *)(*v43 + 8) - (void)v49) >> 2;
          int v51 = v50 - 1;
          if ((int)v50 - 1 >= -1) {
            int v51 = -1;
          }
          int v52 = v51 + 1;
          int v53 = v50 + 1;
          break;
      }
      while (1)
      {
        unsigned int v54 = v53 - 2;
        if (v53 - 2 < 0) {
          break;
        }
        --v53;
        if (*(void *)(*(void *)(v48 + 24) + 8 * v54) != *(void *)(v47[3] + 8 * v54)) {
          goto LABEL_53;
        }
      }
      int v53 = v52;
LABEL_53:
      unsigned int v75 = (int **)*v44;
      char v76 = *(int **)*v44;
      uint64_t v77 = (*(void *)(*v44 + 8) - (void)v76) >> 2;
      int v78 = v77 - 1;
      if ((int)v77 - 1 >= -1) {
        int v78 = -1;
      }
      int v79 = v78 + 1;
      int v80 = v77 + 1;
      while (1)
      {
        unsigned int v81 = v80 - 2;
        if (v80 - 2 < 0) {
          break;
        }
        --v80;
        if (*(void *)&v75[3][2 * v81] != *(void *)(v47[3] + 8 * v81)) {
          goto LABEL_60;
        }
      }
      int v80 = v79;
LABEL_60:
      int v82 = v50 + 1;
      while (1)
      {
        unsigned int v83 = v82 - 2;
        if (v82 - 2 < 0) {
          break;
        }
        --v82;
        if (*(void *)(*(void *)(v48 + 24) + 8 * v83)) {
          goto LABEL_65;
        }
      }
      int v82 = v52;
LABEL_65:
      int v84 = v77 + 1;
      while (1)
      {
        int v85 = v84 - 2;
        if (v84 - 2 < 0) {
          break;
        }
        --v84;
        if (*(void *)&v75[3][2 * v85]) {
          goto LABEL_70;
        }
      }
      int v84 = v79;
LABEL_70:
      unint64_t v86 = (uint64_t)(v47[1] - *v47) >> 2;
      if (v53 <= v80) {
        int v87 = v80;
      }
      else {
        int v87 = v53;
      }
      if (v53 <= v84) {
        int v53 = v84;
      }
      if (v82 > v80) {
        int v80 = v82;
      }
      if (v86 > v80)
      {
        int v88 = 1;
      }
      else
      {
        int v80 = (uint64_t)(v47[1] - *v47) >> 2;
        int v88 = 4;
      }
      if (v86 > v53)
      {
        int v89 = 2;
      }
      else
      {
        int v53 = v80;
        int v89 = v88;
      }
      if (v86 > v87)
      {
        int v53 = v87;
        int v89 = 3;
      }
      unsigned int v1573 = v45;
      if (!v53) {
        goto LABEL_87;
      }
      unint64_t v90 = *(void *)(v47[3] + 8 * (v53 - 1));
      if (v90 < 0x10) {
        goto LABEL_87;
      }
      switch(v89)
      {
        case 1:
          if (v53 == 2)
          {
            int v949 = *v49;
            if (*v49)
            {
              unint64_t v950 = 0;
              uint64_t v951 = 0;
              uint64_t v952 = 0;
              uint64_t v953 = *(void *)(v48 + 152);
              unsigned int v954 = v75[19];
              uint64_t v955 = v47[19];
              do
              {
                if (v49[1])
                {
                  unint64_t v956 = 0;
                  do
                  {
                    if ((int)v90 >= 1)
                    {
                      uint64_t v957 = 0;
                      int v958 = *(unsigned __int8 *)(v953 + v952);
                      unsigned int v959 = v90 + 1;
                      do
                      {
                        *(unsigned char *)(v955 + v957) = v958 << *((unsigned char *)v954 + v951 + v957);
                        --v959;
                        ++v957;
                      }
                      while (v959 > 1);
                      uint64_t v48 = *v43;
                      unsigned int v75 = (int **)*v44;
                      unsigned int v49 = *(int **)*v43;
                    }
                    uint64_t v960 = *(void **)(v48 + 24);
                    uint64_t v961 = v960[1];
                    v952 += v961;
                    v951 += *((void *)v75[3] + 1);
                    v955 += (int)v90;
                    ++v956;
                    unint64_t v962 = v49[1];
                  }
                  while (v956 < v962);
                  int v949 = *v49;
                  char v76 = *v75;
                }
                else
                {
                  unint64_t v962 = 0;
                  uint64_t v960 = *(void **)(v48 + 24);
                  uint64_t v961 = v960[1];
                }
                uint64_t v952 = *v960 + v952 - v962 * v961;
                uint64_t v951 = *(void *)v75[3] + v951 - *((void *)v75[3] + 1) * v76[1];
                ++v950;
              }
              while (v950 < v949);
            }
          }
          else if (v53 == 1)
          {
            int v435 = *v49;
            if (*v49)
            {
              unint64_t v436 = 0;
              uint64_t v437 = 0;
              uint64_t v438 = 0;
              uint64_t v439 = *(void *)(v48 + 152);
              unint64_t v440 = v75[19];
              uint64_t v441 = v47[19];
              do
              {
                if ((int)v90 >= 1)
                {
                  uint64_t v442 = 0;
                  int v443 = *(unsigned __int8 *)(v439 + v438);
                  unsigned int v444 = v90 + 1;
                  do
                  {
                    *(unsigned char *)(v441 + v442) = v443 << *((unsigned char *)v440 + v437 + v442);
                    --v444;
                    ++v442;
                  }
                  while (v444 > 1);
                  uint64_t v48 = *v43;
                  unsigned int v75 = (int **)*v44;
                  int v435 = **(_DWORD **)*v43;
                }
                v438 += **(void **)(v48 + 24);
                v437 += *(void *)v75[3];
                v441 += (int)v90;
                ++v436;
              }
              while (v436 < v435);
            }
          }
          else if (v47[6])
          {
            uint64_t v1512 = v75[19];
            uint64_t v1522 = *(void *)(v48 + 152);
            unint64_t v1564 = 0;
            uint64_t v963 = v47[19];
            do
            {
              uint64_t v964 = *(void *)*v43;
              unint64_t v965 = (unint64_t)(*(void *)(*v43 + 8) - v964) >> 2;
              uint64_t v966 = 0;
              uint64_t v967 = (v965 - 1);
              if ((int)v965 - 1 >= 0)
              {
                uint64_t v968 = *(void *)(*v43 + 24);
                int v969 = v1564;
                do
                {
                  ldiv_t v970 = ldiv(v969, *(int *)(v964 + 4 * v967));
                  int v969 = v970.quot;
                  v966 += *(void *)(v968 + 8 * v967--) * v970.rem;
                }
                while (v967 != -1);
              }
              uint64_t v971 = *(void *)*v44;
              unint64_t v972 = (unint64_t)(*(void *)(*v44 + 8) - v971) >> 2;
              uint64_t v973 = 0;
              uint64_t v974 = (v972 - 1);
              if ((int)v972 - 1 >= 0)
              {
                uint64_t v975 = *(void *)(*v44 + 24);
                int v976 = v1564;
                do
                {
                  ldiv_t v977 = ldiv(v976, *(int *)(v971 + 4 * v974));
                  int v976 = v977.quot;
                  v973 += *(void *)(v975 + 8 * v974--) * v977.rem;
                }
                while (v974 != -1);
              }
              if ((int)v90 >= 1)
              {
                uint64_t v978 = 0;
                int v979 = *(unsigned __int8 *)(v1522 + (int)v966);
                unsigned int v980 = v90 + 1;
                do
                {
                  *(unsigned char *)(v963 + v978) = v979 << *((unsigned char *)v1512 + (int)v973 + v978);
                  --v980;
                  ++v978;
                }
                while (v980 > 1);
                v47 = *(void **)v1573;
              }
              v963 += (int)v90;
              v1564 += (int)v90;
            }
            while (v1564 < v47[6]);
          }
          break;
        case 2:
          if (v53 == 2)
          {
            int v981 = *v49;
            if (*v49)
            {
              unint64_t v982 = 0;
              uint64_t v983 = 0;
              uint64_t v984 = 0;
              uint64_t v985 = *(void *)(v48 + 152);
              ldiv_t v986 = v75[19];
              uint64_t v987 = v47[19];
              do
              {
                if (v49[1])
                {
                  unint64_t v988 = 0;
                  do
                  {
                    if ((int)v90 >= 1)
                    {
                      uint64_t v989 = 0;
                      char v990 = *((unsigned char *)v986 + v983);
                      unsigned int v991 = v90 + 1;
                      do
                      {
                        *(unsigned char *)(v987 + v989) = *(unsigned __int8 *)(v985 + v984 + v989) << v990;
                        --v991;
                        ++v989;
                      }
                      while (v991 > 1);
                      uint64_t v48 = *v43;
                      unsigned int v75 = (int **)*v44;
                      unsigned int v49 = *(int **)*v43;
                    }
                    int v992 = *(void **)(v48 + 24);
                    uint64_t v993 = v992[1];
                    v984 += v993;
                    v983 += *((void *)v75[3] + 1);
                    v987 += (int)v90;
                    ++v988;
                    unint64_t v994 = v49[1];
                  }
                  while (v988 < v994);
                  int v981 = *v49;
                  char v76 = *v75;
                }
                else
                {
                  unint64_t v994 = 0;
                  int v992 = *(void **)(v48 + 24);
                  uint64_t v993 = v992[1];
                }
                uint64_t v984 = *v992 + v984 - v994 * v993;
                uint64_t v983 = *(void *)v75[3] + v983 - *((void *)v75[3] + 1) * v76[1];
                ++v982;
              }
              while (v982 < v981);
            }
          }
          else if (v53 == 1)
          {
            int v445 = *v49;
            if (*v49)
            {
              unint64_t v446 = 0;
              uint64_t v447 = 0;
              uint64_t v448 = 0;
              uint64_t v449 = *(void *)(v48 + 152);
              unint64_t v450 = v75[19];
              uint64_t v451 = v47[19];
              do
              {
                if ((int)v90 >= 1)
                {
                  uint64_t v452 = 0;
                  char v453 = *((unsigned char *)v450 + v447);
                  unsigned int v454 = v90 + 1;
                  do
                  {
                    *(unsigned char *)(v451 + v452) = *(unsigned __int8 *)(v449 + v448 + v452) << v453;
                    --v454;
                    ++v452;
                  }
                  while (v454 > 1);
                  uint64_t v48 = *v43;
                  unsigned int v75 = (int **)*v44;
                  int v445 = **(_DWORD **)*v43;
                }
                v448 += **(void **)(v48 + 24);
                v447 += *(void *)v75[3];
                v451 += (int)v90;
                ++v446;
              }
              while (v446 < v445);
            }
          }
          else if (v47[6])
          {
            uint64_t v1513 = v75[19];
            uint64_t v1523 = *(void *)(v48 + 152);
            unint64_t v1565 = 0;
            uint64_t v995 = v47[19];
            do
            {
              uint64_t v996 = *(void *)*v43;
              unint64_t v997 = (unint64_t)(*(void *)(*v43 + 8) - v996) >> 2;
              uint64_t v998 = 0;
              uint64_t v999 = (v997 - 1);
              if ((int)v997 - 1 >= 0)
              {
                uint64_t v1000 = *(void *)(*v43 + 24);
                int v1001 = v1565;
                do
                {
                  ldiv_t v1002 = ldiv(v1001, *(int *)(v996 + 4 * v999));
                  int v1001 = v1002.quot;
                  v998 += *(void *)(v1000 + 8 * v999--) * v1002.rem;
                }
                while (v999 != -1);
              }
              uint64_t v1003 = *(void *)*v44;
              unint64_t v1004 = (unint64_t)(*(void *)(*v44 + 8) - v1003) >> 2;
              uint64_t v1005 = 0;
              uint64_t v1006 = (v1004 - 1);
              if ((int)v1004 - 1 >= 0)
              {
                uint64_t v1007 = *(void *)(*v44 + 24);
                int v1008 = v1565;
                do
                {
                  ldiv_t v1009 = ldiv(v1008, *(int *)(v1003 + 4 * v1006));
                  int v1008 = v1009.quot;
                  v1005 += *(void *)(v1007 + 8 * v1006--) * v1009.rem;
                }
                while (v1006 != -1);
              }
              if ((int)v90 >= 1)
              {
                uint64_t v1010 = 0;
                char v1011 = *((unsigned char *)v1513 + (int)v1005);
                unsigned int v1012 = v90 + 1;
                do
                {
                  *(unsigned char *)(v995 + v1010) = *(unsigned __int8 *)(v1523 + (int)v998 + v1010) << v1011;
                  --v1012;
                  ++v1010;
                }
                while (v1012 > 1);
                v47 = *(void **)v1573;
              }
              v995 += (int)v90;
              v1565 += (int)v90;
            }
            while (v1565 < v47[6]);
          }
          break;
        case 3:
          if (v53 == 2)
          {
            int v919 = *v49;
            if (*v49)
            {
              unint64_t v920 = 0;
              uint64_t v921 = 0;
              uint64_t v922 = 0;
              uint64_t v923 = *(void *)(v48 + 152);
              uint64_t v924 = v75[19];
              uint64_t v925 = v47[19];
              do
              {
                if (v49[1])
                {
                  unint64_t v926 = 0;
                  do
                  {
                    if ((int)v90 >= 1)
                    {
                      uint64_t v927 = 0;
                      unsigned int v928 = v90 + 1;
                      do
                      {
                        *(unsigned char *)(v925 + v927) = *(unsigned __int8 *)(v923 + v922 + v927) << *((unsigned char *)v924
                                                                                              + v921
                                                                                              + v927);
                        --v928;
                        ++v927;
                      }
                      while (v928 > 1);
                      uint64_t v48 = *v43;
                      unsigned int v75 = (int **)*v44;
                      unsigned int v49 = *(int **)*v43;
                    }
                    uint64_t v929 = *(void **)(v48 + 24);
                    uint64_t v930 = v929[1];
                    v922 += v930;
                    v921 += *((void *)v75[3] + 1);
                    v925 += (int)v90;
                    ++v926;
                    unint64_t v931 = v49[1];
                  }
                  while (v926 < v931);
                  int v919 = *v49;
                  char v76 = *v75;
                }
                else
                {
                  unint64_t v931 = 0;
                  uint64_t v929 = *(void **)(v48 + 24);
                  uint64_t v930 = v929[1];
                }
                uint64_t v922 = *v929 + v922 - v931 * v930;
                uint64_t v921 = *(void *)v75[3] + v921 - *((void *)v75[3] + 1) * v76[1];
                ++v920;
              }
              while (v920 < v919);
            }
          }
          else if (v53 == 1)
          {
            int v206 = *v49;
            if (*v49)
            {
              unint64_t v207 = 0;
              uint64_t v208 = 0;
              uint64_t v209 = 0;
              uint64_t v210 = *(void *)(v48 + 152);
              uint64_t v211 = v75[19];
              uint64_t v212 = v47[19];
              do
              {
                if ((int)v90 >= 1)
                {
                  uint64_t v213 = 0;
                  unsigned int v214 = v90 + 1;
                  do
                  {
                    *(unsigned char *)(v212 + v213) = *(unsigned __int8 *)(v210 + v209 + v213) << *((unsigned char *)v211 + v208 + v213);
                    --v214;
                    ++v213;
                  }
                  while (v214 > 1);
                  uint64_t v48 = *v43;
                  unsigned int v75 = (int **)*v44;
                  int v206 = **(_DWORD **)*v43;
                }
                v209 += **(void **)(v48 + 24);
                v208 += *(void *)v75[3];
                v212 += (int)v90;
                ++v207;
              }
              while (v207 < v206);
            }
          }
          else if (v47[6])
          {
            uint64_t v1511 = v75[19];
            uint64_t v1521 = *(void *)(v48 + 152);
            unint64_t v1563 = 0;
            uint64_t v932 = v47[19];
            do
            {
              uint64_t v933 = *(void *)*v43;
              unint64_t v934 = (unint64_t)(*(void *)(*v43 + 8) - v933) >> 2;
              uint64_t v935 = 0;
              uint64_t v936 = (v934 - 1);
              if ((int)v934 - 1 >= 0)
              {
                uint64_t v937 = *(void *)(*v43 + 24);
                int v938 = v1563;
                do
                {
                  ldiv_t v939 = ldiv(v938, *(int *)(v933 + 4 * v936));
                  int v938 = v939.quot;
                  v935 += *(void *)(v937 + 8 * v936--) * v939.rem;
                }
                while (v936 != -1);
              }
              uint64_t v940 = *(void *)*v44;
              unint64_t v941 = (unint64_t)(*(void *)(*v44 + 8) - v940) >> 2;
              uint64_t v942 = 0;
              uint64_t v943 = (v941 - 1);
              if ((int)v941 - 1 >= 0)
              {
                uint64_t v944 = *(void *)(*v44 + 24);
                int v945 = v1563;
                do
                {
                  ldiv_t v946 = ldiv(v945, *(int *)(v940 + 4 * v943));
                  int v945 = v946.quot;
                  v942 += *(void *)(v944 + 8 * v943--) * v946.rem;
                }
                while (v943 != -1);
              }
              if ((int)v90 >= 1)
              {
                uint64_t v947 = 0;
                unsigned int v948 = v90 + 1;
                do
                {
                  *(unsigned char *)(v932 + v947) = *(unsigned __int8 *)(v1521 + (int)v935 + v947) << *((unsigned char *)v1511
                                                                                              + (int)v942
                                                                                              + v947);
                  --v948;
                  ++v947;
                }
                while (v948 > 1);
                v47 = *(void **)v1573;
              }
              v932 += (int)v90;
              v1563 += (int)v90;
            }
            while (v1563 < v47[6]);
          }
          break;
        default:
LABEL_87:
          switch(v86)
          {
            case 1uLL:
              if (v47[6])
              {
                unint64_t v91 = 0;
                uint64_t v92 = 0;
                uint64_t v93 = 0;
                uint64_t v94 = *(void *)(v48 + 152);
                int v95 = v75[19];
                uint64_t v96 = v47[19];
                do
                {
                  *(unsigned char *)(v96 + v91) = *(unsigned __int8 *)(v94 + v93) << *((unsigned char *)v95 + v92);
                  v93 += **(void **)(*v43 + 24);
                  v92 += **(void **)(*v44 + 24);
                  ++v91;
                }
                while (v91 < *(void *)(*(void *)v45 + 48));
              }
              break;
            case 2uLL:
              int v385 = *v49;
              if (*v49)
              {
                unint64_t v386 = 0;
                uint64_t v387 = 0;
                uint64_t v388 = 0;
                uint64_t v389 = 0;
                uint64_t v390 = *(void *)(v48 + 152);
                uint64_t v391 = v75[19];
                uint64_t v392 = v47[19];
                do
                {
                  if (v49[1])
                  {
                    unint64_t v393 = 0;
                    do
                    {
                      *(unsigned char *)(v392 + v387 + v393) = *(unsigned __int8 *)(v390 + v389) << *((unsigned char *)v391 + v388);
                      uint64_t v48 = *v43;
                      uint64_t v394 = *(void **)(*v43 + 24);
                      uint64_t v395 = v394[1];
                      v389 += v395;
                      unsigned int v75 = (int **)*v44;
                      uint64_t v396 = *(int **)(*v44 + 24);
                      uint64_t v397 = *((void *)v396 + 1);
                      v388 += v397;
                      ++v393;
                      unsigned int v49 = *(int **)*v43;
                      unint64_t v398 = v49[1];
                    }
                    while (v393 < v398);
                    int v385 = *v49;
                    char v76 = *v75;
                    v387 += v393;
                  }
                  else
                  {
                    unint64_t v398 = 0;
                    uint64_t v394 = *(void **)(v48 + 24);
                    uint64_t v395 = v394[1];
                    uint64_t v396 = v75[3];
                    uint64_t v397 = *((void *)v396 + 1);
                  }
                  uint64_t v389 = *v394 + v389 - v398 * v395;
                  uint64_t v388 = *(void *)v396 + v388 - v397 * v76[1];
                  ++v386;
                }
                while (v386 < v385);
              }
              break;
            case 3uLL:
              int v399 = *v49;
              if (*v49)
              {
                unint64_t v400 = 0;
                uint64_t v401 = 0;
                uint64_t v402 = 0;
                uint64_t v403 = 0;
                uint64_t v404 = *(void *)(v48 + 152);
                uint64_t v405 = v75[19];
                uint64_t v406 = v47[19];
                do
                {
                  if (v49[1])
                  {
                    unint64_t v407 = 0;
                    do
                    {
                      if (v49[2])
                      {
                        unint64_t v408 = 0;
                        do
                        {
                          *(unsigned char *)(v406 + v401 + v408) = *(unsigned __int8 *)(v404 + v403) << *((unsigned char *)v405 + v402);
                          uint64_t v48 = *v43;
                          unint64_t v409 = *(void **)(*v43 + 24);
                          uint64_t v410 = v409[2];
                          v403 += v410;
                          unsigned int v75 = (int **)*v44;
                          uint64_t v411 = *(int **)(*v44 + 24);
                          uint64_t v412 = *((void *)v411 + 2);
                          v402 += v412;
                          ++v408;
                          unsigned int v49 = *(int **)*v43;
                          unint64_t v413 = v49[2];
                        }
                        while (v408 < v413);
                        char v76 = *v75;
                        v401 += v408;
                      }
                      else
                      {
                        unint64_t v413 = 0;
                        unint64_t v409 = *(void **)(v48 + 24);
                        uint64_t v410 = v409[2];
                        uint64_t v411 = v75[3];
                        uint64_t v412 = *((void *)v411 + 2);
                      }
                      uint64_t v414 = v409[1];
                      uint64_t v403 = v414 + v403 - v413 * v410;
                      uint64_t v402 = *((void *)v411 + 1) + v402 - v412 * v76[2];
                      ++v407;
                      unint64_t v415 = v49[1];
                    }
                    while (v407 < v415);
                    int v399 = *v49;
                  }
                  else
                  {
                    unint64_t v415 = 0;
                    unint64_t v409 = *(void **)(v48 + 24);
                    uint64_t v414 = v409[1];
                  }
                  uint64_t v403 = *v409 + v403 - v415 * v414;
                  uint64_t v402 = *(void *)v75[3] + v402 - *((void *)v75[3] + 1) * v76[1];
                  ++v400;
                }
                while (v400 < v399);
              }
              break;
            case 4uLL:
              int v416 = *v49;
              if (*v49)
              {
                unint64_t v417 = 0;
                uint64_t v418 = 0;
                uint64_t v419 = 0;
                uint64_t v420 = 0;
                uint64_t v421 = *(void *)(v48 + 152);
                uint64_t v422 = v75[19];
                uint64_t v423 = v47[19];
                do
                {
                  if (v49[1])
                  {
                    unint64_t v424 = 0;
                    do
                    {
                      if (v49[2])
                      {
                        unint64_t v425 = 0;
                        do
                        {
                          if (v49[3])
                          {
                            unint64_t v426 = 0;
                            do
                            {
                              *(unsigned char *)(v423 + v418 + v426) = *(unsigned __int8 *)(v421 + v420) << *((unsigned char *)v422 + v419);
                              uint64_t v48 = *v43;
                              uint64_t v427 = *(void **)(*v43 + 24);
                              uint64_t v428 = v427[3];
                              v420 += v428;
                              unsigned int v75 = (int **)*v44;
                              unint64_t v429 = *(int **)(*v44 + 24);
                              uint64_t v430 = *((void *)v429 + 3);
                              v419 += v430;
                              ++v426;
                              unsigned int v49 = *(int **)*v43;
                              unint64_t v431 = v49[3];
                            }
                            while (v426 < v431);
                            char v76 = *v75;
                            v418 += v426;
                          }
                          else
                          {
                            unint64_t v431 = 0;
                            uint64_t v427 = *(void **)(v48 + 24);
                            uint64_t v428 = v427[3];
                            unint64_t v429 = v75[3];
                            uint64_t v430 = *((void *)v429 + 3);
                          }
                          uint64_t v432 = v427[2];
                          uint64_t v420 = v432 + v420 - v431 * v428;
                          uint64_t v419 = *((void *)v429 + 2) + v419 - v430 * v76[3];
                          ++v425;
                          unint64_t v433 = v49[2];
                        }
                        while (v425 < v433);
                      }
                      else
                      {
                        unint64_t v433 = 0;
                        uint64_t v427 = *(void **)(v48 + 24);
                        uint64_t v432 = v427[2];
                      }
                      uint64_t v420 = v427[1] + v420 - v433 * v432;
                      uint64_t v419 = *((void *)v75[3] + 1) + v419 - *((void *)v75[3] + 2) * v76[2];
                      ++v424;
                      unint64_t v434 = v49[1];
                    }
                    while (v424 < v434);
                    int v416 = *v49;
                  }
                  else
                  {
                    unint64_t v434 = 0;
                  }
                  uint64_t v420 = **(void **)(v48 + 24) + v420 - *(void *)(*(void *)(v48 + 24) + 8) * v434;
                  uint64_t v419 = *(void *)v75[3] + v419 - *((void *)v75[3] + 1) * v76[1];
                  ++v417;
                }
                while (v417 < v416);
              }
              break;
            default:
              if (v47[6])
              {
                unint64_t v368 = 0;
                uint64_t v1560 = *(void *)(v48 + 152);
                uint64_t v369 = v75[19];
                uint64_t v370 = v47[19];
                do
                {
                  uint64_t v371 = *(void *)*v43;
                  unint64_t v372 = (unint64_t)(*(void *)(*v43 + 8) - v371) >> 2;
                  uint64_t v373 = 0;
                  uint64_t v374 = (v372 - 1);
                  if ((int)v372 - 1 >= 0)
                  {
                    uint64_t v375 = *(void *)(*v43 + 24);
                    int v376 = v368;
                    do
                    {
                      ldiv_t v377 = ldiv(v376, *(int *)(v371 + 4 * v374));
                      int v376 = v377.quot;
                      v373 += *(void *)(v375 + 8 * v374--) * v377.rem;
                    }
                    while (v374 != -1);
                  }
                  uint64_t v378 = *(void *)*v44;
                  unint64_t v379 = (unint64_t)(*(void *)(*v44 + 8) - v378) >> 2;
                  uint64_t v380 = 0;
                  uint64_t v381 = (v379 - 1);
                  if ((int)v379 - 1 >= 0)
                  {
                    uint64_t v382 = *(void *)(*v44 + 24);
                    int v383 = v368;
                    do
                    {
                      ldiv_t v384 = ldiv(v383, *(int *)(v378 + 4 * v381));
                      int v383 = v384.quot;
                      v380 += *(void *)(v382 + 8 * v381--) * v384.rem;
                    }
                    while (v381 != -1);
                  }
                  *(unsigned char *)(v370 + v368++) = *(unsigned __int8 *)(v1560 + (int)v373) << *((unsigned char *)v369 + (int)v380);
                }
                while (v368 < *(void *)(*(void *)v1573 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 1:
      goto LABEL_31;
    case 2:
      char v7 = *(uint64_t **)a1;
      BOOL v6 = *(uint64_t **)(a1 + 8);
      switch(v8)
      {
        case 0:
          goto LABEL_12;
        case 1:
          int v9 = *(_DWORD *)(*v6 + 160);
          if (v9 >= 1)
          {
            int v10 = **(_DWORD **)(*v7 + 152);
            int v11 = *(_DWORD **)(*(void *)v1 + 152);
            int v12 = *(int **)(*v6 + 152);
            unsigned int v13 = v9 + 1;
            do
            {
              int v14 = *v12++;
              *v11++ = v10 << v14;
              --v13;
            }
            while (v13 > 1);
          }
          return;
        case 2:
          int v106 = *(_DWORD *)(*v7 + 160);
          if (v106 >= 1)
          {
            int v107 = **(_DWORD **)(*v6 + 152);
            int v108 = *(_DWORD **)(*(void *)v1 + 152);
            int v109 = *(int **)(*v7 + 152);
            unsigned int v110 = v106 + 1;
            do
            {
              int v111 = *v109++;
              *v108++ = v111 << v107;
              --v110;
            }
            while (v110 > 1);
          }
          return;
        case 3:
          int v112 = *(_DWORD *)(*(void *)v1 + 48);
          if (v112 >= 1)
          {
            int v113 = *(_DWORD **)(*(void *)v1 + 152);
            int v114 = *(int **)(*v6 + 152);
            unsigned int v115 = *(int **)(*v7 + 152);
            unsigned int v116 = v112 + 1;
            do
            {
              int v118 = *v115++;
              int v117 = v118;
              int v119 = *v114++;
              *v113++ = v117 << v119;
              --v116;
            }
            while (v116 > 1);
          }
          return;
        default:
          int v97 = *(void **)v1;
          int v98 = (void *)*v7;
          int v99 = *(int **)*v7;
          uint64_t v100 = (v98[1] - (void)v99) >> 2;
          uint64_t v101 = (v100 - 1);
          if ((int)v101 >= -1) {
            int v102 = -1;
          }
          else {
            int v102 = v100 - 1;
          }
          int v103 = v102 + 1;
          int v104 = v100 + 1;
          break;
      }
      while (1)
      {
        unsigned int v105 = v104 - 2;
        if (v104 - 2 < 0) {
          break;
        }
        --v104;
        if (*(void *)(v98[3] + 8 * v105) != *(void *)(v97[3] + 8 * v105)) {
          goto LABEL_184;
        }
      }
      int v104 = v103;
LABEL_184:
      v221 = (void *)*v6;
      uint64_t v222 = *(int **)*v6;
      uint64_t v223 = (v221[1] - (void)v222) >> 2;
      uint64_t v224 = (v223 - 1);
      if ((int)v224 >= -1) {
        int v225 = -1;
      }
      else {
        int v225 = v223 - 1;
      }
      int v226 = v225 + 1;
      int v227 = v223 + 1;
      while (1)
      {
        unsigned int v228 = v227 - 2;
        if (v227 - 2 < 0) {
          break;
        }
        --v227;
        if (*(void *)(v221[3] + 8 * v228) != *(void *)(v97[3] + 8 * v228)) {
          goto LABEL_220;
        }
      }
      int v227 = v226;
LABEL_220:
      int v254 = v100 + 1;
      while (1)
      {
        unsigned int v255 = v254 - 2;
        if (v254 - 2 < 0) {
          break;
        }
        --v254;
        if (*(void *)(v98[3] + 8 * v255)) {
          goto LABEL_245;
        }
      }
      int v254 = v103;
LABEL_245:
      int v264 = v223 + 1;
      while (1)
      {
        unsigned int v265 = v264 - 2;
        if (v264 - 2 < 0) {
          break;
        }
        --v264;
        if (*(void *)(v221[3] + 8 * v265)) {
          goto LABEL_288;
        }
      }
      int v264 = v226;
LABEL_288:
      unint64_t v281 = (uint64_t)(v97[1] - *v97) >> 2;
      if (v104 <= v227) {
        int v282 = v227;
      }
      else {
        int v282 = v104;
      }
      if (v104 <= v264) {
        int v104 = v264;
      }
      if (v254 > v227) {
        int v227 = v254;
      }
      if (v281 > v227)
      {
        int v283 = 1;
      }
      else
      {
        int v227 = (uint64_t)(v97[1] - *v97) >> 2;
        int v283 = 4;
      }
      if (v281 > v104)
      {
        int v284 = 2;
      }
      else
      {
        int v104 = v227;
        int v284 = v283;
      }
      if (v281 > v282)
      {
        int v104 = v282;
        int v284 = 3;
      }
      uint64_t v1557 = v224;
      uint64_t v1575 = v101;
      if (!v104) {
        goto LABEL_305;
      }
      unint64_t v285 = *(void *)(v97[3] + 8 * (v104 - 1));
      if (v285 < 0x10) {
        goto LABEL_305;
      }
      switch(v284)
      {
        case 1:
          if (v104 == 2)
          {
            int v1208 = *v99;
            if (*v99)
            {
              unint64_t v1209 = 0;
              uint64_t v1210 = 0;
              uint64_t v1211 = 0;
              uint64_t v1212 = v98[19];
              uint64_t v1213 = v221[19];
              uint64_t v1214 = v97[19];
              uint64_t v1215 = (uint64_t *)v98[3];
              uint64_t v1216 = *v1215;
              uint64_t v1217 = v1215[1];
              uint64_t v1218 = (uint64_t *)v221[3];
              uint64_t v1219 = *v1218;
              uint64_t v1220 = v1218[1];
              int v1221 = v99[1];
              int v1222 = v1221;
              do
              {
                if (v1222)
                {
                  unint64_t v1223 = 0;
                  uint64_t v1224 = v1213 + 4 * v1210;
                  do
                  {
                    if ((int)v285 >= 1)
                    {
                      uint64_t v1225 = 0;
                      int v1226 = *(_DWORD *)(v1212 + 4 * v1211);
                      unsigned int v1227 = v285 + 1;
                      do
                      {
                        *(_DWORD *)(v1214 + v1225) = v1226 << *(_DWORD *)(v1224 + v1225);
                        --v1227;
                        v1225 += 4;
                      }
                      while (v1227 > 1);
                      int v1221 = v99[1];
                    }
                    v1211 += v1217;
                    v1210 += v1220;
                    v1214 += 4 * (int)v285;
                    ++v1223;
                    v1224 += 4 * v1220;
                  }
                  while (v1223 < v1221);
                  uint64_t v1228 = v1221;
                  int v1208 = *v99;
                  int v1222 = v1221;
                }
                else
                {
                  uint64_t v1228 = 0;
                }
                uint64_t v1211 = v1211 + v1216 - v1228 * v1217;
                uint64_t v1210 = v1210 + v1219 - v1220 * v222[1];
                ++v1209;
              }
              while (v1209 < v1208);
            }
          }
          else if (v104 == 1)
          {
            int v833 = *v99;
            if (*v99)
            {
              unint64_t v834 = 0;
              uint64_t v835 = 0;
              uint64_t v836 = v98[19];
              uint64_t v837 = v221[19];
              uint64_t v838 = v97[19];
              uint64_t v839 = *(void *)v98[3];
              uint64_t v840 = 4 * *(void *)v221[3];
              do
              {
                if ((int)v285 >= 1)
                {
                  uint64_t v841 = 0;
                  int v842 = *(_DWORD *)(v836 + 4 * v835);
                  unsigned int v843 = v285 + 1;
                  do
                  {
                    *(_DWORD *)(v838 + v841) = v842 << *(_DWORD *)(v837 + v841);
                    --v843;
                    v841 += 4;
                  }
                  while (v843 > 1);
                  int v833 = *v99;
                }
                v835 += v839;
                ++v834;
                v838 += 4 * (int)v285;
                v837 += v840;
              }
              while (v834 < v833);
            }
          }
          else
          {
            unint64_t v1529 = v97[6];
            if (v1529)
            {
              unint64_t v1549 = 0;
              uint64_t v1488 = v221[19];
              uint64_t v1497 = v98[19];
              uint64_t v1229 = v97[19];
              do
              {
                uint64_t v1230 = 0;
                if ((v101 & 0x80000000) == 0)
                {
                  uint64_t v1231 = v98[3];
                  uint64_t v1232 = v101;
                  int v1233 = v1549;
                  do
                  {
                    ldiv_t v1234 = ldiv(v1233, v99[v1232]);
                    int v1233 = v1234.quot;
                    v1230 += *(void *)(v1231 + 8 * v1232--) * v1234.rem;
                  }
                  while (v1232 != -1);
                }
                uint64_t v1235 = v1557;
                if ((v1557 & 0x80000000) != 0)
                {
                  LODWORD(v1236) = 0;
                }
                else
                {
                  uint64_t v1236 = 0;
                  uint64_t v1237 = v221[3];
                  int v1238 = v1549;
                  do
                  {
                    ldiv_t v1239 = ldiv(v1238, v222[v1235]);
                    int v1238 = v1239.quot;
                    v1236 += *(void *)(v1237 + 8 * v1235--) * v1239.rem;
                  }
                  while (v1235 != -1);
                }
                uint64_t v101 = v1575;
                if ((int)v285 >= 1)
                {
                  uint64_t v1240 = 0;
                  int v1241 = *(_DWORD *)(v1497 + 4 * (int)v1230);
                  unsigned int v1242 = v285 + 1;
                  do
                  {
                    *(_DWORD *)(v1229 + v1240) = v1241 << *(_DWORD *)(v1488 + 4 * (int)v1236 + v1240);
                    --v1242;
                    v1240 += 4;
                  }
                  while (v1242 > 1);
                }
                v1229 += 4 * (int)v285;
                v1549 += (int)v285;
              }
              while (v1549 < v1529);
            }
          }
          break;
        case 2:
          if (v104 == 2)
          {
            int v1243 = *v99;
            if (*v99)
            {
              unint64_t v1244 = 0;
              uint64_t v1245 = 0;
              uint64_t v1246 = 0;
              uint64_t v1247 = v98[19];
              uint64_t v1248 = v221[19];
              uint64_t v1249 = v97[19];
              uint64_t v1250 = (uint64_t *)v98[3];
              uint64_t v1251 = *v1250;
              uint64_t v1252 = v1250[1];
              uint64_t v1253 = (uint64_t *)v221[3];
              uint64_t v1254 = *v1253;
              uint64_t v1255 = v1253[1];
              int v1256 = v99[1];
              int v1257 = v1256;
              do
              {
                if (v1257)
                {
                  unint64_t v1258 = 0;
                  uint64_t v1259 = v1247 + 4 * v1246;
                  do
                  {
                    if ((int)v285 >= 1)
                    {
                      uint64_t v1260 = 0;
                      int v1261 = *(_DWORD *)(v1248 + 4 * v1245);
                      unsigned int v1262 = v285 + 1;
                      do
                      {
                        *(_DWORD *)(v1249 + v1260) = *(_DWORD *)(v1259 + v1260) << v1261;
                        --v1262;
                        v1260 += 4;
                      }
                      while (v1262 > 1);
                      int v1256 = v99[1];
                    }
                    v1246 += v1252;
                    v1245 += v1255;
                    v1249 += 4 * (int)v285;
                    ++v1258;
                    v1259 += 4 * v1252;
                  }
                  while (v1258 < v1256);
                  uint64_t v1263 = v1256;
                  int v1243 = *v99;
                  int v1257 = v1256;
                }
                else
                {
                  uint64_t v1263 = 0;
                }
                uint64_t v1246 = v1246 + v1251 - v1263 * v1252;
                uint64_t v1245 = v1245 + v1254 - v1255 * v222[1];
                ++v1244;
              }
              while (v1244 < v1243);
            }
          }
          else if (v104 == 1)
          {
            int v844 = *v99;
            if (*v99)
            {
              unint64_t v845 = 0;
              uint64_t v846 = 0;
              uint64_t v847 = v98[19];
              uint64_t v848 = v221[19];
              uint64_t v849 = v97[19];
              uint64_t v850 = *(void *)v221[3];
              uint64_t v851 = 4 * *(void *)v98[3];
              do
              {
                if ((int)v285 >= 1)
                {
                  uint64_t v852 = 0;
                  int v853 = *(_DWORD *)(v848 + 4 * v846);
                  unsigned int v854 = v285 + 1;
                  do
                  {
                    *(_DWORD *)(v849 + v852) = *(_DWORD *)(v847 + v852) << v853;
                    --v854;
                    v852 += 4;
                  }
                  while (v854 > 1);
                  int v844 = *v99;
                }
                v846 += v850;
                ++v845;
                v849 += 4 * (int)v285;
                v847 += v851;
              }
              while (v845 < v844);
            }
          }
          else
          {
            unint64_t v1530 = v97[6];
            if (v1530)
            {
              unint64_t v1550 = 0;
              uint64_t v1489 = v221[19];
              uint64_t v1498 = v98[19];
              uint64_t v1264 = v97[19];
              do
              {
                uint64_t v1265 = 0;
                if ((v101 & 0x80000000) == 0)
                {
                  uint64_t v1266 = v98[3];
                  uint64_t v1267 = v101;
                  int v1268 = v1550;
                  do
                  {
                    ldiv_t v1269 = ldiv(v1268, v99[v1267]);
                    int v1268 = v1269.quot;
                    v1265 += *(void *)(v1266 + 8 * v1267--) * v1269.rem;
                  }
                  while (v1267 != -1);
                }
                uint64_t v1270 = v1557;
                if ((v1557 & 0x80000000) != 0)
                {
                  LODWORD(v1271) = 0;
                }
                else
                {
                  uint64_t v1271 = 0;
                  uint64_t v1272 = v221[3];
                  int v1273 = v1550;
                  do
                  {
                    ldiv_t v1274 = ldiv(v1273, v222[v1270]);
                    int v1273 = v1274.quot;
                    v1271 += *(void *)(v1272 + 8 * v1270--) * v1274.rem;
                  }
                  while (v1270 != -1);
                }
                uint64_t v101 = v1575;
                if ((int)v285 >= 1)
                {
                  uint64_t v1275 = 0;
                  int v1276 = *(_DWORD *)(v1489 + 4 * (int)v1271);
                  unsigned int v1277 = v285 + 1;
                  do
                  {
                    *(_DWORD *)(v1264 + v1275) = *(_DWORD *)(v1498 + 4 * (int)v1265 + v1275) << v1276;
                    --v1277;
                    v1275 += 4;
                  }
                  while (v1277 > 1);
                }
                v1264 += 4 * (int)v285;
                v1550 += (int)v285;
              }
              while (v1550 < v1530);
            }
          }
          break;
        case 3:
          if (v104 == 2)
          {
            int v1036 = *v99;
            if (*v99)
            {
              unint64_t v1037 = 0;
              uint64_t v1038 = 0;
              uint64_t v1039 = 0;
              uint64_t v1040 = v98[19];
              uint64_t v1041 = v221[19];
              uint64_t v1042 = v97[19];
              uint64_t v1043 = (uint64_t *)v98[3];
              uint64_t v1044 = *v1043;
              uint64_t v1045 = v1043[1];
              uint64_t v1046 = (uint64_t *)v221[3];
              uint64_t v1047 = *v1046;
              uint64_t v1048 = v1046[1];
              int v1049 = v99[1];
              int v1050 = v1049;
              do
              {
                if (v1050)
                {
                  unint64_t v1051 = 0;
                  uint64_t v1052 = v1041 + 4 * v1038;
                  uint64_t v1053 = v1040 + 4 * v1039;
                  do
                  {
                    if ((int)v285 >= 1)
                    {
                      uint64_t v1054 = 0;
                      unsigned int v1055 = v285 + 1;
                      do
                      {
                        *(_DWORD *)(v1042 + v1054) = *(_DWORD *)(v1053 + v1054) << *(_DWORD *)(v1052 + v1054);
                        --v1055;
                        v1054 += 4;
                      }
                      while (v1055 > 1);
                      int v1049 = v99[1];
                    }
                    v1039 += v1045;
                    v1038 += v1048;
                    v1042 += 4 * (int)v285;
                    ++v1051;
                    v1052 += 4 * v1048;
                    v1053 += 4 * v1045;
                  }
                  while (v1051 < v1049);
                  uint64_t v1056 = v1049;
                  int v1036 = *v99;
                  int v1050 = v1049;
                }
                else
                {
                  uint64_t v1056 = 0;
                }
                uint64_t v1039 = v1039 + v1044 - v1056 * v1045;
                uint64_t v1038 = v1038 + v1047 - v1048 * v222[1];
                ++v1037;
              }
              while (v1037 < v1036);
            }
          }
          else if (v104 == 1)
          {
            int v332 = *v99;
            if (*v99)
            {
              unint64_t v333 = 0;
              uint64_t v334 = v98[19];
              uint64_t v335 = v221[19];
              uint64_t v336 = v97[19];
              uint64_t v337 = 4 * *(void *)v221[3];
              uint64_t v338 = 4 * *(void *)v98[3];
              do
              {
                if ((int)v285 >= 1)
                {
                  uint64_t v339 = 0;
                  unsigned int v340 = v285 + 1;
                  do
                  {
                    *(_DWORD *)(v336 + v339) = *(_DWORD *)(v334 + v339) << *(_DWORD *)(v335 + v339);
                    --v340;
                    v339 += 4;
                  }
                  while (v340 > 1);
                  int v332 = *v99;
                }
                ++v333;
                v336 += 4 * (int)v285;
                v335 += v337;
                v334 += v338;
              }
              while (v333 < v332);
            }
          }
          else
          {
            unint64_t v1524 = v97[6];
            if (v1524)
            {
              unint64_t v1542 = 0;
              uint64_t v1485 = v221[19];
              uint64_t v1494 = v98[19];
              uint64_t v1057 = v97[19];
              do
              {
                uint64_t v1058 = 0;
                if ((v101 & 0x80000000) == 0)
                {
                  uint64_t v1059 = v98[3];
                  uint64_t v1060 = v101;
                  int v1061 = v1542;
                  do
                  {
                    ldiv_t v1062 = ldiv(v1061, v99[v1060]);
                    int v1061 = v1062.quot;
                    v1058 += *(void *)(v1059 + 8 * v1060--) * v1062.rem;
                  }
                  while (v1060 != -1);
                }
                uint64_t v1063 = v1557;
                if ((v1557 & 0x80000000) != 0)
                {
                  LODWORD(v1064) = 0;
                }
                else
                {
                  uint64_t v1064 = 0;
                  uint64_t v1065 = v221[3];
                  int v1066 = v1542;
                  do
                  {
                    ldiv_t v1067 = ldiv(v1066, v222[v1063]);
                    int v1066 = v1067.quot;
                    v1064 += *(void *)(v1065 + 8 * v1063--) * v1067.rem;
                  }
                  while (v1063 != -1);
                }
                uint64_t v101 = v1575;
                if ((int)v285 >= 1)
                {
                  uint64_t v1068 = 0;
                  unsigned int v1069 = v285 + 1;
                  do
                  {
                    *(_DWORD *)(v1057 + v1068) = *(_DWORD *)(v1494 + 4 * (int)v1058 + v1068) << *(_DWORD *)(v1485 + 4 * (int)v1064 + v1068);
                    --v1069;
                    v1068 += 4;
                  }
                  while (v1069 > 1);
                }
                v1057 += 4 * (int)v285;
                v1542 += (int)v285;
              }
              while (v1542 < v1524);
            }
          }
          break;
        default:
LABEL_305:
          switch(v281)
          {
            case 1uLL:
              uint64_t v286 = v97[6];
              if (v286)
              {
                int v287 = (_DWORD *)v98[19];
                unint64_t v288 = (_DWORD *)v221[19];
                uint64_t v289 = (_DWORD *)v97[19];
                uint64_t v290 = 4 * *(void *)v221[3];
                uint64_t v291 = 4 * *(void *)v98[3];
                do
                {
                  *v289++ = *v287 << *v288;
                  unint64_t v288 = (_DWORD *)((char *)v288 + v290);
                  int v287 = (_DWORD *)((char *)v287 + v291);
                  --v286;
                }
                while (v286);
              }
              break;
            case 2uLL:
              int v526 = *v99;
              if (*v99)
              {
                unint64_t v527 = 0;
                uint64_t v528 = 0;
                uint64_t v529 = 0;
                uint64_t v530 = 0;
                uint64_t v531 = v98[19];
                uint64_t v532 = v221[19];
                uint64_t v533 = v97[19];
                uint64_t v534 = (uint64_t *)v98[3];
                uint64_t v535 = *v534;
                uint64_t v536 = v534[1];
                uint64_t v537 = (uint64_t *)v221[3];
                uint64_t v539 = *v537;
                uint64_t v538 = v537[1];
                int v540 = v99[1];
                do
                {
                  if (v540)
                  {
                    for (unint64_t i = 0; i < v540; ++i)
                    {
                      *(_DWORD *)(v533 + 4 * v528 + 4 * i) = *(_DWORD *)(v531 + 4 * v530) << *(_DWORD *)(v532 + 4 * v529);
                      v530 += v536;
                      v529 += v538;
                      int v540 = v99[1];
                    }
                    uint64_t v542 = v540;
                    int v526 = *v99;
                    v528 += i;
                  }
                  else
                  {
                    uint64_t v542 = 0;
                  }
                  uint64_t v530 = v530 + v535 - v542 * v536;
                  uint64_t v529 = v529 + v539 - v538 * v222[1];
                  ++v527;
                }
                while (v527 < v526);
              }
              break;
            case 3uLL:
              int v543 = *v99;
              if (*v99)
              {
                unint64_t v544 = 0;
                uint64_t v545 = 0;
                uint64_t v546 = 0;
                uint64_t v547 = 0;
                uint64_t v548 = v98[19];
                uint64_t v549 = v221[19];
                uint64_t v550 = v97[19];
                uint64_t v551 = (uint64_t *)v98[3];
                uint64_t v552 = *v551;
                uint64_t v553 = v551[1];
                uint64_t v554 = (uint64_t *)v221[3];
                uint64_t v555 = *v554;
                uint64_t v556 = v554[1];
                int v557 = v99[1];
                int v558 = v557;
                do
                {
                  if (v558)
                  {
                    unint64_t v559 = 0;
                    uint64_t v560 = v551[2];
                    uint64_t v561 = v554[2];
                    int v562 = v99[2];
                    do
                    {
                      if (v562)
                      {
                        for (unint64_t j = 0; j < v562; ++j)
                        {
                          *(_DWORD *)(v550 + 4 * v545 + 4 * j) = *(_DWORD *)(v548 + 4 * v547) << *(_DWORD *)(v549 + 4 * v546);
                          v547 += v560;
                          v546 += v561;
                          int v562 = v99[2];
                        }
                        uint64_t v564 = v562;
                        int v557 = v99[1];
                        v545 += j;
                      }
                      else
                      {
                        uint64_t v564 = 0;
                      }
                      uint64_t v547 = v547 + v553 - v564 * v560;
                      uint64_t v546 = v546 + v556 - v561 * v222[2];
                      ++v559;
                    }
                    while (v559 < v557);
                    uint64_t v565 = v557;
                    int v543 = *v99;
                    int v558 = v557;
                  }
                  else
                  {
                    uint64_t v565 = 0;
                  }
                  uint64_t v547 = v547 + v552 - v565 * v553;
                  uint64_t v546 = v546 + v555 - v556 * v222[1];
                  ++v544;
                }
                while (v544 < v543);
              }
              break;
            case 4uLL:
              int v566 = *v99;
              if (*v99)
              {
                unint64_t v567 = 0;
                uint64_t v568 = 0;
                uint64_t v569 = 0;
                uint64_t v570 = 0;
                uint64_t v571 = v98[19];
                uint64_t v572 = v221[19];
                uint64_t v573 = v97[19];
                uint64_t v574 = (uint64_t *)v98[3];
                uint64_t v575 = *v574;
                uint64_t v576 = v574[1];
                int v577 = (uint64_t *)v221[3];
                uint64_t v578 = *v577;
                uint64_t v579 = v577[1];
                int v580 = v99[1];
                int v581 = v580;
                do
                {
                  if (v581)
                  {
                    unint64_t v582 = 0;
                    uint64_t v583 = v574[2];
                    uint64_t v584 = v577[2];
                    int v585 = v99[2];
                    int v586 = v585;
                    do
                    {
                      if (v586)
                      {
                        unint64_t v587 = 0;
                        uint64_t v588 = v574[3];
                        uint64_t v589 = v577[3];
                        int v590 = v99[3];
                        do
                        {
                          if (v590)
                          {
                            for (unint64_t k = 0; k < v590; ++k)
                            {
                              *(_DWORD *)(v573 + 4 * v568 + 4 * k) = *(_DWORD *)(v571 + 4 * v570) << *(_DWORD *)(v572 + 4 * v569);
                              v570 += v588;
                              v569 += v589;
                              int v590 = v99[3];
                            }
                            uint64_t v592 = v590;
                            int v585 = v99[2];
                            v568 += k;
                          }
                          else
                          {
                            uint64_t v592 = 0;
                          }
                          uint64_t v570 = v570 + v583 - v592 * v588;
                          uint64_t v569 = v569 + v584 - v589 * v222[3];
                          ++v587;
                        }
                        while (v587 < v585);
                        uint64_t v593 = v585;
                        int v580 = v99[1];
                        int v586 = v585;
                      }
                      else
                      {
                        uint64_t v593 = 0;
                      }
                      uint64_t v570 = v570 + v576 - v593 * v583;
                      uint64_t v569 = v569 + v579 - v584 * v222[2];
                      ++v582;
                    }
                    while (v582 < v580);
                    uint64_t v594 = v580;
                    int v566 = *v99;
                    int v581 = v580;
                  }
                  else
                  {
                    uint64_t v594 = 0;
                  }
                  uint64_t v570 = v570 + v575 - v594 * v576;
                  uint64_t v569 = v569 + v578 - v579 * v222[1];
                  ++v567;
                }
                while (v567 < v566);
              }
              break;
            default:
              uint64_t v514 = v97[6];
              if (v514)
              {
                uint64_t v515 = 0;
                uint64_t v1517 = v221[19];
                uint64_t v1537 = v98[19];
                uint64_t v1507 = v97[19];
                do
                {
                  uint64_t v516 = 0;
                  if ((v101 & 0x80000000) == 0)
                  {
                    uint64_t v517 = v98[3];
                    uint64_t v518 = v101;
                    int v519 = v515;
                    do
                    {
                      ldiv_t v520 = ldiv(v519, v99[v518]);
                      int v519 = v520.quot;
                      v516 += *(void *)(v517 + 8 * v518--) * v520.rem;
                    }
                    while (v518 != -1);
                  }
                  uint64_t v521 = v1557;
                  if ((v1557 & 0x80000000) != 0)
                  {
                    LODWORD(v522) = 0;
                  }
                  else
                  {
                    uint64_t v522 = 0;
                    uint64_t v523 = v221[3];
                    int v524 = v515;
                    do
                    {
                      ldiv_t v525 = ldiv(v524, v222[v521]);
                      int v524 = v525.quot;
                      v522 += *(void *)(v523 + 8 * v521--) * v525.rem;
                    }
                    while (v521 != -1);
                  }
                  *(_DWORD *)(v1507 + 4 * v515++) = *(_DWORD *)(v1537 + 4 * (int)v516) << *(_DWORD *)(v1517 + 4 * (int)v522);
                  uint64_t v101 = v1575;
                }
                while (v515 != v514);
              }
              break;
          }
          break;
      }
      return;
    case 3:
      unsigned int v15 = *(uint64_t **)a1;
      int v16 = *(uint64_t **)(a1 + 8);
      switch(v17)
      {
        case 0:
          int v18 = **(unsigned __int8 **)(*v15 + 152) << **(unsigned char **)(*v16 + 152);
          uint64_t v19 = *(void *)v1;
LABEL_33:
          **(unsigned char **)(v19 + 152) = v18;
          return;
        case 1:
          int v128 = *(_DWORD *)(*v16 + 160);
          if (v128 >= 1)
          {
            int v129 = *(unsigned char **)(*(void *)v1 + 152);
            unsigned int v130 = *(char **)(*v16 + 152);
            int v131 = **(unsigned __int8 **)(*v15 + 152);
            unsigned int v132 = v128 + 1;
            do
            {
              char v133 = *v130++;
              *v129++ = v131 << v133;
              --v132;
            }
            while (v132 > 1);
          }
          return;
        case 2:
          int v134 = *(_DWORD *)(*v15 + 160);
          if (v134 >= 1)
          {
            int v135 = *(unsigned char **)(*(void *)v1 + 152);
            int v136 = *(unsigned __int8 **)(*v15 + 152);
            char v137 = **(unsigned char **)(*v16 + 152);
            unsigned int v138 = v134 + 1;
            do
            {
              int v139 = *v136++;
              *v135++ = v139 << v137;
              --v138;
            }
            while (v138 > 1);
          }
          return;
        case 3:
          int v140 = *(_DWORD *)(*(void *)v1 + 48);
          if (v140 >= 1)
          {
            uint64_t v141 = *(unsigned char **)(*(void *)v1 + 152);
            unsigned int v142 = *(char **)(*v16 + 152);
            char v143 = *(unsigned __int8 **)(*v15 + 152);
            unsigned int v144 = v140 + 1;
            do
            {
              char v146 = *v142++;
              char v145 = v146;
              int v147 = *v143++;
              *v141++ = v147 << v145;
              --v144;
            }
            while (v144 > 1);
          }
          return;
        default:
          unsigned int v120 = *(void **)v1;
          uint64_t v121 = *v15;
          int v122 = *(int **)*v15;
          uint64_t v123 = (*(void *)(*v15 + 8) - (void)v122) >> 2;
          int v124 = v123 - 1;
          if ((int)v123 - 1 >= -1) {
            int v124 = -1;
          }
          int v125 = v124 + 1;
          int v126 = v123 + 1;
          break;
      }
      while (1)
      {
        unsigned int v127 = v126 - 2;
        if (v126 - 2 < 0) {
          break;
        }
        --v126;
        if (*(void *)(*(void *)(v121 + 24) + 8 * v127) != *(void *)(v120[3] + 8 * v127)) {
          goto LABEL_192;
        }
      }
      int v126 = v125;
LABEL_192:
      int v229 = (int **)*v16;
      int v230 = *(int **)*v16;
      uint64_t v231 = (*(void *)(*v16 + 8) - (void)v230) >> 2;
      int v232 = v231 - 1;
      if ((int)v231 - 1 >= -1) {
        int v232 = -1;
      }
      int v233 = v232 + 1;
      int v234 = v231 + 1;
      while (1)
      {
        unsigned int v235 = v234 - 2;
        if (v234 - 2 < 0) {
          break;
        }
        --v234;
        if (*(void *)&v229[3][2 * v235] != *(void *)(v120[3] + 8 * v235)) {
          goto LABEL_225;
        }
      }
      int v234 = v233;
LABEL_225:
      int v256 = v123 + 1;
      while (1)
      {
        unsigned int v257 = v256 - 2;
        if (v256 - 2 < 0) {
          break;
        }
        --v256;
        if (*(void *)(*(void *)(v121 + 24) + 8 * v257)) {
          goto LABEL_250;
        }
      }
      int v256 = v125;
LABEL_250:
      int v266 = v231 + 1;
      while (1)
      {
        int v267 = v266 - 2;
        if (v266 - 2 < 0) {
          break;
        }
        --v266;
        if (*(void *)&v229[3][2 * v267]) {
          goto LABEL_311;
        }
      }
      int v266 = v233;
LABEL_311:
      unint64_t v292 = (uint64_t)(v120[1] - *v120) >> 2;
      if (v126 <= v234) {
        int v293 = v234;
      }
      else {
        int v293 = v126;
      }
      if (v126 <= v266) {
        int v126 = v266;
      }
      if (v256 > v234) {
        int v234 = v256;
      }
      if (v292 > v234)
      {
        int v294 = 1;
      }
      else
      {
        int v234 = (uint64_t)(v120[1] - *v120) >> 2;
        int v294 = 4;
      }
      if (v292 > v126)
      {
        int v295 = 2;
      }
      else
      {
        int v126 = v234;
        int v295 = v294;
      }
      if (v292 > v293)
      {
        int v126 = v293;
        int v295 = 3;
      }
      if (!v126) {
        goto LABEL_328;
      }
      unint64_t v296 = *(void *)(v120[3] + 8 * (v126 - 1));
      if (v296 < 0x10) {
        goto LABEL_328;
      }
      uint64_t v1578 = *(void *)(v120[3] + 8 * (v126 - 1));
      switch(v295)
      {
        case 1:
          if (v126 == 2)
          {
            int v1278 = *v122;
            if (*v122)
            {
              unint64_t v1279 = 0;
              uint64_t v1280 = 0;
              uint64_t v1281 = 0;
              uint64_t v1282 = *(void *)(v121 + 152);
              int v1283 = v229[19];
              uint64_t v1284 = v120[19];
              do
              {
                if (v122[1])
                {
                  unint64_t v1285 = 0;
                  do
                  {
                    if ((int)v296 >= 1)
                    {
                      uint64_t v1286 = 0;
                      int v1287 = *(unsigned __int8 *)(v1282 + v1281);
                      unsigned int v1288 = v296 + 1;
                      do
                      {
                        *(unsigned char *)(v1284 + v1286) = v1287 << *((unsigned char *)v1283 + v1280 + v1286);
                        --v1288;
                        ++v1286;
                      }
                      while (v1288 > 1);
                      uint64_t v121 = *v15;
                      int v229 = (int **)*v16;
                      int v122 = *(int **)*v15;
                    }
                    ldiv_t v1289 = *(void **)(v121 + 24);
                    uint64_t v1290 = v1289[1];
                    v1281 += v1290;
                    v1280 += *((void *)v229[3] + 1);
                    v1284 += (int)v296;
                    ++v1285;
                    unint64_t v1291 = v122[1];
                  }
                  while (v1285 < v1291);
                  int v1278 = *v122;
                  int v230 = *v229;
                }
                else
                {
                  unint64_t v1291 = 0;
                  ldiv_t v1289 = *(void **)(v121 + 24);
                  uint64_t v1290 = v1289[1];
                }
                uint64_t v1281 = *v1289 + v1281 - v1291 * v1290;
                uint64_t v1280 = *(void *)v229[3] + v1280 - *((void *)v229[3] + 1) * v230[1];
                ++v1279;
              }
              while (v1279 < v1278);
            }
          }
          else if (v126 == 1)
          {
            int v855 = *v122;
            if (*v122)
            {
              unint64_t v856 = 0;
              uint64_t v857 = 0;
              uint64_t v858 = 0;
              uint64_t v859 = *(void *)(v121 + 152);
              uint64_t v860 = v229[19];
              uint64_t v861 = v120[19];
              do
              {
                if ((int)v296 >= 1)
                {
                  uint64_t v862 = 0;
                  int v863 = *(unsigned __int8 *)(v859 + v858);
                  unsigned int v864 = v296 + 1;
                  do
                  {
                    *(unsigned char *)(v861 + v862) = v863 << *((unsigned char *)v860 + v857 + v862);
                    --v864;
                    ++v862;
                  }
                  while (v864 > 1);
                  uint64_t v121 = *v15;
                  int v229 = (int **)*v16;
                  int v855 = **(_DWORD **)*v15;
                }
                v858 += **(void **)(v121 + 24);
                v857 += *(void *)v229[3];
                v861 += (int)v296;
                ++v856;
              }
              while (v856 < v855);
            }
          }
          else if (v120[6])
          {
            uint64_t v1515 = v229[19];
            uint64_t v1531 = *(void *)(v121 + 152);
            uint64_t v1551 = (int)v296;
            unint64_t v1571 = 0;
            unsigned int v1505 = v296 + 1;
            uint64_t v1292 = v120[19];
            do
            {
              uint64_t v1293 = *(void *)*v15;
              unint64_t v1294 = (unint64_t)(*(void *)(*v15 + 8) - v1293) >> 2;
              uint64_t v1295 = 0;
              uint64_t v1296 = (v1294 - 1);
              if ((int)v1294 - 1 >= 0)
              {
                uint64_t v1297 = *(void *)(*v15 + 24);
                int v1298 = v1571;
                do
                {
                  ldiv_t v1299 = ldiv(v1298, *(int *)(v1293 + 4 * v1296));
                  int v1298 = v1299.quot;
                  v1295 += *(void *)(v1297 + 8 * v1296--) * v1299.rem;
                }
                while (v1296 != -1);
              }
              uint64_t v1300 = *(void *)*v16;
              unint64_t v1301 = (unint64_t)(*(void *)(*v16 + 8) - v1300) >> 2;
              uint64_t v1302 = 0;
              uint64_t v1303 = (v1301 - 1);
              if ((int)v1301 - 1 >= 0)
              {
                uint64_t v1304 = *(void *)(*v16 + 24);
                int v1305 = v1571;
                do
                {
                  ldiv_t v1306 = ldiv(v1305, *(int *)(v1300 + 4 * v1303));
                  int v1305 = v1306.quot;
                  v1302 += *(void *)(v1304 + 8 * v1303--) * v1306.rem;
                }
                while (v1303 != -1);
              }
              if ((int)v1578 >= 1)
              {
                uint64_t v1307 = 0;
                int v1308 = *(unsigned __int8 *)(v1531 + (int)v1295);
                unsigned int v1309 = v1505;
                do
                {
                  *(unsigned char *)(v1292 + v1307) = v1308 << *((unsigned char *)v1515 + (int)v1302 + v1307);
                  --v1309;
                  ++v1307;
                }
                while (v1309 > 1);
                unsigned int v120 = *(void **)v1;
              }
              v1292 += v1551;
              v1571 += v1551;
            }
            while (v1571 < v120[6]);
          }
          break;
        case 2:
          if (v126 == 2)
          {
            int v1310 = *v122;
            if (*v122)
            {
              unint64_t v1311 = 0;
              uint64_t v1312 = 0;
              uint64_t v1313 = 0;
              uint64_t v1314 = *(void *)(v121 + 152);
              uint64_t v1315 = v229[19];
              uint64_t v1316 = v120[19];
              do
              {
                if (v122[1])
                {
                  unint64_t v1317 = 0;
                  do
                  {
                    if ((int)v296 >= 1)
                    {
                      uint64_t v1318 = 0;
                      char v1319 = *((unsigned char *)v1315 + v1312);
                      unsigned int v1320 = v296 + 1;
                      do
                      {
                        *(unsigned char *)(v1316 + v1318) = *(unsigned __int8 *)(v1314 + v1313 + v1318) << v1319;
                        --v1320;
                        ++v1318;
                      }
                      while (v1320 > 1);
                      uint64_t v121 = *v15;
                      int v229 = (int **)*v16;
                      int v122 = *(int **)*v15;
                    }
                    uint64_t v1321 = *(void **)(v121 + 24);
                    uint64_t v1322 = v1321[1];
                    v1313 += v1322;
                    v1312 += *((void *)v229[3] + 1);
                    v1316 += (int)v296;
                    ++v1317;
                    unint64_t v1323 = v122[1];
                  }
                  while (v1317 < v1323);
                  int v1310 = *v122;
                  int v230 = *v229;
                }
                else
                {
                  unint64_t v1323 = 0;
                  uint64_t v1321 = *(void **)(v121 + 24);
                  uint64_t v1322 = v1321[1];
                }
                uint64_t v1313 = *v1321 + v1313 - v1323 * v1322;
                uint64_t v1312 = *(void *)v229[3] + v1312 - *((void *)v229[3] + 1) * v230[1];
                ++v1311;
              }
              while (v1311 < v1310);
            }
          }
          else if (v126 == 1)
          {
            int v865 = *v122;
            if (*v122)
            {
              unint64_t v866 = 0;
              uint64_t v867 = 0;
              uint64_t v868 = 0;
              uint64_t v869 = *(void *)(v121 + 152);
              uint64_t v870 = v229[19];
              uint64_t v871 = v120[19];
              do
              {
                if ((int)v296 >= 1)
                {
                  uint64_t v872 = 0;
                  char v873 = *((unsigned char *)v870 + v867);
                  unsigned int v874 = v296 + 1;
                  do
                  {
                    *(unsigned char *)(v871 + v872) = *(unsigned __int8 *)(v869 + v868 + v872) << v873;
                    --v874;
                    ++v872;
                  }
                  while (v874 > 1);
                  uint64_t v121 = *v15;
                  int v229 = (int **)*v16;
                  int v865 = **(_DWORD **)*v15;
                }
                v868 += **(void **)(v121 + 24);
                v867 += *(void *)v229[3];
                v871 += (int)v296;
                ++v866;
              }
              while (v866 < v865);
            }
          }
          else if (v120[6])
          {
            uint64_t v1516 = v229[19];
            uint64_t v1532 = *(void *)(v121 + 152);
            uint64_t v1552 = (int)v296;
            unint64_t v1572 = 0;
            unsigned int v1506 = v296 + 1;
            uint64_t v1324 = v120[19];
            do
            {
              uint64_t v1325 = *(void *)*v15;
              unint64_t v1326 = (unint64_t)(*(void *)(*v15 + 8) - v1325) >> 2;
              uint64_t v1327 = 0;
              uint64_t v1328 = (v1326 - 1);
              if ((int)v1326 - 1 >= 0)
              {
                uint64_t v1329 = *(void *)(*v15 + 24);
                int v1330 = v1572;
                do
                {
                  ldiv_t v1331 = ldiv(v1330, *(int *)(v1325 + 4 * v1328));
                  int v1330 = v1331.quot;
                  v1327 += *(void *)(v1329 + 8 * v1328--) * v1331.rem;
                }
                while (v1328 != -1);
              }
              uint64_t v1332 = *(void *)*v16;
              unint64_t v1333 = (unint64_t)(*(void *)(*v16 + 8) - v1332) >> 2;
              uint64_t v1334 = 0;
              uint64_t v1335 = (v1333 - 1);
              if ((int)v1333 - 1 >= 0)
              {
                uint64_t v1336 = *(void *)(*v16 + 24);
                int v1337 = v1572;
                do
                {
                  ldiv_t v1338 = ldiv(v1337, *(int *)(v1332 + 4 * v1335));
                  int v1337 = v1338.quot;
                  v1334 += *(void *)(v1336 + 8 * v1335--) * v1338.rem;
                }
                while (v1335 != -1);
              }
              if ((int)v1578 >= 1)
              {
                uint64_t v1339 = 0;
                char v1340 = *((unsigned char *)v1516 + (int)v1334);
                unsigned int v1341 = v1506;
                do
                {
                  *(unsigned char *)(v1324 + v1339) = *(unsigned __int8 *)(v1532 + (int)v1327 + v1339) << v1340;
                  --v1341;
                  ++v1339;
                }
                while (v1341 > 1);
                unsigned int v120 = *(void **)v1;
              }
              v1324 += v1552;
              v1572 += v1552;
            }
            while (v1572 < v120[6]);
          }
          break;
        case 3:
          if (v126 == 2)
          {
            int v1070 = *v122;
            if (*v122)
            {
              unint64_t v1071 = 0;
              uint64_t v1072 = 0;
              uint64_t v1073 = 0;
              uint64_t v1074 = *(void *)(v121 + 152);
              uint64_t v1075 = v229[19];
              uint64_t v1076 = v120[19];
              do
              {
                if (v122[1])
                {
                  unint64_t v1077 = 0;
                  do
                  {
                    if ((int)v296 >= 1)
                    {
                      uint64_t v1078 = 0;
                      unsigned int v1079 = v296 + 1;
                      do
                      {
                        *(unsigned char *)(v1076 + v1078) = *(unsigned __int8 *)(v1074 + v1073 + v1078) << *((unsigned char *)v1075 + v1072 + v1078);
                        --v1079;
                        ++v1078;
                      }
                      while (v1079 > 1);
                      uint64_t v121 = *v15;
                      int v229 = (int **)*v16;
                      int v122 = *(int **)*v15;
                    }
                    uint64_t v1080 = *(void **)(v121 + 24);
                    uint64_t v1081 = v1080[1];
                    v1073 += v1081;
                    v1072 += *((void *)v229[3] + 1);
                    v1076 += (int)v296;
                    ++v1077;
                    unint64_t v1082 = v122[1];
                  }
                  while (v1077 < v1082);
                  int v1070 = *v122;
                  int v230 = *v229;
                }
                else
                {
                  unint64_t v1082 = 0;
                  uint64_t v1080 = *(void **)(v121 + 24);
                  uint64_t v1081 = v1080[1];
                }
                uint64_t v1073 = *v1080 + v1073 - v1082 * v1081;
                uint64_t v1072 = *(void *)v229[3] + v1072 - *((void *)v229[3] + 1) * v230[1];
                ++v1071;
              }
              while (v1071 < v1070);
            }
          }
          else if (v126 == 1)
          {
            int v341 = *v122;
            if (*v122)
            {
              unint64_t v342 = 0;
              uint64_t v343 = 0;
              uint64_t v344 = 0;
              uint64_t v345 = *(void *)(v121 + 152);
              uint64_t v346 = v229[19];
              uint64_t v347 = v120[19];
              do
              {
                if ((int)v296 >= 1)
                {
                  uint64_t v348 = 0;
                  unsigned int v349 = v296 + 1;
                  do
                  {
                    *(unsigned char *)(v347 + v348) = *(unsigned __int8 *)(v345 + v344 + v348) << *((unsigned char *)v346 + v343 + v348);
                    --v349;
                    ++v348;
                  }
                  while (v349 > 1);
                  uint64_t v121 = *v15;
                  int v229 = (int **)*v16;
                  int v341 = **(_DWORD **)*v15;
                }
                v344 += **(void **)(v121 + 24);
                v343 += *(void *)v229[3];
                v347 += (int)v296;
                ++v342;
              }
              while (v342 < v341);
            }
          }
          else if (v120[6])
          {
            uint64_t v1514 = v229[19];
            uint64_t v1525 = *(void *)(v121 + 152);
            uint64_t v1543 = (int)v296;
            unint64_t v1567 = 0;
            unsigned int v1504 = v296 + 1;
            uint64_t v1083 = v120[19];
            do
            {
              uint64_t v1084 = *(void *)*v15;
              unint64_t v1085 = (unint64_t)(*(void *)(*v15 + 8) - v1084) >> 2;
              uint64_t v1086 = 0;
              uint64_t v1087 = (v1085 - 1);
              if ((int)v1085 - 1 >= 0)
              {
                uint64_t v1088 = *(void *)(*v15 + 24);
                int v1089 = v1567;
                do
                {
                  ldiv_t v1090 = ldiv(v1089, *(int *)(v1084 + 4 * v1087));
                  int v1089 = v1090.quot;
                  v1086 += *(void *)(v1088 + 8 * v1087--) * v1090.rem;
                }
                while (v1087 != -1);
              }
              uint64_t v1091 = *(void *)*v16;
              unint64_t v1092 = (unint64_t)(*(void *)(*v16 + 8) - v1091) >> 2;
              uint64_t v1093 = 0;
              uint64_t v1094 = (v1092 - 1);
              if ((int)v1092 - 1 >= 0)
              {
                uint64_t v1095 = *(void *)(*v16 + 24);
                int v1096 = v1567;
                do
                {
                  ldiv_t v1097 = ldiv(v1096, *(int *)(v1091 + 4 * v1094));
                  int v1096 = v1097.quot;
                  v1093 += *(void *)(v1095 + 8 * v1094--) * v1097.rem;
                }
                while (v1094 != -1);
              }
              if ((int)v1578 >= 1)
              {
                uint64_t v1098 = 0;
                unsigned int v1099 = v1504;
                do
                {
                  *(unsigned char *)(v1083 + v1098) = *(unsigned __int8 *)(v1525 + (int)v1086 + v1098) << *((unsigned char *)v1514
                                                                                                  + (int)v1093
                                                                                                  + v1098);
                  --v1099;
                  ++v1098;
                }
                while (v1099 > 1);
                unsigned int v120 = *(void **)v1;
              }
              v1083 += v1543;
              v1567 += v1543;
            }
            while (v1567 < v120[6]);
          }
          break;
        default:
LABEL_328:
          switch(v292)
          {
            case 1uLL:
              if (v120[6])
              {
                unint64_t v297 = 0;
                uint64_t v298 = 0;
                uint64_t v299 = 0;
                uint64_t v300 = *(void *)(v121 + 152);
                v301 = v229[19];
                uint64_t v302 = v120[19];
                do
                {
                  *(unsigned char *)(v302 + v297) = *(unsigned __int8 *)(v300 + v299) << *((unsigned char *)v301 + v298);
                  v299 += **(void **)(*v15 + 24);
                  v298 += **(void **)(*v16 + 24);
                  ++v297;
                }
                while (v297 < *(void *)(*(void *)v1 + 48));
              }
              break;
            case 2uLL:
              int v611 = *v122;
              if (*v122)
              {
                unint64_t v612 = 0;
                uint64_t v613 = 0;
                uint64_t v614 = 0;
                uint64_t v615 = 0;
                uint64_t v616 = *(void *)(v121 + 152);
                int v617 = v229[19];
                uint64_t v618 = v120[19];
                do
                {
                  if (v122[1])
                  {
                    unint64_t v619 = 0;
                    do
                    {
                      *(unsigned char *)(v618 + v613 + v619) = *(unsigned __int8 *)(v616 + v615) << *((unsigned char *)v617 + v614);
                      uint64_t v121 = *v15;
                      uint64_t v620 = *(void **)(*v15 + 24);
                      uint64_t v621 = v620[1];
                      v615 += v621;
                      int v229 = (int **)*v16;
                      int v622 = *(int **)(*v16 + 24);
                      uint64_t v623 = *((void *)v622 + 1);
                      v614 += v623;
                      ++v619;
                      int v122 = *(int **)*v15;
                      unint64_t v624 = v122[1];
                    }
                    while (v619 < v624);
                    int v611 = *v122;
                    int v230 = *v229;
                    v613 += v619;
                  }
                  else
                  {
                    unint64_t v624 = 0;
                    uint64_t v620 = *(void **)(v121 + 24);
                    uint64_t v621 = v620[1];
                    int v622 = v229[3];
                    uint64_t v623 = *((void *)v622 + 1);
                  }
                  uint64_t v615 = *v620 + v615 - v624 * v621;
                  uint64_t v614 = *(void *)v622 + v614 - v623 * v230[1];
                  ++v612;
                }
                while (v612 < v611);
              }
              break;
            case 3uLL:
              int v625 = *v122;
              if (*v122)
              {
                unint64_t v626 = 0;
                uint64_t v627 = 0;
                uint64_t v628 = 0;
                uint64_t v629 = 0;
                uint64_t v630 = *(void *)(v121 + 152);
                unint64_t v631 = v229[19];
                uint64_t v632 = v120[19];
                do
                {
                  if (v122[1])
                  {
                    unint64_t v633 = 0;
                    do
                    {
                      if (v122[2])
                      {
                        unint64_t v634 = 0;
                        do
                        {
                          *(unsigned char *)(v632 + v627 + v634) = *(unsigned __int8 *)(v630 + v629) << *((unsigned char *)v631 + v628);
                          uint64_t v121 = *v15;
                          uint64_t v635 = *(void **)(*v15 + 24);
                          uint64_t v636 = v635[2];
                          v629 += v636;
                          int v229 = (int **)*v16;
                          uint64_t v637 = *(int **)(*v16 + 24);
                          uint64_t v638 = *((void *)v637 + 2);
                          v628 += v638;
                          ++v634;
                          int v122 = *(int **)*v15;
                          unint64_t v639 = v122[2];
                        }
                        while (v634 < v639);
                        int v230 = *v229;
                        v627 += v634;
                      }
                      else
                      {
                        unint64_t v639 = 0;
                        uint64_t v635 = *(void **)(v121 + 24);
                        uint64_t v636 = v635[2];
                        uint64_t v637 = v229[3];
                        uint64_t v638 = *((void *)v637 + 2);
                      }
                      uint64_t v640 = v635[1];
                      uint64_t v629 = v640 + v629 - v639 * v636;
                      uint64_t v628 = *((void *)v637 + 1) + v628 - v638 * v230[2];
                      ++v633;
                      unint64_t v641 = v122[1];
                    }
                    while (v633 < v641);
                    int v625 = *v122;
                  }
                  else
                  {
                    unint64_t v641 = 0;
                    uint64_t v635 = *(void **)(v121 + 24);
                    uint64_t v640 = v635[1];
                  }
                  uint64_t v629 = *v635 + v629 - v641 * v640;
                  uint64_t v628 = *(void *)v229[3] + v628 - *((void *)v229[3] + 1) * v230[1];
                  ++v626;
                }
                while (v626 < v625);
              }
              break;
            case 4uLL:
              int v642 = *v122;
              if (*v122)
              {
                unint64_t v643 = 0;
                uint64_t v644 = 0;
                uint64_t v645 = 0;
                uint64_t v646 = 0;
                uint64_t v647 = *(void *)(v121 + 152);
                unint64_t v648 = v229[19];
                uint64_t v649 = v120[19];
                do
                {
                  if (v122[1])
                  {
                    unint64_t v650 = 0;
                    do
                    {
                      if (v122[2])
                      {
                        unint64_t v651 = 0;
                        do
                        {
                          if (v122[3])
                          {
                            unint64_t v652 = 0;
                            do
                            {
                              *(unsigned char *)(v649 + v644 + v652) = *(unsigned __int8 *)(v647 + v646) << *((unsigned char *)v648 + v645);
                              uint64_t v121 = *v15;
                              unint64_t v653 = *(void **)(*v15 + 24);
                              uint64_t v654 = v653[3];
                              v646 += v654;
                              int v229 = (int **)*v16;
                              unint64_t v655 = *(int **)(*v16 + 24);
                              uint64_t v656 = *((void *)v655 + 3);
                              v645 += v656;
                              ++v652;
                              int v122 = *(int **)*v15;
                              unint64_t v657 = v122[3];
                            }
                            while (v652 < v657);
                            int v230 = *v229;
                            v644 += v652;
                          }
                          else
                          {
                            unint64_t v657 = 0;
                            unint64_t v653 = *(void **)(v121 + 24);
                            uint64_t v654 = v653[3];
                            unint64_t v655 = v229[3];
                            uint64_t v656 = *((void *)v655 + 3);
                          }
                          uint64_t v658 = v653[2];
                          uint64_t v646 = v658 + v646 - v657 * v654;
                          uint64_t v645 = *((void *)v655 + 2) + v645 - v656 * v230[3];
                          ++v651;
                          unint64_t v659 = v122[2];
                        }
                        while (v651 < v659);
                      }
                      else
                      {
                        unint64_t v659 = 0;
                        unint64_t v653 = *(void **)(v121 + 24);
                        uint64_t v658 = v653[2];
                      }
                      uint64_t v646 = v653[1] + v646 - v659 * v658;
                      uint64_t v645 = *((void *)v229[3] + 1) + v645 - *((void *)v229[3] + 2) * v230[2];
                      ++v650;
                      unint64_t v660 = v122[1];
                    }
                    while (v650 < v660);
                    int v642 = *v122;
                  }
                  else
                  {
                    unint64_t v660 = 0;
                  }
                  uint64_t v646 = **(void **)(v121 + 24) + v646 - *(void *)(*(void *)(v121 + 24) + 8) * v660;
                  uint64_t v645 = *(void *)v229[3] + v645 - *((void *)v229[3] + 1) * v230[1];
                  ++v643;
                }
                while (v643 < v642);
              }
              break;
            default:
              if (v120[6])
              {
                unint64_t v595 = 0;
                uint64_t v1561 = v229[19];
                uint64_t v1579 = *(void *)(v121 + 152);
                uint64_t v596 = v120[19];
                do
                {
                  uint64_t v597 = *(void *)*v15;
                  unint64_t v598 = (unint64_t)(*(void *)(*v15 + 8) - v597) >> 2;
                  uint64_t v599 = 0;
                  uint64_t v600 = (v598 - 1);
                  if ((int)v598 - 1 >= 0)
                  {
                    uint64_t v601 = *(void *)(*v15 + 24);
                    int v602 = v595;
                    do
                    {
                      ldiv_t v603 = ldiv(v602, *(int *)(v597 + 4 * v600));
                      int v602 = v603.quot;
                      v599 += *(void *)(v601 + 8 * v600--) * v603.rem;
                    }
                    while (v600 != -1);
                  }
                  uint64_t v604 = *(void *)*v16;
                  unint64_t v605 = (unint64_t)(*(void *)(*v16 + 8) - v604) >> 2;
                  uint64_t v606 = 0;
                  uint64_t v607 = (v605 - 1);
                  if ((int)v605 - 1 >= 0)
                  {
                    uint64_t v608 = *(void *)(*v16 + 24);
                    int v609 = v595;
                    do
                    {
                      ldiv_t v610 = ldiv(v609, *(int *)(v604 + 4 * v607));
                      int v609 = v610.quot;
                      v606 += *(void *)(v608 + 8 * v607--) * v610.rem;
                    }
                    while (v607 != -1);
                  }
                  *(unsigned char *)(v596 + v595++) = *(unsigned __int8 *)(v1579 + (int)v599) << *((unsigned char *)v1561 + (int)v606);
                }
                while (v595 < *(void *)(*(void *)v1 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 4:
      char v7 = *(uint64_t **)a1;
      BOOL v6 = *(uint64_t **)(a1 + 8);
      switch(v20)
      {
        case 0:
LABEL_12:
          **(_DWORD **)(*(void *)v1 + 152) = **(_DWORD **)(*v7 + 152) << **(_DWORD **)(*v6 + 152);
          return;
        case 1:
          int v157 = *(_DWORD *)(*v6 + 160);
          if (v157 >= 1)
          {
            int v158 = **(_DWORD **)(*v7 + 152);
            char v159 = *(_DWORD **)(*(void *)v1 + 152);
            int v160 = *(int **)(*v6 + 152);
            unsigned int v161 = v157 + 1;
            do
            {
              int v162 = *v160++;
              *v159++ = v158 << v162;
              --v161;
            }
            while (v161 > 1);
          }
          return;
        case 2:
          int v163 = *(_DWORD *)(*v7 + 160);
          if (v163 >= 1)
          {
            int v164 = **(_DWORD **)(*v6 + 152);
            int v165 = *(_DWORD **)(*(void *)v1 + 152);
            unsigned int v166 = *(int **)(*v7 + 152);
            unsigned int v167 = v163 + 1;
            do
            {
              int v168 = *v166++;
              *v165++ = v168 << v164;
              --v167;
            }
            while (v167 > 1);
          }
          return;
        case 3:
          int v169 = *(_DWORD *)(*(void *)v1 + 48);
          if (v169 >= 1)
          {
            v170 = *(_DWORD **)(*(void *)v1 + 152);
            unsigned int v171 = *(int **)(*v6 + 152);
            int v172 = *(int **)(*v7 + 152);
            unsigned int v173 = v169 + 1;
            do
            {
              int v175 = *v172++;
              int v174 = v175;
              int v176 = *v171++;
              *v170++ = v174 << v176;
              --v173;
            }
            while (v173 > 1);
          }
          return;
        default:
          unsigned int v148 = *(void **)v1;
          char v149 = (void *)*v7;
          int v150 = *(int **)*v7;
          uint64_t v151 = (v149[1] - (void)v150) >> 2;
          uint64_t v152 = (v151 - 1);
          if ((int)v152 >= -1) {
            int v153 = -1;
          }
          else {
            int v153 = v151 - 1;
          }
          int v154 = v153 + 1;
          int v155 = v151 + 1;
          break;
      }
      while (1)
      {
        unsigned int v156 = v155 - 2;
        if (v155 - 2 < 0) {
          break;
        }
        --v155;
        if (*(void *)(v149[3] + 8 * v156) != *(void *)(v148[3] + 8 * v156)) {
          goto LABEL_199;
        }
      }
      int v155 = v154;
LABEL_199:
      uint64_t v236 = (void *)*v6;
      int v237 = *(int **)*v6;
      uint64_t v238 = (v236[1] - (void)v237) >> 2;
      uint64_t v239 = (v238 - 1);
      if ((int)v239 >= -1) {
        int v240 = -1;
      }
      else {
        int v240 = v238 - 1;
      }
      int v241 = v240 + 1;
      int v242 = v238 + 1;
      while (1)
      {
        unsigned int v243 = v242 - 2;
        if (v242 - 2 < 0) {
          break;
        }
        --v242;
        if (*(void *)(v236[3] + 8 * v243) != *(void *)(v148[3] + 8 * v243)) {
          goto LABEL_230;
        }
      }
      int v242 = v241;
LABEL_230:
      int v258 = v151 + 1;
      while (1)
      {
        unsigned int v259 = v258 - 2;
        if (v258 - 2 < 0) {
          break;
        }
        --v258;
        if (*(void *)(v149[3] + 8 * v259)) {
          goto LABEL_255;
        }
      }
      int v258 = v154;
LABEL_255:
      int v268 = v238 + 1;
      while (1)
      {
        unsigned int v269 = v268 - 2;
        if (v268 - 2 < 0) {
          break;
        }
        --v268;
        if (*(void *)(v236[3] + 8 * v269)) {
          goto LABEL_334;
        }
      }
      int v268 = v241;
LABEL_334:
      unint64_t v303 = (uint64_t)(v148[1] - *v148) >> 2;
      if (v155 <= v242) {
        int v304 = v242;
      }
      else {
        int v304 = v155;
      }
      if (v155 <= v268) {
        int v155 = v268;
      }
      if (v258 > v242) {
        int v242 = v258;
      }
      if (v303 > v242)
      {
        int v305 = 1;
      }
      else
      {
        int v242 = (uint64_t)(v148[1] - *v148) >> 2;
        int v305 = 4;
      }
      if (v303 > v155)
      {
        int v306 = 2;
      }
      else
      {
        int v155 = v242;
        int v306 = v305;
      }
      if (v303 > v304)
      {
        int v155 = v304;
        int v306 = 3;
      }
      uint64_t v1558 = v239;
      uint64_t v1576 = v152;
      if (!v155) {
        goto LABEL_351;
      }
      unint64_t v307 = *(void *)(v148[3] + 8 * (v155 - 1));
      if (v307 < 0x10) {
        goto LABEL_351;
      }
      switch(v306)
      {
        case 1:
          if (v155 == 2)
          {
            int v1342 = *v150;
            if (*v150)
            {
              unint64_t v1343 = 0;
              uint64_t v1344 = 0;
              uint64_t v1345 = 0;
              uint64_t v1346 = v149[19];
              uint64_t v1347 = v236[19];
              uint64_t v1348 = v148[19];
              uint64_t v1349 = (uint64_t *)v149[3];
              uint64_t v1350 = *v1349;
              uint64_t v1351 = v1349[1];
              unsigned int v1352 = (uint64_t *)v236[3];
              uint64_t v1353 = *v1352;
              uint64_t v1354 = v1352[1];
              int v1355 = v150[1];
              int v1356 = v1355;
              do
              {
                if (v1356)
                {
                  unint64_t v1357 = 0;
                  uint64_t v1358 = v1347 + 4 * v1344;
                  do
                  {
                    if ((int)v307 >= 1)
                    {
                      uint64_t v1359 = 0;
                      int v1360 = *(_DWORD *)(v1346 + 4 * v1345);
                      unsigned int v1361 = v307 + 1;
                      do
                      {
                        *(_DWORD *)(v1348 + v1359) = v1360 << *(_DWORD *)(v1358 + v1359);
                        --v1361;
                        v1359 += 4;
                      }
                      while (v1361 > 1);
                      int v1355 = v150[1];
                    }
                    v1345 += v1351;
                    v1344 += v1354;
                    v1348 += 4 * (int)v307;
                    ++v1357;
                    v1358 += 4 * v1354;
                  }
                  while (v1357 < v1355);
                  uint64_t v1362 = v1355;
                  int v1342 = *v150;
                  int v1356 = v1355;
                }
                else
                {
                  uint64_t v1362 = 0;
                }
                uint64_t v1345 = v1345 + v1350 - v1362 * v1351;
                uint64_t v1344 = v1344 + v1353 - v1354 * v237[1];
                ++v1343;
              }
              while (v1343 < v1342);
            }
          }
          else if (v155 == 1)
          {
            int v875 = *v150;
            if (*v150)
            {
              unint64_t v876 = 0;
              uint64_t v877 = 0;
              uint64_t v878 = v149[19];
              uint64_t v879 = v236[19];
              uint64_t v880 = v148[19];
              uint64_t v881 = *(void *)v149[3];
              uint64_t v882 = 4 * *(void *)v236[3];
              do
              {
                if ((int)v307 >= 1)
                {
                  uint64_t v883 = 0;
                  int v884 = *(_DWORD *)(v878 + 4 * v877);
                  unsigned int v885 = v307 + 1;
                  do
                  {
                    *(_DWORD *)(v880 + v883) = v884 << *(_DWORD *)(v879 + v883);
                    --v885;
                    v883 += 4;
                  }
                  while (v885 > 1);
                  int v875 = *v150;
                }
                v877 += v881;
                ++v876;
                v880 += 4 * (int)v307;
                v879 += v882;
              }
              while (v876 < v875);
            }
          }
          else
          {
            unint64_t v1533 = v148[6];
            if (v1533)
            {
              unint64_t v1553 = 0;
              uint64_t v1490 = v236[19];
              uint64_t v1499 = v149[19];
              uint64_t v1363 = v148[19];
              do
              {
                uint64_t v1364 = 0;
                if ((v152 & 0x80000000) == 0)
                {
                  uint64_t v1365 = v149[3];
                  uint64_t v1366 = v152;
                  int v1367 = v1553;
                  do
                  {
                    ldiv_t v1368 = ldiv(v1367, v150[v1366]);
                    int v1367 = v1368.quot;
                    v1364 += *(void *)(v1365 + 8 * v1366--) * v1368.rem;
                  }
                  while (v1366 != -1);
                }
                uint64_t v1369 = v1558;
                if ((v1558 & 0x80000000) != 0)
                {
                  LODWORD(v1370) = 0;
                }
                else
                {
                  uint64_t v1370 = 0;
                  uint64_t v1371 = v236[3];
                  int v1372 = v1553;
                  do
                  {
                    ldiv_t v1373 = ldiv(v1372, v237[v1369]);
                    int v1372 = v1373.quot;
                    v1370 += *(void *)(v1371 + 8 * v1369--) * v1373.rem;
                  }
                  while (v1369 != -1);
                }
                uint64_t v152 = v1576;
                if ((int)v307 >= 1)
                {
                  uint64_t v1374 = 0;
                  int v1375 = *(_DWORD *)(v1499 + 4 * (int)v1364);
                  unsigned int v1376 = v307 + 1;
                  do
                  {
                    *(_DWORD *)(v1363 + v1374) = v1375 << *(_DWORD *)(v1490 + 4 * (int)v1370 + v1374);
                    --v1376;
                    v1374 += 4;
                  }
                  while (v1376 > 1);
                }
                v1363 += 4 * (int)v307;
                v1553 += (int)v307;
              }
              while (v1553 < v1533);
            }
          }
          break;
        case 2:
          if (v155 == 2)
          {
            int v1377 = *v150;
            if (*v150)
            {
              unint64_t v1378 = 0;
              uint64_t v1379 = 0;
              uint64_t v1380 = 0;
              uint64_t v1381 = v149[19];
              uint64_t v1382 = v236[19];
              uint64_t v1383 = v148[19];
              unint64_t v1384 = (uint64_t *)v149[3];
              uint64_t v1385 = *v1384;
              uint64_t v1386 = v1384[1];
              uint64_t v1387 = (uint64_t *)v236[3];
              uint64_t v1388 = *v1387;
              uint64_t v1389 = v1387[1];
              int v1390 = v150[1];
              int v1391 = v1390;
              do
              {
                if (v1391)
                {
                  unint64_t v1392 = 0;
                  uint64_t v1393 = v1381 + 4 * v1380;
                  do
                  {
                    if ((int)v307 >= 1)
                    {
                      uint64_t v1394 = 0;
                      int v1395 = *(_DWORD *)(v1382 + 4 * v1379);
                      unsigned int v1396 = v307 + 1;
                      do
                      {
                        *(_DWORD *)(v1383 + v1394) = *(_DWORD *)(v1393 + v1394) << v1395;
                        --v1396;
                        v1394 += 4;
                      }
                      while (v1396 > 1);
                      int v1390 = v150[1];
                    }
                    v1380 += v1386;
                    v1379 += v1389;
                    v1383 += 4 * (int)v307;
                    ++v1392;
                    v1393 += 4 * v1386;
                  }
                  while (v1392 < v1390);
                  uint64_t v1397 = v1390;
                  int v1377 = *v150;
                  int v1391 = v1390;
                }
                else
                {
                  uint64_t v1397 = 0;
                }
                uint64_t v1380 = v1380 + v1385 - v1397 * v1386;
                uint64_t v1379 = v1379 + v1388 - v1389 * v237[1];
                ++v1378;
              }
              while (v1378 < v1377);
            }
          }
          else if (v155 == 1)
          {
            int v886 = *v150;
            if (*v150)
            {
              unint64_t v887 = 0;
              uint64_t v888 = 0;
              uint64_t v889 = v149[19];
              uint64_t v890 = v236[19];
              uint64_t v891 = v148[19];
              uint64_t v892 = *(void *)v236[3];
              uint64_t v893 = 4 * *(void *)v149[3];
              do
              {
                if ((int)v307 >= 1)
                {
                  uint64_t v894 = 0;
                  int v895 = *(_DWORD *)(v890 + 4 * v888);
                  unsigned int v896 = v307 + 1;
                  do
                  {
                    *(_DWORD *)(v891 + v894) = *(_DWORD *)(v889 + v894) << v895;
                    --v896;
                    v894 += 4;
                  }
                  while (v896 > 1);
                  int v886 = *v150;
                }
                v888 += v892;
                ++v887;
                v891 += 4 * (int)v307;
                v889 += v893;
              }
              while (v887 < v886);
            }
          }
          else
          {
            unint64_t v1534 = v148[6];
            if (v1534)
            {
              unint64_t v1554 = 0;
              uint64_t v1491 = v236[19];
              uint64_t v1500 = v149[19];
              uint64_t v1398 = v148[19];
              do
              {
                uint64_t v1399 = 0;
                if ((v152 & 0x80000000) == 0)
                {
                  uint64_t v1400 = v149[3];
                  uint64_t v1401 = v152;
                  int v1402 = v1554;
                  do
                  {
                    ldiv_t v1403 = ldiv(v1402, v150[v1401]);
                    int v1402 = v1403.quot;
                    v1399 += *(void *)(v1400 + 8 * v1401--) * v1403.rem;
                  }
                  while (v1401 != -1);
                }
                uint64_t v1404 = v1558;
                if ((v1558 & 0x80000000) != 0)
                {
                  LODWORD(v1405) = 0;
                }
                else
                {
                  uint64_t v1405 = 0;
                  uint64_t v1406 = v236[3];
                  int v1407 = v1554;
                  do
                  {
                    ldiv_t v1408 = ldiv(v1407, v237[v1404]);
                    int v1407 = v1408.quot;
                    v1405 += *(void *)(v1406 + 8 * v1404--) * v1408.rem;
                  }
                  while (v1404 != -1);
                }
                uint64_t v152 = v1576;
                if ((int)v307 >= 1)
                {
                  uint64_t v1409 = 0;
                  int v1410 = *(_DWORD *)(v1491 + 4 * (int)v1405);
                  unsigned int v1411 = v307 + 1;
                  do
                  {
                    *(_DWORD *)(v1398 + v1409) = *(_DWORD *)(v1500 + 4 * (int)v1399 + v1409) << v1410;
                    --v1411;
                    v1409 += 4;
                  }
                  while (v1411 > 1);
                }
                v1398 += 4 * (int)v307;
                v1554 += (int)v307;
              }
              while (v1554 < v1534);
            }
          }
          break;
        case 3:
          if (v155 == 2)
          {
            int v1100 = *v150;
            if (*v150)
            {
              unint64_t v1101 = 0;
              uint64_t v1102 = 0;
              uint64_t v1103 = 0;
              uint64_t v1104 = v149[19];
              uint64_t v1105 = v236[19];
              uint64_t v1106 = v148[19];
              uint64_t v1107 = (uint64_t *)v149[3];
              uint64_t v1108 = *v1107;
              uint64_t v1109 = v1107[1];
              unint64_t v1110 = (uint64_t *)v236[3];
              uint64_t v1111 = *v1110;
              uint64_t v1112 = v1110[1];
              int v1113 = v150[1];
              int v1114 = v1113;
              do
              {
                if (v1114)
                {
                  unint64_t v1115 = 0;
                  uint64_t v1116 = v1105 + 4 * v1102;
                  uint64_t v1117 = v1104 + 4 * v1103;
                  do
                  {
                    if ((int)v307 >= 1)
                    {
                      uint64_t v1118 = 0;
                      unsigned int v1119 = v307 + 1;
                      do
                      {
                        *(_DWORD *)(v1106 + v1118) = *(_DWORD *)(v1117 + v1118) << *(_DWORD *)(v1116 + v1118);
                        --v1119;
                        v1118 += 4;
                      }
                      while (v1119 > 1);
                      int v1113 = v150[1];
                    }
                    v1103 += v1109;
                    v1102 += v1112;
                    v1106 += 4 * (int)v307;
                    ++v1115;
                    v1116 += 4 * v1112;
                    v1117 += 4 * v1109;
                  }
                  while (v1115 < v1113);
                  uint64_t v1120 = v1113;
                  int v1100 = *v150;
                  int v1114 = v1113;
                }
                else
                {
                  uint64_t v1120 = 0;
                }
                uint64_t v1103 = v1103 + v1108 - v1120 * v1109;
                uint64_t v1102 = v1102 + v1111 - v1112 * v237[1];
                ++v1101;
              }
              while (v1101 < v1100);
            }
          }
          else if (v155 == 1)
          {
            int v350 = *v150;
            if (*v150)
            {
              unint64_t v351 = 0;
              uint64_t v352 = v149[19];
              uint64_t v353 = v236[19];
              uint64_t v354 = v148[19];
              uint64_t v355 = 4 * *(void *)v236[3];
              uint64_t v356 = 4 * *(void *)v149[3];
              do
              {
                if ((int)v307 >= 1)
                {
                  uint64_t v357 = 0;
                  unsigned int v358 = v307 + 1;
                  do
                  {
                    *(_DWORD *)(v354 + v357) = *(_DWORD *)(v352 + v357) << *(_DWORD *)(v353 + v357);
                    --v358;
                    v357 += 4;
                  }
                  while (v358 > 1);
                  int v350 = *v150;
                }
                ++v351;
                v354 += 4 * (int)v307;
                v353 += v355;
                v352 += v356;
              }
              while (v351 < v350);
            }
          }
          else
          {
            unint64_t v1526 = v148[6];
            if (v1526)
            {
              unint64_t v1544 = 0;
              uint64_t v1486 = v236[19];
              uint64_t v1495 = v149[19];
              uint64_t v1121 = v148[19];
              do
              {
                uint64_t v1122 = 0;
                if ((v152 & 0x80000000) == 0)
                {
                  uint64_t v1123 = v149[3];
                  uint64_t v1124 = v152;
                  int v1125 = v1544;
                  do
                  {
                    ldiv_t v1126 = ldiv(v1125, v150[v1124]);
                    int v1125 = v1126.quot;
                    v1122 += *(void *)(v1123 + 8 * v1124--) * v1126.rem;
                  }
                  while (v1124 != -1);
                }
                uint64_t v1127 = v1558;
                if ((v1558 & 0x80000000) != 0)
                {
                  LODWORD(v1128) = 0;
                }
                else
                {
                  uint64_t v1128 = 0;
                  uint64_t v1129 = v236[3];
                  int v1130 = v1544;
                  do
                  {
                    ldiv_t v1131 = ldiv(v1130, v237[v1127]);
                    int v1130 = v1131.quot;
                    v1128 += *(void *)(v1129 + 8 * v1127--) * v1131.rem;
                  }
                  while (v1127 != -1);
                }
                uint64_t v152 = v1576;
                if ((int)v307 >= 1)
                {
                  uint64_t v1132 = 0;
                  unsigned int v1133 = v307 + 1;
                  do
                  {
                    *(_DWORD *)(v1121 + v1132) = *(_DWORD *)(v1495 + 4 * (int)v1122 + v1132) << *(_DWORD *)(v1486 + 4 * (int)v1128 + v1132);
                    --v1133;
                    v1132 += 4;
                  }
                  while (v1133 > 1);
                }
                v1121 += 4 * (int)v307;
                v1544 += (int)v307;
              }
              while (v1544 < v1526);
            }
          }
          break;
        default:
LABEL_351:
          switch(v303)
          {
            case 1uLL:
              uint64_t v308 = v148[6];
              if (v308)
              {
                int v309 = (_DWORD *)v149[19];
                unint64_t v310 = (_DWORD *)v236[19];
                unint64_t v311 = (_DWORD *)v148[19];
                uint64_t v312 = 4 * *(void *)v236[3];
                uint64_t v313 = 4 * *(void *)v149[3];
                do
                {
                  *v311++ = *v309 << *v310;
                  unint64_t v310 = (_DWORD *)((char *)v310 + v312);
                  int v309 = (_DWORD *)((char *)v309 + v313);
                  --v308;
                }
                while (v308);
              }
              break;
            case 2uLL:
              int v673 = *v150;
              if (*v150)
              {
                unint64_t v674 = 0;
                uint64_t v675 = 0;
                uint64_t v676 = 0;
                uint64_t v677 = 0;
                uint64_t v678 = v149[19];
                uint64_t v679 = v236[19];
                uint64_t v680 = v148[19];
                uint64_t v681 = (uint64_t *)v149[3];
                uint64_t v682 = *v681;
                uint64_t v683 = v681[1];
                unint64_t v684 = (uint64_t *)v236[3];
                uint64_t v686 = *v684;
                uint64_t v685 = v684[1];
                int v687 = v150[1];
                do
                {
                  if (v687)
                  {
                    for (unint64_t m = 0; m < v687; ++m)
                    {
                      *(_DWORD *)(v680 + 4 * v675 + 4 * m) = *(_DWORD *)(v678 + 4 * v677) << *(_DWORD *)(v679 + 4 * v676);
                      v677 += v683;
                      v676 += v685;
                      int v687 = v150[1];
                    }
                    uint64_t v689 = v687;
                    int v673 = *v150;
                    v675 += m;
                  }
                  else
                  {
                    uint64_t v689 = 0;
                  }
                  uint64_t v677 = v677 + v682 - v689 * v683;
                  uint64_t v676 = v676 + v686 - v685 * v237[1];
                  ++v674;
                }
                while (v674 < v673);
              }
              break;
            case 3uLL:
              int v690 = *v150;
              if (*v150)
              {
                unint64_t v691 = 0;
                uint64_t v692 = 0;
                uint64_t v693 = 0;
                uint64_t v694 = 0;
                uint64_t v695 = v149[19];
                uint64_t v696 = v236[19];
                uint64_t v697 = v148[19];
                uint64_t v698 = (uint64_t *)v149[3];
                uint64_t v699 = *v698;
                uint64_t v700 = v698[1];
                uint64_t v701 = (uint64_t *)v236[3];
                uint64_t v702 = *v701;
                uint64_t v703 = v701[1];
                int v704 = v150[1];
                int v705 = v704;
                do
                {
                  if (v705)
                  {
                    unint64_t v706 = 0;
                    uint64_t v707 = v698[2];
                    uint64_t v708 = v701[2];
                    int v709 = v150[2];
                    do
                    {
                      if (v709)
                      {
                        for (unint64_t n = 0; n < v709; ++n)
                        {
                          *(_DWORD *)(v697 + 4 * v692 + 4 * n) = *(_DWORD *)(v695 + 4 * v694) << *(_DWORD *)(v696 + 4 * v693);
                          v694 += v707;
                          v693 += v708;
                          int v709 = v150[2];
                        }
                        uint64_t v711 = v709;
                        int v704 = v150[1];
                        v692 += n;
                      }
                      else
                      {
                        uint64_t v711 = 0;
                      }
                      uint64_t v694 = v694 + v700 - v711 * v707;
                      uint64_t v693 = v693 + v703 - v708 * v237[2];
                      ++v706;
                    }
                    while (v706 < v704);
                    uint64_t v712 = v704;
                    int v690 = *v150;
                    int v705 = v704;
                  }
                  else
                  {
                    uint64_t v712 = 0;
                  }
                  uint64_t v694 = v694 + v699 - v712 * v700;
                  uint64_t v693 = v693 + v702 - v703 * v237[1];
                  ++v691;
                }
                while (v691 < v690);
              }
              break;
            case 4uLL:
              int v713 = *v150;
              if (*v150)
              {
                unint64_t v714 = 0;
                uint64_t v715 = 0;
                uint64_t v716 = 0;
                uint64_t v717 = 0;
                uint64_t v718 = v149[19];
                uint64_t v719 = v236[19];
                uint64_t v720 = v148[19];
                uint64_t v721 = (uint64_t *)v149[3];
                uint64_t v722 = *v721;
                uint64_t v723 = v721[1];
                int v724 = (uint64_t *)v236[3];
                uint64_t v725 = *v724;
                uint64_t v726 = v724[1];
                int v727 = v150[1];
                int v728 = v727;
                do
                {
                  if (v728)
                  {
                    unint64_t v729 = 0;
                    uint64_t v730 = v721[2];
                    uint64_t v731 = v724[2];
                    int v732 = v150[2];
                    int v733 = v732;
                    do
                    {
                      if (v733)
                      {
                        unint64_t v734 = 0;
                        uint64_t v735 = v721[3];
                        uint64_t v736 = v724[3];
                        int v737 = v150[3];
                        do
                        {
                          if (v737)
                          {
                            for (unint64_t ii = 0; ii < v737; ++ii)
                            {
                              *(_DWORD *)(v720 + 4 * v715 + 4 * ii) = *(_DWORD *)(v718 + 4 * v717) << *(_DWORD *)(v719 + 4 * v716);
                              v717 += v735;
                              v716 += v736;
                              int v737 = v150[3];
                            }
                            uint64_t v739 = v737;
                            int v732 = v150[2];
                            v715 += ii;
                          }
                          else
                          {
                            uint64_t v739 = 0;
                          }
                          uint64_t v717 = v717 + v730 - v739 * v735;
                          uint64_t v716 = v716 + v731 - v736 * v237[3];
                          ++v734;
                        }
                        while (v734 < v732);
                        uint64_t v740 = v732;
                        int v727 = v150[1];
                        int v733 = v732;
                      }
                      else
                      {
                        uint64_t v740 = 0;
                      }
                      uint64_t v717 = v717 + v723 - v740 * v730;
                      uint64_t v716 = v716 + v726 - v731 * v237[2];
                      ++v729;
                    }
                    while (v729 < v727);
                    uint64_t v741 = v727;
                    int v713 = *v150;
                    int v728 = v727;
                  }
                  else
                  {
                    uint64_t v741 = 0;
                  }
                  uint64_t v717 = v717 + v722 - v741 * v723;
                  uint64_t v716 = v716 + v725 - v726 * v237[1];
                  ++v714;
                }
                while (v714 < v713);
              }
              break;
            default:
              uint64_t v661 = v148[6];
              if (v661)
              {
                uint64_t v662 = 0;
                uint64_t v1518 = v236[19];
                uint64_t v1538 = v149[19];
                uint64_t v1508 = v148[19];
                do
                {
                  uint64_t v663 = 0;
                  if ((v152 & 0x80000000) == 0)
                  {
                    uint64_t v664 = v149[3];
                    uint64_t v665 = v152;
                    int v666 = v662;
                    do
                    {
                      ldiv_t v667 = ldiv(v666, v150[v665]);
                      int v666 = v667.quot;
                      v663 += *(void *)(v664 + 8 * v665--) * v667.rem;
                    }
                    while (v665 != -1);
                  }
                  uint64_t v668 = v1558;
                  if ((v1558 & 0x80000000) != 0)
                  {
                    LODWORD(v669) = 0;
                  }
                  else
                  {
                    uint64_t v669 = 0;
                    uint64_t v670 = v236[3];
                    int v671 = v662;
                    do
                    {
                      ldiv_t v672 = ldiv(v671, v237[v668]);
                      int v671 = v672.quot;
                      v669 += *(void *)(v670 + 8 * v668--) * v672.rem;
                    }
                    while (v668 != -1);
                  }
                  *(_DWORD *)(v1508 + 4 * v662++) = *(_DWORD *)(v1538 + 4 * (int)v663) << *(_DWORD *)(v1518 + 4 * (int)v669);
                  uint64_t v152 = v1576;
                }
                while (v662 != v661);
              }
              break;
          }
          break;
      }
      return;
    case 5:
      int v22 = *(uint64_t **)a1;
      uint64_t v21 = *(uint64_t **)(a1 + 8);
      switch(v23)
      {
        case 0:
          **(void **)(*(void *)v1 + 152) = **(void **)(*v22 + 152) << **(void **)(*v21 + 152);
          return;
        case 1:
          int v186 = *(_DWORD *)(*v21 + 160);
          if (v186 >= 1)
          {
            uint64_t v187 = **(void **)(*v22 + 152);
            int v188 = *(void **)(*(void *)v1 + 152);
            int v189 = *(uint64_t **)(*v21 + 152);
            unsigned int v190 = v186 + 1;
            do
            {
              uint64_t v191 = *v189++;
              *v188++ = v187 << v191;
              --v190;
            }
            while (v190 > 1);
          }
          return;
        case 2:
          int v192 = *(_DWORD *)(*v22 + 160);
          if (v192 >= 1)
          {
            uint64_t v193 = **(void **)(*v21 + 152);
            int v194 = *(void **)(*(void *)v1 + 152);
            unsigned int v195 = *(uint64_t **)(*v22 + 152);
            unsigned int v196 = v192 + 1;
            do
            {
              uint64_t v197 = *v195++;
              *v194++ = v197 << v193;
              --v196;
            }
            while (v196 > 1);
          }
          return;
        case 3:
          int v198 = *(_DWORD *)(*(void *)v1 + 48);
          if (v198 >= 1)
          {
            v199 = *(void **)(*(void *)v1 + 152);
            unsigned int v200 = *(uint64_t **)(*v21 + 152);
            uint64_t v201 = *(uint64_t **)(*v22 + 152);
            unsigned int v202 = v198 + 1;
            do
            {
              uint64_t v204 = *v201++;
              uint64_t v203 = v204;
              uint64_t v205 = *v200++;
              *v199++ = v203 << v205;
              --v202;
            }
            while (v202 > 1);
          }
          return;
        default:
          unsigned int v177 = *(void **)v1;
          int v178 = (void *)*v22;
          int v179 = *(int **)*v22;
          uint64_t v180 = (v178[1] - (void)v179) >> 2;
          uint64_t v181 = (v180 - 1);
          if ((int)v181 >= -1) {
            int v182 = -1;
          }
          else {
            int v182 = v180 - 1;
          }
          int v183 = v182 + 1;
          int v184 = v180 + 1;
          break;
      }
      break;
    default:
      exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x25A2B1470](exception, "[BitwiseBinary::eval_cpu] Type not supported");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  while (1)
  {
    unsigned int v185 = v184 - 2;
    if (v184 - 2 < 0) {
      break;
    }
    --v184;
    if (*(void *)(v178[3] + 8 * v185) != *(void *)(v177[3] + 8 * v185)) {
      goto LABEL_207;
    }
  }
  int v184 = v183;
LABEL_207:
  int v244 = (void *)*v21;
  int v245 = *(int **)*v21;
  uint64_t v246 = (v244[1] - (void)v245) >> 2;
  uint64_t v247 = (v246 - 1);
  if ((int)v247 >= -1) {
    int v248 = -1;
  }
  else {
    int v248 = v246 - 1;
  }
  int v249 = v248 + 1;
  int v250 = v246 + 1;
  while (1)
  {
    unsigned int v251 = v250 - 2;
    if (v250 - 2 < 0) {
      break;
    }
    --v250;
    if (*(void *)(v244[3] + 8 * v251) != *(void *)(v177[3] + 8 * v251)) {
      goto LABEL_235;
    }
  }
  int v250 = v249;
LABEL_235:
  int v260 = v180 + 1;
  while (1)
  {
    unsigned int v261 = v260 - 2;
    if (v260 - 2 < 0) {
      break;
    }
    --v260;
    if (*(void *)(v178[3] + 8 * v261)) {
      goto LABEL_260;
    }
  }
  int v260 = v183;
LABEL_260:
  int v270 = v246 + 1;
  while (1)
  {
    unsigned int v271 = v270 - 2;
    if (v270 - 2 < 0) {
      break;
    }
    --v270;
    if (*(void *)(v244[3] + 8 * v271)) {
      goto LABEL_357;
    }
  }
  int v270 = v249;
LABEL_357:
  unint64_t v314 = (uint64_t)(v177[1] - *v177) >> 2;
  if (v184 <= v250) {
    int v315 = v250;
  }
  else {
    int v315 = v184;
  }
  if (v184 <= v270) {
    int v184 = v270;
  }
  if (v260 > v250) {
    int v250 = v260;
  }
  if (v314 > v250)
  {
    int v316 = 1;
  }
  else
  {
    int v250 = (uint64_t)(v177[1] - *v177) >> 2;
    int v316 = 4;
  }
  if (v314 > v184)
  {
    int v317 = 2;
  }
  else
  {
    int v184 = v250;
    int v317 = v316;
  }
  if (v314 > v315)
  {
    int v184 = v315;
    int v317 = 3;
  }
  uint64_t v1559 = v247;
  uint64_t v1577 = v181;
  if (!v184) {
    goto LABEL_374;
  }
  unint64_t v318 = *(void *)(v177[3] + 8 * (v184 - 1));
  if (v318 < 0x10) {
    goto LABEL_374;
  }
  switch(v317)
  {
    case 1:
      if (v184 == 2)
      {
        uint64_t v1412 = *v179;
        if (v1412)
        {
          uint64_t v1413 = 0;
          uint64_t v1414 = 0;
          uint64_t v1415 = 0;
          uint64_t v1416 = v178[19];
          uint64_t v1417 = v244[19];
          uint64_t v1418 = v177[19];
          unint64_t v1419 = v179[1];
          int v1420 = (uint64_t *)v178[3];
          uint64_t v1421 = *v1420;
          uint64_t v1422 = v1420[1];
          unint64_t v1423 = (uint64_t *)v244[3];
          uint64_t v1424 = *v1423;
          uint64_t v1425 = v1423[1];
          if (v1419 <= 1) {
            uint64_t v1426 = 1;
          }
          else {
            uint64_t v1426 = v179[1];
          }
          uint64_t v1427 = v1421 - v1422 * v1419;
          uint64_t v1428 = v1424 - v1425 * v245[1];
          do
          {
            if (v1419)
            {
              uint64_t v1429 = 0;
              uint64_t v1430 = v1417 + 8 * v1414;
              do
              {
                if ((int)v318 >= 1)
                {
                  uint64_t v1431 = 0;
                  uint64_t v1432 = *(void *)(v1416 + 8 * v1415);
                  unsigned int v1433 = v318 + 1;
                  do
                  {
                    *(void *)(v1418 + v1431) = v1432 << *(void *)(v1430 + v1431);
                    --v1433;
                    v1431 += 8;
                  }
                  while (v1433 > 1);
                }
                v1415 += v1422;
                v1414 += v1425;
                v1418 += 8 * (int)v318;
                ++v1429;
                v1430 += 8 * v1425;
              }
              while (v1429 != v1426);
            }
            v1415 += v1427;
            v1414 += v1428;
            ++v1413;
          }
          while (v1413 != v1412);
        }
      }
      else if (v184 == 1)
      {
        uint64_t v897 = *v179;
        if (v897)
        {
          uint64_t v898 = 0;
          uint64_t v899 = 0;
          uint64_t v900 = v178[19];
          uint64_t v901 = v244[19];
          uint64_t v902 = v177[19];
          uint64_t v903 = *(void *)v178[3];
          uint64_t v904 = 8 * *(void *)v244[3];
          do
          {
            if ((int)v318 >= 1)
            {
              uint64_t v905 = 0;
              uint64_t v906 = *(void *)(v900 + 8 * v899);
              unsigned int v907 = v318 + 1;
              do
              {
                *(void *)(v902 + v905) = v906 << *(void *)(v901 + v905);
                --v907;
                v905 += 8;
              }
              while (v907 > 1);
            }
            v899 += v903;
            ++v898;
            v902 += 8 * (int)v318;
            v901 += v904;
          }
          while (v898 != v897);
        }
      }
      else
      {
        unint64_t v1535 = v177[6];
        if (v1535)
        {
          unint64_t v1555 = 0;
          uint64_t v1492 = v244[19];
          uint64_t v1501 = v178[19];
          uint64_t v1434 = v177[19];
          do
          {
            uint64_t v1435 = 0;
            if ((v181 & 0x80000000) == 0)
            {
              uint64_t v1436 = v178[3];
              uint64_t v1437 = v181;
              int v1438 = v1555;
              do
              {
                ldiv_t v1439 = ldiv(v1438, v179[v1437]);
                int v1438 = v1439.quot;
                v1435 += *(void *)(v1436 + 8 * v1437--) * v1439.rem;
              }
              while (v1437 != -1);
            }
            uint64_t v1440 = v1559;
            if ((v1559 & 0x80000000) != 0)
            {
              LODWORD(v1441) = 0;
            }
            else
            {
              uint64_t v1441 = 0;
              uint64_t v1442 = v244[3];
              int v1443 = v1555;
              do
              {
                ldiv_t v1444 = ldiv(v1443, v245[v1440]);
                int v1443 = v1444.quot;
                v1441 += *(void *)(v1442 + 8 * v1440--) * v1444.rem;
              }
              while (v1440 != -1);
            }
            uint64_t v181 = v1577;
            if ((int)v318 >= 1)
            {
              uint64_t v1445 = 0;
              uint64_t v1446 = *(void *)(v1501 + 8 * (int)v1435);
              unsigned int v1447 = v318 + 1;
              do
              {
                *(void *)(v1434 + v1445) = v1446 << *(void *)(v1492 + 8 * (int)v1441 + v1445);
                --v1447;
                v1445 += 8;
              }
              while (v1447 > 1);
            }
            v1434 += 8 * (int)v318;
            v1555 += (int)v318;
          }
          while (v1555 < v1535);
        }
      }
      break;
    case 2:
      if (v184 == 2)
      {
        uint64_t v1448 = *v179;
        if (v1448)
        {
          uint64_t v1449 = 0;
          uint64_t v1450 = 0;
          uint64_t v1451 = 0;
          uint64_t v1452 = v178[19];
          uint64_t v1453 = v244[19];
          uint64_t v1454 = v177[19];
          unint64_t v1455 = v179[1];
          uint64_t v1456 = (uint64_t *)v178[3];
          uint64_t v1457 = *v1456;
          uint64_t v1458 = v1456[1];
          uint64_t v1459 = (uint64_t *)v244[3];
          uint64_t v1460 = *v1459;
          uint64_t v1461 = v1459[1];
          if (v1455 <= 1) {
            uint64_t v1462 = 1;
          }
          else {
            uint64_t v1462 = v179[1];
          }
          uint64_t v1463 = v1457 - v1458 * v1455;
          uint64_t v1464 = v1460 - v1461 * v245[1];
          do
          {
            if (v1455)
            {
              uint64_t v1465 = 0;
              uint64_t v1466 = v1452 + 8 * v1451;
              do
              {
                if ((int)v318 >= 1)
                {
                  uint64_t v1467 = 0;
                  uint64_t v1468 = *(void *)(v1453 + 8 * v1450);
                  unsigned int v1469 = v318 + 1;
                  do
                  {
                    *(void *)(v1454 + v1467) = *(void *)(v1466 + v1467) << v1468;
                    --v1469;
                    v1467 += 8;
                  }
                  while (v1469 > 1);
                }
                v1451 += v1458;
                v1450 += v1461;
                v1454 += 8 * (int)v318;
                ++v1465;
                v1466 += 8 * v1458;
              }
              while (v1465 != v1462);
            }
            v1451 += v1463;
            v1450 += v1464;
            ++v1449;
          }
          while (v1449 != v1448);
        }
      }
      else if (v184 == 1)
      {
        uint64_t v908 = *v179;
        if (v908)
        {
          uint64_t v909 = 0;
          uint64_t v910 = 0;
          uint64_t v911 = v178[19];
          uint64_t v912 = v244[19];
          uint64_t v913 = v177[19];
          uint64_t v914 = *(void *)v244[3];
          uint64_t v915 = 8 * *(void *)v178[3];
          do
          {
            if ((int)v318 >= 1)
            {
              uint64_t v916 = 0;
              uint64_t v917 = *(void *)(v912 + 8 * v910);
              unsigned int v918 = v318 + 1;
              do
              {
                *(void *)(v913 + v916) = *(void *)(v911 + v916) << v917;
                --v918;
                v916 += 8;
              }
              while (v918 > 1);
            }
            v910 += v914;
            ++v909;
            v913 += 8 * (int)v318;
            v911 += v915;
          }
          while (v909 != v908);
        }
      }
      else
      {
        unint64_t v1536 = v177[6];
        if (v1536)
        {
          unint64_t v1556 = 0;
          uint64_t v1493 = v244[19];
          uint64_t v1502 = v178[19];
          uint64_t v1470 = v177[19];
          do
          {
            uint64_t v1471 = 0;
            if ((v181 & 0x80000000) == 0)
            {
              uint64_t v1472 = v178[3];
              uint64_t v1473 = v181;
              int v1474 = v1556;
              do
              {
                ldiv_t v1475 = ldiv(v1474, v179[v1473]);
                int v1474 = v1475.quot;
                v1471 += *(void *)(v1472 + 8 * v1473--) * v1475.rem;
              }
              while (v1473 != -1);
            }
            uint64_t v1476 = v1559;
            if ((v1559 & 0x80000000) != 0)
            {
              LODWORD(v1477) = 0;
            }
            else
            {
              uint64_t v1477 = 0;
              uint64_t v1478 = v244[3];
              int v1479 = v1556;
              do
              {
                ldiv_t v1480 = ldiv(v1479, v245[v1476]);
                int v1479 = v1480.quot;
                v1477 += *(void *)(v1478 + 8 * v1476--) * v1480.rem;
              }
              while (v1476 != -1);
            }
            uint64_t v181 = v1577;
            if ((int)v318 >= 1)
            {
              uint64_t v1481 = 0;
              uint64_t v1482 = *(void *)(v1493 + 8 * (int)v1477);
              unsigned int v1483 = v318 + 1;
              do
              {
                *(void *)(v1470 + v1481) = *(void *)(v1502 + 8 * (int)v1471 + v1481) << v1482;
                --v1483;
                v1481 += 8;
              }
              while (v1483 > 1);
            }
            v1470 += 8 * (int)v318;
            v1556 += (int)v318;
          }
          while (v1556 < v1536);
        }
      }
      break;
    case 3:
      if (v184 == 2)
      {
        uint64_t v1134 = *v179;
        if (v1134)
        {
          uint64_t v1135 = 0;
          uint64_t v1136 = 0;
          uint64_t v1137 = 0;
          uint64_t v1138 = v178[19];
          uint64_t v1139 = v244[19];
          uint64_t v1140 = v177[19];
          unint64_t v1141 = v179[1];
          uint64_t v1142 = (uint64_t *)v178[3];
          uint64_t v1143 = *v1142;
          uint64_t v1144 = v1142[1];
          uint64_t v1145 = (uint64_t *)v244[3];
          uint64_t v1146 = *v1145;
          uint64_t v1147 = v1145[1];
          if (v1141 <= 1) {
            uint64_t v1148 = 1;
          }
          else {
            uint64_t v1148 = v179[1];
          }
          uint64_t v1149 = v1143 - v1144 * v1141;
          uint64_t v1150 = v1146 - v1147 * v245[1];
          do
          {
            if (v1141)
            {
              uint64_t v1151 = 0;
              uint64_t v1152 = v1139 + 8 * v1136;
              uint64_t v1153 = v1138 + 8 * v1137;
              do
              {
                if ((int)v318 >= 1)
                {
                  uint64_t v1154 = 0;
                  unsigned int v1155 = v318 + 1;
                  do
                  {
                    *(void *)(v1140 + v1154) = *(void *)(v1153 + v1154) << *(void *)(v1152 + v1154);
                    --v1155;
                    v1154 += 8;
                  }
                  while (v1155 > 1);
                }
                v1137 += v1144;
                v1136 += v1147;
                v1140 += 8 * (int)v318;
                ++v1151;
                v1152 += 8 * v1147;
                v1153 += 8 * v1144;
              }
              while (v1151 != v1148);
            }
            v1137 += v1149;
            v1136 += v1150;
            ++v1135;
          }
          while (v1135 != v1134);
        }
      }
      else if (v184 == 1)
      {
        uint64_t v359 = *v179;
        if (v359)
        {
          uint64_t v360 = 0;
          uint64_t v361 = v178[19];
          uint64_t v362 = v244[19];
          uint64_t v363 = v177[19];
          uint64_t v364 = 8 * *(void *)v244[3];
          uint64_t v365 = 8 * *(void *)v178[3];
          do
          {
            if ((int)v318 >= 1)
            {
              uint64_t v366 = 0;
              unsigned int v367 = v318 + 1;
              do
              {
                *(void *)(v363 + v366) = *(void *)(v361 + v366) << *(void *)(v362 + v366);
                --v367;
                v366 += 8;
              }
              while (v367 > 1);
            }
            ++v360;
            v363 += 8 * (int)v318;
            v362 += v364;
            v361 += v365;
          }
          while (v360 != v359);
        }
      }
      else
      {
        unint64_t v1527 = v177[6];
        if (v1527)
        {
          unint64_t v1545 = 0;
          uint64_t v1487 = v244[19];
          uint64_t v1496 = v178[19];
          uint64_t v1156 = v177[19];
          do
          {
            uint64_t v1157 = 0;
            if ((v181 & 0x80000000) == 0)
            {
              uint64_t v1158 = v178[3];
              uint64_t v1159 = v181;
              int v1160 = v1545;
              do
              {
                ldiv_t v1161 = ldiv(v1160, v179[v1159]);
                int v1160 = v1161.quot;
                v1157 += *(void *)(v1158 + 8 * v1159--) * v1161.rem;
              }
              while (v1159 != -1);
            }
            uint64_t v1162 = v1559;
            if ((v1559 & 0x80000000) != 0)
            {
              LODWORD(v1163) = 0;
            }
            else
            {
              uint64_t v1163 = 0;
              uint64_t v1164 = v244[3];
              int v1165 = v1545;
              do
              {
                ldiv_t v1166 = ldiv(v1165, v245[v1162]);
                int v1165 = v1166.quot;
                v1163 += *(void *)(v1164 + 8 * v1162--) * v1166.rem;
              }
              while (v1162 != -1);
            }
            uint64_t v181 = v1577;
            if ((int)v318 >= 1)
            {
              uint64_t v1167 = 0;
              unsigned int v1168 = v318 + 1;
              do
              {
                *(void *)(v1156 + v1167) = *(void *)(v1496 + 8 * (int)v1157 + v1167) << *(void *)(v1487 + 8 * (int)v1163 + v1167);
                --v1168;
                v1167 += 8;
              }
              while (v1168 > 1);
            }
            v1156 += 8 * (int)v318;
            v1545 += (int)v318;
          }
          while (v1545 < v1527);
        }
      }
      break;
    default:
LABEL_374:
      switch(v314)
      {
        case 1uLL:
          uint64_t v319 = v177[6];
          if (v319)
          {
            int v320 = (void *)v178[19];
            unint64_t v321 = (void *)v244[19];
            uint64_t v322 = (void *)v177[19];
            uint64_t v323 = 8 * *(void *)v244[3];
            uint64_t v324 = 8 * *(void *)v178[3];
            do
            {
              *v322++ = *v320 << *v321;
              unint64_t v321 = (void *)((char *)v321 + v323);
              int v320 = (void *)((char *)v320 + v324);
              --v319;
            }
            while (v319);
          }
          break;
        case 2uLL:
          uint64_t v754 = *v179;
          if (v754)
          {
            uint64_t v755 = 0;
            uint64_t v756 = 0;
            uint64_t v757 = 0;
            uint64_t v758 = 0;
            uint64_t v759 = v178[19];
            uint64_t v760 = v244[19];
            uint64_t v761 = v177[19];
            unint64_t v762 = v179[1];
            int v763 = (uint64_t *)v178[3];
            uint64_t v764 = *v763;
            uint64_t v765 = v763[1];
            uint64_t v766 = (uint64_t *)v244[3];
            uint64_t v767 = *v766;
            uint64_t v768 = v766[1];
            uint64_t v769 = v767 - v768 * v245[1];
            if (v762 <= 1) {
              uint64_t v770 = 1;
            }
            else {
              uint64_t v770 = v179[1];
            }
            uint64_t v771 = v764 - v765 * v762;
            do
            {
              if (v762)
              {
                uint64_t v772 = v756 + v770;
                int v773 = (void *)(v761 + 8 * v756);
                uint64_t v774 = v770;
                do
                {
                  *v773++ = *(void *)(v759 + 8 * v758) << *(void *)(v760 + 8 * v757);
                  v758 += v765;
                  v757 += v768;
                  --v774;
                }
                while (v774);
                uint64_t v756 = v772;
              }
              v758 += v771;
              v757 += v769;
              ++v755;
            }
            while (v755 != v754);
          }
          break;
        case 3uLL:
          uint64_t v775 = *v179;
          if (v775)
          {
            uint64_t v776 = 0;
            uint64_t v777 = 0;
            uint64_t v778 = 0;
            uint64_t v779 = 0;
            uint64_t v780 = v178[19];
            uint64_t v781 = v244[19];
            uint64_t v782 = v177[19];
            unint64_t v783 = v179[1];
            ldiv_t v784 = (void *)v178[3];
            uint64_t v785 = v784[1];
            uint64_t v786 = (void *)v244[3];
            uint64_t v787 = v786[1];
            uint64_t v788 = *v786 - v787 * v245[1];
            if (v783 <= 1) {
              uint64_t v789 = 1;
            }
            else {
              uint64_t v789 = v179[1];
            }
            unint64_t v790 = *v784 - v785 * v783;
            do
            {
              if (v783)
              {
                uint64_t v791 = 0;
                unint64_t v792 = v179[2];
                uint64_t v793 = v784[2];
                uint64_t v794 = v786[2];
                if (v792 <= 1) {
                  uint64_t v795 = 1;
                }
                else {
                  uint64_t v795 = v179[2];
                }
                uint64_t v796 = v787 - v794 * v245[2];
                do
                {
                  uint64_t v797 = v795;
                  if (v792)
                  {
                    do
                    {
                      *(void *)(v782 + 8 * v777++) = *(void *)(v780 + 8 * v779) << *(void *)(v781 + 8 * v778);
                      v779 += v793;
                      v778 += v794;
                      --v797;
                    }
                    while (v797);
                  }
                  v779 += v785 - v793 * v792;
                  v778 += v796;
                  ++v791;
                }
                while (v791 != v789);
              }
              v779 += v790;
              v778 += v788;
              ++v776;
            }
            while (v776 != v775);
          }
          break;
        case 4uLL:
          uint64_t v1580 = *v179;
          if (v1580)
          {
            uint64_t v798 = 0;
            uint64_t v799 = 0;
            uint64_t v800 = 0;
            uint64_t v801 = 0;
            uint64_t v802 = v178[19];
            uint64_t v803 = v244[19];
            uint64_t v804 = v177[19];
            unint64_t v805 = v179[1];
            uint64_t v806 = (void *)v178[3];
            uint64_t v807 = (void *)v244[3];
            uint64_t v1503 = v807[1];
            uint64_t v1510 = v806[1];
            uint64_t v1540 = *v807 - v1503 * v245[1];
            int v1562 = v179[1];
            if (v805 <= 1) {
              uint64_t v808 = 1;
            }
            else {
              uint64_t v808 = v179[1];
            }
            unint64_t v1520 = *v806 - v806[1] * v805;
            do
            {
              if (v1562)
              {
                uint64_t v809 = 0;
                unint64_t v810 = v179[2];
                uint64_t v811 = v806[2];
                uint64_t v812 = v807[2];
                if (v810 <= 1) {
                  uint64_t v813 = 1;
                }
                else {
                  uint64_t v813 = v179[2];
                }
                uint64_t v814 = v1503 - v812 * v245[2];
                do
                {
                  if (v810)
                  {
                    uint64_t v815 = 0;
                    unint64_t v816 = v179[3];
                    uint64_t v817 = v806[3];
                    uint64_t v818 = v807[3];
                    if (v816 <= 1) {
                      uint64_t v819 = 1;
                    }
                    else {
                      uint64_t v819 = v179[3];
                    }
                    uint64_t v820 = v812 - v818 * v245[3];
                    do
                    {
                      uint64_t v821 = v819;
                      if (v816)
                      {
                        do
                        {
                          *(void *)(v804 + 8 * v799++) = *(void *)(v802 + 8 * v801) << *(void *)(v803 + 8 * v800);
                          v801 += v817;
                          v800 += v818;
                          --v821;
                        }
                        while (v821);
                      }
                      v801 += v811 - v817 * v816;
                      v800 += v820;
                      ++v815;
                    }
                    while (v815 != v813);
                  }
                  v801 += v1510 - v811 * v810;
                  v800 += v814;
                  ++v809;
                }
                while (v809 != v808);
              }
              v801 += v1520;
              v800 += v1540;
              ++v798;
            }
            while (v798 != v1580);
          }
          break;
        default:
          uint64_t v742 = v177[6];
          if (v742)
          {
            uint64_t v743 = 0;
            uint64_t v1519 = v244[19];
            uint64_t v1539 = v178[19];
            uint64_t v1509 = v177[19];
            do
            {
              uint64_t v744 = 0;
              if ((v181 & 0x80000000) == 0)
              {
                uint64_t v745 = v178[3];
                uint64_t v746 = v181;
                int v747 = v743;
                do
                {
                  ldiv_t v748 = ldiv(v747, v179[v746]);
                  int v747 = v748.quot;
                  v744 += *(void *)(v745 + 8 * v746--) * v748.rem;
                }
                while (v746 != -1);
              }
              uint64_t v749 = v1559;
              if ((v1559 & 0x80000000) != 0)
              {
                LODWORD(v750) = 0;
              }
              else
              {
                uint64_t v750 = 0;
                uint64_t v751 = v244[3];
                int v752 = v743;
                do
                {
                  ldiv_t v753 = ldiv(v752, v245[v749]);
                  int v752 = v753.quot;
                  v750 += *(void *)(v751 + 8 * v749--) * v753.rem;
                }
                while (v749 != -1);
              }
              *(void *)(v1509 + 8 * v743++) = *(void *)(v1539 + 8 * (int)v744) << *(void *)(v1519
                                                                                                  + 8 * (int)v750);
              uint64_t v181 = v1577;
            }
            while (v743 != v742);
          }
          break;
      }
      return;
  }
}

void sub_256E655FC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::BitwiseBinary::eval_cpu(std::vector<mlx::core::array> const&,mlx::core::array&)::$_0::operator()<mlx::core::detail::RightShift>(uint64_t a1)
{
  v1 = *(mlx::core::array **)(a1 + 16);
  uint64_t v2 = a1;
  switch(*(_DWORD *)(*(void *)v1 + 56))
  {
    case 0:
      v4 = *(uint64_t **)a1;
      v3 = *(uint64_t **)(a1 + 8);
      switch(binary_op_type)
      {
        case 0:
          **(unsigned char **)(*(void *)v1 + 152) = **(unsigned __int8 **)(*v4 + 152) >> **(unsigned char **)(*v3 + 152);
          goto LABEL_31;
        case 1:
          int v30 = *(_DWORD *)(*v3 + 160);
          if (v30 >= 1)
          {
            unsigned int v31 = **(unsigned __int8 **)(*v4 + 152);
            unsigned int v32 = *(unsigned char **)(*(void *)v1 + 152);
            int v33 = *(char **)(*v3 + 152);
            unsigned int v34 = v30 + 1;
            do
            {
              char v35 = *v33++;
              *v32++ = v31 >> v35;
              --v34;
            }
            while (v34 > 1);
          }
          goto LABEL_31;
        case 2:
          int v36 = *(_DWORD *)(*v4 + 160);
          if (v36 >= 1)
          {
            char v37 = **(unsigned char **)(*v3 + 152);
            int v38 = *(unsigned char **)(*(void *)v1 + 152);
            int v39 = *(unsigned __int8 **)(*v4 + 152);
            unsigned int v40 = v36 + 1;
            do
            {
              unsigned int v41 = *v39++;
              *v38++ = v41 >> v37;
              --v40;
            }
            while (v40 > 1);
          }
          goto LABEL_31;
        case 3:
          int v42 = *(_DWORD *)(*(void *)v1 + 48);
          if (v42 >= 1)
          {
            unsigned int v43 = *(unsigned char **)(*(void *)v1 + 152);
            int v44 = *(unsigned char **)(*v3 + 152);
            int v45 = *(unsigned __int8 **)(*v4 + 152);
            unsigned int v46 = v42 + 1;
            do
            {
              unsigned int v48 = *v45++;
              unsigned int v47 = v48;
              LOBYTE(v48) = *v44++;
              *v43++ = v47 >> v48;
              --v46;
            }
            while (v46 > 1);
          }
          goto LABEL_31;
        default:
          uint64_t v21 = *(void **)v1;
          int v22 = (void *)*v4;
          int v23 = *(int **)*v4;
          uint64_t v24 = (v22[1] - (void)v23) >> 2;
          uint64_t v25 = (v24 - 1);
          if ((int)v25 >= -1) {
            int v26 = -1;
          }
          else {
            int v26 = v24 - 1;
          }
          int v27 = v26 + 1;
          int v28 = v24 + 1;
          break;
      }
      while (1)
      {
        unsigned int v29 = v28 - 2;
        if (v28 - 2 < 0) {
          break;
        }
        --v28;
        if (*(void *)(v22[3] + 8 * v29) != *(void *)(v21[3] + 8 * v29)) {
          goto LABEL_181;
        }
      }
      int v28 = v27;
LABEL_181:
      int v225 = (void *)*v3;
      int v226 = *(int **)*v3;
      uint64_t v227 = (v225[1] - (void)v226) >> 2;
      uint64_t v228 = (v227 - 1);
      if ((int)v228 >= -1) {
        int v229 = -1;
      }
      else {
        int v229 = v227 - 1;
      }
      int v230 = v229 + 1;
      int v231 = v227 + 1;
      while (1)
      {
        unsigned int v232 = v231 - 2;
        if (v231 - 2 < 0) {
          break;
        }
        --v231;
        if (*(void *)(v225[3] + 8 * v232) != *(void *)(v21[3] + 8 * v232)) {
          goto LABEL_220;
        }
      }
      int v231 = v230;
LABEL_220:
      int v264 = v24 + 1;
      while (1)
      {
        unsigned int v265 = v264 - 2;
        if (v264 - 2 < 0) {
          break;
        }
        --v264;
        if (*(void *)(v22[3] + 8 * v265)) {
          goto LABEL_245;
        }
      }
      int v264 = v27;
LABEL_245:
      int v274 = v227 + 1;
      while (1)
      {
        unsigned int v275 = v274 - 2;
        if (v274 - 2 < 0) {
          break;
        }
        --v274;
        if (*(void *)(v225[3] + 8 * v275)) {
          goto LABEL_270;
        }
      }
      int v274 = v230;
LABEL_270:
      unint64_t v284 = (uint64_t)(v21[1] - *v21) >> 2;
      if (v28 <= v231) {
        int v285 = v231;
      }
      else {
        int v285 = v28;
      }
      if (v28 <= v274) {
        int v28 = v274;
      }
      if (v264 > v231) {
        int v231 = v264;
      }
      if (v284 > v231)
      {
        int v286 = 1;
      }
      else
      {
        int v231 = (uint64_t)(v21[1] - *v21) >> 2;
        int v286 = 4;
      }
      if (v284 > v28)
      {
        int v287 = 2;
      }
      else
      {
        int v28 = v231;
        int v287 = v286;
      }
      if (v284 > v285)
      {
        int v28 = v285;
        int v287 = 3;
      }
      uint64_t v1670 = v228;
      uint64_t v1685 = v25;
      if (!v28) {
        goto LABEL_287;
      }
      unint64_t v288 = *(void *)(v21[3] + 8 * (v28 - 1));
      if (v288 < 0x10) {
        goto LABEL_287;
      }
      uint64_t v1651 = *(void *)(v21[3] + 8 * (v28 - 1));
      switch(v287)
      {
        case 1:
          if (v28 == 2)
          {
            uint64_t v1228 = *v23;
            if (v1228)
            {
              uint64_t v1229 = 0;
              uint64_t v1230 = 0;
              uint64_t v1231 = 0;
              uint64_t v1232 = v22[19];
              uint64_t v1233 = v225[19];
              uint64_t v1234 = v21[19];
              unint64_t v1235 = v23[1];
              uint64_t v1236 = (uint64_t *)v22[3];
              uint64_t v1237 = *v1236;
              uint64_t v1238 = v1236[1];
              ldiv_t v1239 = (uint64_t *)v225[3];
              uint64_t v1241 = *v1239;
              uint64_t v1240 = v1239[1];
              if (v1235 <= 1) {
                uint64_t v1242 = 1;
              }
              else {
                uint64_t v1242 = v23[1];
              }
              uint64_t v1243 = v1237 - v1238 * v1235;
              uint64_t v1244 = v1241 - v1240 * v226[1];
              do
              {
                if (v1235)
                {
                  uint64_t v1245 = 0;
                  uint64_t v1246 = v1233 + v1230;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1247 = 0;
                      unsigned int v1248 = *(unsigned __int8 *)(v1232 + v1231);
                      unsigned int v1249 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1234 + v1247) = v1248 >> *(unsigned char *)(v1246 + v1247);
                        --v1249;
                        ++v1247;
                      }
                      while (v1249 > 1);
                    }
                    v1231 += v1238;
                    v1230 += v1240;
                    v1234 += (int)v288;
                    ++v1245;
                    v1246 += v1240;
                  }
                  while (v1245 != v1242);
                }
                v1231 += v1243;
                v1230 += v1244;
                ++v1229;
              }
              while (v1229 != v1228);
            }
          }
          else if (v28 == 1)
          {
            uint64_t v858 = *v23;
            if (v858)
            {
              uint64_t v859 = 0;
              uint64_t v860 = 0;
              uint64_t v861 = v22[19];
              uint64_t v862 = v225[19];
              uint64_t v863 = v21[19];
              uint64_t v864 = *(void *)v22[3];
              uint64_t v865 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v866 = 0;
                  unsigned int v867 = *(unsigned __int8 *)(v861 + v860);
                  unsigned int v868 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v863 + v866) = v867 >> *(unsigned char *)(v862 + v866);
                    --v868;
                    ++v866;
                  }
                  while (v868 > 1);
                }
                v860 += v864;
                v863 += (int)v288;
                ++v859;
                v862 += v865;
              }
              while (v859 != v858);
            }
          }
          else
          {
            unint64_t v1612 = v21[6];
            if (v1612)
            {
              uint64_t v1250 = 0;
              uint64_t v1579 = v225[19];
              uint64_t v1585 = v22[19];
              uint64_t v1599 = (int)v288;
              unsigned int v1576 = v288 + 1;
              uint64_t v1251 = v21[19];
              do
              {
                uint64_t v1627 = v1250;
                uint64_t v1252 = 0;
                if ((v25 & 0x80000000) == 0)
                {
                  uint64_t v1253 = v22[3];
                  do
                  {
                    ldiv_t v1254 = ldiv((int)v1250, v23[v25]);
                    LODWORD(v1250) = v1254.quot;
                    v1252 += *(void *)(v1253 + 8 * v25--) * v1254.rem;
                  }
                  while (v25 != -1);
                }
                uint64_t v1255 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1256) = 0;
                }
                else
                {
                  uint64_t v1256 = 0;
                  uint64_t v1257 = v225[3];
                  int quot = v1627;
                  do
                  {
                    ldiv_t v1259 = ldiv(quot, v226[v1255]);
                    int quot = v1259.quot;
                    v1256 += *(void *)(v1257 + 8 * v1255--) * v1259.rem;
                  }
                  while (v1255 != -1);
                }
                if ((int)v1651 >= 1)
                {
                  uint64_t v1260 = 0;
                  unsigned int v1261 = *(unsigned __int8 *)(v1585 + (int)v1252);
                  unsigned int v1262 = v1576;
                  do
                  {
                    *(unsigned char *)(v1251 + v1260) = v1261 >> *(unsigned char *)(v1579 + (int)v1256 + v1260);
                    --v1262;
                    ++v1260;
                  }
                  while (v1262 > 1);
                }
                v1251 += v1599;
                uint64_t v1250 = v1627 + v1599;
                uint64_t v25 = v1685;
              }
              while (v1627 + v1599 < v1612);
            }
          }
          break;
        case 2:
          if (v28 == 2)
          {
            uint64_t v1263 = *v23;
            if (v1263)
            {
              uint64_t v1264 = 0;
              uint64_t v1265 = 0;
              uint64_t v1266 = 0;
              uint64_t v1267 = v22[19];
              uint64_t v1268 = v225[19];
              uint64_t v1269 = v21[19];
              unint64_t v1270 = v23[1];
              uint64_t v1271 = (uint64_t *)v22[3];
              uint64_t v1272 = *v1271;
              uint64_t v1273 = v1271[1];
              ldiv_t v1274 = (uint64_t *)v225[3];
              uint64_t v1276 = *v1274;
              uint64_t v1275 = v1274[1];
              if (v1270 <= 1) {
                uint64_t v1277 = 1;
              }
              else {
                uint64_t v1277 = v23[1];
              }
              uint64_t v1278 = v1272 - v1273 * v1270;
              uint64_t v1279 = v1276 - v1275 * v226[1];
              do
              {
                if (v1270)
                {
                  uint64_t v1280 = 0;
                  uint64_t v1281 = v1267 + v1266;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1282 = 0;
                      char v1283 = *(unsigned char *)(v1268 + v1265);
                      unsigned int v1284 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1269 + v1282) = *(unsigned __int8 *)(v1281 + v1282) >> v1283;
                        --v1284;
                        ++v1282;
                      }
                      while (v1284 > 1);
                    }
                    v1266 += v1273;
                    v1265 += v1275;
                    v1269 += (int)v288;
                    ++v1280;
                    v1281 += v1273;
                  }
                  while (v1280 != v1277);
                }
                v1266 += v1278;
                v1265 += v1279;
                ++v1264;
              }
              while (v1264 != v1263);
            }
          }
          else if (v28 == 1)
          {
            uint64_t v869 = *v23;
            if (v869)
            {
              uint64_t v870 = 0;
              uint64_t v871 = 0;
              uint64_t v872 = v22[19];
              uint64_t v873 = v225[19];
              uint64_t v874 = v21[19];
              uint64_t v875 = *(void *)v22[3];
              uint64_t v876 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v877 = 0;
                  char v878 = *(unsigned char *)(v873 + v871);
                  unsigned int v879 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v874 + v877) = *(unsigned __int8 *)(v872 + v877) >> v878;
                    --v879;
                    ++v877;
                  }
                  while (v879 > 1);
                }
                v871 += v876;
                v874 += (int)v288;
                ++v870;
                v872 += v875;
              }
              while (v870 != v869);
            }
          }
          else
          {
            unint64_t v1613 = v21[6];
            if (v1613)
            {
              uint64_t v1285 = 0;
              uint64_t v1580 = v225[19];
              uint64_t v1586 = v22[19];
              uint64_t v1600 = (int)v288;
              unsigned int v1577 = v288 + 1;
              uint64_t v1286 = v21[19];
              do
              {
                uint64_t v1628 = v1285;
                uint64_t v1287 = 0;
                if ((v25 & 0x80000000) == 0)
                {
                  uint64_t v1288 = v22[3];
                  do
                  {
                    ldiv_t v1289 = ldiv((int)v1285, v23[v25]);
                    LODWORD(v1285) = v1289.quot;
                    v1287 += *(void *)(v1288 + 8 * v25--) * v1289.rem;
                  }
                  while (v25 != -1);
                }
                uint64_t v1290 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1291) = 0;
                }
                else
                {
                  uint64_t v1291 = 0;
                  uint64_t v1292 = v225[3];
                  int v1293 = v1628;
                  do
                  {
                    ldiv_t v1294 = ldiv(v1293, v226[v1290]);
                    int v1293 = v1294.quot;
                    v1291 += *(void *)(v1292 + 8 * v1290--) * v1294.rem;
                  }
                  while (v1290 != -1);
                }
                if ((int)v1651 >= 1)
                {
                  uint64_t v1295 = 0;
                  char v1296 = *(unsigned char *)(v1580 + (int)v1291);
                  unsigned int v1297 = v1577;
                  do
                  {
                    *(unsigned char *)(v1286 + v1295) = *(unsigned __int8 *)(v1586 + (int)v1287 + v1295) >> v1296;
                    --v1297;
                    ++v1295;
                  }
                  while (v1297 > 1);
                }
                v1286 += v1600;
                uint64_t v1285 = v1628 + v1600;
                uint64_t v25 = v1685;
              }
              while (v1628 + v1600 < v1613);
            }
          }
          break;
        case 3:
          if (v28 == 2)
          {
            uint64_t v1060 = *v23;
            if (v1060)
            {
              uint64_t v1061 = 0;
              uint64_t v1062 = 0;
              uint64_t v1063 = 0;
              uint64_t v1064 = v22[19];
              uint64_t v1065 = v225[19];
              uint64_t v1066 = v21[19];
              unint64_t v1067 = v23[1];
              uint64_t v1068 = (uint64_t *)v22[3];
              uint64_t v1069 = *v1068;
              uint64_t v1070 = v1068[1];
              unint64_t v1071 = (uint64_t *)v225[3];
              uint64_t v1073 = *v1071;
              uint64_t v1072 = v1071[1];
              if (v1067 <= 1) {
                uint64_t v1074 = 1;
              }
              else {
                uint64_t v1074 = v23[1];
              }
              uint64_t v1075 = v1069 - v1070 * v1067;
              uint64_t v1076 = v1073 - v1072 * v226[1];
              do
              {
                if (v1067)
                {
                  uint64_t v1077 = 0;
                  uint64_t v1078 = v1065 + v1062;
                  uint64_t v1079 = v1064 + v1063;
                  do
                  {
                    if ((int)v288 >= 1)
                    {
                      uint64_t v1080 = 0;
                      unsigned int v1081 = v288 + 1;
                      do
                      {
                        *(unsigned char *)(v1066 + v1080) = *(unsigned __int8 *)(v1079 + v1080) >> *(unsigned char *)(v1078 + v1080);
                        --v1081;
                        ++v1080;
                      }
                      while (v1081 > 1);
                    }
                    v1063 += v1070;
                    v1062 += v1072;
                    v1066 += (int)v288;
                    ++v1077;
                    v1078 += v1072;
                    v1079 += v1070;
                  }
                  while (v1077 != v1074);
                }
                v1063 += v1075;
                v1062 += v1076;
                ++v1061;
              }
              while (v1061 != v1060);
            }
          }
          else if (v28 == 1)
          {
            uint64_t v339 = *v23;
            if (v339)
            {
              uint64_t v340 = 0;
              uint64_t v341 = v22[19];
              uint64_t v342 = v225[19];
              uint64_t v343 = v21[19];
              uint64_t v344 = *(void *)v22[3];
              uint64_t v345 = *(void *)v225[3];
              do
              {
                if ((int)v288 >= 1)
                {
                  uint64_t v346 = 0;
                  unsigned int v347 = v288 + 1;
                  do
                  {
                    *(unsigned char *)(v343 + v346) = *(unsigned __int8 *)(v341 + v346) >> *(unsigned char *)(v342 + v346);
                    --v347;
                    ++v346;
                  }
                  while (v347 > 1);
                }
                v343 += (int)v288;
                ++v340;
                v342 += v345;
                v341 += v344;
              }
              while (v340 != v339);
            }
          }
          else
          {
            unint64_t v1610 = v21[6];
            if (v1610)
            {
              uint64_t v1082 = 0;
              uint64_t v1578 = v225[19];
              uint64_t v1581 = v22[19];
              uint64_t v1595 = (int)v288;
              unsigned int v1575 = v288 + 1;
              uint64_t v1083 = v21[19];
              do
              {
                uint64_t v1625 = v1082;
                uint64_t v1084 = 0;
                if ((v25 & 0x80000000) == 0)
                {
                  uint64_t v1085 = v22[3];
                  for (uint64_t i = v25; i != -1; --i)
                  {
                    ldiv_t v1087 = ldiv((int)v1082, v23[i]);
                    LODWORD(v1082) = v1087.quot;
                    v1084 += *(void *)(v1085 + 8 * i) * v1087.rem;
                  }
                }
                uint64_t v1088 = v1670;
                if ((v1670 & 0x80000000) != 0)
                {
                  LODWORD(v1089) = 0;
                }
                else
                {
                  uint64_t v1089 = 0;
                  uint64_t v1090 = v225[3];
                  int v1091 = v1625;
                  do
                  {
                    ldiv_t v1092 = ldiv(v1091, v226[v1088]);
                    int v1091 = v1092.quot;
                    v1089 += *(void *)(v1090 + 8 * v1088--) * v1092.rem;
                  }
                  while (v1088 != -1);
                }
                uint64_t v25 = v1685;
                if ((int)v1651 >= 1)
                {
                  uint64_t v1093 = 0;
                  unsigned int v1094 = v1575;
                  do
                  {
                    *(unsigned char *)(v1083 + v1093) = *(unsigned __int8 *)(v1581 + (int)v1084 + v1093) >> *(unsigned char *)(v1578 + (int)v1089 + v1093);
                    --v1094;
                    ++v1093;
                  }
                  while (v1094 > 1);
                }
                v1083 += v1595;
                uint64_t v1082 = v1625 + v1595;
              }
              while (v1625 + v1595 < v1610);
            }
          }
          break;
        default:
LABEL_287:
          switch(v284)
          {
            case 1uLL:
              uint64_t v289 = v21[6];
              if (v289)
              {
                uint64_t v290 = (unsigned __int8 *)v22[19];
                uint64_t v291 = (unsigned char *)v225[19];
                unint64_t v292 = (unsigned char *)v21[19];
                uint64_t v293 = *(void *)v22[3];
                uint64_t v294 = *(void *)v225[3];
                do
                {
                  *v292++ = *v290 >> *v291;
                  v291 += v294;
                  v290 += v293;
                  --v289;
                }
                while (v289);
              }
              break;
            case 2uLL:
              uint64_t v482 = *v23;
              if (v482)
              {
                uint64_t v483 = 0;
                uint64_t v484 = 0;
                uint64_t v485 = 0;
                uint64_t v486 = 0;
                uint64_t v487 = v22[19];
                uint64_t v488 = v225[19];
                uint64_t v489 = v21[19];
                unint64_t v490 = v23[1];
                uint64_t v491 = (uint64_t *)v22[3];
                uint64_t v492 = *v491;
                uint64_t v493 = v491[1];
                uint64_t v494 = (uint64_t *)v225[3];
                uint64_t v495 = *v494;
                uint64_t v496 = v494[1];
                uint64_t v497 = v495 - v496 * v226[1];
                if (v490 <= 1) {
                  uint64_t v498 = 1;
                }
                else {
                  uint64_t v498 = v23[1];
                }
                uint64_t v499 = v492 - v493 * v490;
                do
                {
                  if (v490)
                  {
                    uint64_t v500 = v484 + v498;
                    uint64_t v501 = (unsigned char *)(v489 + v484);
                    uint64_t v502 = v498;
                    do
                    {
                      *v501++ = *(unsigned __int8 *)(v487 + v486) >> *(unsigned char *)(v488 + v485);
                      v486 += v493;
                      v485 += v496;
                      --v502;
                    }
                    while (v502);
                    uint64_t v484 = v500;
                  }
                  v486 += v499;
                  v485 += v497;
                  ++v483;
                }
                while (v483 != v482);
              }
              break;
            case 3uLL:
              uint64_t v503 = *v23;
              if (v503)
              {
                uint64_t v504 = 0;
                uint64_t v505 = 0;
                uint64_t v506 = 0;
                uint64_t v507 = 0;
                uint64_t v508 = v22[19];
                uint64_t v509 = v225[19];
                uint64_t v510 = v21[19];
                unint64_t v511 = v23[1];
                uint64_t v512 = (void *)v22[3];
                uint64_t v513 = v512[1];
                uint64_t v514 = (void *)v225[3];
                uint64_t v515 = v514[1];
                uint64_t v516 = *v514 - v515 * v226[1];
                if (v511 <= 1) {
                  uint64_t v517 = 1;
                }
                else {
                  uint64_t v517 = v23[1];
                }
                unint64_t v518 = *v512 - v513 * v511;
                do
                {
                  if (v511)
                  {
                    uint64_t v519 = 0;
                    unint64_t v520 = v23[2];
                    uint64_t v521 = v512[2];
                    uint64_t v522 = v514[2];
                    if (v520 <= 1) {
                      uint64_t v523 = 1;
                    }
                    else {
                      uint64_t v523 = v23[2];
                    }
                    uint64_t v524 = v515 - v522 * v226[2];
                    do
                    {
                      uint64_t v525 = v523;
                      if (v520)
                      {
                        do
                        {
                          *(unsigned char *)(v510 + v505++) = *(unsigned __int8 *)(v508 + v507) >> *(unsigned char *)(v509 + v506);
                          v507 += v521;
                          v506 += v522;
                          --v525;
                        }
                        while (v525);
                      }
                      v507 += v513 - v521 * v520;
                      v506 += v524;
                      ++v519;
                    }
                    while (v519 != v517);
                  }
                  v507 += v518;
                  v506 += v516;
                  ++v504;
                }
                while (v504 != v503);
              }
              break;
            case 4uLL:
              uint64_t v1690 = *v23;
              if (v1690)
              {
                uint64_t v526 = 0;
                uint64_t v527 = 0;
                uint64_t v528 = 0;
                uint64_t v529 = 0;
                uint64_t v530 = v22[19];
                uint64_t v531 = v225[19];
                uint64_t v532 = v21[19];
                unint64_t v533 = v23[1];
                uint64_t v534 = (void *)v22[3];
                uint64_t v535 = (void *)v225[3];
                uint64_t v1594 = v535[1];
                uint64_t v1608 = v534[1];
                uint64_t v1653 = *v535 - v1594 * v226[1];
                int v1675 = v23[1];
                if (v533 <= 1) {
                  uint64_t v536 = 1;
                }
                else {
                  uint64_t v536 = v23[1];
                }
                unint64_t v1617 = *v534 - v534[1] * v533;
                uint64_t v1631 = v2;
                do
                {
                  if (v1675)
                  {
                    uint64_t v537 = 0;
                    unint64_t v538 = v23[2];
                    uint64_t v539 = v534[2];
                    uint64_t v540 = v535[2];
                    if (v538 <= 1) {
                      uint64_t v541 = 1;
                    }
                    else {
                      uint64_t v541 = v23[2];
                    }
                    uint64_t v542 = v1594 - v540 * v226[2];
                    do
                    {
                      if (v538)
                      {
                        uint64_t v543 = 0;
                        unint64_t v544 = v23[3];
                        uint64_t v545 = v534[3];
                        uint64_t v546 = v535[3];
                        if (v544 <= 1) {
                          uint64_t v547 = 1;
                        }
                        else {
                          uint64_t v547 = v23[3];
                        }
                        uint64_t v548 = v540 - v546 * v226[3];
                        do
                        {
                          uint64_t v549 = v547;
                          if (v544)
                          {
                            do
                            {
                              *(unsigned char *)(v532 + v527++) = *(unsigned __int8 *)(v530 + v529) >> *(unsigned char *)(v531 + v528);
                              v529 += v545;
                              v528 += v546;
                              --v549;
                            }
                            while (v549);
                          }
                          v529 += v539 - v545 * v544;
                          v528 += v548;
                          ++v543;
                        }
                        while (v543 != v541);
                      }
                      v529 += v1608 - v539 * v538;
                      v528 += v542;
                      ++v537;
                    }
                    while (v537 != v536);
                  }
                  uint64_t v2 = v1631;
                  v529 += v1617;
                  v528 += v1653;
                  ++v526;
                }
                while (v526 != v1690);
              }
              break;
            default:
              uint64_t v1652 = v21[6];
              if (v1652)
              {
                uint64_t v471 = 0;
                uint64_t v1607 = v225[19];
                uint64_t v1616 = v22[19];
                uint64_t v1593 = v21[19];
                do
                {
                  uint64_t v472 = 0;
                  if ((v25 & 0x80000000) == 0)
                  {
                    uint64_t v473 = v22[3];
                    uint64_t v474 = v25;
                    int v475 = v471;
                    do
                    {
                      ldiv_t v476 = ldiv(v475, v23[v474]);
                      int v475 = v476.quot;
                      v472 += *(void *)(v473 + 8 * v474--) * v476.rem;
                    }
                    while (v474 != -1);
                  }
                  uint64_t v477 = v1670;
                  if ((v1670 & 0x80000000) != 0)
                  {
                    LODWORD(v478) = 0;
                  }
                  else
                  {
                    uint64_t v478 = 0;
                    uint64_t v479 = v225[3];
                    int v480 = v471;
                    do
                    {
                      ldiv_t v481 = ldiv(v480, v226[v477]);
                      int v480 = v481.quot;
                      v478 += *(void *)(v479 + 8 * v477--) * v481.rem;
                    }
                    while (v477 != -1);
                  }
                  *(unsigned char *)(v1593 + v471++) = *(unsigned __int8 *)(v1616 + (int)v472) >> *(unsigned char *)(v1607 + (int)v478);
                  uint64_t v25 = v1685;
                }
                while (v471 != v1652);
              }
              break;
          }
          break;
      }
LABEL_31:
      unsigned int v49 = *(uint64_t **)v2;
      uint64_t v50 = *(uint64_t **)(v2 + 8);
      int v51 = *(mlx::core::array **)(v2 + 16);
      switch(v52)
      {
        case 0:
          int v13 = **(unsigned __int8 **)(*v49 + 152) >> **(unsigned char **)(*v50 + 152);
          uint64_t v14 = *(void *)v51;
          goto LABEL_33;
        case 1:
          int v61 = *(_DWORD *)(*v50 + 160);
          if (v61 >= 1)
          {
            int v62 = *(unsigned char **)(*(void *)v51 + 152);
            int v63 = *(char **)(*v50 + 152);
            unsigned int v64 = **(unsigned __int8 **)(*v49 + 152);
            unsigned int v65 = v61 + 1;
            do
            {
              char v66 = *v63++;
              *v62++ = v64 >> v66;
              --v65;
            }
            while (v65 > 1);
          }
          return;
        case 2:
          int v67 = *(_DWORD *)(*v49 + 160);
          if (v67 >= 1)
          {
            uint64_t v68 = *(unsigned char **)(*(void *)v51 + 152);
            unsigned int v69 = *(unsigned __int8 **)(*v49 + 152);
            char v70 = **(unsigned char **)(*v50 + 152);
            unsigned int v71 = v67 + 1;
            do
            {
              unsigned int v72 = *v69++;
              *v68++ = v72 >> v70;
              --v71;
            }
            while (v71 > 1);
          }
          return;
        case 3:
          int v73 = *(_DWORD *)(*(void *)v51 + 48);
          if (v73 >= 1)
          {
            int v74 = *(unsigned char **)(*(void *)v51 + 152);
            unsigned int v75 = *(unsigned char **)(*v50 + 152);
            char v76 = *(unsigned __int8 **)(*v49 + 152);
            unsigned int v77 = v73 + 1;
            do
            {
              unsigned int v79 = *v76++;
              unsigned int v78 = v79;
              LOBYTE(v79) = *v75++;
              *v74++ = v78 >> v79;
              --v77;
            }
            while (v77 > 1);
          }
          return;
        default:
          int v53 = *(void **)v51;
          uint64_t v54 = *v49;
          int v55 = *(int **)*v49;
          uint64_t v56 = (*(void *)(*v49 + 8) - (void)v55) >> 2;
          int v57 = v56 - 1;
          if ((int)v56 - 1 >= -1) {
            int v57 = -1;
          }
          int v58 = v57 + 1;
          int v59 = v56 + 1;
          break;
      }
      while (1)
      {
        unsigned int v60 = v59 - 2;
        if (v59 - 2 < 0) {
          break;
        }
        --v59;
        if (*(void *)(*(void *)(v54 + 24) + 8 * v60) != *(void *)(v53[3] + 8 * v60)) {
          goto LABEL_53;
        }
      }
      int v59 = v58;
LABEL_53:
      int v80 = (int **)*v50;
      unsigned int v81 = *(int **)*v50;
      uint64_t v82 = (*(void *)(*v50 + 8) - (void)v81) >> 2;
      int v83 = v82 - 1;
      if ((int)v82 - 1 >= -1) {
        int v83 = -1;
      }
      int v84 = v83 + 1;
      int v85 = v82 + 1;
      while (1)
      {
        unsigned int v86 = v85 - 2;
        if (v85 - 2 < 0) {
          break;
        }
        --v85;
        if (*(void *)&v80[3][2 * v86] != *(void *)(v53[3] + 8 * v86)) {
          goto LABEL_60;
        }
      }
      int v85 = v84;
LABEL_60:
      int v87 = v56 + 1;
      while (1)
      {
        unsigned int v88 = v87 - 2;
        if (v87 - 2 < 0) {
          break;
        }
        --v87;
        if (*(void *)(*(void *)(v54 + 24) + 8 * v88)) {
          goto LABEL_65;
        }
      }
      int v87 = v58;
LABEL_65:
      int v89 = v82 + 1;
      while (1)
      {
        int v90 = v89 - 2;
        if (v89 - 2 < 0) {
          break;
        }
        --v89;
        if (*(void *)&v80[3][2 * v90]) {
          goto LABEL_70;
        }
      }
      int v89 = v84;
LABEL_70:
      unint64_t v91 = (uint64_t)(v53[1] - *v53) >> 2;
      if (v59 <= v85) {
        int v92 = v85;
      }
      else {
        int v92 = v59;
      }
      if (v59 <= v89) {
        int v59 = v89;
      }
      if (v87 > v85) {
        int v85 = v87;
      }
      if (v91 > v85)
      {
        int v93 = 1;
      }
      else
      {
        int v85 = (uint64_t)(v53[1] - *v53) >> 2;
        int v93 = 4;
      }
      if (v91 > v59)
      {
        int v94 = 2;
      }
      else
      {
        int v59 = v85;
        int v94 = v93;
      }
      if (v91 > v92)
      {
        int v59 = v92;
        int v94 = 3;
      }
      unint64_t v1684 = v51;
      if (!v59) {
        goto LABEL_87;
      }
      unint64_t v95 = *(void *)(v53[3] + 8 * (v59 - 1));
      if (v95 < 0x10) {
        goto LABEL_87;
      }
      switch(v94)
      {
        case 1:
          if (v59 == 2)
          {
            int v996 = *v55;
            if (*v55)
            {
              unint64_t v997 = 0;
              uint64_t v998 = 0;
              uint64_t v999 = 0;
              uint64_t v1000 = *(void *)(v54 + 152);
              int v1001 = v80[19];
              uint64_t v1002 = v53[19];
              do
              {
                if (v55[1])
                {
                  unint64_t v1003 = 0;
                  do
                  {
                    if ((int)v95 >= 1)
                    {
                      uint64_t v1004 = 0;
                      unsigned int v1005 = *(unsigned __int8 *)(v1000 + v999);
                      unsigned int v1006 = v95 + 1;
                      do
                      {
                        *(unsigned char *)(v1002 + v1004) = v1005 >> *((unsigned char *)v1001 + v998 + v1004);
                        --v1006;
                        ++v1004;
                      }
                      while (v1006 > 1);
                      uint64_t v54 = *v49;
                      int v80 = (int **)*v50;
                      int v55 = *(int **)*v49;
                    }
                    uint64_t v1007 = *(void **)(v54 + 24);
                    uint64_t v1008 = v1007[1];
                    v999 += v1008;
                    v998 += *((void *)v80[3] + 1);
                    v1002 += (int)v95;
                    ++v1003;
                    unint64_t v1009 = v55[1];
                  }
                  while (v1003 < v1009);
                  int v996 = *v55;
                  unsigned int v81 = *v80;
                }
                else
                {
                  unint64_t v1009 = 0;
                  uint64_t v1007 = *(void **)(v54 + 24);
                  uint64_t v1008 = v1007[1];
                }
                uint64_t v999 = *v1007 + v999 - v1009 * v1008;
                uint64_t v998 = *(void *)v80[3] + v998 - *((void *)v80[3] + 1) * v81[1];
                ++v997;
              }
              while (v997 < v996);
            }
          }
          else if (v59 == 1)
          {
            int v451 = *v55;
            if (*v55)
            {
              unint64_t v452 = 0;
              uint64_t v453 = 0;
              uint64_t v454 = 0;
              uint64_t v455 = *(void *)(v54 + 152);
              uint64_t v456 = v80[19];
              uint64_t v457 = v53[19];
              do
              {
                if ((int)v95 >= 1)
                {
                  uint64_t v458 = 0;
                  unsigned int v459 = *(unsigned __int8 *)(v455 + v454);
                  unsigned int v460 = v95 + 1;
                  do
                  {
                    *(unsigned char *)(v457 + v458) = v459 >> *((unsigned char *)v456 + v453 + v458);
                    --v460;
                    ++v458;
                  }
                  while (v460 > 1);
                  uint64_t v54 = *v49;
                  int v80 = (int **)*v50;
                  int v451 = **(_DWORD **)*v49;
                }
                v454 += **(void **)(v54 + 24);
                v453 += *(void *)v80[3];
                v457 += (int)v95;
                ++v452;
              }
              while (v452 < v451);
            }
          }
          else if (v53[6])
          {
            uint64_t v1623 = v80[19];
            uint64_t v1637 = *(void *)(v54 + 152);
            unint64_t v1679 = 0;
            uint64_t v1010 = v53[19];
            do
            {
              uint64_t v1011 = *(void *)*v49;
              unint64_t v1012 = (unint64_t)(*(void *)(*v49 + 8) - v1011) >> 2;
              uint64_t v1013 = 0;
              uint64_t v1014 = (v1012 - 1);
              if ((int)v1012 - 1 >= 0)
              {
                uint64_t v1015 = *(void *)(*v49 + 24);
                int v1016 = v1679;
                do
                {
                  ldiv_t v1017 = ldiv(v1016, *(int *)(v1011 + 4 * v1014));
                  int v1016 = v1017.quot;
                  v1013 += *(void *)(v1015 + 8 * v1014--) * v1017.rem;
                }
                while (v1014 != -1);
              }
              uint64_t v1018 = *(void *)*v50;
              unint64_t v1019 = (unint64_t)(*(void *)(*v50 + 8) - v1018) >> 2;
              uint64_t v1020 = 0;
              uint64_t v1021 = (v1019 - 1);
              if ((int)v1019 - 1 >= 0)
              {
                uint64_t v1022 = *(void *)(*v50 + 24);
                int v1023 = v1679;
                do
                {
                  ldiv_t v1024 = ldiv(v1023, *(int *)(v1018 + 4 * v1021));
                  int v1023 = v1024.quot;
                  v1020 += *(void *)(v1022 + 8 * v1021--) * v1024.rem;
                }
                while (v1021 != -1);
              }
              if ((int)v95 >= 1)
              {
                uint64_t v1025 = 0;
                unsigned int v1026 = *(unsigned __int8 *)(v1637 + (int)v1013);
                unsigned int v1027 = v95 + 1;
                do
                {
                  *(unsigned char *)(v1010 + v1025) = v1026 >> *((unsigned char *)v1623 + (int)v1020 + v1025);
                  --v1027;
                  ++v1025;
                }
                while (v1027 > 1);
                int v53 = *(void **)v1684;
              }
              v1010 += (int)v95;
              v1679 += (int)v95;
            }
            while (v1679 < v53[6]);
          }
          break;
        case 2:
          if (v59 == 2)
          {
            int v1028 = *v55;
            if (*v55)
            {
              unint64_t v1029 = 0;
              uint64_t v1030 = 0;
              uint64_t v1031 = 0;
              uint64_t v1032 = *(void *)(v54 + 152);
              ldiv_t v1033 = v80[19];
              uint64_t v1034 = v53[19];
              do
              {
                if (v55[1])
                {
                  unint64_t v1035 = 0;
                  do
                  {
                    if ((int)v95 >= 1)
                    {
                      uint64_t v1036 = 0;
                      char v1037 = *((unsigned char *)v1033 + v1030);
                      unsigned int v1038 = v95 + 1;
                      do
                      {
                        *(unsigned char *)(v1034 + v1036) = *(unsigned __int8 *)(v1032 + v1031 + v1036) >> v1037;
                        --v1038;
                        ++v1036;
                      }
                      while (v1038 > 1);
                      uint64_t v54 = *v49;
                      int v80 = (int **)*v50;
                      int v55 = *(int **)*v49;
                    }
                    uint64_t v1039 = *(void **)(v54 + 24);
                    uint64_t v1040 = v1039[1];
                    v1031 += v1040;
                    v1030 += *((void *)v80[3] + 1);
                    v1034 += (int)v95;
                    ++v1035;
                    unint64_t v1041 = v55[1];
                  }
                  while (v1035 < v1041);
                  int v1028 = *v55;
                  unsigned int v81 = *v80;
                }
                else
                {
                  unint64_t v1041 = 0;
                  uint64_t v1039 = *(void **)(v54 + 24);
                  uint64_t v1040 = v1039[1];
                }
                uint64_t v1031 = *v1039 + v1031 - v1041 * v1040;
                uint64_t v1030 = *(void *)v80[3] + v1030 - *((void *)v80[3] + 1) * v81[1];
                ++v1029;
              }
              while (v1029 < v1028);
            }
          }
          else if (v59 == 1)
          {
            int v461 = *v55;
            if (*v55)
            {
              unint64_t v462 = 0;
              uint64_t v463 = 0;
              uint64_t v464 = 0;
              uint64_t v465 = *(void *)(v54 + 152);
              uint64_t v466 = v80[19];
              uint64_t v467 = v53[19];
              do
              {
                if ((int)v95 >= 1)
                {
                  uint64_t v468 = 0;
                  char v469 = *((unsigned char *)v466 + v463);
                  unsigned int v470 = v95 + 1;
                  do
                  {
                    *(unsigned char *)(v467 + v468) = *(unsigned __int8 *)(v465 + v464 + v468) >> v469;
                    --v470;
                    ++v468;
                  }
                  while (v470 > 1);
                  uint64_t v54 = *v49;
                  int v80 = (int **)*v50;
                  int v461 = **(_DWORD **)*v49;
                }
                v464 += **(void **)(v54 + 24);
                v463 += *(void *)v80[3];
                v467 += (int)v95;
                ++v462;
              }
              while (v462 < v461);
            }
          }
          else if (v53[6])
          {
            uint64_t v1624 = v80[19];
            uint64_t v1638 = *(void *)(v54 + 152);
            unint64_t v1680 = 0;
            uint64_t v1042 = v53[19];
            do
            {
              uint64_t v1043 = *(void *)*v49;
              unint64_t v1044 = (unint64_t)(*(void *)(*v49 + 8) - v1043) >> 2;
              uint64_t v1045 = 0;
              uint64_t v1046 = (v1044 - 1);
              if ((int)v1044 - 1 >= 0)
              {
                uint64_t v1047 = *(void *)(*v49 + 24);
                int v1048 = v1680;
                do
                {
                  ldiv_t v1049 = ldiv(v1048, *(int *)(v1043 + 4 * v1046));
                  int v1048 = v1049.quot;
                  v1045 += *(void *)(v1047 + 8 * v1046--) * v1049.rem;
                }
                while (v1046 != -1);
              }
              uint64_t v1050 = *(void *)*v50;
              unint64_t v1051 = (unint64_t)(*(void *)(*v50 + 8) - v1050) >> 2;
              uint64_t v1052 = 0;
              uint64_t v1053 = (v1051 - 1);
              if ((int)v1051 - 1 >= 0)
              {
                uint64_t v1054 = *(void *)(*v50 + 24);
                int v1055 = v1680;
                do
                {
                  ldiv_t v1056 = ldiv(v1055, *(int *)(v1050 + 4 * v1053));
                  int v1055 = v1056.quot;
                  v1052 += *(void *)(v1054 + 8 * v1053--) * v1056.rem;
                }
                while (v1053 != -1);
              }
              if ((int)v95 >= 1)
              {
                uint64_t v1057 = 0;
                char v1058 = *((unsigned char *)v1624 + (int)v1052);
                unsigned int v1059 = v95 + 1;
                do
                {
                  *(unsigned char *)(v1042 + v1057) = *(unsigned __int8 *)(v1638 + (int)v1045 + v1057) >> v1058;
                  --v1059;
                  ++v1057;
                }
                while (v1059 > 1);
                int v53 = *(void **)v1684;
              }
              v1042 += (int)v95;
              v1680 += (int)v95;
            }
            while (v1680 < v53[6]);
          }
          break;
        case 3:
          if (v59 == 2)
          {
            int v966 = *v55;
            if (*v55)
            {
              unint64_t v967 = 0;
              uint64_t v968 = 0;
              uint64_t v969 = 0;
              uint64_t v970 = *(void *)(v54 + 152);
              uint64_t v971 = v80[19];
              uint64_t v972 = v53[19];
              do
              {
                if (v55[1])
                {
                  unint64_t v973 = 0;
                  do
                  {
                    if ((int)v95 >= 1)
                    {
                      uint64_t v974 = 0;
                      unsigned int v975 = v95 + 1;
                      do
                      {
                        *(unsigned char *)(v972 + v974) = *(unsigned __int8 *)(v970 + v969 + v974) >> *((unsigned char *)v971
                                                                                              + v968
                                                                                              + v974);
                        --v975;
                        ++v974;
                      }
                      while (v975 > 1);
                      uint64_t v54 = *v49;
                      int v80 = (int **)*v50;
                      int v55 = *(int **)*v49;
                    }
                    int v976 = *(void **)(v54 + 24);
                    uint64_t v977 = v976[1];
                    v969 += v977;
                    v968 += *((void *)v80[3] + 1);
                    v972 += (int)v95;
                    ++v973;
                    unint64_t v978 = v55[1];
                  }
                  while (v973 < v978);
                  int v966 = *v55;
                  unsigned int v81 = *v80;
                }
                else
                {
                  unint64_t v978 = 0;
                  int v976 = *(void **)(v54 + 24);
                  uint64_t v977 = v976[1];
                }
                uint64_t v969 = *v976 + v969 - v978 * v977;
                uint64_t v968 = *(void *)v80[3] + v968 - *((void *)v80[3] + 1) * v81[1];
                ++v967;
              }
              while (v967 < v966);
            }
          }
          else if (v59 == 1)
          {
            int v216 = *v55;
            if (*v55)
            {
              unint64_t v217 = 0;
              uint64_t v218 = 0;
              uint64_t v219 = 0;
              uint64_t v220 = *(void *)(v54 + 152);
              v221 = v80[19];
              uint64_t v222 = v53[19];
              do
              {
                if ((int)v95 >= 1)
                {
                  uint64_t v223 = 0;
                  unsigned int v224 = v95 + 1;
                  do
                  {
                    *(unsigned char *)(v222 + v223) = *(unsigned __int8 *)(v220 + v219 + v223) >> *((unsigned char *)v221 + v218 + v223);
                    --v224;
                    ++v223;
                  }
                  while (v224 > 1);
                  uint64_t v54 = *v49;
                  int v80 = (int **)*v50;
                  int v216 = **(_DWORD **)*v49;
                }
                v219 += **(void **)(v54 + 24);
                v218 += *(void *)v80[3];
                v222 += (int)v95;
                ++v217;
              }
              while (v217 < v216);
            }
          }
          else if (v53[6])
          {
            uint64_t v1622 = v80[19];
            uint64_t v1636 = *(void *)(v54 + 152);
            unint64_t v1678 = 0;
            uint64_t v979 = v53[19];
            do
            {
              uint64_t v980 = *(void *)*v49;
              unint64_t v981 = (unint64_t)(*(void *)(*v49 + 8) - v980) >> 2;
              uint64_t v982 = 0;
              uint64_t v983 = (v981 - 1);
              if ((int)v981 - 1 >= 0)
              {
                uint64_t v984 = *(void *)(*v49 + 24);
                int v985 = v1678;
                do
                {
                  ldiv_t v986 = ldiv(v985, *(int *)(v980 + 4 * v983));
                  int v985 = v986.quot;
                  v982 += *(void *)(v984 + 8 * v983--) * v986.rem;
                }
                while (v983 != -1);
              }
              uint64_t v987 = *(void *)*v50;
              unint64_t v988 = (unint64_t)(*(void *)(*v50 + 8) - v987) >> 2;
              uint64_t v989 = 0;
              uint64_t v990 = (v988 - 1);
              if ((int)v988 - 1 >= 0)
              {
                uint64_t v991 = *(void *)(*v50 + 24);
                int v992 = v1678;
                do
                {
                  ldiv_t v993 = ldiv(v992, *(int *)(v987 + 4 * v990));
                  int v992 = v993.quot;
                  v989 += *(void *)(v991 + 8 * v990--) * v993.rem;
                }
                while (v990 != -1);
              }
              if ((int)v95 >= 1)
              {
                uint64_t v994 = 0;
                unsigned int v995 = v95 + 1;
                do
                {
                  *(unsigned char *)(v979 + v994) = *(unsigned __int8 *)(v1636 + (int)v982 + v994) >> *((unsigned char *)v1622
                                                                                              + (int)v989
                                                                                              + v994);
                  --v995;
                  ++v994;
                }
                while (v995 > 1);
                int v53 = *(void **)v1684;
              }
              v979 += (int)v95;
              v1678 += (int)v95;
            }
            while (v1678 < v53[6]);
          }
          break;
        default:
LABEL_87:
          switch(v91)
          {
            case 1uLL:
              if (v53[6])
              {
                unint64_t v96 = 0;
                uint64_t v97 = 0;
                uint64_t v98 = 0;
                uint64_t v99 = *(void *)(v54 + 152);
                uint64_t v100 = v80[19];
                uint64_t v101 = v53[19];
                do
                {
                  *(unsigned char *)(v101 + v96) = *(unsigned __int8 *)(v99 + v98) >> *((unsigned char *)v100 + v97);
                  v98 += **(void **)(*v49 + 24);
                  v97 += **(void **)(*v50 + 24);
                  ++v96;
                }
                while (v96 < *(void *)(*(void *)v51 + 48));
              }
              break;
            case 2uLL:
              int v401 = *v55;
              if (*v55)
              {
                unint64_t v402 = 0;
                uint64_t v403 = 0;
                uint64_t v404 = 0;
                uint64_t v405 = 0;
                uint64_t v406 = *(void *)(v54 + 152);
                unint64_t v407 = v80[19];
                uint64_t v408 = v53[19];
                do
                {
                  if (v55[1])
                  {
                    unint64_t v409 = 0;
                    do
                    {
                      *(unsigned char *)(v408 + v403 + v409) = *(unsigned __int8 *)(v406 + v405) >> *((unsigned char *)v407 + v404);
                      uint64_t v54 = *v49;
                      uint64_t v410 = *(void **)(*v49 + 24);
                      uint64_t v411 = v410[1];
                      v405 += v411;
                      int v80 = (int **)*v50;
                      uint64_t v412 = *(int **)(*v50 + 24);
                      uint64_t v413 = *((void *)v412 + 1);
                      v404 += v413;
                      ++v409;
                      int v55 = *(int **)*v49;
                      unint64_t v414 = v55[1];
                    }
                    while (v409 < v414);
                    int v401 = *v55;
                    unsigned int v81 = *v80;
                    v403 += v409;
                  }
                  else
                  {
                    unint64_t v414 = 0;
                    uint64_t v410 = *(void **)(v54 + 24);
                    uint64_t v411 = v410[1];
                    uint64_t v412 = v80[3];
                    uint64_t v413 = *((void *)v412 + 1);
                  }
                  uint64_t v405 = *v410 + v405 - v414 * v411;
                  uint64_t v404 = *(void *)v412 + v404 - v413 * v81[1];
                  ++v402;
                }
                while (v402 < v401);
              }
              break;
            case 3uLL:
              int v415 = *v55;
              if (*v55)
              {
                unint64_t v416 = 0;
                uint64_t v417 = 0;
                uint64_t v418 = 0;
                uint64_t v419 = 0;
                uint64_t v420 = *(void *)(v54 + 152);
                uint64_t v421 = v80[19];
                uint64_t v422 = v53[19];
                do
                {
                  if (v55[1])
                  {
                    unint64_t v423 = 0;
                    do
                    {
                      if (v55[2])
                      {
                        unint64_t v424 = 0;
                        do
                        {
                          *(unsigned char *)(v422 + v417 + v424) = *(unsigned __int8 *)(v420 + v419) >> *((unsigned char *)v421 + v418);
                          uint64_t v54 = *v49;
                          unint64_t v425 = *(void **)(*v49 + 24);
                          uint64_t v426 = v425[2];
                          v419 += v426;
                          int v80 = (int **)*v50;
                          uint64_t v427 = *(int **)(*v50 + 24);
                          uint64_t v428 = *((void *)v427 + 2);
                          v418 += v428;
                          ++v424;
                          int v55 = *(int **)*v49;
                          unint64_t v429 = v55[2];
                        }
                        while (v424 < v429);
                        unsigned int v81 = *v80;
                        v417 += v424;
                      }
                      else
                      {
                        unint64_t v429 = 0;
                        unint64_t v425 = *(void **)(v54 + 24);
                        uint64_t v426 = v425[2];
                        uint64_t v427 = v80[3];
                        uint64_t v428 = *((void *)v427 + 2);
                      }
                      uint64_t v430 = v425[1];
                      uint64_t v419 = v430 + v419 - v429 * v426;
                      uint64_t v418 = *((void *)v427 + 1) + v418 - v428 * v81[2];
                      ++v423;
                      unint64_t v431 = v55[1];
                    }
                    while (v423 < v431);
                    int v415 = *v55;
                  }
                  else
                  {
                    unint64_t v431 = 0;
                    unint64_t v425 = *(void **)(v54 + 24);
                    uint64_t v430 = v425[1];
                  }
                  uint64_t v419 = *v425 + v419 - v431 * v430;
                  uint64_t v418 = *(void *)v80[3] + v418 - *((void *)v80[3] + 1) * v81[1];
                  ++v416;
                }
                while (v416 < v415);
              }
              break;
            case 4uLL:
              int v432 = *v55;
              if (*v55)
              {
                unint64_t v433 = 0;
                uint64_t v434 = 0;
                uint64_t v435 = 0;
                uint64_t v436 = 0;
                uint64_t v437 = *(void *)(v54 + 152);
                uint64_t v438 = v80[19];
                uint64_t v439 = v53[19];
                do
                {
                  if (v55[1])
                  {
                    unint64_t v440 = 0;
                    do
                    {
                      if (v55[2])
                      {
                        unint64_t v441 = 0;
                        do
                        {
                          if (v55[3])
                          {
                            unint64_t v442 = 0;
                            do
                            {
                              *(unsigned char *)(v439 + v434 + v442) = *(unsigned __int8 *)(v437 + v436) >> *((unsigned char *)v438 + v435);
                              uint64_t v54 = *v49;
                              int v443 = *(void **)(*v49 + 24);
                              uint64_t v444 = v443[3];
                              v436 += v444;
                              int v80 = (int **)*v50;
                              int v445 = *(int **)(*v50 + 24);
                              uint64_t v446 = *((void *)v445 + 3);
                              v435 += v446;
                              ++v442;
                              int v55 = *(int **)*v49;
                              unint64_t v447 = v55[3];
                            }
                            while (v442 < v447);
                            unsigned int v81 = *v80;
                            v434 += v442;
                          }
                          else
                          {
                            unint64_t v447 = 0;
                            int v443 = *(void **)(v54 + 24);
                            uint64_t v444 = v443[3];
                            int v445 = v80[3];
                            uint64_t v446 = *((void *)v445 + 3);
                          }
                          uint64_t v448 = v443[2];
                          uint64_t v436 = v448 + v436 - v447 * v444;
                          uint64_t v435 = *((void *)v445 + 2) + v435 - v446 * v81[3];
                          ++v441;
                          unint64_t v449 = v55[2];
                        }
                        while (v441 < v449);
                      }
                      else
                      {
                        unint64_t v449 = 0;
                        int v443 = *(void **)(v54 + 24);
                        uint64_t v448 = v443[2];
                      }
                      uint64_t v436 = v443[1] + v436 - v449 * v448;
                      uint64_t v435 = *((void *)v80[3] + 1) + v435 - *((void *)v80[3] + 2) * v81[2];
                      ++v440;
                      unint64_t v450 = v55[1];
                    }
                    while (v440 < v450);
                    int v432 = *v55;
                  }
                  else
                  {
                    unint64_t v450 = 0;
                  }
                  uint64_t v436 = **(void **)(v54 + 24) + v436 - *(void *)(*(void *)(v54 + 24) + 8) * v450;
                  uint64_t v435 = *(void *)v80[3] + v435 - *((void *)v80[3] + 1) * v81[1];
                  ++v433;
                }
                while (v433 < v432);
              }
              break;
            default:
              if (v53[6])
              {
                unint64_t v384 = 0;
                uint64_t v1674 = *(void *)(v54 + 152);
                int v385 = v80[19];
                uint64_t v386 = v53[19];
                do
                {
                  uint64_t v387 = *(void *)*v49;
                  unint64_t v388 = (unint64_t)(*(void *)(*v49 + 8) - v387) >> 2;
                  uint64_t v389 = 0;
                  uint64_t v390 = (v388 - 1);
                  if ((int)v388 - 1 >= 0)
                  {
                    uint64_t v391 = *(void *)(*v49 + 24);
                    int v392 = v384;
                    do
                    {
                      ldiv_t v393 = ldiv(v392, *(int *)(v387 + 4 * v390));
                      int v392 = v393.quot;
                      v389 += *(void *)(v391 + 8 * v390--) * v393.rem;
                    }
                    while (v390 != -1);
                  }
                  uint64_t v394 = *(void *)*v50;
                  unint64_t v395 = (unint64_t)(*(void *)(*v50 + 8) - v394) >> 2;
                  uint64_t v396 = 0;
                  uint64_t v397 = (v395 - 1);
                  if ((int)v395 - 1 >= 0)
                  {
                    uint64_t v398 = *(void *)(*v50 + 24);
                    int v399 = v384;
                    do
                    {
                      ldiv_t v400 = ldiv(v399, *(int *)(v394 + 4 * v397));
                      int v399 = v400.quot;
                      v396 += *(void *)(v398 + 8 * v397--) * v400.rem;
                    }
                    while (v397 != -1);
                  }
                  *(unsigned char *)(v386 + v384++) = *(unsigned __int8 *)(v1674 + (int)v389) >> *((unsigned char *)v385 + (int)v396);
                }
                while (v384 < *(void *)(*(void *)v1684 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 1:
      goto LABEL_31;
    case 2:
      char v7 = *(uint64_t **)a1;
      BOOL v6 = *(uint64_t **)(a1 + 8);
      switch(v8)
      {
        case 0:
          int v9 = **(_DWORD **)(*v7 + 152) >> **(_DWORD **)(*v6 + 152);
          goto LABEL_10;
        case 1:
          int v111 = *(_DWORD *)(*v6 + 160);
          if (v111 >= 1)
          {
            unsigned int v112 = **(_DWORD **)(*v7 + 152);
            int v113 = *(unsigned int **)(*(void *)v1 + 152);
            int v114 = *(int **)(*v6 + 152);
            unsigned int v115 = v111 + 1;
            do
            {
              int v116 = *v114++;
              *v113++ = v112 >> v116;
              --v115;
            }
            while (v115 > 1);
          }
          return;
        case 2:
          int v117 = *(_DWORD *)(*v7 + 160);
          if (v117 >= 1)
          {
            int v118 = **(_DWORD **)(*v6 + 152);
            int v119 = *(unsigned int **)(*(void *)v1 + 152);
            unsigned int v120 = *(unsigned int **)(*v7 + 152);
            unsigned int v121 = v117 + 1;
            do
            {
              unsigned int v122 = *v120++;
              *v119++ = v122 >> v118;
              --v121;
            }
            while (v121 > 1);
          }
          return;
        case 3:
          int v123 = *(_DWORD *)(*(void *)v1 + 48);
          if (v123 >= 1)
          {
            int v124 = *(unsigned int **)(*(void *)v1 + 152);
            int v125 = *(int **)(*v6 + 152);
            int v126 = *(unsigned int **)(*v7 + 152);
            unsigned int v127 = v123 + 1;
            do
            {
              unsigned int v129 = *v126++;
              unsigned int v128 = v129;
              int v130 = *v125++;
              *v124++ = v128 >> v130;
              --v127;
            }
            while (v127 > 1);
          }
          return;
        default:
          int v102 = *(void **)v1;
          int v103 = (void *)*v7;
          int v104 = *(int **)*v7;
          uint64_t v105 = (v103[1] - (void)v104) >> 2;
          uint64_t v106 = (v105 - 1);
          if ((int)v106 >= -1) {
            int v107 = -1;
          }
          else {
            int v107 = v105 - 1;
          }
          int v108 = v107 + 1;
          int v109 = v105 + 1;
          break;
      }
      while (1)
      {
        unsigned int v110 = v109 - 2;
        if (v109 - 2 < 0) {
          break;
        }
        --v109;
        if (*(void *)(v103[3] + 8 * v110) != *(void *)(v102[3] + 8 * v110)) {
          goto LABEL_189;
        }
      }
      int v109 = v108;
LABEL_189:
      int v233 = (void *)*v6;
      int v234 = *(int **)*v6;
      uint64_t v235 = (v233[1] - (void)v234) >> 2;
      uint64_t v236 = (v235 - 1);
      if ((int)v236 >= -1) {
        int v237 = -1;
      }
      else {
        int v237 = v235 - 1;
      }
      int v238 = v237 + 1;
      int v239 = v235 + 1;
      while (1)
      {
        unsigned int v240 = v239 - 2;
        if (v239 - 2 < 0) {
          break;
        }
        --v239;
        if (*(void *)(v233[3] + 8 * v240) != *(void *)(v102[3] + 8 * v240)) {
          goto LABEL_225;
        }
      }
      int v239 = v238;
LABEL_225:
      int v266 = v105 + 1;
      while (1)
      {
        unsigned int v267 = v266 - 2;
        if (v266 - 2 < 0) {
          break;
        }
        --v266;
        if (*(void *)(v103[3] + 8 * v267)) {
          goto LABEL_250;
        }
      }
      int v266 = v108;
LABEL_250:
      int v276 = v235 + 1;
      while (1)
      {
        unsigned int v277 = v276 - 2;
        if (v276 - 2 < 0) {
          break;
        }
        --v276;
        if (*(void *)(v233[3] + 8 * v277)) {
          goto LABEL_293;
        }
      }
      int v276 = v238;
LABEL_293:
      unint64_t v295 = (uint64_t)(v102[1] - *v102) >> 2;
      if (v109 <= v239) {
        int v296 = v239;
      }
      else {
        int v296 = v109;
      }
      if (v109 <= v276) {
        int v109 = v276;
      }
      if (v266 > v239) {
        int v239 = v266;
      }
      if (v295 > v239)
      {
        int v297 = 1;
      }
      else
      {
        int v239 = (uint64_t)(v102[1] - *v102) >> 2;
        int v297 = 4;
      }
      if (v295 > v109)
      {
        int v298 = 2;
      }
      else
      {
        int v109 = v239;
        int v298 = v297;
      }
      if (v295 > v296)
      {
        int v109 = v296;
        int v298 = 3;
      }
      uint64_t v1671 = v236;
      uint64_t v1686 = v106;
      if (!v109) {
        goto LABEL_310;
      }
      unint64_t v299 = *(void *)(v102[3] + 8 * (v109 - 1));
      if (v299 < 0x10) {
        goto LABEL_310;
      }
      switch(v298)
      {
        case 1:
          if (v109 == 2)
          {
            int v1298 = *v104;
            if (*v104)
            {
              unint64_t v1299 = 0;
              uint64_t v1300 = 0;
              uint64_t v1301 = 0;
              uint64_t v1302 = v103[19];
              uint64_t v1303 = v233[19];
              uint64_t v1304 = v102[19];
              int v1305 = (uint64_t *)v103[3];
              uint64_t v1306 = *v1305;
              uint64_t v1307 = v1305[1];
              int v1308 = (uint64_t *)v233[3];
              uint64_t v1309 = *v1308;
              uint64_t v1310 = v1308[1];
              int v1311 = v104[1];
              int v1312 = v1311;
              do
              {
                if (v1312)
                {
                  unint64_t v1313 = 0;
                  uint64_t v1314 = v1303 + 4 * v1300;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1315 = 0;
                      unsigned int v1316 = *(_DWORD *)(v1302 + 4 * v1301);
                      unsigned int v1317 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1304 + v1315) = v1316 >> *(_DWORD *)(v1314 + v1315);
                        --v1317;
                        v1315 += 4;
                      }
                      while (v1317 > 1);
                      int v1311 = v104[1];
                    }
                    v1301 += v1307;
                    v1300 += v1310;
                    v1304 += 4 * (int)v299;
                    ++v1313;
                    v1314 += 4 * v1310;
                  }
                  while (v1313 < v1311);
                  uint64_t v1318 = v1311;
                  int v1298 = *v104;
                  int v1312 = v1311;
                }
                else
                {
                  uint64_t v1318 = 0;
                }
                uint64_t v1301 = v1301 + v1306 - v1318 * v1307;
                uint64_t v1300 = v1300 + v1309 - v1310 * v234[1];
                ++v1299;
              }
              while (v1299 < v1298);
            }
          }
          else if (v109 == 1)
          {
            int v880 = *v104;
            if (*v104)
            {
              unint64_t v881 = 0;
              uint64_t v882 = 0;
              uint64_t v883 = v103[19];
              uint64_t v884 = v233[19];
              uint64_t v885 = v102[19];
              uint64_t v886 = *(void *)v103[3];
              uint64_t v887 = 4 * *(void *)v233[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v888 = 0;
                  unsigned int v889 = *(_DWORD *)(v883 + 4 * v882);
                  unsigned int v890 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v885 + v888) = v889 >> *(_DWORD *)(v884 + v888);
                    --v890;
                    v888 += 4;
                  }
                  while (v890 > 1);
                  int v880 = *v104;
                }
                v882 += v886;
                ++v881;
                v885 += 4 * (int)v299;
                v884 += v887;
              }
              while (v881 < v880);
            }
          }
          else
          {
            unint64_t v1643 = v102[6];
            if (v1643)
            {
              unint64_t v1662 = 0;
              uint64_t v1587 = v233[19];
              uint64_t v1601 = v103[19];
              uint64_t v1319 = v102[19];
              do
              {
                uint64_t v1320 = 0;
                if ((v106 & 0x80000000) == 0)
                {
                  uint64_t v1321 = v103[3];
                  uint64_t v1322 = v106;
                  int v1323 = v1662;
                  do
                  {
                    ldiv_t v1324 = ldiv(v1323, v104[v1322]);
                    int v1323 = v1324.quot;
                    v1320 += *(void *)(v1321 + 8 * v1322--) * v1324.rem;
                  }
                  while (v1322 != -1);
                }
                uint64_t v1325 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1326) = 0;
                }
                else
                {
                  uint64_t v1326 = 0;
                  uint64_t v1327 = v233[3];
                  int v1328 = v1662;
                  do
                  {
                    ldiv_t v1329 = ldiv(v1328, v234[v1325]);
                    int v1328 = v1329.quot;
                    v1326 += *(void *)(v1327 + 8 * v1325--) * v1329.rem;
                  }
                  while (v1325 != -1);
                }
                uint64_t v106 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1330 = 0;
                  unsigned int v1331 = *(_DWORD *)(v1601 + 4 * (int)v1320);
                  unsigned int v1332 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1319 + v1330) = v1331 >> *(_DWORD *)(v1587 + 4 * (int)v1326 + v1330);
                    --v1332;
                    v1330 += 4;
                  }
                  while (v1332 > 1);
                }
                v1319 += 4 * (int)v299;
                v1662 += (int)v299;
              }
              while (v1662 < v1643);
            }
          }
          break;
        case 2:
          if (v109 == 2)
          {
            int v1333 = *v104;
            if (*v104)
            {
              unint64_t v1334 = 0;
              uint64_t v1335 = 0;
              uint64_t v1336 = 0;
              uint64_t v1337 = v103[19];
              uint64_t v1338 = v233[19];
              uint64_t v1339 = v102[19];
              char v1340 = (uint64_t *)v103[3];
              uint64_t v1341 = *v1340;
              uint64_t v1342 = v1340[1];
              unint64_t v1343 = (uint64_t *)v233[3];
              uint64_t v1344 = *v1343;
              uint64_t v1345 = v1343[1];
              int v1346 = v104[1];
              int v1347 = v1346;
              do
              {
                if (v1347)
                {
                  unint64_t v1348 = 0;
                  uint64_t v1349 = v1337 + 4 * v1336;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1350 = 0;
                      int v1351 = *(_DWORD *)(v1338 + 4 * v1335);
                      unsigned int v1352 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1339 + v1350) = *(_DWORD *)(v1349 + v1350) >> v1351;
                        --v1352;
                        v1350 += 4;
                      }
                      while (v1352 > 1);
                      int v1346 = v104[1];
                    }
                    v1336 += v1342;
                    v1335 += v1345;
                    v1339 += 4 * (int)v299;
                    ++v1348;
                    v1349 += 4 * v1342;
                  }
                  while (v1348 < v1346);
                  uint64_t v1353 = v1346;
                  int v1333 = *v104;
                  int v1347 = v1346;
                }
                else
                {
                  uint64_t v1353 = 0;
                }
                uint64_t v1336 = v1336 + v1341 - v1353 * v1342;
                uint64_t v1335 = v1335 + v1344 - v1345 * v234[1];
                ++v1334;
              }
              while (v1334 < v1333);
            }
          }
          else if (v109 == 1)
          {
            int v891 = *v104;
            if (*v104)
            {
              unint64_t v892 = 0;
              uint64_t v893 = 0;
              uint64_t v894 = v103[19];
              uint64_t v895 = v233[19];
              uint64_t v896 = v102[19];
              uint64_t v897 = *(void *)v233[3];
              uint64_t v898 = 4 * *(void *)v103[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v899 = 0;
                  int v900 = *(_DWORD *)(v895 + 4 * v893);
                  unsigned int v901 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v896 + v899) = *(_DWORD *)(v894 + v899) >> v900;
                    --v901;
                    v899 += 4;
                  }
                  while (v901 > 1);
                  int v891 = *v104;
                }
                v893 += v897;
                ++v892;
                v896 += 4 * (int)v299;
                v894 += v898;
              }
              while (v892 < v891);
            }
          }
          else
          {
            unint64_t v1644 = v102[6];
            if (v1644)
            {
              unint64_t v1663 = 0;
              uint64_t v1588 = v233[19];
              uint64_t v1602 = v103[19];
              uint64_t v1354 = v102[19];
              do
              {
                uint64_t v1355 = 0;
                if ((v106 & 0x80000000) == 0)
                {
                  uint64_t v1356 = v103[3];
                  uint64_t v1357 = v106;
                  int v1358 = v1663;
                  do
                  {
                    ldiv_t v1359 = ldiv(v1358, v104[v1357]);
                    int v1358 = v1359.quot;
                    v1355 += *(void *)(v1356 + 8 * v1357--) * v1359.rem;
                  }
                  while (v1357 != -1);
                }
                uint64_t v1360 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1361) = 0;
                }
                else
                {
                  uint64_t v1361 = 0;
                  uint64_t v1362 = v233[3];
                  int v1363 = v1663;
                  do
                  {
                    ldiv_t v1364 = ldiv(v1363, v234[v1360]);
                    int v1363 = v1364.quot;
                    v1361 += *(void *)(v1362 + 8 * v1360--) * v1364.rem;
                  }
                  while (v1360 != -1);
                }
                uint64_t v106 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1365 = 0;
                  int v1366 = *(_DWORD *)(v1588 + 4 * (int)v1361);
                  unsigned int v1367 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1354 + v1365) = *(_DWORD *)(v1602 + 4 * (int)v1355 + v1365) >> v1366;
                    --v1367;
                    v1365 += 4;
                  }
                  while (v1367 > 1);
                }
                v1354 += 4 * (int)v299;
                v1663 += (int)v299;
              }
              while (v1663 < v1644);
            }
          }
          break;
        case 3:
          if (v109 == 2)
          {
            int v1095 = *v104;
            if (*v104)
            {
              unint64_t v1096 = 0;
              uint64_t v1097 = 0;
              uint64_t v1098 = 0;
              uint64_t v1099 = v103[19];
              uint64_t v1100 = v233[19];
              uint64_t v1101 = v102[19];
              uint64_t v1102 = (uint64_t *)v103[3];
              uint64_t v1103 = *v1102;
              uint64_t v1104 = v1102[1];
              uint64_t v1105 = (uint64_t *)v233[3];
              uint64_t v1106 = *v1105;
              uint64_t v1107 = v1105[1];
              int v1108 = v104[1];
              int v1109 = v1108;
              do
              {
                if (v1109)
                {
                  unint64_t v1110 = 0;
                  uint64_t v1111 = v1100 + 4 * v1097;
                  uint64_t v1112 = v1099 + 4 * v1098;
                  do
                  {
                    if ((int)v299 >= 1)
                    {
                      uint64_t v1113 = 0;
                      unsigned int v1114 = v299 + 1;
                      do
                      {
                        *(_DWORD *)(v1101 + v1113) = *(_DWORD *)(v1112 + v1113) >> *(_DWORD *)(v1111 + v1113);
                        --v1114;
                        v1113 += 4;
                      }
                      while (v1114 > 1);
                      int v1108 = v104[1];
                    }
                    v1098 += v1104;
                    v1097 += v1107;
                    v1101 += 4 * (int)v299;
                    ++v1110;
                    v1111 += 4 * v1107;
                    v1112 += 4 * v1104;
                  }
                  while (v1110 < v1108);
                  uint64_t v1115 = v1108;
                  int v1095 = *v104;
                  int v1109 = v1108;
                }
                else
                {
                  uint64_t v1115 = 0;
                }
                uint64_t v1098 = v1098 + v1103 - v1115 * v1104;
                uint64_t v1097 = v1097 + v1106 - v1107 * v234[1];
                ++v1096;
              }
              while (v1096 < v1095);
            }
          }
          else if (v109 == 1)
          {
            int v348 = *v104;
            if (*v104)
            {
              unint64_t v349 = 0;
              uint64_t v350 = v103[19];
              uint64_t v351 = v233[19];
              uint64_t v352 = v102[19];
              uint64_t v353 = 4 * *(void *)v233[3];
              uint64_t v354 = 4 * *(void *)v103[3];
              do
              {
                if ((int)v299 >= 1)
                {
                  uint64_t v355 = 0;
                  unsigned int v356 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v352 + v355) = *(_DWORD *)(v350 + v355) >> *(_DWORD *)(v351 + v355);
                    --v356;
                    v355 += 4;
                  }
                  while (v356 > 1);
                  int v348 = *v104;
                }
                ++v349;
                v352 += 4 * (int)v299;
                v351 += v353;
                v350 += v354;
              }
              while (v349 < v348);
            }
          }
          else
          {
            unint64_t v1639 = v102[6];
            if (v1639)
            {
              unint64_t v1658 = 0;
              uint64_t v1582 = v233[19];
              uint64_t v1596 = v103[19];
              uint64_t v1116 = v102[19];
              do
              {
                uint64_t v1117 = 0;
                if ((v106 & 0x80000000) == 0)
                {
                  uint64_t v1118 = v103[3];
                  uint64_t v1119 = v106;
                  int v1120 = v1658;
                  do
                  {
                    ldiv_t v1121 = ldiv(v1120, v104[v1119]);
                    int v1120 = v1121.quot;
                    v1117 += *(void *)(v1118 + 8 * v1119--) * v1121.rem;
                  }
                  while (v1119 != -1);
                }
                uint64_t v1122 = v1671;
                if ((v1671 & 0x80000000) != 0)
                {
                  LODWORD(v1123) = 0;
                }
                else
                {
                  uint64_t v1123 = 0;
                  uint64_t v1124 = v233[3];
                  int v1125 = v1658;
                  do
                  {
                    ldiv_t v1126 = ldiv(v1125, v234[v1122]);
                    int v1125 = v1126.quot;
                    v1123 += *(void *)(v1124 + 8 * v1122--) * v1126.rem;
                  }
                  while (v1122 != -1);
                }
                uint64_t v106 = v1686;
                if ((int)v299 >= 1)
                {
                  uint64_t v1127 = 0;
                  unsigned int v1128 = v299 + 1;
                  do
                  {
                    *(_DWORD *)(v1116 + v1127) = *(_DWORD *)(v1596 + 4 * (int)v1117 + v1127) >> *(_DWORD *)(v1582 + 4 * (int)v1123 + v1127);
                    --v1128;
                    v1127 += 4;
                  }
                  while (v1128 > 1);
                }
                v1116 += 4 * (int)v299;
                v1658 += (int)v299;
              }
              while (v1658 < v1639);
            }
          }
          break;
        default:
LABEL_310:
          switch(v295)
          {
            case 1uLL:
              uint64_t v300 = v102[6];
              if (v300)
              {
                v301 = (_DWORD *)v103[19];
                uint64_t v302 = (_DWORD *)v233[19];
                unint64_t v303 = (_DWORD *)v102[19];
                uint64_t v304 = 4 * *(void *)v233[3];
                uint64_t v305 = 4 * *(void *)v103[3];
                do
                {
                  *v303++ = *v301 >> *v302;
                  uint64_t v302 = (_DWORD *)((char *)v302 + v304);
                  v301 = (_DWORD *)((char *)v301 + v305);
                  --v300;
                }
                while (v300);
              }
              break;
            case 2uLL:
              int v562 = *v104;
              if (*v104)
              {
                unint64_t v563 = 0;
                uint64_t v564 = 0;
                uint64_t v565 = 0;
                uint64_t v566 = 0;
                uint64_t v567 = v103[19];
                uint64_t v568 = v233[19];
                uint64_t v569 = v102[19];
                uint64_t v570 = (uint64_t *)v103[3];
                uint64_t v571 = *v570;
                uint64_t v572 = v570[1];
                uint64_t v573 = (uint64_t *)v233[3];
                uint64_t v575 = *v573;
                uint64_t v574 = v573[1];
                int v576 = v104[1];
                do
                {
                  if (v576)
                  {
                    for (unint64_t j = 0; j < v576; ++j)
                    {
                      *(_DWORD *)(v569 + 4 * v564 + 4 * j) = *(_DWORD *)(v567 + 4 * v566) >> *(_DWORD *)(v568 + 4 * v565);
                      v566 += v572;
                      v565 += v574;
                      int v576 = v104[1];
                    }
                    uint64_t v578 = v576;
                    int v562 = *v104;
                    v564 += j;
                  }
                  else
                  {
                    uint64_t v578 = 0;
                  }
                  uint64_t v566 = v566 + v571 - v578 * v572;
                  uint64_t v565 = v565 + v575 - v574 * v234[1];
                  ++v563;
                }
                while (v563 < v562);
              }
              break;
            case 3uLL:
              int v579 = *v104;
              if (*v104)
              {
                unint64_t v580 = 0;
                uint64_t v581 = 0;
                uint64_t v582 = 0;
                uint64_t v583 = 0;
                uint64_t v584 = v103[19];
                uint64_t v585 = v233[19];
                uint64_t v586 = v102[19];
                unint64_t v587 = (uint64_t *)v103[3];
                uint64_t v588 = *v587;
                uint64_t v589 = v587[1];
                int v590 = (uint64_t *)v233[3];
                uint64_t v591 = *v590;
                uint64_t v592 = v590[1];
                int v593 = v104[1];
                int v594 = v593;
                do
                {
                  if (v594)
                  {
                    unint64_t v595 = 0;
                    uint64_t v596 = v587[2];
                    uint64_t v597 = v590[2];
                    int v598 = v104[2];
                    do
                    {
                      if (v598)
                      {
                        for (unint64_t k = 0; k < v598; ++k)
                        {
                          *(_DWORD *)(v586 + 4 * v581 + 4 * k) = *(_DWORD *)(v584 + 4 * v583) >> *(_DWORD *)(v585 + 4 * v582);
                          v583 += v596;
                          v582 += v597;
                          int v598 = v104[2];
                        }
                        uint64_t v600 = v598;
                        int v593 = v104[1];
                        v581 += k;
                      }
                      else
                      {
                        uint64_t v600 = 0;
                      }
                      uint64_t v583 = v583 + v589 - v600 * v596;
                      uint64_t v582 = v582 + v592 - v597 * v234[2];
                      ++v595;
                    }
                    while (v595 < v593);
                    uint64_t v601 = v593;
                    int v579 = *v104;
                    int v594 = v593;
                  }
                  else
                  {
                    uint64_t v601 = 0;
                  }
                  uint64_t v583 = v583 + v588 - v601 * v589;
                  uint64_t v582 = v582 + v591 - v592 * v234[1];
                  ++v580;
                }
                while (v580 < v579);
              }
              break;
            case 4uLL:
              int v602 = *v104;
              if (*v104)
              {
                unint64_t v603 = 0;
                uint64_t v604 = 0;
                uint64_t v605 = 0;
                uint64_t v606 = 0;
                uint64_t v607 = v103[19];
                uint64_t v608 = v233[19];
                uint64_t v609 = v102[19];
                ldiv_t v610 = (uint64_t *)v103[3];
                uint64_t v611 = *v610;
                uint64_t v612 = v610[1];
                uint64_t v613 = (uint64_t *)v233[3];
                uint64_t v614 = *v613;
                uint64_t v615 = v613[1];
                int v616 = v104[1];
                int v617 = v616;
                do
                {
                  if (v617)
                  {
                    unint64_t v618 = 0;
                    uint64_t v619 = v610[2];
                    uint64_t v620 = v613[2];
                    int v621 = v104[2];
                    int v622 = v621;
                    do
                    {
                      if (v622)
                      {
                        unint64_t v623 = 0;
                        uint64_t v624 = v610[3];
                        uint64_t v625 = v613[3];
                        int v626 = v104[3];
                        do
                        {
                          if (v626)
                          {
                            for (unint64_t m = 0; m < v626; ++m)
                            {
                              *(_DWORD *)(v609 + 4 * v604 + 4 * m) = *(_DWORD *)(v607 + 4 * v606) >> *(_DWORD *)(v608 + 4 * v605);
                              v606 += v624;
                              v605 += v625;
                              int v626 = v104[3];
                            }
                            uint64_t v628 = v626;
                            int v621 = v104[2];
                            v604 += m;
                          }
                          else
                          {
                            uint64_t v628 = 0;
                          }
                          uint64_t v606 = v606 + v619 - v628 * v624;
                          uint64_t v605 = v605 + v620 - v625 * v234[3];
                          ++v623;
                        }
                        while (v623 < v621);
                        uint64_t v629 = v621;
                        int v616 = v104[1];
                        int v622 = v621;
                      }
                      else
                      {
                        uint64_t v629 = 0;
                      }
                      uint64_t v606 = v606 + v612 - v629 * v619;
                      uint64_t v605 = v605 + v615 - v620 * v234[2];
                      ++v618;
                    }
                    while (v618 < v616);
                    uint64_t v630 = v616;
                    int v602 = *v104;
                    int v617 = v616;
                  }
                  else
                  {
                    uint64_t v630 = 0;
                  }
                  uint64_t v606 = v606 + v611 - v630 * v612;
                  uint64_t v605 = v605 + v614 - v615 * v234[1];
                  ++v603;
                }
                while (v603 < v602);
              }
              break;
            default:
              uint64_t v550 = v102[6];
              if (v550)
              {
                uint64_t v551 = 0;
                uint64_t v1632 = v233[19];
                uint64_t v1654 = v103[19];
                uint64_t v1618 = v102[19];
                do
                {
                  uint64_t v552 = 0;
                  if ((v106 & 0x80000000) == 0)
                  {
                    uint64_t v553 = v103[3];
                    uint64_t v554 = v106;
                    int v555 = v551;
                    do
                    {
                      ldiv_t v556 = ldiv(v555, v104[v554]);
                      int v555 = v556.quot;
                      v552 += *(void *)(v553 + 8 * v554--) * v556.rem;
                    }
                    while (v554 != -1);
                  }
                  uint64_t v557 = v1671;
                  if ((v1671 & 0x80000000) != 0)
                  {
                    LODWORD(v558) = 0;
                  }
                  else
                  {
                    uint64_t v558 = 0;
                    uint64_t v559 = v233[3];
                    int v560 = v551;
                    do
                    {
                      ldiv_t v561 = ldiv(v560, v234[v557]);
                      int v560 = v561.quot;
                      v558 += *(void *)(v559 + 8 * v557--) * v561.rem;
                    }
                    while (v557 != -1);
                  }
                  *(_DWORD *)(v1618 + 4 * v551++) = *(_DWORD *)(v1654 + 4 * (int)v552) >> *(_DWORD *)(v1632 + 4 * (int)v558);
                  uint64_t v106 = v1686;
                }
                while (v551 != v550);
              }
              break;
          }
          break;
      }
      return;
    case 3:
      int v10 = *(uint64_t **)a1;
      int v11 = *(uint64_t **)(a1 + 8);
      switch(v12)
      {
        case 0:
          int v13 = **(char **)(*v10 + 152) >> **(unsigned char **)(*v11 + 152);
          uint64_t v14 = *(void *)v1;
LABEL_33:
          **(unsigned char **)(v14 + 152) = v13;
          return;
        case 1:
          int v139 = *(_DWORD *)(*v11 + 160);
          if (v139 >= 1)
          {
            int v140 = *(unsigned char **)(*(void *)v1 + 152);
            uint64_t v141 = *(char **)(*v11 + 152);
            int v142 = **(char **)(*v10 + 152);
            unsigned int v143 = v139 + 1;
            do
            {
              char v144 = *v141++;
              *v140++ = v142 >> v144;
              --v143;
            }
            while (v143 > 1);
          }
          return;
        case 2:
          int v145 = *(_DWORD *)(*v10 + 160);
          if (v145 >= 1)
          {
            char v146 = *(unsigned char **)(*(void *)v1 + 152);
            int v147 = *(char **)(*v10 + 152);
            char v148 = **(unsigned char **)(*v11 + 152);
            unsigned int v149 = v145 + 1;
            do
            {
              int v150 = *v147++;
              *v146++ = v150 >> v148;
              --v149;
            }
            while (v149 > 1);
          }
          return;
        case 3:
          int v151 = *(_DWORD *)(*(void *)v1 + 48);
          if (v151 >= 1)
          {
            uint64_t v152 = *(unsigned char **)(*(void *)v1 + 152);
            int v153 = *(unsigned char **)(*v11 + 152);
            int v154 = *(char **)(*v10 + 152);
            unsigned int v155 = v151 + 1;
            do
            {
              int v157 = *v154++;
              int v156 = v157;
              LOBYTE(v157) = *v153++;
              *v152++ = v156 >> v157;
              --v155;
            }
            while (v155 > 1);
          }
          return;
        default:
          int v131 = *(void **)v1;
          uint64_t v132 = *v10;
          char v133 = *(int **)*v10;
          uint64_t v134 = (*(void *)(*v10 + 8) - (void)v133) >> 2;
          int v135 = v134 - 1;
          if ((int)v134 - 1 >= -1) {
            int v135 = -1;
          }
          int v136 = v135 + 1;
          int v137 = v134 + 1;
          break;
      }
      while (1)
      {
        unsigned int v138 = v137 - 2;
        if (v137 - 2 < 0) {
          break;
        }
        --v137;
        if (*(void *)(*(void *)(v132 + 24) + 8 * v138) != *(void *)(v131[3] + 8 * v138)) {
          goto LABEL_197;
        }
      }
      int v137 = v136;
LABEL_197:
      int v241 = (int **)*v11;
      int v242 = *(int **)*v11;
      uint64_t v243 = (*(void *)(*v11 + 8) - (void)v242) >> 2;
      int v244 = v243 - 1;
      if ((int)v243 - 1 >= -1) {
        int v244 = -1;
      }
      int v245 = v244 + 1;
      int v246 = v243 + 1;
      while (1)
      {
        unsigned int v247 = v246 - 2;
        if (v246 - 2 < 0) {
          break;
        }
        --v246;
        if (*(void *)&v241[3][2 * v247] != *(void *)(v131[3] + 8 * v247)) {
          goto LABEL_230;
        }
      }
      int v246 = v245;
LABEL_230:
      int v268 = v134 + 1;
      while (1)
      {
        unsigned int v269 = v268 - 2;
        if (v268 - 2 < 0) {
          break;
        }
        --v268;
        if (*(void *)(*(void *)(v132 + 24) + 8 * v269)) {
          goto LABEL_255;
        }
      }
      int v268 = v136;
LABEL_255:
      int v278 = v243 + 1;
      while (1)
      {
        int v279 = v278 - 2;
        if (v278 - 2 < 0) {
          break;
        }
        --v278;
        if (*(void *)&v241[3][2 * v279]) {
          goto LABEL_316;
        }
      }
      int v278 = v245;
LABEL_316:
      unint64_t v306 = (uint64_t)(v131[1] - *v131) >> 2;
      if (v137 <= v246) {
        int v307 = v246;
      }
      else {
        int v307 = v137;
      }
      if (v137 <= v278) {
        int v137 = v278;
      }
      if (v268 > v246) {
        int v246 = v268;
      }
      if (v306 > v246)
      {
        int v308 = 1;
      }
      else
      {
        int v246 = (uint64_t)(v131[1] - *v131) >> 2;
        int v308 = 4;
      }
      if (v306 > v137)
      {
        int v309 = 2;
      }
      else
      {
        int v137 = v246;
        int v309 = v308;
      }
      if (v306 > v307)
      {
        int v137 = v307;
        int v309 = 3;
      }
      if (!v137) {
        goto LABEL_333;
      }
      unint64_t v310 = *(void *)(v131[3] + 8 * (v137 - 1));
      if (v310 < 0x10) {
        goto LABEL_333;
      }
      uint64_t v1689 = *(void *)(v131[3] + 8 * (v137 - 1));
      switch(v309)
      {
        case 1:
          if (v137 == 2)
          {
            int v1368 = *v133;
            if (*v133)
            {
              unint64_t v1369 = 0;
              uint64_t v1370 = 0;
              uint64_t v1371 = 0;
              uint64_t v1372 = *(void *)(v132 + 152);
              ldiv_t v1373 = v241[19];
              uint64_t v1374 = v131[19];
              do
              {
                if (v133[1])
                {
                  unint64_t v1375 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1376 = 0;
                      int v1377 = *(char *)(v1372 + v1371);
                      unsigned int v1378 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1374 + v1376) = v1377 >> *((unsigned char *)v1373 + v1370 + v1376);
                        --v1378;
                        ++v1376;
                      }
                      while (v1378 > 1);
                      uint64_t v132 = *v10;
                      int v241 = (int **)*v11;
                      char v133 = *(int **)*v10;
                    }
                    uint64_t v1379 = *(void **)(v132 + 24);
                    uint64_t v1380 = v1379[1];
                    v1371 += v1380;
                    v1370 += *((void *)v241[3] + 1);
                    v1374 += (int)v310;
                    ++v1375;
                    unint64_t v1381 = v133[1];
                  }
                  while (v1375 < v1381);
                  int v1368 = *v133;
                  int v242 = *v241;
                }
                else
                {
                  unint64_t v1381 = 0;
                  uint64_t v1379 = *(void **)(v132 + 24);
                  uint64_t v1380 = v1379[1];
                }
                uint64_t v1371 = *v1379 + v1371 - v1381 * v1380;
                uint64_t v1370 = *(void *)v241[3] + v1370 - *((void *)v241[3] + 1) * v242[1];
                ++v1369;
              }
              while (v1369 < v1368);
            }
          }
          else if (v137 == 1)
          {
            int v902 = *v133;
            if (*v133)
            {
              unint64_t v903 = 0;
              uint64_t v904 = 0;
              uint64_t v905 = 0;
              uint64_t v906 = *(void *)(v132 + 152);
              unsigned int v907 = v241[19];
              uint64_t v908 = v131[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v909 = 0;
                  int v910 = *(char *)(v906 + v905);
                  unsigned int v911 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v908 + v909) = v910 >> *((unsigned char *)v907 + v904 + v909);
                    --v911;
                    ++v909;
                  }
                  while (v911 > 1);
                  uint64_t v132 = *v10;
                  int v241 = (int **)*v11;
                  int v902 = **(_DWORD **)*v10;
                }
                v905 += **(void **)(v132 + 24);
                v904 += *(void *)v241[3];
                v908 += (int)v310;
                ++v903;
              }
              while (v903 < v902);
            }
          }
          else if (v131[6])
          {
            uint64_t v1629 = v241[19];
            uint64_t v1645 = *(void *)(v132 + 152);
            uint64_t v1664 = (int)v310;
            unint64_t v1682 = 0;
            unsigned int v1614 = v310 + 1;
            uint64_t v1382 = v131[19];
            do
            {
              uint64_t v1383 = *(void *)*v10;
              unint64_t v1384 = (unint64_t)(*(void *)(*v10 + 8) - v1383) >> 2;
              uint64_t v1385 = 0;
              uint64_t v1386 = (v1384 - 1);
              if ((int)v1384 - 1 >= 0)
              {
                uint64_t v1387 = *(void *)(*v10 + 24);
                int v1388 = v1682;
                do
                {
                  ldiv_t v1389 = ldiv(v1388, *(int *)(v1383 + 4 * v1386));
                  int v1388 = v1389.quot;
                  v1385 += *(void *)(v1387 + 8 * v1386--) * v1389.rem;
                }
                while (v1386 != -1);
              }
              uint64_t v1390 = *(void *)*v11;
              unint64_t v1391 = (unint64_t)(*(void *)(*v11 + 8) - v1390) >> 2;
              uint64_t v1392 = 0;
              uint64_t v1393 = (v1391 - 1);
              if ((int)v1391 - 1 >= 0)
              {
                uint64_t v1394 = *(void *)(*v11 + 24);
                int v1395 = v1682;
                do
                {
                  ldiv_t v1396 = ldiv(v1395, *(int *)(v1390 + 4 * v1393));
                  int v1395 = v1396.quot;
                  v1392 += *(void *)(v1394 + 8 * v1393--) * v1396.rem;
                }
                while (v1393 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1397 = 0;
                int v1398 = *(char *)(v1645 + (int)v1385);
                unsigned int v1399 = v1614;
                do
                {
                  *(unsigned char *)(v1382 + v1397) = v1398 >> *((unsigned char *)v1629 + (int)v1392 + v1397);
                  --v1399;
                  ++v1397;
                }
                while (v1399 > 1);
                int v131 = *(void **)v1;
              }
              v1382 += v1664;
              v1682 += v1664;
            }
            while (v1682 < v131[6]);
          }
          break;
        case 2:
          if (v137 == 2)
          {
            int v1400 = *v133;
            if (*v133)
            {
              unint64_t v1401 = 0;
              uint64_t v1402 = 0;
              uint64_t v1403 = 0;
              uint64_t v1404 = *(void *)(v132 + 152);
              uint64_t v1405 = v241[19];
              uint64_t v1406 = v131[19];
              do
              {
                if (v133[1])
                {
                  unint64_t v1407 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1408 = 0;
                      char v1409 = *((unsigned char *)v1405 + v1402);
                      unsigned int v1410 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1406 + v1408) = *(char *)(v1404 + v1403 + v1408) >> v1409;
                        --v1410;
                        ++v1408;
                      }
                      while (v1410 > 1);
                      uint64_t v132 = *v10;
                      int v241 = (int **)*v11;
                      char v133 = *(int **)*v10;
                    }
                    unsigned int v1411 = *(void **)(v132 + 24);
                    uint64_t v1412 = v1411[1];
                    v1403 += v1412;
                    v1402 += *((void *)v241[3] + 1);
                    v1406 += (int)v310;
                    ++v1407;
                    unint64_t v1413 = v133[1];
                  }
                  while (v1407 < v1413);
                  int v1400 = *v133;
                  int v242 = *v241;
                }
                else
                {
                  unint64_t v1413 = 0;
                  unsigned int v1411 = *(void **)(v132 + 24);
                  uint64_t v1412 = v1411[1];
                }
                uint64_t v1403 = *v1411 + v1403 - v1413 * v1412;
                uint64_t v1402 = *(void *)v241[3] + v1402 - *((void *)v241[3] + 1) * v242[1];
                ++v1401;
              }
              while (v1401 < v1400);
            }
          }
          else if (v137 == 1)
          {
            int v912 = *v133;
            if (*v133)
            {
              unint64_t v913 = 0;
              uint64_t v914 = 0;
              uint64_t v915 = 0;
              uint64_t v916 = *(void *)(v132 + 152);
              uint64_t v917 = v241[19];
              uint64_t v918 = v131[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v919 = 0;
                  char v920 = *((unsigned char *)v917 + v914);
                  unsigned int v921 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v918 + v919) = *(char *)(v916 + v915 + v919) >> v920;
                    --v921;
                    ++v919;
                  }
                  while (v921 > 1);
                  uint64_t v132 = *v10;
                  int v241 = (int **)*v11;
                  int v912 = **(_DWORD **)*v10;
                }
                v915 += **(void **)(v132 + 24);
                v914 += *(void *)v241[3];
                v918 += (int)v310;
                ++v913;
              }
              while (v913 < v912);
            }
          }
          else if (v131[6])
          {
            uint64_t v1630 = v241[19];
            uint64_t v1646 = *(void *)(v132 + 152);
            uint64_t v1665 = (int)v310;
            unint64_t v1683 = 0;
            unsigned int v1615 = v310 + 1;
            uint64_t v1414 = v131[19];
            do
            {
              uint64_t v1415 = *(void *)*v10;
              unint64_t v1416 = (unint64_t)(*(void *)(*v10 + 8) - v1415) >> 2;
              uint64_t v1417 = 0;
              uint64_t v1418 = (v1416 - 1);
              if ((int)v1416 - 1 >= 0)
              {
                uint64_t v1419 = *(void *)(*v10 + 24);
                int v1420 = v1683;
                do
                {
                  ldiv_t v1421 = ldiv(v1420, *(int *)(v1415 + 4 * v1418));
                  int v1420 = v1421.quot;
                  v1417 += *(void *)(v1419 + 8 * v1418--) * v1421.rem;
                }
                while (v1418 != -1);
              }
              uint64_t v1422 = *(void *)*v11;
              unint64_t v1423 = (unint64_t)(*(void *)(*v11 + 8) - v1422) >> 2;
              uint64_t v1424 = 0;
              uint64_t v1425 = (v1423 - 1);
              if ((int)v1423 - 1 >= 0)
              {
                uint64_t v1426 = *(void *)(*v11 + 24);
                int v1427 = v1683;
                do
                {
                  ldiv_t v1428 = ldiv(v1427, *(int *)(v1422 + 4 * v1425));
                  int v1427 = v1428.quot;
                  v1424 += *(void *)(v1426 + 8 * v1425--) * v1428.rem;
                }
                while (v1425 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1429 = 0;
                char v1430 = *((unsigned char *)v1630 + (int)v1424);
                unsigned int v1431 = v1615;
                do
                {
                  *(unsigned char *)(v1414 + v1429) = *(char *)(v1646 + (int)v1417 + v1429) >> v1430;
                  --v1431;
                  ++v1429;
                }
                while (v1431 > 1);
                int v131 = *(void **)v1;
              }
              v1414 += v1665;
              v1683 += v1665;
            }
            while (v1683 < v131[6]);
          }
          break;
        case 3:
          if (v137 == 2)
          {
            int v1129 = *v133;
            if (*v133)
            {
              unint64_t v1130 = 0;
              uint64_t v1131 = 0;
              uint64_t v1132 = 0;
              uint64_t v1133 = *(void *)(v132 + 152);
              uint64_t v1134 = v241[19];
              uint64_t v1135 = v131[19];
              do
              {
                if (v133[1])
                {
                  unint64_t v1136 = 0;
                  do
                  {
                    if ((int)v310 >= 1)
                    {
                      uint64_t v1137 = 0;
                      unsigned int v1138 = v310 + 1;
                      do
                      {
                        *(unsigned char *)(v1135 + v1137) = *(char *)(v1133 + v1132 + v1137) >> *((unsigned char *)v1134 + v1131 + v1137);
                        --v1138;
                        ++v1137;
                      }
                      while (v1138 > 1);
                      uint64_t v132 = *v10;
                      int v241 = (int **)*v11;
                      char v133 = *(int **)*v10;
                    }
                    uint64_t v1139 = *(void **)(v132 + 24);
                    uint64_t v1140 = v1139[1];
                    v1132 += v1140;
                    v1131 += *((void *)v241[3] + 1);
                    v1135 += (int)v310;
                    ++v1136;
                    unint64_t v1141 = v133[1];
                  }
                  while (v1136 < v1141);
                  int v1129 = *v133;
                  int v242 = *v241;
                }
                else
                {
                  unint64_t v1141 = 0;
                  uint64_t v1139 = *(void **)(v132 + 24);
                  uint64_t v1140 = v1139[1];
                }
                uint64_t v1132 = *v1139 + v1132 - v1141 * v1140;
                uint64_t v1131 = *(void *)v241[3] + v1131 - *((void *)v241[3] + 1) * v242[1];
                ++v1130;
              }
              while (v1130 < v1129);
            }
          }
          else if (v137 == 1)
          {
            int v357 = *v133;
            if (*v133)
            {
              unint64_t v358 = 0;
              uint64_t v359 = 0;
              uint64_t v360 = 0;
              uint64_t v361 = *(void *)(v132 + 152);
              uint64_t v362 = v241[19];
              uint64_t v363 = v131[19];
              do
              {
                if ((int)v310 >= 1)
                {
                  uint64_t v364 = 0;
                  unsigned int v365 = v310 + 1;
                  do
                  {
                    *(unsigned char *)(v363 + v364) = *(char *)(v361 + v360 + v364) >> *((unsigned char *)v362 + v359 + v364);
                    --v365;
                    ++v364;
                  }
                  while (v365 > 1);
                  uint64_t v132 = *v10;
                  int v241 = (int **)*v11;
                  int v357 = **(_DWORD **)*v10;
                }
                v360 += **(void **)(v132 + 24);
                v359 += *(void *)v241[3];
                v363 += (int)v310;
                ++v358;
              }
              while (v358 < v357);
            }
          }
          else if (v131[6])
          {
            uint64_t v1626 = v241[19];
            uint64_t v1640 = *(void *)(v132 + 152);
            uint64_t v1659 = (int)v310;
            unint64_t v1681 = 0;
            unsigned int v1611 = v310 + 1;
            uint64_t v1142 = v131[19];
            do
            {
              uint64_t v1143 = *(void *)*v10;
              unint64_t v1144 = (unint64_t)(*(void *)(*v10 + 8) - v1143) >> 2;
              uint64_t v1145 = 0;
              uint64_t v1146 = (v1144 - 1);
              if ((int)v1144 - 1 >= 0)
              {
                uint64_t v1147 = *(void *)(*v10 + 24);
                int v1148 = v1681;
                do
                {
                  ldiv_t v1149 = ldiv(v1148, *(int *)(v1143 + 4 * v1146));
                  int v1148 = v1149.quot;
                  v1145 += *(void *)(v1147 + 8 * v1146--) * v1149.rem;
                }
                while (v1146 != -1);
              }
              uint64_t v1150 = *(void *)*v11;
              unint64_t v1151 = (unint64_t)(*(void *)(*v11 + 8) - v1150) >> 2;
              uint64_t v1152 = 0;
              uint64_t v1153 = (v1151 - 1);
              if ((int)v1151 - 1 >= 0)
              {
                uint64_t v1154 = *(void *)(*v11 + 24);
                int v1155 = v1681;
                do
                {
                  ldiv_t v1156 = ldiv(v1155, *(int *)(v1150 + 4 * v1153));
                  int v1155 = v1156.quot;
                  v1152 += *(void *)(v1154 + 8 * v1153--) * v1156.rem;
                }
                while (v1153 != -1);
              }
              if ((int)v1689 >= 1)
              {
                uint64_t v1157 = 0;
                unsigned int v1158 = v1611;
                do
                {
                  *(unsigned char *)(v1142 + v1157) = *(char *)(v1640 + (int)v1145 + v1157) >> *((unsigned char *)v1626
                                                                                       + (int)v1152
                                                                                       + v1157);
                  --v1158;
                  ++v1157;
                }
                while (v1158 > 1);
                int v131 = *(void **)v1;
              }
              v1142 += v1659;
              v1681 += v1659;
            }
            while (v1681 < v131[6]);
          }
          break;
        default:
LABEL_333:
          switch(v306)
          {
            case 1uLL:
              if (v131[6])
              {
                unint64_t v311 = 0;
                uint64_t v312 = 0;
                uint64_t v313 = 0;
                uint64_t v314 = *(void *)(v132 + 152);
                int v315 = v241[19];
                uint64_t v316 = v131[19];
                do
                {
                  *(unsigned char *)(v316 + v311) = *(char *)(v314 + v313) >> *((unsigned char *)v315 + v312);
                  v313 += **(void **)(*v10 + 24);
                  v312 += **(void **)(*v11 + 24);
                  ++v311;
                }
                while (v311 < *(void *)(*(void *)v1 + 48));
              }
              break;
            case 2uLL:
              int v647 = *v133;
              if (*v133)
              {
                unint64_t v648 = 0;
                uint64_t v649 = 0;
                uint64_t v650 = 0;
                uint64_t v651 = 0;
                uint64_t v652 = *(void *)(v132 + 152);
                unint64_t v653 = v241[19];
                uint64_t v654 = v131[19];
                do
                {
                  if (v133[1])
                  {
                    unint64_t v655 = 0;
                    do
                    {
                      *(unsigned char *)(v654 + v649 + v655) = *(char *)(v652 + v651) >> *((unsigned char *)v653 + v650);
                      uint64_t v132 = *v10;
                      uint64_t v656 = *(void **)(*v10 + 24);
                      uint64_t v657 = v656[1];
                      v651 += v657;
                      int v241 = (int **)*v11;
                      uint64_t v658 = *(int **)(*v11 + 24);
                      uint64_t v659 = *((void *)v658 + 1);
                      v650 += v659;
                      ++v655;
                      char v133 = *(int **)*v10;
                      unint64_t v660 = v133[1];
                    }
                    while (v655 < v660);
                    int v647 = *v133;
                    int v242 = *v241;
                    v649 += v655;
                  }
                  else
                  {
                    unint64_t v660 = 0;
                    uint64_t v656 = *(void **)(v132 + 24);
                    uint64_t v657 = v656[1];
                    uint64_t v658 = v241[3];
                    uint64_t v659 = *((void *)v658 + 1);
                  }
                  uint64_t v651 = *v656 + v651 - v660 * v657;
                  uint64_t v650 = *(void *)v658 + v650 - v659 * v242[1];
                  ++v648;
                }
                while (v648 < v647);
              }
              break;
            case 3uLL:
              int v661 = *v133;
              if (*v133)
              {
                unint64_t v662 = 0;
                uint64_t v663 = 0;
                uint64_t v664 = 0;
                uint64_t v665 = 0;
                uint64_t v666 = *(void *)(v132 + 152);
                ldiv_t v667 = v241[19];
                uint64_t v668 = v131[19];
                do
                {
                  if (v133[1])
                  {
                    unint64_t v669 = 0;
                    do
                    {
                      if (v133[2])
                      {
                        unint64_t v670 = 0;
                        do
                        {
                          *(unsigned char *)(v668 + v663 + v670) = *(char *)(v666 + v665) >> *((unsigned char *)v667 + v664);
                          uint64_t v132 = *v10;
                          int v671 = *(void **)(*v10 + 24);
                          uint64_t v672 = v671[2];
                          v665 += v672;
                          int v241 = (int **)*v11;
                          int v673 = *(int **)(*v11 + 24);
                          uint64_t v674 = *((void *)v673 + 2);
                          v664 += v674;
                          ++v670;
                          char v133 = *(int **)*v10;
                          unint64_t v675 = v133[2];
                        }
                        while (v670 < v675);
                        int v242 = *v241;
                        v663 += v670;
                      }
                      else
                      {
                        unint64_t v675 = 0;
                        int v671 = *(void **)(v132 + 24);
                        uint64_t v672 = v671[2];
                        int v673 = v241[3];
                        uint64_t v674 = *((void *)v673 + 2);
                      }
                      uint64_t v676 = v671[1];
                      uint64_t v665 = v676 + v665 - v675 * v672;
                      uint64_t v664 = *((void *)v673 + 1) + v664 - v674 * v242[2];
                      ++v669;
                      unint64_t v677 = v133[1];
                    }
                    while (v669 < v677);
                    int v661 = *v133;
                  }
                  else
                  {
                    unint64_t v677 = 0;
                    int v671 = *(void **)(v132 + 24);
                    uint64_t v676 = v671[1];
                  }
                  uint64_t v665 = *v671 + v665 - v677 * v676;
                  uint64_t v664 = *(void *)v241[3] + v664 - *((void *)v241[3] + 1) * v242[1];
                  ++v662;
                }
                while (v662 < v661);
              }
              break;
            case 4uLL:
              int v678 = *v133;
              if (*v133)
              {
                unint64_t v679 = 0;
                uint64_t v680 = 0;
                uint64_t v681 = 0;
                uint64_t v682 = 0;
                uint64_t v683 = *(void *)(v132 + 152);
                unint64_t v684 = v241[19];
                uint64_t v685 = v131[19];
                do
                {
                  if (v133[1])
                  {
                    unint64_t v686 = 0;
                    do
                    {
                      if (v133[2])
                      {
                        unint64_t v687 = 0;
                        do
                        {
                          if (v133[3])
                          {
                            unint64_t v688 = 0;
                            do
                            {
                              *(unsigned char *)(v685 + v680 + v688) = *(char *)(v683 + v682) >> *((unsigned char *)v684 + v681);
                              uint64_t v132 = *v10;
                              uint64_t v689 = *(void **)(*v10 + 24);
                              uint64_t v690 = v689[3];
                              v682 += v690;
                              int v241 = (int **)*v11;
                              unint64_t v691 = *(int **)(*v11 + 24);
                              uint64_t v692 = *((void *)v691 + 3);
                              v681 += v692;
                              ++v688;
                              char v133 = *(int **)*v10;
                              unint64_t v693 = v133[3];
                            }
                            while (v688 < v693);
                            int v242 = *v241;
                            v680 += v688;
                          }
                          else
                          {
                            unint64_t v693 = 0;
                            uint64_t v689 = *(void **)(v132 + 24);
                            uint64_t v690 = v689[3];
                            unint64_t v691 = v241[3];
                            uint64_t v692 = *((void *)v691 + 3);
                          }
                          uint64_t v694 = v689[2];
                          uint64_t v682 = v694 + v682 - v693 * v690;
                          uint64_t v681 = *((void *)v691 + 2) + v681 - v692 * v242[3];
                          ++v687;
                          unint64_t v695 = v133[2];
                        }
                        while (v687 < v695);
                      }
                      else
                      {
                        unint64_t v695 = 0;
                        uint64_t v689 = *(void **)(v132 + 24);
                        uint64_t v694 = v689[2];
                      }
                      uint64_t v682 = v689[1] + v682 - v695 * v694;
                      uint64_t v681 = *((void *)v241[3] + 1) + v681 - *((void *)v241[3] + 2) * v242[2];
                      ++v686;
                      unint64_t v696 = v133[1];
                    }
                    while (v686 < v696);
                    int v678 = *v133;
                  }
                  else
                  {
                    unint64_t v696 = 0;
                  }
                  uint64_t v682 = **(void **)(v132 + 24) + v682 - *(void *)(*(void *)(v132 + 24) + 8) * v696;
                  uint64_t v681 = *(void *)v241[3] + v681 - *((void *)v241[3] + 1) * v242[1];
                  ++v679;
                }
                while (v679 < v678);
              }
              break;
            default:
              if (v131[6])
              {
                unint64_t v631 = 0;
                unint64_t v1676 = v241[19];
                uint64_t v1691 = *(void *)(v132 + 152);
                uint64_t v632 = v131[19];
                do
                {
                  uint64_t v633 = *(void *)*v10;
                  unint64_t v634 = (unint64_t)(*(void *)(*v10 + 8) - v633) >> 2;
                  uint64_t v635 = 0;
                  uint64_t v636 = (v634 - 1);
                  if ((int)v634 - 1 >= 0)
                  {
                    uint64_t v637 = *(void *)(*v10 + 24);
                    int v638 = v631;
                    do
                    {
                      ldiv_t v639 = ldiv(v638, *(int *)(v633 + 4 * v636));
                      int v638 = v639.quot;
                      v635 += *(void *)(v637 + 8 * v636--) * v639.rem;
                    }
                    while (v636 != -1);
                  }
                  uint64_t v640 = *(void *)*v11;
                  unint64_t v641 = (unint64_t)(*(void *)(*v11 + 8) - v640) >> 2;
                  uint64_t v642 = 0;
                  uint64_t v643 = (v641 - 1);
                  if ((int)v641 - 1 >= 0)
                  {
                    uint64_t v644 = *(void *)(*v11 + 24);
                    int v645 = v631;
                    do
                    {
                      ldiv_t v646 = ldiv(v645, *(int *)(v640 + 4 * v643));
                      int v645 = v646.quot;
                      v642 += *(void *)(v644 + 8 * v643--) * v646.rem;
                    }
                    while (v643 != -1);
                  }
                  *(unsigned char *)(v632 + v631++) = *(char *)(v1691 + (int)v635) >> *((unsigned char *)v1676 + (int)v642);
                }
                while (v631 < *(void *)(*(void *)v1 + 48));
              }
              break;
          }
          break;
      }
      return;
    case 4:
      int v16 = *(uint64_t **)a1;
      unsigned int v15 = *(uint64_t **)(a1 + 8);
      switch(v17)
      {
        case 0:
          int v9 = **(int **)(*v16 + 152) >> **(_DWORD **)(*v15 + 152);
LABEL_10:
          **(_DWORD **)(*(void *)v1 + 152) = v9;
          return;
        case 1:
          int v167 = *(_DWORD *)(*v15 + 160);
          if (v167 >= 1)
          {
            int v168 = **(_DWORD **)(*v16 + 152);
            int v169 = *(int **)(*(void *)v1 + 152);
            v170 = *(int **)(*v15 + 152);
            unsigned int v171 = v167 + 1;
            do
            {
              int v172 = *v170++;
              *v169++ = v168 >> v172;
              --v171;
            }
            while (v171 > 1);
          }
          return;
        case 2:
          int v173 = *(_DWORD *)(*v16 + 160);
          if (v173 >= 1)
          {
            int v174 = **(_DWORD **)(*v15 + 152);
            int v175 = *(int **)(*(void *)v1 + 152);
            int v176 = *(int **)(*v16 + 152);
            unsigned int v177 = v173 + 1;
            do
            {
              int v178 = *v176++;
              *v175++ = v178 >> v174;
              --v177;
            }
            while (v177 > 1);
          }
          return;
        case 3:
          int v179 = *(_DWORD *)(*(void *)v1 + 48);
          if (v179 >= 1)
          {
            uint64_t v180 = *(int **)(*(void *)v1 + 152);
            uint64_t v181 = *(int **)(*v15 + 152);
            int v182 = *(int **)(*v16 + 152);
            unsigned int v183 = v179 + 1;
            do
            {
              int v185 = *v182++;
              int v184 = v185;
              int v186 = *v181++;
              *v180++ = v184 >> v186;
              --v183;
            }
            while (v183 > 1);
          }
          return;
        default:
          int v158 = *(void **)v1;
          char v159 = (void *)*v16;
          int v160 = *(int **)*v16;
          uint64_t v161 = (v159[1] - (void)v160) >> 2;
          uint64_t v162 = (v161 - 1);
          if ((int)v162 >= -1) {
            int v163 = -1;
          }
          else {
            int v163 = v161 - 1;
          }
          int v164 = v163 + 1;
          int v165 = v161 + 1;
          break;
      }
      while (1)
      {
        unsigned int v166 = v165 - 2;
        if (v165 - 2 < 0) {
          break;
        }
        --v165;
        if (*(void *)(v159[3] + 8 * v166) != *(void *)(v158[3] + 8 * v166)) {
          goto LABEL_204;
        }
      }
      int v165 = v164;
LABEL_204:
      int v248 = (void *)*v15;
      int v249 = *(int **)*v15;
      uint64_t v250 = (v248[1] - (void)v249) >> 2;
      uint64_t v251 = (v250 - 1);
      if ((int)v251 >= -1) {
        int v252 = -1;
      }
      else {
        int v252 = v250 - 1;
      }
      int v253 = v252 + 1;
      int v254 = v250 + 1;
      while (1)
      {
        unsigned int v255 = v254 - 2;
        if (v254 - 2 < 0) {
          break;
        }
        --v254;
        if (*(void *)(v248[3] + 8 * v255) != *(void *)(v158[3] + 8 * v255)) {
          goto LABEL_235;
        }
      }
      int v254 = v253;
LABEL_235:
      int v270 = v161 + 1;
      while (1)
      {
        unsigned int v271 = v270 - 2;
        if (v270 - 2 < 0) {
          break;
        }
        --v270;
        if (*(void *)(v159[3] + 8 * v271)) {
          goto LABEL_260;
        }
      }
      int v270 = v164;
LABEL_260:
      int v280 = v250 + 1;
      while (1)
      {
        unsigned int v281 = v280 - 2;
        if (v280 - 2 < 0) {
          break;
        }
        --v280;
        if (*(void *)(v248[3] + 8 * v281)) {
          goto LABEL_339;
        }
      }
      int v280 = v253;
LABEL_339:
      unint64_t v317 = (uint64_t)(v158[1] - *v158) >> 2;
      if (v165 <= v254) {
        int v318 = v254;
      }
      else {
        int v318 = v165;
      }
      if (v165 <= v280) {
        int v165 = v280;
      }
      if (v270 > v254) {
        int v254 = v270;
      }
      if (v317 > v254)
      {
        int v319 = 1;
      }
      else
      {
        int v254 = (uint64_t)(v158[1] - *v158) >> 2;
        int v319 = 4;
      }
      if (v317 > v165)
      {
        int v320 = 2;
      }
      else
      {
        int v165 = v254;
        int v320 = v319;
      }
      if (v317 > v318)
      {
        int v165 = v318;
        int v320 = 3;
      }
      uint64_t v1672 = v251;
      uint64_t v1687 = v162;
      if (!v165) {
        goto LABEL_356;
      }
      unint64_t v321 = *(void *)(v158[3] + 8 * (v165 - 1));
      if (v321 < 0x10) {
        goto LABEL_356;
      }
      switch(v320)
      {
        case 1:
          if (v165 == 2)
          {
            int v1432 = *v160;
            if (*v160)
            {
              unint64_t v1433 = 0;
              uint64_t v1434 = 0;
              uint64_t v1435 = 0;
              uint64_t v1436 = v159[19];
              uint64_t v1437 = v248[19];
              uint64_t v1438 = v158[19];
              ldiv_t v1439 = (uint64_t *)v159[3];
              uint64_t v1440 = *v1439;
              uint64_t v1441 = v1439[1];
              uint64_t v1442 = (uint64_t *)v248[3];
              uint64_t v1443 = *v1442;
              uint64_t v1444 = v1442[1];
              int v1445 = v160[1];
              int v1446 = v1445;
              do
              {
                if (v1446)
                {
                  unint64_t v1447 = 0;
                  uint64_t v1448 = v1437 + 4 * v1434;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1449 = 0;
                      int v1450 = *(_DWORD *)(v1436 + 4 * v1435);
                      unsigned int v1451 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1438 + v1449) = v1450 >> *(_DWORD *)(v1448 + v1449);
                        --v1451;
                        v1449 += 4;
                      }
                      while (v1451 > 1);
                      int v1445 = v160[1];
                    }
                    v1435 += v1441;
                    v1434 += v1444;
                    v1438 += 4 * (int)v321;
                    ++v1447;
                    v1448 += 4 * v1444;
                  }
                  while (v1447 < v1445);
                  uint64_t v1452 = v1445;
                  int v1432 = *v160;
                  int v1446 = v1445;
                }
                else
                {
                  uint64_t v1452 = 0;
                }
                uint64_t v1435 = v1435 + v1440 - v1452 * v1441;
                uint64_t v1434 = v1434 + v1443 - v1444 * v249[1];
                ++v1433;
              }
              while (v1433 < v1432);
            }
          }
          else if (v165 == 1)
          {
            int v922 = *v160;
            if (*v160)
            {
              unint64_t v923 = 0;
              uint64_t v924 = 0;
              uint64_t v925 = v159[19];
              uint64_t v926 = v248[19];
              uint64_t v927 = v158[19];
              uint64_t v928 = *(void *)v159[3];
              uint64_t v929 = 4 * *(void *)v248[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v930 = 0;
                  int v931 = *(_DWORD *)(v925 + 4 * v924);
                  unsigned int v932 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v927 + v930) = v931 >> *(_DWORD *)(v926 + v930);
                    --v932;
                    v930 += 4;
                  }
                  while (v932 > 1);
                  int v922 = *v160;
                }
                v924 += v928;
                ++v923;
                v927 += 4 * (int)v321;
                v926 += v929;
              }
              while (v923 < v922);
            }
          }
          else
          {
            unint64_t v1647 = v158[6];
            if (v1647)
            {
              unint64_t v1666 = 0;
              uint64_t v1589 = v248[19];
              uint64_t v1603 = v159[19];
              uint64_t v1453 = v158[19];
              do
              {
                uint64_t v1454 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1455 = v159[3];
                  uint64_t v1456 = v162;
                  int v1457 = v1666;
                  do
                  {
                    ldiv_t v1458 = ldiv(v1457, v160[v1456]);
                    int v1457 = v1458.quot;
                    v1454 += *(void *)(v1455 + 8 * v1456--) * v1458.rem;
                  }
                  while (v1456 != -1);
                }
                uint64_t v1459 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1460) = 0;
                }
                else
                {
                  uint64_t v1460 = 0;
                  uint64_t v1461 = v248[3];
                  int v1462 = v1666;
                  do
                  {
                    ldiv_t v1463 = ldiv(v1462, v249[v1459]);
                    int v1462 = v1463.quot;
                    v1460 += *(void *)(v1461 + 8 * v1459--) * v1463.rem;
                  }
                  while (v1459 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1464 = 0;
                  int v1465 = *(_DWORD *)(v1603 + 4 * (int)v1454);
                  unsigned int v1466 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1453 + v1464) = v1465 >> *(_DWORD *)(v1589 + 4 * (int)v1460 + v1464);
                    --v1466;
                    v1464 += 4;
                  }
                  while (v1466 > 1);
                }
                v1453 += 4 * (int)v321;
                v1666 += (int)v321;
              }
              while (v1666 < v1647);
            }
          }
          break;
        case 2:
          if (v165 == 2)
          {
            int v1467 = *v160;
            if (*v160)
            {
              unint64_t v1468 = 0;
              uint64_t v1469 = 0;
              uint64_t v1470 = 0;
              uint64_t v1471 = v159[19];
              uint64_t v1472 = v248[19];
              uint64_t v1473 = v158[19];
              int v1474 = (uint64_t *)v159[3];
              uint64_t v1475 = *v1474;
              uint64_t v1476 = v1474[1];
              uint64_t v1477 = (uint64_t *)v248[3];
              uint64_t v1478 = *v1477;
              uint64_t v1479 = v1477[1];
              int v1480 = v160[1];
              int v1481 = v1480;
              do
              {
                if (v1481)
                {
                  unint64_t v1482 = 0;
                  uint64_t v1483 = v1471 + 4 * v1470;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1484 = 0;
                      int v1485 = *(_DWORD *)(v1472 + 4 * v1469);
                      unsigned int v1486 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1473 + v1484) = *(int *)(v1483 + v1484) >> v1485;
                        --v1486;
                        v1484 += 4;
                      }
                      while (v1486 > 1);
                      int v1480 = v160[1];
                    }
                    v1470 += v1476;
                    v1469 += v1479;
                    v1473 += 4 * (int)v321;
                    ++v1482;
                    v1483 += 4 * v1476;
                  }
                  while (v1482 < v1480);
                  uint64_t v1487 = v1480;
                  int v1467 = *v160;
                  int v1481 = v1480;
                }
                else
                {
                  uint64_t v1487 = 0;
                }
                uint64_t v1470 = v1470 + v1475 - v1487 * v1476;
                uint64_t v1469 = v1469 + v1478 - v1479 * v249[1];
                ++v1468;
              }
              while (v1468 < v1467);
            }
          }
          else if (v165 == 1)
          {
            int v933 = *v160;
            if (*v160)
            {
              unint64_t v934 = 0;
              uint64_t v935 = 0;
              uint64_t v936 = v159[19];
              uint64_t v937 = v248[19];
              uint64_t v938 = v158[19];
              uint64_t v939 = *(void *)v248[3];
              uint64_t v940 = 4 * *(void *)v159[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v941 = 0;
                  int v942 = *(_DWORD *)(v937 + 4 * v935);
                  unsigned int v943 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v938 + v941) = *(int *)(v936 + v941) >> v942;
                    --v943;
                    v941 += 4;
                  }
                  while (v943 > 1);
                  int v933 = *v160;
                }
                v935 += v939;
                ++v934;
                v938 += 4 * (int)v321;
                v936 += v940;
              }
              while (v934 < v933);
            }
          }
          else
          {
            unint64_t v1648 = v158[6];
            if (v1648)
            {
              unint64_t v1667 = 0;
              uint64_t v1590 = v248[19];
              uint64_t v1604 = v159[19];
              uint64_t v1488 = v158[19];
              do
              {
                uint64_t v1489 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1490 = v159[3];
                  uint64_t v1491 = v162;
                  int v1492 = v1667;
                  do
                  {
                    ldiv_t v1493 = ldiv(v1492, v160[v1491]);
                    int v1492 = v1493.quot;
                    v1489 += *(void *)(v1490 + 8 * v1491--) * v1493.rem;
                  }
                  while (v1491 != -1);
                }
                uint64_t v1494 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1495) = 0;
                }
                else
                {
                  uint64_t v1495 = 0;
                  uint64_t v1496 = v248[3];
                  int v1497 = v1667;
                  do
                  {
                    ldiv_t v1498 = ldiv(v1497, v249[v1494]);
                    int v1497 = v1498.quot;
                    v1495 += *(void *)(v1496 + 8 * v1494--) * v1498.rem;
                  }
                  while (v1494 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1499 = 0;
                  int v1500 = *(_DWORD *)(v1590 + 4 * (int)v1495);
                  unsigned int v1501 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1488 + v1499) = *(int *)(v1604 + 4 * (int)v1489 + v1499) >> v1500;
                    --v1501;
                    v1499 += 4;
                  }
                  while (v1501 > 1);
                }
                v1488 += 4 * (int)v321;
                v1667 += (int)v321;
              }
              while (v1667 < v1648);
            }
          }
          break;
        case 3:
          if (v165 == 2)
          {
            int v1159 = *v160;
            if (*v160)
            {
              unint64_t v1160 = 0;
              uint64_t v1161 = 0;
              uint64_t v1162 = 0;
              uint64_t v1163 = v159[19];
              uint64_t v1164 = v248[19];
              uint64_t v1165 = v158[19];
              ldiv_t v1166 = (uint64_t *)v159[3];
              uint64_t v1167 = *v1166;
              uint64_t v1168 = v1166[1];
              uint64_t v1169 = (uint64_t *)v248[3];
              uint64_t v1170 = *v1169;
              uint64_t v1171 = v1169[1];
              int v1172 = v160[1];
              int v1173 = v1172;
              do
              {
                if (v1173)
                {
                  unint64_t v1174 = 0;
                  uint64_t v1175 = v1164 + 4 * v1161;
                  uint64_t v1176 = v1163 + 4 * v1162;
                  do
                  {
                    if ((int)v321 >= 1)
                    {
                      uint64_t v1177 = 0;
                      unsigned int v1178 = v321 + 1;
                      do
                      {
                        *(_DWORD *)(v1165 + v1177) = *(int *)(v1176 + v1177) >> *(_DWORD *)(v1175 + v1177);
                        --v1178;
                        v1177 += 4;
                      }
                      while (v1178 > 1);
                      int v1172 = v160[1];
                    }
                    v1162 += v1168;
                    v1161 += v1171;
                    v1165 += 4 * (int)v321;
                    ++v1174;
                    v1175 += 4 * v1171;
                    v1176 += 4 * v1168;
                  }
                  while (v1174 < v1172);
                  uint64_t v1179 = v1172;
                  int v1159 = *v160;
                  int v1173 = v1172;
                }
                else
                {
                  uint64_t v1179 = 0;
                }
                uint64_t v1162 = v1162 + v1167 - v1179 * v1168;
                uint64_t v1161 = v1161 + v1170 - v1171 * v249[1];
                ++v1160;
              }
              while (v1160 < v1159);
            }
          }
          else if (v165 == 1)
          {
            int v366 = *v160;
            if (*v160)
            {
              unint64_t v367 = 0;
              uint64_t v368 = v159[19];
              uint64_t v369 = v248[19];
              uint64_t v370 = v158[19];
              uint64_t v371 = 4 * *(void *)v248[3];
              uint64_t v372 = 4 * *(void *)v159[3];
              do
              {
                if ((int)v321 >= 1)
                {
                  uint64_t v373 = 0;
                  unsigned int v374 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v370 + v373) = *(int *)(v368 + v373) >> *(_DWORD *)(v369 + v373);
                    --v374;
                    v373 += 4;
                  }
                  while (v374 > 1);
                  int v366 = *v160;
                }
                ++v367;
                v370 += 4 * (int)v321;
                v369 += v371;
                v368 += v372;
              }
              while (v367 < v366);
            }
          }
          else
          {
            unint64_t v1641 = v158[6];
            if (v1641)
            {
              unint64_t v1660 = 0;
              uint64_t v1583 = v248[19];
              uint64_t v1597 = v159[19];
              uint64_t v1180 = v158[19];
              do
              {
                uint64_t v1181 = 0;
                if ((v162 & 0x80000000) == 0)
                {
                  uint64_t v1182 = v159[3];
                  uint64_t v1183 = v162;
                  int v1184 = v1660;
                  do
                  {
                    ldiv_t v1185 = ldiv(v1184, v160[v1183]);
                    int v1184 = v1185.quot;
                    v1181 += *(void *)(v1182 + 8 * v1183--) * v1185.rem;
                  }
                  while (v1183 != -1);
                }
                uint64_t v1186 = v1672;
                if ((v1672 & 0x80000000) != 0)
                {
                  LODWORD(v1187) = 0;
                }
                else
                {
                  uint64_t v1187 = 0;
                  uint64_t v1188 = v248[3];
                  int v1189 = v1660;
                  do
                  {
                    ldiv_t v1190 = ldiv(v1189, v249[v1186]);
                    int v1189 = v1190.quot;
                    v1187 += *(void *)(v1188 + 8 * v1186--) * v1190.rem;
                  }
                  while (v1186 != -1);
                }
                uint64_t v162 = v1687;
                if ((int)v321 >= 1)
                {
                  uint64_t v1191 = 0;
                  unsigned int v1192 = v321 + 1;
                  do
                  {
                    *(_DWORD *)(v1180 + v1191) = *(int *)(v1597 + 4 * (int)v1181 + v1191) >> *(_DWORD *)(v1583 + 4 * (int)v1187 + v1191);
                    --v1192;
                    v1191 += 4;
                  }
                  while (v1192 > 1);
                }
                v1180 += 4 * (int)v321;
                v1660 += (int)v321;
              }
              while (v1660 < v1641);
            }
          }
          break;
        default:
LABEL_356:
          switch(v317)
          {
            case 1uLL:
              uint64_t v322 = v158[6];
              if (v322)
              {
                uint64_t v323 = (int *)v159[19];
                uint64_t v324 = (_DWORD *)v248[19];
                uint64_t v325 = (int *)v158[19];
                uint64_t v326 = 4 * *(void *)v248[3];
                uint64_t v327 = 4 * *(void *)v159[3];
                do
                {
                  *v325++ = *v323 >> *v324;
                  uint64_t v324 = (_DWORD *)((char *)v324 + v326);
                  uint64_t v323 = (int *)((char *)v323 + v327);
                  --v322;
                }
                while (v322);
              }
              break;
            case 2uLL:
              int v709 = *v160;
              if (*v160)
              {
                unint64_t v710 = 0;
                uint64_t v711 = 0;
                uint64_t v712 = 0;
                uint64_t v713 = 0;
                uint64_t v714 = v159[19];
                uint64_t v715 = v248[19];
                uint64_t v716 = v158[19];
                uint64_t v717 = (uint64_t *)v159[3];
                uint64_t v718 = *v717;
                uint64_t v719 = v717[1];
                uint64_t v720 = (uint64_t *)v248[3];
                uint64_t v722 = *v720;
                uint64_t v721 = v720[1];
                int v723 = v160[1];
                do
                {
                  if (v723)
                  {
                    for (unint64_t n = 0; n < v723; ++n)
                    {
                      *(_DWORD *)(v716 + 4 * v711 + 4 * n) = *(int *)(v714 + 4 * v713) >> *(_DWORD *)(v715 + 4 * v712);
                      v713 += v719;
                      v712 += v721;
                      int v723 = v160[1];
                    }
                    uint64_t v725 = v723;
                    int v709 = *v160;
                    v711 += n;
                  }
                  else
                  {
                    uint64_t v725 = 0;
                  }
                  uint64_t v713 = v713 + v718 - v725 * v719;
                  uint64_t v712 = v712 + v722 - v721 * v249[1];
                  ++v710;
                }
                while (v710 < v709);
              }
              break;
            case 3uLL:
              int v726 = *v160;
              if (*v160)
              {
                unint64_t v727 = 0;
                uint64_t v728 = 0;
                uint64_t v729 = 0;
                uint64_t v730 = 0;
                uint64_t v731 = v159[19];
                uint64_t v732 = v248[19];
                uint64_t v733 = v158[19];
                unint64_t v734 = (uint64_t *)v159[3];
                uint64_t v735 = *v734;
                uint64_t v736 = v734[1];
                int v737 = (uint64_t *)v248[3];
                uint64_t v738 = *v737;
                uint64_t v739 = v737[1];
                int v740 = v160[1];
                int v741 = v740;
                do
                {
                  if (v741)
                  {
                    unint64_t v742 = 0;
                    uint64_t v743 = v734[2];
                    uint64_t v744 = v737[2];
                    int v745 = v160[2];
                    do
                    {
                      if (v745)
                      {
                        for (unint64_t ii = 0; ii < v745; ++ii)
                        {
                          *(_DWORD *)(v733 + 4 * v728 + 4 * ii) = *(int *)(v731 + 4 * v730) >> *(_DWORD *)(v732 + 4 * v729);
                          v730 += v743;
                          v729 += v744;
                          int v745 = v160[2];
                        }
                        uint64_t v747 = v745;
                        int v740 = v160[1];
                        v728 += ii;
                      }
                      else
                      {
                        uint64_t v747 = 0;
                      }
                      uint64_t v730 = v730 + v736 - v747 * v743;
                      uint64_t v729 = v729 + v739 - v744 * v249[2];
                      ++v742;
                    }
                    while (v742 < v740);
                    uint64_t v748 = v740;
                    int v726 = *v160;
                    int v741 = v740;
                  }
                  else
                  {
                    uint64_t v748 = 0;
                  }
                  uint64_t v730 = v730 + v735 - v748 * v736;
                  uint64_t v729 = v729 + v738 - v739 * v249[1];
                  ++v727;
                }
                while (v727 < v726);
              }
              break;
            case 4uLL:
              int v749 = *v160;
              if (*v160)
              {
                unint64_t v750 = 0;
                uint64_t v751 = 0;
                uint64_t v752 = 0;
                uint64_t v753 = 0;
                uint64_t v754 = v159[19];
                uint64_t v755 = v248[19];
                uint64_t v756 = v158[19];
                uint64_t v757 = (uint64_t *)v159[3];
                uint64_t v758 = *v757;
                uint64_t v759 = v757[1];
                uint64_t v760 = (uint64_t *)v248[3];
                uint64_t v761 = *v760;
                uint64_t v762 = v760[1];
                int v763 = v160[1];
                int v764 = v763;
                do
                {
                  if (v764)
                  {
                    unint64_t v765 = 0;
                    uint64_t v766 = v757[2];
                    uint64_t v767 = v760[2];
                    int v768 = v160[2];
                    int v769 = v768;
                    do
                    {
                      if (v769)
                      {
                        unint64_t v770 = 0;
                        uint64_t v771 = v757[3];
                        uint64_t v772 = v760[3];
                        int v773 = v160[3];
                        do
                        {
                          if (v773)
                          {
                            for (junint64_t j = 0; jj < v773; ++jj)
                            {
                              *(_DWORD *)(v756 + 4 * v751 + 4 * jj) = *(int *)(v754 + 4 * v753) >> *(_DWORD *)(v755 + 4 * v752);
                              v753 += v771;
                              v752 += v772;
                              int v773 = v160[3];
                            }
                            uint64_t v775 = v773;
                            int v768 = v160[2];
                            v751 += jj;
                          }
                          else
                          {
                            uint64_t v775 = 0;
                          }
                          uint64_t v753 = v753 + v766 - v775 * v771;
                          uint64_t v752 = v752 + v767 - v772 * v249[3];
                          ++v770;
                        }
                        while (v770 < v768);
                        uint64_t v776 = v768;
                        int v763 = v160[1];
                        int v769 = v768;
                      }
                      else
                      {
                        uint64_t v776 = 0;
                      }
                      uint64_t v753 = v753 + v759 - v776 * v766;
                      uint64_t v752 = v752 + v762 - v767 * v249[2];
                      ++v765;
                    }
                    while (v765 < v763);
                    uint64_t v777 = v763;
                    int v749 = *v160;
                    int v764 = v763;
                  }
                  else
                  {
                    uint64_t v777 = 0;
                  }
                  uint64_t v753 = v753 + v758 - v777 * v759;
                  uint64_t v752 = v752 + v761 - v762 * v249[1];
                  ++v750;
                }
                while (v750 < v749);
              }
              break;
            default:
              uint64_t v697 = v158[6];
              if (v697)
              {
                uint64_t v698 = 0;
                uint64_t v1633 = v248[19];
                uint64_t v1655 = v159[19];
                uint64_t v1619 = v158[19];
                do
                {
                  uint64_t v699 = 0;
                  if ((v162 & 0x80000000) == 0)
                  {
                    uint64_t v700 = v159[3];
                    uint64_t v701 = v162;
                    int v702 = v698;
                    do
                    {
                      ldiv_t v703 = ldiv(v702, v160[v701]);
                      int v702 = v703.quot;
                      v699 += *(void *)(v700 + 8 * v701--) * v703.rem;
                    }
                    while (v701 != -1);
                  }
                  uint64_t v704 = v1672;
                  if ((v1672 & 0x80000000) != 0)
                  {
                    LODWORD(v705) = 0;
                  }
                  else
                  {
                    uint64_t v705 = 0;
                    uint64_t v706 = v248[3];
                    int v707 = v698;
                    do
                    {
                      ldiv_t v708 = ldiv(v707, v249[v704]);
                      int v707 = v708.quot;
                      v705 += *(void *)(v706 + 8 * v704--) * v708.rem;
                    }
                    while (v704 != -1);
                  }
                  *(_DWORD *)(v1619 + 4 * v698++) = *(int *)(v1655 + 4 * (int)v699) >> *(_DWORD *)(v1633 + 4 * (int)v705);
                  uint64_t v162 = v1687;
                }
                while (v698 != v697);
              }
              break;
          }
          break;
      }
      return;
    case 5:
      uint64_t v19 = *(uint64_t **)a1;
      int v18 = *(uint64_t **)(a1 + 8);
      switch(v20)
      {
        case 0:
          **(void **)(*(void *)v1 + 152) = **(uint64_t **)(*v19 + 152) >> **(void **)(*v18 + 152);
          return;
        case 1:
          int v196 = *(_DWORD *)(*v18 + 160);
          if (v196 >= 1)
          {
            uint64_t v197 = **(void **)(*v19 + 152);
            int v198 = *(uint64_t **)(*(void *)v1 + 152);
            v199 = *(uint64_t **)(*v18 + 152);
            unsigned int v200 = v196 + 1;
            do
            {
              uint64_t v201 = *v199++;
              *v198++ = v197 >> v201;
              --v200;
            }
            while (v200 > 1);
          }
          return;
        case 2:
          int v202 = *(_DWORD *)(*v19 + 160);
          if (v202 >= 1)
          {
            uint64_t v203 = **(void **)(*v18 + 152);
            uint64_t v204 = *(uint64_t **)(*(void *)v1 + 152);
            uint64_t v205 = *(uint64_t **)(*v19 + 152);
            unsigned int v206 = v202 + 1;
            do
            {
              uint64_t v207 = *v205++;
              *v204++ = v207 >> v203;
              --v206;
            }
            while (v206 > 1);
          }
          return;
        case 3:
          int v208 = *(_DWORD *)(*(void *)v1 + 48);
          if (v208 >= 1)
          {
            uint64_t v209 = *(uint64_t **)(*(void *)v1 + 152);
            uint64_t v210 = *(uint64_t **)(*v18 + 152);
            uint64_t v211 = *(uint64_t **)(*v19 + 152);
            unsigned int v212 = v208 + 1;
            do
            {
              uint64_t v214 = *v211++;
              uint64_t v213 = v214;
              uint64_t v215 = *v210++;
              *v209++ = v213 >> v215;
              --v212;
            }
            while (v212 > 1);
          }
          return;
        default:
          uint64_t v187 = *(void **)v1;
          int v188 = (void *)*v19;
          int v189 = *(int **)*v19;
          uint64_t v190 = (v188[1] - (void)v189) >> 2;
          uint64_t v191 = (v190 - 1);
          if ((int)v191 >= -1) {
            int v192 = -1;
          }
          else {
            int v192 = v190 - 1;
          }
          int v193 = v192 + 1;
          int v194 = v190 + 1;
          break;
      }
      break;
    default:
      exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x25A2B1470](exception, "[BitwiseBinary::eval_cpu] Type not supported");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  while (1)
  {
    unsigned int v195 = v194 - 2;
    if (v194 - 2 < 0) {
      break;
    }
    --v194;
    if (*(void *)(v188[3] + 8 * v195) != *(void *)(v187[3] + 8 * v195)) {
      goto LABEL_212;
    }
  }
  int v194 = v193;
LABEL_212:
  int v256 = (void *)*v18;
  unsigned int v257 = *(int **)*v18;
  uint64_t v258 = (v256[1] - (void)v257) >> 2;
  uint64_t v259 = (v258 - 1);
  if ((int)v259 >= -1) {
    int v260 = -1;
  }
  else {
    int v260 = v258 - 1;
  }
  int v261 = v260 + 1;
  int v262 = v258 + 1;
  while (1)
  {
    unsigned int v263 = v262 - 2;
    if (v262 - 2 < 0) {
      break;
    }
    --v262;
    if (*(void *)(v256[3] + 8 * v263) != *(void *)(v187[3] + 8 * v263)) {
      goto LABEL_240;
    }
  }
  int v262 = v261;
LABEL_240:
  int v272 = v190 + 1;
  while (1)
  {
    unsigned int v273 = v272 - 2;
    if (v272 - 2 < 0) {
      break;
    }
    --v272;
    if (*(void *)(v188[3] + 8 * v273)) {
      goto LABEL_265;
    }
  }
  int v272 = v193;
LABEL_265:
  int v282 = v258 + 1;
  while (1)
  {
    unsigned int v283 = v282 - 2;
    if (v282 - 2 < 0) {
      break;
    }
    --v282;
    if (*(void *)(v256[3] + 8 * v283)) {
      goto LABEL_362;
    }
  }
  int v282 = v261;
LABEL_362:
  unint64_t v328 = (uint64_t)(v187[1] - *v187) >> 2;
  if (v194 <= v262) {
    int v329 = v262;
  }
  else {
    int v329 = v194;
  }
  if (v194 <= v282) {
    int v194 = v282;
  }
  if (v272 > v262) {
    int v262 = v272;
  }
  if (v328 > v262)
  {
    int v330 = 1;
  }
  else
  {
    int v262 = (uint64_t)(v187[1] - *v187) >> 2;
    int v330 = 4;
  }
  if (v328 > v194)
  {
    int v331 = 2;
  }
  else
  {
    int v194 = v262;
    int v331 = v330;
  }
  if (v328 > v329)
  {
    int v194 = v329;
    int v331 = 3;
  }
  uint64_t v1673 = v259;
  uint64_t v1688 = v191;
  if (!v194) {
    goto LABEL_379;
  }
  unint64_t v332 = *(void *)(v187[3] + 8 * (v194 - 1));
  if (v332 < 0x10) {
    goto LABEL_379;
  }
  switch(v331)
  {
    case 1:
      if (v194 == 2)
      {
        uint64_t v1502 = *v189;
        if (v1502)
        {
          uint64_t v1503 = 0;
          uint64_t v1504 = 0;
          uint64_t v1505 = 0;
          uint64_t v1506 = v188[19];
          uint64_t v1507 = v256[19];
          uint64_t v1508 = v187[19];
          unint64_t v1509 = v189[1];
          uint64_t v1510 = (uint64_t *)v188[3];
          uint64_t v1511 = *v1510;
          uint64_t v1512 = v1510[1];
          uint64_t v1513 = (uint64_t *)v256[3];
          uint64_t v1514 = *v1513;
          uint64_t v1515 = v1513[1];
          if (v1509 <= 1) {
            uint64_t v1516 = 1;
          }
          else {
            uint64_t v1516 = v189[1];
          }
          uint64_t v1517 = v1511 - v1512 * v1509;
          uint64_t v1518 = v1514 - v1515 * v257[1];
          do
          {
            if (v1509)
            {
              uint64_t v1519 = 0;
              uint64_t v1520 = v1507 + 8 * v1504;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1521 = 0;
                  uint64_t v1522 = *(void *)(v1506 + 8 * v1505);
                  unsigned int v1523 = v332 + 1;
                  do
                  {
                    *(void *)(v1508 + v1521) = v1522 >> *(void *)(v1520 + v1521);
                    --v1523;
                    v1521 += 8;
                  }
                  while (v1523 > 1);
                }
                v1505 += v1512;
                v1504 += v1515;
                v1508 += 8 * (int)v332;
                ++v1519;
                v1520 += 8 * v1515;
              }
              while (v1519 != v1516);
            }
            v1505 += v1517;
            v1504 += v1518;
            ++v1503;
          }
          while (v1503 != v1502);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v944 = *v189;
        if (v944)
        {
          uint64_t v945 = 0;
          uint64_t v946 = 0;
          uint64_t v947 = v188[19];
          uint64_t v948 = v256[19];
          uint64_t v949 = v187[19];
          uint64_t v950 = *(void *)v188[3];
          uint64_t v951 = 8 * *(void *)v256[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v952 = 0;
              uint64_t v953 = *(void *)(v947 + 8 * v946);
              unsigned int v954 = v332 + 1;
              do
              {
                *(void *)(v949 + v952) = v953 >> *(void *)(v948 + v952);
                --v954;
                v952 += 8;
              }
              while (v954 > 1);
            }
            v946 += v950;
            ++v945;
            v949 += 8 * (int)v332;
            v948 += v951;
          }
          while (v945 != v944);
        }
      }
      else
      {
        unint64_t v1649 = v187[6];
        if (v1649)
        {
          unint64_t v1668 = 0;
          uint64_t v1591 = v256[19];
          uint64_t v1605 = v188[19];
          uint64_t v1524 = v187[19];
          do
          {
            uint64_t v1525 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1526 = v188[3];
              uint64_t v1527 = v191;
              int v1528 = v1668;
              do
              {
                ldiv_t v1529 = ldiv(v1528, v189[v1527]);
                int v1528 = v1529.quot;
                v1525 += *(void *)(v1526 + 8 * v1527--) * v1529.rem;
              }
              while (v1527 != -1);
            }
            uint64_t v1530 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1531) = 0;
            }
            else
            {
              uint64_t v1531 = 0;
              uint64_t v1532 = v256[3];
              int v1533 = v1668;
              do
              {
                ldiv_t v1534 = ldiv(v1533, v257[v1530]);
                int v1533 = v1534.quot;
                v1531 += *(void *)(v1532 + 8 * v1530--) * v1534.rem;
              }
              while (v1530 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1535 = 0;
              uint64_t v1536 = *(void *)(v1605 + 8 * (int)v1525);
              unsigned int v1537 = v332 + 1;
              do
              {
                *(void *)(v1524 + v1535) = v1536 >> *(void *)(v1591 + 8 * (int)v1531 + v1535);
                --v1537;
                v1535 += 8;
              }
              while (v1537 > 1);
            }
            v1524 += 8 * (int)v332;
            v1668 += (int)v332;
          }
          while (v1668 < v1649);
        }
      }
      break;
    case 2:
      if (v194 == 2)
      {
        uint64_t v1538 = *v189;
        if (v1538)
        {
          uint64_t v1539 = 0;
          uint64_t v1540 = 0;
          uint64_t v1541 = 0;
          uint64_t v1542 = v188[19];
          uint64_t v1543 = v256[19];
          uint64_t v1544 = v187[19];
          unint64_t v1545 = v189[1];
          uint64_t v1546 = (uint64_t *)v188[3];
          uint64_t v1547 = *v1546;
          uint64_t v1548 = v1546[1];
          unint64_t v1549 = (uint64_t *)v256[3];
          uint64_t v1550 = *v1549;
          uint64_t v1551 = v1549[1];
          if (v1545 <= 1) {
            uint64_t v1552 = 1;
          }
          else {
            uint64_t v1552 = v189[1];
          }
          uint64_t v1553 = v1547 - v1548 * v1545;
          uint64_t v1554 = v1550 - v1551 * v257[1];
          do
          {
            if (v1545)
            {
              uint64_t v1555 = 0;
              uint64_t v1556 = v1542 + 8 * v1541;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1557 = 0;
                  uint64_t v1558 = *(void *)(v1543 + 8 * v1540);
                  unsigned int v1559 = v332 + 1;
                  do
                  {
                    *(void *)(v1544 + v1557) = *(uint64_t *)(v1556 + v1557) >> v1558;
                    --v1559;
                    v1557 += 8;
                  }
                  while (v1559 > 1);
                }
                v1541 += v1548;
                v1540 += v1551;
                v1544 += 8 * (int)v332;
                ++v1555;
                v1556 += 8 * v1548;
              }
              while (v1555 != v1552);
            }
            v1541 += v1553;
            v1540 += v1554;
            ++v1539;
          }
          while (v1539 != v1538);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v955 = *v189;
        if (v955)
        {
          uint64_t v956 = 0;
          uint64_t v957 = 0;
          uint64_t v958 = v188[19];
          uint64_t v959 = v256[19];
          uint64_t v960 = v187[19];
          uint64_t v961 = *(void *)v256[3];
          uint64_t v962 = 8 * *(void *)v188[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v963 = 0;
              uint64_t v964 = *(void *)(v959 + 8 * v957);
              unsigned int v965 = v332 + 1;
              do
              {
                *(void *)(v960 + v963) = *(uint64_t *)(v958 + v963) >> v964;
                --v965;
                v963 += 8;
              }
              while (v965 > 1);
            }
            v957 += v961;
            ++v956;
            v960 += 8 * (int)v332;
            v958 += v962;
          }
          while (v956 != v955);
        }
      }
      else
      {
        unint64_t v1650 = v187[6];
        if (v1650)
        {
          unint64_t v1669 = 0;
          uint64_t v1592 = v256[19];
          uint64_t v1606 = v188[19];
          uint64_t v1560 = v187[19];
          do
          {
            uint64_t v1561 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1562 = v188[3];
              uint64_t v1563 = v191;
              int v1564 = v1669;
              do
              {
                ldiv_t v1565 = ldiv(v1564, v189[v1563]);
                int v1564 = v1565.quot;
                v1561 += *(void *)(v1562 + 8 * v1563--) * v1565.rem;
              }
              while (v1563 != -1);
            }
            uint64_t v1566 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1567) = 0;
            }
            else
            {
              uint64_t v1567 = 0;
              uint64_t v1568 = v256[3];
              int v1569 = v1669;
              do
              {
                ldiv_t v1570 = ldiv(v1569, v257[v1566]);
                int v1569 = v1570.quot;
                v1567 += *(void *)(v1568 + 8 * v1566--) * v1570.rem;
              }
              while (v1566 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1571 = 0;
              uint64_t v1572 = *(void *)(v1592 + 8 * (int)v1567);
              unsigned int v1573 = v332 + 1;
              do
              {
                *(void *)(v1560 + v1571) = *(uint64_t *)(v1606 + 8 * (int)v1561 + v1571) >> v1572;
                --v1573;
                v1571 += 8;
              }
              while (v1573 > 1);
            }
            v1560 += 8 * (int)v332;
            v1669 += (int)v332;
          }
          while (v1669 < v1650);
        }
      }
      break;
    case 3:
      if (v194 == 2)
      {
        uint64_t v1193 = *v189;
        if (v1193)
        {
          uint64_t v1194 = 0;
          uint64_t v1195 = 0;
          uint64_t v1196 = 0;
          uint64_t v1197 = v188[19];
          uint64_t v1198 = v256[19];
          uint64_t v1199 = v187[19];
          unint64_t v1200 = v189[1];
          uint64_t v1201 = (uint64_t *)v188[3];
          uint64_t v1202 = *v1201;
          uint64_t v1203 = v1201[1];
          int v1204 = (uint64_t *)v256[3];
          uint64_t v1205 = *v1204;
          uint64_t v1206 = v1204[1];
          if (v1200 <= 1) {
            uint64_t v1207 = 1;
          }
          else {
            uint64_t v1207 = v189[1];
          }
          uint64_t v1208 = v1202 - v1203 * v1200;
          uint64_t v1209 = v1205 - v1206 * v257[1];
          do
          {
            if (v1200)
            {
              uint64_t v1210 = 0;
              uint64_t v1211 = v1198 + 8 * v1195;
              uint64_t v1212 = v1197 + 8 * v1196;
              do
              {
                if ((int)v332 >= 1)
                {
                  uint64_t v1213 = 0;
                  unsigned int v1214 = v332 + 1;
                  do
                  {
                    *(void *)(v1199 + v1213) = *(uint64_t *)(v1212 + v1213) >> *(void *)(v1211 + v1213);
                    --v1214;
                    v1213 += 8;
                  }
                  while (v1214 > 1);
                }
                v1196 += v1203;
                v1195 += v1206;
                v1199 += 8 * (int)v332;
                ++v1210;
                v1211 += 8 * v1206;
                v1212 += 8 * v1203;
              }
              while (v1210 != v1207);
            }
            v1196 += v1208;
            v1195 += v1209;
            ++v1194;
          }
          while (v1194 != v1193);
        }
      }
      else if (v194 == 1)
      {
        uint64_t v375 = *v189;
        if (v375)
        {
          uint64_t v376 = 0;
          uint64_t v377 = v188[19];
          uint64_t v378 = v256[19];
          uint64_t v379 = v187[19];
          uint64_t v380 = 8 * *(void *)v256[3];
          uint64_t v381 = 8 * *(void *)v188[3];
          do
          {
            if ((int)v332 >= 1)
            {
              uint64_t v382 = 0;
              unsigned int v383 = v332 + 1;
              do
              {
                *(void *)(v379 + v382) = *(uint64_t *)(v377 + v382) >> *(void *)(v378 + v382);
                --v383;
                v382 += 8;
              }
              while (v383 > 1);
            }
            ++v376;
            v379 += 8 * (int)v332;
            v378 += v380;
            v377 += v381;
          }
          while (v376 != v375);
        }
      }
      else
      {
        unint64_t v1642 = v187[6];
        if (v1642)
        {
          unint64_t v1661 = 0;
          uint64_t v1584 = v256[19];
          uint64_t v1598 = v188[19];
          uint64_t v1215 = v187[19];
          do
          {
            uint64_t v1216 = 0;
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v1217 = v188[3];
              uint64_t v1218 = v191;
              int v1219 = v1661;
              do
              {
                ldiv_t v1220 = ldiv(v1219, v189[v1218]);
                int v1219 = v1220.quot;
                v1216 += *(void *)(v1217 + 8 * v1218--) * v1220.rem;
              }
              while (v1218 != -1);
            }
            uint64_t v1221 = v1673;
            if ((v1673 & 0x80000000) != 0)
            {
              LODWORD(v1222) = 0;
            }
            else
            {
              uint64_t v1222 = 0;
              uint64_t v1223 = v256[3];
              int v1224 = v1661;
              do
              {
                ldiv_t v1225 = ldiv(v1224, v257[v1221]);
                int v1224 = v1225.quot;
                v1222 += *(void *)(v1223 + 8 * v1221--) * v1225.rem;
              }
              while (v1221 != -1);
            }
            uint64_t v191 = v1688;
            if ((int)v332 >= 1)
            {
              uint64_t v1226 = 0;
              unsigned int v1227 = v332 + 1;
              do
              {
                *(void *)(v1215 + v1226) = *(uint64_t *)(v1598 + 8 * (int)v1216 + v1226) >> *(void *)(v1584 + 8 * (int)v1222 + v1226);
                --v1227;
                v1226 += 8;
              }
              while (v1227 > 1);
            }
            v1215 += 8 * (int)v332;
            v1661 += (int)v332;
          }
          while (v1661 < v1642);
        }
      }
      break;
    default:
LABEL_379:
      switch(v328)
      {
        case 1uLL:
          uint64_t v333 = v187[6];
          if (v333)
          {
            uint64_t v334 = (uint64_t *)v188[19];
            uint64_t v335 = (void *)v256[19];
            uint64_t v336 = (uint64_t *)v187[19];
            uint64_t v337 = 8 * *(void *)v256[3];
            uint64_t v338 = 8 * *(void *)v188[3];
            do
            {
              *v336++ = *v334 >> *v335;
              uint64_t v335 = (void *)((char *)v335 + v337);
              uint64_t v334 = (uint64_t *)((char *)v334 + v338);
              --v333;
            }
            while (v333);
          }
          break;
        case 2uLL:
          uint64_t v790 = *v189;
          if (v790)
          {
            uint64_t v791 = 0;
            uint64_t v792 = 0;
            uint64_t v793 = 0;
            uint64_t v794 = 0;
            uint64_t v795 = v188[19];
            uint64_t v796 = v256[19];
            uint64_t v797 = v187[19];
            unint64_t v798 = v189[1];
            uint64_t v799 = (uint64_t *)v188[3];
            uint64_t v800 = *v799;
            uint64_t v801 = v799[1];
            uint64_t v802 = (uint64_t *)v256[3];
            uint64_t v803 = *v802;
            uint64_t v804 = v802[1];
            uint64_t v805 = v803 - v804 * v257[1];
            if (v798 <= 1) {
              uint64_t v806 = 1;
            }
            else {
              uint64_t v806 = v189[1];
            }
            uint64_t v807 = v800 - v801 * v798;
            do
            {
              if (v798)
              {
                uint64_t v808 = v792 + v806;
                uint64_t v809 = (uint64_t *)(v797 + 8 * v792);
                uint64_t v810 = v806;
                do
                {
                  *v809++ = *(uint64_t *)(v795 + 8 * v794) >> *(void *)(v796 + 8 * v793);
                  v794 += v801;
                  v793 += v804;
                  --v810;
                }
                while (v810);
                uint64_t v792 = v808;
              }
              v794 += v807;
              v793 += v805;
              ++v791;
            }
            while (v791 != v790);
          }
          break;
        case 3uLL:
          uint64_t v811 = *v189;
          if (v811)
          {
            uint64_t v812 = 0;
            uint64_t v813 = 0;
            uint64_t v814 = 0;
            uint64_t v815 = 0;
            uint64_t v816 = v188[19];
            uint64_t v817 = v256[19];
            uint64_t v818 = v187[19];
            unint64_t v819 = v189[1];
            uint64_t v820 = (void *)v188[3];
            uint64_t v821 = v820[1];
            uint64_t v822 = (void *)v256[3];
            uint64_t v823 = v822[1];
            uint64_t v824 = *v822 - v823 * v257[1];
            if (v819 <= 1) {
              uint64_t v825 = 1;
            }
            else {
              uint64_t v825 = v189[1];
            }
            unint64_t v826 = *v820 - v821 * v819;
            do
            {
              if (v819)
              {
                uint64_t v827 = 0;
                unint64_t v828 = v189[2];
                uint64_t v829 = v820[2];
                uint64_t v830 = v822[2];
                if (v828 <= 1) {
                  uint64_t v831 = 1;
                }
                else {
                  uint64_t v831 = v189[2];
                }
                uint64_t v832 = v823 - v830 * v257[2];
                do
                {
                  uint64_t v833 = v831;
                  if (v828)
                  {
                    do
                    {
                      *(void *)(v818 + 8 * v813++) = *(uint64_t *)(v816 + 8 * v815) >> *(void *)(v817 + 8 * v814);
                      v815 += v829;
                      v814 += v830;
                      --v833;
                    }
                    while (v833);
                  }
                  v815 += v821 - v829 * v828;
                  v814 += v832;
                  ++v827;
                }
                while (v827 != v825);
              }
              v815 += v826;
              v814 += v824;
              ++v812;
            }
            while (v812 != v811);
          }
          break;
        case 4uLL:
          uint64_t v1692 = *v189;
          if (v1692)
          {
            uint64_t v834 = 0;
            uint64_t v835 = 0;
            uint64_t v836 = 0;
            uint64_t v837 = 0;
            uint64_t v838 = v188[19];
            uint64_t v839 = v256[19];
            uint64_t v840 = v187[19];
            unint64_t v841 = v189[1];
            int v842 = (void *)v188[3];
            unsigned int v843 = (void *)v256[3];
            uint64_t v1609 = v843[1];
            uint64_t v1621 = v842[1];
            uint64_t v1657 = *v843 - v1609 * v257[1];
            int v1677 = v189[1];
            if (v841 <= 1) {
              uint64_t v844 = 1;
            }
            else {
              uint64_t v844 = v189[1];
            }
            unint64_t v1635 = *v842 - v842[1] * v841;
            do
            {
              if (v1677)
              {
                uint64_t v845 = 0;
                unint64_t v846 = v189[2];
                uint64_t v847 = v842[2];
                uint64_t v848 = v843[2];
                if (v846 <= 1) {
                  uint64_t v849 = 1;
                }
                else {
                  uint64_t v849 = v189[2];
                }
                uint64_t v850 = v1609 - v848 * v257[2];
                do
                {
                  if (v846)
                  {
                    uint64_t v851 = 0;
                    unint64_t v852 = v189[3];
                    uint64_t v853 = v842[3];
                    uint64_t v854 = v843[3];
                    if (v852 <= 1) {
                      uint64_t v855 = 1;
                    }
                    else {
                      uint64_t v855 = v189[3];
                    }
                    uint64_t v856 = v848 - v854 * v257[3];
                    do
                    {
                      uint64_t v857 = v855;
                      if (v852)
                      {
                        do
                        {
                          *(void *)(v840 + 8 * v835++) = *(uint64_t *)(v838 + 8 * v837) >> *(void *)(v839 + 8 * v836);
                          v837 += v853;
                          v836 += v854;
                          --v857;
                        }
                        while (v857);
                      }
                      v837 += v847 - v853 * v852;
                      v836 += v856;
                      ++v851;
                    }
                    while (v851 != v849);
                  }
                  v837 += v1621 - v847 * v846;
                  v836 += v850;
                  ++v845;
                }
                while (v845 != v844);
              }
              v837 += v1635;
              v836 += v1657;
              ++v834;
            }
            while (v834 != v1692);
          }
          break;
        default:
          uint64_t v778 = v187[6];
          if (v778)
          {
            uint64_t v779 = 0;
            uint64_t v1634 = v256[19];
            uint64_t v1656 = v188[19];
            uint64_t v1620 = v187[19];
            do
            {
              uint64_t v780 = 0;
              if ((v191 & 0x80000000) == 0)
              {
                uint64_t v781 = v188[3];
                uint64_t v782 = v191;
                int v783 = v779;
                do
                {
                  ldiv_t v784 = ldiv(v783, v189[v782]);
                  int v783 = v784.quot;
                  v780 += *(void *)(v781 + 8 * v782--) * v784.rem;
                }
                while (v782 != -1);
              }
              uint64_t v785 = v1673;
              if ((v1673 & 0x80000000) != 0)
              {
                LODWORD(v786) = 0;
              }
              else
              {
                uint64_t v786 = 0;
                uint64_t v787 = v256[3];
                int v788 = v779;
                do
                {
                  ldiv_t v789 = ldiv(v788, v257[v785]);
                  int v788 = v789.quot;
                  v786 += *(void *)(v787 + 8 * v785--) * v789.rem;
                }
                while (v785 != -1);
              }
              *(void *)(v1620 + 8 * v779++) = *(uint64_t *)(v1656 + 8 * (int)v780) >> *(void *)(v1634 + 8 * (int)v786);
              uint64_t v191 = v1688;
            }
            while (v779 != v778);
          }
          break;
      }
      return;
  }
}

void sub_256E6AEE8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::ArcTan2::eval(uint64_t a1, uint64_t a2, mlx::core::array *a3)
{
  v3 = *(uint64_t **)a2;
  if (*(void *)(a2 + 8) - *(void *)a2 != 32) {
    mlx::core::ArcTan2::eval();
  }
  if (*(void *)(*(void *)a3 + 56) != 6)
  {
    uint64_t v360 = *(void *)(*(void *)a3 + 56);
    if (mlx::core::issubdtype((unsigned int *)&v360, &mlx::core::inexact))
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v360);
      int v266 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v360, (uint64_t)"[arctan2] Does not support ", 27);
      v359.__r_.__value_.__r.__words[0] = *(void *)(*(void *)a3 + 56);
      mlx::core::operator<<(v266, &v359);
      exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v361, &v359);
      std::logic_error::logic_error(exception, &v359);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
    }
    int v268 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](v268, "[arctan2] Cannot compute inverse tangent for arrays with non floating point type.");
    __cxa_throw(v268, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  v5 = (uint64_t **)(v3 + 2);
  switch(binary_op_type)
  {
    case 0:
      **(float **)(*(void *)a3 + 152) = atan2f(**(float **)(*v3 + 152), **(float **)(v3[2] + 152));
      return;
    case 1:
      uint64_t v21 = v3[2];
      int v22 = *(_DWORD *)(v21 + 160);
      if (v22 >= 1)
      {
        float v23 = **(float **)(*v3 + 152);
        uint64_t v24 = *(float **)(*(void *)a3 + 152);
        uint64_t v25 = *(float **)(v21 + 152);
        unsigned int v26 = v22 + 1;
        do
        {
          float v27 = *v25++;
          *v24++ = atan2f(v23, v27);
          --v26;
        }
        while (v26 > 1);
      }
      return;
    case 2:
      int v7 = *(_DWORD *)(*v3 + 160);
      if (v7 >= 1)
      {
        float v8 = **(float **)(v3[2] + 152);
        int v9 = *(float **)(*(void *)a3 + 152);
        int v10 = *(float **)(*v3 + 152);
        unsigned int v11 = v7 + 1;
        do
        {
          float v12 = *v10++;
          *v9++ = atan2f(v12, v8);
          --v11;
        }
        while (v11 > 1);
      }
      return;
    case 3:
      int v13 = *(_DWORD *)(*(void *)a3 + 48);
      if (v13 >= 1)
      {
        uint64_t v14 = *(float **)(*(void *)a3 + 152);
        unsigned int v15 = *(float **)(v3[2] + 152);
        int v16 = *(float **)(*v3 + 152);
        unsigned int v17 = v13 + 1;
        do
        {
          float v18 = *v16++;
          float v19 = v18;
          float v20 = *v15++;
          *v14++ = atan2f(v19, v20);
          --v17;
        }
        while (v17 > 1);
      }
      return;
    default:
      int v28 = *(void **)a3;
      uint64_t v29 = *v3;
      int v30 = *(int **)*v3;
      uint64_t v31 = (*(void *)(*v3 + 8) - (void)v30) >> 2;
      uint64_t v32 = (v31 - 1);
      if ((int)v32 >= -1) {
        int v33 = -1;
      }
      else {
        int v33 = v31 - 1;
      }
      int v34 = v33 + 1;
      int v35 = v31 + 1;
      while (1)
      {
        unsigned int v36 = v35 - 2;
        if (v35 - 2 < 0) {
          break;
        }
        --v35;
        if (*(void *)(*(void *)(v29 + 24) + 8 * v36) != *(void *)(v28[3] + 8 * v36)) {
          goto LABEL_25;
        }
      }
      int v35 = v34;
LABEL_25:
      char v37 = *v5;
      uint64_t v38 = **v5;
      unint64_t v39 = (unint64_t)((*v5)[1] - v38) >> 2;
      uint64_t v40 = (v39 - 1);
      if ((int)v40 >= -1) {
        int v41 = -1;
      }
      else {
        int v41 = v39 - 1;
      }
      int v42 = v41 + 1;
      int v43 = v39 + 1;
      while (1)
      {
        unsigned int v44 = v43 - 2;
        if (v43 - 2 < 0) {
          break;
        }
        --v43;
        if (*(void *)(v37[3] + 8 * v44) != *(void *)(v28[3] + 8 * v44)) {
          goto LABEL_33;
        }
      }
      int v43 = v42;
LABEL_33:
      int v45 = v31 + 1;
      while (1)
      {
        unsigned int v46 = v45 - 2;
        if (v45 - 2 < 0) {
          break;
        }
        --v45;
        if (*(void *)(*(void *)(v29 + 24) + 8 * v46)) {
          goto LABEL_38;
        }
      }
      int v45 = v34;
LABEL_38:
      int v47 = v39 + 1;
      while (1)
      {
        unsigned int v48 = v47 - 2;
        if (v47 - 2 < 0) {
          break;
        }
        --v47;
        if (*(void *)(v37[3] + 8 * v48)) {
          goto LABEL_43;
        }
      }
      int v47 = v42;
LABEL_43:
      unint64_t v49 = (uint64_t)(v28[1] - *v28) >> 2;
      if (v35 <= v43) {
        int v50 = v43;
      }
      else {
        int v50 = v35;
      }
      if (v35 <= v47) {
        int v35 = v47;
      }
      if (v45 > v43) {
        int v43 = v45;
      }
      if (v49 > v43)
      {
        int v51 = 1;
      }
      else
      {
        int v43 = (uint64_t)(v28[1] - *v28) >> 2;
        int v51 = 4;
      }
      if (v49 > v35)
      {
        int v52 = 2;
      }
      else
      {
        int v35 = v43;
        int v52 = v51;
      }
      if (v49 > v50)
      {
        int v35 = v50;
        int v52 = 3;
      }
      unint64_t v288 = *(int **)*v3;
      uint64_t v289 = **v5;
      uint64_t v339 = v40;
      uint64_t v345 = v32;
      if (!v35) {
        goto LABEL_60;
      }
      unint64_t v354 = *(void *)(v28[3] + 8 * (v35 - 1));
      if (v354 < 0x10) {
        goto LABEL_60;
      }
      switch(v52)
      {
        case 1:
          if (v35 == 2)
          {
            uint64_t v309 = *v30;
            if (v309)
            {
              uint64_t v177 = 0;
              uint64_t v178 = 0;
              uint64_t v179 = 0;
              uint64_t v337 = *(void *)(v29 + 152);
              uint64_t v286 = v37[19];
              uint64_t v180 = v28[19];
              unint64_t v181 = v288[1];
              int v182 = *(uint64_t **)(v29 + 24);
              uint64_t v183 = *v182;
              uint64_t v184 = v182[1];
              int v185 = (void *)v37[3];
              uint64_t v186 = v185[1];
              if (v181 <= 1) {
                uint64_t v187 = 1;
              }
              else {
                uint64_t v187 = v288[1];
              }
              uint64_t v344 = v187;
              uint64_t v352 = v184;
              uint64_t v299 = v183 - v184 * v181;
              int v304 = v288[1];
              uint64_t v294 = *v185 - v186 * *(int *)(v38 + 4);
              uint64_t v188 = v185[1];
              uint64_t v189 = 4 * v186;
              do
              {
                uint64_t v318 = v177;
                if (v304)
                {
                  uint64_t v190 = 0;
                  uint64_t v191 = v286 + 4 * v178;
                  do
                  {
                    if ((int)v354 >= 1)
                    {
                      uint64_t v192 = 0;
                      float v193 = *(float *)(v337 + 4 * v179);
                      unsigned int v194 = v354 + 1;
                      do
                      {
                        *(float *)(v180 + v192) = atan2f(v193, *(float *)(v191 + v192));
                        --v194;
                        v192 += 4;
                      }
                      while (v194 > 1);
                    }
                    v179 += v352;
                    v178 += v188;
                    v180 += 4 * (int)v354;
                    ++v190;
                    v191 += v189;
                  }
                  while (v190 != v344);
                }
                v179 += v299;
                v178 += v294;
                uint64_t v177 = v318 + 1;
              }
              while (v318 + 1 != v309);
            }
          }
          else
          {
            uint64_t v335 = *v5;
            if (v35 == 1)
            {
              uint64_t v150 = *v30;
              if (v150)
              {
                uint64_t v151 = 0;
                uint64_t v152 = 0;
                uint64_t v350 = *(void *)(v29 + 152);
                uint64_t v153 = v37[19];
                uint64_t v154 = v28[19];
                uint64_t v155 = **(void **)(v29 + 24);
                uint64_t v156 = 4 * *(void *)v37[3];
                do
                {
                  if ((int)v354 >= 1)
                  {
                    uint64_t v157 = 0;
                    float v158 = *(float *)(v350 + 4 * v152);
                    unsigned int v159 = v354 + 1;
                    do
                    {
                      *(float *)(v154 + v157) = atan2f(v158, *(float *)(v153 + v157));
                      --v159;
                      v157 += 4;
                    }
                    while (v159 > 1);
                  }
                  v152 += v155;
                  ++v151;
                  v154 += 4 * (int)v354;
                  v153 += v156;
                }
                while (v151 != v150);
              }
            }
            else
            {
              unint64_t v327 = v28[6];
              if (v327)
              {
                unint64_t v231 = 0;
                uint64_t v312 = v37[19];
                uint64_t v320 = *(void *)(v29 + 152);
                uint64_t v232 = v28[19];
                do
                {
                  uint64_t v233 = 0;
                  if ((v32 & 0x80000000) != 0)
                  {
                    uint64_t v237 = v289;
                  }
                  else
                  {
                    uint64_t v234 = *(void *)(v29 + 24);
                    uint64_t v235 = v32;
                    int quot = v231;
                    uint64_t v237 = v289;
                    do
                    {
                      ldiv_t v238 = ldiv(quot, v288[v235]);
                      int quot = v238.quot;
                      v233 += *(void *)(v234 + 8 * v235--) * v238.rem;
                    }
                    while (v235 != -1);
                  }
                  uint64_t v239 = v339;
                  if ((v339 & 0x80000000) != 0)
                  {
                    LODWORD(v240) = 0;
                  }
                  else
                  {
                    uint64_t v240 = 0;
                    uint64_t v241 = v335[3];
                    int v242 = v231;
                    do
                    {
                      ldiv_t v243 = ldiv(v242, *(int *)(v237 + 4 * v239));
                      int v242 = v243.quot;
                      v240 += *(void *)(v241 + 8 * v239--) * v243.rem;
                    }
                    while (v239 != -1);
                  }
                  if ((int)v354 >= 1)
                  {
                    uint64_t v244 = 0;
                    float v245 = *(float *)(v320 + 4 * (int)v233);
                    unsigned int v246 = v354 + 1;
                    uint64_t v247 = v312 + 4 * (int)v240;
                    do
                    {
                      *(float *)(v232 + v244) = atan2f(v245, *(float *)(v247 + v244));
                      --v246;
                      v244 += 4;
                    }
                    while (v246 > 1);
                  }
                  v231 += (int)v354;
                  v232 += 4 * (int)v354;
                  uint64_t v32 = v345;
                }
                while (v231 < v327);
              }
            }
          }
          break;
        case 2:
          if (v35 == 2)
          {
            uint64_t v308 = *v30;
            if (v308)
            {
              uint64_t v160 = 0;
              uint64_t v161 = 0;
              uint64_t v162 = 0;
              uint64_t v285 = *(void *)(v29 + 152);
              uint64_t v336 = v37[19];
              uint64_t v163 = v28[19];
              unint64_t v164 = v288[1];
              int v165 = *(uint64_t **)(v29 + 24);
              uint64_t v166 = *v165;
              uint64_t v167 = v165[1];
              int v168 = (void *)v37[3];
              if (v164 <= 1) {
                uint64_t v169 = 1;
              }
              else {
                uint64_t v169 = v288[1];
              }
              uint64_t v343 = v169;
              uint64_t v351 = v168[1];
              uint64_t v298 = v166 - v167 * v164;
              int v303 = v288[1];
              uint64_t v293 = *v168 - v351 * *(int *)(v38 + 4);
              uint64_t v170 = v167;
              uint64_t v171 = 4 * v167;
              do
              {
                uint64_t v317 = v160;
                if (v303)
                {
                  uint64_t v172 = 0;
                  uint64_t v173 = v285 + 4 * v162;
                  do
                  {
                    if ((int)v354 >= 1)
                    {
                      uint64_t v174 = 0;
                      float v175 = *(float *)(v336 + 4 * v161);
                      unsigned int v176 = v354 + 1;
                      do
                      {
                        *(float *)(v163 + v174) = atan2f(*(float *)(v173 + v174), v175);
                        --v176;
                        v174 += 4;
                      }
                      while (v176 > 1);
                    }
                    v162 += v170;
                    v161 += v351;
                    v163 += 4 * (int)v354;
                    ++v172;
                    v173 += v171;
                  }
                  while (v172 != v343);
                }
                v162 += v298;
                v161 += v293;
                uint64_t v160 = v317 + 1;
              }
              while (v317 + 1 != v308);
            }
          }
          else
          {
            uint64_t v334 = *v5;
            if (v35 == 1)
            {
              uint64_t v139 = *v30;
              if (v139)
              {
                uint64_t v140 = 0;
                uint64_t v141 = 0;
                uint64_t v142 = *(void *)(v29 + 152);
                uint64_t v349 = v37[19];
                uint64_t v143 = v28[19];
                uint64_t v144 = **(void **)(v29 + 24);
                uint64_t v145 = *(void *)v37[3];
                uint64_t v146 = 4 * v144;
                do
                {
                  if ((int)v354 >= 1)
                  {
                    uint64_t v147 = 0;
                    float v148 = *(float *)(v349 + 4 * v141);
                    unsigned int v149 = v354 + 1;
                    do
                    {
                      *(float *)(v143 + v147) = atan2f(*(float *)(v142 + v147), v148);
                      --v149;
                      v147 += 4;
                    }
                    while (v149 > 1);
                  }
                  v141 += v145;
                  ++v140;
                  v143 += 4 * (int)v354;
                  v142 += v146;
                }
                while (v140 != v139);
              }
            }
            else
            {
              unint64_t v326 = v28[6];
              if (v326)
              {
                unint64_t v213 = 0;
                uint64_t v311 = v37[19];
                uint64_t v319 = *(void *)(v29 + 152);
                uint64_t v214 = v28[19];
                do
                {
                  uint64_t v215 = 0;
                  if ((v32 & 0x80000000) != 0)
                  {
                    uint64_t v219 = v289;
                  }
                  else
                  {
                    uint64_t v216 = *(void *)(v29 + 24);
                    uint64_t v217 = v32;
                    int v218 = v213;
                    uint64_t v219 = v289;
                    do
                    {
                      ldiv_t v220 = ldiv(v218, v288[v217]);
                      int v218 = v220.quot;
                      v215 += *(void *)(v216 + 8 * v217--) * v220.rem;
                    }
                    while (v217 != -1);
                  }
                  uint64_t v221 = v339;
                  if ((v339 & 0x80000000) != 0)
                  {
                    LODWORD(v222) = 0;
                  }
                  else
                  {
                    uint64_t v222 = 0;
                    uint64_t v223 = v334[3];
                    int v224 = v213;
                    do
                    {
                      ldiv_t v225 = ldiv(v224, *(int *)(v219 + 4 * v221));
                      int v224 = v225.quot;
                      v222 += *(void *)(v223 + 8 * v221--) * v225.rem;
                    }
                    while (v221 != -1);
                  }
                  if ((int)v354 >= 1)
                  {
                    uint64_t v226 = 0;
                    float v227 = *(float *)(v311 + 4 * (int)v222);
                    uint64_t v228 = v215 << 32;
                    unsigned int v229 = v354 + 1;
                    uint64_t v230 = v319 + (v228 >> 30);
                    do
                    {
                      *(float *)(v214 + v226) = atan2f(*(float *)(v230 + v226), v227);
                      --v229;
                      v226 += 4;
                    }
                    while (v229 > 1);
                  }
                  v213 += (int)v354;
                  v214 += 4 * (int)v354;
                  uint64_t v32 = v345;
                }
                while (v213 < v326);
              }
            }
          }
          break;
        case 3:
          if (v35 == 2)
          {
            uint64_t v305 = *v30;
            if (v305)
            {
              uint64_t v195 = 0;
              uint64_t v196 = 0;
              uint64_t v197 = 0;
              uint64_t v282 = v37[19];
              uint64_t v287 = *(void *)(v29 + 152);
              uint64_t v198 = v28[19];
              unint64_t v199 = v288[1];
              unsigned int v200 = *(uint64_t **)(v29 + 24);
              uint64_t v201 = *v200;
              uint64_t v202 = v200[1];
              uint64_t v203 = (void *)v37[3];
              uint64_t v204 = v203[1];
              if (v199 <= 1) {
                uint64_t v205 = 1;
              }
              else {
                uint64_t v205 = v288[1];
              }
              uint64_t v295 = v201 - v202 * v199;
              int v300 = v288[1];
              uint64_t v353 = v205;
              uint64_t v290 = *v203 - v204 * *(int *)(v38 + 4);
              uint64_t v206 = v203[1];
              uint64_t v207 = v202;
              uint64_t v325 = 4 * v202;
              uint64_t v338 = 4 * v204;
              do
              {
                uint64_t v310 = v195;
                if (v300)
                {
                  uint64_t v208 = 0;
                  uint64_t v209 = v282 + 4 * v196;
                  uint64_t v210 = v287 + 4 * v197;
                  do
                  {
                    if ((int)v354 >= 1)
                    {
                      uint64_t v211 = 0;
                      unsigned int v212 = v354 + 1;
                      do
                      {
                        *(float *)(v198 + v211) = atan2f(*(float *)(v210 + v211), *(float *)(v209 + v211));
                        --v212;
                        v211 += 4;
                      }
                      while (v212 > 1);
                    }
                    v197 += v207;
                    v196 += v206;
                    v198 += 4 * (int)v354;
                    ++v208;
                    v209 += v338;
                    v210 += v325;
                  }
                  while (v208 != v353);
                }
                v197 += v295;
                v196 += v290;
                uint64_t v195 = v310 + 1;
              }
              while (v310 + 1 != v305);
            }
          }
          else
          {
            int v329 = *v5;
            if (v35 == 1)
            {
              uint64_t v60 = *v30;
              if (v60)
              {
                uint64_t v61 = 0;
                uint64_t v62 = *(void *)(v29 + 152);
                uint64_t v63 = v37[19];
                uint64_t v64 = v28[19];
                uint64_t v65 = 4 * *(void *)v37[3];
                uint64_t v66 = 4 * **(void **)(v29 + 24);
                do
                {
                  if ((int)v354 >= 1)
                  {
                    uint64_t v67 = 0;
                    unsigned int v68 = v354 + 1;
                    do
                    {
                      *(float *)(v64 + v67) = atan2f(*(float *)(v62 + v67), *(float *)(v63 + v67));
                      --v68;
                      v67 += 4;
                    }
                    while (v68 > 1);
                  }
                  ++v61;
                  v64 += 4 * (int)v354;
                  v63 += v65;
                  v62 += v66;
                }
                while (v61 != v60);
              }
            }
            else
            {
              unint64_t v328 = v28[6];
              if (v328)
              {
                unint64_t v248 = 0;
                uint64_t v313 = v37[19];
                uint64_t v321 = *(void *)(v29 + 152);
                uint64_t v249 = v28[19];
                do
                {
                  uint64_t v250 = 0;
                  if ((v32 & 0x80000000) != 0)
                  {
                    uint64_t v254 = v289;
                  }
                  else
                  {
                    uint64_t v251 = *(void *)(v29 + 24);
                    uint64_t v252 = v32;
                    int v253 = v248;
                    uint64_t v254 = v289;
                    do
                    {
                      ldiv_t v255 = ldiv(v253, v288[v252]);
                      int v253 = v255.quot;
                      v250 += *(void *)(v251 + 8 * v252--) * v255.rem;
                    }
                    while (v252 != -1);
                  }
                  uint64_t v256 = v339;
                  if ((v339 & 0x80000000) != 0)
                  {
                    LODWORD(v257) = 0;
                  }
                  else
                  {
                    uint64_t v257 = 0;
                    uint64_t v258 = v329[3];
                    int v259 = v248;
                    do
                    {
                      ldiv_t v260 = ldiv(v259, *(int *)(v254 + 4 * v256));
                      int v259 = v260.quot;
                      v257 += *(void *)(v258 + 8 * v256--) * v260.rem;
                    }
                    while (v256 != -1);
                  }
                  if ((int)v354 >= 1)
                  {
                    uint64_t v261 = 0;
                    uint64_t v262 = v313 + 4 * (int)v257;
                    uint64_t v263 = v250 << 32;
                    unsigned int v264 = v354 + 1;
                    uint64_t v265 = v321 + (v263 >> 30);
                    do
                    {
                      *(float *)(v249 + v261) = atan2f(*(float *)(v265 + v261), *(float *)(v262 + v261));
                      --v264;
                      v261 += 4;
                    }
                    while (v264 > 1);
                  }
                  v248 += (int)v354;
                  v249 += 4 * (int)v354;
                  uint64_t v32 = v345;
                }
                while (v248 < v328);
              }
            }
          }
          break;
        default:
LABEL_60:
          switch(v49)
          {
            case 1uLL:
              uint64_t v53 = v28[6];
              if (v53)
              {
                uint64_t v54 = *(float **)(v29 + 152);
                int v55 = (float *)v37[19];
                uint64_t v56 = (float *)v28[19];
                uint64_t v57 = **(void **)(v29 + 24);
                uint64_t v58 = 4 * *(void *)v37[3];
                uint64_t v59 = 4 * v57;
                do
                {
                  *v56++ = atan2f(*v54, *v55);
                  int v55 = (float *)((char *)v55 + v58);
                  uint64_t v54 = (float *)((char *)v54 + v59);
                  --v53;
                }
                while (v53);
              }
              break;
            case 2uLL:
              uint64_t v357 = *v30;
              if (v357)
              {
                uint64_t v110 = 0;
                uint64_t v111 = 0;
                uint64_t v112 = 0;
                uint64_t v113 = 0;
                uint64_t v114 = *(void *)(v29 + 152);
                uint64_t v115 = v37[19];
                uint64_t v324 = v28[19];
                unint64_t v116 = v288[1];
                int v117 = *(uint64_t **)(v29 + 24);
                uint64_t v118 = *v117;
                uint64_t v119 = v117[1];
                unsigned int v120 = (void *)v37[3];
                uint64_t v121 = v120[1];
                uint64_t v342 = *v120 - v121 * *(int *)(v38 + 4);
                int v348 = v288[1];
                if (v116 <= 1) {
                  uint64_t v122 = 1;
                }
                else {
                  uint64_t v122 = v288[1];
                }
                uint64_t v316 = v122;
                uint64_t v332 = v118 - v119 * v116;
                do
                {
                  if (v348)
                  {
                    uint64_t v123 = v316;
                    uint64_t v124 = v111 + v316;
                    int v125 = (float *)(v324 + 4 * v111);
                    do
                    {
                      *v125++ = atan2f(*(float *)(v114 + 4 * v113), *(float *)(v115 + 4 * v112));
                      v113 += v119;
                      v112 += v121;
                      --v123;
                    }
                    while (v123);
                    uint64_t v111 = v124;
                  }
                  v113 += v332;
                  v112 += v342;
                  ++v110;
                }
                while (v110 != v357);
              }
              break;
            case 3uLL:
              uint64_t v306 = *v30;
              if (v306)
              {
                uint64_t v69 = 0;
                uint64_t v70 = 0;
                uint64_t v71 = 0;
                uint64_t v72 = 0;
                uint64_t v73 = *(void *)(v29 + 152);
                uint64_t v74 = v37[19];
                uint64_t v75 = v28[19];
                unint64_t v76 = v288[1];
                unsigned int v77 = *(void **)(v29 + 24);
                uint64_t v78 = *v77;
                uint64_t v79 = v77[1];
                uint64_t v280 = v79;
                unsigned int v283 = v77;
                int v80 = (void *)v37[3];
                uint64_t v276 = v80[1];
                int v278 = v80;
                uint64_t v296 = *v80 - v276 * *(int *)(v38 + 4);
                int v301 = v288[1];
                if (v76 <= 1) {
                  uint64_t v81 = 1;
                }
                else {
                  uint64_t v81 = v288[1];
                }
                uint64_t v322 = v81;
                uint64_t v291 = v78 - v79 * v76;
                do
                {
                  uint64_t v314 = v69;
                  if (v301)
                  {
                    uint64_t v82 = 0;
                    unint64_t v83 = v288[2];
                    uint64_t v84 = v283[2];
                    uint64_t v85 = v278[2];
                    if (v83 <= 1) {
                      uint64_t v86 = 1;
                    }
                    else {
                      uint64_t v86 = v288[2];
                    }
                    uint64_t v346 = v86;
                    int v355 = v288[2];
                    uint64_t v330 = v276 - v85 * *(int *)(v289 + 8);
                    uint64_t v340 = v280 - v84 * v83;
                    do
                    {
                      uint64_t v87 = v346;
                      if (v355)
                      {
                        do
                        {
                          *(float *)(v75 + 4 * v70++) = atan2f(*(float *)(v73 + 4 * v72), *(float *)(v74 + 4 * v71));
                          v72 += v84;
                          v71 += v85;
                          --v87;
                        }
                        while (v87);
                      }
                      v72 += v340;
                      v71 += v330;
                      ++v82;
                    }
                    while (v82 != v322);
                  }
                  v72 += v291;
                  v71 += v296;
                  uint64_t v69 = v314 + 1;
                }
                while (v314 + 1 != v306);
              }
              break;
            case 4uLL:
              uint64_t v274 = *v30;
              if (v274)
              {
                uint64_t v88 = 0;
                uint64_t v89 = 0;
                uint64_t v90 = 0;
                uint64_t v91 = 0;
                uint64_t v92 = *(void *)(v29 + 152);
                uint64_t v93 = v37[19];
                uint64_t v94 = v28[19];
                unint64_t v95 = v288[1];
                unint64_t v96 = *(void **)(v29 + 24);
                uint64_t v97 = *v96;
                uint64_t v98 = v96[1];
                unint64_t v284 = v96;
                uint64_t v99 = (void *)v37[3];
                unsigned int v281 = v99;
                uint64_t v269 = v99[1];
                uint64_t v270 = v98;
                uint64_t v272 = *v99 - v269 * *(int *)(v38 + 4);
                int v273 = v288[1];
                if (v95 <= 1) {
                  uint64_t v100 = 1;
                }
                else {
                  uint64_t v100 = v288[1];
                }
                uint64_t v292 = v100;
                uint64_t v271 = v97 - v98 * v95;
                do
                {
                  uint64_t v275 = v88;
                  if (v273)
                  {
                    uint64_t v101 = 0;
                    unint64_t v102 = v288[2];
                    if (v102 <= 1) {
                      uint64_t v103 = 1;
                    }
                    else {
                      uint64_t v103 = v288[2];
                    }
                    uint64_t v323 = v103;
                    uint64_t v277 = v281[2];
                    uint64_t v279 = v284[2];
                    uint64_t v302 = v270 - v279 * v102;
                    int v307 = v288[2];
                    uint64_t v297 = v269 - v277 * *(int *)(v289 + 8);
                    do
                    {
                      uint64_t v315 = v101;
                      if (v307)
                      {
                        uint64_t v104 = 0;
                        unint64_t v105 = v288[3];
                        uint64_t v106 = v284[3];
                        uint64_t v107 = v281[3];
                        if (v105 <= 1) {
                          uint64_t v108 = 1;
                        }
                        else {
                          uint64_t v108 = v288[3];
                        }
                        uint64_t v347 = v108;
                        int v356 = v288[3];
                        uint64_t v331 = v277 - v107 * *(int *)(v289 + 12);
                        uint64_t v341 = v279 - v106 * v105;
                        do
                        {
                          uint64_t v109 = v347;
                          if (v356)
                          {
                            do
                            {
                              *(float *)(v94 + 4 * v89++) = atan2f(*(float *)(v92 + 4 * v91), *(float *)(v93 + 4 * v90));
                              v91 += v106;
                              v90 += v107;
                              --v109;
                            }
                            while (v109);
                          }
                          v91 += v341;
                          v90 += v331;
                          ++v104;
                        }
                        while (v104 != v323);
                      }
                      v91 += v302;
                      v90 += v297;
                      uint64_t v101 = v315 + 1;
                    }
                    while (v315 + 1 != v292);
                  }
                  v91 += v271;
                  v90 += v272;
                  uint64_t v88 = v275 + 1;
                }
                while (v275 + 1 != v274);
              }
              break;
            default:
              uint64_t v333 = *v5;
              uint64_t v126 = v28[6];
              if (v126)
              {
                uint64_t v127 = 0;
                uint64_t v358 = *(void *)(v29 + 152);
                uint64_t v128 = v37[19];
                uint64_t v129 = v28[19];
                do
                {
                  uint64_t v130 = 0;
                  if ((v32 & 0x80000000) == 0)
                  {
                    uint64_t v131 = *(void *)(v29 + 24);
                    int v132 = v127;
                    do
                    {
                      ldiv_t v133 = ldiv(v132, v288[v32]);
                      int v132 = v133.quot;
                      v130 += *(void *)(v131 + 8 * v32--) * v133.rem;
                    }
                    while (v32 != -1);
                  }
                  uint64_t v134 = v339;
                  if ((v339 & 0x80000000) != 0)
                  {
                    LODWORD(v135) = 0;
                  }
                  else
                  {
                    uint64_t v135 = 0;
                    uint64_t v136 = v333[3];
                    int v137 = v127;
                    do
                    {
                      ldiv_t v138 = ldiv(v137, *(int *)(v289 + 4 * v134));
                      int v137 = v138.quot;
                      v135 += *(void *)(v136 + 8 * v134--) * v138.rem;
                    }
                    while (v134 != -1);
                  }
                  *(float *)(v129 + 4 * v127++) = atan2f(*(float *)(v358 + 4 * (int)v130), *(float *)(v128 + 4 * (int)v135));
                  uint64_t v32 = v345;
                }
                while (v127 != v126);
              }
              break;
          }
          break;
      }
      return;
  }
}

void sub_256E6C1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
  if (a38 < 0)
  {
    operator delete(__p);
    if ((v40 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a39);
      _Unwind_Resume(a1);
    }
  }
  else if (!v40)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v39);
  goto LABEL_6;
}

void mlx::core::BitwiseBinary::output_shapes(uint64_t **a1@<X1>, void *a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v3 = **a1;
  BOOL v6 = 0;
  uint64_t v7 = 0;
  __p = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)v3, *(void *)(v3 + 8), (uint64_t)(*(void *)(v3 + 8) - *(void *)v3) >> 2);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v4 = operator new(0x18uLL);
  *a2 = v4;
  a2[1] = v4;
  a2[2] = v4 + 3;
  a2[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<int>>,std::vector<int> const*,std::vector<int> const*,std::vector<int>*>((uint64_t)(a2 + 2), (uint64_t)&__p, (uint64_t)&v8, v4);
  if (__p)
  {
    BOOL v6 = __p;
    operator delete(__p);
  }
}

void sub_256E6C330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  uint64_t v14 = v13;
  *(void *)(v12 + 8) = v14;
  std::vector<std::vector<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
  if (__p)
  {
    a12 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void mlx::core::BitwiseBinary::~BitwiseBinary(mlx::core::BitwiseBinary *this)
{
}

void sub_256E6C934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<int>>,std::vector<int> const*,std::vector<int> const*,std::vector<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v4 = a4;
  int v10 = a4;
  unsigned int v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::vector<int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_256E6CA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::vector<int>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned long>>,std::vector<unsigned long>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

float mlx::core::detail::LogAddExp::operator()<float>(float a1, float a2)
{
  if (a1 <= a2) {
    float v2 = a2;
  }
  else {
    float v2 = a1;
  }
  if (a1 >= a2) {
    a1 = a2;
  }
  if (a1 != -INFINITY && v2 != INFINITY)
  {
    float v4 = a1 - v2;
    float v5 = 0.0;
    if (v4 != -INFINITY)
    {
      float v5 = v4;
      if (v4 != INFINITY)
      {
        float v6 = v4 * 1.442695;
        if (v6 > 80.0) {
          float v6 = 80.0;
        }
        float v7 = fmaxf(v6, -80.0);
        float v8 = floor(v7 + 0.5);
        float v9 = v7 - v8;
        float v5 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v9 * 0.00015353) + 0.0013399)
                                                                                           * v9)
                                                                                   + 0.0096184)
                                                                           * v9)
                                                                   + 0.055503)
                                                           * v9)
                                                   + 0.24023)
                                           * v9)
                                   + 0.69315)
                           * v9)
                   + 1.0)
           * COERCE_FLOAT(((int)v8 << 23) + 1065353216);
      }
    }
    return v2 + log1pf(v5);
  }
  return v2;
}

void mlx_device_::tostring(mlx_device_ *this)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v3);
  mlx::core::operator<<(&v3, (_DWORD *)this + 4);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v4, __p);
  operator new();
}

void sub_256E6CDB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  MEMORY[0x25A2B1780](v16, 0x1093C401FB1DE5ELL);
  if (a15 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void mlx_device_new()
{
}

uint64_t mlx_device_get_type(uint64_t a1)
{
}

BOOL mlx_device_equal(uint64_t a1, uint64_t a2)
{
  return mlx::core::operator==((_DWORD *)(a1 + 16), (_DWORD *)(a2 + 16));
}

void mlx_default_device()
{
}

void sub_256E6CEF4(_Unwind_Exception *a1)
{
  MEMORY[0x25A2B1780](v1, 0x1081C40468F112ELL);
  _Unwind_Resume(a1);
}

uint64_t mlx_set_default_device(uint64_t a1)
{
  return a1;
}

void mlx_device_::~mlx_device_(mlx_device_ *this)
{
}

uint64_t mlx::core::default_device(mlx::core *this)
{
  return 0;
}

uint64_t mlx::core::set_default_device(mlx::core::metal *a1)
{
  uint64_t result = mlx::core::metal::is_available(a1);
  if ((result & 1) == 0 && *(_DWORD *)a1 == 1 && *((_DWORD *)a1 + 1) == 0)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[set_default_device] Cannot set gpu device without gpu backend.");
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_256E6CFD4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL mlx::core::operator==(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL mlx::core::operator!=(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1];
}

int ***mlx::core::random::KeySequence::KeySequence(int ***this, mlx::core::random *a2)
{
  return this;
}

{
  mlx::core::random::key(a2, this);
  return this;
}

int ***mlx::core::random::key@<X0>(mlx::core::random *this@<X0>, int ***a2@<X8>)
{
  v5[1] = *MEMORY[0x263EF8340];
  v5[0] = __ROR8__(this, 32);
  uint64_t v3 = mlx::core::TypeToDtype<unsigned int>::operator mlx::core::Dtype();
  return mlx::core::array::array<unsigned int>(a2, (unsigned int *)v5, 2, v3);
}

void mlx::core::random::KeySequence::seed(mlx::core::random::KeySequence *this, mlx::core::random *a2)
{
  mlx::core::random::key(a2, (int ***)&v5);
  long long v3 = v5;
  long long v5 = 0uLL;
  float v4 = (std::__shared_weak_count *)*((void *)this + 1);
  *(_OWORD *)this = v3;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  mlx::core::array::~array((mlx::core::array *)&v5);
}

void mlx::core::random::KeySequence::next(mlx::core::random::KeySequence *this@<X0>, mlx::core *a2@<X1>, void *a3@<X8>)
{
  mlx::core::random::split(this, a2, 0, &v6);
  mlx::core::array::operator=(this, (uint64_t *)&v6);
  uint64_t v5 = v7[1];
  *a3 = v7[0];
  a3[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  mlx::core::array::~array((mlx::core::array *)v7);
  mlx::core::array::~array((mlx::core::array *)&v6);
}

void sub_256E6D1BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  mlx::core::array::~array((mlx::core::array *)(v9 + 16));
  mlx::core::array::~array((mlx::core::array *)&a9);
  _Unwind_Resume(a1);
}

void mlx::core::random::split(void *a1@<X0>, mlx::core *a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  long long v6 = mlx::core::to_stream(a2, a3);
  uint64_t v8 = v7 | 0x100000000;
  mlx::core::random::split(a1, 2u, (uint64_t)v6, v8);
  mlx::core::split((mlx::core::array *)&v22, 2, v6, v8, v23);
  mlx::core::array::~array((mlx::core::array *)&v22);
  uint64_t v9 = (const void ***)v23[0];
  int v10 = operator new(4uLL);
  float v19 = v10;
  *int v10 = 2;
  float v20 = v10 + 1;
  uint64_t v21 = v10 + 1;
  mlx::core::reshape(v9, (uint64_t)&v19, v6, v8, (const void ***)&v22);
  uint64_t v11 = v23[0];
  uint64_t v12 = operator new(4uLL);
  __p = v12;
  *uint64_t v12 = 2;
  uint64_t v16 = v12 + 1;
  unsigned int v17 = v12 + 1;
  mlx::core::reshape((const void ***)(v11 + 16), (uint64_t)&__p, v6, v8, (const void ***)&v18);
  long long v13 = v22;
  long long v22 = 0uLL;
  long long v14 = v18;
  *a4 = v13;
  a4[1] = v14;
  long long v18 = 0uLL;
  mlx::core::array::~array((mlx::core::array *)&v18);
  if (__p)
  {
    uint64_t v16 = __p;
    operator delete(__p);
  }
  mlx::core::array::~array((mlx::core::array *)&v22);
  if (v19)
  {
    float v20 = v19;
    operator delete(v19);
  }
  *(void *)&long long v22 = v23;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v22);
}

void sub_256E6D32C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  mlx::core::array::~array((mlx::core::array *)&a19);
  if (a16) {
    operator delete(a16);
  }
  a19 = v19 - 56;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  _Unwind_Resume(a1);
}

void *mlx::core::array::operator=(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a1 != *a2)
  {
    uint64_t v4 = a2[1];
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = (std::__shared_weak_count *)a1[1];
    *a1 = v3;
    a1[1] = v4;
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
  return a1;
}

void mlx::core::random::seed(mlx::core::random *this)
{
  float v2 = (mlx::core::random::KeySequence *)mlx::core::random::KeySequence::default_(this);
  mlx::core::random::KeySequence::seed(v2, this);
}

void *mlx::core::random::KeySequence::default_(mlx::core::random::KeySequence *this)
{
  {
    v2.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    mlx::core::random::key((mlx::core::random *)(v2.__d_.__rep_ / 1000), (int ***)&mlx::core::random::KeySequence::default_(void)::ks);
    __cxa_atexit((void (*)(void *))mlx::core::random::KeySequence::~KeySequence, &mlx::core::random::KeySequence::default_(void)::ks, &dword_256D65000);
  }
  return &mlx::core::random::KeySequence::default_(void)::ks;
}

void sub_256E6D4CC(_Unwind_Exception *a1)
{
}

void mlx::core::random::bits(uint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, mlx::core *a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  v43[2] = *MEMORY[0x263EF8340];
  int v39 = a2;
  if (*(unsigned char *)(a3 + 16))
  {
    uint64_t v12 = *(int ***)a3;
    uint64_t v11 = *(void *)(a3 + 8);
    char v37 = *(int ***)a3;
    uint64_t v38 = v11;
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    long long v13 = (mlx::core::random::KeySequence *)mlx::core::random::KeySequence::default_((mlx::core::random::KeySequence *)a1);
    mlx::core::random::KeySequence::next(v13, v14, &v37);
    uint64_t v12 = v37;
  }
  if (*((_DWORD *)v12 + 14) != 2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
    float v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Expected key type uint32 but received ", 38);
    v40.__r_.__value_.__r.__words[0] = (std::string::size_type)v37[7];
    uint64_t v24 = mlx::core::operator<<(v23, &v40);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)".", 1);
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v42, &v40);
    std::logic_error::logic_error(exception, &v40);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  unsigned int v15 = (int *)operator new(4uLL);
  *unsigned int v15 = 2;
  if ((char *)v12[1] - (char *)*v12 != 4)
  {
    operator delete(v15);
LABEL_25:
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
    unsigned int v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Expected key shape (2) but received ", 36);
    float v27 = mlx::core::operator<<(v26, v37);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)".", 1);
    int v28 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v42, &v40);
    std::logic_error::logic_error(v28, &v40);
    v28->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(v28, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  int v16 = **v12;
  int v17 = *v15;
  operator delete(v15);
  if (v16 != v17) {
    goto LABEL_25;
  }
  memset(__p, 0, sizeof(__p));
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(__p, (const void *)*a1, a1[1], (a1[1] - *a1) >> 2);
  if (a2 == 4)
  {
    uint64_t v18 = 0x400000002;
  }
  else
  {
    if (a2 != 1)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"[bits] Bit width must be in {1, 2, 4} but got ", 46);
      uint64_t v29 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)".", 1);
      int v30 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v42, &v40);
      std::logic_error::logic_error(v30, &v40);
      v30->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(v30, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
    }
    uint64_t v18 = 0x100000001;
  }
  int v33 = mlx::core::to_stream(a4, a5);
  int v34 = v19;
  std::allocate_shared[abi:ne180100]<mlx::core::RandomBits,std::allocator<mlx::core::RandomBits>,mlx::core::Stream,std::vector<int> const&,int &,void>((uint64_t *)&v33, (uint64_t)a1, &v39, &v40);
  long long v35 = *(_OWORD *)&v40.__r_.__value_.__l.__data_;
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v21 = v37;
  uint64_t v20 = v38;
  v43[0] = v37;
  v43[1] = v38;
  if (v38) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
  }
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  int v41 = (void **)&v31;
  v42[0] = 0;
  long long v22 = operator new(0x10uLL);
  *(void *)&long long v31 = v22;
  uint64_t v32 = v22 + 2;
  *long long v22 = v21;
  v22[1] = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)&v31 + 1) = v22 + 2;
  mlx::core::array::array(a6, (long long *)__p, v18, &v35, &v31);
  int v41 = (void **)&v31;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v41);
  mlx::core::array::~array((mlx::core::array *)v43);
  if (*((void *)&v35 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v35 + 1));
  }
  if (v40.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v40.__r_.__value_.__l.__size_);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  mlx::core::array::~array((mlx::core::array *)&v37);
}

void sub_256E6D90C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30)
{
  if (a28 < 0)
  {
    operator delete(__p);
    if ((v31 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a30);
      if (a17) {
        operator delete(a17);
      }
      mlx::core::array::~array((mlx::core::array *)&a20);
      _Unwind_Resume(a1);
    }
  }
  else if (!v31)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v30);
  goto LABEL_6;
}

void mlx::core::random::split(void *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = operator new(8uLL);
  __p = v8;
  void *v8 = a2 | 0x200000000;
  long long v13 = v8 + 1;
  long long v14 = v8 + 1;
  uint64_t v9 = a1[1];
  v10[0] = *a1;
  v10[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  char v11 = 1;
  mlx::core::random::bits(&__p, 4, v10, a3, a4);
  if (v11) {
    mlx::core::array::~array((mlx::core::array *)v10);
  }
  if (__p)
  {
    long long v13 = __p;
    operator delete(__p);
  }
}

void sub_256E6DAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *__p, uint64_t a13)
{
  if (a11) {
    mlx::core::array::~array((mlx::core::array *)&a9);
  }
  if (__p)
  {
    a13 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::random::uniform(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, mlx::core *a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  uint64_t v44 = a4;
  if ((mlx::core::issubdtype((unsigned int *)&v44, mlx::core::floating) & 1) == 0)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Can only generate uniform numbers with real floating point type.");
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  int v16 = mlx::core::to_stream(a6, a7);
  uint64_t v17 = a1[1];
  v42[0] = *a1;
  v42[1] = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = v15 | 0x100000000;
  mlx::core::astype(v42, v44, v16, v18, v43);
  mlx::core::array::~array((mlx::core::array *)v42);
  uint64_t v19 = a2[1];
  v40[0] = *a2;
  v40[1] = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  mlx::core::astype(v40, v44, v16, v18, v41);
  mlx::core::array::~array((mlx::core::array *)v40);
  mlx::core::subtract(v41, v43, v16, v18, v39);
  mlx::core::broadcast_shapes(a3, v39[0], &v38);
  if ((char *)v38.__end_ - (char *)v38.__begin_ != a3[1] - *a3
    || memcmp(v38.__begin_, (const void *)*a3, (char *)v38.__end_ - (char *)v38.__begin_))
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v36);
    float v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Cannot generate random values of shape ", 39);
    int v28 = mlx::core::operator<<(v27, a3);
    uint64_t v29 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)" from broadcasted shape ", 24);
    int v30 = mlx::core::operator<<(v29, &v38);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)".", 1);
    int v31 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v36 + 8, &v35);
    std::logic_error::logic_error(v31, &v35);
    v31->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(v31, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  if (v44 != 6)
  {
    int v33 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x25A2B1470](v33, "[uniform] Unsupported type.");
    __cxa_throw(v33, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  float v20 = nextafterf(1.0, 0.0);
  mlx::core::array::array<float>((int ***)&v35, 0x400000006, v20);
  uint64_t v21 = mlx::core::array::array<unsigned int>((int ***)&v45, 0xFFFFFFFF, 0x400000006);
  long long v22 = *(_OWORD *)&v35.__r_.__value_.__l.__data_;
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = 0uLL;
  long long v36 = v22;
  v37[0] = v45;
  long long v45 = 0uLL;
  mlx::core::array::~array((mlx::core::array *)v21);
  mlx::core::array::~array((mlx::core::array *)&v35);
  mlx::core::random::bits(a3, BYTE4(v44), a5, v16, v18, &v35);
  mlx::core::divide(&v35, v37, v16, v18, v34);
  mlx::core::astype(v34, v44, v16, v18, &v45);
  long long v23 = v45;
  long long v45 = 0uLL;
  size = (std::__shared_weak_count *)v35.__r_.__value_.__l.__size_;
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v23;
  if (size) {
    std::__shared_weak_count::__release_shared[abi:ne180100](size);
  }
  mlx::core::array::~array((mlx::core::array *)&v45);
  mlx::core::array::~array((mlx::core::array *)v34);
  mlx::core::minimum(&v35, &v36, v16, v18, &v45);
  long long v25 = v45;
  long long v45 = 0uLL;
  unsigned int v26 = (std::__shared_weak_count *)v35.__r_.__value_.__l.__size_;
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v25;
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  }
  mlx::core::array::~array((mlx::core::array *)&v45);
  mlx::core::multiply(v39, &v35, v16, v18, &v45);
  mlx::core::add(&v45, v43, v16, v18, a8);
  mlx::core::array::~array((mlx::core::array *)&v45);
  mlx::core::array::~array((mlx::core::array *)&v35);
  mlx::core::array::~array((mlx::core::array *)v37);
  mlx::core::array::~array((mlx::core::array *)&v36);
  if (v38.__begin_)
  {
    v38.__end_ = v38.__begin_;
    operator delete(v38.__begin_);
  }
  mlx::core::array::~array((mlx::core::array *)v39);
  mlx::core::array::~array((mlx::core::array *)v41);
  mlx::core::array::~array((mlx::core::array *)v43);
}

void sub_256E6DF10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((v19 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a18);
      long long v22 = *(void **)(v20 - 192);
      if (v22)
      {
        *(void *)(v20 - 184) = v22;
        operator delete(v22);
      }
      mlx::core::array::~array((mlx::core::array *)(v20 - 168));
      mlx::core::array::~array((mlx::core::array *)(v20 - 136));
      mlx::core::array::~array((mlx::core::array *)(v20 - 104));
      _Unwind_Resume(a1);
    }
  }
  else if (!v19)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v18);
  goto LABEL_6;
}

void mlx::core::random::uniform(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, mlx::core *a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  mlx::core::array::array<double>(v15, a2, 0.0);
  mlx::core::array::array<double>(v14, a2, 1.0);
  uint64_t v12 = mlx::core::to_stream(a4, a5);
  mlx::core::random::uniform(v15, v14, a1, a2, a3, v12, v13 | 0x100000000, a6);
  mlx::core::array::~array((mlx::core::array *)v14);
  mlx::core::array::~array((mlx::core::array *)v15);
}

void sub_256E6E0D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  mlx::core::array::~array((mlx::core::array *)va);
  _Unwind_Resume(a1);
}

void mlx::core::random::normal(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, mlx::core *a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>, float a7@<S0>, float a8@<S1>)
{
  long long v14 = mlx::core::to_stream(a4, a5);
  unsigned int v16 = v15;
  float v17 = nextafterf(-1.0, 0.0);
  mlx::core::array::array<float>(v28, a2, v17);
  mlx::core::array::array<float>(v27, a2, 1.0);
  mlx::core::random::uniform(v28, v27, a1, a2, a3, v14, v16 | 0x100000000, a6);
  mlx::core::array::array<double>(v25, a2, 1.41421356);
  mlx::core::erfinv(a6, v14, v16 | 0x100000000, v24);
  mlx::core::multiply(v25, v24, v14, v16 | 0x100000000, &v26);
  long long v18 = v26;
  long long v26 = 0uLL;
  int v19 = (std::__shared_weak_count *)a6[1];
  *(_OWORD *)a6 = v18;
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
  mlx::core::array::~array((mlx::core::array *)&v26);
  mlx::core::array::~array((mlx::core::array *)v24);
  mlx::core::array::~array((mlx::core::array *)v25);
  if (a8 != 1.0)
  {
    mlx::core::array::array<float>(v25, a2, a8);
    mlx::core::multiply(v25, a6, v14, v16 | 0x100000000, &v26);
    long long v20 = v26;
    long long v26 = 0uLL;
    uint64_t v21 = (std::__shared_weak_count *)a6[1];
    *(_OWORD *)a6 = v20;
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
    mlx::core::array::~array((mlx::core::array *)&v26);
    mlx::core::array::~array((mlx::core::array *)v25);
  }
  if (a7 != 0.0)
  {
    mlx::core::array::array<float>(v25, a2, a7);
    mlx::core::add(v25, a6, v14, v16 | 0x100000000, &v26);
    long long v22 = v26;
    long long v26 = 0uLL;
    long long v23 = (std::__shared_weak_count *)a6[1];
    *(_OWORD *)a6 = v22;
    if (v23) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v23);
    }
    mlx::core::array::~array((mlx::core::array *)&v26);
    mlx::core::array::~array((mlx::core::array *)v25);
  }
  mlx::core::array::~array((mlx::core::array *)v27);
  mlx::core::array::~array((mlx::core::array *)v28);
}

void sub_256E6E2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  mlx::core::array::~array((mlx::core::array *)va);
  mlx::core::array::~array(v3);
  mlx::core::array::~array((mlx::core::array *)va1);
  mlx::core::array::~array((mlx::core::array *)va2);
  _Unwind_Resume(a1);
}

void sub_256E6E348()
{
}

void sub_256E6E350()
{
}

void mlx::core::random::multivariate_normal(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, mlx::core *a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  long long v14 = mlx::core::to_stream(a6, a7);
  if (a4 != 6)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[multivariate_normal] dtype must be float32.");
    goto LABEL_40;
  }
  unsigned int v16 = v15;
  float v17 = *(_DWORD **)*a1;
  long long v18 = *(unsigned char **)(*a1 + 8);
  if (v18 == (unsigned char *)v17)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[multivariate_normal] mean must have at least one dimension.");
    goto LABEL_40;
  }
  if (*(void *)(*(void *)a2 + 8) - **(void **)a2 <= 7uLL)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[multivariate_normal] cov must have at least two dimensions.");
    goto LABEL_40;
  }
  int v19 = *(_DWORD *)(*(void *)(*(void *)a2 + 8) - 4);
  if (v19 != *(_DWORD *)(*(void *)(*(void *)a2 + 8) - 8))
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[multivariate_normal] last two dimensions of cov must be equal.");
    goto LABEL_40;
  }
  int v20 = v17[((v18 - (unsigned char *)v17) >> 2) - 1];
  if (v20 != v19)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[multivariate_normal] mean and cov must have compatible shapes.");
LABEL_40:
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  uint64_t v21 = v14;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&v53, v17, (uint64_t)(v18 - 4), (v18 - 4 - (unsigned char *)v17) >> 2);
  long long v22 = **(const void ***)a2;
  uint64_t v23 = *(void *)(*(void *)a2 + 8) - 8;
  int v51 = 0;
  uint64_t v52 = 0;
  int v50 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&v50, v22, v23, (v23 - (uint64_t)v22) >> 2);
  mlx::core::broadcast_shapes(&v50, &v53, &__p);
  mlx::core::broadcast_shapes(&__p, a3, &v56);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
  begiunint64_t n = v56.__begin_;
  std::vector<int>::pointer end = v56.__end_;
  std::vector<int> __p = v56;
  if (v56.__end_ >= v56.__end_cap_.__value_)
  {
    int64_t v27 = v56.__end_ - v56.__begin_;
    unint64_t v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    int64_t v29 = (char *)v56.__end_cap_.__value_ - (char *)v56.__begin_;
    if (((char *)v56.__end_cap_.__value_ - (char *)v56.__begin_) >> 1 > v28) {
      unint64_t v28 = v29 >> 1;
    }
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30)
    {
      int v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&__p.__end_cap_, v30);
      begiunint64_t n = __p.__begin_;
      std::vector<int>::pointer end = __p.__end_;
    }
    else
    {
      int v31 = 0;
    }
    uint64_t v32 = (int *)&v31[4 * v27];
    int v33 = (int *)&v31[4 * v30];
    *uint64_t v32 = v20;
    long long v26 = v32 + 1;
    while (end != begin)
    {
      int v34 = *--end;
      *--uint64_t v32 = v34;
    }
    __p.__begin_ = v32;
    __p.__end_ = v26;
    __p.__end_cap_.__value_ = v33;
    if (begin) {
      operator delete(begin);
    }
  }
  else
  {
    *v56.__end_ = v20;
    long long v26 = end + 1;
  }
  __p.__end_ = v26;
  uint64_t v35 = *(void *)(a2 + 8);
  v47[0] = *(void *)a2;
  v47[1] = v35;
  if (v35) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v35 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v36 = v16 | 0x100000000;
  mlx::core::astype(v47, 0x400000006, v21, v36, v48);
  mlx::core::array::~array((mlx::core::array *)v47);
  mlx::core::linalg::svd(v48, v21, v36, v46);
  char v37 = (void *)v46[0];
  mlx::core::sqrt((void *)(v46[0] + 16), v21, v36, v42);
  mlx::core::expand_dims(v42, -2, v21, v36, v43);
  mlx::core::multiply(v37, v43, v21, v36, &v56);
  mlx::core::matmul(&v56, (void *)(v46[0] + 32), v21, v36, v44);
  mlx::core::astype(v44, a4, v21, v36, v45);
  mlx::core::array::~array((mlx::core::array *)v44);
  mlx::core::array::~array((mlx::core::array *)&v56);
  mlx::core::array::~array((mlx::core::array *)v43);
  mlx::core::array::~array((mlx::core::array *)v42);
  mlx::core::random::normal((uint64_t *)&__p, a4, a5, v21, v36, v43, 0.0, 1.0);
  mlx::core::expand_dims(v43, -2, v21, v36, v40);
  mlx::core::matmul(v40, v45, v21, v36, v41);
  std::vector<int> v38 = (int *)operator new(4uLL);
  v56.__begin_ = v38;
  int *v38 = -2;
  v56.__end_ = v38 + 1;
  v56.__end_cap_.__value_ = v38 + 1;
  mlx::core::squeeze((mlx::core::array *)v41, (unsigned int **)&v56, v21, v36, v42);
  if (v56.__begin_)
  {
    v56.__end_ = v56.__begin_;
    operator delete(v56.__begin_);
  }
  mlx::core::array::~array((mlx::core::array *)v41);
  mlx::core::array::~array((mlx::core::array *)v40);
  mlx::core::add(a1, v42, v21, v36, a8);
  mlx::core::array::~array((mlx::core::array *)v42);
  mlx::core::array::~array((mlx::core::array *)v43);
  mlx::core::array::~array((mlx::core::array *)v45);
  v56.__begin_ = (std::vector<int>::pointer)v46;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v56);
  mlx::core::array::~array((mlx::core::array *)v48);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
  if (v50)
  {
    int v51 = v50;
    operator delete(v50);
  }
  if (v53)
  {
    uint64_t v54 = v53;
    operator delete(v53);
  }
}

void sub_256E6E7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,void *__p,uint64_t a30)
{
  __cxa_free_exception(v30);
  _Unwind_Resume(a1);
}

void sub_256E6E90C()
{
}

void sub_256E6E914()
{
}

void sub_256E6E91C()
{
}

void sub_256E6E930()
{
}

void sub_256E6E938()
{
}

void sub_256E6E940()
{
}

void mlx::core::random::randint(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, mlx::core *a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  uint64_t v18 = a4;
  if (mlx::core::issubdtype((unsigned int *)&v18, &mlx::core::inexact))
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[randint] randint only accepts integer dtypes and BOOL.");
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  mlx::core::random::uniform(a1, a2, a3, 0x400000006, a5, a6, a7, v17);
  mlx::core::maximum(v17, a1, a6, a7, v16);
  mlx::core::astype(v16, v18, a6, a7, a8);
  mlx::core::array::~array((mlx::core::array *)v16);
  mlx::core::array::~array((mlx::core::array *)v17);
}

void sub_256E6EA58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  __cxa_free_exception(v12);
  _Unwind_Resume(a1);
}

uint64_t mlx::core::random::bernoulli@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, mlx::core *a4@<X3>, uint64_t a5@<X4>, const void ***a6@<X8>)
{
  *(void *)&long long v19 = *(void *)(*a1 + 56);
  if ((mlx::core::issubdtype((unsigned int *)&v19, mlx::core::floating) & 1) == 0)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  mlx::core::random::uniform(a2, *(void *)(*a1 + 56), a3, a4, a5, a6);
  mlx::core::less(a6, a1, a4, a5, &v19);
  long long v12 = v19;
  long long v19 = 0uLL;
  unsigned int v13 = (std::__shared_weak_count *)a6[1];
  *(_OWORD *)a6 = v12;
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  mlx::core::array::~array((mlx::core::array *)&v19);
  long long v14 = **a6;
  size_t v15 = (unsigned char *)(*a6)[1] - v14;
  if (v15 != a2[1] - *a2 || (uint64_t result = memcmp(v14, (const void *)*a2, v15), result))
  {
    float v17 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    v17->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(v17, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_256E6EC04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t mlx::core::random::bernoulli@<X0>(uint64_t **a1@<X0>, uint64_t a2@<X1>, mlx::core *a3@<X2>, uint64_t a4@<X3>, const void ***a5@<X8>)
{
  return mlx::core::random::bernoulli(a1, *a1, a2, a3, a4, a5);
}

void mlx::core::random::bernoulli(uint64_t a1@<X0>, mlx::core *a2@<X1>, uint64_t a3@<X2>, const void ***a4@<X8>)
{
  uint64_t v8 = mlx::core::TypeToDtype<float>::operator mlx::core::Dtype();
  mlx::core::array::array<float>(v9, v8, 0.5);
  mlx::core::random::bernoulli(v9, (uint64_t *)v9[0], a1, a2, a3, a4);
  mlx::core::array::~array((mlx::core::array *)v9);
}

void sub_256E6ECC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  mlx::core::array::~array((mlx::core::array *)va);
  _Unwind_Resume(a1);
}

void mlx::core::random::truncated_normal(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, mlx::core *a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  uint64_t v28 = a4;
  if ((mlx::core::issubdtype((unsigned int *)&v28, mlx::core::floating) & 1) == 0)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[trunc_normal] trunc_normal only accepts floating point dtypes.");
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  mlx::core::array::array<double>(v27, v28, 1.41421356);
  uint64_t v15 = a1[1];
  v25[0] = *a1;
  v25[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  mlx::core::astype(v25, v28, a6, a7, v26);
  mlx::core::array::~array((mlx::core::array *)v25);
  uint64_t v16 = a2[1];
  v23[0] = *a2;
  v23[1] = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  mlx::core::astype(v23, v28, a6, a7, v24);
  mlx::core::array::~array((mlx::core::array *)v23);
  mlx::core::divide(v26, v27, a6, a7, v21);
  mlx::core::erf(v21, a6, a7, v22);
  mlx::core::array::~array((mlx::core::array *)v21);
  mlx::core::divide(v24, v27, a6, a7, v20);
  mlx::core::erf(v20, a6, a7, v21);
  mlx::core::array::~array((mlx::core::array *)v20);
  mlx::core::random::uniform(v22, v21, a3, v28, a5, a6, a7, v20);
  mlx::core::erfinv(v20, a6, a7, v18);
  mlx::core::multiply(v27, v18, a6, a7, v19);
  mlx::core::array::~array((mlx::core::array *)v18);
  mlx::core::minimum(v24, v19, a6, a7, v18);
  mlx::core::maximum(v18, v26, a6, a7, a8);
  mlx::core::array::~array((mlx::core::array *)v18);
  mlx::core::array::~array((mlx::core::array *)v19);
  mlx::core::array::~array((mlx::core::array *)v20);
  mlx::core::array::~array((mlx::core::array *)v21);
  mlx::core::array::~array((mlx::core::array *)v22);
  mlx::core::array::~array((mlx::core::array *)v24);
  mlx::core::array::~array((mlx::core::array *)v26);
  mlx::core::array::~array((mlx::core::array *)v27);
}

void sub_256E6EF38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void sub_256E6EFB0()
{
}

void sub_256E6EFB8()
{
}

void sub_256E6EFC4()
{
}

void sub_256E6EFCC()
{
}

void sub_256E6EFD8()
{
}

void sub_256E6EFE0()
{
}

void sub_256E6EFEC()
{
}

void mlx::core::random::truncated_normal(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, mlx::core *a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  mlx::core::broadcast_shapes((void *)*a1, (void *)*a2, &__p);
  mlx::core::random::truncated_normal(a1, a2, (uint64_t *)&__p, a3, a4, a5, a6, a7);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_256E6F094(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::random::gumbel(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, mlx::core *a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  mlx::core::random::uniform(a1, a2, a3, a4, a5, v9);
  mlx::core::log(v9, a4, a5, v10);
  mlx::core::negative(v10, a4, a5, v11);
  mlx::core::log(v11, a4, a5, v12);
  mlx::core::negative(v12, a4, a5, a6);
  mlx::core::array::~array((mlx::core::array *)v12);
  mlx::core::array::~array((mlx::core::array *)v11);
  mlx::core::array::~array((mlx::core::array *)v10);
  mlx::core::array::~array((mlx::core::array *)v9);
}

void sub_256E6F160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
}

uint64_t mlx::core::random::get_valid_axis(mlx::core::random *this, int a2)
{
  uint64_t result = (a2 & ((int)this >> 31)) + this;
  if ((int)result < 0 || (int)result >= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v7);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v7, (uint64_t)"[categorical] Invalid axis ", 27);
    uint64_t v3 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" for logits with ", 17);
    uint64_t v4 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)" dimensions.", 12);
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v8, &v6);
    std::logic_error::logic_error(exception, &v6);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_256E6F2AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a16);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void mlx::core::random::categorical_impl(mlx::core::array *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, mlx::core *a5@<X4>, uint64_t a6@<X5>, mlx::core::array *a7@<X8>)
{
  memset(&v24, 0, sizeof(v24));
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v24, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  long long v14 = *(const void **)a3;
  uint64_t v13 = *(void *)(a3 + 8);
  uint64_t v15 = **(void **)a1;
  uint64_t v16 = *(void *)(*(void *)a1 + 8);
  begiunint64_t n = v24.__begin_;
  std::vector<int>::value_type v18 = mlx::core::array::shape(a1, a2);
  uint64_t v19 = ((v13 - (uint64_t)v14) >> 2) + a2 - ((v16 - v15) >> 2) + 1;
  v20.__i_ = &begin[v19];
  __x[0] = v18;
  std::vector<int>::insert(&v24, v20, __x);
  mlx::core::random::gumbel((uint64_t *)&v24, 0x400000006, a4, a5, a6, __x);
  mlx::core::add(__x, a1, a5, a6, v22);
  mlx::core::argmax(v22, v19, 0, a5, a6, a7);
  mlx::core::array::~array((mlx::core::array *)v22);
  mlx::core::array::~array((mlx::core::array *)__x);
  if (v24.__begin_)
  {
    v24.__end_ = v24.__begin_;
    operator delete(v24.__begin_);
  }
}

void sub_256E6F42C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

std::vector<int>::iterator std::vector<int>::insert(std::vector<int> *this, std::vector<int>::const_iterator __position, std::vector<int>::value_type *__x)
{
  uint64_t i = (int *)__position.__i_;
  std::vector<int>::pointer end = this->__end_;
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  uint64_t v8 = value;
  if (end >= value)
  {
    begiunint64_t n = this->__begin_;
    unint64_t v15 = end - this->__begin_ + 1;
    if (v15 >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = __position.__i_ - begin;
    uint64_t v17 = (char *)v8 - (char *)begin;
    if (v17 >> 1 > v15) {
      unint64_t v15 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v15;
    }
    __v.__end_cap_.__value_ = (std::allocator<int> *)p_end_cap;
    if (v18) {
      uint64_t v19 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)p_end_cap, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    __v.__first_ = v19;
    __v.__begin_ = &v19[v16];
    __v.__end_ = __v.__begin_;
    __v.__end_cap_.__value_ = &v19[v18];
    std::__split_buffer<int>::push_back(&__v, __x);
    uint64_t i = std::vector<int>::__swap_out_circular_buffer(this, &__v, i);
    if (__v.__end_ != __v.__begin_) {
      __v.__end_ = (std::__split_buffer<int>::pointer)((char *)__v.__end_
    }
                                                     + (((char *)__v.__begin_ - (char *)__v.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
    if (__v.__first_) {
      operator delete(__v.__first_);
    }
  }
  else if (__position.__i_ == end)
  {
    *__position.__i_ = *__x;
    this->__end_ = (std::vector<int>::pointer)(__position.__i_ + 1);
  }
  else
  {
    std::__wrap_iter<const int *>::iterator_type v10 = __position.__i_ + 1;
    char v11 = end - 1;
    long long v12 = (int *)end;
    while (v11 < end)
    {
      int v13 = *v11++;
      *v12++ = v13;
    }
    this->__end_ = v12;
    if (end != v10) {
      memmove((void *)&end[-(end - v10)], __position.__i_, (char *)end - (char *)v10);
    }
    *uint64_t i = *__x;
  }
  return (std::vector<int>::iterator)i;
}

void sub_256E6F5D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::random::categorical(mlx::core::random *this@<X1>, mlx::core::array *a2@<X0>, const void **a3@<X2>, uint64_t a4@<X3>, mlx::core *a5@<X4>, uint64_t a6@<X5>, mlx::core::array *a7@<X8>)
{
  unsigned int valid_axis = mlx::core::random::get_valid_axis(this, (*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  uint64_t v14 = *(void *)a2;
  int64_t v27 = 0;
  uint64_t v28 = 0;
  long long v26 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v26, *(const void **)v14, *(void *)(v14 + 8), (uint64_t)(*(void *)(v14 + 8) - *(void *)v14) >> 2);
  unint64_t v15 = &v26[4 * valid_axis];
  int64_t v16 = v27 - (v15 + 4);
  if (v27 != v15 + 4) {
    memmove(&v26[4 * valid_axis], v15 + 4, v27 - (v15 + 4));
  }
  int64_t v27 = &v15[v16];
  mlx::core::broadcast_shapes(a3, &v26, v25);
  begiunint64_t n = v25[0].__begin_;
  if ((char *)v25[0].__end_ - (char *)v25[0].__begin_ != (unsigned char *)a3[1] - (unsigned char *)*a3)
  {
    BOOL v18 = 0;
    if (!v25[0].__begin_) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  BOOL v18 = memcmp(v25[0].__begin_, *a3, (char *)v25[0].__end_ - (char *)v25[0].__begin_) == 0;
  if (begin)
  {
LABEL_7:
    v25[0].__end_ = begin;
    operator delete(begin);
  }
LABEL_8:
  if (!v18)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v25);
    uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"[categorical] Requested shape ", 30);
    std::vector<int>::const_iterator v20 = mlx::core::operator<<(v19, a3);
    uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" is not broadcast compatable with reduced logits shape", 54);
    long long v22 = mlx::core::operator<<(v21, &v26);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)".", 1);
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v25[0].__end_, &v24);
    std::logic_error::logic_error(exception, &v24);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  mlx::core::random::categorical_impl(a2, valid_axis, (uint64_t)a3, a4, a5, a6, a7);
  if (v26)
  {
    int64_t v27 = v26;
    operator delete(v26);
  }
}

void sub_256E6F81C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      uint64_t v19 = *(void **)(v17 - 112);
      if (v19)
      {
        *(void *)(v17 - 104) = v19;
        operator delete(v19);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void mlx::core::random::categorical(mlx::core::random *this@<X1>, const void ***a2@<X0>, int a3@<W2>, uint64_t a4@<X3>, mlx::core *a5@<X4>, uint64_t a6@<X5>, mlx::core::array *a7@<X8>)
{
  unsigned int valid_axis = mlx::core::random::get_valid_axis(this, (unint64_t)((unsigned char *)(*a2)[1] - (unsigned char *)**a2) >> 2);
  mlx::core::expand_dims(a2, -1, v14, 0, v20);
  BOOL v18 = 0;
  uint64_t v19 = 0;
  std::vector<int> __p = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *v20[0], (uint64_t)v20[0][1], ((char *)v20[0][1] - (char *)*v20[0]) >> 2);
  unint64_t v15 = (char *)__p + 4 * valid_axis;
  int64_t v16 = v18 - (v15 + 4);
  if (v18 != v15 + 4) {
    memmove((char *)__p + 4 * valid_axis, v15 + 4, v18 - (v15 + 4));
  }
  BOOL v18 = &v15[v16];
  *((_DWORD *)v18 - 1) = a3;
  mlx::core::random::categorical_impl((mlx::core::array *)v20, valid_axis, (uint64_t)&__p, a4, a5, a6, a7);
  if (__p)
  {
    BOOL v18 = (char *)__p;
    operator delete(__p);
  }
  mlx::core::array::~array((mlx::core::array *)v20);
}

void sub_256E6F990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  mlx::core::array::~array((mlx::core::array *)&a13);
  _Unwind_Resume(a1);
}

void mlx::core::random::categorical(mlx::core::random *this@<X1>, mlx::core::array *a2@<X0>, uint64_t a3@<X2>, mlx::core *a4@<X3>, uint64_t a5@<X4>, mlx::core::array *a6@<X8>)
{
  unsigned int valid_axis = mlx::core::random::get_valid_axis(this, (*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  uint64_t v12 = *(void *)a2;
  int64_t v16 = 0;
  uint64_t v17 = 0;
  std::vector<int> __p = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)v12, *(void *)(v12 + 8), (uint64_t)(*(void *)(v12 + 8) - *(void *)v12) >> 2);
  int v13 = (char *)__p + 4 * valid_axis;
  int64_t v14 = v16 - (v13 + 4);
  if (v16 != v13 + 4) {
    memmove((char *)__p + 4 * valid_axis, v13 + 4, v16 - (v13 + 4));
  }
  int64_t v16 = &v13[v14];
  mlx::core::random::categorical_impl(a2, valid_axis, (uint64_t)&__p, a3, a4, a5, a6);
  if (__p)
  {
    int64_t v16 = (char *)__p;
    operator delete(__p);
  }
}

void sub_256E6FAA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int ***mlx::core::array::array<unsigned int>(int ***a1, unsigned int a2, uint64_t a3)
{
  uint64_t v9 = a3;
  unsigned int v8 = a2;
  std::vector<int> __p = 0;
  std::string v6 = 0;
  uint64_t v7 = 0;
  std::allocate_shared[abi:ne180100]<mlx::core::array::ArrayDesc,std::allocator<mlx::core::array::ArrayDesc>,std::vector<int>,mlx::core::Dtype &,void>((uint64_t)&__p, &v9, a1);
  if (__p)
  {
    std::string v6 = __p;
    operator delete(__p);
  }
  mlx::core::array::init<unsigned int *>(a1, &v8);
  return a1;
}

void sub_256E6FB30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(exception_object);
}

float mlx::core::array::init<unsigned int *>(int ***a1, unsigned int *a2)
{
  v28[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = mlx::core::allocator::malloc((mlx::core::allocator *)(*((unsigned __int8 *)*a1 + 60) * (void)(*a1)[6]));
  v28[0] = &unk_27062AEC8;
  v28[1] = mlx::core::allocator::free;
  v28[3] = v28;
  mlx::core::array::set_data(a1, v4, (uint64_t)v28);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100](v28);
  std::string v6 = *a1;
  switch(*((_DWORD *)*a1 + 14))
  {
    case 0:
      unsigned int v8 = v6[6];
      if (v8)
      {
        uint64_t v9 = (BOOL *)v6[19];
        uint64_t v10 = 4 * (void)v8;
        do
        {
          int v11 = *a2++;
          *v9++ = v11 != 0;
          v10 -= 4;
        }
        while (v10);
      }
      break;
    case 1:
      uint64_t v12 = v6[6];
      if (v12)
      {
        int v13 = v6[19];
        uint64_t v14 = 4 * (void)v12;
        do
        {
          int v15 = *a2++;
          *(unsigned char *)int v13 = v15;
          int v13 = (int *)((char *)v13 + 1);
          v14 -= 4;
        }
        while (v14);
      }
      break;
    case 2:
    case 4:
      uint64_t v7 = v6[6];
      if (v7) {
        memmove(v6[19], a2, 4 * (void)v7);
      }
      break;
    case 3:
      int64_t v16 = v6[6];
      if (v16)
      {
        uint64_t v17 = v6[19];
        uint64_t v18 = 4 * (void)v16;
        do
        {
          int v19 = *a2++;
          *(unsigned char *)uint64_t v17 = v19;
          uint64_t v17 = (int *)((char *)v17 + 1);
          v18 -= 4;
        }
        while (v18);
      }
      break;
    case 5:
      std::vector<int>::const_iterator v20 = v6[6];
      if (v20)
      {
        uint64_t v21 = v6[19];
        uint64_t v22 = 4 * (void)v20;
        do
        {
          unsigned int v23 = *a2++;
          *(void *)uint64_t v21 = v23;
          v21 += 2;
          v22 -= 4;
        }
        while (v22);
      }
      break;
    case 6:
      std::string v24 = v6[6];
      if (v24)
      {
        long long v25 = (float *)v6[19];
        uint64_t v26 = 4 * (void)v24;
        do
        {
          unsigned int v27 = *a2++;
          float result = (float)v27;
          *v25++ = (float)v27;
          v26 -= 4;
        }
        while (v26);
      }
      break;
    default:
      return result;
  }
  return result;
}

void sub_256E6FD20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<mlx::core::array::ArrayDesc,std::allocator<mlx::core::array::ArrayDesc>,std::vector<int>,mlx::core::Dtype &,void>@<X0>(uint64_t a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  std::string v6 = operator new(0x100uLL);
  float result = std::__shared_ptr_emplace<mlx::core::array::ArrayDesc>::__shared_ptr_emplace[abi:ne180100]<std::vector<int>,mlx::core::Dtype &,std::allocator<mlx::core::array::ArrayDesc>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_256E6FDA0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<mlx::core::array::ArrayDesc>::__shared_ptr_emplace[abi:ne180100]<std::vector<int>,mlx::core::Dtype &,std::allocator<mlx::core::array::ArrayDesc>,0>(void *a1, uint64_t a2, void *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_270632520;
  std::construct_at[abi:ne180100]<mlx::core::array::ArrayDesc,std::vector<int>,mlx::core::Dtype &,mlx::core::array::ArrayDesc*>((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_256E6FDFC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<mlx::core::array::ArrayDesc>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlx::core::array::ArrayDesc>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632520;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x25A2B1780);
}

void std::__shared_ptr_emplace<mlx::core::array::ArrayDesc>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::construct_at[abi:ne180100]<mlx::core::array::ArrayDesc,std::vector<int>,mlx::core::Dtype &,mlx::core::array::ArrayDesc*>(uint64_t a1, uint64_t a2, void *a3)
{
  *(_OWORD *)std::vector<int> __p = *(_OWORD *)a2;
  uint64_t v6 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  mlx::core::array::ArrayDesc::ArrayDesc(a1, __p, *a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return a1;
}

void sub_256E6FEF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    float result = std::vector<int>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_256E6FF6C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__split_buffer<int>::push_back(std::__split_buffer<int> *this, std::__split_buffer<int>::value_type *__x)
{
  std::__split_buffer<int>::pointer end = this->__end_;
  if (end == this->__end_cap_.__value_)
  {
    begiunint64_t n = this->__begin_;
    uint64_t v6 = (char *)begin - (char *)this->__first_;
    if (begin <= this->__first_)
    {
      if (end == this->__first_) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = ((char *)end - (char *)this->__first_) >> 1;
      }
      uint64_t v17 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this->__end_cap_.__value_, v16);
      int v19 = (int *)((char *)v17 + (v16 & 0xFFFFFFFFFFFFFFFCLL));
      std::__split_buffer<int>::pointer v20 = this->__begin_;
      std::__split_buffer<int>::pointer end = v19;
      uint64_t v21 = (char *)this->__end_ - (char *)v20;
      if (v21)
      {
        std::__split_buffer<int>::pointer end = (int *)((char *)v19 + (v21 & 0xFFFFFFFFFFFFFFFCLL));
        uint64_t v22 = 4 * (v21 >> 2);
        unsigned int v23 = (int *)((char *)v17 + (v16 & 0xFFFFFFFFFFFFFFFCLL));
        do
        {
          int v24 = *v20++;
          *v23++ = v24;
          v22 -= 4;
        }
        while (v22);
      }
      std::__split_buffer<int>::pointer first = this->__first_;
      this->__first_ = v17;
      this->__begin_ = v19;
      this->__end_ = end;
      this->__end_cap_.__value_ = &v17[v18];
      if (first)
      {
        operator delete(first);
        std::__split_buffer<int>::pointer end = this->__end_;
      }
    }
    else
    {
      uint64_t v7 = v6 >> 2;
      BOOL v8 = v6 >> 2 < -1;
      uint64_t v9 = (v6 >> 2) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      int v13 = &begin[-v12];
      int64_t v14 = (char *)end - (char *)begin;
      if (end != begin)
      {
        memmove(&begin[-v12], begin, (char *)end - (char *)begin);
        std::__split_buffer<int>::pointer end = this->__begin_;
      }
      int v15 = &end[v11];
      std::__split_buffer<int>::pointer end = (int *)((char *)v13 + v14);
      this->__begin_ = v15;
    }
  }
  *std::__split_buffer<int>::pointer end = *__x;
  this->__end_ = end + 1;
}

int ***mlx::core::array::array<unsigned int>(int ***a1, unsigned int *a2, int a3, uint64_t a4)
{
  uint64_t v12 = a4;
  uint64_t v7 = operator new(4uLL);
  std::vector<int> __p = v7;
  *uint64_t v7 = a3;
  uint64_t v10 = v7 + 1;
  uint64_t v11 = v7 + 1;
  std::allocate_shared[abi:ne180100]<mlx::core::array::ArrayDesc,std::allocator<mlx::core::array::ArrayDesc>,std::vector<int>,mlx::core::Dtype &,void>((uint64_t)&__p, &v12, a1);
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
  mlx::core::array::init<unsigned int const*>(a1, a2);
  return a1;
}

void sub_256E7011C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  int v13 = *(std::__shared_weak_count **)(v11 + 8);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  _Unwind_Resume(exception_object);
}

float mlx::core::array::init<unsigned int const*>(int ***a1, unsigned int *a2)
{
  v28[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = mlx::core::allocator::malloc((mlx::core::allocator *)(*((unsigned __int8 *)*a1 + 60) * (void)(*a1)[6]));
  v28[0] = &unk_27062AEC8;
  v28[1] = mlx::core::allocator::free;
  v28[3] = v28;
  mlx::core::array::set_data(a1, v4, (uint64_t)v28);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100](v28);
  uint64_t v6 = *a1;
  switch(*((_DWORD *)*a1 + 14))
  {
    case 0:
      BOOL v8 = v6[6];
      if (v8)
      {
        uint64_t v9 = (BOOL *)v6[19];
        uint64_t v10 = 4 * (void)v8;
        do
        {
          int v11 = *a2++;
          *v9++ = v11 != 0;
          v10 -= 4;
        }
        while (v10);
      }
      break;
    case 1:
      uint64_t v12 = v6[6];
      if (v12)
      {
        int v13 = v6[19];
        uint64_t v14 = 4 * (void)v12;
        do
        {
          int v15 = *a2++;
          *(unsigned char *)int v13 = v15;
          int v13 = (int *)((char *)v13 + 1);
          v14 -= 4;
        }
        while (v14);
      }
      break;
    case 2:
    case 4:
      uint64_t v7 = v6[6];
      if (v7) {
        memmove(v6[19], a2, 4 * (void)v7);
      }
      break;
    case 3:
      unint64_t v16 = v6[6];
      if (v16)
      {
        uint64_t v17 = v6[19];
        uint64_t v18 = 4 * (void)v16;
        do
        {
          int v19 = *a2++;
          *(unsigned char *)uint64_t v17 = v19;
          uint64_t v17 = (int *)((char *)v17 + 1);
          v18 -= 4;
        }
        while (v18);
      }
      break;
    case 5:
      std::__split_buffer<int>::pointer v20 = v6[6];
      if (v20)
      {
        uint64_t v21 = v6[19];
        uint64_t v22 = 4 * (void)v20;
        do
        {
          unsigned int v23 = *a2++;
          *(void *)uint64_t v21 = v23;
          v21 += 2;
          v22 -= 4;
        }
        while (v22);
      }
      break;
    case 6:
      int v24 = v6[6];
      if (v24)
      {
        long long v25 = (float *)v6[19];
        uint64_t v26 = 4 * (void)v24;
        do
        {
          unsigned int v27 = *a2++;
          float result = (float)v27;
          *v25++ = (float)v27;
          v26 -= 4;
        }
        while (v26);
      }
      break;
    default:
      return result;
  }
  return result;
}

void sub_256E7030C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<mlx::core::RandomBits,std::allocator<mlx::core::RandomBits>,mlx::core::Stream,std::vector<int> const&,int &,void>@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, int *a3@<X3>, void *a4@<X8>)
{
  BOOL v8 = (char *)operator new(0x50uLL);
  uint64_t result = std::__shared_ptr_emplace<mlx::core::RandomBits>::__shared_ptr_emplace[abi:ne180100]<mlx::core::Stream,std::vector<int> const&,int &,std::allocator<mlx::core::RandomBits>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_256E7039C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<mlx::core::RandomBits>::__shared_ptr_emplace[abi:ne180100]<mlx::core::Stream,std::vector<int> const&,int &,std::allocator<mlx::core::RandomBits>,0>(uint64_t a1, uint64_t *a2, uint64_t a3, int *a4)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = &unk_270632570;
  uint64_t v5 = *a2;
  int v6 = *((_DWORD *)a2 + 2);
  int v7 = *a4;
  *(void *)(a1 + 48) = 0;
  uint64_t v8 = a1 + 48;
  *(_DWORD *)(v8 - 8) = v6;
  *(void *)(v8 - 24) = &unk_270636C10;
  *(void *)(v8 - 16) = v5;
  *(_OWORD *)(v8 + 8) = 0u;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)v8, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  *(_DWORD *)(a1 + 72) = v7;
  return a1;
}

void sub_256E70444(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<mlx::core::RandomBits>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632570;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlx::core::RandomBits>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632570;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x25A2B1780);
}

uint64_t std::__shared_ptr_emplace<mlx::core::RandomBits>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 64))();
}

int ***mlx::core::array::array<float>(int ***a1, uint64_t a2, float a3)
{
  uint64_t v9 = a2;
  float v8 = a3;
  std::vector<int> __p = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  std::allocate_shared[abi:ne180100]<mlx::core::array::ArrayDesc,std::allocator<mlx::core::array::ArrayDesc>,std::vector<int>,mlx::core::Dtype &,void>((uint64_t)&__p, &v9, a1);
  if (__p)
  {
    int v6 = __p;
    operator delete(__p);
  }
  mlx::core::array::init<float *>(a1, &v8);
  return a1;
}

void sub_256E70560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(exception_object);
}

void *mlx::core::array::init<float *>(int ***a1, float *a2)
{
  v32[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = mlx::core::allocator::malloc((mlx::core::allocator *)(*((unsigned __int8 *)*a1 + 60) * (void)(*a1)[6]));
  v32[0] = &unk_27062AEC8;
  v32[1] = mlx::core::allocator::free;
  v32[3] = v32;
  mlx::core::array::set_data(a1, v4, (uint64_t)v32);
  uint64_t result = std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100](v32);
  int v6 = *a1;
  switch(*((_DWORD *)*a1 + 14))
  {
    case 0:
      uint64_t v7 = v6[6];
      if (v7)
      {
        float v8 = (BOOL *)v6[19];
        uint64_t v9 = 4 * (void)v7;
        do
        {
          float v10 = *a2++;
          *v8++ = v10 != 0.0;
          v9 -= 4;
        }
        while (v9);
      }
      break;
    case 1:
      unsigned int v23 = v6[6];
      if (v23)
      {
        int v24 = v6[19];
        uint64_t v25 = 4 * (void)v23;
        do
        {
          float v26 = *a2++;
          *(unsigned char *)int v24 = (int)v26;
          int v24 = (int *)((char *)v24 + 1);
          v25 -= 4;
        }
        while (v25);
      }
      break;
    case 2:
      int v11 = v6[6];
      if (v11)
      {
        uint64_t v12 = v6[19];
        uint64_t v13 = 4 * (void)v11;
        do
        {
          float v14 = *a2++;
          *v12++ = v14;
          v13 -= 4;
        }
        while (v13);
      }
      break;
    case 3:
      int v15 = v6[6];
      if (v15)
      {
        unint64_t v16 = v6[19];
        uint64_t v17 = 4 * (void)v15;
        do
        {
          float v18 = *a2++;
          *(unsigned char *)unint64_t v16 = (int)v18;
          unint64_t v16 = (int *)((char *)v16 + 1);
          v17 -= 4;
        }
        while (v17);
      }
      break;
    case 4:
      int v19 = v6[6];
      if (v19)
      {
        std::__split_buffer<int>::pointer v20 = v6[19];
        uint64_t v21 = 4 * (void)v19;
        do
        {
          float v22 = *a2++;
          *v20++ = (int)v22;
          v21 -= 4;
        }
        while (v21);
      }
      break;
    case 5:
      unsigned int v27 = v6[6];
      if (v27)
      {
        uint64_t v28 = v6[19];
        uint64_t v29 = 4 * (void)v27;
        do
        {
          float v30 = *a2++;
          *(void *)uint64_t v28 = (uint64_t)v30;
          v28 += 2;
          v29 -= 4;
        }
        while (v29);
      }
      break;
    case 6:
      int v31 = v6[6];
      if (v31) {
        uint64_t result = memmove(v6[19], a2, 4 * (void)v31);
      }
      break;
    default:
      return result;
  }
  return result;
}

void sub_256E70784(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

int ***mlx::core::array::array<double>(int ***a1, uint64_t a2, double a3)
{
  uint64_t v9 = a2;
  double v8 = a3;
  std::vector<int> __p = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  std::allocate_shared[abi:ne180100]<mlx::core::array::ArrayDesc,std::allocator<mlx::core::array::ArrayDesc>,std::vector<int>,mlx::core::Dtype &,void>((uint64_t)&__p, &v9, a1);
  if (__p)
  {
    int v6 = __p;
    operator delete(__p);
  }
  mlx::core::array::init<double *>(a1, &v8);
  return a1;
}

void sub_256E70820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(exception_object);
}

float mlx::core::array::init<double *>(int ***a1, double *a2)
{
  v35[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = mlx::core::allocator::malloc((mlx::core::allocator *)(*((unsigned __int8 *)*a1 + 60) * (void)(*a1)[6]));
  v35[0] = &unk_27062AEC8;
  v35[1] = mlx::core::allocator::free;
  v35[3] = v35;
  mlx::core::array::set_data(a1, v4, (uint64_t)v35);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100](v35);
  int v6 = *a1;
  switch(*((_DWORD *)*a1 + 14))
  {
    case 0:
      uint64_t v7 = v6[6];
      if (v7)
      {
        double v8 = (BOOL *)v6[19];
        uint64_t v9 = 8 * (void)v7;
        do
        {
          double v10 = *a2++;
          float result = *(float *)&v10;
          *v8++ = v10 != 0.0;
          v9 -= 8;
        }
        while (v9);
      }
      break;
    case 1:
      unsigned int v23 = v6[6];
      if (v23)
      {
        int v24 = v6[19];
        uint64_t v25 = 8 * (void)v23;
        do
        {
          double v26 = *a2++;
          float result = *(float *)&v26;
          *(unsigned char *)int v24 = (int)v26;
          int v24 = (int *)((char *)v24 + 1);
          v25 -= 8;
        }
        while (v25);
      }
      break;
    case 2:
      int v11 = v6[6];
      if (v11)
      {
        uint64_t v12 = v6[19];
        uint64_t v13 = 8 * (void)v11;
        do
        {
          double v14 = *a2++;
          float result = *(float *)&v14;
          *v12++ = v14;
          v13 -= 8;
        }
        while (v13);
      }
      break;
    case 3:
      int v15 = v6[6];
      if (v15)
      {
        unint64_t v16 = v6[19];
        uint64_t v17 = 8 * (void)v15;
        do
        {
          double v18 = *a2++;
          float result = *(float *)&v18;
          *(unsigned char *)unint64_t v16 = (int)v18;
          unint64_t v16 = (int *)((char *)v16 + 1);
          v17 -= 8;
        }
        while (v17);
      }
      break;
    case 4:
      int v19 = v6[6];
      if (v19)
      {
        std::__split_buffer<int>::pointer v20 = v6[19];
        uint64_t v21 = 8 * (void)v19;
        do
        {
          double v22 = *a2++;
          float result = *(float *)&v22;
          *v20++ = (int)v22;
          v21 -= 8;
        }
        while (v21);
      }
      break;
    case 5:
      unsigned int v27 = v6[6];
      if (v27)
      {
        uint64_t v28 = v6[19];
        uint64_t v29 = 8 * (void)v27;
        do
        {
          double v30 = *a2++;
          float result = *(float *)&v30;
          *(void *)uint64_t v28 = (uint64_t)v30;
          v28 += 2;
          v29 -= 8;
        }
        while (v29);
      }
      break;
    case 6:
      int v31 = v6[6];
      if (v31)
      {
        uint64_t v32 = (float *)v6[19];
        uint64_t v33 = 8 * (void)v31;
        do
        {
          double v34 = *a2++;
          float result = v34;
          *v32++ = result;
          v33 -= 8;
        }
        while (v33);
      }
      break;
    default:
      return result;
  }
  return result;
}

void sub_256E70A50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t mlx_tostring(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t mlx_retain(uint64_t result)
{
  return result;
}

atomic_ullong *mlx_free(atomic_ullong *result)
{
  unint64_t add = atomic_fetch_add(result + 1, 0xFFFFFFFFFFFFFFFFLL);
  if (result)
  {
    if (add == 1) {
      return (atomic_ullong *)(*(uint64_t (**)(void))(*result + 16))();
    }
  }
  return result;
}

BOOL mlx::core::detail::compile_available_for_device(_DWORD *a1)
{
  uint64_t v2 = 1;
  return mlx::core::operator==(a1, &v2);
}

void mlx::core::load_gguf()
{
  exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
  MEMORY[0x25A2B1470](exception, "[load_gguf] Compile with MLX_BUILD_GGUF=ON to enable GGUF support.");
  __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
}

void sub_256E70B6C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::save_gguf()
{
  exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
  MEMORY[0x25A2B1470](exception, "[save_gguf] Compile with MLX_BUILD_GGUF=ON to enable GGUF support.");
  __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
}

void sub_256E70BC8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

mlx_string_ *mlx_string_::tostring(mlx_string_ *this)
{
  return this;
}

void mlx_string_new(char *__s)
{
  std::string::basic_string[abi:ne180100]<0>(__p, __s);
  operator new();
}

void sub_256E70CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  MEMORY[0x25A2B1780](v15, 0x1093C401FB1DE5ELL);
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t mlx_string_data(uint64_t a1)
{
  uint64_t result = a1 + 16;
  if (*(char *)(a1 + 39) < 0) {
    return *(void *)result;
  }
  return result;
}

void mlx_string_::~mlx_string_(void **this)
{
  *this = &unk_2706325C0;
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2706325C0;
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
  JUMPOUT(0x25A2B1780);
}

uint64_t mlx::core::allocator::malloc(mlx::core::allocator *this)
{
  uint64_t v2 = mlx::core::allocator::allocator(this);
  uint64_t result = (**v2)((mlx::core::allocator::CommonAllocator *)v2, (size_t)this, 1);
  if (this)
  {
    if (!result)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v7, (uint64_t)"[malloc] Unable to allocate ", 28);
      uint64_t v4 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)" bytes.", 7);
      exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v8, v6);
      MEMORY[0x25A2B1480](exception, v6);
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
    }
  }
  return result;
}

void sub_256E70EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a16);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t mlx::core::allocator::free(mlx::core::allocator *a1)
{
  uint64_t v1 = (uint64_t (*)(void))(*mlx::core::allocator::allocator(a1))[1];
  return v1();
}

void *mlx::core::allocator::CommonAllocator::malloc(mlx::core::allocator::CommonAllocator *this, size_t size)
{
  return malloc_type_malloc(size, 0x101B465DuLL);
}

void mlx::core::allocator::CommonAllocator::free(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  uint64_t v2 = (void *)mlx::core::allocator::Buffer::raw_ptr((mlx::core::allocator::Buffer *)&v3);
  free(v2);
}

mlx::core::scheduler *mlx::core::allocator::malloc_or_wait(mlx::core::allocator *this)
{
  uint64_t v2 = mlx::core::allocator::allocator(this);
  uint64_t result = (mlx::core::scheduler *)(**v2)((mlx::core::allocator::CommonAllocator *)v2, (size_t)this, 0);
  if (this && !result)
  {
    while (1)
    {
      uint64_t v4 = (mlx::core::scheduler *)mlx::core::scheduler::scheduler(result);
      if (*(int *)v4 < 1) {
        break;
      }
      uint64_t v5 = (mlx::core::scheduler::Scheduler *)mlx::core::scheduler::scheduler(v4);
      mlx::core::scheduler::Scheduler::wait_for_one(v5);
      uint64_t v7 = mlx::core::allocator::allocator(v6);
      uint64_t result = (mlx::core::scheduler *)(**v7)((mlx::core::allocator::CommonAllocator *)v7, (size_t)this, 0);
      if (result) {
        return result;
      }
    }
    uint64_t v8 = mlx::core::allocator::allocator(v4);
    uint64_t result = (mlx::core::scheduler *)(**v8)((mlx::core::allocator::CommonAllocator *)v8, (size_t)this, 1);
    if (!result)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v12, (uint64_t)"[malloc_or_wait] Unable to allocate ", 36);
      uint64_t v9 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" bytes.", 7);
      exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v13, v11);
      MEMORY[0x25A2B1480](exception, v11);
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
    }
  }
  return result;
}

void sub_256E71108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a16);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void mlx::core::allocator::CommonAllocator::~CommonAllocator(mlx::core::allocator::CommonAllocator *this)
{
}

void mlx::core::scheduler::Scheduler::wait_for_one(mlx::core::scheduler::Scheduler *this)
{
  v3.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 120);
  v3.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 120));
  int v2 = *(_DWORD *)this;
  if (*(int *)this < 2) {
    goto LABEL_4;
  }
  do
    std::condition_variable::wait((std::condition_variable *)((char *)this + 72), &v3);
  while (*(_DWORD *)this == v2);
  if (v3.__owns_) {
LABEL_4:
  }
    std::mutex::unlock(v3.__m_);
}

void mlx_async_eval(uint64_t a1)
{
  long long v1 = 0uLL;
  uint64_t v2 = 0;
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)&v1, *(void **)(a1 + 16), *(void **)(a1 + 24), (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 4);
  mlx::core::async_eval(&v1);
  std::unique_lock<std::mutex> v3 = (void **)&v1;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void sub_256E7123C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void mlx_checkpoint()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_256E71320(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  MEMORY[0x25A2B1780](v2, 0x10A1C40E41A338ALL);
  _Unwind_Resume(a1);
}

void mlx_eval(uint64_t a1)
{
  long long v1 = 0uLL;
  uint64_t v2 = 0;
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)&v1, *(void **)(a1 + 16), *(void **)(a1 + 24), (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 4);
  mlx::core::eval(&v1);
  std::unique_lock<std::mutex> v3 = (void **)&v1;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void sub_256E713BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void mlx_jvp()
{
}

void sub_256E71470(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>>::~pair((void **)va);
  MEMORY[0x25A2B1780](v2, 0x10A1C405897D53FLL);
  _Unwind_Resume(a1);
}

void **std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>>::~pair(void **a1)
{
  std::unique_lock<std::mutex> v3 = a1 + 3;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::unique_lock<std::mutex> v3 = a1;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

void mlx_value_and_grad()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_256E715E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::__function::__value_func<std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](&a12);
  if (__p) {
    operator delete(__p);
  }
  MEMORY[0x25A2B1780](v12, 0x10A1C40E41A338ALL);
  _Unwind_Resume(a1);
}

void mlx_vjp()
{
}

void sub_256E716C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>>::~pair((void **)va);
  MEMORY[0x25A2B1780](v2, 0x10A1C405897D53FLL);
  _Unwind_Resume(a1);
}

char *std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>(char *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<mlx::core::array>::__vallocate[abi:ne180100](result, a4);
    for (uint64_t i = (void *)*((void *)v6 + 1); a2 != a3; a2 += 2)
    {
      *uint64_t i = *a2;
      uint64_t v8 = a2[1];
      i[1] = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      i += 2;
    }
    *((void *)v6 + 1) = i;
  }
  return result;
}

void sub_256E71784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<mlx::core::array>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<int>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<int,unsigned long>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

uint64_t mlx_vector_vector_array_::mlx_vector_vector_array_(uint64_t a1, void **a2)
{
  int v11 = (void *)*MEMORY[0x263EF8340];
  *(void *)a1 = &unk_270633240;
  *(void *)(a1 + 8) = 1;
  memset(v9, 0, sizeof(v9));
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)v9, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 4);
  memset(v10, 0, sizeof(v10));
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)v10, a2[3], a2[4], ((char *)a2[4] - (char *)a2[3]) >> 4);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v7 = (void **)(a1 + 16);
  char v8 = 0;
  uint64_t v4 = (char *)operator new(0x30uLL);
  *(void *)(a1 + 32) = v4 + 48;
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v4;
  *(void *)(a1 + 24) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<mlx::core::array>>,std::vector<mlx::core::array> const*,std::vector<mlx::core::array> const*,std::vector<mlx::core::array>*>(a1 + 32, v9, &v11, (uint64_t)v4);
  for (uint64_t i = 3; i != -3; i -= 3)
  {
    uint64_t v7 = (void **)&v9[i];
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v7);
  }
  return a1;
}

void sub_256E71908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v14 = v13;
  *(void *)(v12 + 24) = v14;
  std::vector<std::vector<mlx::core::array>>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (uint64_t i = 24; i != -24; i -= 24)
  {
    a10 = (void **)(&a12 + i);
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&a10);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<mlx::core::array>>,std::vector<mlx::core::array> const*,std::vector<mlx::core::array> const*,std::vector<mlx::core::array>*>(uint64_t a1, void **a2, void **a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      *(void *)(v4 + 16) = 0;
      std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)v4, *v6, v6[1], ((char *)v6[1] - (char *)*v6) >> 4);
      uint64_t v4 = v11 + 24;
      v11 += 24;
      v6 += 3;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<mlx::core::array>>,std::vector<mlx::core::array>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_256E71A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<mlx::core::array>>,std::vector<mlx::core::array>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<mlx::core::array>>,std::vector<mlx::core::array>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<mlx::core::array>>,std::vector<mlx::core::array>*>::operator()[abi:ne180100](uint64_t a1)
{
  long long v1 = **(void ****)(a1 + 16);
  uint64_t v2 = **(void ****)(a1 + 8);
  while (v1 != v2)
  {
    v1 -= 3;
    std::unique_lock<std::mutex> v3 = v1;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
}

void std::vector<std::vector<mlx::core::array>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  long long v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__function::__value_func<std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

{
  void *v3;
  uint64_t v4;

  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t mlx::core::default_stream(mlx::core::metal *a1)
{
  uint64_t v5 = a1;
  is_available = (mlx::core::scheduler *)mlx::core::metal::is_available(a1);
  if ((is_available & 1) == 0)
  {
    uint64_t v4 = 1;
    is_available = (mlx::core::scheduler *)mlx::core::operator==(&v5, &v4);
    if (is_available)
    {
      exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "[default_stream] Cannot get gpu stream without gpu backend.");
      __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
    }
  }
  mlx::core::scheduler::scheduler(is_available);
  return mlx::core::scheduler::Scheduler::get_default_stream((uint64_t)&mlx::core::scheduler::scheduler(void)::scheduler, (int *)&v5);
}

void sub_256E71DF0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *mlx::core::scheduler::scheduler(mlx::core::scheduler *this)
{
  {
    mlx::core::scheduler::Scheduler::Scheduler((mlx::core::scheduler::Scheduler *)&mlx::core::scheduler::scheduler(void)::scheduler);
  }
  return &mlx::core::scheduler::scheduler(void)::scheduler;
}

void sub_256E71E88(_Unwind_Exception *a1)
{
}

uint64_t mlx::core::scheduler::Scheduler::get_default_stream(uint64_t a1, int *a2)
{
  uint64_t v2 = std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::find<mlx::core::Device::DeviceType>((void *)(a1 + 32), a2);
  if (!v2) {
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
  return *(uint64_t *)((char *)v2 + 20);
}

uint64_t *mlx::core::set_default_stream(mlx::core::metal *a1, int a2)
{
  uint64_t v6 = a1;
  int v7 = a2;
  is_available = (mlx::core::scheduler *)mlx::core::metal::is_available(a1);
  if ((is_available & 1) == 0)
  {
    uint64_t v5 = 1;
    is_available = (mlx::core::scheduler *)mlx::core::operator==((_DWORD *)&v6 + 1, &v5);
    if (is_available)
    {
      exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "[set_default_stream] Cannot set gpu stream without gpu backend.");
      __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
    }
  }
  mlx::core::scheduler::scheduler(is_available);
  return mlx::core::scheduler::Scheduler::set_default_stream((uint64_t)&mlx::core::scheduler::scheduler(void)::scheduler, (uint64_t)&v6);
}

void sub_256E71F78(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t *mlx::core::scheduler::Scheduler::set_default_stream(uint64_t a1, uint64_t a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::find<mlx::core::Device::DeviceType>((void *)(a1 + 32), (int *)(a2 + 4));
  if (!result) {
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
  uint64_t v4 = *(void *)a2;
  *((_DWORD *)result + 7) = *(_DWORD *)(a2 + 8);
  *(uint64_t *)((char *)result + 20) = v4;
  return result;
}

void mlx::core::new_stream(mlx::core::metal *a1)
{
  uint64_t v4 = a1;
  is_available = (mlx::core::scheduler *)mlx::core::metal::is_available(a1);
  if ((is_available & 1) == 0)
  {
    uint64_t v3 = 1;
    is_available = (mlx::core::scheduler *)mlx::core::operator==(&v4, &v3);
    if (is_available)
    {
      exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "[new_stream] Cannot make gpu stream without gpu backend.");
      __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
    }
  }
  mlx::core::scheduler::scheduler(is_available);
  mlx::core::scheduler::Scheduler::new_stream();
}

void sub_256E72074(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::scheduler::Scheduler::new_stream()
{
}

void sub_256E721B4(_Unwind_Exception *a1)
{
  MEMORY[0x25A2B1780](v1, 0x10A0C40C3DAA8D3);
  _Unwind_Resume(a1);
}

void mlx::core::new_stream(mlx::core *this)
{
  uint64_t v1 = (mlx::core *)mlx::core::scheduler::scheduler(this);
  mlx::core::default_device(v1);
  mlx::core::scheduler::Scheduler::new_stream();
}

void mlx::core::synchronize(uint64_t a1, int a2)
{
  v16[4] = *MEMORY[0x263EF8340];
  uint64_t v14 = a1;
  int v15 = a2;
  _ZNSt3__115allocate_sharedB8ne180100INS_7promiseIvEENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(v13);
  std::promise<void>::get_future(v13[0]);
  v16[0] = 0;
  BOOL v2 = mlx::core::operator==((_DWORD *)&v14 + 1, v16);
  if (!v2)
  {
    v13[0] = 0;
    v13[1] = 0;
    mlx::core::metal::make_synchronize_task();
  }
  uint64_t v4 = v13[0];
  uint64_t v3 = v13[1];
  v13[0] = 0;
  v13[1] = 0;
  mlx::core::scheduler::scheduler((mlx::core::scheduler *)v2);
  uint64_t v5 = *(void *)(qword_269FDD688 + 8 * (int)v14);
  std::mutex::lock((std::mutex *)v5);
  if (*(unsigned char *)(v5 + 160))
  {
    exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x25A2B1470](exception, "Cannot enqueue work after stream is stopped.");
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v6 = *(void *)(v5 + 72);
  uint64_t v7 = *(void *)(v5 + 80);
  if (v7 == v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 16 * (v7 - v6) - 1;
  }
  uint64_t v9 = *(void *)(v5 + 104);
  if (v8 == v9 + *(void *)(v5 + 96))
  {
    std::deque<std::function<void ()(void)>>::__add_back_capacity((void *)(v5 + 64));
    uint64_t v6 = *(void *)(v5 + 72);
    uint64_t v7 = *(void *)(v5 + 80);
    uint64_t v9 = *(void *)(v5 + 104);
  }
  if (v7 == v6) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = (void *)(*(void *)(v6 + (((unint64_t)(v9 + *(void *)(v5 + 96)) >> 4) & 0xFFFFFFFFFFFFFF8))
  }
                   + 32 * ((v9 + *(void *)(v5 + 96)) & 0x7F));
  *uint64_t v10 = &unk_2706326A8;
  v10[1] = v4;
  void v10[2] = v3;
  void v10[3] = v10;
  *(void *)(v5 + 104) = v9 + 1;
  std::mutex::unlock((std::mutex *)v5);
  std::condition_variable::notify_one((std::condition_variable *)(v5 + 112));
  std::__assoc_sub_state::wait(v12.__state_);
  std::future<void>::~future(&v12);
  if (v13[1]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v13[1]);
  }
}

void sub_256E72418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::future<void> a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  __cxa_free_exception(v20);
  std::mutex::unlock(v19);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  std::future<void>::~future(&a12);
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(a1);
}

void mlx::core::synchronize(mlx::core *this)
{
  uint64_t v1 = (mlx::core::metal *)mlx::core::default_device(this);
  uint64_t v2 = mlx::core::default_stream(v1);
  mlx::core::synchronize(v2, v3);
}

uint64_t *std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::find<mlx::core::Device::DeviceType>(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  uint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

void mlx::core::scheduler::StreamThread::StreamThread(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = 850045863;
  *(void *)(a1 + 112) = 1018212795;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 145) = 0u;
  *(void *)(a1 + 164) = a2;
  *(_DWORD *)(a1 + 172) = a3;
  std::thread::thread<void (mlx::core::scheduler::StreamThread::*)(void),mlx::core::scheduler::StreamThread*,void>();
}

void sub_256E72654(_Unwind_Exception *a1)
{
  std::thread::~thread(v3);
  std::condition_variable::~condition_variable(v2);
  std::deque<std::function<void ()(void)>>::~deque[abi:ne180100](&v1[1].__m_.__sig);
  std::mutex::~mutex(v1);
  _Unwind_Resume(a1);
}

void *mlx::core::scheduler::StreamThread::thread_fn(std::mutex *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int8x8_t v2 = (std::condition_variable *)&this[1].__m_.__opaque[40];
  unint64_t v3 = (int64x2_t *)&this[1];
  while (1)
  {
    uint64_t v8 = 0;
    __lk.__m_ = this;
    __lk.__owns_ = 1;
    std::mutex::lock(this);
    while (1)
    {
      if (*(void *)&this[1].__m_.__opaque[32])
      {
        std::__function::__value_func<void ()(void)>::operator=[abi:ne180100](v7, *(void *)(*(void *)this[1].__m_.__opaque+ ((*(void *)&this[1].__m_.__opaque[24] >> 4) & 0xFFFFFFFFFFFFFF8))+ 32 * (*(void *)&this[1].__m_.__opaque[24] & 0x7FLL));
        std::deque<std::function<void ()(void)>>::pop_front(v3);
        int v4 = 1;
        goto LABEL_7;
      }
      if (this[2].__m_.__opaque[24]) {
        break;
      }
      std::condition_variable::wait(v2, &__lk);
    }
    int v4 = 0;
LABEL_7:
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (!v4) {
      return std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v7);
    }
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t))(*(void *)v8 + 48))(v8);
    std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v7);
  }
}

void sub_256E727C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, __int16 a13, char a14, char a15)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__value_func<void ()(void)>::operator=[abi:ne180100](void *a1, uint64_t a2)
{
  std::__function::__value_func<void ()(void)>::operator=[abi:ne180100](a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(void)>::operator=[abi:ne180100](void *a1)
{
  int8x8_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::deque<std::function<void ()(void)>>::pop_front(int64x2_t *a1)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100]((void *)(*(void *)(a1->i64[1]
                                                                                                 + (((unint64_t)a1[2].i64[0] >> 4) & 0xFFFFFFFFFFFFFF8))
                                                                                     + 32 * (a1[2].i64[0] & 0x7F)));
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_25706AE40);
  return std::deque<std::function<void ()(void)>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

uint64_t std::deque<std::function<void ()(void)>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x80) {
    a2 = 1;
  }
  if (v2 < 0x100) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 128;
  }
  return v4 ^ 1u;
}

void std::thread::thread<void (mlx::core::scheduler::StreamThread::*)(void),mlx::core::scheduler::StreamThread*,void>()
{
}

void sub_256E72AB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__thread_struct>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:ne180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (mlx::core::scheduler::StreamThread::*)(void),mlx::core::scheduler::StreamThread*>>(uint64_t *a1)
{
  uint64_t v7 = (const void **)a1;
  uint64_t v1 = std::__thread_local_data();
  unint64_t v2 = *v7;
  *uint64_t v7 = 0;
  pthread_setspecific(v1->__key_, v2);
  unint64_t v3 = (void (*)(void *))v7[1];
  uint64_t v4 = (uint64_t)v7[2];
  unint64_t v5 = (char *)v7[3] + (v4 >> 1);
  if (v4) {
    unint64_t v3 = *(void (**)(void *))(*v5 + v3);
  }
  v3(v5);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (mlx::core::scheduler::StreamThread::*)(void),mlx::core::scheduler::StreamThread*>>::reset[abi:ne180100]((uint64_t **)&v7, 0);
  return 0;
}

void sub_256E72B7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (mlx::core::scheduler::StreamThread::*)(void),mlx::core::scheduler::StreamThread*>>::reset[abi:ne180100]((uint64_t **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (mlx::core::scheduler::StreamThread::*)(void),mlx::core::scheduler::StreamThread*>>::reset[abi:ne180100](uint64_t **result, uint64_t *a2)
{
  unint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:ne180100](v2, 0);
    JUMPOUT(0x25A2B1780);
  }
  return result;
}

uint64_t std::unique_ptr<std::__thread_struct>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    MEMORY[0x25A2B1590]();
    JUMPOUT(0x25A2B1780);
  }
  return result;
}

uint64_t std::deque<std::function<void ()(void)>>::~deque[abi:ne180100](void *a1)
{
  unint64_t v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    uint64_t v4 = a1 + 5;
    unint64_t v3 = (void **)a1[1];
  }
  else
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 7];
    uint64_t v7 = (char *)*v6 + 32 * (v5 & 0x7F);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((a1[5] + v5) & 0x7F);
    if (v7 != (char *)v8)
    {
      do
      {
        uint64_t v7 = (char *)(std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v7) + 4);
        if (v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      unint64_t v2 = (void **)a1[1];
      unint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 64;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 128;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

void mlx::core::scheduler::Scheduler::Scheduler(mlx::core::scheduler::Scheduler *this)
{
  *(_DWORD *)this = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = 0;
  *((void *)this + 9) = 1018212795;
  *((_DWORD *)this + 16) = 1065353216;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 850045863;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = 0;
  if (mlx::core::metal::is_available(this)) {
    mlx::core::scheduler::Scheduler::new_stream();
  }
  mlx::core::scheduler::Scheduler::new_stream();
}

void sub_256E72EC8(_Unwind_Exception *a1)
{
  std::mutex::~mutex(v4);
  std::condition_variable::~condition_variable(v3);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table(v2);
  uint64_t v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 16) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::__emplace_unique_key_args<mlx::core::Device::DeviceType,std::pair<mlx::core::Device::DeviceType const,mlx::core::Stream>>(uint64_t a1, int *a2, _OWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x20uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_OWORD *)v10 + 1) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,mlx::core::array>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mlx::core::array>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mlx::core::array>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mlx::core::array>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  int v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    *int v19 = v10;
    goto LABEL_39;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    int v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_256E7310C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void mlx::core::scheduler::Scheduler::~Scheduler(mlx::core::scheduler::Scheduler *this)
{
  uint64_t v2 = (mlx::core::scheduler::StreamThread **)*((void *)this + 1);
  unint64_t v3 = (mlx::core::scheduler::StreamThread **)*((void *)this + 2);
  while (v2 != v3)
  {
    if (*v2)
    {
      mlx::core::scheduler::StreamThread::~StreamThread(*v2);
      MEMORY[0x25A2B1780]();
    }
    ++v2;
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 120));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)this + 32);
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
}

void mlx::core::scheduler::StreamThread::~StreamThread(mlx::core::scheduler::StreamThread *this)
{
  mlx::core::synchronize(*(void *)((char *)this + 164), *((_DWORD *)this + 43));
  std::mutex::lock((std::mutex *)this);
  *((unsigned char *)this + 160) = 1;
  std::mutex::unlock((std::mutex *)this);
  std::condition_variable::notify_one((std::condition_variable *)((char *)this + 112));
  std::thread::join((std::thread *)this + 22);
  std::thread::~thread((std::thread *)this + 22);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 112));
  std::deque<std::function<void ()(void)>>::~deque[abi:ne180100]((void *)this + 8);
  std::mutex::~mutex((std::mutex *)this);
}

void *std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

std::promise<void> *_ZNSt3__115allocate_sharedB8ne180100INS_7promiseIvEENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  uint64_t v2 = (std::promise<void> *)operator new(0x20uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceINS_7promiseIvEENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_256E73344(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

std::promise<void> *_ZNSt3__120__shared_ptr_emplaceINS_7promiseIvEENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(std::promise<void> *a1)
{
  a1[1].__state_ = 0;
  a1[2].__state_ = 0;
  a1->__state_ = (std::__assoc_sub_state *)&unk_270632658;
  std::promise<void>::promise(a1 + 3);
  return a1;
}

void sub_256E733A0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::promise<void>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632658;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::promise<void>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632658;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x25A2B1780);
}

void std::__shared_ptr_emplace<std::promise<void>>::__on_zero_shared()
{
}

void std::deque<std::function<void ()(void)>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    uint8x8_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint8x8_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      std::vector<int> v38 = (uint64_t *)a1[1];
      uint8x8_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint8x8_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    int v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    uint8x8_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    uint8x8_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      char v37 = &v34[8 * v47];
      unsigned int v48 = (uint64_t *)a1[1];
      uint8x8_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint8x8_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        int v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)int v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      int v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint8x8_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  std::vector<int> v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_back(&v54, &v53);
  unsigned int v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_front((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_256E73700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_back(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  unint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    unint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      unint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        unint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      unsigned int v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        unint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        unint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      unint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)unint64_t v6 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_back(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void *std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_2706326A8;
  unint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_2706326A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  JUMPOUT(0x25A2B1780);
}

void *std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = &unk_2706326A8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_2706326A8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  operator delete(__p);
}

void std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
}

uint64_t std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<mlx::core::synchronize(mlx::core::Stream)::$_0,std::allocator<mlx::core::synchronize(mlx::core::Stream)::$_0>,void ()(void)>::target_type()
{
}

void mlx::core::scheduler::StreamThread::enqueue<std::function<void ()(void)>>(uint64_t a1, uint64_t a2)
{
  std::mutex::lock((std::mutex *)a1);
  if (*(unsigned char *)(a1 + 160))
  {
    exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x25A2B1470](exception, "Cannot enqueue work after stream is stopped.");
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  std::deque<std::function<void ()(void)>>::emplace_back<std::function<void ()(void)>>((void *)(a1 + 64), a2);
  std::mutex::unlock((std::mutex *)a1);
  std::condition_variable::notify_one((std::condition_variable *)(a1 + 112));
}

void sub_256E73E44(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::function<void ()(void)>>::emplace_back<std::function<void ()(void)>>(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = 16 * (v5 - v4) - 1;
  if (v5 == v4) {
    uint64_t v6 = 0;
  }
  if (v6 == a1[5] + a1[4])
  {
    std::deque<std::function<void ()(void)>>::__add_back_capacity(a1);
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
  }
  if (v5 == v4)
  {
    uint64_t v8 = 0;
  }
  else
  {
    unint64_t v7 = a1[5] + a1[4];
    uint64_t v8 = *(void *)(v4 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F);
  }
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](v8, a2);
  uint64_t v9 = a1[4];
  uint64_t v10 = a1[5] + 1;
  a1[5] = v10;
  unint64_t v11 = v9 + v10;
  uint64_t v12 = a1[1];
  uint64_t v13 = (void *)(v12 + 8 * (v11 >> 7));
  uint64_t v14 = *v13 + 32 * (v11 & 0x7F);
  if (a1[2] == v12) {
    uint64_t v14 = 0;
  }
  if (v14 == *v13) {
    uint64_t v14 = *(v13 - 1) + 4096;
  }
  return v14 - 32;
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void mlx::core::Gather::eval(uint64_t a1, uint64_t a2, int ***a3)
{
  v15[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = mlx::core::allocator::malloc_or_wait((mlx::core::allocator *)(*((unsigned __int8 *)*a3 + 60) * (void)(*a3)[6]));
  v15[0] = &unk_27062AEC8;
  v15[1] = mlx::core::allocator::free;
  v15[3] = v15;
  mlx::core::array::set_data(a3, (uint64_t)v6, (uint64_t)v15);
  std::__function::__value_func<void ()(mlx::core::allocator::Buffer)>::~__value_func[abi:ne180100](v15);
  uint64_t v8 = *(mlx::core::array **)a2;
  unint64_t v7 = *(char **)(a2 + 8);
  uint64_t v9 = (char *)(*(void *)a2 + 16);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<std::__wrap_iter<mlx::core::array const*>,std::__wrap_iter<mlx::core::array const*>>((char *)&v11, v9, v7, (v7 - v9) >> 4);
  if (v11 != v12)
  {
    switch(*(_DWORD *)(*(void *)v11 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_gather<unsigned char>(v8, &v11, (uint64_t)a3, (void *)(a1 + 24), (int **)(a1 + 48));
        goto LABEL_4;
      case 2:
        mlx::core::dispatch_gather<unsigned int>(v8, &v11, (uint64_t)a3, (void *)(a1 + 24), (int **)(a1 + 48));
        goto LABEL_4;
      case 3:
        mlx::core::dispatch_gather<signed char>(v8, &v11, (uint64_t)a3, (void *)(a1 + 24), (int **)(a1 + 48));
        goto LABEL_4;
      case 4:
        mlx::core::dispatch_gather<int>((uint64_t)v8, &v11, (uint64_t)a3, (void *)(a1 + 24), (int **)(a1 + 48));
        goto LABEL_4;
      case 5:
        mlx::core::dispatch_gather<long long>(v8, &v11, (uint64_t)a3, (void *)(a1 + 24), (int **)(a1 + 48));
        goto LABEL_4;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Gather::eval] Cannot gather with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        goto LABEL_4;
    }
  }
  mlx::core::dispatch_gather<BOOL>(v8, &v11, (uint64_t)a3, (void *)(a1 + 24), (int **)(a1 + 48));
LABEL_4:
  uint64_t v14 = (void **)&v11;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v14);
}

void sub_256E741C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14)
{
  __cxa_free_exception(v14);
  a13 = &a10;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

mlx::core::array *mlx::core::dispatch_gather<BOOL>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  switch(*(_DWORD *)(*(void *)a3 + 56))
  {
    case 0:
      this = mlx::core::gather<BOOL,BOOL>(this, a2, a3, a4, a5);
      break;
    case 1:
    case 3:
      this = mlx::core::gather<unsigned char,BOOL>(this, a2, a3, a4, a5);
      break;
    case 2:
    case 4:
      this = mlx::core::gather<unsigned int,BOOL>(this, a2, a3, a4, a5);
      break;
    case 5:
      this = mlx::core::gather<long long,BOOL>(this, a2, a3, a4, a5);
      break;
    case 6:
      this = mlx::core::gather<float,BOOL>(this, a2, a3, a4, a5);
      break;
    default:
      return this;
  }
  return this;
}

mlx::core::array *mlx::core::dispatch_gather<unsigned char>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  switch(*(_DWORD *)(*(void *)a3 + 56))
  {
    case 0:
      this = mlx::core::gather<BOOL,BOOL>(this, a2, a3, a4, a5);
      break;
    case 1:
    case 3:
      this = mlx::core::gather<unsigned char,BOOL>(this, a2, a3, a4, a5);
      break;
    case 2:
    case 4:
      this = mlx::core::gather<unsigned int,BOOL>(this, a2, a3, a4, a5);
      break;
    case 5:
      this = mlx::core::gather<long long,BOOL>(this, a2, a3, a4, a5);
      break;
    case 6:
      this = mlx::core::gather<float,BOOL>(this, a2, a3, a4, a5);
      break;
    default:
      return this;
  }
  return this;
}

mlx::core::array *mlx::core::dispatch_gather<unsigned int>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  switch(*(_DWORD *)(*(void *)a3 + 56))
  {
    case 0:
      this = mlx::core::gather<BOOL,unsigned int>(this, a2, a3, a4, a5);
      break;
    case 1:
    case 3:
      this = mlx::core::gather<unsigned char,unsigned int>(this, a2, a3, a4, a5);
      break;
    case 2:
    case 4:
      this = mlx::core::gather<unsigned int,unsigned int>(this, a2, a3, a4, a5);
      break;
    case 5:
      this = mlx::core::gather<long long,unsigned int>(this, a2, a3, a4, a5);
      break;
    case 6:
      this = mlx::core::gather<float,unsigned int>(this, a2, a3, a4, a5);
      break;
    default:
      return this;
  }
  return this;
}

mlx::core::array *mlx::core::dispatch_gather<signed char>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  switch(*(_DWORD *)(*(void *)a3 + 56))
  {
    case 0:
      this = mlx::core::gather<BOOL,signed char>(this, a2, a3, a4, a5);
      break;
    case 1:
    case 3:
      this = mlx::core::gather<unsigned char,signed char>(this, a2, a3, a4, a5);
      break;
    case 2:
    case 4:
      this = mlx::core::gather<unsigned int,signed char>(this, a2, a3, a4, a5);
      break;
    case 5:
      this = mlx::core::gather<long long,signed char>(this, a2, a3, a4, a5);
      break;
    case 6:
      this = mlx::core::gather<float,signed char>(this, a2, a3, a4, a5);
      break;
    default:
      return this;
  }
  return this;
}

uint64_t mlx::core::dispatch_gather<int>(uint64_t this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  switch(*(_DWORD *)(*(void *)a3 + 56))
  {
    case 0:
      this = mlx::core::gather<BOOL,int>(this, a2, a3, a4, a5);
      break;
    case 1:
    case 3:
      this = mlx::core::gather<unsigned char,int>(this, a2, a3, a4, a5);
      break;
    case 2:
    case 4:
      this = mlx::core::gather<unsigned int,int>(this, a2, a3, a4, a5);
      break;
    case 5:
      this = mlx::core::gather<long long,int>(this, a2, a3, a4, a5);
      break;
    case 6:
      this = mlx::core::gather<float,int>(this, a2, a3, a4, a5);
      break;
    default:
      return this;
  }
  return this;
}

mlx::core::array *mlx::core::dispatch_gather<long long>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  switch(*(_DWORD *)(*(void *)a3 + 56))
  {
    case 0:
      this = mlx::core::gather<BOOL,long long>(this, a2, a3, a4, a5);
      break;
    case 1:
    case 3:
      this = mlx::core::gather<unsigned char,long long>(this, a2, a3, a4, a5);
      break;
    case 2:
    case 4:
      this = mlx::core::gather<unsigned int,long long>(this, a2, a3, a4, a5);
      break;
    case 5:
      this = mlx::core::gather<long long,long long>(this, a2, a3, a4, a5);
      break;
    case 6:
      this = mlx::core::gather<float,long long>(this, a2, a3, a4, a5);
      break;
    default:
      return this;
  }
  return this;
}

void mlx::core::Scatter::eval(uint64_t a1, uint64_t a2, int ***a3)
{
  uint64_t v4 = *(mlx::core::array **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  if ((unint64_t)(v3 - *(void *)a2) <= 0x1F) {
    mlx::core::Scatter::eval();
  }
  memset(v11, 0, sizeof(v11));
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<std::__wrap_iter<mlx::core::array const*>,std::__wrap_iter<mlx::core::array const*>>((char *)v11, (void *)v4 + 2, (void *)(v3 - 16), (v3 - 16 - ((uint64_t)v4 + 16)) >> 4);
  uint64_t v8 = *(void *)(a2 + 8);
  mlx::core::copy(v4, a3, 2, v9);
  uint64_t v10 = (uint64_t **)(v8 - 16);
  switch(*(_DWORD *)(*(void *)v4 + 56))
  {
    case 0:
      mlx::core::dispatch_scatter<BOOL>((mlx::core::array *)a3, v11, v10, (void *)(a1 + 24), *(_DWORD *)(a1 + 20));
      break;
    case 1:
      mlx::core::dispatch_scatter<unsigned char>((mlx::core::array *)a3, v11, v10, (void *)(a1 + 24), *(_DWORD *)(a1 + 20));
      break;
    case 2:
      mlx::core::dispatch_scatter<unsigned int>((mlx::core::array *)a3, v11, v10, (void *)(a1 + 24), *(_DWORD *)(a1 + 20));
      break;
    case 3:
      mlx::core::dispatch_scatter<signed char>((mlx::core::array *)a3, v11, v10, (void *)(a1 + 24), *(_DWORD *)(a1 + 20));
      break;
    case 4:
      mlx::core::dispatch_scatter<int>((mlx::core::array *)a3, v11, v10, (void *)(a1 + 24), *(_DWORD *)(a1 + 20));
      break;
    case 5:
      mlx::core::dispatch_scatter<long long>((mlx::core::array *)a3, v11, v10, (void *)(a1 + 24), *(_DWORD *)(a1 + 20));
      break;
    case 6:
      mlx::core::dispatch_scatter<float>((mlx::core::array *)a3, v11, v10, (void *)(a1 + 24), *(_DWORD *)(a1 + 20));
      break;
    default:
      break;
  }
  uint64_t v12 = (void **)v11;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v12);
}

void sub_256E74624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void mlx::core::dispatch_scatter<BOOL>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  if (*a2 != a2[1])
  {
    switch(*(_DWORD *)(*(void *)*a2 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_scatter_inds<BOOL,unsigned char>(a1, a2, a3, a4, a5);
        return;
      case 2:
        mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(a1, a2, a3, a4, a5);
        return;
      case 3:
        mlx::core::dispatch_scatter_inds<BOOL,signed char>(a1, a2, a3, a4, a5);
        return;
      case 4:
        mlx::core::dispatch_scatter_inds<BOOL,int>(a1, a2, a3, a4, a5);
        return;
      case 5:
        mlx::core::dispatch_scatter_inds<BOOL,long long>(a1, a2, a3, a4, a5);
        return;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Scatter::eval_cpu] Cannot scatter with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        return;
    }
  }
  mlx::core::dispatch_scatter_inds<BOOL,BOOL>(a1, a2, a3, a4, a5);
}

void sub_256E74790(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::dispatch_scatter<unsigned char>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  if (*a2 != a2[1])
  {
    switch(*(_DWORD *)(*(void *)*a2 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_scatter_inds<unsigned char,unsigned char>(a1, a2, a3, a4, a5);
        return;
      case 2:
        mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(a1, a2, a3, a4, a5);
        return;
      case 3:
        mlx::core::dispatch_scatter_inds<unsigned char,signed char>(a1, a2, a3, a4, a5);
        return;
      case 4:
        mlx::core::dispatch_scatter_inds<unsigned char,int>(a1, a2, a3, a4, a5);
        return;
      case 5:
        mlx::core::dispatch_scatter_inds<unsigned char,long long>(a1, a2, a3, a4, a5);
        return;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Scatter::eval_cpu] Cannot scatter with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        return;
    }
  }
  mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(a1, a2, a3, a4, a5);
}

void sub_256E748F8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::dispatch_scatter<unsigned int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  if (*a2 != a2[1])
  {
    switch(*(_DWORD *)(*(void *)*a2 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_scatter_inds<unsigned int,unsigned char>(a1, a2, a3, a4, a5);
        return;
      case 2:
        mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(a1, a2, a3, a4, a5);
        return;
      case 3:
        mlx::core::dispatch_scatter_inds<unsigned int,signed char>(a1, a2, a3, a4, a5);
        return;
      case 4:
        mlx::core::dispatch_scatter_inds<unsigned int,int>(a1, a2, a3, a4, a5);
        return;
      case 5:
        mlx::core::dispatch_scatter_inds<unsigned int,long long>(a1, a2, a3, a4, a5);
        return;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Scatter::eval_cpu] Cannot scatter with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        return;
    }
  }
  mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(a1, a2, a3, a4, a5);
}

void sub_256E74A60(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::dispatch_scatter<signed char>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  if (*a2 != a2[1])
  {
    switch(*(_DWORD *)(*(void *)*a2 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_scatter_inds<signed char,unsigned char>(a1, a2, a3, a4, a5);
        return;
      case 2:
        mlx::core::dispatch_scatter_inds<signed char,unsigned int>(a1, a2, a3, a4, a5);
        return;
      case 3:
        mlx::core::dispatch_scatter_inds<signed char,signed char>(a1, a2, a3, a4, a5);
        return;
      case 4:
        mlx::core::dispatch_scatter_inds<signed char,int>(a1, a2, a3, a4, a5);
        return;
      case 5:
        mlx::core::dispatch_scatter_inds<signed char,long long>(a1, a2, a3, a4, a5);
        return;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Scatter::eval_cpu] Cannot scatter with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        return;
    }
  }
  mlx::core::dispatch_scatter_inds<signed char,BOOL>(a1, a2, a3, a4, a5);
}

void sub_256E74BC8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::dispatch_scatter<int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  if (*a2 != a2[1])
  {
    switch(*(_DWORD *)(*(void *)*a2 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_scatter_inds<int,unsigned char>(a1, a2, a3, a4, a5);
        return;
      case 2:
        mlx::core::dispatch_scatter_inds<int,unsigned int>(a1, a2, a3, a4, a5);
        return;
      case 3:
        mlx::core::dispatch_scatter_inds<int,signed char>(a1, a2, a3, a4, a5);
        return;
      case 4:
        mlx::core::dispatch_scatter_inds<int,int>(a1, a2, a3, a4, a5);
        return;
      case 5:
        mlx::core::dispatch_scatter_inds<int,long long>(a1, a2, a3, a4, a5);
        return;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Scatter::eval_cpu] Cannot scatter with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        return;
    }
  }
  mlx::core::dispatch_scatter_inds<int,BOOL>(a1, a2, a3, a4, a5);
}

void sub_256E74D30(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::dispatch_scatter<long long>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  if (*a2 != a2[1])
  {
    switch(*(_DWORD *)(*(void *)*a2 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_scatter_inds<long long,unsigned char>(a1, a2, a3, a4, a5);
        return;
      case 2:
        mlx::core::dispatch_scatter_inds<long long,unsigned int>(a1, a2, a3, a4, a5);
        return;
      case 3:
        mlx::core::dispatch_scatter_inds<long long,signed char>(a1, a2, a3, a4, a5);
        return;
      case 4:
        mlx::core::dispatch_scatter_inds<long long,int>(a1, a2, a3, a4, a5);
        return;
      case 5:
        mlx::core::dispatch_scatter_inds<long long,long long>(a1, a2, a3, a4, a5);
        return;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Scatter::eval_cpu] Cannot scatter with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        return;
    }
  }
  mlx::core::dispatch_scatter_inds<long long,BOOL>(a1, a2, a3, a4, a5);
}

void sub_256E74E98(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::dispatch_scatter<float>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  if (*a2 != a2[1])
  {
    switch(*(_DWORD *)(*(void *)*a2 + 56))
    {
      case 0:
        break;
      case 1:
        mlx::core::dispatch_scatter_inds<float,unsigned char>(a1, a2, a3, a4, a5);
        return;
      case 2:
        mlx::core::dispatch_scatter_inds<float,unsigned int>(a1, a2, a3, a4, a5);
        return;
      case 3:
        mlx::core::dispatch_scatter_inds<float,signed char>(a1, a2, a3, a4, a5);
        return;
      case 4:
        mlx::core::dispatch_scatter_inds<float,int>(a1, a2, a3, a4, a5);
        return;
      case 5:
        mlx::core::dispatch_scatter_inds<float,long long>(a1, a2, a3, a4, a5);
        return;
      case 6:
        exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](exception, "[Scatter::eval_cpu] Cannot scatter with floating point indices.");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      default:
        return;
    }
  }
  mlx::core::dispatch_scatter_inds<float,BOOL>(a1, a2, a3, a4, a5);
}

void sub_256E75000(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<std::__wrap_iter<mlx::core::array const*>,std::__wrap_iter<mlx::core::array const*>>(char *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<mlx::core::array>::__vallocate[abi:ne180100](result, a4);
    for (uint64_t i = (void *)*((void *)v6 + 1); a2 != a3; a2 += 2)
    {
      *uint64_t i = *a2;
      uint64_t v8 = a2[1];
      i[1] = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      i += 2;
    }
    *((void *)v6 + 1) = i;
  }
  return result;
}

void sub_256E750BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

mlx::core::array *mlx::core::gather<BOOL,BOOL>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  uint64_t v52 = a5;
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v60 = 0;
      uint64_t v29 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      __leunint64_t n = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            double v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v60;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v60;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned __int8 *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v43 = v29 + 1;
          *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v32);
        }
        else if (v53)
        {
          this = (mlx::core::array *)memmove((void *)(v55 + v29), (const void *)(v56 + v32), __len);
          uint64_t v43 = v29 + __len;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v52;
          uint64_t v46 = ((unint64_t)((char *)v52[1] - (char *)*v52) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v48 + v32);
            ++v44;
            ++v29;
          }
          while (v44 != __len);
        }
        uint64_t v29 = v43;
        ++v60;
      }
      while (v60 != v54);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned char,BOOL>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      uint64_t v52 = a5;
      uint64_t v59 = v7;
      __leunint64_t n = v26;
      do
      {
        uint64_t v31 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v33 = 0;
        }
        else
        {
          unint64_t v32 = 0;
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = *(int *)(*a4 + 4 * v32);
            uint64_t v35 = *(uint64_t **)(v31 + 16 * v32);
            uint64_t v36 = v29;
            if ((v35[21] & 2) == 0)
            {
              uint64_t v37 = *v35;
              unint64_t v38 = (unint64_t)(v35[1] - *v35) >> 2;
              uint64_t v36 = 0;
              uint64_t v39 = (v38 - 1);
              if ((int)v38 - 1 >= 0)
              {
                uint64_t v40 = v35[3];
                int quot = v29;
                do
                {
                  ldiv_t v42 = ldiv(quot, *(int *)(v37 + 4 * v39));
                  int quot = v42.quot;
                  v36 += *(void *)(v40 + 8 * v39--) * v42.rem;
                }
                while (v39 != -1);
              }
            }
            uint64_t v43 = *(unsigned __int8 *)(v35[19] + v36);
            this = (mlx::core::array *)mlx::core::array::shape(v59, v34);
            v33 += *(void *)(*(void *)(*(void *)v59 + 24) + 8 * v34) * v43;
            ++v32;
            uint64_t v31 = *a2;
          }
          while (v32 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v44 = v30 + 1;
          *(unsigned char *)(v55 + v30) = *(unsigned char *)(v56 + v33);
        }
        else if (v53)
        {
          this = (mlx::core::array *)memmove((void *)(v55 + v30), (const void *)(v56 + v33), __len);
          uint64_t v44 = v30 + __len;
        }
        else
        {
          for (uint64_t i = 0; i != __len; ++i)
          {
            uint64_t v46 = *v52;
            unint64_t v47 = (unint64_t)((char *)v52[1] - (char *)*v52) >> 2;
            uint64_t v48 = 0;
            uint64_t v49 = (v47 - 1);
            if ((int)v47 - 1 >= 0)
            {
              uint64_t v50 = *(void *)(*(void *)v59 + 24);
              LODWORD(this) = i;
              do
              {
                ldiv_t v51 = ldiv((int)this, v46[v49]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v50 + 8 * v49--) * v51.rem;
              }
              while (v49 != -1);
            }
            uint64_t v44 = v30 + 1;
            *(unsigned char *)(v55 + v30++) = *(unsigned char *)(v56 + v48 + v33);
          }
        }
        ++v29;
        uint64_t v30 = v44;
      }
      while (v29 != v54);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned int,BOOL>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned __int8 *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<long long,BOOL>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 8 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned __int8 *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 8 * v29), (const void *)(v57 + 8 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<float,BOOL>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned __int8 *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<BOOL,unsigned int>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  uint64_t v52 = a5;
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v60 = 0;
      uint64_t v29 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      __leunint64_t n = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v60;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v60;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned int *)(v34[19] + 4 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v43 = v29 + 1;
          *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v32);
        }
        else if (v53)
        {
          this = (mlx::core::array *)memmove((void *)(v55 + v29), (const void *)(v56 + v32), __len);
          uint64_t v43 = v29 + __len;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v52;
          uint64_t v46 = ((unint64_t)((char *)v52[1] - (char *)*v52) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v48 + v32);
            ++v44;
            ++v29;
          }
          while (v44 != __len);
        }
        uint64_t v29 = v43;
        ++v60;
      }
      while (v60 != v54);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned char,unsigned int>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      uint64_t v52 = a5;
      uint64_t v59 = v7;
      __leunint64_t n = v26;
      do
      {
        uint64_t v31 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v33 = 0;
        }
        else
        {
          unint64_t v32 = 0;
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = *(int *)(*a4 + 4 * v32);
            uint64_t v35 = *(uint64_t **)(v31 + 16 * v32);
            uint64_t v36 = v29;
            if ((v35[21] & 2) == 0)
            {
              uint64_t v37 = *v35;
              unint64_t v38 = (unint64_t)(v35[1] - *v35) >> 2;
              uint64_t v36 = 0;
              uint64_t v39 = (v38 - 1);
              if ((int)v38 - 1 >= 0)
              {
                uint64_t v40 = v35[3];
                int quot = v29;
                do
                {
                  ldiv_t v42 = ldiv(quot, *(int *)(v37 + 4 * v39));
                  int quot = v42.quot;
                  v36 += *(void *)(v40 + 8 * v39--) * v42.rem;
                }
                while (v39 != -1);
              }
            }
            uint64_t v43 = *(unsigned int *)(v35[19] + 4 * v36);
            this = (mlx::core::array *)mlx::core::array::shape(v59, v34);
            v33 += *(void *)(*(void *)(*(void *)v59 + 24) + 8 * v34) * v43;
            ++v32;
            uint64_t v31 = *a2;
          }
          while (v32 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v44 = v30 + 1;
          *(unsigned char *)(v55 + v30) = *(unsigned char *)(v56 + v33);
        }
        else if (v53)
        {
          this = (mlx::core::array *)memmove((void *)(v55 + v30), (const void *)(v56 + v33), __len);
          uint64_t v44 = v30 + __len;
        }
        else
        {
          for (uint64_t i = 0; i != __len; ++i)
          {
            uint64_t v46 = *v52;
            unint64_t v47 = (unint64_t)((char *)v52[1] - (char *)*v52) >> 2;
            uint64_t v48 = 0;
            uint64_t v49 = (v47 - 1);
            if ((int)v47 - 1 >= 0)
            {
              uint64_t v50 = *(void *)(*(void *)v59 + 24);
              LODWORD(this) = i;
              do
              {
                ldiv_t v51 = ldiv((int)this, v46[v49]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v50 + 8 * v49--) * v51.rem;
              }
              while (v49 != -1);
            }
            uint64_t v44 = v30 + 1;
            *(unsigned char *)(v55 + v30++) = *(unsigned char *)(v56 + v48 + v33);
          }
        }
        ++v29;
        uint64_t v30 = v44;
      }
      while (v29 != v54);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned int,unsigned int>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned int *)(v34[19] + 4 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<long long,unsigned int>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 8 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned int *)(v34[19] + 4 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 8 * v29), (const void *)(v57 + 8 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<float,unsigned int>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(unsigned int *)(v34[19] + 4 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33) * v42;
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<BOOL,signed char>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_59;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_59:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      unint64_t v55 = v28 / v26;
      __leunint64_t n = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(char *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            uint64_t v43 = (int)this;
            if ((int)v42 >= 0) {
              uint64_t v43 = 0;
            }
            v32 += (v43 + v42) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v44 = v29 + 1;
          *(unsigned char *)(v56 + v29) = *(unsigned char *)(v57 + v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + v29), (const void *)(v57 + v32), __len);
          uint64_t v44 = v29 + __len;
        }
        else
        {
          uint64_t v45 = 0;
          uint64_t v46 = *v53;
          uint64_t v47 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v48 = *(void *)v7;
          do
          {
            uint64_t v49 = 0;
            if ((v47 & 0x80000000) == 0)
            {
              uint64_t v50 = *(void *)(v48 + 24);
              uint64_t v51 = v47;
              LODWORD(this) = v45;
              do
              {
                ldiv_t v52 = ldiv((int)this, v46[v51]);
                this = (mlx::core::array *)v52.quot;
                v49 += *(void *)(v50 + 8 * v51--) * v52.rem;
              }
              while (v51 != -1);
            }
            uint64_t v44 = v29 + 1;
            *(unsigned char *)(v56 + v29) = *(unsigned char *)(v57 + v49 + v32);
            ++v45;
            ++v29;
          }
          while (v45 != __len);
        }
        uint64_t v29 = v44;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned char,signed char>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_59;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_59:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      unint64_t v55 = v28 / v26;
      BOOL v53 = a5;
      uint64_t v60 = v7;
      __leunint64_t n = v26;
      do
      {
        uint64_t v31 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v33 = 0;
        }
        else
        {
          unint64_t v32 = 0;
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = *(int *)(*a4 + 4 * v32);
            uint64_t v35 = *(uint64_t **)(v31 + 16 * v32);
            uint64_t v36 = v29;
            if ((v35[21] & 2) == 0)
            {
              uint64_t v37 = *v35;
              unint64_t v38 = (unint64_t)(v35[1] - *v35) >> 2;
              uint64_t v36 = 0;
              uint64_t v39 = (v38 - 1);
              if ((int)v38 - 1 >= 0)
              {
                uint64_t v40 = v35[3];
                int quot = v29;
                do
                {
                  ldiv_t v42 = ldiv(quot, *(int *)(v37 + 4 * v39));
                  int quot = v42.quot;
                  v36 += *(void *)(v40 + 8 * v39--) * v42.rem;
                }
                while (v39 != -1);
              }
            }
            uint64_t v43 = *(char *)(v35[19] + v36);
            this = (mlx::core::array *)mlx::core::array::shape(v60, v34);
            uint64_t v44 = (int)this;
            if ((int)v43 >= 0) {
              uint64_t v44 = 0;
            }
            v33 += (v44 + v43) * *(void *)(*(void *)(*(void *)v60 + 24) + 8 * v34);
            ++v32;
            uint64_t v31 = *a2;
          }
          while (v32 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v45 = v30 + 1;
          *(unsigned char *)(v56 + v30) = *(unsigned char *)(v57 + v33);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + v30), (const void *)(v57 + v33), __len);
          uint64_t v45 = v30 + __len;
        }
        else
        {
          for (uint64_t i = 0; i != __len; ++i)
          {
            uint64_t v47 = *v53;
            unint64_t v48 = (unint64_t)((char *)v53[1] - (char *)*v53) >> 2;
            uint64_t v49 = 0;
            uint64_t v50 = (v48 - 1);
            if ((int)v48 - 1 >= 0)
            {
              uint64_t v51 = *(void *)(*(void *)v60 + 24);
              LODWORD(this) = i;
              do
              {
                ldiv_t v52 = ldiv((int)this, v47[v50]);
                this = (mlx::core::array *)v52.quot;
                v49 += *(void *)(v51 + 8 * v50--) * v52.rem;
              }
              while (v50 != -1);
            }
            uint64_t v45 = v30 + 1;
            *(unsigned char *)(v56 + v30++) = *(unsigned char *)(v57 + v49 + v33);
          }
        }
        ++v29;
        uint64_t v30 = v45;
      }
      while (v29 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned int,signed char>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v54 = a5;
  BOOL v55 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_59;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_59:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v62 = 0;
      uint64_t v29 = 0;
      uint64_t v57 = *(void *)(*(void *)a3 + 152);
      uint64_t v58 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v56 = v28 / v26;
      unint64_t v59 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v62;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v62;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(char *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            uint64_t v43 = (int)this;
            if ((int)v42 >= 0) {
              uint64_t v43 = 0;
            }
            v32 += (v43 + v42) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v59 == 1)
        {
          uint64_t v44 = v29 + 1;
          *(_DWORD *)(v57 + 4 * v29) = *(_DWORD *)(v58 + 4 * v32);
        }
        else if (v55)
        {
          this = (mlx::core::array *)memmove((void *)(v57 + 4 * v29), (const void *)(v58 + 4 * v32), __len);
          uint64_t v44 = v29 + v59;
        }
        else
        {
          uint64_t v45 = 0;
          uint64_t v46 = *v54;
          uint64_t v47 = ((unint64_t)((char *)v54[1] - (char *)*v54) >> 2) - 1;
          uint64_t v48 = *(void *)v7;
          do
          {
            uint64_t v49 = 0;
            if ((v47 & 0x80000000) == 0)
            {
              uint64_t v50 = *(void *)(v48 + 24);
              uint64_t v51 = v47;
              LODWORD(this) = v45;
              do
              {
                ldiv_t v52 = ldiv((int)this, v46[v51]);
                this = (mlx::core::array *)v52.quot;
                v49 += *(void *)(v50 + 8 * v51--) * v52.rem;
              }
              while (v51 != -1);
            }
            uint64_t v44 = v29 + 1;
            *(_DWORD *)(v57 + 4 * v29) = *(_DWORD *)(v58 + 4 * (v49 + v32));
            ++v45;
            ++v29;
          }
          while (v45 != v59);
        }
        uint64_t v29 = v44;
        ++v62;
      }
      while (v62 != v56);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<long long,signed char>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v54 = a5;
  BOOL v55 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_59;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_59:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v62 = 0;
      uint64_t v29 = 0;
      uint64_t v57 = *(void *)(*(void *)a3 + 152);
      uint64_t v58 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 8 * v26;
      unint64_t v56 = v28 / v26;
      unint64_t v59 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v62;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v62;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(char *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            uint64_t v43 = (int)this;
            if ((int)v42 >= 0) {
              uint64_t v43 = 0;
            }
            v32 += (v43 + v42) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v59 == 1)
        {
          uint64_t v44 = v29 + 1;
          *(void *)(v57 + 8 * v29) = *(void *)(v58 + 8 * v32);
        }
        else if (v55)
        {
          this = (mlx::core::array *)memmove((void *)(v57 + 8 * v29), (const void *)(v58 + 8 * v32), __len);
          uint64_t v44 = v29 + v59;
        }
        else
        {
          uint64_t v45 = 0;
          uint64_t v46 = *v54;
          uint64_t v47 = ((unint64_t)((char *)v54[1] - (char *)*v54) >> 2) - 1;
          uint64_t v48 = *(void *)v7;
          do
          {
            uint64_t v49 = 0;
            if ((v47 & 0x80000000) == 0)
            {
              uint64_t v50 = *(void *)(v48 + 24);
              uint64_t v51 = v47;
              LODWORD(this) = v45;
              do
              {
                ldiv_t v52 = ldiv((int)this, v46[v51]);
                this = (mlx::core::array *)v52.quot;
                v49 += *(void *)(v50 + 8 * v51--) * v52.rem;
              }
              while (v51 != -1);
            }
            uint64_t v44 = v29 + 1;
            *(void *)(v57 + 8 * v29) = *(void *)(v58 + 8 * (v49 + v32));
            ++v45;
            ++v29;
          }
          while (v45 != v59);
        }
        uint64_t v29 = v44;
        ++v62;
      }
      while (v62 != v56);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<float,signed char>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v54 = a5;
  BOOL v55 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_59;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_59:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v62 = 0;
      uint64_t v29 = 0;
      uint64_t v57 = *(void *)(*(void *)a3 + 152);
      uint64_t v58 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v56 = v28 / v26;
      unint64_t v59 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v62;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v62;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(char *)(v34[19] + v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            uint64_t v43 = (int)this;
            if ((int)v42 >= 0) {
              uint64_t v43 = 0;
            }
            v32 += (v43 + v42) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v59 == 1)
        {
          uint64_t v44 = v29 + 1;
          *(_DWORD *)(v57 + 4 * v29) = *(_DWORD *)(v58 + 4 * v32);
        }
        else if (v55)
        {
          this = (mlx::core::array *)memmove((void *)(v57 + 4 * v29), (const void *)(v58 + 4 * v32), __len);
          uint64_t v44 = v29 + v59;
        }
        else
        {
          uint64_t v45 = 0;
          uint64_t v46 = *v54;
          uint64_t v47 = ((unint64_t)((char *)v54[1] - (char *)*v54) >> 2) - 1;
          uint64_t v48 = *(void *)v7;
          do
          {
            uint64_t v49 = 0;
            if ((v47 & 0x80000000) == 0)
            {
              uint64_t v50 = *(void *)(v48 + 24);
              uint64_t v51 = v47;
              LODWORD(this) = v45;
              do
              {
                ldiv_t v52 = ldiv((int)this, v46[v51]);
                this = (mlx::core::array *)v52.quot;
                v49 += *(void *)(v50 + 8 * v51--) * v52.rem;
              }
              while (v51 != -1);
            }
            uint64_t v44 = v29 + 1;
            *(_DWORD *)(v57 + 4 * v29) = *(_DWORD *)(v58 + 4 * (v49 + v32));
            ++v45;
            ++v29;
          }
          while (v45 != v59);
        }
        uint64_t v29 = v44;
        ++v62;
      }
      while (v62 != v56);
    }
  }
  return this;
}

uint64_t mlx::core::gather<BOOL,int>(uint64_t this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = (mlx::core::array *)this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  ldiv_t v52 = a5;
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v60 = 0;
      uint64_t v29 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      __leunint64_t n = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v60;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v60;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(int *)(v34[19] + 4 * v35);
            this = mlx::core::array::shape(v7, v33);
            v32 += (v42 + (int)(this & ((int)v42 >> 31))) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v43 = v29 + 1;
          *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v32);
        }
        else if (v53)
        {
          this = (uint64_t)memmove((void *)(v55 + v29), (const void *)(v56 + v32), __len);
          uint64_t v43 = v29 + __len;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v52;
          uint64_t v46 = ((unint64_t)((char *)v52[1] - (char *)*v52) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v48 + v32);
            ++v44;
            ++v29;
          }
          while (v44 != __len);
        }
        uint64_t v29 = v43;
        ++v60;
      }
      while (v60 != v54);
    }
  }
  return this;
}

uint64_t mlx::core::gather<unsigned char,int>(uint64_t this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = (mlx::core::array *)this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      ldiv_t v52 = a5;
      unint64_t v59 = v7;
      __leunint64_t n = v26;
      do
      {
        uint64_t v31 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v33 = 0;
        }
        else
        {
          unint64_t v32 = 0;
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = *(int *)(*a4 + 4 * v32);
            uint64_t v35 = *(uint64_t **)(v31 + 16 * v32);
            uint64_t v36 = v29;
            if ((v35[21] & 2) == 0)
            {
              uint64_t v37 = *v35;
              unint64_t v38 = (unint64_t)(v35[1] - *v35) >> 2;
              uint64_t v36 = 0;
              uint64_t v39 = (v38 - 1);
              if ((int)v38 - 1 >= 0)
              {
                uint64_t v40 = v35[3];
                int quot = v29;
                do
                {
                  ldiv_t v42 = ldiv(quot, *(int *)(v37 + 4 * v39));
                  int quot = v42.quot;
                  v36 += *(void *)(v40 + 8 * v39--) * v42.rem;
                }
                while (v39 != -1);
              }
            }
            uint64_t v43 = *(int *)(v35[19] + 4 * v36);
            this = mlx::core::array::shape(v59, v34);
            v33 += (v43 + (int)(this & ((int)v43 >> 31))) * *(void *)(*(void *)(*(void *)v59 + 24) + 8 * v34);
            ++v32;
            uint64_t v31 = *a2;
          }
          while (v32 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v44 = v30 + 1;
          *(unsigned char *)(v55 + v30) = *(unsigned char *)(v56 + v33);
        }
        else if (v53)
        {
          this = (uint64_t)memmove((void *)(v55 + v30), (const void *)(v56 + v33), __len);
          uint64_t v44 = v30 + __len;
        }
        else
        {
          for (uint64_t i = 0; i != __len; ++i)
          {
            uint64_t v46 = *v52;
            unint64_t v47 = (unint64_t)((char *)v52[1] - (char *)*v52) >> 2;
            uint64_t v48 = 0;
            uint64_t v49 = (v47 - 1);
            if ((int)v47 - 1 >= 0)
            {
              uint64_t v50 = *(void *)(*(void *)v59 + 24);
              LODWORD(this) = i;
              do
              {
                ldiv_t v51 = ldiv((int)this, v46[v49]);
                this = v51.quot;
                v48 += *(void *)(v50 + 8 * v49--) * v51.rem;
              }
              while (v49 != -1);
            }
            uint64_t v44 = v30 + 1;
            *(unsigned char *)(v55 + v30++) = *(unsigned char *)(v56 + v48 + v33);
          }
        }
        ++v29;
        uint64_t v30 = v44;
      }
      while (v29 != v54);
    }
  }
  return this;
}

uint64_t mlx::core::gather<unsigned int,int>(uint64_t this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = (mlx::core::array *)this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(int *)(v34[19] + 4 * v35);
            this = mlx::core::array::shape(v7, v33);
            v32 += (v42 + (int)(this & ((int)v42 >> 31))) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (uint64_t)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

uint64_t mlx::core::gather<long long,int>(uint64_t this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = (mlx::core::array *)this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 8 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(int *)(v34[19] + 4 * v35);
            this = mlx::core::array::shape(v7, v33);
            v32 += (v42 + (int)(this & ((int)v42 >> 31))) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * v32);
        }
        else if (v54)
        {
          this = (uint64_t)memmove((void *)(v56 + 8 * v29), (const void *)(v57 + 8 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

uint64_t mlx::core::gather<float,int>(uint64_t this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = (mlx::core::array *)this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(int *)(v34[19] + 4 * v35);
            this = mlx::core::array::shape(v7, v33);
            v32 += (v42 + (int)(this & ((int)v42 >> 31))) * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (uint64_t)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<BOOL,long long>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  ldiv_t v52 = a5;
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v60 = 0;
      uint64_t v29 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      __leunint64_t n = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v60;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v60;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(void *)(v34[19] + 8 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += (((int)this & (unint64_t)(v42 >> 63)) + v42)
                 * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v43 = v29 + 1;
          *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v32);
        }
        else if (v53)
        {
          this = (mlx::core::array *)memmove((void *)(v55 + v29), (const void *)(v56 + v32), __len);
          uint64_t v43 = v29 + __len;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v52;
          uint64_t v46 = ((unint64_t)((char *)v52[1] - (char *)*v52) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(unsigned char *)(v55 + v29) = *(unsigned char *)(v56 + v48 + v32);
            ++v44;
            ++v29;
          }
          while (v44 != __len);
        }
        uint64_t v29 = v43;
        ++v60;
      }
      while (v60 != v54);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned char,long long>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      uint64_t v55 = *(void *)(*(void *)a3 + 152);
      uint64_t v56 = *(void *)(*(void *)v7 + 152);
      unint64_t v54 = v28 / v26;
      ldiv_t v52 = a5;
      unint64_t v59 = v7;
      __leunint64_t n = v26;
      do
      {
        uint64_t v31 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v33 = 0;
        }
        else
        {
          unint64_t v32 = 0;
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = *(int *)(*a4 + 4 * v32);
            uint64_t v35 = *(uint64_t **)(v31 + 16 * v32);
            uint64_t v36 = v29;
            if ((v35[21] & 2) == 0)
            {
              uint64_t v37 = *v35;
              unint64_t v38 = (unint64_t)(v35[1] - *v35) >> 2;
              uint64_t v36 = 0;
              uint64_t v39 = (v38 - 1);
              if ((int)v38 - 1 >= 0)
              {
                uint64_t v40 = v35[3];
                int quot = v29;
                do
                {
                  ldiv_t v42 = ldiv(quot, *(int *)(v37 + 4 * v39));
                  int quot = v42.quot;
                  v36 += *(void *)(v40 + 8 * v39--) * v42.rem;
                }
                while (v39 != -1);
              }
            }
            uint64_t v43 = *(void *)(v35[19] + 8 * v36);
            this = (mlx::core::array *)mlx::core::array::shape(v59, v34);
            v33 += (((int)this & (unint64_t)(v43 >> 63)) + v43)
                 * *(void *)(*(void *)(*(void *)v59 + 24) + 8 * v34);
            ++v32;
            uint64_t v31 = *a2;
          }
          while (v32 < (a2[1] - *a2) >> 4);
        }
        if (__len == 1)
        {
          uint64_t v44 = v30 + 1;
          *(unsigned char *)(v55 + v30) = *(unsigned char *)(v56 + v33);
        }
        else if (v53)
        {
          this = (mlx::core::array *)memmove((void *)(v55 + v30), (const void *)(v56 + v33), __len);
          uint64_t v44 = v30 + __len;
        }
        else
        {
          for (uint64_t i = 0; i != __len; ++i)
          {
            uint64_t v46 = *v52;
            unint64_t v47 = (unint64_t)((char *)v52[1] - (char *)*v52) >> 2;
            uint64_t v48 = 0;
            uint64_t v49 = (v47 - 1);
            if ((int)v47 - 1 >= 0)
            {
              uint64_t v50 = *(void *)(*(void *)v59 + 24);
              LODWORD(this) = i;
              do
              {
                ldiv_t v51 = ldiv((int)this, v46[v49]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v50 + 8 * v49--) * v51.rem;
              }
              while (v49 != -1);
            }
            uint64_t v44 = v30 + 1;
            *(unsigned char *)(v55 + v30++) = *(unsigned char *)(v56 + v48 + v33);
          }
        }
        ++v29;
        uint64_t v30 = v44;
      }
      while (v29 != v54);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<unsigned int,long long>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(void *)(v34[19] + 8 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += (((int)this & (unint64_t)(v42 >> 63)) + v42)
                 * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<long long,long long>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 8 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(void *)(v34[19] + 8 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += (((int)this & (unint64_t)(v42 >> 63)) + v42)
                 * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 8 * v29), (const void *)(v57 + 8 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(void *)(v56 + 8 * v29) = *(void *)(v57 + 8 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

mlx::core::array *mlx::core::gather<float,long long>(mlx::core::array *this, uint64_t *a2, uint64_t a3, void *a4, int **a5)
{
  unint64_t v7 = this;
  uint64_t v8 = *a5;
  if ((*(unsigned char *)(*(void *)this + 168) & 2) == 0)
  {
    if ((*(unsigned char *)(*(void *)this + 168) & 4) == 0)
    {
      BOOL v9 = 0;
      goto LABEL_31;
    }
    unint64_t v15 = (unint64_t)((char *)a5[1] - (char *)v8) >> 2;
    int v16 = v15 - 1;
    if ((int)v15 - 1 >= -1) {
      int v16 = -1;
    }
    int v17 = v16 + 1;
    int v18 = v15 + 1;
    while (1)
    {
      int v19 = v18 - 2;
      if (v18 - 2 < 0) {
        break;
      }
      --v18;
      if (v8[v19] != 1) {
        goto LABEL_25;
      }
    }
    int v18 = v17;
LABEL_25:
    unsigned int v22 = v18 - 2;
    if (v18 - 2 >= 0)
    {
      do
      {
        this = (mlx::core::array *)mlx::core::array::shape(v7, v22);
        uint64_t v8 = *a5;
        int v23 = (*a5)[v22];
        BOOL v9 = this == v23;
        BOOL v24 = v22-- != 0;
      }
      while (v24 && this == v23);
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  uint64_t v10 = a5[1];
  uint64_t v11 = (char *)v10 - (char *)v8;
  if (v10 == v8)
  {
    unint64_t v14 = 1;
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v13 = v11 >> 2;
    if (v13 <= 1) {
      unint64_t v13 = 1;
    }
    while (v8[v12] == 1)
    {
      if (v13 == ++v12)
      {
        LODWORD(v12) = v13;
        break;
      }
    }
    unint64_t v14 = (v12 + 1);
  }
  if (v14 >= (uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 2)
  {
LABEL_30:
    BOOL v9 = 1;
    goto LABEL_31;
  }
  do
  {
    this = (mlx::core::array *)mlx::core::array::shape(v7, v14);
    uint64_t v8 = *a5;
    int v20 = (*a5)[v14];
    BOOL v9 = this == v20;
  }
  while (++v14 < (uint64_t)(*(void *)(*(void *)v7 + 8) - **(void **)v7) >> 2 && this == v20);
LABEL_31:
  unint64_t v25 = a5[1];
  BOOL v53 = a5;
  BOOL v54 = v9;
  unint64_t v26 = 1;
  if (v8 == v25) {
    goto LABEL_57;
  }
  do
  {
    uint64_t v27 = *v8++;
    v26 *= v27;
  }
  while (v8 != v25);
  if (v26)
  {
LABEL_57:
    unint64_t v28 = *(void *)(*(void *)a3 + 48);
    if (v26 <= v28)
    {
      uint64_t v61 = 0;
      uint64_t v29 = 0;
      uint64_t v56 = *(void *)(*(void *)a3 + 152);
      uint64_t v57 = *(void *)(*(void *)v7 + 152);
      __leunint64_t n = 4 * v26;
      unint64_t v55 = v28 / v26;
      unint64_t v58 = v26;
      do
      {
        uint64_t v30 = *a2;
        if (a2[1] == *a2)
        {
          uint64_t v32 = 0;
        }
        else
        {
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = *(int *)(*a4 + 4 * v31);
            uint64_t v34 = *(uint64_t **)(v30 + 16 * v31);
            uint64_t v35 = v61;
            if ((v34[21] & 2) == 0)
            {
              uint64_t v36 = *v34;
              unint64_t v37 = (unint64_t)(v34[1] - *v34) >> 2;
              uint64_t v35 = 0;
              uint64_t v38 = (v37 - 1);
              if ((int)v37 - 1 >= 0)
              {
                uint64_t v39 = v34[3];
                int quot = v61;
                do
                {
                  ldiv_t v41 = ldiv(quot, *(int *)(v36 + 4 * v38));
                  int quot = v41.quot;
                  v35 += *(void *)(v39 + 8 * v38--) * v41.rem;
                }
                while (v38 != -1);
              }
            }
            uint64_t v42 = *(void *)(v34[19] + 8 * v35);
            this = (mlx::core::array *)mlx::core::array::shape(v7, v33);
            v32 += (((int)this & (unint64_t)(v42 >> 63)) + v42)
                 * *(void *)(*(void *)(*(void *)v7 + 24) + 8 * v33);
            ++v31;
            uint64_t v30 = *a2;
          }
          while (v31 < (a2[1] - *a2) >> 4);
        }
        if (v58 == 1)
        {
          uint64_t v43 = v29 + 1;
          *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * v32);
        }
        else if (v54)
        {
          this = (mlx::core::array *)memmove((void *)(v56 + 4 * v29), (const void *)(v57 + 4 * v32), __len);
          uint64_t v43 = v29 + v58;
        }
        else
        {
          uint64_t v44 = 0;
          uint64_t v45 = *v53;
          uint64_t v46 = ((unint64_t)((char *)v53[1] - (char *)*v53) >> 2) - 1;
          uint64_t v47 = *(void *)v7;
          do
          {
            uint64_t v48 = 0;
            if ((v46 & 0x80000000) == 0)
            {
              uint64_t v49 = *(void *)(v47 + 24);
              uint64_t v50 = v46;
              LODWORD(this) = v44;
              do
              {
                ldiv_t v51 = ldiv((int)this, v45[v50]);
                this = (mlx::core::array *)v51.quot;
                v48 += *(void *)(v49 + 8 * v50--) * v51.rem;
              }
              while (v50 != -1);
            }
            uint64_t v43 = v29 + 1;
            *(_DWORD *)(v56 + 4 * v29) = *(_DWORD *)(v57 + 4 * (v48 + v32));
            ++v44;
            ++v29;
          }
          while (v44 != v58);
        }
        uint64_t v29 = v43;
        ++v61;
      }
      while (v61 != v55);
    }
  }
  return this;
}

void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
    case 3:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<BOOL,unsigned char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
    case 3:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
    case 3:
      mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#3}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#2}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
    case 3:
      mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#3}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#2}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
    case 3:
      mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#3}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#2}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
    case 3:
      mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#3}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#2}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  unint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    unint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    unint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7B040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  unint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    unint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned __int8 *)(v34 + v42) != -*(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    unint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7B334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    uint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v57, v19);
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v56 = v59 * v58;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v34 = *(void *)(*(void *)v57 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v56 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v56 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v54 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          if (*(unsigned char *)(v33 + v37)) {
            BOOL v47 = *(unsigned char *)(v34 + v42) == 0;
          }
          else {
            BOOL v47 = 1;
          }
          char v48 = !v47;
          *(unsigned char *)(v34 + v42) = v48;
          ++v29;
        }
        while (v29 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E7B628(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,BOOL,void mlx::core::dispatch_scatter_inds<BOOL,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,BOOL *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) |= *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7B914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7BBF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned __int8 *)(v34 + v42) != -*(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7BEEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    uint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v57, v19);
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v56 = v59 * v58;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v34 = *(void *)(*(void *)v57 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v56 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v56 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v54 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          if (*(unsigned char *)(v33 + v37)) {
            BOOL v47 = *(unsigned char *)(v34 + v42) == 0;
          }
          else {
            BOOL v47 = 1;
          }
          char v48 = !v47;
          *(unsigned char *)(v34 + v42) = v48;
          ++v29;
        }
        while (v29 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E7C1E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,unsigned int,void mlx::core::dispatch_scatter_inds<BOOL,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,unsigned int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) |= *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7C4CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        unint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(unsigned char *)(v35 + v43) = *(unsigned char *)(v34 + v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E7C7C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        unint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(unsigned char *)(v35 + v43) = *(unsigned __int8 *)(v35 + v43) != -*(unsigned char *)(v34 + v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E7CAC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v53 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v54 = v12;
  std::vector<int> __p = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v62)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v62);
  }
  if (v54)
  {
    uint64_t v59 = v14;
    uint64_t v60 = 0;
    uint64_t v56 = (v8 >> 4);
    uint64_t v58 = a2;
    unint64_t v51 = v5;
    uint64_t v52 = a4;
    do
    {
      if ((int)v53 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v60;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v60;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v58, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v58 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v56);
      }
      if (v59)
      {
        uint64_t v30 = 0;
        unint64_t v31 = (int *)__p;
        int v57 = v60 * v59;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v62 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v55 = *(void *)v58;
        uint64_t v35 = *(void *)(*(void *)v58 + 152) + v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v57 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v57 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v55 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          if (*(unsigned char *)(v34 + v38)) {
            BOOL v48 = *(unsigned char *)(v35 + v43) == 0;
          }
          else {
            BOOL v48 = 1;
          }
          char v49 = !v48;
          *(unsigned char *)(v35 + v43) = v49;
          ++v30;
        }
        while (v30 != v59);
      }
      ++v60;
      uint64_t v5 = v51;
      a4 = v52;
    }
    while (v60 != v54);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v62 = v13;
    operator delete(v13);
  }
}

void sub_256E7CDC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,signed char,void mlx::core::dispatch_scatter_inds<BOOL,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,signed char *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    char v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        unint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(unsigned char *)(v35 + v43) |= *(unsigned char *)(v34 + v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E7D0C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    BOOL v48 = v5;
    char v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7D3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    BOOL v48 = v5;
    char v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned __int8 *)(v34 + v42) != -*(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7D6AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    uint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v57, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v56 = v59 * v58;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v34 = *(void *)(*(void *)v57 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v56 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v56 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v54 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          if (*(unsigned char *)(v33 + v37)) {
            BOOL v47 = *(unsigned char *)(v34 + v42) == 0;
          }
          else {
            BOOL v47 = 1;
          }
          char v48 = !v47;
          *(unsigned char *)(v34 + v42) = v48;
          ++v29;
        }
        while (v29 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E7D9A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,int,void mlx::core::dispatch_scatter_inds<BOOL,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    char v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) |= *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7DC9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    char v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7DF8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    char v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) = *(unsigned __int8 *)(v34 + v42) != -*(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7E28C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    uint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v57, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v56 = v59 * v58;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v34 = *(void *)(*(void *)v57 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v56 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v56 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v54 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          if (*(unsigned char *)(v33 + v37)) {
            BOOL v47 = *(unsigned char *)(v34 + v42) == 0;
          }
          else {
            BOOL v47 = 1;
          }
          char v48 = !v47;
          *(unsigned char *)(v34 + v42) = v48;
          ++v29;
        }
        while (v29 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E7E58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<BOOL,long long,void mlx::core::dispatch_scatter_inds<BOOL,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(BOOL,long long *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    unint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    char v48 = v5;
    char v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          int v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        unint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(unsigned char *)(v34 + v42) |= *(unsigned char *)(v33 + v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E7E884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned char,unsigned char>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#1}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  int v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    uint64_t v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned __int8 *)(v18[19] + v19);
      uint64_t v4 = v52;
      mlx::core::array::shape(v52, v17);
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) = *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    int v54 = v11;
    operator delete(v11);
  }
}

void sub_256E7F000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#2}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  int v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    uint64_t v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned __int8 *)(v18[19] + v19);
      uint64_t v4 = v52;
      mlx::core::array::shape(v52, v17);
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) += *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    int v54 = v11;
    operator delete(v11);
  }
}

void sub_256E7F2D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#3}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  int v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    uint64_t v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned __int8 *)(v18[19] + v19);
      uint64_t v4 = v52;
      mlx::core::array::shape(v52, v17);
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) *= *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    int v54 = v11;
    operator delete(v11);
  }
}

void sub_256E7F5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    int v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned __int8 *)(v18[19] + v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E7F880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    int v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned __int8 *)(v18[19] + v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E7FB58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#1}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  int v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    int v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned int *)(v18[19] + 4 * v19);
      uint64_t v4 = v52;
      mlx::core::array::shape(v52, v17);
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) = *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    int v54 = v11;
    operator delete(v11);
  }
}

void sub_256E7FE24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#2}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  int v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    int v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned int *)(v18[19] + 4 * v19);
      uint64_t v4 = v52;
      mlx::core::array::shape(v52, v17);
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) += *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    int v54 = v11;
    operator delete(v11);
  }
}

void sub_256E800F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#3}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  int v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    int v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned int *)(v18[19] + 4 * v19);
      uint64_t v4 = v52;
      mlx::core::array::shape(v52, v17);
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) *= *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    int v54 = v11;
    operator delete(v11);
  }
}

void sub_256E803CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    int v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E806A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    int v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E8097C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#1}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v45 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v46 = v10;
  std::vector<int> __p = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v55)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v55);
  }
  if (v46)
  {
    uint64_t v52 = 0;
    uint64_t v53 = v4;
    uint64_t v47 = (v6 >> 4);
    while ((int)v45 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_21;
      }
LABEL_32:
      if (++v52 == v46)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v52;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v52;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(char *)(v18[19] + v19);
      uint64_t v4 = v53;
      uint64_t v27 = (int)mlx::core::array::shape(v53, v17);
      if ((int)v26 >= 0) {
        uint64_t v27 = 0;
      }
      v16 += *(void *)(*(void *)(*(void *)v53 + 24) + 8 * v17) * (v27 + v26);
      ++v15;
    }
    while (v15 != v47);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_21:
    uint64_t v28 = 0;
    int v51 = v52 * v12;
    do
    {
      uint64_t v29 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v32 = v51 + (int)v28;
      }
      else
      {
        uint64_t v30 = *v29;
        unint64_t v31 = (unint64_t)(v29[1] - *v29) >> 2;
        uint64_t v32 = 0;
        uint64_t v33 = (v31 - 1);
        if ((int)v31 - 1 >= 0)
        {
          uint64_t v34 = v29[3];
          int v35 = v51 + v28;
          do
          {
            ldiv_t v36 = ldiv(v35, *(int *)(v30 + 4 * v33));
            int v35 = v36.quot;
            v32 += *(void *)(v34 + 8 * v33--) * v36.rem;
          }
          while (v33 != -1);
        }
      }
      uint64_t v37 = *(void *)v4;
      unint64_t v38 = (int *)__p;
      unint64_t v39 = (unint64_t)((char *)v55 - (unsigned char *)__p) >> 2;
      uint64_t v40 = 0;
      uint64_t v41 = (v39 - 1);
      if ((int)v39 - 1 >= 0)
      {
        uint64_t v42 = *(void *)(v37 + 24);
        int v43 = v28;
        do
        {
          ldiv_t v44 = ldiv(v43, v38[v41]);
          int v43 = v44.quot;
          v40 += *(void *)(v42 + 8 * v41--) * v44.rem;
        }
        while (v41 != -1);
      }
      *(unsigned char *)(*(void *)(v37 + 152) + v16 + v40) = *(unsigned char *)(v29[19] + v32);
      ++v28;
      uint64_t v4 = v53;
    }
    while (v28 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v55 = v11;
    operator delete(v11);
  }
}

void sub_256E80C58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#2}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v45 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v46 = v10;
  std::vector<int> __p = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v55)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v55);
  }
  if (v46)
  {
    uint64_t v52 = 0;
    uint64_t v53 = v4;
    uint64_t v47 = (v6 >> 4);
    while ((int)v45 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_21;
      }
LABEL_32:
      if (++v52 == v46)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v52;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v52;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(char *)(v18[19] + v19);
      uint64_t v4 = v53;
      uint64_t v27 = (int)mlx::core::array::shape(v53, v17);
      if ((int)v26 >= 0) {
        uint64_t v27 = 0;
      }
      v16 += *(void *)(*(void *)(*(void *)v53 + 24) + 8 * v17) * (v27 + v26);
      ++v15;
    }
    while (v15 != v47);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_21:
    uint64_t v28 = 0;
    int v51 = v52 * v12;
    do
    {
      uint64_t v29 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v32 = v51 + (int)v28;
      }
      else
      {
        uint64_t v30 = *v29;
        unint64_t v31 = (unint64_t)(v29[1] - *v29) >> 2;
        uint64_t v32 = 0;
        uint64_t v33 = (v31 - 1);
        if ((int)v31 - 1 >= 0)
        {
          uint64_t v34 = v29[3];
          int v35 = v51 + v28;
          do
          {
            ldiv_t v36 = ldiv(v35, *(int *)(v30 + 4 * v33));
            int v35 = v36.quot;
            v32 += *(void *)(v34 + 8 * v33--) * v36.rem;
          }
          while (v33 != -1);
        }
      }
      uint64_t v37 = *(void *)v4;
      unint64_t v38 = (int *)__p;
      unint64_t v39 = (unint64_t)((char *)v55 - (unsigned char *)__p) >> 2;
      uint64_t v40 = 0;
      uint64_t v41 = (v39 - 1);
      if ((int)v39 - 1 >= 0)
      {
        uint64_t v42 = *(void *)(v37 + 24);
        int v43 = v28;
        do
        {
          ldiv_t v44 = ldiv(v43, v38[v41]);
          int v43 = v44.quot;
          v40 += *(void *)(v42 + 8 * v41--) * v44.rem;
        }
        while (v41 != -1);
      }
      *(unsigned char *)(*(void *)(v37 + 152) + v16 + v40) += *(unsigned char *)(v29[19] + v32);
      ++v28;
      uint64_t v4 = v53;
    }
    while (v28 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v55 = v11;
    operator delete(v11);
  }
}

void sub_256E80F3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#3}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v45 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v46 = v10;
  std::vector<int> __p = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v55)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v55);
  }
  if (v46)
  {
    uint64_t v52 = 0;
    uint64_t v53 = v4;
    uint64_t v47 = (v6 >> 4);
    while ((int)v45 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_21;
      }
LABEL_32:
      if (++v52 == v46)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v52;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v52;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(char *)(v18[19] + v19);
      uint64_t v4 = v53;
      uint64_t v27 = (int)mlx::core::array::shape(v53, v17);
      if ((int)v26 >= 0) {
        uint64_t v27 = 0;
      }
      v16 += *(void *)(*(void *)(*(void *)v53 + 24) + 8 * v17) * (v27 + v26);
      ++v15;
    }
    while (v15 != v47);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_21:
    uint64_t v28 = 0;
    int v51 = v52 * v12;
    do
    {
      uint64_t v29 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v32 = v51 + (int)v28;
      }
      else
      {
        uint64_t v30 = *v29;
        unint64_t v31 = (unint64_t)(v29[1] - *v29) >> 2;
        uint64_t v32 = 0;
        uint64_t v33 = (v31 - 1);
        if ((int)v31 - 1 >= 0)
        {
          uint64_t v34 = v29[3];
          int v35 = v51 + v28;
          do
          {
            ldiv_t v36 = ldiv(v35, *(int *)(v30 + 4 * v33));
            int v35 = v36.quot;
            v32 += *(void *)(v34 + 8 * v33--) * v36.rem;
          }
          while (v33 != -1);
        }
      }
      uint64_t v37 = *(void *)v4;
      unint64_t v38 = (int *)__p;
      unint64_t v39 = (unint64_t)((char *)v55 - (unsigned char *)__p) >> 2;
      uint64_t v40 = 0;
      uint64_t v41 = (v39 - 1);
      if ((int)v39 - 1 >= 0)
      {
        uint64_t v42 = *(void *)(v37 + 24);
        int v43 = v28;
        do
        {
          ldiv_t v44 = ldiv(v43, v38[v41]);
          int v43 = v44.quot;
          v40 += *(void *)(v42 + 8 * v41--) * v44.rem;
        }
        while (v41 != -1);
      }
      *(unsigned char *)(*(void *)(v37 + 152) + v16 + v40) *= *(unsigned char *)(v29[19] + v32);
      ++v28;
      uint64_t v4 = v53;
    }
    while (v28 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v55 = v11;
    operator delete(v11);
  }
}

void sub_256E81220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v47 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v48 = v10;
  std::vector<int> __p = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v57)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v57);
  }
  if (v48)
  {
    uint64_t v54 = 0;
    uint64_t v55 = v4;
    uint64_t v49 = (v6 >> 4);
    while ((int)v47 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_21;
      }
LABEL_34:
      if (++v54 == v48)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_36;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v54;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v54;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(char *)(v18[19] + v19);
      uint64_t v4 = v55;
      uint64_t v27 = (int)mlx::core::array::shape(v55, v17);
      if ((int)v26 >= 0) {
        uint64_t v27 = 0;
      }
      v16 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v17) * (v27 + v26);
      ++v15;
    }
    while (v15 != v49);
    if (!v12) {
      goto LABEL_34;
    }
LABEL_21:
    uint64_t v28 = 0;
    int v53 = v54 * v12;
    do
    {
      uint64_t v29 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v32 = v53 + (int)v28;
      }
      else
      {
        uint64_t v30 = *v29;
        unint64_t v31 = (unint64_t)(v29[1] - *v29) >> 2;
        uint64_t v32 = 0;
        uint64_t v33 = (v31 - 1);
        if ((int)v31 - 1 >= 0)
        {
          uint64_t v34 = v29[3];
          int v35 = v53 + v28;
          do
          {
            ldiv_t v36 = ldiv(v35, *(int *)(v30 + 4 * v33));
            int v35 = v36.quot;
            v32 += *(void *)(v34 + 8 * v33--) * v36.rem;
          }
          while (v33 != -1);
        }
      }
      uint64_t v37 = *(void *)v4;
      unint64_t v38 = (int *)__p;
      unint64_t v39 = (unint64_t)((char *)v57 - (unsigned char *)__p) >> 2;
      uint64_t v40 = 0;
      uint64_t v41 = (v39 - 1);
      if ((int)v39 - 1 >= 0)
      {
        uint64_t v42 = *(void *)(v37 + 24);
        int v43 = v28;
        do
        {
          ldiv_t v44 = ldiv(v43, v38[v41]);
          int v43 = v44.quot;
          v40 += *(void *)(v42 + 8 * v41--) * v44.rem;
        }
        while (v41 != -1);
      }
      unsigned int v45 = *(unsigned __int8 *)(v29[19] + v32);
      uint64_t v46 = *(void *)(v37 + 152) + v16;
      if (*(unsigned __int8 *)(v46 + v40) > v45) {
        LOBYTE(v45) = *(unsigned char *)(v46 + v40);
      }
      *(unsigned char *)(v46 + v40) = v45;
      ++v28;
      uint64_t v4 = v55;
    }
    while (v28 != v12);
    goto LABEL_34;
  }
LABEL_36:
  if (v11)
  {
    uint64_t v57 = v11;
    operator delete(v11);
  }
}

void sub_256E81508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v47 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v48 = v10;
  std::vector<int> __p = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v57)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v57);
  }
  if (v48)
  {
    uint64_t v54 = 0;
    uint64_t v55 = v4;
    uint64_t v49 = (v6 >> 4);
    while ((int)v47 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_21;
      }
LABEL_34:
      if (++v54 == v48)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_36;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v54;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v54;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(char *)(v18[19] + v19);
      uint64_t v4 = v55;
      uint64_t v27 = (int)mlx::core::array::shape(v55, v17);
      if ((int)v26 >= 0) {
        uint64_t v27 = 0;
      }
      v16 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v17) * (v27 + v26);
      ++v15;
    }
    while (v15 != v49);
    if (!v12) {
      goto LABEL_34;
    }
LABEL_21:
    uint64_t v28 = 0;
    int v53 = v54 * v12;
    do
    {
      uint64_t v29 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v32 = v53 + (int)v28;
      }
      else
      {
        uint64_t v30 = *v29;
        unint64_t v31 = (unint64_t)(v29[1] - *v29) >> 2;
        uint64_t v32 = 0;
        uint64_t v33 = (v31 - 1);
        if ((int)v31 - 1 >= 0)
        {
          uint64_t v34 = v29[3];
          int v35 = v53 + v28;
          do
          {
            ldiv_t v36 = ldiv(v35, *(int *)(v30 + 4 * v33));
            int v35 = v36.quot;
            v32 += *(void *)(v34 + 8 * v33--) * v36.rem;
          }
          while (v33 != -1);
        }
      }
      uint64_t v37 = *(void *)v4;
      unint64_t v38 = (int *)__p;
      unint64_t v39 = (unint64_t)((char *)v57 - (unsigned char *)__p) >> 2;
      uint64_t v40 = 0;
      uint64_t v41 = (v39 - 1);
      if ((int)v39 - 1 >= 0)
      {
        uint64_t v42 = *(void *)(v37 + 24);
        int v43 = v28;
        do
        {
          ldiv_t v44 = ldiv(v43, v38[v41]);
          int v43 = v44.quot;
          v40 += *(void *)(v42 + 8 * v41--) * v44.rem;
        }
        while (v41 != -1);
      }
      unsigned int v45 = *(unsigned __int8 *)(v29[19] + v32);
      uint64_t v46 = *(void *)(v37 + 152) + v16;
      if (*(unsigned __int8 *)(v46 + v40) < v45) {
        LOBYTE(v45) = *(unsigned char *)(v46 + v40);
      }
      *(unsigned char *)(v46 + v40) = v45;
      ++v28;
      uint64_t v4 = v55;
    }
    while (v28 != v12);
    goto LABEL_34;
  }
LABEL_36:
  if (v11)
  {
    uint64_t v57 = v11;
    operator delete(v11);
  }
}

void sub_256E817F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#1}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    uint64_t v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(int *)(v18[19] + 4 * v19);
      uint64_t v4 = v52;
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17)
           * (v26 + (int)(mlx::core::array::shape(v52, v17) & ((int)v26 >> 31)));
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) = *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    uint64_t v54 = v11;
    operator delete(v11);
  }
}

void sub_256E81AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#2}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    uint64_t v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(int *)(v18[19] + 4 * v19);
      uint64_t v4 = v52;
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17)
           * (v26 + (int)(mlx::core::array::shape(v52, v17) & ((int)v26 >> 31)));
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) += *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    uint64_t v54 = v11;
    operator delete(v11);
  }
}

void sub_256E81DA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#3}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    uint64_t v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(int *)(v18[19] + 4 * v19);
      uint64_t v4 = v52;
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17)
           * (v26 + (int)(mlx::core::array::shape(v52, v17) & ((int)v26 >> 31)));
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) *= *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    uint64_t v54 = v11;
    operator delete(v11);
  }
}

void sub_256E8207C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (v26 + (int)(mlx::core::array::shape(v54, v17) & ((int)v26 >> 31)));
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E8235C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (v26 + (int)(mlx::core::array::shape(v54, v17) & ((int)v26 >> 31)));
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E8263C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#1}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    int v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(void *)(v18[19] + 8 * v19);
      uint64_t v4 = v52;
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17)
           * (((int)mlx::core::array::shape(v52, v17) & (unint64_t)(v26 >> 63)) + v26);
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) = *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    uint64_t v54 = v11;
    operator delete(v11);
  }
}

void sub_256E82914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#2}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    int v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(void *)(v18[19] + 8 * v19);
      uint64_t v4 = v52;
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17)
           * (((int)mlx::core::array::shape(v52, v17) & (unint64_t)(v26 >> 63)) + v26);
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) += *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    uint64_t v54 = v11;
    operator delete(v11);
  }
}

void sub_256E82BF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#3}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v44 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v45 = v10;
  std::vector<int> __p = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v54)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v54);
  }
  if (v45)
  {
    uint64_t v51 = 0;
    int v52 = v4;
    uint64_t v46 = (v6 >> 4);
    while ((int)v44 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_30:
      if (++v51 == v45)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_32;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v51;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v51;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(void *)(v18[19] + 8 * v19);
      uint64_t v4 = v52;
      v16 += *(void *)(*(void *)(*(void *)v52 + 24) + 8 * v17)
           * (((int)mlx::core::array::shape(v52, v17) & (unint64_t)(v26 >> 63)) + v26);
      ++v15;
    }
    while (v15 != v46);
    if (!v12) {
      goto LABEL_30;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v50 = v51 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v50 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v50 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v54 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      *(unsigned char *)(*(void *)(v36 + 152) + v16 + v39) *= *(unsigned char *)(v28[19] + v31);
      ++v27;
      uint64_t v4 = v52;
    }
    while (v27 != v12);
    goto LABEL_30;
  }
LABEL_32:
  if (v11)
  {
    uint64_t v54 = v11;
    operator delete(v11);
  }
}

void sub_256E82ED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(void *)(v18[19] + 8 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (((int)mlx::core::array::shape(v54, v17) & (unint64_t)(v26 >> 63)) + v26);
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E831B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(void *)(v18[19] + 8 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (((int)mlx::core::array::shape(v54, v17) & (unint64_t)(v26 >> 63)) + v26);
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      unsigned int v44 = *(unsigned __int8 *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(unsigned __int8 *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E8349C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned int,unsigned char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E83C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) += *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E83F1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) *= *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E84208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E844F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E847E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E84ACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) += *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E84DB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) *= *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E850A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E85394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E85684(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(_DWORD *)(v35 + 4 * v43) = *(_DWORD *)(v34 + 4 * v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E85978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(_DWORD *)(v35 + 4 * v43) += *(_DWORD *)(v34 + 4 * v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E85C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(_DWORD *)(v35 + 4 * v43) *= *(_DWORD *)(v34 + 4 * v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E85F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          unsigned int v48 = *(_DWORD *)(v34 + 4 * v38);
          if (*(_DWORD *)(v35 + 4 * v43) > v48) {
            unsigned int v48 = *(_DWORD *)(v35 + 4 * v43);
          }
          *(_DWORD *)(v35 + 4 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E86270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          unsigned int v48 = *(_DWORD *)(v34 + 4 * v38);
          if (*(_DWORD *)(v35 + 4 * v43) < v48) {
            unsigned int v48 = *(_DWORD *)(v35 + 4 * v43);
          }
          *(_DWORD *)(v35 + 4 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E86570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    unsigned int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8685C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    unsigned int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) += *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E86B50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    unsigned int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) *= *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E86E44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8713C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E87434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    unsigned int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E87724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    unsigned int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) += *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E87A1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    unsigned int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) *= *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E87D14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E88010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          unsigned int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            unsigned int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8830C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::dispatch_scatter_inds<signed char,BOOL>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<signed char,BOOL,void mlx::core::dispatch_scatter_inds<signed char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<signed char,BOOL,void mlx::core::dispatch_scatter_inds<signed char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<signed char,unsigned char>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<signed char,BOOL,void mlx::core::dispatch_scatter_inds<signed char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<signed char,BOOL,void mlx::core::dispatch_scatter_inds<signed char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,BOOL,void mlx::core::dispatch_scatter_inds<unsigned char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<signed char,unsigned int>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<signed char,unsigned int,void mlx::core::dispatch_scatter_inds<signed char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,unsigned int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<signed char,unsigned int,void mlx::core::dispatch_scatter_inds<signed char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,unsigned int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,unsigned int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<signed char,signed char>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<signed char,signed char,void mlx::core::dispatch_scatter_inds<signed char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,signed char *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<signed char,signed char,void mlx::core::dispatch_scatter_inds<signed char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,signed char *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,signed char,void mlx::core::dispatch_scatter_inds<unsigned char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,signed char *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<signed char,int>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<signed char,int,void mlx::core::dispatch_scatter_inds<signed char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<signed char,int,void mlx::core::dispatch_scatter_inds<signed char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,int,void mlx::core::dispatch_scatter_inds<unsigned char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<signed char,long long>(mlx::core::array *a1, uint64_t *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<signed char,long long,void mlx::core::dispatch_scatter_inds<signed char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,long long *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<signed char,long long,void mlx::core::dispatch_scatter_inds<signed char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,long long *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned char,long long,void mlx::core::dispatch_scatter_inds<unsigned char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned char,long long *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::scatter<signed char,BOOL,void mlx::core::dispatch_scatter_inds<signed char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,BOOL *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned __int8 *)(v18[19] + v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E88A94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,BOOL,void mlx::core::dispatch_scatter_inds<signed char,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,BOOL *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned __int8 *)(v18[19] + v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E88D6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,unsigned int,void mlx::core::dispatch_scatter_inds<signed char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,unsigned int *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E89044(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,unsigned int,void mlx::core::dispatch_scatter_inds<signed char,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,unsigned int *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(unsigned int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      mlx::core::array::shape(v54, v17);
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17) * v26;
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E8931C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,signed char,void mlx::core::dispatch_scatter_inds<signed char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,signed char *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v47 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v48 = v10;
  std::vector<int> __p = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v57)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v57);
  }
  if (v48)
  {
    uint64_t v54 = 0;
    int v55 = v4;
    uint64_t v49 = (v6 >> 4);
    while ((int)v47 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_21;
      }
LABEL_34:
      if (++v54 == v48)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_36;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v54;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v54;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(char *)(v18[19] + v19);
      uint64_t v4 = v55;
      uint64_t v27 = (int)mlx::core::array::shape(v55, v17);
      if ((int)v26 >= 0) {
        uint64_t v27 = 0;
      }
      v16 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v17) * (v27 + v26);
      ++v15;
    }
    while (v15 != v49);
    if (!v12) {
      goto LABEL_34;
    }
LABEL_21:
    uint64_t v28 = 0;
    int v53 = v54 * v12;
    do
    {
      uint64_t v29 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v32 = v53 + (int)v28;
      }
      else
      {
        uint64_t v30 = *v29;
        unint64_t v31 = (unint64_t)(v29[1] - *v29) >> 2;
        uint64_t v32 = 0;
        uint64_t v33 = (v31 - 1);
        if ((int)v31 - 1 >= 0)
        {
          uint64_t v34 = v29[3];
          int v35 = v53 + v28;
          do
          {
            ldiv_t v36 = ldiv(v35, *(int *)(v30 + 4 * v33));
            int v35 = v36.quot;
            v32 += *(void *)(v34 + 8 * v33--) * v36.rem;
          }
          while (v33 != -1);
        }
      }
      uint64_t v37 = *(void *)v4;
      unint64_t v38 = (int *)__p;
      unint64_t v39 = (unint64_t)((char *)v57 - (unsigned char *)__p) >> 2;
      uint64_t v40 = 0;
      uint64_t v41 = (v39 - 1);
      if ((int)v39 - 1 >= 0)
      {
        uint64_t v42 = *(void *)(v37 + 24);
        int v43 = v28;
        do
        {
          ldiv_t v44 = ldiv(v43, v38[v41]);
          int v43 = v44.quot;
          v40 += *(void *)(v42 + 8 * v41--) * v44.rem;
        }
        while (v41 != -1);
      }
      int v45 = *(char *)(v29[19] + v32);
      uint64_t v46 = *(void *)(v37 + 152) + v16;
      if (*(char *)(v46 + v40) > v45) {
        LOBYTE(v45) = *(unsigned char *)(v46 + v40);
      }
      *(unsigned char *)(v46 + v40) = v45;
      ++v28;
      uint64_t v4 = v55;
    }
    while (v28 != v12);
    goto LABEL_34;
  }
LABEL_36:
  if (v11)
  {
    uint64_t v57 = v11;
    operator delete(v11);
  }
}

void sub_256E89604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,signed char,void mlx::core::dispatch_scatter_inds<signed char,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,signed char *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v47 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v48 = v10;
  std::vector<int> __p = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v57)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v57);
  }
  if (v48)
  {
    uint64_t v54 = 0;
    int v55 = v4;
    uint64_t v49 = (v6 >> 4);
    while ((int)v47 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_21;
      }
LABEL_34:
      if (++v54 == v48)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_36;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v54;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v54;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(char *)(v18[19] + v19);
      uint64_t v4 = v55;
      uint64_t v27 = (int)mlx::core::array::shape(v55, v17);
      if ((int)v26 >= 0) {
        uint64_t v27 = 0;
      }
      v16 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v17) * (v27 + v26);
      ++v15;
    }
    while (v15 != v49);
    if (!v12) {
      goto LABEL_34;
    }
LABEL_21:
    uint64_t v28 = 0;
    int v53 = v54 * v12;
    do
    {
      uint64_t v29 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v32 = v53 + (int)v28;
      }
      else
      {
        uint64_t v30 = *v29;
        unint64_t v31 = (unint64_t)(v29[1] - *v29) >> 2;
        uint64_t v32 = 0;
        uint64_t v33 = (v31 - 1);
        if ((int)v31 - 1 >= 0)
        {
          uint64_t v34 = v29[3];
          int v35 = v53 + v28;
          do
          {
            ldiv_t v36 = ldiv(v35, *(int *)(v30 + 4 * v33));
            int v35 = v36.quot;
            v32 += *(void *)(v34 + 8 * v33--) * v36.rem;
          }
          while (v33 != -1);
        }
      }
      uint64_t v37 = *(void *)v4;
      unint64_t v38 = (int *)__p;
      unint64_t v39 = (unint64_t)((char *)v57 - (unsigned char *)__p) >> 2;
      uint64_t v40 = 0;
      uint64_t v41 = (v39 - 1);
      if ((int)v39 - 1 >= 0)
      {
        uint64_t v42 = *(void *)(v37 + 24);
        int v43 = v28;
        do
        {
          ldiv_t v44 = ldiv(v43, v38[v41]);
          int v43 = v44.quot;
          v40 += *(void *)(v42 + 8 * v41--) * v44.rem;
        }
        while (v41 != -1);
      }
      int v45 = *(char *)(v29[19] + v32);
      uint64_t v46 = *(void *)(v37 + 152) + v16;
      if (*(char *)(v46 + v40) < v45) {
        LOBYTE(v45) = *(unsigned char *)(v46 + v40);
      }
      *(unsigned char *)(v46 + v40) = v45;
      ++v28;
      uint64_t v4 = v55;
    }
    while (v28 != v12);
    goto LABEL_34;
  }
LABEL_36:
  if (v11)
  {
    uint64_t v57 = v11;
    operator delete(v11);
  }
}

void sub_256E898EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,int,void mlx::core::dispatch_scatter_inds<signed char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,int *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (v26 + (int)(mlx::core::array::shape(v54, v17) & ((int)v26 >> 31)));
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E89BCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,int,void mlx::core::dispatch_scatter_inds<signed char,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,int *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(int *)(v18[19] + 4 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (v26 + (int)(mlx::core::array::shape(v54, v17) & ((int)v26 >> 31)));
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E89EAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,long long,void mlx::core::dispatch_scatter_inds<signed char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,long long *)#4}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(void *)(v18[19] + 8 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (((int)mlx::core::array::shape(v54, v17) & (unint64_t)(v26 >> 63)) + v26);
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) > v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E8A190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<signed char,long long,void mlx::core::dispatch_scatter_inds<signed char,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(signed char,long long *)#5}>(uint64_t **a1, mlx::core::array *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = *a3;
  unint64_t v6 = a3[1] - *a3;
  uint64_t v8 = **a1;
  uint64_t v7 = (*a1)[1];
  uint64_t v9 = ((v7 - v8) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v46 = v6 >> 4;
  if ((v6 >> 4)) {
    uint64_t v10 = *(void *)(*(void *)v5 + 48);
  }
  else {
    uint64_t v10 = 1;
  }
  uint64_t v47 = v10;
  std::vector<int> __p = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v8 + 4 * v9), v7, (v7 - (v8 + 4 * v9)) >> 2);
  uint64_t v11 = (int *)__p;
  uint64_t v12 = 1;
  if (__p != v56)
  {
    unint64_t v13 = (int *)__p;
    do
    {
      uint64_t v14 = *v13++;
      v12 *= v14;
    }
    while (v13 != v56);
  }
  if (v47)
  {
    uint64_t v53 = 0;
    uint64_t v54 = v4;
    uint64_t v48 = (v6 >> 4);
    while ((int)v46 < 1)
    {
      uint64_t v16 = 0;
      if (v12) {
        goto LABEL_19;
      }
LABEL_32:
      if (++v53 == v47)
      {
        uint64_t v11 = (int *)__p;
        goto LABEL_34;
      }
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(int *)(*a4 + 4 * v15);
      uint64_t v18 = *(uint64_t **)(*a3 + 16 * v15);
      uint64_t v19 = v53;
      if ((v18[21] & 2) == 0)
      {
        uint64_t v20 = *v18;
        unint64_t v21 = (unint64_t)(v18[1] - *v18) >> 2;
        uint64_t v19 = 0;
        uint64_t v22 = (v21 - 1);
        if ((int)v21 - 1 >= 0)
        {
          uint64_t v23 = v18[3];
          int quot = v53;
          do
          {
            ldiv_t v25 = ldiv(quot, *(int *)(v20 + 4 * v22));
            int quot = v25.quot;
            v19 += *(void *)(v23 + 8 * v22--) * v25.rem;
          }
          while (v22 != -1);
        }
      }
      uint64_t v26 = *(void *)(v18[19] + 8 * v19);
      uint64_t v4 = v54;
      v16 += *(void *)(*(void *)(*(void *)v54 + 24) + 8 * v17)
           * (((int)mlx::core::array::shape(v54, v17) & (unint64_t)(v26 >> 63)) + v26);
      ++v15;
    }
    while (v15 != v48);
    if (!v12) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v27 = 0;
    int v52 = v53 * v12;
    do
    {
      uint64_t v28 = *a1;
      if (((*a1)[21] & 2) != 0)
      {
        uint64_t v31 = v52 + (int)v27;
      }
      else
      {
        uint64_t v29 = *v28;
        unint64_t v30 = (unint64_t)(v28[1] - *v28) >> 2;
        uint64_t v31 = 0;
        uint64_t v32 = (v30 - 1);
        if ((int)v30 - 1 >= 0)
        {
          uint64_t v33 = v28[3];
          int v34 = v52 + v27;
          do
          {
            ldiv_t v35 = ldiv(v34, *(int *)(v29 + 4 * v32));
            int v34 = v35.quot;
            v31 += *(void *)(v33 + 8 * v32--) * v35.rem;
          }
          while (v32 != -1);
        }
      }
      uint64_t v36 = *(void *)v4;
      uint64_t v37 = (int *)__p;
      unint64_t v38 = (unint64_t)((char *)v56 - (unsigned char *)__p) >> 2;
      uint64_t v39 = 0;
      uint64_t v40 = (v38 - 1);
      if ((int)v38 - 1 >= 0)
      {
        uint64_t v41 = *(void *)(v36 + 24);
        int v42 = v27;
        do
        {
          ldiv_t v43 = ldiv(v42, v37[v40]);
          int v42 = v43.quot;
          v39 += *(void *)(v41 + 8 * v40--) * v43.rem;
        }
        while (v40 != -1);
      }
      int v44 = *(char *)(v28[19] + v31);
      uint64_t v45 = *(void *)(v36 + 152) + v16;
      if (*(char *)(v45 + v39) < v44) {
        LOBYTE(v44) = *(unsigned char *)(v45 + v39);
      }
      *(unsigned char *)(v45 + v39) = v44;
      ++v27;
      uint64_t v4 = v54;
    }
    while (v27 != v12);
    goto LABEL_32;
  }
LABEL_34:
  if (v11)
  {
    uint64_t v56 = v11;
    operator delete(v11);
  }
}

void sub_256E8A474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::dispatch_scatter_inds<int,BOOL>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<int,BOOL,void mlx::core::dispatch_scatter_inds<int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<int,BOOL,void mlx::core::dispatch_scatter_inds<int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<int,unsigned char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<int,BOOL,void mlx::core::dispatch_scatter_inds<int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<int,BOOL,void mlx::core::dispatch_scatter_inds<int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,BOOL,void mlx::core::dispatch_scatter_inds<unsigned int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<int,unsigned int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<int,unsigned int,void mlx::core::dispatch_scatter_inds<int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,unsigned int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<int,unsigned int,void mlx::core::dispatch_scatter_inds<int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,unsigned int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,unsigned int,void mlx::core::dispatch_scatter_inds<unsigned int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,unsigned int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<int,signed char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<int,signed char,void mlx::core::dispatch_scatter_inds<int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,signed char *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<int,signed char,void mlx::core::dispatch_scatter_inds<int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,signed char *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,signed char,void mlx::core::dispatch_scatter_inds<unsigned int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,signed char *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<int,int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<int,int,void mlx::core::dispatch_scatter_inds<int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<int,int,void mlx::core::dispatch_scatter_inds<int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,int,void mlx::core::dispatch_scatter_inds<unsigned int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<int,long long>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<int,long long,void mlx::core::dispatch_scatter_inds<int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,long long *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<int,long long,void mlx::core::dispatch_scatter_inds<int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,long long *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<unsigned int,long long,void mlx::core::dispatch_scatter_inds<unsigned int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(unsigned int,long long *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::scatter<int,BOOL,void mlx::core::dispatch_scatter_inds<int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,BOOL *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8AC14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,BOOL,void mlx::core::dispatch_scatter_inds<int,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,BOOL *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8AF04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,unsigned int,void mlx::core::dispatch_scatter_inds<int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,unsigned int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8B1F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,unsigned int,void mlx::core::dispatch_scatter_inds<int,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,unsigned int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        unint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8B4E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,signed char,void mlx::core::dispatch_scatter_inds<int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,signed char *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          int v48 = *(_DWORD *)(v34 + 4 * v38);
          if (*(_DWORD *)(v35 + 4 * v43) > v48) {
            int v48 = *(_DWORD *)(v35 + 4 * v43);
          }
          *(_DWORD *)(v35 + 4 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E8B7E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,signed char,void mlx::core::dispatch_scatter_inds<int,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,signed char *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          int v48 = *(_DWORD *)(v34 + 4 * v38);
          if (*(_DWORD *)(v35 + 4 * v43) < v48) {
            int v48 = *(_DWORD *)(v35 + 4 * v43);
          }
          *(_DWORD *)(v35 + 4 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E8BAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,int,void mlx::core::dispatch_scatter_inds<int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    int v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8BDDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,int,void mlx::core::dispatch_scatter_inds<int,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    int v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8C0D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,long long,void mlx::core::dispatch_scatter_inds<int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,long long *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    int v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) > v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8C3D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<int,long long,void mlx::core::dispatch_scatter_inds<int,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(int,long long *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    int v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          int v47 = *(_DWORD *)(v33 + 4 * v37);
          if (*(_DWORD *)(v34 + 4 * v42) < v47) {
            int v47 = *(_DWORD *)(v34 + 4 * v42);
          }
          *(_DWORD *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8C6CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<long long,unsigned char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) = *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8CE60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) += *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8D14C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) *= *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8D438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) > v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8D728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,BOOL,void mlx::core::dispatch_scatter_inds<long long,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,BOOL *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) < v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8DA18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) = *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8DCFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) += *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8DFE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    int v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) *= *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8E2D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) > v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8E5C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,unsigned int,void mlx::core::dispatch_scatter_inds<long long,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,unsigned int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) < v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8E8B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(void *)(v35 + 8 * v43) = *(void *)(v34 + 8 * v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8EBA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(void *)(v35 + 8 * v43) += *(void *)(v34 + 8 * v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8EEA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(void *)(v35 + 8 * v43) *= *(void *)(v34 + 8 * v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E8F1A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 8 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          uint64_t v48 = *(void *)(v34 + 8 * v38);
          if (*(void *)(v35 + 8 * v43) > v48) {
            uint64_t v48 = *(void *)(v35 + 8 * v43);
          }
          *(void *)(v35 + 8 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E8F4A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,signed char,void mlx::core::dispatch_scatter_inds<long long,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,signed char *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 8 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          uint64_t v48 = *(void *)(v34 + 8 * v38);
          if (*(void *)(v35 + 8 * v43) < v48) {
            uint64_t v48 = *(void *)(v35 + 8 * v43);
          }
          *(void *)(v35 + 8 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E8F7A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) = *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8FA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) += *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E8FD80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) *= *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E90074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) > v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E9036C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,int,void mlx::core::dispatch_scatter_inds<long long,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) < v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E90664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) = *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E90954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) += *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E90C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(void *)(v34 + 8 * v42) *= *(void *)(v33 + 8 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E90F44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) > v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E91240(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<long long,long long,void mlx::core::dispatch_scatter_inds<long long,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(long long,long long *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 8 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          uint64_t v47 = *(void *)(v33 + 8 * v37);
          if (*(void *)(v34 + 8 * v42) < v47) {
            uint64_t v47 = *(void *)(v34 + 8 * v42);
          }
          *(void *)(v34 + 8 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E9153C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<float,unsigned char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array *a1, void *a2, uint64_t **a3, void *a4, int a5)
{
  switch(a5)
  {
    case 0:
      mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#4}>(a3, a1, a2, a4);
      break;
    case 1:
      mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#5}>(a3, a1, a2, a4);
      break;
    case 2:
      mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#2}>(a3, a1, a2, a4);
      break;
    case 3:
      mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#3}>(a3, a1, a2, a4);
      break;
    case 4:
      mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#1}>(a3, a1, a2, a4);
      break;
    default:
      return;
  }
}

void mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E91CD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) + *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E91FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) * *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E922A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) > v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E92598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,BOOL,void mlx::core::dispatch_scatter_inds<float,BOOL>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,BOOL *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned __int8 *)(v20[19] + v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) < v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E92888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E92B6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) + *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E92E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    uint64_t v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v55, v19);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) * *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E93144(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) > v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E93434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,unsigned int,void mlx::core::dispatch_scatter_inds<float,unsigned int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,unsigned int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(unsigned int *)(v20[19] + 4 * v21);
          mlx::core::array::shape(v56, v19);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * v28;
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) < v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E93724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(_DWORD *)(v35 + 4 * v43) = *(_DWORD *)(v34 + 4 * v38);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E93A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(float *)(v35 + 4 * v43) = *(float *)(v34 + 4 * v38) + *(float *)(v35 + 4 * v43);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E93D14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v56, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v35 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v55 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v55 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v53 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          *(float *)(v35 + 4 * v43) = *(float *)(v34 + 4 * v38) * *(float *)(v35 + 4 * v43);
          ++v30;
        }
        while (v30 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E94010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          float v48 = *(float *)(v34 + 4 * v38);
          if (*(float *)(v35 + 4 * v43) > v48) {
            float v48 = *(float *)(v35 + 4 * v43);
          }
          *(float *)(v35 + 4 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E94310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,signed char,void mlx::core::dispatch_scatter_inds<float,signed char>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,signed char *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v52 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v53 = v12;
  std::vector<int> __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v61)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v61);
  }
  if (v53)
  {
    uint64_t v58 = v14;
    uint64_t v59 = 0;
    uint64_t v55 = (v8 >> 4);
    uint64_t v57 = a2;
    unint64_t v50 = v5;
    unint64_t v51 = a4;
    do
    {
      if ((int)v52 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v59;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v59;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(char *)(v20[19] + v21);
          uint64_t v29 = (int)mlx::core::array::shape(v57, v19);
          if ((int)v28 >= 0) {
            uint64_t v29 = 0;
          }
          v18 += *(void *)(*(void *)(*(void *)v57 + 24) + 8 * v19) * (v29 + v28);
          ++v17;
        }
        while (v17 != v55);
      }
      if (v58)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (int *)__p;
        int v56 = v59 * v58;
        uint64_t v32 = *a1;
        uint64_t v33 = ((unint64_t)((char *)v61 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v34 = (*a1)[19];
        uint64_t v54 = *(void *)v57;
        uint64_t v35 = *(void *)(*(void *)v57 + 152) + 4 * v18;
        do
        {
          if ((v32[21] & 2) != 0)
          {
            uint64_t v38 = v56 + (int)v30;
          }
          else
          {
            uint64_t v36 = *v32;
            unint64_t v37 = (unint64_t)(v32[1] - *v32) >> 2;
            uint64_t v38 = 0;
            uint64_t v39 = (v37 - 1);
            if ((int)v37 - 1 >= 0)
            {
              uint64_t v40 = v32[3];
              int v41 = v56 + v30;
              do
              {
                ldiv_t v42 = ldiv(v41, *(int *)(v36 + 4 * v39));
                int v41 = v42.quot;
                v38 += *(void *)(v40 + 8 * v39--) * v42.rem;
              }
              while (v39 != -1);
            }
          }
          uint64_t v43 = 0;
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v44 = *(void *)(v54 + 24);
            uint64_t v45 = v33;
            int v46 = v30;
            do
            {
              ldiv_t v47 = ldiv(v46, v31[v45]);
              int v46 = v47.quot;
              v43 += *(void *)(v44 + 8 * v45--) * v47.rem;
            }
            while (v45 != -1);
          }
          float v48 = *(float *)(v34 + 4 * v38);
          if (*(float *)(v35 + 4 * v43) < v48) {
            float v48 = *(float *)(v35 + 4 * v43);
          }
          *(float *)(v35 + 4 * v43) = v48;
          ++v30;
        }
        while (v30 != v58);
      }
      ++v59;
      uint64_t v5 = v50;
      a4 = v51;
    }
    while (v59 != v53);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v61 = v13;
    operator delete(v13);
  }
}

void sub_256E94610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    float v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E948FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    float v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) + *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E94BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    uint64_t v55 = a2;
    float v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v55, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) * *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E94EE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) > v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E951DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,int,void mlx::core::dispatch_scatter_inds<float,int>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,int *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(int *)(v20[19] + 4 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (v28 + (int)(mlx::core::array::shape(v56, v19) & ((int)v28 >> 31)));
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) < v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E954D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#1}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    float v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(_DWORD *)(v34 + 4 * v42) = *(_DWORD *)(v33 + 4 * v37);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E957C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#2}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    float v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) + *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E95ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#3}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v50 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v51 = v12;
  std::vector<int> __p = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v59)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v59);
  }
  if (v51)
  {
    uint64_t v56 = v14;
    uint64_t v57 = 0;
    uint64_t v53 = (v8 >> 4);
    int v55 = a2;
    float v48 = v5;
    uint64_t v49 = a4;
    do
    {
      if ((int)v50 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v57;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v57;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v55 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v55, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v53);
      }
      if (v56)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v54 = v57 * v56;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v59 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v52 = *(void *)v55;
        uint64_t v34 = *(void *)(*(void *)v55 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v54 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v54 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v52 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          *(float *)(v34 + 4 * v42) = *(float *)(v33 + 4 * v37) * *(float *)(v34 + 4 * v42);
          ++v29;
        }
        while (v29 != v56);
      }
      ++v57;
      uint64_t v5 = v48;
      a4 = v49;
    }
    while (v57 != v51);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v59 = v13;
    operator delete(v13);
  }
}

void sub_256E95DB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#4}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) > v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E960B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mlx::core::scatter<float,long long,void mlx::core::dispatch_scatter_inds<float,long long>(mlx::core::array &,std::vector<mlx::core::array> const&,mlx::core::array const&,std::vector<int> const&,mlx::core::Scatter::ReduceType)::{lambda(float,long long *)#5}>(uint64_t **a1, mlx::core::array *a2, void *a3, void *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *a3;
  unint64_t v8 = a3[1] - *a3;
  uint64_t v10 = **a1;
  uint64_t v9 = (*a1)[1];
  uint64_t v11 = ((v9 - v10) >> 2) - ((uint64_t)(*(void *)(*(void *)a2 + 8) - **(void **)a2) >> 2);
  unint64_t v51 = v8 >> 4;
  if ((v8 >> 4)) {
    uint64_t v12 = *(void *)(*(void *)v7 + 48);
  }
  else {
    uint64_t v12 = 1;
  }
  uint64_t v52 = v12;
  std::vector<int> __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, (const void *)(v10 + 4 * v11), v9, (v9 - (v10 + 4 * v11)) >> 2);
  unint64_t v13 = (int *)__p;
  uint64_t v14 = 1;
  if (__p != v60)
  {
    uint64_t v15 = (int *)__p;
    do
    {
      uint64_t v16 = *v15++;
      v14 *= v16;
    }
    while (v15 != v60);
  }
  if (v52)
  {
    uint64_t v57 = v14;
    uint64_t v58 = 0;
    uint64_t v54 = (v8 >> 4);
    uint64_t v56 = a2;
    uint64_t v49 = v5;
    unint64_t v50 = a4;
    do
    {
      if ((int)v51 < 1)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(int *)(*a4 + 4 * v17);
          uint64_t v20 = *(uint64_t **)(*v5 + 16 * v17);
          uint64_t v21 = v58;
          if ((v20[21] & 2) == 0)
          {
            uint64_t v22 = *v20;
            unint64_t v23 = (unint64_t)(v20[1] - *v20) >> 2;
            uint64_t v21 = 0;
            uint64_t v24 = (v23 - 1);
            if ((int)v23 - 1 >= 0)
            {
              uint64_t v25 = v20[3];
              int quot = v58;
              do
              {
                ldiv_t v27 = ldiv(quot, *(int *)(v22 + 4 * v24));
                int quot = v27.quot;
                v21 += *(void *)(v25 + 8 * v24--) * v27.rem;
              }
              while (v24 != -1);
            }
          }
          uint64_t v28 = *(void *)(v20[19] + 8 * v21);
          v18 += *(void *)(*(void *)(*(void *)v56 + 24) + 8 * v19)
               * (((int)mlx::core::array::shape(v56, v19) & (unint64_t)(v28 >> 63)) + v28);
          ++v17;
        }
        while (v17 != v54);
      }
      if (v57)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (int *)__p;
        int v55 = v58 * v57;
        uint64_t v31 = *a1;
        uint64_t v32 = ((unint64_t)((char *)v60 - (unsigned char *)__p) >> 2) - 1;
        uint64_t v33 = (*a1)[19];
        uint64_t v53 = *(void *)v56;
        uint64_t v34 = *(void *)(*(void *)v56 + 152) + 4 * v18;
        do
        {
          if ((v31[21] & 2) != 0)
          {
            uint64_t v37 = v55 + (int)v29;
          }
          else
          {
            uint64_t v35 = *v31;
            unint64_t v36 = (unint64_t)(v31[1] - *v31) >> 2;
            uint64_t v37 = 0;
            uint64_t v38 = (v36 - 1);
            if ((int)v36 - 1 >= 0)
            {
              uint64_t v39 = v31[3];
              int v40 = v55 + v29;
              do
              {
                ldiv_t v41 = ldiv(v40, *(int *)(v35 + 4 * v38));
                int v40 = v41.quot;
                v37 += *(void *)(v39 + 8 * v38--) * v41.rem;
              }
              while (v38 != -1);
            }
          }
          uint64_t v42 = 0;
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v43 = *(void *)(v53 + 24);
            uint64_t v44 = v32;
            int v45 = v29;
            do
            {
              ldiv_t v46 = ldiv(v45, v30[v44]);
              int v45 = v46.quot;
              v42 += *(void *)(v43 + 8 * v44--) * v46.rem;
            }
            while (v44 != -1);
          }
          float v47 = *(float *)(v33 + 4 * v37);
          if (*(float *)(v34 + 4 * v42) < v47) {
            float v47 = *(float *)(v34 + 4 * v42);
          }
          *(float *)(v34 + 4 * v42) = v47;
          ++v29;
        }
        while (v29 != v57);
      }
      ++v58;
      uint64_t v5 = v49;
      a4 = v50;
    }
    while (v58 != v52);
    unint64_t v13 = (int *)__p;
  }
  if (v13)
  {
    uint64_t v60 = v13;
    operator delete(v13);
  }
}

void sub_256E963AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlx::core::metal::is_available(mlx::core::metal *this)
{
  return 0;
}

void mlx::core::metal::new_scoped_memory_pool(void *a1@<X8>)
{
  *a1 = 0;
  a1[4] = 0;
}

void mlx::core::metal::make_task()
{
  exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
  MEMORY[0x25A2B1470](exception, "[metal::make_task] Cannot make GPU task without metal backend");
  __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
}

void sub_256E96428(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void mlx::core::metal::make_synchronize_task()
{
  exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
  MEMORY[0x25A2B1470](exception, "[metal::make_synchronize_task] Cannot synchronize GPU without metal backend");
  __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
}

void sub_256E96484(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t mlx::core::metal::get_active_memory(mlx::core::metal *this)
{
  return 0;
}

uint64_t mlx::core::metal::get_peak_memory(mlx::core::metal *this)
{
  return 0;
}

uint64_t mlx::core::metal::get_cache_memory(mlx::core::metal *this)
{
  return 0;
}

uint64_t mlx::core::metal::set_memory_limit(mlx::core::metal *this)
{
  return 0;
}

uint64_t mlx::core::metal::set_cache_limit(mlx::core::metal *this)
{
  return 0;
}

void mlx::core::metal::device_info(mlx::core::metal *this)
{
  exceptiounint64_t n = __cxa_allocate_exception(0x10uLL);
  MEMORY[0x25A2B1470](exception, "[metal::device_info] Cannot get device info without metal backend");
  __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
}

void sub_256E96518(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t mlx::core::eval_impl@<X0>(mlx::core *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  long long v97 = 0u;
  memset(&v96, 0, 32);
  memset(v94, 0, sizeof(v94));
  int v95 = 1065353216;
  unint64_t v6 = (mlx::core::metal *)mlx::core::default_device(a1);
  uint64_t v92 = mlx::core::default_stream(v6);
  int v93 = v7;
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *((void *)a1 + 1);
  if (*(void *)a1 != v9)
  {
    uint64_t v10 = *(void *)a1;
    while (1)
    {
      if (!*(_DWORD *)(*(void *)v10 + 80))
      {
        uint64_t v11 = *(void *)(*(void *)v10 + 64);
        if (v11) {
          break;
        }
      }
      v10 += 16;
      if (v10 == v9) {
        goto LABEL_8;
      }
    }
    uint64_t v92 = *(void *)(v11 + 8);
    int v93 = *(_DWORD *)(v11 + 16);
  }
LABEL_8:
  memset(v90, 0, sizeof(v90));
  int v91 = 1065353216;
  memset(__p, 0, sizeof(__p));
  uint64_t v12 = operator new(0x30uLL);
  v12[1] = 0;
  void v12[2] = 0;
  *uint64_t v12 = &unk_270632738;
  uint64_t v13 = v92;
  *((_DWORD *)v12 + 10) = v93;
  v12[3] = &unk_270632788;
  v12[4] = v13;
  *(void *)&long long v88 = v12 + 3;
  *((void *)&v88 + 1) = v12;
  *(void *)&long long v86 = v8;
  *((void *)&v86 + 1) = v9;
  uint64_t v87 = *((void *)a1 + 2);
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  mlx::core::array::array(a3, (long long *)__p, 0x100000000, &v88, &v86);
  *(void *)&long long v98 = &v86;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v98);
  if (*((void *)&v88 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v88 + 1));
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(void *)&long long v98 = *a3;
  std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v90, (unint64_t *)&v98, &v98);
  mlx::core::Event::Event(&v98, &v92);
  std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__emplace_unique_impl<int &,mlx::core::Event>(v94, (unsigned int *)&v92, (uint64_t)&v98);
  if (*((void *)&v99 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v99 + 1));
  }
  long long v83 = 0u;
  long long v84 = 0u;
  int v85 = 1065353216;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v98 = 0u;
  LODWORD(v81[0]) = 0;
  std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::emplace_back<mlx::core::array&,int>(&v98, (uint64_t)a3, v81);
  for (uint64_t i = *((void *)&v100 + 1); *((void *)&v100 + 1); uint64_t i = *((void *)&v100 + 1))
  {
    unint64_t v15 = i + v100 - 1;
    uint64_t v16 = *(void *)(*((void *)&v98 + 1) + ((v15 >> 5) & 0x7FFFFFFFFFFFFF8));
    uint64_t v17 = v16 + 16 * v15;
    unint64_t v20 = *(int *)(v17 + 8);
    uint64_t v18 = (_DWORD *)(v17 + 8);
    unint64_t v19 = v20;
    uint64_t v21 = *(mlx::core::array **)(v16 + 16 * v15);
    uint64_t v22 = *(void *)v21;
    uint64_t v23 = *(void *)(*(void *)v21 + 176);
    if (v20 >= (*(void *)(*(void *)v21 + 184) - v23) >> 4)
    {
      if (*(_DWORD *)(v22 + 80) == 2
        && (is_tracer = mlx::core::array::is_tracer(v21), uint64_t v22 = *(void *)v21, !is_tracer)
        && *(void *)(v22 + 64))
      {
        mlx::core::array::detach(v21);
      }
      else if (!*(_DWORD *)(v22 + 80))
      {
        std::deque<mlx::core::array>::push_back(&v96, v21);
        uint64_t v31 = *(void *)(*(void *)v21 + 64);
        int v33 = *(_DWORD *)(v31 + 8);
        uint64_t v32 = (unsigned int *)(v31 + 8);
        LODWORD(v81[0]) = v33;
        uint64_t v34 = std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::find<unsigned int>(v94, (unsigned int *)v81);
        if (!v34)
        {
          mlx::core::Event::Event(v81, v32);
          uint64_t v34 = std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__emplace_unique_impl<int &,mlx::core::Event>(v94, v32, (uint64_t)v81);
          if (v82) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v82);
          }
        }
        uint64_t v35 = v34[3];
        uint64_t v36 = v34[7] + 1;
        v34[7] = v36;
        uint64_t v79 = v35;
        int v80 = *((_DWORD *)v34 + 8);
        uint64_t v37 = v34[5];
        uint64_t v38 = v34[6];
        if (v38)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
          uint64_t v36 = v34[7];
        }
        uint64_t v39 = *(void *)v21;
        *(void *)(v39 + 88) = v79;
        *(_DWORD *)(v39 + 96) = v80;
        int v40 = *(std::__shared_weak_count **)(v39 + 112);
        *(void *)(v39 + 104) = v37;
        *(void *)(v39 + 112) = v38;
        if (v40) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v40);
        }
        *(void *)(v39 + 120) = v36;
        uint64_t v41 = *(void *)v21;
        uint64_t v42 = *(uint64_t **)(*(void *)v21 + 200);
        uint64_t v43 = *(uint64_t **)(v41 + 208);
        while (v42 != v43)
        {
          uint64_t v77 = v34[3];
          int v78 = *((_DWORD *)v34 + 8);
          uint64_t v44 = v34[5];
          uint64_t v45 = v34[6];
          if (v45) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v46 = v34[7];
          uint64_t v47 = *v42;
          *(void *)(v47 + 88) = v77;
          *(_DWORD *)(v47 + 96) = v78;
          float v48 = *(std::__shared_weak_count **)(v47 + 112);
          *(void *)(v47 + 104) = v44;
          *(void *)(v47 + 112) = v45;
          if (v48) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v48);
          }
          *(void *)(v47 + 120) = v46;
          v42 += 2;
        }
      }
      --*((void *)&v100 + 1);
      std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::__maybe_remove_back_spare[abi:ne180100](&v98, 1);
    }
    else
    {
      _DWORD *v18 = v19 + 1;
      uint64_t v24 = (mlx::core::array *)(v23 + 16 * v19);
      unint64_t v25 = *(void *)v24;
      int v26 = *(_DWORD *)(*(void *)v24 + 80);
      if (v26 != 1)
      {
        if (v26 != 2)
        {
          if (a2)
          {
            if (mlx::core::array::is_tracer((mlx::core::array *)(v23 + 16 * v19)))
            {
              exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(exception, "[async_eval] Not allowed inside a graph transformation.");
              goto LABEL_75;
            }
            unint64_t v25 = *(void *)v24;
          }
          uint64_t v27 = *(void *)(v25 + 64);
          if (!v27)
          {
            BOOL v73 = mlx::core::array::is_tracer(v24);
            uint64_t v74 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            exceptiounint64_t n = v74;
            if (!v73)
            {
              MEMORY[0x25A2B1470](v74, "[eval] Attempting to eval an array without a primitive.\nIf you are compiling a function, make sure all the inputs and outputs are captured:\nhttps://ml-explore.github.io/mlx/build/html/usage/compile.html#pure-functions.\nIf you are not using compile, this may be a bug. Please file an issue here:\nhttps://github.com/ml-explore/mlx/issues.");
              __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
            }
            std::logic_error::logic_error(v74, "[eval] Attempting to eval an array during function transformations like compile or vmap is not allowed.");
LABEL_75:
            exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
            __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
          }
          if (*(_DWORD *)(*(void *)(*(void *)v21 + 64) + 8) != *(_DWORD *)(v27 + 8))
          {
            v81[0] = v25;
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v90, v81, v81);
            unint64_t v25 = *(void *)v24;
          }
        }
        v81[0] = v25;
        if (!std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(&v83, v81))
        {
          LODWORD(v81[0]) = 0;
          std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::emplace_back<mlx::core::array&,int>(&v98, (uint64_t)v24, v81);
          v81[0] = *(void *)v24;
          std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)&v83, v81, v81);
          uint64_t v28 = *(unint64_t **)(*(void *)v24 + 200);
          uint64_t v29 = *(unint64_t **)(*(void *)v24 + 208);
          while (v28 != v29)
          {
            v81[0] = *v28;
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)&v83, v81, v81);
            v28 += 2;
          }
        }
      }
    }
  }
  std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::~deque[abi:ne180100](&v98);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)&v83);
  if (*((void *)&v97 + 1))
  {
    if (a2) {
      int v49 = 1;
    }
    else {
      int v49 = 2;
    }
    do
    {
      uint64_t v50 = *(void *)(v96.i64[1] + (((unint64_t)v97 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v97;
      long long v76 = *(_OWORD *)v50;
      *(void *)uint64_t v50 = 0;
      *(void *)(v50 + 8) = 0;
      std::deque<mlx::core::array>::pop_front(&v96);
      unint64_t v51 = (void *)v76;
      *(_DWORD *)(v76 + 80) = v49;
      uint64_t v52 = (uint64_t *)v51[25];
      uint64_t v53 = (uint64_t *)v51[26];
      while (v52 != v53)
      {
        uint64_t v54 = *v52;
        v52 += 2;
        *(_DWORD *)(v54 + 80) = v49;
      }
      uint64_t v55 = v51[8];
      int v56 = *(_DWORD *)(v55 + 8);
      uint64_t v57 = *(void *)(v55 + 12);
      memset(v81, 0, sizeof(v81));
      *(void *)&long long v98 = v51;
      BOOL v58 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(v90, (unint64_t *)&v98) != 0;
      uint64_t v59 = (_DWORD *)(*(void *)(v76 + 64) + 12);
      *(void *)&long long v98 = 1;
      BOOL v60 = mlx::core::operator==(v59, &v98);
      if (v60)
      {
        if (mlx::core::metal::is_available((mlx::core::metal *)v60))
        {
          long long v76 = 0uLL;
          mlx::core::metal::make_task();
        }
        uint64_t v71 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](v71, "Metal GPU is not available.");
        __cxa_throw(v71, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      long long v83 = v76;
      long long v76 = 0uLL;
      LODWORD(v84) = v56;
      *(void *)((char *)&v84 + 4) = v57;
      BYTE12(v84) = v58;
      uint64_t v61 = *(void *)(*((void *)mlx::core::scheduler::scheduler((mlx::core::scheduler *)v60) + 1) + 8 * v56);
      std::mutex::lock((std::mutex *)v61);
      if (*(unsigned char *)(v61 + 160))
      {
        uint64_t v72 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x25A2B1470](v72, "Cannot enqueue work after stream is stopped.");
        __cxa_throw(v72, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v62 = *(void *)(v61 + 72);
      uint64_t v63 = *(void *)(v61 + 80);
      uint64_t v64 = 16 * (v63 - v62) - 1;
      if (v63 == v62) {
        uint64_t v64 = 0;
      }
      if (v64 == *(void *)(v61 + 104) + *(void *)(v61 + 96))
      {
        std::deque<std::function<void ()(void)>>::__add_back_capacity((void *)(v61 + 64));
        uint64_t v62 = *(void *)(v61 + 72);
        uint64_t v63 = *(void *)(v61 + 80);
      }
      if (v63 == v62)
      {
        uint64_t v66 = 0;
      }
      else
      {
        unint64_t v65 = *(void *)(v61 + 104) + *(void *)(v61 + 96);
        uint64_t v66 = *(void *)(v62 + ((v65 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v65 & 0x7F);
      }
      long long v67 = v83;
      long long v98 = v83;
      long long v83 = 0uLL;
      *(void *)((char *)&v99 + 5) = *(void *)((char *)&v84 + 5);
      *(void *)&long long v99 = v84;
      *(void *)(v66 + 24) = 0;
      unsigned int v68 = operator new(0x28uLL);
      *unsigned int v68 = &unk_270632800;
      v68[1] = v67;
      long long v98 = 0uLL;
      uint64_t v69 = v99;
      v68[2] = *((void *)&v67 + 1);
      v68[3] = v69;
      *(void *)((char *)v68 + 29) = *(void *)((char *)&v99 + 5);
      *(void *)(v66 + 24) = v68;
      mlx::core::array::~array((mlx::core::array *)&v98);
      ++*(void *)(v61 + 104);
      std::mutex::unlock((std::mutex *)v61);
      std::condition_variable::notify_one((std::condition_variable *)(v61 + 112));
      mlx::core::array::~array((mlx::core::array *)&v83);
      *(void *)&long long v98 = v81;
      std::vector<std::shared_future<void>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v98);
      mlx::core::array::~array((mlx::core::array *)&v76);
    }
    while (*((void *)&v97 + 1));
  }
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)v90);
  std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::~__hash_table((uint64_t)v94);
  return std::deque<mlx::core::array>::~deque[abi:ne180100](&v96);
}

void sub_256E96DA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,uint64_t a36,char a37)
{
  __cxa_free_exception(v38);
  std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::~deque[abi:ne180100]((void *)(v39 - 160));
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)&a23);
  mlx::core::array::~array(v37);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)&a37);
  std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::~__hash_table(v39 - 256);
  std::deque<mlx::core::array>::~deque[abi:ne180100]((void *)(v39 - 208));
  _Unwind_Resume(a1);
}

void mlx::core::async_eval(long long *a1)
{
  long long v1 = *a1;
  uint64_t v2 = *((void *)a1 + 2);
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *(void *)a1 = 0;
  mlx::core::eval_impl((mlx::core *)&v1, 1, v3);
  mlx::core::array::~array((mlx::core::array *)v3);
  uint64_t v4 = (void **)&v1;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void sub_256E96F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(void *)(v9 - 24) = &a9;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)(v9 - 24));
  _Unwind_Resume(a1);
}

void mlx::core::eval(long long *a1)
{
  long long v1 = *a1;
  uint64_t v2 = *((void *)a1 + 2);
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *(void *)a1 = 0;
  mlx::core::eval_impl((mlx::core *)&v1, 0, v3);
  mlx::core::Event::wait((mlx::core::Event *)(v3[0] + 88));
  mlx::core::array::~array((mlx::core::array *)v3);
  uint64_t v4 = (void **)&v1;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void sub_256E97020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  mlx::core::array::~array((mlx::core::array *)&a12);
  *(void *)(v12 - 24) = &a9;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)(v12 - 24));
  _Unwind_Resume(a1);
}

void mlx::core::vjp(mlx::core *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v138 = *MEMORY[0x263EF8340];
  ++mlx::core::detail::InTracing::tracing_counter;
  uint64_t v128 = 0;
  uint64_t v129 = 0;
  uint64_t v130 = 0;
  unint64_t v6 = *(void **)a2;
  int v7 = *(void **)(a2 + 8);
  if (*(void **)a2 != v7)
  {
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = *(void *)(*v6 + 64);
      if (v9)
      {
        uint64_t v10 = *(mlx::core **)(v9 + 8);
        uint64_t v11 = *(unsigned int *)(v9 + 16);
      }
      else
      {
        uint64_t v12 = (mlx::core::metal *)mlx::core::default_device(a1);
        uint64_t v10 = (mlx::core *)mlx::core::default_stream(v12);
        uint64_t v11 = v13;
        uint64_t v8 = *v6;
      }
      v127[0] = v8;
      uint64_t v14 = v6[1];
      v127[1] = v14;
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      mlx::core::copy(v127, v10, v11 | 0x100000000, v120);
      std::vector<mlx::core::array>::push_back[abi:ne180100](&v128, (uint64_t)v120);
      mlx::core::array::~array((mlx::core::array *)v120);
      mlx::core::array::~array((mlx::core::array *)v127);
      *(unsigned char *)(*((void *)v129 - 2) + 128) = 1;
      v6 += 2;
    }
    while (v6 != v7);
  }
  uint64_t v15 = *((void *)a1 + 3);
  if (!v15) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(char **__return_ptr))(*(void *)v15 + 48))(&v125);
  uint64_t v122 = 0;
  uint64_t v123 = 0;
  uint64_t v124 = 0;
  uint64_t v16 = v125;
  if (v126 != v125)
  {
    unint64_t v17 = 0;
    int v18 = 0;
    do
    {
      unint64_t v19 = (const void ***)&v16[16 * v17];
      unint64_t v20 = (*v19)[8];
      if (!v20
      {
        if (v18 >= (unint64_t)((uint64_t)(a3[1] - *a3) >> 4))
        {
          std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v120);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v120, (uint64_t)"[vjp] Number of outputs to compute gradients for (", 50);
          uint64_t v101 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v101, (uint64_t)") does not match number of cotangents (", 39);
          unint64_t v102 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v102, (uint64_t)").", 2);
          exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v120 + 8, v118);
          std::logic_error::logic_error(exception, (const std::string *)v118);
          exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
        }
        uint64_t v21 = *(void *)(*a3 + 16 * v18);
        uint64_t v22 = **v19;
        size_t v23 = (unsigned char *)(*v19)[1] - v22;
        if (v23 != *(void *)(v21 + 8) - *(void *)v21 || memcmp(v22, *(const void **)v21, v23))
        {
          std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v120);
          int64x2_t v96 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v120, (uint64_t)"[vjp] Output shape ", 19);
          long long v97 = mlx::core::operator<<(v96, *v19);
          long long v98 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v97, (uint64_t)" does not match cotangent shape ", 32);
          long long v99 = mlx::core::operator<<(v98, *(void **)(*a3 + 16 * v18));
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)".", 1);
          if (v126 - v125 == 16 && (*v19)[6] == (const void *)1) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v120, (uint64_t)" If you are using grad your function must return a scalar.", 58);
          }
          long long v100 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v120 + 8, v118);
          std::logic_error::logic_error(v100, (const std::string *)v118);
          v100->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          __cxa_throw(v100, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
        }
        uint64_t v24 = v123;
        if (v123 >= v124)
        {
          uint64_t v26 = (v123 - (unsigned char *)v122) >> 3;
          unint64_t v27 = v26 + 1;
          if ((unint64_t)(v26 + 1) >> 61) {
            std::vector<int>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v28 = v124 - (unsigned char *)v122;
          if ((v124 - (unsigned char *)v122) >> 2 > v27) {
            unint64_t v27 = v28 >> 2;
          }
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v29 = v27;
          }
          uint64_t v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)&v124, v29);
          uint64_t v32 = &v30[8 * v26];
          *(_DWORD *)uint64_t v32 = v17;
          *((_DWORD *)v32 + 1) = v18;
          uint64_t v34 = (char *)v122;
          int v33 = v123;
          uint64_t v35 = v32;
          if (v123 != v122)
          {
            do
            {
              uint64_t v36 = *((void *)v33 - 1);
              v33 -= 8;
              *((void *)v35 - 1) = v36;
              v35 -= 8;
            }
            while (v33 != v34);
            int v33 = (char *)v122;
          }
          unint64_t v25 = v32 + 8;
          uint64_t v122 = v35;
          uint64_t v123 = v32 + 8;
          uint64_t v124 = &v30[8 * v31];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v123 = v17;
          *((_DWORD *)v24 + 1) = v18;
          unint64_t v25 = v24 + 8;
        }
        uint64_t v123 = v25;
        ++v18;
      }
      ++v17;
      uint64_t v16 = v125;
    }
    while (v17 < (v126 - v125) >> 4);
  }
  memset(v120, 0, sizeof(v120));
  int v121 = 1065353216;
  memset(v118, 0, sizeof(v118));
  int v119 = 1065353216;
  uint64_t v37 = v128;
  uint64_t v38 = v129;
  while (v37 != v38)
  {
    uint64_t v39 = *(void *)v37;
    *(unsigned char *)(v39 + 128) = 0;
    *(void *)&long long v133 = v39;
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v118, (unint64_t *)&v133, &v133);
    *(void *)&long long v133 = *(void *)v37;
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v120, (unint64_t *)&v133, &v133);
    v37 += 16;
  }
  uint64_t v115 = 0;
  unint64_t v116 = 0;
  uint64_t v117 = 0;
  uint64_t v137 = 0;
  int v40 = operator new(0x28uLL);
  *int v40 = &unk_270632880;
  v40[1] = v120;
  void v40[2] = v136;
  v40[3] = v118;
  v40[4] = &v115;
  *((void *)&v134 + 1) = v40;
  std::__function::__value_func<void ()(mlx::core::array &)>::swap[abi:ne180100](&v133, v136);
  uint64_t v41 = (mlx::core *)std::__function::__value_func<void ()(mlx::core::array &)>::~__value_func[abi:ne180100](&v133);
  uint64_t v42 = v125;
  for (uint64_t i = v126; v42 != i; v42 += 16)
  {
    *(void *)&long long v133 = *(void *)v42;
    uint64_t v44 = *((void *)v42 + 1);
    *((void *)&v133 + 1) = v44;
    if (v44) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
    }
    if (!v137) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v137 + 48))(v137, &v133);
    mlx::core::array::~array((mlx::core::array *)&v133);
  }
  long long v133 = 0u;
  long long v134 = 0u;
  int v135 = 1065353216;
  uint64_t v45 = (uint64_t *)v122;
  uint64_t v46 = v123;
  if (v122 != v123)
  {
    do
    {
      uint64_t v47 = *v45;
      float v48 = &v125[*v45 << 32 >> 28];
      int v49 = *(char ***)v48;
      uint64_t v50 = *(void *)(*(void *)v48 + 64);
      if (v50)
      {
        unint64_t v51 = *(mlx::core **)(v50 + 8);
        uint64_t v52 = *(unsigned int *)(v50 + 16);
      }
      else
      {
        uint64_t v53 = (mlx::core::metal *)mlx::core::default_device(v41);
        unint64_t v51 = (mlx::core *)mlx::core::default_stream(v53);
        uint64_t v52 = v54;
        int v49 = *(char ***)v48;
      }
      uint64_t v55 = (void *)(*a3 + 16 * (v47 >> 32));
      v114[0] = *v55;
      uint64_t v56 = v55[1];
      v114[1] = v56;
      if (v56) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v56 + 8), 1uLL, memory_order_relaxed);
      }
      mlx::core::astype(v114, *(void *)(*(void *)v48 + 56), v51, v52 | 0x100000000, __p);
      uint64_t v131 = v49;
      long long v132 = *(_OWORD *)__p;
      __p[0] = 0;
      __p[1] = 0;
      std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,mlx::core::array>>((uint64_t)&v133, (unint64_t *)&v131, (uint64_t)&v131);
      mlx::core::array::~array((mlx::core::array *)&v132);
      mlx::core::array::~array((mlx::core::array *)__p);
      mlx::core::array::~array((mlx::core::array *)v114);
      ++v45;
    }
    while (v45 != (uint64_t *)v46);
  }
  uint64_t v57 = v116;
  while (v57 != v115)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v113 = 0;
    uint64_t v58 = *((void *)v57 - 2);
    uint64_t v57 = (mlx::core::array *)((char *)v57 - 16);
    uint64_t v59 = *(void *)(v58 + 176);
    if (*(void *)(v58 + 184) != v59)
    {
      unint64_t v60 = 0;
      do
      {
        uint64_t v131 = *(char ***)(v59 + 16 * v60);
        if (std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(v118, (unint64_t *)&v131))
        {
          uint64_t v61 = (char *)__p[1];
          if (__p[1] >= v113)
          {
            uint64_t v63 = (char *)__p[0];
            int64_t v64 = ((char *)__p[1] - (char *)__p[0]) >> 2;
            unint64_t v65 = v64 + 1;
            if ((unint64_t)(v64 + 1) >> 62) {
              std::vector<int>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v66 = v113 - (char *)__p[0];
            if ((v113 - (char *)__p[0]) >> 1 > v65) {
              unint64_t v65 = v66 >> 1;
            }
            if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v67 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v67 = v65;
            }
            if (v67)
            {
              unsigned int v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v113, v67);
              uint64_t v63 = (char *)__p[0];
              uint64_t v61 = (char *)__p[1];
            }
            else
            {
              unsigned int v68 = 0;
            }
            uint64_t v69 = &v68[4 * v64];
            *(_DWORD *)uint64_t v69 = v60;
            uint64_t v62 = v69 + 4;
            while (v61 != v63)
            {
              int v70 = *((_DWORD *)v61 - 1);
              v61 -= 4;
              *((_DWORD *)v69 - 1) = v70;
              v69 -= 4;
            }
            __p[0] = v69;
            __p[1] = v62;
            uint64_t v113 = &v68[4 * v67];
            if (v63) {
              operator delete(v63);
            }
          }
          else
          {
            *(_DWORD *)__p[1] = v60;
            uint64_t v62 = v61 + 4;
          }
          __p[1] = v62;
        }
        ++v60;
        uint64_t v59 = *(void *)(*(void *)v57 + 176);
      }
      while (v60 < (*(void *)(*(void *)v57 + 184) - v59) >> 4);
    }
    mlx::core::array::outputs(v57, (uint64_t)&v110);
    uint64_t v71 = v110;
    uint64_t v72 = v111;
    while (v71 != v72)
    {
      v109[0] = *v71;
      if (std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(&v133, (unint64_t *)v109))
      {
        uint64_t v73 = *(void *)(*(void *)v57 + 64);
        uint64_t v74 = *(mlx::core **)(v73 + 8);
        uint64_t v105 = *(unsigned int *)(v73 + 16);
        memset(v109, 0, sizeof(v109));
        long long v76 = (uint64_t *)v110;
        uint64_t v75 = (uint64_t *)v111;
        if (v110 != v111)
        {
          do
          {
            uint64_t v131 = (char **)*v76;
            uint64_t v77 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(&v133, (unint64_t *)&v131);
            if (v77)
            {
              std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::remove(&v133, v77, (uint64_t)&v131);
              int v78 = v131;
              uint64_t v131 = 0;
              *(void *)&long long v106 = v78;
              BYTE9(v106) = 1;
              std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,mlx::core::array>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,mlx::core::array>,void *>>>>::reset[abi:ne180100]((uint64_t *)&v131, 0);
              std::vector<mlx::core::array>::push_back[abi:ne180100](v109, v78 + 3);
              if (v78)
              {
                mlx::core::array::~array((mlx::core::array *)(v78 + 3));
                operator delete(v78);
              }
            }
            else
            {
              mlx::core::zeros_like(v76, v74, v105 | 0x100000000, &v131);
              std::vector<mlx::core::array>::push_back[abi:ne180100](v109, (uint64_t)&v131);
              mlx::core::array::~array((mlx::core::array *)&v131);
            }
            v76 += 2;
          }
          while (v76 != v75);
        }
        (*(void (**)(char ***__return_ptr))(**(void **)(*(void *)v57 + 64) + 24))(&v131);
        uint64_t v79 = (int *)__p[0];
        if (__p[1] != __p[0])
        {
          uint64_t v80 = 0;
          unint64_t v81 = 0;
          do
          {
            unint64_t v108 = 0;
            unint64_t v108 = *(void *)(*(void *)(*(void *)v57 + 176) + 16 * v79[v81]);
            uint64_t v82 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(&v133, &v108);
            long long v83 = v82;
            if (v82)
            {
              mlx::core::add(v82 + 3, &v131[v80], v74, v105 | 0x100000000, &v106);
              long long v84 = v106;
              long long v106 = 0uLL;
              int v85 = (std::__shared_weak_count *)v83[4];
              *(_OWORD *)(v83 + 3) = v84;
              if (v85) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v85);
              }
              long long v86 = (mlx::core::array *)&v106;
            }
            else
            {
              *(void *)&long long v106 = v108;
              *((void *)&v106 + 1) = v131[v80];
              uint64_t v87 = v131[v80 + 1];
              uint64_t v107 = v87;
              if (v87) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)v87 + 1, 1uLL, memory_order_relaxed);
              }
              std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,mlx::core::array>>((uint64_t)&v133, (unint64_t *)&v106, (uint64_t)&v106);
              long long v86 = (mlx::core::array *)((char *)&v106 + 8);
            }
            mlx::core::array::~array(v86);
            ++v81;
            uint64_t v79 = (int *)__p[0];
            v80 += 2;
          }
          while (v81 < ((char *)__p[1] - (char *)__p[0]) >> 2);
        }
        *(void *)&long long v106 = &v131;
        std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v106);
        uint64_t v131 = v109;
        std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v131);
        break;
      }
      v71 += 2;
    }
    uint64_t v131 = (char **)&v110;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v131);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  uint64_t v131 = 0;
  long long v132 = 0uLL;
  uint64_t v89 = (uint64_t *)v128;
  long long v88 = (uint64_t *)v129;
  if (v128 != v129)
  {
    do
    {
      __p[0] = (void *)*v89;
      uint64_t v90 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(&v133, (unint64_t *)__p);
      if (v90)
      {
        std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)&v131, v90 + 3);
      }
      else
      {
        uint64_t v91 = *(void *)(*v89 + 64);
        if (v91)
        {
          uint64_t v92 = *(mlx::core **)(v91 + 8);
          uint64_t v93 = *(unsigned int *)(v91 + 16);
        }
        else
        {
          uint64_t v94 = (mlx::core::metal *)mlx::core::default_device(0);
          uint64_t v92 = (mlx::core *)mlx::core::default_stream(v94);
          uint64_t v93 = v95;
        }
        mlx::core::zeros_like(v89, v92, v93 | 0x100000000, __p);
        std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)&v131, (uint64_t)__p);
        mlx::core::array::~array((mlx::core::array *)__p);
      }
      v89 += 2;
    }
    while (v89 != v88);
  }
  std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>>::pair[abi:ne180100]<std::vector<mlx::core::array>&,std::vector<mlx::core::array>&,0>(a4, (void **)&v125, &v131);
  __p[0] = &v131;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::~__hash_table((uint64_t)&v133);
  std::__function::__value_func<void ()(mlx::core::array &)>::~__value_func[abi:ne180100](v136);
  *(void *)&long long v133 = &v115;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v133);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)v118);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)v120);
  if (v122)
  {
    uint64_t v123 = (char *)v122;
    operator delete(v122);
  }
  *(void *)&v120[0] = &v125;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)v120);
  *(void *)&v120[0] = &v128;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)v120);
  --mlx::core::detail::InTracing::tracing_counter;
}

void sub_256E97BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, mlx::core::array *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a36 < 0)
  {
    operator delete(__p);
    if ((v74 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a40);
      if (a72)
      {
        a73 = (uint64_t)a72;
        operator delete(a72);
      }
      a40 = (uint64_t)&STACK[0x208];
      std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&a40);
      a40 = v76 - 224;
      std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&a40);
      --*(_DWORD *)(v75 + 1596);
      _Unwind_Resume(a1);
    }
  }
  else if (!v74)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v73);
  goto LABEL_6;
}

uint64_t std::vector<mlx::core::array>::push_back[abi:ne180100](char **a1, uint64_t a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  int v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = (v7 - *a1) >> 4;
    if ((unint64_t)(v9 + 1) >> 60) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5 - (void)*a1;
    uint64_t v11 = v10 >> 3;
    if (v10 >> 3 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v24 = result;
    if (v12) {
      unsigned int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<int,unsigned long>>>(result, v12);
    }
    else {
      unsigned int v13 = 0;
    }
    uint64_t v14 = &v13[16 * v9];
    uint64_t v15 = &v13[16 * v12];
    size_t v23 = v15;
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    uint64_t v8 = v14 + 16;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    v22.i64[1] = (uint64_t)(v14 + 16);
    unint64_t v17 = *a1;
    uint64_t v16 = a1[1];
    if (v16 == *a1)
    {
      int64x2_t v19 = vdupq_n_s64((unint64_t)v16);
    }
    else
    {
      do
      {
        long long v18 = *((_OWORD *)v16 - 1);
        v16 -= 16;
        *((_OWORD *)v14 - 1) = v18;
        v14 -= 16;
        *(void *)uint64_t v16 = 0;
        *((void *)v16 + 1) = 0;
      }
      while (v16 != v17);
      int64x2_t v19 = *(int64x2_t *)a1;
      uint64_t v8 = (char *)v22.i64[1];
      uint64_t v15 = v23;
    }
    *a1 = v14;
    a1[1] = v8;
    int64x2_t v22 = v19;
    unint64_t v20 = a1[2];
    a1[2] = v15;
    size_t v23 = v20;
    uint64_t v21 = v19.i64[0];
    uint64_t result = std::__split_buffer<mlx::core::array>::~__split_buffer((uint64_t)&v21);
  }
  else
  {
    *(_OWORD *)int v7 = *(_OWORD *)a2;
    uint64_t v8 = v7 + 16;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  a1[1] = v8;
  return result;
}

void *mlx::core::array::outputs@<X0>(mlx::core::array *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)this;
  uint64_t v5 = *(unsigned int *)(*(void *)this + 224);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  std::vector<mlx::core::array>::reserve((char **)a2, ((uint64_t)(*(void *)(v4 + 208) - *(void *)(v4 + 200)) >> 4) + 1);
  std::vector<mlx::core::array>::__insert_with_size[abi:ne180100]<std::__wrap_iter<mlx::core::array const*>,std::__wrap_iter<mlx::core::array const*>>((uint64_t *)a2, *(void **)(a2 + 8), *(uint64_t **)(*(void *)this + 200), (uint64_t *)(*(void *)(*(void *)this + 200) + 16 * v5), v5);
  std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)a2, this);
  unint64_t v6 = (uint64_t *)(*(void *)(*(void *)this + 200) + 16 * v5);
  return std::vector<mlx::core::array>::__insert_with_size[abi:ne180100]<std::__wrap_iter<mlx::core::array const*>,std::__wrap_iter<mlx::core::array const*>>((uint64_t *)a2, *(void **)(a2 + 8), v6, *(uint64_t **)(*(void *)this + 208), (uint64_t)(*(void *)(*(void *)this + 208) - (void)v6) >> 4);
}

void sub_256E97FEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<mlx::core::array>::push_back[abi:ne180100](char **a1, void *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  int v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = (v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - (void)*a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    uint64_t v26 = result;
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<int,unsigned long>>>(result, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[16 * v10];
    uint64_t v16 = &v14[16 * v13];
    unint64_t v25 = v16;
    *(void *)uint64_t v15 = *a2;
    uint64_t v17 = a2[1];
    *((void *)v15 + 1) = v17;
    if (v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v15 + 16;
    v24.i64[1] = (uint64_t)(v15 + 16);
    int64x2_t v19 = *a1;
    long long v18 = a1[1];
    if (v18 == *a1)
    {
      int64x2_t v21 = vdupq_n_s64((unint64_t)v18);
    }
    else
    {
      do
      {
        long long v20 = *((_OWORD *)v18 - 1);
        v18 -= 16;
        *((_OWORD *)v15 - 1) = v20;
        v15 -= 16;
        *(void *)long long v18 = 0;
        *((void *)v18 + 1) = 0;
      }
      while (v18 != v19);
      int64x2_t v21 = *(int64x2_t *)a1;
      uint64_t v9 = (char *)v24.i64[1];
      uint64_t v16 = v25;
    }
    *a1 = v15;
    a1[1] = v9;
    int64x2_t v24 = v21;
    int64x2_t v22 = a1[2];
    a1[2] = v16;
    unint64_t v25 = v22;
    uint64_t v23 = v21.i64[0];
    uint64_t result = std::__split_buffer<mlx::core::array>::~__split_buffer((uint64_t)&v23);
  }
  else
  {
    *(void *)int v7 = *a2;
    uint64_t v8 = a2[1];
    *((void *)v7 + 1) = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 16;
  }
  a1[1] = v9;
  return result;
}

void *mlx::core::vjp@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, void **a3@<X2>, void *a4@<X8>)
{
  v34[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)v34, a1);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)v34);
  int v33 = 0;
  int v7 = operator new(0x28uLL);
  *int v7 = &unk_270632910;
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)(v7 + 1), (uint64_t)v31);
  int v33 = v7;
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  v30[0] = v9;
  v30[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  int64x2_t v22 = 0;
  uint64_t v23 = 0;
  int64x2_t v24 = 0;
  int64x2_t v19 = (void **)&v22;
  LOBYTE(v20) = 0;
  uint64_t v10 = operator new(0x10uLL);
  int64x2_t v22 = v10;
  int64x2_t v24 = v10 + 2;
  *uint64_t v10 = v9;
  v10[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v23 = v10 + 2;
  uint64_t v12 = *a3;
  unint64_t v11 = (atomic_ullong *)a3[1];
  v29[0] = v12;
  v29[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
  }
  int64x2_t v19 = 0;
  long long v20 = 0;
  int64x2_t v21 = 0;
  unint64_t v27 = &v19;
  char v28 = 0;
  unint64_t v13 = (void **)operator new(0x10uLL);
  int64x2_t v19 = v13;
  int64x2_t v21 = (char *)(v13 + 2);
  char *v13 = v12;
  v13[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
  }
  long long v20 = (char *)(v13 + 2);
  mlx::core::vjp((mlx::core *)v32, (uint64_t)&v22, &v19, (uint64_t)v25);
  unint64_t v27 = &v19;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
  mlx::core::array::~array((mlx::core::array *)v29);
  int64x2_t v19 = (void **)&v22;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v19);
  mlx::core::array::~array((mlx::core::array *)v30);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v32);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](v31);
  uint64_t v14 = v26;
  uint64_t v15 = *(void *)(v25[0] + 8);
  *a4 = *(void *)v25[0];
  a4[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = *v14;
  uint64_t v16 = v14[1];
  a4[2] = v17;
  a4[3] = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  v32[0] = (void **)&v26;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](v32);
  v32[0] = (void **)v25;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](v32);
  return std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](v34);
}

void sub_256E98378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void **a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28)
{
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&a22);
  mlx::core::array::~array((mlx::core::array *)&a24);
  a10 = (void **)&a13;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&a10);
  mlx::core::array::~array((mlx::core::array *)&a26);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((void *)(v28 - 120));
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](&a28);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100]((void *)(v28 - 88));
  _Unwind_Resume(a1);
}

void sub_256E983F0()
{
}

void sub_256E983F8()
{
}

void mlx::core::jvp(uint64_t a1@<X0>, const void ****a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v95 = *MEMORY[0x263EF8340];
  ++mlx::core::detail::InTracing::tracing_counter;
  unint64_t v6 = *a2;
  unint64_t v5 = a2[1];
  unint64_t v7 = ((char *)v5 - (char *)*a2) >> 4;
  uint64_t v8 = *(const void ****)a3;
  if (v7 != (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "[jvp] Number of inputs does not match number of tangents.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  if (v5 == v6)
  {
    uint64_t v87 = 0;
    long long v88 = 0;
    uint64_t v89 = 0;
  }
  else
  {
    if (v7 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = ((char *)v5 - (char *)*a2) >> 4;
    }
    uint64_t v12 = *a2;
    do
    {
      unint64_t v13 = **v12;
      size_t v14 = (unsigned char *)(*v12)[1] - v13;
      uint64_t v15 = **v8;
      if (v14 != (unsigned char *)(*v8)[1] - v15 || (uint64_t v16 = (mlx::core *)memcmp(v13, v15, v14), v16))
      {
        uint64_t v66 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v66, "[jvp] Input shape does not match shape of tangent.");
        v66->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
        __cxa_throw(v66, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
      }
      v8 += 2;
      v12 += 2;
      --v11;
    }
    while (v11);
    uint64_t v87 = 0;
    long long v88 = 0;
    uint64_t v89 = 0;
    do
    {
      uint64_t v17 = *v6;
      long long v18 = (unsigned int *)(*v6)[8];
      if (v18)
      {
        int64x2_t v19 = (mlx::core *)*((void *)v18 + 1);
        uint64_t v20 = v18[4];
      }
      else
      {
        int64x2_t v21 = (mlx::core::metal *)mlx::core::default_device(v16);
        int64x2_t v19 = (mlx::core *)mlx::core::default_stream(v21);
        uint64_t v20 = v22;
        uint64_t v17 = *v6;
      }
      v86[0] = v17;
      uint64_t v23 = v6[1];
      v86[1] = v23;
      if (v23) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v23 + 1, 1uLL, memory_order_relaxed);
      }
      mlx::core::copy(v86, v19, v20 | 0x100000000, v82);
      std::vector<mlx::core::array>::push_back[abi:ne180100](&v87, (uint64_t)v82);
      mlx::core::array::~array((mlx::core::array *)v82);
      mlx::core::array::~array((mlx::core::array *)v86);
      *(unsigned char *)(*((void *)v88 - 2) + 128) = 1;
      v6 += 2;
    }
    while (v6 != v5);
  }
  uint64_t v24 = *(void *)(a1 + 24);
  if (!v24) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(void **__return_ptr))(*(void *)v24 + 48))(&v84);
  memset(v82, 0, sizeof(v82));
  int v83 = 1065353216;
  memset(v80, 0, sizeof(v80));
  int v81 = 1065353216;
  unint64_t v25 = v87;
  uint64_t v26 = v88;
  while (v25 != v26)
  {
    uint64_t v27 = *(void *)v25;
    *(unsigned char *)(v27 + 128) = 0;
    *(void *)&long long v90 = v27;
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v80, (unint64_t *)&v90, &v90);
    *(void *)&long long v90 = *(void *)v25;
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v82, (unint64_t *)&v90, &v90);
    v25 += 16;
  }
  uint64_t v77 = 0;
  int v78 = 0;
  uint64_t v79 = 0;
  uint64_t v94 = 0;
  uint64_t v28 = operator new(0x28uLL);
  void *v28 = &unk_2706329A0;
  v28[1] = v82;
  v28[2] = v93;
  v28[3] = v80;
  v28[4] = &v77;
  *((void *)&v91 + 1) = v28;
  std::__function::__value_func<void ()(mlx::core::array &)>::swap[abi:ne180100](&v90, v93);
  std::__function::__value_func<void ()(mlx::core::array &)>::~__value_func[abi:ne180100](&v90);
  unint64_t v29 = v84;
  for (uint64_t i = v85; v29 != i; v29 += 2)
  {
    *(void *)&long long v90 = *v29;
    uint64_t v31 = v29[1];
    *((void *)&v90 + 1) = v31;
    if (v31) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
    }
    if (!v94) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v94 + 48))(v94, &v90);
    mlx::core::array::~array((mlx::core::array *)&v90);
  }
  long long v90 = 0u;
  long long v91 = 0u;
  int v92 = 1065353216;
  uint64_t v32 = v87;
  if (v88 != v87)
  {
    uint64_t v33 = 0;
    unint64_t v34 = 0;
    do
    {
      uint64_t v35 = *(void *)a3 + v33;
      std::vector<int> __p = *(void **)&v32[v33];
      uint64_t v75 = *(char **)v35;
      uint64_t v36 = *(char **)(v35 + 8);
      uint64_t v76 = v36;
      if (v36) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v36 + 1, 1uLL, memory_order_relaxed);
      }
      std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,mlx::core::array>>((uint64_t)&v90, (unint64_t *)&__p, (uint64_t)&__p);
      mlx::core::array::~array((mlx::core::array *)&v75);
      ++v34;
      uint64_t v32 = v87;
      v33 += 16;
    }
    while (v34 < (v88 - v87) >> 4);
  }
  uint64_t v37 = v77;
  for (unint64_t j = v78; v37 != j; v37 = (mlx::core::array *)((char *)v37 + 16))
  {
    std::vector<int> __p = 0;
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    memset(v73, 0, sizeof(v73));
    uint64_t v39 = *(void *)v37;
    uint64_t v40 = *(void *)(*(void *)v37 + 176);
    if (*(void *)(*(void *)v37 + 184) != v40)
    {
      unint64_t v41 = 0;
      do
      {
        uint64_t v71 = *(void ***)(v40 + 16 * v41);
        uint64_t v42 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(&v90, (unint64_t *)&v71);
        if (v42)
        {
          uint64_t v43 = v75;
          if (v75 >= v76)
          {
            uint64_t v45 = (char *)__p;
            uint64_t v46 = (v75 - (unsigned char *)__p) >> 2;
            unint64_t v47 = v46 + 1;
            if ((unint64_t)(v46 + 1) >> 62) {
              std::vector<int>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v48 = v76 - (unsigned char *)__p;
            if ((v76 - (unsigned char *)__p) >> 1 > v47) {
              unint64_t v47 = v48 >> 1;
            }
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v47;
            }
            if (v49)
            {
              uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v76, v49);
              uint64_t v45 = (char *)__p;
              uint64_t v43 = v75;
            }
            else
            {
              uint64_t v50 = 0;
            }
            unint64_t v51 = &v50[4 * v46];
            *(_DWORD *)unint64_t v51 = v41;
            uint64_t v44 = v51 + 4;
            while (v43 != v45)
            {
              int v52 = *((_DWORD *)v43 - 1);
              v43 -= 4;
              *((_DWORD *)v51 - 1) = v52;
              v51 -= 4;
            }
            std::vector<int> __p = v51;
            uint64_t v75 = v44;
            uint64_t v76 = &v50[4 * v49];
            if (v45) {
              operator delete(v45);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v75 = v41;
            uint64_t v44 = v43 + 4;
          }
          uint64_t v75 = v44;
          std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)v73, v42 + 3);
        }
        ++v41;
        uint64_t v39 = *(void *)v37;
        uint64_t v40 = *(void *)(*(void *)v37 + 176);
      }
      while (v41 < (*(void *)(*(void *)v37 + 184) - v40) >> 4);
    }
    (*(void (**)(void ***__return_ptr))(**(void **)(v39 + 64) + 16))(&v71);
    mlx::core::array::outputs(v37, (uint64_t)v70);
    uint64_t v53 = v71;
    if (v72 != v71)
    {
      uint64_t v54 = 0;
      unint64_t v55 = 0;
      do
      {
        uint64_t v56 = &v53[v54];
        unsigned int v68 = (void ***)v70[0][v54];
        v69[0] = *v56;
        uint64_t v57 = (atomic_ullong *)v56[1];
        v69[1] = v57;
        if (v57) {
          atomic_fetch_add_explicit(v57 + 1, 1uLL, memory_order_relaxed);
        }
        std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,mlx::core::array>>((uint64_t)&v90, (unint64_t *)&v68, (uint64_t)&v68);
        mlx::core::array::~array((mlx::core::array *)v69);
        ++v55;
        uint64_t v53 = v71;
        v54 += 2;
      }
      while (v55 < ((char *)v72 - (char *)v71) >> 4);
    }
    unsigned int v68 = v70;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v68);
    v70[0] = (void **)&v71;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](v70);
    uint64_t v71 = (void **)v73;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v71);
    if (__p)
    {
      uint64_t v75 = (char *)__p;
      operator delete(__p);
    }
  }
  std::vector<int> __p = 0;
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  uint64_t v59 = v84;
  for (unint64_t k = v85; v59 != k; v59 += 2)
  {
    v73[0] = (void **)*v59;
    unint64_t v60 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(&v90, (unint64_t *)v73);
    if (v60)
    {
      std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)&__p, v60 + 3);
    }
    else
    {
      uint64_t v61 = *(void *)(*v59 + 64);
      if (v61)
      {
        uint64_t v62 = *(mlx::core **)(v61 + 8);
        uint64_t v63 = *(unsigned int *)(v61 + 16);
      }
      else
      {
        int64_t v64 = (mlx::core::metal *)mlx::core::default_device(0);
        uint64_t v62 = (mlx::core *)mlx::core::default_stream(v64);
        uint64_t v63 = v65;
      }
      mlx::core::zeros_like(v59, v62, v63 | 0x100000000, v73);
      std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)&__p, (uint64_t)v73);
      mlx::core::array::~array((mlx::core::array *)v73);
    }
  }
  std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>>::pair[abi:ne180100]<std::vector<mlx::core::array>&,std::vector<mlx::core::array>&,0>(a4, &v84, (void **)&__p);
  v73[0] = &__p;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](v73);
  std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::~__hash_table((uint64_t)&v90);
  std::__function::__value_func<void ()(mlx::core::array &)>::~__value_func[abi:ne180100](v93);
  *(void *)&long long v90 = &v77;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v90);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)v80);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)v82);
  *(void *)&v82[0] = &v84;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)v82);
  *(void *)&v82[0] = &v87;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)v82);
  --mlx::core::detail::InTracing::tracing_counter;
}

void sub_256E98BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
}

void *mlx::core::jvp@<X0>(uint64_t a1@<X0>, const void ***a2@<X1>, const void ****a3@<X2>, void *a4@<X8>)
{
  v34[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)v34, a1);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)v34);
  uint64_t v33 = 0;
  unint64_t v7 = operator new(0x28uLL);
  *unint64_t v7 = &unk_270632A20;
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)(v7 + 1), (uint64_t)v31);
  uint64_t v33 = v7;
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  v30[0] = v9;
  v30[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
  }
  unsigned int v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  int64x2_t v19 = &v22;
  LOBYTE(v20) = 0;
  uint64_t v10 = (const void ***)operator new(0x10uLL);
  unsigned int v22 = v10;
  uint64_t v24 = (char *)(v10 + 2);
  *uint64_t v10 = v9;
  v10[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v23 = (char *)(v10 + 2);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  v29[0] = v12;
  v29[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
  }
  int64x2_t v19 = 0;
  uint64_t v20 = 0;
  int64x2_t v21 = 0;
  uint64_t v27 = (void ***)&v19;
  char v28 = 0;
  unint64_t v13 = (const void ****)operator new(0x10uLL);
  int64x2_t v19 = v13;
  int64x2_t v21 = (char *)(v13 + 2);
  unsigned char *v13 = v12;
  v13[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = (char *)(v13 + 2);
  mlx::core::jvp((uint64_t)v32, &v22, (uint64_t)&v19, (uint64_t)v25);
  uint64_t v27 = (void ***)&v19;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
  mlx::core::array::~array((mlx::core::array *)v29);
  int64x2_t v19 = &v22;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v19);
  mlx::core::array::~array((mlx::core::array *)v30);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v32);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](v31);
  size_t v14 = v26;
  uint64_t v15 = *(void *)(v25[0] + 8);
  *a4 = *(void *)v25[0];
  a4[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = *v14;
  uint64_t v16 = v14[1];
  a4[2] = v17;
  a4[3] = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  v32[0] = (void **)&v26;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](v32);
  v32[0] = (void **)v25;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](v32);
  return std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](v34);
}

void sub_256E98F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void **a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28)
{
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&a22);
  mlx::core::array::~array((mlx::core::array *)&a24);
  a10 = (void **)&a13;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&a10);
  mlx::core::array::~array((mlx::core::array *)&a26);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((void *)(v28 - 120));
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](&a28);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100]((void *)(v28 - 88));
  _Unwind_Resume(a1);
}

void sub_256E98FC8()
{
}

void sub_256E98FD0()
{
}

void *mlx::core::value_and_grad@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(void *)a2 == *(void *)(a2 + 8))
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[grad] Must specify at least one argument.");
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v8, a1);
  std::vector<int> __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  *(void *)(a3 + 24) = 0;
  unint64_t v5 = operator new(0x40uLL);
  *unint64_t v5 = &unk_270632AA0;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)(v5 + 1), (uint64_t)v8);
  v5[5] = 0;
  v5[6] = 0;
  v5[7] = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v5 + 5, __p, (uint64_t)v10, (v10 - (unsigned char *)__p) >> 2);
  *(void *)(a3 + 24) = v5;
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v8);
}

void sub_256E9911C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *mlx::core::value_and_grad(std::function<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)> const&,std::vector<int> const&)::$_0::~$_0(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](a1);
}

void mlx::core::detail::vmap_trace(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, std::string *a4@<X8>)
{
  ++mlx::core::detail::InTracing::tracing_counter;
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if ((uint64_t)(a3[1] - *a3) >> 2 != (v6 - *a2) >> 4)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "[vmap] The number of in axes must match the number of inputs.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  if (v6 == v5) {
    goto LABEL_29;
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  do
  {
    unint64_t v13 = *(int *)(*a3 + 4 * v11);
    if (v13 != -1)
    {
      size_t v14 = (mlx::core::array *)(v5 + v10);
      uint64_t v15 = *(void *)(*(void *)(v5 + v10) + 8) - **(void **)(v5 + v10);
      if (!v15)
      {
        uint64_t v30 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v30, "[vmap] Cannot vmap an input with zero dimensions.");
        v30->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
        __cxa_throw(v30, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
      }
      if (v13 > v15 >> 2)
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"[vmap] Axis ", 12);
        uint64_t v27 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)" invalid for input with ", 24);
        uint64_t v28 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)" dimensions.", 12);
        unint64_t v29 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v42, &v40);
        std::logic_error::logic_error(v29, &v40);
        v29->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
        __cxa_throw(v29, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
      }
      uint64_t v12 = (int)mlx::core::array::shape(v14, v13);
      uint64_t v5 = *a2;
      uint64_t v6 = a2[1];
    }
    ++v11;
    v10 += 16;
  }
  while (v11 < (v6 - v5) >> 4);
  if (v6 == v5)
  {
LABEL_29:
    unint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
  }
  else
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    do
    {
      int v18 = *(_DWORD *)(*a3 + 4 * v17);
      if (v18 != -1)
      {
        if (v12 != (int)mlx::core::array::shape((mlx::core::array *)(v5 + v16), v18))
        {
          std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"[vmap] Inconsistent axis sizes: ", 32);
          uint64_t v31 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)" and ", 5);
          uint64_t v32 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)".", 1);
          uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v42, &v40);
          std::logic_error::logic_error(v33, &v40);
          v33->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          __cxa_throw(v33, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
        }
        uint64_t v5 = *a2;
        uint64_t v6 = a2[1];
      }
      ++v17;
      v16 += 16;
    }
    while (v17 < (v6 - v5) >> 4);
    unint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    if (v6 != v5)
    {
      uint64_t v19 = 0;
      unint64_t v20 = 0;
      do
      {
        if (*(_DWORD *)(*a3 + 4 * v20) == -1)
        {
          std::vector<mlx::core::array>::push_back[abi:ne180100](&v41, (void *)(v5 + v19));
        }
        else
        {
          uint64_t v21 = *(void *)(v5 + v19);
          memset(&v40, 0, sizeof(v40));
          std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v40, *(const void **)v21, *(void *)(v21 + 8), (uint64_t)(*(void *)(v21 + 8) - *(void *)v21) >> 2);
          unsigned int v22 = (const void *)v40.__r_.__value_.__r.__words[0];
          std::string::size_type v23 = v40.__r_.__value_.__r.__words[0] + 4 * *(int *)(*a3 + 4 * v20);
          std::string::size_type v24 = v40.__r_.__value_.__l.__size_ - (v23 + 4);
          if (v40.__r_.__value_.__l.__size_ != v23 + 4)
          {
            memmove((void *)(v40.__r_.__value_.__r.__words[0] + 4 * *(int *)(*a3 + 4 * v20)), (const void *)(v23 + 4), v40.__r_.__value_.__l.__size_ - (v23 + 4));
            unsigned int v22 = (const void *)v40.__r_.__value_.__r.__words[0];
          }
          v40.__r_.__value_.__l.__size_ = v23 + v24;
          memset(__p, 0, sizeof(__p));
          std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(__p, v22, v23 + v24, (uint64_t)(v23 + v24 - (void)v22) >> 2);
          uint64_t v25 = *(void *)(*(void *)(*a2 + v19) + 56);
          long long v37 = 0uLL;
          uint64_t v36 = 0;
          long long v35 = 0uLL;
          mlx::core::array::array(v39, (long long *)__p, v25, &v37, &v35);
          uint64_t v44 = (void **)&v35;
          std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v44);
          if (*((void *)&v37 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v37 + 1));
          }
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          std::vector<mlx::core::array>::push_back[abi:ne180100](&v41, v39);
          *(unsigned char *)(*((void *)v42 - 2) + 128) = 1;
          mlx::core::array::~array((mlx::core::array *)v39);
          if (v40.__r_.__value_.__r.__words[0])
          {
            v40.__r_.__value_.__l.__size_ = v40.__r_.__value_.__r.__words[0];
            operator delete(v40.__r_.__value_.__l.__data_);
          }
        }
        ++v20;
        uint64_t v5 = *a2;
        v19 += 16;
      }
      while (v20 < (a2[1] - *a2) >> 4);
    }
  }
  uint64_t v26 = *(void *)(a1 + 24);
  if (!v26) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(std::string *__return_ptr))(*(void *)v26 + 48))(&v40);
  a4->__r_.__value_.__r.__words[0] = 0;
  a4->__r_.__value_.__l.__size_ = 0;
  a4->__r_.__value_.__r.__words[2] = 0;
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)a4, v41, v42, (v42 - v41) >> 4);
  a4[1] = v40;
  memset(&v40, 0, sizeof(v40));
  v39[0] = (void **)&v40;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](v39);
  v40.__r_.__value_.__r.__words[0] = (std::string::size_type)&v41;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v40);
  --mlx::core::detail::InTracing::tracing_counter;
}

void sub_256E99724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25)
{
  if (a24 < 0)
  {
    operator delete(__p);
    if ((v26 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a25);
      --mlx::core::detail::InTracing::tracing_counter;
      _Unwind_Resume(a1);
    }
  }
  else if (!v26)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v25);
  goto LABEL_6;
}

uint64_t mlx::core::detail::vmap_replace@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, void *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  if ((uint64_t)(a5[1] - *a5) >> 2 != (a3[1] - *a3) >> 4)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[vmap] The number of out axes must match the number of outputs.");
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  memset(v91, 0, sizeof(v91));
  int v92 = 1065353216;
  memset(v89, 0, sizeof(v89));
  int v90 = 1065353216;
  memset(v87, 0, sizeof(v87));
  int v88 = 1065353216;
  uint64_t v10 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      uint64_t v15 = v10 + v13;
      std::string::size_type v16 = *(void *)(v10 + v13);
      v77.__r_.__value_.__r.__words[0] = v16;
      std::string::size_type v17 = *(void *)(v15 + 8);
      v77.__r_.__value_.__l.__size_ = v17;
      if (v17) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v18 = *a4;
      int v19 = *(_DWORD *)(*a4 + 4 * v14);
      if (v19 != -1)
      {
        unint64_t v20 = (uint64_t *)(*a1 + v13);
        uint64_t v21 = *v20;
        uint64_t v97 = *v20;
        uint64_t v22 = v20[1];
        uint64_t v98 = v22;
        if (v22)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
          int v19 = *(_DWORD *)(v18 + 4 * v14);
          int v99 = v19;
          *(void *)&long long v93 = v16;
          *((void *)&v93 + 1) = v21;
          uint64_t v94 = v98;
          if (v98)
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v98 + 8), 1uLL, memory_order_relaxed);
            int v19 = v99;
          }
        }
        else
        {
          int v99 = v19;
          *(void *)&long long v93 = v16;
          *((void *)&v93 + 1) = v21;
          uint64_t v94 = 0;
        }
        LODWORD(__p) = v19;
        std::__hash_table<std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::pair<mlx::core::array,int>>>((uint64_t)v91, (unint64_t *)&v93, (uint64_t)&v93);
        mlx::core::array::~array((mlx::core::array *)((char *)&v93 + 8));
        mlx::core::array::~array((mlx::core::array *)&v97);
        *(void *)&long long v93 = v77.__r_.__value_.__r.__words[0];
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v89, (unint64_t *)&v93, &v93);
        std::string::size_type v16 = v77.__r_.__value_.__r.__words[0];
        *(unsigned char *)(v77.__r_.__value_.__r.__words[0] + 128) = 0;
      }
      *(void *)&long long v93 = v16;
      std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>((uint64_t)v87, (unint64_t *)&v93, &v93);
      mlx::core::array::~array((mlx::core::array *)&v77);
      ++v14;
      uint64_t v10 = *a2;
      v13 += 16;
    }
    while (v14 < (a2[1] - *a2) >> 4);
  }
  uint64_t v72 = a6;
  long long v84 = 0;
  int v85 = 0;
  uint64_t v86 = 0;
  uint64_t v100 = 0;
  std::string::size_type v23 = operator new(0x28uLL);
  void *v23 = &unk_270632BB0;
  v23[1] = v87;
  void v23[2] = &v97;
  uint64_t v23[3] = v89;
  v23[4] = &v84;
  std::vector<int> __p = v23;
  std::__function::__value_func<void ()(mlx::core::array const&)>::swap[abi:ne180100](&v93, &v97);
  std::__function::__value_func<void ()(mlx::core::array const&)>::~__value_func[abi:ne180100](&v93);
  uint64_t v25 = *a3;
  uint64_t v24 = a3[1];
  while (v25 != v24)
  {
    if (*(void *)(*(void *)v25 + 64))
    {
      if (!v100) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v100 + 48))(v100, v25);
    }
    v25 += 16;
  }
  uint64_t v71 = a5;
  int v26 = v84;
  uint64_t v73 = v85;
  if (v84 == v85) {
    goto LABEL_67;
  }
  do
  {
    memset(v83, 0, sizeof(v83));
    uint64_t v80 = 0;
    int v81 = 0;
    uint64_t v82 = 0;
    uint64_t v27 = *(void *)v26;
    unint64_t v29 = *(void **)(*(void *)v26 + 176);
    uint64_t v28 = *(void **)(*(void *)v26 + 184);
    if (v29 == v28) {
      goto LABEL_55;
    }
    do
    {
      *(void *)&long long v93 = *v29;
      uint64_t v30 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(v91, (unint64_t *)&v93);
      uint64_t v31 = v30;
      if (v30)
      {
        std::vector<mlx::core::array>::push_back[abi:ne180100](v83, v30 + 3);
        uint64_t v32 = v81;
        if (v81 < (int *)v82)
        {
          int v33 = *((_DWORD *)v31 + 10);
LABEL_26:
          *uint64_t v32 = v33;
          unint64_t v34 = v32 + 1;
          goto LABEL_49;
        }
        long long v35 = (int *)v80;
        uint64_t v36 = ((char *)v81 - (unsigned char *)v80) >> 2;
        unint64_t v37 = v36 + 1;
        if ((unint64_t)(v36 + 1) >> 62) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v38 = v82 - (unsigned char *)v80;
        if ((v82 - (unsigned char *)v80) >> 1 > v37) {
          unint64_t v37 = v38 >> 1;
        }
        if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v39 = v37;
        }
        if (v39)
        {
          std::string v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v82, v39);
          long long v35 = (int *)v80;
          uint64_t v32 = v81;
        }
        else
        {
          std::string v40 = 0;
        }
        uint64_t v44 = &v40[4 * v36];
        *(_DWORD *)uint64_t v44 = *((_DWORD *)v31 + 10);
        unint64_t v34 = (int *)(v44 + 4);
        while (v32 != v35)
        {
          int v45 = *--v32;
          *((_DWORD *)v44 - 1) = v45;
          v44 -= 4;
        }
      }
      else
      {
        std::vector<mlx::core::array>::push_back[abi:ne180100](v83, v29);
        uint64_t v32 = v81;
        if (v81 < (int *)v82)
        {
          int v33 = -1;
          goto LABEL_26;
        }
        long long v35 = (int *)v80;
        uint64_t v41 = ((char *)v81 - (unsigned char *)v80) >> 2;
        unint64_t v42 = v41 + 1;
        if ((unint64_t)(v41 + 1) >> 62) {
          std::vector<int>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v43 = v82 - (unsigned char *)v80;
        if ((v82 - (unsigned char *)v80) >> 1 > v42) {
          unint64_t v42 = v43 >> 1;
        }
        if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v39 = v42;
        }
        if (v39)
        {
          std::string v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v82, v39);
          long long v35 = (int *)v80;
          uint64_t v32 = v81;
        }
        else
        {
          std::string v40 = 0;
        }
        uint64_t v44 = &v40[4 * v41];
        *(_DWORD *)uint64_t v44 = -1;
        unint64_t v34 = (int *)(v44 + 4);
        while (v32 != v35)
        {
          int v46 = *--v32;
          *((_DWORD *)v44 - 1) = v46;
          v44 -= 4;
        }
      }
      uint64_t v80 = v44;
      int v81 = v34;
      uint64_t v82 = &v40[4 * v39];
      if (v35) {
        operator delete(v35);
      }
LABEL_49:
      int v81 = v34;
      v29 += 2;
    }
    while (v29 != v28);
    uint64_t v27 = *(void *)v26;
LABEL_55:
    (*(void (**)(long long *__return_ptr))(**(void **)(v27 + 64) + 32))(&v93);
    mlx::core::array::outputs(v26, (uint64_t)v79);
    uint64_t v47 = v93;
    if (*((void *)&v93 + 1) != (void)v93)
    {
      uint64_t v48 = 0;
      unint64_t v49 = 0;
      do
      {
        std::string::size_type v50 = *(void *)(v79[0] + v48);
        unint64_t v51 = (std::string::size_type *)(v47 + v48);
        int v52 = __p;
        std::string::size_type v53 = *v51;
        std::string::size_type v74 = *v51;
        std::string::size_type v54 = v51[1];
        std::string::size_type v75 = v54;
        if (v54)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v54 + 8), 1uLL, memory_order_relaxed);
          int v55 = v52[v49];
          int v76 = v55;
          v77.__r_.__value_.__r.__words[0] = v50;
          v77.__r_.__value_.__l.__size_ = v53;
          v77.__r_.__value_.__r.__words[2] = v75;
          if (v75)
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v75 + 8), 1uLL, memory_order_relaxed);
            int v55 = v76;
          }
        }
        else
        {
          int v55 = *((_DWORD *)__p + v49);
          int v76 = v55;
          v77.__r_.__value_.__r.__words[0] = v50;
          *(_OWORD *)&v77.__r_.__value_.__r.__words[1] = v53;
        }
        int v78 = v55;
        std::__hash_table<std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<mlx::core::array,int>>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long const,std::pair<mlx::core::array,int>>>((uint64_t)v91, (unint64_t *)&v77, (uint64_t)&v77);
        mlx::core::array::~array((mlx::core::array *)&v77.__r_.__value_.__r.__words[1]);
        mlx::core::array::~array((mlx::core::array *)&v74);
        ++v49;
        uint64_t v47 = v93;
        v48 += 16;
      }
      while (v49 < (uint64_t)(*((void *)&v93 + 1) - v93) >> 4);
    }
    v77.__r_.__value_.__r.__words[0] = (std::string::size_type)v79;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v77);
    if (__p)
    {
      int64x2_t v96 = __p;
      operator delete(__p);
    }
    v77.__r_.__value_.__r.__words[0] = (std::string::size_type)&v93;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v77);
    if (v80)
    {
      int v81 = (int *)v80;
      operator delete(v80);
    }
    *(void *)&long long v93 = v83;
    std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v93);
    int v26 = (mlx::core::array *)((char *)v26 + 16);
  }
  while (v26 != v73);
LABEL_67:
  *(void *)uint64_t v72 = 0;
  *(void *)(v72 + 8) = 0;
  *(void *)(v72 + 16) = 0;
  uint64_t v56 = *a3;
  if (a3[1] != *a3)
  {
    uint64_t v57 = 0;
    unint64_t v58 = 0;
    do
    {
      *(void *)&long long v93 = *(void *)(v56 + v57);
      uint64_t v59 = std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(v91, (unint64_t *)&v93);
      uint64_t v61 = v59;
      if (v59)
      {
        int v62 = *((_DWORD *)v59 + 10);
        unint64_t v63 = *(int *)(*v71 + 4 * v58);
        if (v62 != v63)
        {
          if (v63 >= (uint64_t)(*(void *)(v59[3] + 8) - *(void *)v59[3]) >> 2)
          {
            std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v93);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v93, (uint64_t)"[vmap] Axis ", 12);
            unint64_t v67 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v67, (uint64_t)" invalid for output with ", 25);
            unsigned int v68 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)" dimensions.", 12);
            uint64_t v69 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v93 + 8, &v77);
            std::logic_error::logic_error(v69, &v77);
            v69->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
            __cxa_throw(v69, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
          }
          mlx::core::moveaxis((uint64_t **)v59 + 3, v62, v63, v60, 0, &v93);
          long long v64 = v93;
          long long v93 = 0uLL;
          unsigned int v65 = (std::__shared_weak_count *)v61[4];
          *(_OWORD *)(v61 + 3) = v64;
          if (v65) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v65);
          }
          mlx::core::array::~array((mlx::core::array *)&v93);
        }
        std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)v72, v61 + 3);
      }
      else
      {
        std::vector<mlx::core::array>::push_back[abi:ne180100]((char **)v72, (void *)(*a3 + v57));
      }
      ++v58;
      uint64_t v56 = *a3;
      v57 += 16;
    }
    while (v58 < (a3[1] - *a3) >> 4);
  }
  std::__function::__value_func<void ()(mlx::core::array const&)>::~__value_func[abi:ne180100](&v97);
  *(void *)&long long v93 = &v84;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&v93);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)v87);
  std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)v89);
  return std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::~__hash_table((uint64_t)v91);
}

void sub_256E9A030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char *a54)
{
  if (a22 < 0)
  {
    operator delete(__p);
    if ((v54 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a54);
      a54 = a12;
      std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&a54);
      std::__function::__value_func<void ()(mlx::core::array const&)>::~__value_func[abi:ne180100]((void *)(v56 - 136));
      a54 = &a33;
      std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)&a54);
      std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)&a36);
      std::__hash_table<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::__unordered_map_hasher<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::hash<mlx::core::Device::DeviceType>,std::equal_to<mlx::core::Device::DeviceType>,true>,std::__unordered_map_equal<mlx::core::Device::DeviceType,std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>,std::equal_to<mlx::core::Device::DeviceType>,std::hash<mlx::core::Device::DeviceType>,true>,std::allocator<std::__hash_value_type<mlx::core::Device::DeviceType,mlx::core::Stream>>>::~__hash_table((uint64_t)&a42);
      std::__hash_table<std::__hash_value_type<unsigned long,mlx::core::array>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,mlx::core::array>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,mlx::core::array>>>::~__hash_table((uint64_t)&a48);
      _Unwind_Resume(a1);
    }
  }
  else if (!v54)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v55);
  goto LABEL_6;
}

uint64_t std::pair<std::vector<mlx::core::array>,std::vector<int>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v4 = (void **)a1;
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100](&v4);
  return a1;
}

void *mlx::core::vmap@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  std::string::size_type v23 = 0;
  uint64_t v24 = 0;
  std::vector<int> __p = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  if (__p == v23)
  {
    unsigned int v10 = 0;
  }
  else
  {
    uint64_t v8 = (char *)__p + 4;
    do
    {
      unsigned int v9 = *((_DWORD *)v8 - 1);
      unsigned int v10 = v9 >> 31;
      if ((v9 & 0x80000000) == 0) {
        break;
      }
      BOOL v11 = v8 == v23;
      v8 += 4;
    }
    while (!v11);
  }
  int v19 = 0;
  unint64_t v20 = 0;
  uint64_t v21 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v19, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  if (v19 == v20)
  {
    unsigned int v14 = 0;
    if (v19)
    {
LABEL_14:
      unint64_t v20 = v19;
      operator delete(v19);
    }
  }
  else
  {
    uint64_t v12 = v19 + 4;
    do
    {
      unsigned int v13 = *((_DWORD *)v12 - 1);
      unsigned int v14 = v13 >> 31;
      if ((v13 & 0x80000000) == 0) {
        break;
      }
      BOOL v11 = v12 == v20;
      v12 += 4;
    }
    while (!v11);
    if (v19) {
      goto LABEL_14;
    }
  }
  int v15 = v10 ^ v14;
  if (__p)
  {
    std::string::size_type v23 = (char *)__p;
    operator delete(__p);
  }
  if (v15)
  {
    exceptiounint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "[vmap] Input (or output) axes must be specified if output (or input) axes are.");
    __cxa_throw(exception, (struct type_info *)off_265426358, MEMORY[0x263F8C080]);
  }
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v30, a1);
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v32 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v31, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  v33[0] = 0;
  v33[1] = 0;
  uint64_t v34 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v33, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v25, (uint64_t)v30);
  long long v26 = *(_OWORD *)v31;
  uint64_t v27 = v32;
  v31[1] = 0;
  uint64_t v32 = 0;
  v31[0] = 0;
  long long v28 = *(_OWORD *)v33;
  uint64_t v29 = v34;
  v33[1] = 0;
  uint64_t v34 = 0;
  v33[0] = 0;
  *(void *)(a4 + 24) = 0;
  std::string::size_type v16 = (char *)operator new(0x58uLL);
  *(void *)std::string::size_type v16 = &unk_270632C40;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)(v16 + 8), (uint64_t)v25);
  *(_OWORD *)(v16 + 40) = v26;
  *((void *)v16 + 7) = v27;
  uint64_t v27 = 0;
  long long v26 = 0uLL;
  *((_OWORD *)v16 + 4) = v28;
  *((void *)v16 + 10) = v29;
  uint64_t v29 = 0;
  long long v28 = 0uLL;
  *(void *)(a4 + 24) = v16;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v25);
  if (v33[0])
  {
    v33[1] = v33[0];
    operator delete(v33[0]);
  }
  if (v31[0])
  {
    v31[1] = v31[0];
    operator delete(v31[0]);
  }
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v30);
}

void sub_256E9A480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31)
{
  __cxa_free_exception(v31);
  _Unwind_Resume(a1);
}

void *mlx::core::vmap(std::function<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)> const&,std::vector<int> const&,std::vector<int> const&)::$_1::~$_1(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](a1);
}

void *mlx::core::vmap@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  v23[4] = *MEMORY[0x263EF8340];
  unint64_t v18 = __PAIR64__(a3, a2);
  int v19 = a4;
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&,mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)v20, a1);
  uint64_t v22 = 0;
  unsigned int v9 = operator new(0x38uLL);
  unint64_t v10 = v18;
  void *v9 = &unk_270632CC0;
  v9[1] = v10;
  *((_DWORD *)v9 + 4) = v19;
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&,mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)(v9 + 3), (uint64_t)v20);
  uint64_t v22 = v9;
  BOOL v11 = operator new(8uLL);
  *BOOL v11 = a2 | (unint64_t)(a3 << 32);
  v16[1] = v11 + 1;
  void v16[2] = v11 + 1;
  v16[0] = v11;
  uint64_t v12 = operator new(4uLL);
  *uint64_t v12 = a4;
  v15[1] = v12 + 1;
  v15[2] = v12 + 1;
  v15[0] = v12;
  mlx::core::vmap((uint64_t)v21, (uint64_t)v16, (uint64_t)v15, (uint64_t)v23);
  operator delete(v12);
  operator delete(v11);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v21);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&,mlx::core::array const&)>::~__value_func[abi:ne180100](v20);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v17, (uint64_t)v23);
  *(void *)(a5 + 24) = 0;
  unsigned int v13 = operator new(0x28uLL);
  void *v13 = &unk_270632D40;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)(v13 + 1), (uint64_t)v17);
  *(void *)(a5 + 24) = v13;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v17);
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v23);
}

void sub_256E9A704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](va);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((void *)(v8 - 104));
  _Unwind_Resume(a1);
}

void sub_256E9A778()
{
}

void *mlx::core::vmap@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  void v20[4] = *MEMORY[0x263EF8340];
  unint64_t v16 = __PAIR64__(a3, a2);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)v17, a1);
  int v19 = 0;
  unint64_t v7 = operator new(0x30uLL);
  unint64_t v8 = v16;
  *unint64_t v7 = &unk_270632DD0;
  v7[1] = v8;
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100]((uint64_t)(v7 + 2), (uint64_t)v17);
  int v19 = v7;
  unsigned int v9 = operator new(4uLL);
  _DWORD *v9 = a2;
  v14[1] = v9 + 1;
  v14[2] = v9 + 1;
  v14[0] = v9;
  unint64_t v10 = operator new(4uLL);
  *unint64_t v10 = a3;
  v13[1] = v10 + 1;
  v13[2] = v10 + 1;
  v13[0] = v10;
  mlx::core::vmap((uint64_t)v18, (uint64_t)v14, (uint64_t)v13, (uint64_t)v20);
  operator delete(v10);
  operator delete(v9);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v18);
  std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](v17);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v15, (uint64_t)v20);
  *(void *)(a4 + 24) = 0;
  BOOL v11 = operator new(0x28uLL);
  *BOOL v11 = &unk_270632E50;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)(v11 + 1), (uint64_t)v15);
  *(void *)(a4 + 24) = v11;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v15);
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v20);
}

void sub_256E9A900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](va);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((void *)(v7 - 88));
  _Unwind_Resume(a1);
}

void sub_256E9A974()
{
}

void *mlx::core::custom_vjp@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v8[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v7, a1);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v8, a2);
  *(void *)(a3 + 24) = 0;
  uint64_t v5 = operator new(0x48uLL);
  *uint64_t v5 = &unk_270632EE0;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)(v5 + 1), (uint64_t)v7);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)(v5 + 5), (uint64_t)v8);
  *(void *)(a3 + 24) = v5;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v8);
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v7);
}

void sub_256E9AA50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v2);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *mlx::core::checkpoint@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v10[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v10, a1);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v9, a1);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v10);
  unint64_t v8 = 0;
  uint64_t v4 = operator new(0x28uLL);
  void *v4 = &unk_270632FB0;
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100]((uint64_t)(v4 + 1), (uint64_t)v6);
  unint64_t v8 = v4;
  mlx::core::custom_vjp((uint64_t)v9, (uint64_t)v7, a2);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v7);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v6);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v9);
  return std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](v10);
}

void sub_256E9AB50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100]((void *)(v2 - 56));
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::emplace_back<mlx::core::array&,int>(void *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[1];
  if (v6 == v7) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 32 * (v6 - v7) - 1;
  }
  uint64_t v9 = a1[4];
  uint64_t v10 = a1[5];
  unint64_t v11 = v10 + v9;
  if (v8 == v10 + v9)
  {
    std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::__add_back_capacity(a1);
    uint64_t v9 = a1[4];
    uint64_t v10 = a1[5];
    uint64_t v7 = a1[1];
    unint64_t v11 = v9 + v10;
  }
  uint64_t v12 = *(void *)(v7 + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v11;
  *(void *)uint64_t v12 = a2;
  *(_DWORD *)(v12 + 8) = *a3;
  uint64_t v13 = v10 + 1;
  a1[5] = v13;
  unint64_t v14 = v9 + v13;
  int v15 = (void *)(v7 + 8 * (v14 >> 8));
  if ((_BYTE)v14) {
    uint64_t v16 = *v15 + 16 * v14;
  }
  else {
    uint64_t v16 = *(v15 - 1) + 4096;
  }
  return v16 - 16;
}

void std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    int v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  std::string::size_type v53 = operator new(0x1000uLL);
  std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_front((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_256E9AF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::pair<std::reference_wrapper<mlx::core::array>,int>>::~deque[abi:ne180100](void *a1)
{
  unint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 128;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 256;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::~__split_buffer((uint64_t)a1);
}

void std::vector<std::shared_future<void>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  long long v1 = *a1;
  unint64_t v2 = (std::shared_future<void> *)**a1;
  if (v2)
  {
    unint64_t v4 = (std::shared_future<void> *)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        std::shared_future<void>::~shared_future(v4 - 1);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::deque<mlx::core::array>::~deque[abi:ne180100](void *a1)
{
  unint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  if (v3 == v2)
  {
    unint64_t v4 = a1 + 5;
    BOOL v3 = (void **)a1[1];
  }
  else
  {
    unint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 8];
    uint64_t v7 = (mlx::core::array *)((char *)*v6 + 16 * v5);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*((unsigned char *)a1 + 40) + v5);
    if (v7 != (mlx::core::array *)v8)
    {
      do
      {
        mlx::core::array::~array(v7);
        uint64_t v7 = (mlx::core::array *)(v9 + 16);
        if (v7 - (mlx::core::array *)*v6 == 4096)
        {
          uint64_t v10 = (mlx::core::array *)v6[1];
          ++v6;
          uint64_t v7 = v10;
        }
      }
      while (v7 != (mlx::core::array *)v8);
      unint64_t v2 = (void **)a1[1];
      BOOL v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 128;
  }
  else
  {
    if (v12 != 2) {
      goto LABEL_16;
    }
    uint64_t v13 = 256;
  }
  a1[4] = v13;
LABEL_16:
  while (v2 != v3)
  {
    BOOL v14 = *v2++;
    operator delete(v14);
  }
  return std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<mlx::core::array>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    mlx::core::array::~array((mlx::core::array *)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<mlx::core::array>::reserve(char **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v17 = result;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<int,unsigned long>>>(result, a2);
    uint64_t v9 = *a1;
    uint64_t v8 = a1[1];
    if (v8 == *a1)
    {
      int64x2_t v12 = vdupq_n_s64((unint64_t)v8);
      uint64_t v10 = &v6[v5];
    }
    else
    {
      uint64_t v10 = &v6[v5];
      do
      {
        long long v11 = *((_OWORD *)v8 - 1);
        v8 -= 16;
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 16;
        *(void *)uint64_t v8 = 0;
        *((void *)v8 + 1) = 0;
      }
      while (v8 != v9);
      int64x2_t v12 = *(int64x2_t *)a1;
    }
    *a1 = v10;
    a1[1] = &v6[v5];
    int64x2_t v15 = v12;
    uint64_t v13 = a1[2];
    a1[2] = &v6[16 * v7];
    uint64_t v16 = v13;
    uint64_t v14 = v12.i64[0];
    return std::__split_buffer<mlx::core::array>::~__split_buffer((uint64_t)&v14);
  }
  return result;
}

void *std::vector<mlx::core::array>::__insert_with_size[abi:ne180100]<std::__wrap_iter<mlx::core::array const*>,std::__wrap_iter<mlx::core::array const*>>(uint64_t *a1, void *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    uint64_t v13 = *a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *a1) >> 4);
    if (v14 >> 60) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = ((uint64_t)a2 - v13) >> 4;
    uint64_t v16 = v10 - v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    void v30[4] = v9;
    if (v17) {
      uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<int,unsigned long>>>(v9, v17);
    }
    else {
      uint64_t v18 = 0;
    }
    unint64_t v25 = (uint64_t *)&v18[16 * v15];
    v30[0] = v18;
    v30[1] = v25;
    v30[3] = &v18[16 * v17];
    uint64_t v26 = &v25[2 * a5];
    do
    {
      *unint64_t v25 = *a3;
      uint64_t v27 = a3[1];
      v25[1] = v27;
      if (v27) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
      }
      v25 += 2;
      a3 += 2;
    }
    while (v25 != v26);
    void v30[2] = v26;
    uint64_t v5 = (void *)std::vector<mlx::core::array>::__swap_out_circular_buffer(a1, v30, v5);
    std::__split_buffer<mlx::core::array>::~__split_buffer((uint64_t)v30);
    return v5;
  }
  uint64_t v19 = (uint64_t)(v12 - (void)a2) >> 4;
  if (v19 >= a5)
  {
    int64_t v20 = &a3[2 * a5];
LABEL_27:
    std::vector<mlx::core::array>::__move_range((uint64_t)a1, a2, v12, (uint64_t)&a2[2 * a5]);
    if (v20 != a3)
    {
      uint64_t v28 = v5;
      do
      {
        mlx::core::array::operator=(v28, a3);
        a3 += 2;
        v28 += 2;
      }
      while (a3 != v20);
    }
    return v5;
  }
  int64_t v20 = &a3[2 * v19];
  if (v20 == a4)
  {
    uint64_t v21 = *(uint64_t **)(v9 - 8);
  }
  else
  {
    uint64_t v21 = *(uint64_t **)(v9 - 8);
    unint64_t v22 = v20;
    uint64_t v23 = v21;
    do
    {
      uint64_t *v23 = *v22;
      uint64_t v24 = v22[1];
      v23[1] = v24;
      if (v24) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
      }
      v21 += 2;
      v22 += 2;
      v23 += 2;
    }
    while (v22 != a4);
  }
  a1[1] = (uint64_t)v21;
  if ((uint64_t)(v12 - (void)a2) >= 1) {
    goto LABEL_27;
  }
  return v5;
}

void sub_256E9B4A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<mlx::core::array>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<mlx::core::array>::__move_range(uint64_t a1, void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (void *)((char *)a2 + v6 - a4);
  uint64_t v8 = (_OWORD *)v6;
  if ((unint64_t)v7 < a3)
  {
    uint64_t v9 = v7;
    uint64_t v8 = *(_OWORD **)(a1 + 8);
    do
    {
      *v8++ = *(_OWORD *)v9;
      void *v9 = 0;
      v9[1] = 0;
      v9 += 2;
    }
    while ((unint64_t)v9 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<mlx::core::array *,mlx::core::array *,mlx::core::array *>((uint64_t)&v11, a2, v7, v6);
}

uint64_t std::vector<mlx::core::array>::__swap_out_circular_buffer(void *a1, void *a2, void *a3)
{
  uint64_t result = a2[1];
  uint64_t v5 = (void *)*a1;
  uint64_t v6 = result;
  if ((void *)*a1 != a3)
  {
    uint64_t v7 = a3;
    uint64_t v6 = a2[1];
    do
    {
      long long v8 = *((_OWORD *)v7 - 1);
      v7 -= 2;
      *(_OWORD *)(v6 - 16) = v8;
      v6 -= 16;
      *uint64_t v7 = 0;
      v7[1] = 0;
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v9 = (void *)a1[1];
  uint64_t v10 = (_OWORD *)a2[2];
  if (v9 != a3)
  {
    do
    {
      *v10++ = *(_OWORD *)a3;
      *a3 = 0;
      a3[1] = 0;
      a3 += 2;
    }
    while (a3 != v9);
    uint64_t v6 = a2[1];
  }
  a2[2] = v10;
  char v11 = (void *)*a1;
  *a1 = v6;
  a2[1] = v11;
  uint64_t v12 = a1[1];
  a1[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = a1[2];
  a1[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<mlx::core::array *,mlx::core::array *,mlx::core::array *>(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = a3;
    do
    {
      long long v8 = *((_OWORD *)v7 - 1);
      v7 -= 2;
      *uint64_t v7 = 0;
      v7[1] = 0;
      uint64_t v9 = *(std::__shared_weak_count **)(a4 - 8);
      *(_OWORD *)(a4 - 16) = v8;
      a4 -= 16;
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      }
    }
    while (v7 != a2);
  }
  return a3;
}

uint64_t std::pair<std::vector<mlx::core::array>,std::vector<mlx::core::array>>::pair[abi:ne180100]<std::vector<mlx::core::array>&,std::vector<mlx::core::array>&,0>(uint64_t a1, void **a2, void **a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)a1, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 4);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  std::vector<mlx::core::array>::__init_with_size[abi:ne180100]<mlx::core::array*,mlx::core::array*>((char *)(a1 + 24), *a3, a3[1], ((char *)a3[1] - (char *)*a3) >> 4);
  return a1;
}

void sub_256E9B684(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<mlx::core::array>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<mlx::core::array ()(mlx::core::array const&,mlx::core::array const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

{
  uint64_t v3;

  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<std::vector<mlx::core::array> ()(std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&,std::vector<mlx::core::array> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<mlx::core::array ()(mlx::core::array const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    unint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[6];
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::__shared_ptr_emplace<mlx::core::Synchronizer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632738;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlx::core::Synchronizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_270632738;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x25A2B1780);
}

uint64_t std::__shared_ptr_emplace<mlx::core::Synchronizer>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 64))();
}

void *mlx::core::Synchronizer::print(uint64_t a1, void *a2)
{
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"Synchronize", 11);
}

uint64_t mlx::core::Primitive::is_equivalent()
{
  return 0;
}

void mlx::core::Synchronizer::~Synchronizer(mlx::core::Synchronizer *this)
{
}

void *std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x18uLL);
  *uint64_t i = 0;
  i[1] = v6;
  i[2] = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,mlx::core::array>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mlx::core::array>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mlx::core::array>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mlx::core::array>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t i = *v19;
LABEL_38:
    *uint64_t v19 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_256E9BCA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__emplace_unique_impl<int &,mlx::core::Event>(void *a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v6 = a1 + 2;
  std::vector<int> __p = (char *)operator new(0x40uLL);
  float v12 = v6;
  uint64_t v7 = *a2;
  *((_DWORD *)__p + 4) = v7;
  *((void *)__p + 3) = *(void *)a3;
  *((_DWORD *)__p + 8) = *(_DWORD *)(a3 + 8);
  *(_OWORD *)(__p + 40) = *(_OWORD *)(a3 + 16);
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *((void *)__p + 7) = *(void *)(a3 + 32);
  char v13 = 1;
  *(void *)std::vector<int> __p = 0;
  *((void *)__p + 1) = v7;
  inserted = std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__node_insert_unique(a1, (uint64_t)__p);
  if ((v9 & 1) == 0 && __p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,mlx::core::Event>,void *>>>::operator()[abi:ne180100]((uint64_t)&v12, __p);
  }
  return inserted;
}

void sub_256E9BD7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,mlx::core::Event>,void *>>>::operator()[abi:ne180100](v10, __p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__node_insert_unique(void *a1, uint64_t a2)
{
  unint64_t v2 = (void *)a2;
  uint64_t v5 = (_DWORD *)(a2 + 16);
  unint64_t v4 = *(unsigned int *)(a2 + 16);
  *((void *)v5 - 1) = v4;
  unint64_t v6 = std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__node_insert_unique_prepare[abi:ne180100]((uint64_t)a1, v4, v5);
  if (v6) {
    return v6;
  }
  std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__node_insert_unique_perform[abi:ne180100](a1, v2);
  return v2;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__node_insert_unique_prepare[abi:ne180100](uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL) {
      uint64_t v5 = v3 <= a2 ? a2 % v3 : a2;
    }
    else {
      uint64_t v5 = (v3 - 1) & a2;
    }
    unint64_t v6 = *(uint64_t ***)(*(void *)a1 + 8 * v5);
    if (v6)
    {
      for (uint64_t i = *v6; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v8 = i[1];
        if (v8 == a2)
        {
          if (*((_DWORD *)i + 4) == *a3) {
            return i;
          }
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3) {
              v8 %= v3;
            }
          }
          else
          {
            v8 &= v3 - 1;
          }
          if (v8 != v5) {
            break;
          }
        }
      }
    }
  }
  float v9 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v10 = *(float *)(a1 + 32);
  if (!v3 || (float)(v10 * (float)v3) < v9)
  {
    uint64_t v11 = 2 * v3;
    BOOL v12 = v3 < 3 || (v3 & (v3 - 1)) != 0;
    size_t v13 = v12 | v11;
    unint64_t v14 = vcvtps_u32_f32(v9 / v10);
    if (v13 <= v14) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = v13;
    }
    std::__hash_table<std::__hash_value_type<std::string,mlx::core::array>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mlx::core::array>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mlx::core::array>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mlx::core::array>>>::__rehash<true>(a1, v15);
  }
  return 0;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,mlx::core::Event>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,mlx::core::Event>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,mlx::core::Event>>>::__node_insert_unique_perform[abi:ne180100](void *result, void *a2)
{
  int8x8_t v2 = (int8x8_t)result[1];
  unint64_t v3 = a2[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  uint64_t v5 = *(void **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *uint64_t v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(void *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v2) {
        v6 %= *(void *)&v2;
      }
    }
    else
    {
      v6 &= *(void *)&v2 - 1;
    }
    uint64_t v5 = (void *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,mlx::core::Event>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v3 = (std::__shared_weak_count *)__p[6];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void *std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::find<unsigned long>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  unint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void std::deque<mlx::core::array>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 32 * (v4 - v5) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<mlx::core::array>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = v7 + a1[4];
  }
  uint64_t v9 = *(void *)(v5 + ((v8 >> 5) & 0x7FFFFFFFFFFFFF8));
  uint64_t v10 = a2[1];
  uint64_t v11 = (void *)(v9 + 16 * v8);
  *uint64_t v11 = *a2;
  v11[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = a1[5];
  }
  a1[5] = v7 + 1;
}

void std::deque<mlx::core::array>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *>>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  std::string::size_type v53 = operator new(0x1000uLL);
  std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::function<void ()(void)> *,std::allocator<std::function<void ()(void)> *> &>::push_front((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}