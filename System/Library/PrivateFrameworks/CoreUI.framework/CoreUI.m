unsigned __int16 *CUIRenditionKeySetValueForAttribute(unsigned __int16 *result, int a2, int a3, unsigned int a4)
{
  int v4;
  unint64_t v5;
  unsigned __int16 *v6;
  int v7;
  BOOL v8;
  unsigned __int16 v9;
  unsigned __int16 *v10;
  unsigned __int16 v11;
  unint64_t v12;
  unsigned __int16 *v13;

  if (result)
  {
    if (!a4) {
      CUIRenditionKeySetValueForAttribute_cold_1();
    }
    v4 = *result;
    if (!(result[1] | v4)) {
      goto LABEL_15;
    }
    LODWORD(v5) = 0;
    v6 = result + 3;
    while (v4 != a2)
    {
      LODWORD(v5) = v5 + 1;
      v7 = *v6;
      v4 = *(v6 - 1);
      v6 += 2;
      if (v7) {
        v8 = 0;
      }
      else {
        v8 = v4 == 0;
      }
      if (v8) {
        goto LABEL_15;
      }
    }
    if ((v5 & 0x80000000) != 0)
    {
LABEL_15:
      if (!a3) {
        return result;
      }
      v9 = 0;
      if (result[1]) {
        goto LABEL_18;
      }
      while (result[2 * v9])
      {
        do
LABEL_18:
          ++v9;
        while (result[2 * v9 + 1]);
      }
      if ((int)(a4 - 1) <= v9) {
        CUIRenditionKeySetValueForAttribute_cold_2();
      }
      v10 = &result[2 * v9];
      *v10 = a2;
      v10[1] = a3;
      v5 = v9 + 1;
      result[2 * v5] = 0;
      LOWORD(a3) = 0;
      goto LABEL_22;
    }
    if (a3)
    {
      v5 = v5;
LABEL_22:
      result[2 * v5 + 1] = a3;
      return result;
    }
    v11 = 0;
    if (result[1]) {
      goto LABEL_26;
    }
    while (1)
    {
      v12 = v11;
      if (!result[2 * v11]) {
        break;
      }
      do
LABEL_26:
        ++v11;
      while (result[2 * v11 + 1]);
    }
    if (a4 <= v11) {
      CUIRenditionKeySetValueForAttribute_cold_3();
    }
    if (v11 > (unsigned __int16)v5)
    {
      v5 = (unsigned __int16)v5;
      v13 = &result[2 * (unsigned __int16)v5 + 2];
      do
      {
        ++v5;
        *((_DWORD *)v13 - 1) = *(_DWORD *)v13;
        v13 += 2;
      }
      while (v5 < v12);
    }
  }
  return result;
}

unsigned __int16 *_CUIRenditionKeySetIntegerValueForAttribute(unsigned __int16 *a1, __int16 a2, unint64_t a3)
{
  if (a3 >> 16) {
    _CUIRenditionKeySetIntegerValueForAttribute_cold_1(a2);
  }
  return CUIRenditionKeySetValueForAttribute(a1, a2, (unsigned __int16)a3, 0x16u);
}

uint64_t CUIBitVectorIsBitSet(os_unfair_lock_s *a1, unsigned int a2)
{
  os_unfair_lock_lock(a1);
  if (a2 >> 5 >= a1[1]._os_unfair_lock_opaque) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = (a1[(a2 >> 5) + 2]._os_unfair_lock_opaque >> a2) & 1;
  }
  os_unfair_lock_unlock(a1);
  return v4;
}

unsigned __int16 *CUIRenditionKeyValueForAttribute(unsigned __int16 *result, int a2)
{
  if (result)
  {
    int v2 = *result;
    if (result[1]) {
      BOOL v3 = 0;
    }
    else {
      BOOL v3 = v2 == 0;
    }
    if (v3) {
      return 0;
    }
    int v4 = 0;
    v5 = result + 3;
    while (v2 != a2)
    {
      ++v4;
      int v6 = *v5;
      int v2 = *(v5 - 1);
      v5 += 2;
      if (v6) {
        BOOL v7 = 0;
      }
      else {
        BOOL v7 = v2 == 0;
      }
      if (v7) {
        return 0;
      }
    }
    if (v4 < 0) {
      return 0;
    }
    else {
      return (unsigned __int16 *)result[2 * v4 + 1];
    }
  }
  return result;
}

uint64_t CUIRenditionKeyTokenCount(uint64_t a1)
{
  unsigned __int16 v1 = 0;
  if (a1)
  {
    while (*(_WORD *)(a1 + 4 * v1 + 2) || *(_WORD *)(a1 + 4 * v1))
      ++v1;
  }
  return v1;
}

uint64_t _findIndexForKey(uint64_t a1, uint64_t a2, void *__s1, unint64_t a4, BOOL *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a2 + 16))
  {
    int v12 = 0;
    int v13 = *(unsigned __int16 *)(a2 + 16) - 1;
    while (1)
    {
      uint64_t v14 = v12 + ((v13 - v12) >> 1);
      unsigned int v15 = *(_DWORD *)(*(void *)(a2 + 24) + 8 * (int)v14 + 4);
      int v16 = *(_DWORD *)(a1 + 356);
      unsigned int v17 = bswap32(v15);
      if ((v16 & 0x40) != 0) {
        unint64_t v18 = v17;
      }
      else {
        unint64_t v18 = v15;
      }
      if (!v18)
      {
        unint64_t v18 = 0;
LABEL_18:
        unint64_t v19 = 0;
        goto LABEL_27;
      }
      if ((v16 & 4) != 0) {
        goto LABEL_18;
      }
      if ((v16 & 0x40) != 0)
      {
        unint64_t v19 = *(unsigned int *)(a1 + 348);
        if ((int)v19 >= 1) {
          goto LABEL_12;
        }
        unsigned int v15 = v17;
      }
      unint64_t v19 = BOMStorageSizeOfBlock(*(void *)a1, v15, (uint64_t)__s1, a4, (uint64_t)a5, a6, a7, a8);
LABEL_12:
      unint64_t v20 = *(unsigned int *)(a1 + 344);
      unint64_t v18 = *(void *)(a1 + 336);
      if (v19 > v20)
      {
        unint64_t v21 = (2 * v20);
        if (v19 > v21) {
          LODWORD(v21) = v19;
        }
        *(_DWORD *)(a1 + 344) = v21;
        if (v18)
        {
          free((void *)v18);
          *(void *)(a1 + 336) = 0;
          size_t v22 = *(unsigned int *)(a1 + 344);
        }
        else
        {
          size_t v22 = v21;
        }
        unint64_t v18 = (unint64_t)BOM_malloc(v22);
        *(void *)(a1 + 336) = v18;
      }
      if ((*(unsigned char *)(a1 + 356) & 0x40) != 0)
      {
        size_t v24 = *(unsigned int *)(a1 + 348);
        if ((int)v24 >= 1)
        {
          memcpy((void *)v18, (const void *)(*(void *)(a2 + 32) + v24 * (int)v14), v24);
          goto LABEL_27;
        }
        unsigned int v23 = bswap32(*(_DWORD *)(*(void *)(a2 + 24) + 8 * (int)v14 + 4));
      }
      else
      {
        unsigned int v23 = *(_DWORD *)(*(void *)(a2 + 24) + 8 * (int)v14 + 4);
      }
      BOMStorageCopyFromBlock(*(void *)a1, v23, (void *)v18, a4, (uint64_t)a5, a6, a7, a8);
LABEL_27:
      if ((*(unsigned char *)(a1 + 356) & 4) != 0)
      {
        if (v18 <= (unint64_t)__s1) {
          int v27 = 0;
        }
        else {
          int v27 = -1;
        }
        if (v18 < (unint64_t)__s1) {
          int v26 = 1;
        }
        else {
          int v26 = v27;
        }
        goto LABEL_43;
      }
      if ((void *)v18 == __s1)
      {
        if (!a5) {
          return v14;
        }
        int v26 = 0;
        BOOL v28 = 1;
        goto LABEL_47;
      }
      if (__s1)
      {
        if (!v18)
        {
          int v26 = 1;
          goto LABEL_43;
        }
        if (a4 >= v19) {
          size_t v25 = v19;
        }
        else {
          size_t v25 = a4;
        }
        int v26 = memcmp(__s1, (const void *)v18, v25);
        if (v26) {
          goto LABEL_43;
        }
        if (v19 <= a4)
        {
          int v26 = v19 < a4;
          goto LABEL_43;
        }
      }
      int v26 = -1;
LABEL_43:
      if (!a5) {
        goto LABEL_48;
      }
      BOOL v28 = v26 == 0;
LABEL_47:
      *a5 = v28;
LABEL_48:
      if (v13 == v12)
      {
        if (v26 <= 0) {
          return v14;
        }
        else {
          return (v14 + 1);
        }
      }
      if (v26 >= 1)
      {
        if (v14 == v13) {
          v12 += (v13 - v12) >> 1;
        }
        else {
          int v12 = v14 + 1;
        }
      }
      else
      {
        if ((v26 & 0x80000000) == 0) {
          return v14;
        }
        int v13 = v14 - ((v13 - v12) > 1);
      }
    }
  }
  uint64_t v14 = 0;
  if (a5) {
    *a5 = 0;
  }
  return v14;
}

uint64_t BOMStorageSizeOfBlock(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 1056) < a2) {
      return 0;
    }
    unsigned int v11 = *(_DWORD *)(a1 + 1068);
    if (v11 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
      unsigned int v11 = *(_DWORD *)(a1 + 1068);
    }
    else
    {
      unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2);
      unsigned int v13 = bswap32(v12);
      if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
        unsigned int v12 = v13;
      }
      if (v12 != -1)
      {
LABEL_16:
        if (v11 > a2)
        {
          unsigned int v16 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
          unsigned int v17 = bswap32(v16);
          if (*(unsigned char *)(a1 + 1052)) {
            return v16;
          }
          else {
            return v17;
          }
        }
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        return 0;
      }
    }
    if (v11 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
      unsigned int v11 = *(_DWORD *)(a1 + 1068);
    }
    else
    {
      unsigned int v14 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
      unsigned int v15 = bswap32(v14);
      if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
        unsigned int v14 = v15;
      }
      if (v14 == -1) {
        return 0;
      }
    }
    goto LABEL_16;
  }
  return result;
}

uint64_t BOMStorageCopyFromBlockRange(uint64_t a1, unsigned int a2, uint64_t a3, size_t __len, void *__dst, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !__dst)
  {
    if (a1)
    {
      if (a2) {
        goto LABEL_8;
      }
    }
    else
    {
      unint64_t v19 = __error();
      _BOMExceptionHandlerCall("BOMStorageCopyFromBlockRange: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1096, *v19);
      if (a2)
      {
LABEL_8:
        if (!__dst) {
          goto LABEL_17;
        }
        return 1;
      }
    }
    unint64_t v20 = __error();
    _BOMExceptionHandlerCall("BOMStorageCopyFromBlockRange: !bid", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1098, *v20);
    if (!__dst)
    {
LABEL_17:
      int v11 = *__error();
      unsigned int v12 = "BOMStorageCopyFromBlockRange: !data";
      int v13 = 1100;
      goto LABEL_43;
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    int v11 = *__error();
    unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: bad block (bid > storage->blocks)";
    int v13 = 1106;
LABEL_43:
    _BOMExceptionHandlerCall(v12, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v13, v11);
    return 1;
  }
  unsigned int v16 = *(_DWORD *)(a1 + 1068);
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
    unsigned int v16 = *(_DWORD *)(a1 + 1068);
  }
  else
  {
    unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2);
    unsigned int v18 = bswap32(v17);
    if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
      unsigned int v17 = v18;
    }
    if (v17 != -1) {
      goto LABEL_25;
    }
  }
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    unsigned int v16 = *(_DWORD *)(a1 + 1068);
  }
  else
  {
    unsigned int v21 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
    unsigned int v22 = bswap32(v21);
    if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
      unsigned int v21 = v22;
    }
    if (v21 == -1)
    {
      int v11 = *__error();
      unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: reading from free block";
      int v13 = 1111;
      goto LABEL_43;
    }
  }
LABEL_25:
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
    unsigned int v16 = *(_DWORD *)(a1 + 1068);
    unsigned int v24 = -1;
  }
  else
  {
    unsigned int v23 = bswap32(*(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2));
    if (*(unsigned char *)(a1 + 1052)) {
      unsigned int v24 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2);
    }
    else {
      unsigned int v24 = v23;
    }
  }
  if (v16 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, __len, (uint64_t)__dst, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    unsigned int v25 = 0;
  }
  else
  {
    unsigned int v25 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
    unsigned int v26 = bswap32(v25);
    if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
      unsigned int v25 = v26;
    }
  }
  if (__CFADD__(v25, v24))
  {
    int v11 = *__error();
    unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: 32-bit overflow with block address+size";
    int v13 = 1121;
    goto LABEL_43;
  }
  if (v25 + v24 > *(_DWORD *)(a1 + 1032))
  {
    int v11 = *__error();
    unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: block extends past end of storage";
    int v13 = 1125;
    goto LABEL_43;
  }
  if (__CFADD__(__len, a3))
  {
    int v11 = *__error();
    unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: length extends beyond block size overflow";
    int v13 = 1136;
    goto LABEL_43;
  }
  if (__len + a3 > v25)
  {
    int v11 = *__error();
    unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: length extends beyond block size";
    int v13 = 1140;
    goto LABEL_43;
  }
  if (v25)
  {
    if (!v24)
    {
      int v11 = *__error();
      unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: bad block address";
      int v13 = 1148;
      goto LABEL_43;
    }
    uint64_t v28 = *(void *)(a1 + 1080);
    if (v28 && (*(unsigned char *)(v28 + 4 * a2) & 1) != 0)
    {
      int v29 = *(_DWORD *)(a1 + 1052);
    }
    else
    {
      int v29 = *(_DWORD *)(a1 + 1052);
      if ((v29 & 1) != 0 && *(_DWORD *)(a1 + 1028) != -1) {
        goto LABEL_55;
      }
    }
    if ((v29 & 2) != 0)
    {
      v44 = (const void *)(*(void *)(a1 + 1040) + v24 + a3);
      goto LABEL_64;
    }
LABEL_55:
    int v30 = *(_DWORD *)(a1 + 1028);
    if ((v29 & 2) == 0)
    {
      v31 = BOMStreamWithFile(v30, v24, v25, 0, 0);
      BOMStreamReadBuffer((uint64_t)v31, __dst, __len, v32, v33, v34, v35, v36);
      BOMStreamFree((uint64_t)v31, v37, v38, v39, v40, v41, v42, v43);
      return 0;
    }
    v45 = BOMStreamWithFile(v30, v24, v25, 0, (char *)(*(void *)(a1 + 1040) + v24));
    if (!v45)
    {
      int v11 = *__error();
      unsigned int v12 = "BOMStorageCopyRangeFromBlockRange: !stream";
      int v13 = 1173;
      goto LABEL_43;
    }
    BOMStreamFree((uint64_t)v45, v46, v47, v48, v49, v50, v51, v52);
    uint64_t v60 = *(void *)(a1 + 1080);
    if (v60)
    {
      *(unsigned char *)(v60 + 4 * a2) |= 1u;
    }
    else
    {
      v61 = BOMExceptionHandlerMessage("BOM blockShadowTable is null", v53, v54, v55, v56, v57, v58, v59, v63);
      v62 = __error();
      _BOMExceptionHandlerCall(v61, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1180, *v62);
    }
    v44 = (const void *)(*(void *)(a1 + 1040) + v24 + a3);
LABEL_64:
    memmove(__dst, v44, __len);
  }
  return 0;
}

uint64_t BOMStorageCopyFromBlock(uint64_t a1, unsigned int a2, void *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2)
  {
    if (a1)
    {
      if (!a2) {
        goto LABEL_13;
      }
    }
    else
    {
      unsigned int v17 = __error();
      _BOMExceptionHandlerCall("BOMStorageCopyFromBlock: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 994, *v17);
      if (!a2)
      {
LABEL_13:
        int v10 = *__error();
        int v11 = "BOMStorageCopyFromBlock: !bid";
        int v12 = 996;
        goto LABEL_14;
      }
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    int v10 = *__error();
    int v11 = "BOMStorageCopyFromBlock: bid > storage->blocks";
    int v12 = 1000;
LABEL_14:
    _BOMExceptionHandlerCall(v11, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v12, v10);
    return 1;
  }
  if (*(_DWORD *)(a1 + 1068) <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)__dst, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    size_t v16 = 0;
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
    unsigned int v15 = bswap32(v14);
    if (*(unsigned char *)(a1 + 1052)) {
      size_t v16 = v14;
    }
    else {
      size_t v16 = v15;
    }
  }
  return BOMStorageCopyFromBlockRange(a1, a2, 0, v16, __dst, a6, a7, a8);
}

void *CUIRenditionKeyCopy(void *a1, _WORD *a2, unsigned int a3)
{
  if (!a1 || !a2) {
    CUIRenditionKeyCopy_cold_1();
  }
  for (unsigned __int16 i = 0; a2[2 * i + 1] || a2[2 * i]; ++i)
    ;
  if (i >= a3) {
    CUIRenditionKeyCopy_cold_2();
  }
  return memmove(a1, a2, 4 * i + 4);
}

uint64_t CUICopyKeySignatureWithPrefix(char *a1, unint64_t a2, int *a3, uint64_t a4, uint64_t *a5, unsigned int a6)
{
  if (!a4) {
    CUICopyKeySignatureWithPrefix_cold_1();
  }
  memset(v34, 0, 44);
  size_t v12 = *(unsigned int *)(a4 + 8);
  if (v12 < 0x16) {
    int v13 = v34;
  }
  else {
    int v13 = malloc_type_calloc(v12, 2uLL, 0x1000040BDFB0063uLL);
  }
  CUIFillCARKeyArrayForRenditionKey2((uint64_t)v13, a3, a4, a5);
  if (a2)
  {
    unsigned int v14 = a1 + 1;
    do
    {
      unsigned int v15 = a6;
      size_t v16 = v14;
      a6 /= 0xAu;
      *(v14 - 1) = (v15 - 10 * a6) | 0x30;
      if (v15 < 0xA) {
        break;
      }
      ++v14;
      --a2;
    }
    while (a2);
  }
  else
  {
    size_t v16 = a1;
  }
  unint64_t v17 = v16 - a1;
  if ((unint64_t)(v16 - a1) >= 2)
  {
    uint64_t v18 = 0;
    do
    {
      char v19 = a1[v18];
      unint64_t v20 = (char *)(v17 - (v18 + 1));
      a1[v18] = v20[(void)a1];
      v20[(void)a1] = v19;
    }
    while (v17 >> 1 > ++v18);
  }
  uint64_t v22 = _CUICopySortedKeySignature(v16, a2, (uint64_t)v13, 2 * *(unsigned int *)(a4 + 8));
  if (v22 < 0)
  {
    if (v13 != v34) {
      free(v13);
    }
    return -1;
  }
  unint64_t v23 = v22;
  if (v13 != v34) {
    free(v13);
  }
  if (a2 - v23 < 0x11) {
    return -1;
  }
  if (v23 < 0x61) {
    return v23;
  }
  uint64_t v24 = 0;
  unint64_t v25 = 0;
  while (HIWORD(a3[v24]))
  {
    int v26 = LOWORD(a3[v24]);
    if (a5 && (*a5 & (1 << v26)) != 0)
    {
      LODWORD(v27) = *((unsigned __int8 *)a5 + LOWORD(a3[v24]) + 8);
LABEL_24:
      char v28 = 4 * v24 + 16;
      if (v27 < 4) {
        char v28 = 8 * v24;
      }
      if (v27 <= 0xB) {
        v25 ^= (unint64_t)HIWORD(a3[v24]) << v28;
      }
      goto LABEL_33;
    }
    uint64_t v29 = *(unsigned int *)(a4 + 8);
    if (v29)
    {
      uint64_t v27 = 0;
      while (*(_DWORD *)(a4 + 12 + 4 * v27) != v26)
      {
        if (v29 == ++v27) {
          goto LABEL_33;
        }
      }
      goto LABEL_24;
    }
LABEL_33:
    if (++v24 == 21) {
      break;
    }
  }
  v23 += 16;
  int v30 = &v16[v23];
  v16[v23] = 0;
  int v31 = 16;
  do
  {
    if (v25)
    {
      if ((v25 & 0xF) >= 0xA) {
        char v32 = (v25 & 0xF) + 87;
      }
      else {
        char v32 = v25 & 0xF | 0x30;
      }
      *--int v30 = v32;
      v25 >>= 4;
    }
    else
    {
      *--int v30 = 48;
    }
    --v31;
  }
  while (v31);
  return v23;
}

uint64_t CUIFillCARKeyArrayForRenditionKey2(uint64_t result, int *a2, uint64_t a3, uint64_t *a4)
{
  if (!result || !a2) {
    CUIFillCARKeyArrayForRenditionKey2_cold_1();
  }
  v5 = a4;
  uint64_t v6 = result;
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  if (!a4)
  {
    v5 = (uint64_t *)v11;
    uint64_t result = CUIRenditionKeyInitializeAttributeIndexWithKeyFormat((uint64_t)v11, a3);
  }
  int v7 = *a2;
  if (*a2)
  {
    uint64_t v8 = *v5;
    v9 = a2 + 1;
    do
    {
      if ((v8 & (1 << v7)) != 0) {
        *(_WORD *)(v6 + 2 * *((unsigned __int8 *)v5 + (unsigned __int16)v7 + 8)) = *((_WORD *)v9 - 1);
      }
      int v10 = *v9++;
      LOWORD(v7) = v10;
    }
    while (v10);
  }
  return result;
}

uint64_t _CUICopySortedKeySignature(char *__dst, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = -1;
  if (__dst && a2 >= 0x65)
  {
    v9 = stpncpy(__dst, "{", a2 - 1);
    int v10 = (char *)(&__dst[a2] - v9);
    if (&__dst[a2] != v9 && (uint64_t)(a4 & 0xFFFFFFFFFFFFFFFELL) >= 1)
    {
      unint64_t v11 = a3 + 2;
      do
      {
        unsigned int v12 = *(unsigned __int16 *)(v11 - 2);
        unsigned int v13 = (v12 >> 8) & 0xF;
        if (v12 >= 0xA000) {
          int v14 = 87;
        }
        else {
          int v14 = 48;
        }
        unsigned int v15 = v14 + (v12 >> 12);
        if (v13 >= 0xA) {
          int v16 = 87;
        }
        else {
          int v16 = 48;
        }
        unsigned int v17 = v16 + v13;
        unsigned int v18 = v12 & 0xF;
        unsigned int v19 = v12 >> 4;
        if (v19 >= 0xA) {
          int v20 = 87;
        }
        else {
          int v20 = 48;
        }
        unsigned int v21 = v20 + v19;
        if (v18 >= 0xA) {
          int v22 = 87;
        }
        else {
          int v22 = 48;
        }
        unsigned int v23 = v22 + v18;
        BOOL v25 = v15 == 48 && v17 == 48;
        BOOL v26 = v21 == 48 && v25;
        uint64_t v27 = v9 + 1;
        if (v26 && v23 == 48)
        {
          char *v9 = 48;
        }
        else if (v26)
        {
          char *v9 = v23;
        }
        else if (v25)
        {
          char *v9 = v21;
          uint64_t v27 = v9 + 2;
          v9[1] = v23;
        }
        else if (v15 == 48)
        {
          uint64_t v27 = v9 + 3;
          char *v9 = v17;
          v9[1] = v21;
          v9[2] = v23;
        }
        else
        {
          char *v9 = v15;
          v9[1] = v17;
          v9[2] = v21;
          uint64_t v27 = v9 + 4;
          v9[3] = v23;
        }
        *uint64_t v27 = 45;
        v9 = v27 + 1;
        v10 -= 5;
        if (!v10) {
          break;
        }
        BOOL v28 = v11 >= a3 + (a4 & 0xFFFFFFFFFFFFFFFELL);
        v11 += 2;
      }
      while (!v28);
    }
    if ((unint64_t)(v10 - 3) > 0xFFFFFFFFFFFFFFFDLL) {
      v9 -= 2;
    }
    else {
      *(v9 - 1) = 125;
    }
    char *v9 = 0;
    return v9 - __dst;
  }
  return result;
}

uint64_t CUICopyKeySignature(char *a1, unint64_t a2, int *a3, uint64_t a4, uint64_t *a5)
{
  return CUICopyKeySignatureWithPrefix(a1, a2, a3, a4, a5, 0);
}

uint64_t BOMTreeValueExists(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  BOOL v15 = 0;
  if (a1 && a2)
  {
    if (a3 || (*(unsigned char *)(a1 + 356) & 4) != 0)
    {
      uint64_t result = _findPagesForKey(a1, 0, a2, a3, a5, a6, a7, a8);
      if (result)
      {
        _findIndexForKey(a1, result, a2, a3, &v15, v12, v13, v14);
        return v15;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _findPagesForKey(uint64_t a1, char *a2, void *__s1, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v12 = *(void *)(a1 + 24);
  if (a2) {
    BOMStackPush(a2, v12, (uint64_t)__s1, a4, a5, a6, a7, a8);
  }
  if ((*(_WORD *)(v12 + 4) & 1) == 0)
  {
    do
    {
      unsigned int v19 = *(_DWORD *)(*(void *)(v12 + 24) + 8 * (int)_findIndexForKey(a1, v12, __s1, a4, 0, a6, a7, a8));
      unsigned int v20 = bswap32(v19);
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0) {
        int v21 = v20;
      }
      else {
        int v21 = v19;
      }
      Page = _findPage(a1, v21, v13, v14, v15, v16, v17, v18);
      uint64_t v12 = (uint64_t)Page;
      if (!Page) {
        break;
      }
      if (a2)
      {
        BOMStackPush(a2, (uint64_t)Page, v23, v24, v25, a6, a7, a8);
        __int16 v26 = *(_WORD *)(v12 + 4) | 8;
      }
      else
      {
        __int16 v26 = *((_WORD *)Page + 2);
      }
      *(_WORD *)(v12 + 4) = v26 & 0xFFFB;
    }
    while ((v26 & 1) == 0);
  }
  return v12;
}

void *_findPage(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (a1)
    {
      uint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = *(void **)(a1 + 32 + v10);
        if (v11)
        {
          if (*(_DWORD *)v11 == a2) {
            break;
          }
        }
        v10 += 8;
        if (v10 == 256) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      unint64_t v11 = 0;
    }
    int v12 = 0;
    while (1)
    {
      if (v11) {
        return v11;
      }
      uint64_t v13 = *(int *)(a1 + 288);
      unint64_t v11 = *(void **)(a1 + 8 * v13 + 32);
      if (!v11)
      {
        unint64_t v11 = _NewPage(a1, a2);
        if (!v11) {
          return v11;
        }
        if (_ReadPage(a1, (uint64_t)v11, v18, v19, v20, v21, v22, v23)) {
          return 0;
        }
        uint64_t v13 = *(int *)(a1 + 288);
        *(void *)(a1 + 8 * v13 + 32) = v11;
        goto LABEL_26;
      }
      __int16 v14 = *((_WORD *)v11 + 2);
      if ((v14 & 0xC) == 4) {
        break;
      }
      if ((v14 & 4) != 0)
      {
        unint64_t v11 = 0;
LABEL_26:
        int v24 = v12;
        goto LABEL_27;
      }
      int v24 = 0;
      *((_WORD *)v11 + 2) = v14 | 4;
      LODWORD(v13) = *(_DWORD *)(a1 + 288);
      unint64_t v11 = 0;
LABEL_27:
      int v25 = v13 + 1;
      BOOL v26 = -v25 < 0;
      int v27 = -v25 & 0x1F;
      int v28 = v25 & 0x1F;
      if (!v26) {
        int v28 = -v27;
      }
      *(_DWORD *)(a1 + 288) = v28;
      int v12 = v24 + 1;
      if (!v11 && v24 >= 32)
      {
        uint64_t v29 = __error();
        _BOMExceptionHandlerCall("btree cache is deadlocked", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2347, *v29);
        return 0;
      }
    }
    if ((v14 & 2) != 0) {
      _WritePage(a1, (uint64_t)v11);
    }
    uint64_t v15 = 0;
    uint64_t v16 = (void *)v11[3];
    v11[4] = 0;
    *(_OWORD *)unint64_t v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    if ((*(unsigned char *)(a1 + 356) & 0x40) == 0)
    {
      unsigned int v17 = *(_DWORD *)(a1 + 308);
      if (v17 <= *(_DWORD *)(a1 + 312)) {
        unsigned int v17 = *(_DWORD *)(a1 + 312);
      }
      bzero(v16, 8 * v17);
      uint64_t v15 = v16;
    }
    *(_DWORD *)unint64_t v11 = a2;
    v11[1] = -1;
    v11[3] = v15;
    v11[4] = 0;
    if (_ReadPage(a1, (uint64_t)v11, a3, a4, a5, a6, a7, a8)) {
      return 0;
    }
    uint64_t v13 = *(int *)(a1 + 288);
    *(void *)(a1 + 8 * v13 + 32) = v11;
    goto LABEL_26;
  }
  return 0;
}

uint64_t BOMTreeReadValue(uint64_t a1, void *__s1, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  BOOL v25 = 0;
  if (a1 && __s1)
  {
    if (!a3 && (*(unsigned char *)(a1 + 356) & 4) == 0) {
      return 0;
    }
    uint64_t result = _findPagesForKey(a1, 0, __s1, a3, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    uint64_t v15 = result;
    int IndexForKey = _findIndexForKey(a1, result, __s1, a3, &v25, v12, v13, v14);
    if (v25)
    {
      unsigned int v23 = bswap32(*(_DWORD *)(*(void *)(v15 + 24) + 8 * IndexForKey));
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0) {
        unsigned int v24 = v23;
      }
      else {
        unsigned int v24 = *(_DWORD *)(*(void *)(v15 + 24) + 8 * IndexForKey);
      }
      return BOMStorageReadFromBlock(*(void *)a1, v24, v17, v18, v19, v20, v21, v22);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BOMStorageReadFromBlock(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2)
  {
    if (a1)
    {
      if (!a2) {
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v16 = __error();
      _BOMExceptionHandlerCall("BOMStorageCopyFromBlock: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1013, *v16);
      if (!a2)
      {
LABEL_13:
        int v10 = *__error();
        unint64_t v11 = "BOMStorageCopyFromBlock: !bid";
        int v12 = 1016;
        goto LABEL_27;
      }
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    int v10 = *__error();
    unint64_t v11 = "BOMStorageCopyRangeFromBlockRange: bad block (bid > storage->blocks)";
    int v12 = 1023;
LABEL_27:
    _BOMExceptionHandlerCall(v11, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v12, v10);
    return 0;
  }
  unsigned int v13 = *(_DWORD *)(a1 + 1068);
  if (v13 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
    unsigned int v13 = *(_DWORD *)(a1 + 1068);
    unsigned int v15 = -1;
  }
  else
  {
    unsigned int v14 = bswap32(*(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2));
    if (*(unsigned char *)(a1 + 1052)) {
      unsigned int v15 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2);
    }
    else {
      unsigned int v15 = v14;
    }
  }
  if (v13 <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    unsigned int v17 = 0;
  }
  else
  {
    unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
    unsigned int v18 = bswap32(v17);
    if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
      unsigned int v17 = v18;
    }
    if (v15 == -1 && v17 == -1)
    {
      int v10 = *__error();
      unint64_t v11 = "BOMStorageCopyRangeFromBlockRange: reading from free block";
      int v12 = 1032;
      goto LABEL_27;
    }
  }
  if (__CFADD__(v17, v15))
  {
    int v10 = *__error();
    unint64_t v11 = "BOMStorageCopyRangeFromBlockRange: 32-bit overflow with block address+size";
    int v12 = 1038;
    goto LABEL_27;
  }
  if (v17 + v15 > *(_DWORD *)(a1 + 1032))
  {
    int v10 = *__error();
    unint64_t v11 = "BOMStorageCopyRangeFromBlockRange: block extends past end of storage";
    int v12 = 1042;
    goto LABEL_27;
  }
  if (!v17) {
    return 0;
  }
  uint64_t v20 = *(void *)(a1 + 1080);
  if (v20 && (*(unsigned char *)(v20 + 4 * a2) & 1) != 0)
  {
    int v21 = *(_DWORD *)(a1 + 1052);
LABEL_39:
    if ((v21 & 2) == 0) {
      return 0;
    }
    return *(void *)(a1 + 1040) + v15;
  }
  int v21 = *(_DWORD *)(a1 + 1052);
  if ((v21 & 1) == 0) {
    goto LABEL_39;
  }
  int v22 = *(_DWORD *)(a1 + 1028);
  if (v22 == -1) {
    goto LABEL_39;
  }
  if ((v21 & 2) == 0) {
    return 0;
  }
  unsigned int v23 = BOMStreamWithFile(v22, v15, v17, 0, (char *)(*(void *)(a1 + 1040) + v15));
  if (!v23)
  {
    int v10 = *__error();
    unint64_t v11 = "BOMStorageCopyRangeFromBlockRange: !stream";
    int v12 = 1070;
    goto LABEL_27;
  }
  BOMStreamFree((uint64_t)v23, v24, v25, v26, v27, v28, v29, v30);
  uint64_t v38 = *(void *)(a1 + 1080);
  if (v38)
  {
    *(unsigned char *)(v38 + 4 * a2) |= 1u;
  }
  else
  {
    uint64_t v39 = BOMExceptionHandlerMessage("BOM blockShadowTable is null", v31, v32, v33, v34, v35, v36, v37, v41);
    uint64_t v40 = __error();
    _BOMExceptionHandlerCall(v39, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1077, *v40);
  }
  return *(void *)(a1 + 1040) + v15;
}

uint64_t BOMTreeGetValueSize(uint64_t a1, void *__s1, unint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && __s1 && a4 && (a3 || (*(unsigned char *)(a1 + 356) & 4) != 0))
  {
    uint64_t PagesForKey = _findPagesForKey(a1, 0, __s1, a3, a5, a6, a7, a8);
    if (PagesForKey
      && (uint64_t v17 = PagesForKey, v28 = 0,
                             int IndexForKey = _findIndexForKey(a1, PagesForKey, __s1, a3, &v28, v14, v15, v16),
                             v28))
    {
      unsigned int v25 = bswap32(*(_DWORD *)(*(void *)(v17 + 24) + 8 * IndexForKey));
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0) {
        unsigned int v26 = v25;
      }
      else {
        unsigned int v26 = *(_DWORD *)(*(void *)(v17 + 24) + 8 * IndexForKey);
      }
      uint64_t v27 = BOMStorageSizeOfBlock(*(void *)a1, v26, v19, v20, v21, v22, v23, v24);
      uint64_t result = 0;
      *a4 = v27;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t CUIBitVectorNumberOfBitsSetInBucket(uint64_t a1, unsigned int a2)
{
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)*(unsigned int *)(a1 + 4 * (a2 >> 5) + 8));
  v2.i16[0] = vaddlv_u8(v2);
  return v2.u32[0];
}

uint64_t CUIMaxScaleForTargetPlatform(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) >= 2) {
    return 2;
  }
  else {
    return 3;
  }
}

uint64_t CUICurrentDeploymentVersionForTargetPlatform()
{
  return 11;
}

const char *CUISystemThemeRenditionKeyFormat()
{
  return "tmfk";
}

id _LookupThemeProvider(uint64_t a1)
{
  uint64_t v12 = 0;
  unsigned int v13 = &v12;
  uint64_t v14 = 0x3052000000;
  uint64_t v15 = __Block_byref_object_copy__2;
  uint64_t v16 = __Block_byref_object_dispose__2;
  uint64_t v17 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = ___LookupThemeProvider_block_invoke;
  v11[3] = &unk_1E5A58B58;
  v11[4] = &v12;
  v11[5] = a1;
  __PerformBlockWithThemeRegistry((uint64_t)v11);
  uint64_t v8 = (void *)v13[5];
  if (!v8)
  {
    _CUILog(4, (uint64_t)"CoreUI: CUIThemeStore: No theme registered with id=%lu", v2, v3, v4, v5, v6, v7, a1);
    uint64_t v8 = (void *)v13[5];
  }
  id v9 = v8;
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_1A12F294C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __PerformBlockWithThemeRegistry(uint64_t a1)
{
  if (__PerformBlockWithThemeRegistry___onceToken != -1) {
    dispatch_once(&__PerformBlockWithThemeRegistry___onceToken, &__block_literal_global_13);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__PerformBlockWithThemeRegistry___lock);
  (*(void (**)(uint64_t, uint64_t))(a1 + 16))(a1, __PerformBlockWithThemeRegistry___themeRegistry);
  os_unfair_lock_unlock((os_unfair_lock_t)&__PerformBlockWithThemeRegistry___lock);
}

void _CUILog(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (_CUILog___onceDefaultToken != -1) {
    dispatch_once(&_CUILog___onceDefaultToken, &__block_literal_global_28);
  }
  if (a1 != 3 || _CUILog___showDebugLogs)
  {
    unint64_t v11 = (void *)MEMORY[0x1A62313E0]();
    if (__logToStderr)
    {
      *(void *)buf = &a9;
      id v12 = [objc_alloc((Class)NSString) initWithUTF8String:a2];
      id v13 = [objc_alloc((Class)NSString) initWithFormat:v12 arguments:&a9];

      switch(a1)
      {
        case 1:
        case 2:
        case 3:
          fprintf(__stderrp, "%s\n", (const char *)[v13 UTF8String]);
          break;
        case 4:
          fprintf(__stderrp, "%s\n", (const char *)[v13 UTF8String]);
          goto LABEL_30;
        default:
          break;
      }
    }
    else
    {
      id v14 = [objc_alloc((Class)NSString) initWithUTF8String:a2];
      id v13 = [objc_alloc((Class)NSString) initWithFormat:v14 arguments:&a9];

      switch(a1)
      {
        case 1:
          if (__onceToken != -1) {
            dispatch_once(&__onceToken, &__block_literal_global_3);
          }
          uint64_t v15 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            *(void *)&buf[4] = v13;
            uint64_t v16 = v15;
            os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
            goto LABEL_22;
          }
          break;
        case 2:
          if (__onceToken != -1) {
            dispatch_once(&__onceToken, &__block_literal_global_3);
          }
          uint64_t v18 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138543362;
            *(void *)&buf[4] = v13;
            uint64_t v16 = v18;
            os_log_type_t v17 = OS_LOG_TYPE_INFO;
            goto LABEL_22;
          }
          break;
        case 3:
          if (__onceToken != -1) {
            dispatch_once(&__onceToken, &__block_literal_global_3);
          }
          uint64_t v19 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543362;
            *(void *)&buf[4] = v13;
            uint64_t v16 = v19;
            os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
LABEL_22:
            _os_log_impl(&dword_1A12EB000, v16, v17, "%{public}@", buf, 0xCu);
          }
          break;
        case 4:
          if (__onceToken != -1) {
            dispatch_once(&__onceToken, &__block_literal_global_3);
          }
          uint64_t v20 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            *(void *)&buf[4] = v13;
            _os_log_impl(&dword_1A12EB000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            if (__onceToken != -1) {
              dispatch_once(&__onceToken, &__block_literal_global_3);
            }
          }
          uint64_t v21 = __handle;
          if (os_log_type_enabled((os_log_t)__handle, OS_LOG_TYPE_FAULT)) {
            _CUILog_cold_1((uint64_t)v13, v21);
          }
LABEL_30:
          qword_1E953FD80 = (uint64_t)[v13 UTF8String];
          break;
        default:
          break;
      }
    }
  }
}

uint64_t CUIPlatformForPlatformString(void *a1)
{
  if (([a1 isEqualToString:kCUIPlatformMac[0]] & 1) != 0
    || ([a1 isEqualToString:@"osx"] & 1) != 0)
  {
    return 0;
  }
  if ([a1 isEqualToString:kCUIPlatformMaciOS]) {
    return 2;
  }
  if (([a1 isEqualToString:kCUIPlatformiOS] & 1) != 0
    || ([a1 isEqualToString:@"iphoneos"] & 1) != 0)
  {
    return 1;
  }
  if ([a1 isEqualToString:kCUIPlatformAppleTV]) {
    return 3;
  }
  if ([a1 isEqualToString:kCUIPlatformWatch]) {
    return 4;
  }
  if ([a1 isEqualToString:kCUIPlatformVision]) {
    return 5;
  }
  if ([a1 isEqualToString:@"xros"]) {
    return 5;
  }
  return -1;
}

_DWORD *CUIBitVectorFromData(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = 4 * v2;
  if (4 * v2 + 4 != a2) {
    return 0;
  }
  uint64_t v5 = malloc_type_malloc(v3 + 8, 0x7EDDED84uLL);
  bzero(v5, v3 + 8);
  __CFSetLastAllocationEventName();
  _DWORD *v5 = 0;
  v5[1] = v2;
  if (v2)
  {
    unint64_t v6 = 0;
    do
    {
      v5[v6 / 4 + 2] = a1[v6 / 4 + 1];
      v6 += 4;
    }
    while (v3 != v6);
  }
  return v5;
}

uint64_t BOMTreeStorage(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t _CUIColorGetSRGBBlack()
{
  if (_CUIColorGetSRGBBlack_onceToken != -1) {
    dispatch_once(&_CUIColorGetSRGBBlack_onceToken, &__block_literal_global_34);
  }
  return _CUIColorGetSRGBBlack_sBlackColor;
}

CGContextRef CUICGBitmapContextCreate(size_t a1, size_t a2, size_t a3, size_t a4, CGColorSpaceRef space, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGContextRef result = 0;
  if (!a1 || !a2) {
    return result;
  }
  uint32_t v11 = a6;
  size_t AlignedBytesPerRow = a4;
  if (!a4)
  {
    if ((a6 & 0x1F) - 1 >= 6)
    {
      if ((a6 & 0x1F) == 7) {
        goto LABEL_6;
      }
      if ((a6 & 0x1F) != 0) {
        CUICGBitmapContextCreate_cold_1(0, a2, a3, 0, (uint64_t)space, a6, a7, a8);
      }
    }
    CGColorSpaceGetNumberOfComponents(space);
LABEL_6:
    size_t AlignedBytesPerRow = CGBitmapGetAlignedBytesPerRow();
  }
  releaseInfo = (void *)((vm_page_size + AlignedBytesPerRow * a2 - 1) & -(uint64_t)vm_page_size);
  uint64_t v16 = mmap(0, (size_t)releaseInfo, 3, 4098, 1728053248, 0);
  if (v16 == (void *)-1)
  {
    uint64_t v18 = __error();
    uint64_t v19 = strerror(*v18);
    _CUILog(4, (uint64_t)"CoreUI: CUICGBitmapContextCreate() mmap failed error:'%s'", v20, v21, v22, v23, v24, v25, (uint64_t)v19);
  }
  else
  {
    os_log_type_t v17 = v16;
    CGContextRef result = CGBitmapContextCreateWithData(v16, a1, a2, a3, AlignedBytesPerRow, space, v11, (CGBitmapContextReleaseDataCallback)__freeBitmapContextData, releaseInfo);
    if (result) {
      return result;
    }
    munmap(v17, (size_t)releaseInfo);
  }
  return 0;
}

__CFString *_CUICreateStringWithColor(CGColor *a1)
{
  ColorSpace = CGColorGetColorSpace(a1);
  CFStringRef Name = CGColorSpaceGetName(ColorSpace);
  size_t NumberOfComponents = CGColorGetNumberOfComponents(a1);
  Components = CGColorGetComponents(a1);
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  uint64_t v7 = Mutable;
  if (Name)
  {
    CFStringAppendFormat(Mutable, 0, @"%@-", Name);
    if (!NumberOfComponents) {
      return v7;
    }
  }
  else
  {
    CFDataRef v8 = CGColorSpaceCopyICCData(ColorSpace);
    CFStringAppendFormat(v7, 0, @"%@", v8);
    CFRelease(v8);
    if (!NumberOfComponents) {
      return v7;
    }
  }
  do
  {
    if (--NumberOfComponents) {
      CFStringRef v9 = @"%f,";
    }
    else {
      CFStringRef v9 = @"%f";
    }
    uint64_t v10 = *(void *)Components++;
    CFStringAppendFormat(v7, 0, v9, v10);
  }
  while (NumberOfComponents);
  return v7;
}

void _CUILog_cold_1(uint64_t a1, NSObject *a2)
{
  int v2 = 138543362;
  uint64_t v3 = a1;
  _os_log_fault_impl(&dword_1A12EB000, a2, OS_LOG_TYPE_FAULT, "%{public}@", (uint8_t *)&v2, 0xCu);
}

void sub_1A12F5A74(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A12F697C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id CUICreatePathFromSVGNode(void *a1, long long *a2)
{
  id v2 = a1;
  if (a1)
  {
    while (CGSVGNodeGetParent())
      ;
    v18[0] = 0;
    v18[1] = v18;
    v18[2] = 0x2020000000;
    char v19 = 0;
    v16[0] = 0;
    v16[1] = v16;
    v16[2] = 0x3052000000;
    v16[3] = __Block_byref_object_copy__0;
    v16[4] = __Block_byref_object_dispose__0;
    os_log_type_t v17 = 0;
    long long v4 = a2[1];
    long long v13 = *a2;
    long long v5 = a2[2];
    long long v14 = v4;
    long long v15 = v5;
    os_log_type_t v17 = +[NSValue valueWithCGAffineTransform:&v13];
    *(void *)&long long v13 = 0;
    *((void *)&v13 + 1) = &v13;
    *(void *)&long long v14 = 0x3052000000;
    *((void *)&v14 + 1) = __Block_byref_object_copy__0;
    *(void *)&long long v15 = __Block_byref_object_dispose__0;
    *((void *)&v15 + 1) = 0;
    *((void *)&v15 + 1) = +[NSMutableArray array];
    uint64_t v7 = 0;
    CFDataRef v8 = &v7;
    uint64_t v9 = 0x3052000000;
    uint64_t v10 = __Block_byref_object_copy__0;
    uint32_t v11 = __Block_byref_object_dispose__0;
    id v12 = 0;
    id v12 = +[NSMutableArray array];
    CGSVGNodeEnumerate();
    id v2 = +[CUIVectorGlyphPath createConcatenatingPaths:v8[5]];
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v13, 8);
    _Block_object_dispose(v16, 8);
    _Block_object_dispose(v18, 8);
  }
  return v2;
}

void sub_1A12F70C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 144), 8);
  _Block_object_dispose((const void *)(v17 - 96), 8);
  _Unwind_Resume(a1);
}

void __CUICreatePathFromSVGNode_block_invoke(void *a1, uint64_t a2, int a3, unsigned char *a4)
{
  if (a3)
  {
    if (a1[8] == a2)
    {
      *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 0;
      *a4 = 1;
    }
    *(void *)(*(void *)(a1[4] + 8) + 40) = [*(id *)(*(void *)(a1[5] + 8) + 40) lastObject];
    unint64_t v6 = *(void **)(*(void *)(a1[5] + 8) + 40);
    [v6 removeLastObject];
  }
  else
  {
    long long v7 = *(_OWORD *)&CGAffineTransformIdentity.c;
    *(_OWORD *)&v15.a = *(_OWORD *)&CGAffineTransformIdentity.a;
    *(_OWORD *)&v15.c = v7;
    *(_OWORD *)&v15.tx = *(_OWORD *)&CGAffineTransformIdentity.tx;
    if (CGSVGNodeGetAttributeMap() && CGSVGAttributeMapGetAttribute()) {
      CGSVGAttributeGetTransform();
    }
    memset(&v14, 0, sizeof(v14));
    uint64_t v8 = a1[4];
    uint64_t v9 = *(void **)(*(void *)(v8 + 8) + 40);
    if (v9)
    {
      [v9 cgAffineTransformValue];
      uint64_t v8 = a1[4];
    }
    else
    {
      memset(&t2, 0, sizeof(t2));
    }
    CGAffineTransform v12 = v15;
    CGAffineTransformConcat(&v14, &v12, &t2);
    [*(id *)(*(void *)(a1[5] + 8) + 40) addObject:*(void *)(*(void *)(v8 + 8) + 40)];
    CGAffineTransform v12 = v14;
    *(void *)(*(void *)(a1[4] + 8) + 40) = +[NSValue valueWithCGAffineTransform:&v12];
    if (a1[8] == a2) {
      *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
    }
    if (*(unsigned char *)(*(void *)(a1[6] + 8) + 24))
    {
      CGAffineTransform v12 = v14;
      id v10 = CUICreatePathFromSVGShapeNode(a2, &v12);
      if (v10)
      {
        uint32_t v11 = v10;
        [*(id *)(*(void *)(a1[7] + 8) + 40) addObject:v10];
      }
    }
  }
}

id CUICreatePathFromSVGShapeNode(uint64_t a1, const CGAffineTransform *a2)
{
  if (CGSVGNodeGetType() != 2) {
    return 0;
  }
  int Primitive = CGSVGShapeNodeGetPrimitive();
  if (Primitive != 42)
  {
    int v6 = Primitive;
    if ((Primitive & 0xFFFFFFFE) != 0x2C) {
      return 0;
    }
    uint64_t FloatCount = CGSVGShapeNodeGetFloatCount();
    if (!FloatCount) {
      return 0;
    }
    unint64_t v8 = FloatCount;
    uint64_t v9 = (CGFloat *)malloc_type_malloc(8 * FloatCount, 0x100004000313F17uLL);
    CGSVGShapeNodeGetFloats();
    Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, a2, *v9, v9[1]);
    if (v8 >= 3)
    {
      uint64_t v10 = 0;
      do
      {
        CGPathAddLineToPoint(Mutable, a2, v9[v10 + 2], v9[v10 + 3]);
        unint64_t v11 = v10 + 4;
        v10 += 2;
      }
      while (v11 < v8);
    }
    if (v6 == 44) {
      CGPathCloseSubpath(Mutable);
    }
    free(v9);
    if (!Mutable) {
      return 0;
    }
LABEL_14:
    CGAffineTransform v12 = (void *)CUICreateClipStrokeKeyframeDataFromNode(0.0);
    id v13 = +[CUIVectorGlyphPath createWithPath:Mutable clipStrokeKeyframes:v12];
    CGPathRelease(Mutable);

    return v13;
  }
  if (CGSVGShapeNodeGetPath())
  {
    CGPath = (const CGPath *)CGSVGPathCreateCGPath();
    Mutable = (CGPath *)MEMORY[0x1A6230620](CGPath, a2);
    CGPathRelease(CGPath);
    if (Mutable) {
      goto LABEL_14;
    }
  }
  return 0;
}

uint64_t CUICreateClipStrokeKeyframeDataFromNode(float a1)
{
  CGSVGNodeGetAttributeMap();
  if (CUIVectorGlyphClipStrokeKeyframesAtom_onceToken != -1) {
    dispatch_once(&CUIVectorGlyphClipStrokeKeyframesAtom_onceToken, &__block_literal_global_5);
  }
  uint64_t result = CGSVGAttributeMapGetAttribute();
  if (result)
  {
    uint64_t v3 = (void *)CGSVGAttributeCopyString();
    long long v4 = CUICreateClipStrokeKeyframeDataFromString(v3, a1);

    return (uint64_t)v4;
  }
  return result;
}

void sub_1A12F97A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL CUISVGAttributeGetBoolean(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  BOOL v1 = 0;
  if (!CGSVGAttributeGetAtom()) {
    return v1;
  }
  CFStringRef v2 = (const __CFString *)CGSVGAtomCopyString();
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  BOOL v1 = CFStringCompare(v2, @"1", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v3, @"true", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v3, @"yes", 1uLL) == kCFCompareEqualTo;
  CFRelease(v3);
  return v1;
}

uint64_t CUISVGNodeCanBeRepresentedAsPath()
{
  uint64_t v2 = 0;
  CFStringRef v3 = &v2;
  uint64_t v4 = 0x2020000000;
  char v5 = 1;
  CGSVGNodeEnumerate();
  uint64_t v0 = *((unsigned __int8 *)v3 + 24);
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_1A12FA040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id __RunTimeThemeRefForFileURL_block_invoke(void *a1, void *a2)
{
  id v4 = [a2 objectForKey:a1[4]];
  if (v4)
  {
    id result = [v4 unsignedIntegerValue];
    *(void *)(*(void *)(a1[6] + 8) + 24) = result;
  }
  else
  {
    int v6 = [[CUIStructuredThemeStore alloc] initWithURL:a1[5]];
    if (v6)
    {
      long long v7 = v6;
      *(void *)(*(void *)(a1[6] + 8) + 24) = _RegisterThemeProvider(v6);

      unint64_t v8 = +[NSNumber numberWithUnsignedInteger:*(void *)(*(void *)(a1[6] + 8) + 24)];
      uint64_t v9 = a1[4];
      return [a2 setObject:v8 forKey:v9];
    }
    else
    {
      id result = [objc_alloc((Class)NSString) initWithFormat:@"RunTimeThemeRefForFileURL() failed to initialize CUIStructuredThemeStore at path: %@", a1[5]];
      *(void *)(*(void *)(a1[7] + 8) + 40) = result;
    }
  }
  return result;
}

void sub_1A12FAF9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 64), 8);
  _Unwind_Resume(a1);
}

void PerformBlockWithThemeRefCache(uint64_t a1)
{
  if (PerformBlockWithThemeRefCache___onceToken != -1) {
    dispatch_once(&PerformBlockWithThemeRefCache___onceToken, &__block_literal_global_7);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&PerformBlockWithThemeRefCache___themeRefCacheLookupMutex);
  (*(void (**)(uint64_t, uint64_t))(a1 + 16))(a1, PerformBlockWithThemeRefCache___themeRefsByUniqueKey);
  os_unfair_lock_unlock((os_unfair_lock_t)&PerformBlockWithThemeRefCache___themeRefCacheLookupMutex);
}

void __RunTimeThemeRefForBundleIdentifierAndName_block_invoke(uint64_t a1, void *a2)
{
  id v4 = [a2 objectForKey:*(void *)(a1 + 32)];
  if (v4)
  {
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v4 unsignedIntegerValue];
    return;
  }
  if ([*(id *)(a1 + 40) hasPrefix:kCUIMutableStructureThemeStoreBundlePrefix])
  {
    char v5 = [[CUIMutableStructuredThemeStore alloc] initWithIdentifier:*(void *)(a1 + 32)];
  }
  else
  {
    int v6 = +[NSBundle bundleWithIdentifier:*(void *)(a1 + 40)];
    long long v7 = [(NSBundle *)v6 pathForResource:*(void *)(a1 + 48) ofType:@"car" inDirectory:0];
    if (!v7)
    {
      *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) = [objc_alloc((Class)NSString) initWithFormat:@"RunTimeThemeRefForBundleIdentifierAndName() couldn't find %@.car in bundle with identifier: %@", *(void *)(a1 + 48), *(void *)(a1 + 40)];
      return;
    }
    uint64_t v8 = (uint64_t)v7;
    char v5 = [[CUIStructuredThemeStore alloc] initWithPath:v7];
    [(CUIStructuredThemeStore *)v5 setBundleID:*(void *)(a1 + 40)];
    [(CUIStructuredThemeStore *)v5 setMainBundle:v6 == +[NSBundle mainBundle]];
    if (!v5)
    {
      *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) = [objc_alloc((Class)NSString) initWithFormat:@"RunTimeThemeRefForBundleIdentifierAndName() failed to initialize CUIStructuredThemeStore at path: %@ in bundle: %@", v8, *(void *)(a1 + 40)];
      _CUILog(4, (uint64_t)"CoreUI: RunTimeThemeRefForBundleIdentifierAndName() failed to initialize CUIStructuredThemeStore at path: '%@' in bundle '%@'", v11, v12, v13, v14, v15, v16, v8);
      return;
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = _RegisterThemeProvider(v5);

  uint64_t v9 = +[NSNumber numberWithUnsignedInteger:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)];
  uint64_t v10 = *(void *)(a1 + 32);
  [a2 setObject:v9 forKey:v10];
}

uint64_t _RegisterThemeProvider(void *a1)
{
  if ([a1 conformsToProtocol:&unk_1EF4B2B28])
  {
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2020000000;
    uint64_t v14 = 0;
    v10[0] = (uint64_t)_NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = (uint64_t)___RegisterThemeProvider_block_invoke;
    v10[3] = (uint64_t)&unk_1E5A58AE8;
    v10[4] = (uint64_t)a1;
    v10[5] = (uint64_t)&v11;
    __PerformBlockWithThemeRegistry((uint64_t)v10);
    [a1 setThemeIndex:v12[3]];
    uint64_t v8 = v12[3];
    _Block_object_dispose(&v11, 8);
  }
  else
  {
    _CUILog(4, (uint64_t)"provider must conform to the CUIStructuredThemeStorage protocol", v2, v3, v4, v5, v6, v7, v10[0]);
    return 0;
  }
  return v8;
}

void sub_1A12FB2FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t BOMStorageOpenWithSys(uint64_t a1, int a2, long long *a3)
{
  uint64_t v3 = a3;
  if (!a3) {
    uint64_t v3 = BomSys_default();
  }
  long long v215 = 0u;
  long long v216 = 0u;
  long long v214 = 0u;
  memset(v213, 0, sizeof(v213));
  uint64_t v6 = (*((uint64_t (**)(void, uint64_t, void, uint64_t))v3 + 2))(*((void *)v3 + 1), a1, 2 * (a2 != 0), 420);
  if (v6 != -1)
  {
    uint64_t v7 = v6;
    if ((*((unsigned int (**)(void, uint64_t, _OWORD *))v3 + 9))(*((void *)v3 + 1), v6, v213) != -1)
    {
      uint64_t v8 = BOMStreamWithFileAndSys(v7, 0, 0x200uLL, 0, 0, v3);
      if (!v8)
      {
        v122 = __error();
        strerror(*v122);
        v130 = BOMExceptionHandlerMessage("can't read from: '%s' %s", v123, v124, v125, v126, v127, v128, v129, a1);
        int v88 = *__error();
        v89 = v130;
        int v90 = 286;
        goto LABEL_18;
      }
      uint64_t v16 = (uint64_t)v8;
      if (BOMStreamReadUInt32((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15) == 1112493395
        && BOMStreamReadUInt32(v16, v17, v18, v19, v20, v21, v22, v23) == 1953460837)
      {
        if (BOMStreamReadUInt32(v16, v17, v18, v19, v20, v21, v22, v23) == 1)
        {
          uint64_t v31 = BOM_malloczero(0x470uLL);
          uint64_t v39 = (uint64_t)v31;
          if (!v31)
          {
            v133 = __error();
            char v134 = strerror(*v133);
            v142 = BOMExceptionHandlerMessage("malloc: %s", v135, v136, v137, v138, v139, v140, v141, v134);
            v143 = __error();
            _BOMExceptionHandlerCall(v142, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 317, *v143);
            BOMStreamFree(v16, v144, v145, v146, v147, v148, v149, v150);
            (*((void (**)(void, uint64_t))v3 + 3))(*((void *)v3 + 1), v7);
            return v39;
          }
          v31[140] = v3;
          *((_DWORD *)v31 + 257) = v7;
          int v40 = v214;
          *((_DWORD *)v31 + 258) = v214;
          *((_DWORD *)v31 + 259) = v40;
          *((_DWORD *)v31 + 263) = *((_DWORD *)v31 + 263) & 0xFFFFFFF6 | a2 & 1;
          *((_DWORD *)v31 + 264) = BOMStreamReadUInt32(v16, v32, v33, v34, v35, v36, v37, v38);
          *(_DWORD *)(v39 + 1060) = BOMStreamReadUInt32(v16, v41, v42, v43, v44, v45, v46, v47);
          *(_DWORD *)(v39 + 1064) = BOMStreamReadUInt32(v16, v48, v49, v50, v51, v52, v53, v54);
          *(_DWORD *)(v39 + 1096) = BOMStreamReadUInt32(v16, v55, v56, v57, v58, v59, v60, v61);
          *(_DWORD *)(v39 + 1100) = BOMStreamReadUInt32(v16, v62, v63, v64, v65, v66, v67, v68);
          *(_DWORD *)(v39 + 1052) &= ~4u;
          *(void *)(v39 + 1128) = 0;
          BOMStreamFree(v16, v69, v70, v71, v72, v73, v74, v75);
          int v83 = *(_DWORD *)(v39 + 1060);
          int v84 = *(_DWORD *)(v39 + 1064);
          BOOL v85 = __CFADD__(v84, v83);
          unsigned int v86 = v84 + v83;
          if (v85)
          {
            v87 = BOMExceptionHandlerMessage("%s: stream invalid; overflow of admin offset+size",
                    v76,
                    v77,
                    v78,
                    v79,
                    v80,
                    v81,
                    v82,
                    a1);
            int v88 = *__error();
            v89 = v87;
            int v90 = 344;
          }
          else
          {
            uint64_t v151 = *(unsigned int *)(v39 + 1032);
            if (v86 <= v151)
            {
              int v153 = *(_DWORD *)(v39 + 1096);
              int v154 = *(_DWORD *)(v39 + 1100);
              BOOL v85 = __CFADD__(v154, v153);
              unsigned int v155 = v154 + v153;
              if (v85)
              {
                v156 = BOMExceptionHandlerMessage("%s: stream invalid; overflow of toc offset+size",
                         v76,
                         v151,
                         v78,
                         v79,
                         v80,
                         v81,
                         v82,
                         a1);
                int v88 = *__error();
                v89 = v156;
                int v90 = 358;
              }
              else
              {
                if (v155 <= v151)
                {
                  if (a2)
                  {
                    if (v151 <= 0x800) {
                      unsigned int v158 = 2048;
                    }
                    else {
                      unsigned int v158 = *(_DWORD *)(v39 + 1032);
                    }
                    *(_DWORD *)(v39 + 1048) = v158;
                    _CreateMapAddress(v39, v158);
                    uint64_t v159 = *(void *)(v39 + 1040);
                    if (!v159) {
                      goto LABEL_19;
                    }
                    *(_DWORD *)(v39 + 1052) |= 0xAu;
                    uint64_t v160 = *(unsigned int *)(v39 + 1096);
                    if (v160)
                    {
                      v161 = BOMStreamWithFileAndSys(*(_DWORD *)(v39 + 1028), v160, *(unsigned int *)(v39 + 1100), 0, (char *)(v159 + v160), v3);
                      if (!v161) {
                        goto LABEL_19;
                      }
                      BOMStreamFree((uint64_t)v161, v162, v163, v164, v165, v166, v167, v168);
                    }
                  }
                  else
                  {
                    v169 = (uint64_t (*)(void, void))*((void *)v3 + 12);
                    if (!v169) {
                      goto LABEL_48;
                    }
                    uint64_t v170 = v169(*((void *)v3 + 1), 0);
                    if (CUILogRenditionLogEnabled())
                    {
                      v171 = CUILogHandle();
                      if (os_log_type_enabled(v171, OS_LOG_TYPE_INFO))
                      {
                        *(_DWORD *)buf = 136446466;
                        uint64_t v218 = a1;
                        __int16 v219 = 2050;
                        uint64_t v220 = v170;
                        _os_log_impl(&dword_1A12EB000, v171, OS_LOG_TYPE_INFO, "CoreUI %{public}s %{public}p", buf, 0x16u);
                      }
                    }
                    if (v170 == -1)
                    {
LABEL_48:
                      *(_DWORD *)(v39 + 1048) = 0;
                      *(void *)(v39 + 1040) = 0;
                      *(_DWORD *)(v39 + 1052) &= ~2u;
                      __error();
                      _CUILog(1, (uint64_t)"mmap failed for '%s' using regular file reading %d", v175, v176, v177, v178, v179, v180, a1);
                    }
                    else
                    {
                      (*(void (**)(void, void))(*(void *)(v39 + 1120) + 24))(*(void *)(*(void *)(v39 + 1120) + 8), *(unsigned int *)(v39 + 1028));
                      *(_DWORD *)(v39 + 1028) = -1;
                      int v172 = *(_DWORD *)(v39 + 1052);
                      *(_DWORD *)(v39 + 1048) = *(_DWORD *)(v39 + 1032);
                      *(void *)(v39 + 1040) = v170;
                      *(_DWORD *)(v39 + 1052) = v172 | 0xA;
                      uint64_t v173 = *(unsigned int *)(v39 + 1060);
                      if (v173) {
                        madvise((void *)(v170 + v173), *(unsigned int *)(v39 + 1064), 3);
                      }
                      uint64_t v174 = *(unsigned int *)(v39 + 1096);
                      if (v174) {
                        madvise((void *)(*(void *)(v39 + 1040) + v174), *(unsigned int *)(v39 + 1100), 3);
                      }
                    }
                  }
                  _CreateBlockTable((void *)v39);
                  uint64_t v181 = *(unsigned int *)(v39 + 1060);
                  if (v181)
                  {
                    if (!a2 && (*(unsigned char *)(v39 + 1052) & 2) != 0)
                    {
                      uint64_t v183 = BOMStreamWithAddress(*(void *)(v39 + 1040) + v181, *(unsigned int *)(v39 + 1064), 0);
                    }
                    else
                    {
                      v182 = (char *)BOM_malloczero(*(unsigned int *)(v39 + 1064));
                      *(void *)(v39 + 1128) = v182;
                      if (!v182)
                      {
                        v191 = __error();
                        strerror(*v191);
                        _CUILog(4, (uint64_t)"%s: malloc: %s", v192, v193, v194, v195, v196, v197, (uint64_t)"BOMStorage BOMStorageOpenWithSys(const char *, Boolean, BomSys *)");
                        return 0;
                      }
                      uint64_t v183 = (uint64_t)BOMStreamWithFileAndSys(v7, *(unsigned int *)(v39 + 1060), *(unsigned int *)(v39 + 1064), 0, v182, v3);
                    }
                    uint64_t v198 = v183;
                    if (!v183)
                    {
                      v212 = BOMExceptionHandlerMessage("can't read from %s unable to create a BOMStream", v184, v185, v186, v187, v188, v189, v190, a1);
                      int v88 = *__error();
                      v89 = v212;
                      int v90 = 452;
                      goto LABEL_18;
                    }
                    if (_ReadBlockTable(v39, v183, v185, v186, v187, v188, v189, v190)
                      || _ReadFreeList(v39, v198, v199, v200, v201, v202, v203, v204))
                    {
                      goto LABEL_19;
                    }
                    BOMStreamFree(v198, v205, v206, v207, v208, v209, v210, v211);
                  }
                  else
                  {
                    *(void *)(v39 + 1088) = _BOMFreeListAllocate();
                  }
                  __strlcpy_chk();
                  return v39;
                }
                v157 = BOMExceptionHandlerMessage("%s: stream invalid; toc range is outside of file",
                         v76,
                         v151,
                         v78,
                         v79,
                         v80,
                         v81,
                         v82,
                         a1);
                int v88 = *__error();
                v89 = v157;
                int v90 = 365;
              }
            }
            else
            {
              v152 = BOMExceptionHandlerMessage("%s: stream invalid; admin range is outside of file",
                       v76,
                       v151,
                       v78,
                       v79,
                       v80,
                       v81,
                       v82,
                       a1);
              int v88 = *__error();
              v89 = v152;
              int v90 = 351;
            }
          }
LABEL_18:
          _BOMExceptionHandlerCall(v89, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v90, v88);
          goto LABEL_19;
        }
        v132 = BOMExceptionHandlerMessage("%s has an unknown version: 0x%X", v24, v25, v26, v27, v28, v29, v30, a1);
        int v112 = *__error();
        v113 = v132;
        int v114 = 307;
      }
      else
      {
        v111 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", v17, v18, v19, v20, v21, v22, v23, a1);
        int v112 = *__error();
        v113 = v111;
        int v114 = 293;
      }
      _BOMExceptionHandlerCall(v113, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v114, v112);
      BOMStreamFree(v16, v115, v116, v117, v118, v119, v120, v121);
LABEL_19:
      (*((void (**)(void, uint64_t))v3 + 3))(*((void *)v3 + 1), v7);
      return 0;
    }
    v101 = __error();
    char v102 = strerror(*v101);
    v110 = BOMExceptionHandlerMessage("fstat: %s", v103, v104, v105, v106, v107, v108, v109, v102);
    int v88 = *__error();
    v89 = v110;
    int v90 = 277;
    goto LABEL_18;
  }
  v91 = __error();
  strerror(*v91);
  v99 = BOMExceptionHandlerMessage("can't open: '%s' %s", v92, v93, v94, v95, v96, v97, v98, a1);
  v100 = __error();
  _BOMExceptionHandlerCall(v99, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 270, *v100);
  return 0;
}

uint64_t CUILogRenditionLogEnabled()
{
  return __renditionLogginEnabled;
}

uint64_t _ReadBlockTable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = BOMStreamReadUInt32(a2, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    int v18 = result;
    if (result >> 29 || (unint64_t v11 = 8 * result, v11 > *(unsigned int *)(a1 + 1064)))
    {
      uint64_t v19 = BOMExceptionHandlerMessage("bad value for block table count", v11, v12, v13, v14, v15, v16, v17, v40);
      uint64_t v20 = __error();
      _BOMExceptionHandlerCall(v19, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1594, *v20);
      return 1;
    }
    else if (*(unsigned char *)(a1 + 1052))
    {
      uint64_t v22 = result;
      _ExpandBlockTable((char *)a1, result);
      uint64_t v30 = 0;
      uint64_t v31 = 4 * v22;
      uint64_t v32 = 4;
      do
      {
        *(_DWORD *)(*(void *)(a1 + 1072) + v32 - 4) = BOMStreamReadUInt32(a2, v23, v24, v25, v26, v27, v28, v29);
        *(_DWORD *)(*(void *)(a1 + 1072) + v32) = BOMStreamReadUInt32(a2, v33, v34, v35, v36, v37, v38, v39);
        *(unsigned char *)(*(void *)(a1 + 1080) + v30) &= ~1u;
        v32 += 8;
        v30 += 4;
      }
      while (v31 != v30);
      return 0;
    }
    else
    {
      uint64_t DataPointer = BOMStreamGetDataPointer(a2, v11);
      uint64_t result = 0;
      *(void *)(a1 + 1072) = DataPointer;
      *(_DWORD *)(a1 + 1068) = v18;
    }
  }
  return result;
}

void *_CreateBlockTable(void *result)
{
  if (*((unsigned char *)result + 1052))
  {
    BOOL v1 = result;
    result[134] = BOM_malloczero(0x800uLL);
    uint64_t result = BOM_malloczero(0x400uLL);
    v1[135] = result;
    *((_DWORD *)v1 + 267) = 256;
  }
  return result;
}

uint64_t BomSys_open(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

void *BomSys_mmap(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

uint64_t BomSys_fstat(int a1, int a2, stat *a3)
{
  return fstat(a2, a3);
}

long long *BomSys_default()
{
  return &gDefaultSys;
}

uint64_t BomSys_close(int a1, int a2)
{
  return close(a2);
}

void *BOMStreamWithFileAndSys(int a1, uint64_t a2, size_t a3, int a4, char *a5, long long *a6)
{
  uint64_t v12 = BOM_malloczero(0x58uLL);
  if (v12)
  {
    if (!a6) {
      a6 = BomSys_default();
    }
    v12[9] = a6;
    *uint64_t v12 = 0x100000001;
    *((_DWORD *)v12 + 5) = a1;
    v12[3] = a2;
    v12[4] = a3;
    *((_DWORD *)v12 + 10) = a4;
    if (a5)
    {
      v12[6] = a5;
      *((unsigned char *)v12 + 80) &= ~1u;
      if ((a3 & 0x8000000000000000) != 0)
      {
LABEL_15:
        uint64_t v21 = __error();
        strerror(*v21);
        _CUILog(4, (uint64_t)"%s: malloc: %s", v22, v23, v24, v25, v26, v27, (uint64_t)"BOMStreamWithFileAndSys");
LABEL_18:
        BOMStreamFree(v12);
        return 0;
      }
    }
    else
    {
      uint64_t v20 = (char *)BOM_malloczero(a3);
      v12[6] = v20;
      if (!v20) {
        goto LABEL_15;
      }
      a5 = v20;
      *((unsigned char *)v12 + 80) |= 1u;
      a3 = v12[4];
      if ((a3 & 0x8000000000000000) != 0) {
        goto LABEL_15;
      }
    }
    v12[7] = a5;
    v12[8] = &a5[a3];
    if ((*((_DWORD *)v12 + 10) | 2) == 2)
    {
      if ((*((uint64_t (**)(void, void, void, void))a6 + 7))(*((void *)a6 + 1), *((unsigned int *)v12 + 5), v12[3], 0) == -1)
      {
        uint64_t v28 = __error();
        strerror(*v28);
        _CUILog(4, (uint64_t)"%s: lseek: %s", v29, v30, v31, v32, v33, v34, (uint64_t)"BOMStreamWithFileAndSys");
        goto LABEL_18;
      }
      a3 = (*((uint64_t (**)(void, void, void, void))a6 + 5))(*((void *)a6 + 1), *((unsigned int *)v12 + 5), v12[6], v12[4]);
      if (a3 != v12[4])
      {
        uint64_t v35 = __error();
        strerror(*v35);
        _CUILog(4, (uint64_t)"%s: read: %s", v36, v37, v38, v39, v40, v41, (uint64_t)"BOMStreamWithFileAndSys");
        goto LABEL_18;
      }
    }
    if (!a3) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v13 = __error();
    strerror(*v13);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v14, v15, v16, v17, v18, v19, (uint64_t)"BOMStreamWithFileAndSys");
  }
  return v12;
}

ssize_t BomSys_read(int a1, int a2, void *a3, size_t a4)
{
  return read(a2, a3, a4);
}

off_t BomSys_lseek(int a1, int a2, off_t a3, int a4)
{
  return lseek(a2, a3, a4);
}

void BOMExceptionHandlerSetDefault(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void BOMExceptionHandlerSet(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (__BOMExceptionHandlerKey___onceHandler != -1) {
    dispatch_once(&__BOMExceptionHandlerKey___onceHandler, &__block_literal_global_21);
  }
  if (pthread_setspecific(__BOMExceptionHandlerKey___key, a1))
  {
    _CUILog(4, (uint64_t)"BOMExceptionHandlerSet couldn't pthread_setspecific", v10, v11, v12, v13, v14, v15, a9);
  }
}

uint64_t _ReadFreeList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 1052) & 1) == 0)
  {
    uint64_t v9 = _BOMFreeListAllocate();
    uint64_t result = 0;
    *(void *)(a1 + 1088) = v9;
    return result;
  }
  int UInt32 = BOMStreamReadUInt32(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 1088) = _BOMFreeListAllocate();
  if (!UInt32) {
    return 0;
  }
  size_t v20 = (8 * UInt32);
  if ((int)v20 < 1)
  {
    uint64_t v31 = BOMExceptionHandlerMessage("_ReadFreeList: tring to read %d byte for freelist table.", v13, v14, v15, v16, v17, v18, v19, v20);
    uint64_t v32 = __error();
    _BOMExceptionHandlerCall(v31, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1723, *v32);
  }
  else
  {
    uint64_t v21 = BOM_malloc(v20);
    if (v21)
    {
      uint64_t v27 = v21;
      BOMStreamReadBuffer(a2, v21, v20, v22, v23, v24, v25, v26);
      uint64_t v28 = *(void *)(a1 + 1088);
      uint64_t v29 = *(void (**)(uint64_t, void *, size_t, BOOL))(v28 + 16);
      BOOL v30 = BOMStreamGetByteOrder(a2) == 1;
      v29(v28, v27, v20, v30);
      free(v27);
      return 0;
    }
  }
  return 1;
}

_DWORD *_BOMFreeListAllocate()
{
  uint64_t v0 = BOM_malloc(0x48uLL);
  BOOL v1 = v0;
  if (v0)
  {
    v0[2] = _dense_initialize;
    v0[3] = _dense_serialize;
    v0[4] = _dense_deallocate;
    v0[7] = _dense_clear;
    v0[5] = _dense_addFreeRange;
    v0[6] = _dense_allocateRange;
    v0[8] = _dense_print;
    uint64_t v2 = BOM_malloc(0x18uLL);
    if (v2)
    {
      uint64_t v3 = v2;
      uint64_t v4 = BOM_calloc(0x20uLL, 8uLL);
      *uint64_t v3 = v4;
      if (v4)
      {
        v3[1] = 0;
        *((_DWORD *)v3 + 4) = 32;
        *(void *)BOOL v1 = v3;
        v1[2] = 0;
        return v1;
      }
      free(v1);
      uint64_t v5 = v3;
    }
    else
    {
      uint64_t v5 = v1;
    }
    free(v5);
    return 0;
  }
  return v1;
}

void *BOM_calloc(size_t a1, size_t a2)
{
  char v2 = a2;
  uint64_t v3 = malloc_type_calloc(a1, a2, 0x561175E7uLL);
  if (v3)
  {
    __CFSetLastAllocationEventName();
  }
  else
  {
    uint64_t v4 = __error();
    strerror(*v4);
    uint64_t v12 = BOMExceptionHandlerMessage("BOM_calloc: (%zd bytes) %s\n", v5, v6, v7, v8, v9, v10, v11, v2);
    uint64_t v13 = __error();
    _BOMExceptionHandlerCall(v12, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 54, *v13);
  }
  return v3;
}

uint64_t BOMTreeIteratorKeySize(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if ((*(unsigned char *)(result + 57) & 8) != 0) {
      return 0;
    }
    if (((*(unsigned char *)(result + 57) & 1) != 0 || (uint64_t v9 = *(_DWORD **)(result + 8)) == 0
                                             || *v9 != *(_DWORD *)(result + 16))
      && !_revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8))
    {
      uint64_t result = 0;
      *(unsigned char *)(v8 + 57) |= 8u;
      return result;
    }
    uint64_t v10 = *(void *)v8;
    int v11 = *(_DWORD *)(*(void *)v8 + 356);
    if ((v11 & 4) != 0) {
      return 0;
    }
    if ((v11 & 0x40) != 0)
    {
      uint64_t result = *(unsigned int *)(v10 + 348);
      if ((int)result >= 1) {
        return result;
      }
      unsigned int v12 = bswap32(*(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4));
    }
    else
    {
      unsigned int v12 = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
    }
    uint64_t v13 = *(void *)v10;
    return BOMStorageSizeOfBlock(v13, v12, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t BOMTreeIteratorValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    char v9 = *(unsigned char *)(result + 57);
    if ((v9 & 8) != 0) {
      return 0;
    }
    if ((*(unsigned char *)(result + 57) & 1) == 0
      && (uint64_t v10 = *(_DWORD **)(result + 8)) != 0
      && *v10 == *(_DWORD *)(result + 16)
      || (int v11 = _revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8), v9 = *(unsigned char *)(v8 + 57), v11))
    {
      if ((v9 & 4) == 0)
      {
        unsigned int v12 = bswap32(*(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20)));
        if ((*(_DWORD *)(*(void *)v8 + 356) & 0x40) != 0) {
          unsigned int v13 = v12;
        }
        else {
          unsigned int v13 = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20));
        }
        unint64_t v14 = BOMStorageSizeOfBlock(**(void **)v8, v13, a3, a4, a5, a6, a7, a8);
        unint64_t v20 = *(void *)(v8 + 48);
        if (v14 > v20)
        {
          unint64_t v21 = v14;
          uint64_t v22 = *(void **)(v8 + 40);
          if (v22)
          {
            free(v22);
            *(void *)(v8 + 40) = 0;
            unint64_t v20 = *(void *)(v8 + 48);
          }
          if (v21 <= 2 * v20) {
            size_t v23 = 2 * v20;
          }
          else {
            size_t v23 = v21;
          }
          *(void *)(v8 + 48) = v23;
          *(void *)(v8 + 40) = BOM_malloc(v23);
        }
        unsigned int v24 = bswap32(*(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20)));
        if ((*(_DWORD *)(*(void *)v8 + 356) & 0x40) != 0) {
          unsigned int v25 = v24;
        }
        else {
          unsigned int v25 = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20));
        }
        if (BOMStorageCopyFromBlock(**(void **)v8, v25, *(void **)(v8 + 40), v15, v16, v17, v18, v19)) {
          return 0;
        }
        *(unsigned char *)(v8 + 57) |= 4u;
      }
      return *(void *)(v8 + 40);
    }
    else
    {
      uint64_t result = 0;
      *(unsigned char *)(v8 + 57) = v9 | 8;
    }
  }
  return result;
}

uint64_t BOMTreeIteratorIsAtEnd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  unsigned int v9 = *(unsigned __int8 *)(a1 + 57);
  if ((v9 & 8) != 0) {
    return 1;
  }
  if ((v9 & 1) != 0 || (uint64_t v10 = *(_DWORD **)(a1 + 8)) == 0 || *v10 != *(_DWORD *)(a1 + 16))
  {
    int v11 = _revalidateIterator(a1, a2, a3, a4, a5, a6, a7, a8);
    unsigned int v9 = *(unsigned __int8 *)(a1 + 57);
    if (!v11)
    {
      v9 |= 8u;
      *(unsigned char *)(a1 + 57) = v9;
    }
  }
  return (v9 >> 3) & 1;
}

uint64_t BOMTreeIteratorKey(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if ((*(unsigned char *)(result + 57) & 8) != 0) {
      return 0;
    }
    if (((*(unsigned char *)(result + 57) & 1) != 0 || (unsigned int v9 = *(_DWORD **)(result + 8)) == 0
                                             || *v9 != *(_DWORD *)(result + 16))
      && !_revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8))
    {
      uint64_t result = 0;
      *(unsigned char *)(v8 + 57) |= 8u;
      return result;
    }
    uint64_t v10 = *(void *)v8;
    int v11 = *(_DWORD *)(*(void *)v8 + 356);
    if ((v11 & 4) == 0)
    {
      if ((*(unsigned char *)(v8 + 57) & 2) != 0) {
        return *(void *)(v8 + 24);
      }
      if ((v11 & 0x40) != 0)
      {
        unint64_t v15 = *(unsigned int *)(v10 + 348);
        if ((int)v15 >= 1)
        {
LABEL_18:
          unint64_t v16 = *(void *)(v8 + 32);
          if (v15 > v16)
          {
            uint64_t v17 = *(void **)(v8 + 24);
            if (v17)
            {
              free(v17);
              *(void *)(v8 + 24) = 0;
              unint64_t v16 = *(void *)(v8 + 32);
            }
            if (v15 <= 2 * v16) {
              size_t v18 = 2 * v16;
            }
            else {
              size_t v18 = v15;
            }
            *(void *)(v8 + 32) = v18;
            *(void *)(v8 + 24) = BOM_malloc(v18);
          }
          uint64_t v19 = *(void *)v8;
          if ((*(unsigned char *)(*(void *)v8 + 356) & 0x40) == 0)
          {
            unsigned int v20 = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
            goto LABEL_31;
          }
          size_t v21 = *(unsigned int *)(v19 + 348);
          uint64_t v22 = *(void *)(v8 + 8);
          if ((int)v21 < 1)
          {
            unsigned int v20 = bswap32(*(_DWORD *)(*(void *)(v22 + 24) + 8 * *(int *)(v8 + 20) + 4));
LABEL_31:
            if (BOMStorageCopyFromBlock(*(void *)v19, v20, *(void **)(v8 + 24), a4, a5, a6, a7, a8)) {
              return 0;
            }
            goto LABEL_34;
          }
          uint64_t v23 = *(void *)(v22 + 32);
          if (v23)
          {
            memcpy(*(void **)(v8 + 24), (const void *)(v23 + *(int *)(v8 + 20) * v21), v21);
LABEL_34:
            *(unsigned char *)(v8 + 57) |= 2u;
            return *(void *)(v8 + 24);
          }
          return 0;
        }
        unsigned int v12 = bswap32(*(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4));
      }
      else
      {
        unsigned int v12 = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
      }
      unint64_t v15 = BOMStorageSizeOfBlock(*(void *)v10, v12, a3, a4, a5, a6, a7, a8);
      goto LABEL_18;
    }
    unsigned int v13 = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
    unsigned int v14 = bswap32(v13);
    if ((v11 & 0x40) != 0) {
      return v14;
    }
    else {
      return v13;
    }
  }
  return result;
}

uint64_t BOMTreeIteratorNext(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if ((*(unsigned char *)(result + 57) & 8) == 0)
    {
      if ((*(unsigned char *)(result + 57) & 1) == 0
        && (unsigned int v9 = *(_DWORD **)(result + 8)) != 0
        && *v9 == *(_DWORD *)(result + 16)
        || (uint64_t result = _revalidateIterator(result, a2, a3, a4, a5, a6, a7, a8), result))
      {
        if (*(unsigned char *)(v8 + 56))
        {
          unsigned int v10 = *(_DWORD *)(v8 + 20) + 1;
          *(_DWORD *)(v8 + 20) = v10;
          uint64_t v11 = *(void *)(v8 + 8);
          if (v10 >= *(unsigned __int16 *)(v11 + 16))
          {
            *(_DWORD *)(v8 + 20) = 0;
            int v12 = *(_DWORD *)(v11 + 8);
            if (!v12
              || (*(_DWORD *)(v8 + 16) = v12,
                  uint64_t result = (uint64_t)_findPage(*(void *)v8, v12, a3, a4, a5, a6, a7, a8),
                  (*(void *)(v8 + 8) = result) == 0))
            {
              *(unsigned char *)(v8 + 57) |= 8u;
            }
          }
        }
        else
        {
          *(unsigned char *)(v8 + 56) = 1;
        }
        char v13 = *(unsigned char *)(v8 + 57) & 0xF9;
      }
      else
      {
        char v13 = *(unsigned char *)(v8 + 57) | 8;
      }
      *(unsigned char *)(v8 + 57) = v13;
    }
  }
  return result;
}

uint64_t BOMTreeOpenWithName(uint64_t a1, const char *a2, char a3)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, a2);
  if (!NamedBlock) {
    return 0;
  }
  return _BOMTreeOpen(a1, a2, NamedBlock, a3);
}

uint64_t CUIRenditionKeyInitializeAttributeIndexWithKeyFormat(uint64_t result, uint64_t a2)
{
  *(void *)(result + 192) = 0;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 80) = 0u;
  unsigned int v2 = *(_DWORD *)(a2 + 8);
  if (v2 >= 0x40) {
    unsigned int v2 = 64;
  }
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    do
    {
      unint64_t v6 = *(unsigned __int16 *)(a2 + 12 + 4 * v3);
      *(unsigned char *)(result + 8 + v6) = v3;
      if (v6 <= 0x1C) {
        *(_DWORD *)(result + 80 + 4 * v5++) = v6;
      }
      v4 |= 1 << v6;
      ++v3;
      LODWORD(v6) = *(_DWORD *)(a2 + 8);
      if (v6 >= 0x40) {
        unint64_t v6 = 64;
      }
      else {
        unint64_t v6 = v6;
      }
    }
    while (v3 < v6);
  }
  else
  {
    unsigned int v5 = 0;
    uint64_t v4 = 0;
  }
  *(_DWORD *)(result + 76) = v5;
  *(void *)uint64_t result = v4;
  return result;
}

uint64_t _BOMTreeOpen(uint64_t a1, const char *a2, unsigned int a3, char a4)
{
  uint64_t v8 = _newBOMTree(a1, a2);
  uint64_t v15 = (uint64_t)v8;
  if (!v8) {
    return v15;
  }
  *uint64_t v8 = a1;
  *((_DWORD *)v8 + 4) = a3;
  uint64_t v22 = BOMStorageSizeOfBlock(a1, a3, v9, v10, v11, v12, v13, v14);
  uint64_t v23 = *(void *)v15;
  if ((*(unsigned char *)(v15 + 356) & 0x40) != 0)
  {
    uint64_t v32 = BOMStorageReadFromBlock(v23, a3, v16, v17, v18, v19, v20, v21);
    if (!v32) {
      goto LABEL_22;
    }
    uint64_t v33 = (void *)v32;
    uint64_t v31 = BOMStreamWithAddress(v32, v22, 0);
    madvise(v33, v22, 3);
    if (!v31) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v31 = BOMStreamWithBlockID(v23, a3, v22, 0);
    if (!v31) {
      goto LABEL_22;
    }
  }
  if (BOMStreamReadUInt32(v31, v24, v25, v26, v27, v28, v29, v30) != 1953654117)
  {
    if (a2) {
      _CUILog(4, (uint64_t)"%s: '%s' is not a BOMTree", v35, v36, v37, v38, v39, v40, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
    }
    else {
      _CUILog(4, (uint64_t)"%s: '<Tree %d>' is not a BOMTree", v35, v36, v37, v38, v39, v40, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
    }
    goto LABEL_21;
  }
  if (BOMStreamReadUInt32(v31, v34, v35, v36, v37, v38, v39, v40) != 1)
  {
    if (a2) {
      _CUILog(4, (uint64_t)"%s: BOMTree '%s' has an unknown version: 0x%X", v42, v43, v44, v45, v46, v47, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
    }
    else {
      _CUILog(4, (uint64_t)"%s: BOMTree '<Tree %d>' has an unknown version: 0x%X", v42, v43, v44, v45, v46, v47, (uint64_t)"BOMTree _BOMTreeOpen(BOMStorage, const char *, BOMBlockID, Boolean)");
    }
LABEL_21:
    BOMStreamFree(v31, v99, v100, v101, v102, v103, v104, v105);
LABEL_22:
    BOMTreeFree(v15);
    return 0;
  }
  int UInt32 = BOMStreamReadUInt32(v31, v41, v42, v43, v44, v45, v46, v47);
  *(_DWORD *)(v15 + 304) = BOMStreamReadUInt32(v31, v49, v50, v51, v52, v53, v54, v55);
  *(_DWORD *)(v15 + 20) = BOMStreamReadUInt32(v31, v56, v57, v58, v59, v60, v61, v62);
  *(_DWORD *)(v15 + 356) = *(_DWORD *)(v15 + 356) & 0xFFFFFFFB | (4
                                                                * (BOMStreamReadUInt8(v31, v63, v64, v65, v66, v67, v68, v69) & 1));
  if (!BOMStreamAtEOF(v31, v70, v71, v72, v73, v74, v75, v76))
  {
    *(_DWORD *)(v15 + 348) = BOMStreamReadUInt32(v31, v77, v78, v79, v80, v81, v82, v83);
    if (!BOMStreamAtEOF(v31, v84, v85, v86, v87, v88, v89, v90)) {
      *(_DWORD *)(v15 + 352) = BOMStreamReadUInt32(v31, v77, v78, v79, v80, v81, v82, v83);
    }
  }
  BOMStreamFree(v31, v77, v78, v79, v80, v81, v82, v83);
  unsigned int v91 = *(_DWORD *)(v15 + 304) - 16;
  *(_DWORD *)(v15 + 308) = v91 >> 3;
  *(_DWORD *)(v15 + 312) = (v91 >> 3) + 1;
  *(_DWORD *)(v15 + 316) = v91 >> 4;
  uint64_t v92 = _NewPage(v15, UInt32);
  *(void *)(v15 + 24) = v92;
  if (!v92 || _ReadPage(v15, (uint64_t)v92, v93, v94, v95, v96, v97, v98)) {
    goto LABEL_22;
  }
  *(_DWORD *)(v15 + 356) = *(_DWORD *)(v15 + 356) & 0xFFFFFFFD | (2 * (a4 & 1));
  return v15;
}

void *_NewPage(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)a1;
  if ((*(unsigned char *)(a1 + 356) & 0x40) != 0)
  {
    uint64_t v8 = BOM_malloczero(0x28uLL);
    unint64_t v6 = 0;
    uint64_t result = 0;
    if (!v8) {
      return result;
    }
LABEL_8:
    if (!a2) {
      a2 = BOMStorageNewBlock(v3);
    }
    v8[3] = v6;
    *(_DWORD *)uint64_t v8 = a2;
    return v8;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 308);
  if (v4 <= *(_DWORD *)(a1 + 312)) {
    unsigned int v4 = *(_DWORD *)(a1 + 312);
  }
  uint64_t result = BOM_malloczero(8 * (v4 + 1));
  if (result)
  {
    unint64_t v6 = result;
    uint64_t v7 = BOM_malloczero(0x28uLL);
    if (!v7)
    {
      free(v6);
      return 0;
    }
    uint64_t v8 = v7;
    goto LABEL_8;
  }
  return result;
}

uint64_t _tocGet(uint64_t a1, const char *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 1096);
  if (!v4) {
    return 0;
  }
  size_t v5 = *(unsigned int *)(a1 + 1100);
  if (!v5) {
    return 0;
  }
  unint64_t v6 = (*(unsigned char *)(a1 + 1052) & 2) != 0
     ? (void *)BOMStreamWithAddress(*(void *)(a1 + 1040) + v4, *(unsigned int *)(a1 + 1100), 0)
     : BOMStreamWithFile(*(_DWORD *)(a1 + 1028), v4, v5, 0, 0);
  uint64_t v14 = (uint64_t)v6;
  if (!v6) {
    return 0;
  }
  int UInt32 = BOMStreamReadUInt32((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13);
  if (UInt32)
  {
    int v23 = UInt32;
    while (1)
    {
      uint64_t v24 = BOMStreamReadUInt32(v14, v16, v17, v18, v19, v20, v21, v22);
      unsigned int UInt8 = BOMStreamReadUInt8(v14, v25, v26, v27, v28, v29, v30, v31);
      BOMStreamReadBuffer(v14, __s2, UInt8, v33, v34, v35, v36, v37);
      __s2[UInt8] = 0;
      if (!strncmp(a2, __s2, 0xFFuLL)) {
        break;
      }
      if (!--v23) {
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    uint64_t v24 = 0;
  }
  BOMStreamFree(v14, v16, v17, v18, v19, v20, v21, v22);
  unsigned int v44 = *(_DWORD *)(a1 + 1068);
  if (v24 <= v44) {
    uint64_t v45 = v24;
  }
  else {
    uint64_t v45 = 0;
  }
  int v46 = *(_DWORD *)(a1 + 1052);
  if ((v46 & 2) != 0 && (v46 & 1) == 0 && v45)
  {
    uint64_t v47 = *(void *)(a1 + 1040);
    if (v44 <= v45)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v38, v39, v40, v41, v42, v43, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
      unsigned int v44 = *(_DWORD *)(a1 + 1068);
      uint64_t v48 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v48 = bswap32(*(_DWORD *)(*(void *)(a1 + 1072) + 8 * v45));
    }
    uint64_t v50 = (void *)(v47 + v48);
    if (v44 <= v45)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v38, v39, v40, v41, v42, v43, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
      size_t v53 = 0;
    }
    else
    {
      unsigned int v51 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * v45 + 4);
      unsigned int v52 = bswap32(v51);
      if (*(unsigned char *)(a1 + 1052)) {
        size_t v53 = v51;
      }
      else {
        size_t v53 = v52;
      }
    }
    madvise(v50, v53, 3);
    return v24;
  }
  return v45;
}

uint64_t BOMStreamReadUInt32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    uint64_t v9 = BOMExceptionHandlerMessage("%s read called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt32");
    int v10 = *__error();
    uint64_t v11 = v9;
    unsigned __int8 v12 = 0;
    int v13 = 272;
LABEL_5:
    _BOMExceptionHandlerCall(v11, v12, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v13, v10);
    unsigned int v17 = 0;
    goto LABEL_7;
  }
  uint64_t v14 = *(unsigned int **)(a1 + 56);
  uint64_t v15 = v14 + 1;
  if ((unint64_t)(v14 + 1) > *(void *)(a1 + 64))
  {
    uint64_t v16 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt32");
    int v10 = *__error();
    uint64_t v11 = v16;
    unsigned __int8 v12 = 1;
    int v13 = 274;
    goto LABEL_5;
  }
  unsigned int v17 = *v14;
  *(void *)(a1 + 56) = v15;
LABEL_7:
  unsigned int v18 = bswap32(v17);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v17;
  }
  else {
    return v18;
  }
}

uint64_t BOMStreamReadUInt8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    uint64_t v8 = BOMExceptionHandlerMessage("%s read called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt8");
    int v9 = *__error();
    int v10 = v8;
    unsigned __int8 v11 = 0;
    int v12 = 312;
  }
  else
  {
    int v13 = *(unsigned __int8 **)(a1 + 56);
    uint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) <= *(void *)(a1 + 64))
    {
      uint64_t v16 = *v13;
      *(void *)(a1 + 56) = v14;
      return v16;
    }
    uint64_t v15 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt8");
    int v9 = *__error();
    int v10 = v15;
    unsigned __int8 v11 = 1;
    int v12 = 314;
  }
  _BOMExceptionHandlerCall(v10, v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v12, v9);
  return 0;
}

uint64_t (*BOMStreamReadBuffer(uint64_t a1, void *__dst, size_t __len, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(void *)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    uint64_t v8 = BOMExceptionHandlerMessage("%s read called on read-only buffer", (uint64_t)__dst, __len, a4, a5, a6, a7, a8, (char)"BOMStreamReadBuffer");
    int v9 = *__error();
    int v10 = v8;
    unsigned __int8 v11 = 0;
    int v12 = 326;
  }
  else
  {
    uint64_t v15 = *(const void **)(a1 + 56);
    if (__CFADD__(__len, v15))
    {
      unsigned int v18 = BOMExceptionHandlerMessage("%s buffer overflow", (uint64_t)__dst, __len, a4, a5, a6, a7, a8, (char)"BOMStreamReadBuffer");
      int v9 = *__error();
      int v10 = v18;
      unsigned __int8 v11 = 1;
      int v12 = 338;
    }
    else
    {
      if ((unint64_t)v15 + __len <= *(void *)(a1 + 64))
      {
        uint64_t result = (uint64_t (*)(void *))memmove(__dst, v15, __len);
        *(void *)(a1 + 56) += __len;
        return result;
      }
      uint64_t v16 = BOMExceptionHandlerMessage("%s buffer overflow", (uint64_t)__dst, __len, a4, a5, a6, a7, a8, (char)"BOMStreamReadBuffer");
      int v9 = *__error();
      int v10 = v16;
      unsigned __int8 v11 = 1;
      int v12 = 341;
    }
  }
  return _BOMExceptionHandlerCall(v10, v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v12, v9);
}

uint64_t _ReadPage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)a2;
  uint64_t v17 = BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = *(void *)a1;
  if ((*(unsigned char *)(a1 + 356) & 0x40) != 0)
  {
    uint64_t v27 = BOMStorageReadFromBlock(v18, v10, v11, v12, v13, v14, v15, v16);
    if (!v27) {
      return 1;
    }
    uint64_t v28 = (void *)v27;
    uint64_t v26 = BOMStreamWithAddress(v27, v17, 0);
    madvise(v28, v17, 3);
    if (!v26) {
      return 1;
    }
  }
  else
  {
    uint64_t v26 = BOMStreamWithBlockID(v18, v10, v17, 0);
    if (!v26) {
      return 1;
    }
  }
  *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 4) & 0xFFFE | (BOMStreamReadUInt16(v26, v19, v20, v21, v22, v23, v24, v25) != 0);
  *(_WORD *)(a2 + 16) = BOMStreamReadUInt16(v26, v29, v30, v31, v32, v33, v34, v35);
  *(_DWORD *)(a2 + 8) = BOMStreamReadUInt32(v26, v36, v37, v38, v39, v40, v41, v42);
  *(_DWORD *)(a2 + 12) = BOMStreamReadUInt32(v26, v43, v44, v45, v46, v47, v48, v49);
  uint64_t v57 = *(unsigned __int16 *)(a2 + 16);
  if (*(_DWORD *)(a1 + 308) < v57)
  {
    uint64_t v77 = BOMExceptionHandlerMessage("(tree (%s) page->numKeys(%d) > tree->maxKeys(%d)", v50, v51, v52, v53, v54, v55, v56, *(void *)(a1 + 8));
    uint64_t v78 = __error();
    _BOMFatalException(v77, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 1329, *v78);
  }
  if ((*(unsigned char *)(a1 + 356) & 0x40) != 0)
  {
    *(void *)(a2 + 24) = BOMStreamGetDataPointer(v26, (8 * v57) | 4);
  }
  else
  {
    if (*(_WORD *)(a2 + 16))
    {
      uint64_t v58 = 0;
      unint64_t v59 = 0;
      do
      {
        *(_DWORD *)(*(void *)(a2 + 24) + v58) = BOMStreamReadUInt32(v26, v50, v51, v52, v53, v54, v55, v56);
        *(_DWORD *)(*(void *)(a2 + 24) + v58 + 4) = BOMStreamReadUInt32(v26, v60, v61, v62, v63, v64, v65, v66);
        ++v59;
        v58 += 8;
      }
      while (v59 < *(unsigned __int16 *)(a2 + 16));
    }
    *(_DWORD *)(*(void *)(a2 + 24) + 8 * *(unsigned __int16 *)(a2 + 16)) = BOMStreamReadUInt32(v26, v50, v51, v52, v53, v54, v55, v56);
  }
  if ((*(_DWORD *)(a1 + 356) & 0x44) == 0x40 && (int v75 = *(_DWORD *)(a1 + 348), v75 >= 1)) {
    uint64_t DataPointer = BOMStreamGetDataPointer(v26, v75 * (unint64_t)*(unsigned __int16 *)(a2 + 16));
  }
  else {
    uint64_t DataPointer = 0;
  }
  *(void *)(a2 + 32) = DataPointer;
  BOMStreamFree(v26, v67, v68, v69, v70, v71, v72, v73);
  return 0;
}

uint64_t BOMStreamReadUInt16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v9 = BOMExceptionHandlerMessage("%s read called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt16");
    int v10 = *__error();
    uint64_t v11 = v9;
    unsigned __int8 v12 = 0;
    int v13 = 292;
LABEL_5:
    _BOMExceptionHandlerCall(v11, v12, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v13, v10);
    unsigned int v17 = 0;
    goto LABEL_7;
  }
  uint64_t v14 = *(unsigned __int16 **)(a1 + 56);
  uint64_t v15 = v14 + 1;
  if ((unint64_t)(v14 + 1) > *(void *)(a1 + 64))
  {
    uint64_t v16 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamReadUInt16");
    int v10 = *__error();
    uint64_t v11 = v16;
    unsigned __int8 v12 = 1;
    int v13 = 294;
    goto LABEL_5;
  }
  unsigned int v17 = *v14;
  *(void *)(a1 + 56) = v15;
LABEL_7:
  unsigned int v18 = __rev16(v17);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v17;
  }
  else {
    return v18;
  }
}

uint64_t BOMStreamFree(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if ((*(unsigned char *)(result + 80) & 2) != 0 && BOMStreamFlush((int *)result, a2, a3, a4, a5, a6, a7, a8))
    {
      return 1;
    }
    else
    {
      int v9 = *(void **)(v8 + 48);
      if (v9)
      {
        if (*(unsigned char *)(v8 + 80)) {
          free(v9);
        }
      }
      free((void *)v8);
      return 0;
    }
  }
  return result;
}

uint64_t BOMStreamWithAddress(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v6 = BOM_malloczero(0x58uLL);
  uint64_t v14 = (uint64_t)v6;
  if (v6)
  {
    *unint64_t v6 = 0x100000002;
    v6[4] = a2;
    *((_DWORD *)v6 + 10) = a3;
    v6[6] = a1;
    *((unsigned char *)v6 + 80) &= ~1u;
    if (a2 < 0)
    {
      _CUILog(4, (uint64_t)"%s: stream invalid: overflow", v8, v9, v10, v11, v12, v13, (uint64_t)"BOMStreamWithAddress");
LABEL_7:
      BOMStreamFree(v14, v7, v8, v9, v10, v11, v12, v13);
      return 0;
    }
    v6[7] = a1;
    v6[8] = a1 + a2;
    if (!a2) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v15 = __error();
    strerror(*v15);
    _CUILog(4, (uint64_t)"%s malloc: %s", v16, v17, v18, v19, v20, v21, (uint64_t)"BOMStreamWithAddress");
  }
  return v14;
}

void *BOM_malloczero(size_t size)
{
  char v1 = size;
  unsigned int v2 = malloc_type_calloc(1uLL, size, 0x83655E9DuLL);
  if (v2)
  {
    __CFSetLastAllocationEventName();
  }
  else
  {
    uint64_t v3 = __error();
    strerror(*v3);
    uint64_t v11 = BOMExceptionHandlerMessage("BOM_malloczero: (%zd bytes) %s\n", v4, v5, v6, v7, v8, v9, v10, v1);
    uint64_t v12 = __error();
    _BOMExceptionHandlerCall(v11, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 37, *v12);
  }
  return v2;
}

uint64_t BOMStreamGetDataPointer(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = result + a2;
  return result;
}

BOOL BOMStreamAtEOF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 40))
  {
    uint64_t v9 = BOMExceptionHandlerMessage("%s Can't check EOF on a writeable stream", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamAtEOF");
    uint64_t v10 = __error();
    _BOMExceptionHandlerCall(v9, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", 353, *v10);
  }
  return *(void *)(a1 + 56) == *(void *)(a1 + 64);
}

void *_newBOMTree(uint64_t a1, const char *a2)
{
  uint64_t v4 = BOM_malloczero(0x168uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *uint64_t v4 = a1;
    if (BOMStorageMemoryMapped(a1)) {
      int v6 = (BOMStorageIsOpenForWriting(a1) == 0) << 6;
    }
    else {
      int v6 = 0;
    }
    unsigned int v14 = *((_DWORD *)v5 + 89) & 0xFFFFFFBF | v6;
    *((_DWORD *)v5 + 89) = v14;
    if (a2)
    {
      uint64_t v15 = strdup(a2);
      v5[1] = v15;
      *((_DWORD *)v5 + 89) = v14 & 0xFFFFFFDF | (32 * (v15 != a2));
    }
  }
  else
  {
    uint64_t v7 = __error();
    strerror(*v7);
    _CUILog(4, (uint64_t)"%s: malloc: %s creating tree '%s'", v8, v9, v10, v11, v12, v13, (uint64_t)"BOMTree _newBOMTree(BOMStorage, const char *)");
  }
  return v5;
}

BOOL BOMStorageMemoryMapped(BOOL result)
{
  if (result) {
    return (*(_DWORD *)(result + 1052) & 6) == 2;
  }
  return result;
}

uint64_t BOMStorageIsOpenForWriting(uint64_t result)
{
  if (result) {
    return *(unsigned char *)(result + 1052) & 1;
  }
  return result;
}

void *BOMTreeIteratorNew(uint64_t a1, void *a2, unint64_t a3, BOOL *a4)
{
  uint64_t v8 = BOM_malloczero(0x40uLL);
  uint64_t v13 = v8;
  if (!v8) {
    return v13;
  }
  *uint64_t v8 = a1;
  BOMTreeIteratorSet((uint64_t)v8, a2, a3, a4, v9, v10, v11, v12);
  CFArrayRef v14 = *(const __CFArray **)(a1 + 296);
  if (!v14)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(void *)(a1 + 296) = Mutable;
    if (!Mutable)
    {
      uint64_t v19 = __error();
      _BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2679, *v19);
      goto LABEL_8;
    }
    goto LABEL_6;
  }
  CFIndex v15 = BOMCFArrayMaxRange(v14);
  CFIndex v17 = v16;
  v21.location = v15;
  v21.length = v17;
  if (!CFArrayContainsValue(*(CFArrayRef *)(a1 + 296), v21, v13))
  {
    Mutable = *(__CFArray **)(a1 + 296);
LABEL_6:
    CFArrayAppendValue(Mutable, v13);
  }
LABEL_8:
  if ((*(unsigned char *)(*v13 + 356) & 4) == 0) {
    v13[3] = BOM_malloc(v13[4]);
  }
  v13[5] = BOM_malloc(v13[6]);
  return v13;
}

void *BOM_malloc(size_t a1)
{
  char v1 = a1;
  unsigned int v2 = malloc_type_malloc(a1, 0x1607F7D5uLL);
  if (v2)
  {
    __CFSetLastAllocationEventName();
  }
  else
  {
    uint64_t v3 = __error();
    strerror(*v3);
    uint64_t v11 = BOMExceptionHandlerMessage("BOM_malloc: (%zd bytes) %s\n", v4, v5, v6, v7, v8, v9, v10, v1);
    uint64_t v12 = __error();
    _BOMExceptionHandlerCall(v11, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 24, *v12);
  }
  return v2;
}

_DWORD *BOMTreeIteratorSet(uint64_t a1, void *__s1, unint64_t a3, BOOL *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 57) &= 0xF6u;
  uint64_t result = (_DWORD *)_findPagesForKey(*(void *)a1, 0, __s1, a3, a5, a6, a7, a8);
  *(void *)(a1 + 8) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 16) = *result;
    uint64_t result = (_DWORD *)_findIndexForKey(*(void *)a1, (uint64_t)result, __s1, a3, a4, v13, v14, v15);
    *(_DWORD *)(a1 + 20) = result;
    *(unsigned char *)(a1 + 56) = 1;
    uint64_t v22 = *(void *)(a1 + 8);
    if (result >= *(unsigned __int16 *)(v22 + 16))
    {
      *(_DWORD *)(a1 + 20) = 0;
      int v23 = *(_DWORD *)(v22 + 8);
      if (!v23
        || (*(_DWORD *)(a1 + 16) = v23,
            uint64_t result = _findPage(*(void *)a1, v23, v16, v17, v18, v19, v20, v21),
            (*(void *)(a1 + 8) = result) == 0))
      {
        *(unsigned char *)(a1 + 57) |= 8u;
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 57) |= 8u;
    *(unsigned char *)(a1 + 56) = 0;
  }
  return result;
}

void BOMTreeIteratorFree(unsigned char *a1)
{
  if (a1)
  {
    char v2 = a1[57];
    a1[56] = 0;
    char v3 = v2 | 9;
    a1[57] = v3;
    uint64_t v4 = (void *)*((void *)a1 + 3);
    if (v4 && (*(unsigned char *)(*(void *)a1 + 356) & 4) == 0)
    {
      free(v4);
      *((void *)a1 + 3) = 0;
      char v3 = a1[57];
    }
    char v5 = v3 & 0xFD;
    a1[57] = v5;
    uint64_t v6 = (void *)*((void *)a1 + 5);
    if (v6)
    {
      free(v6);
      *((void *)a1 + 5) = 0;
      char v5 = a1[57];
    }
    a1[57] = v5 & 0xFB;
    *((_DWORD *)a1 + 4) = -1;
    *((void *)a1 + 1) = 0;
    uint64_t v7 = *(void *)a1;
    CFArrayRef v8 = *(const __CFArray **)(*(void *)a1 + 296);
    if (v8)
    {
      CFIndex v9 = BOMCFArrayMaxRange(v8);
      CFIndex v11 = v10;
      v14.location = v9;
      v14.length = v11;
      CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v7 + 296), v14, a1);
      if (FirstIndexOfValue != -1)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v7 + 296), FirstIndexOfValue);
        if (!CFArrayGetCount(*(CFArrayRef *)(v7 + 296)))
        {
          CFRelease(*(CFTypeRef *)(v7 + 296));
          *(void *)(v7 + 296) = 0;
        }
      }
    }
    free(a1);
  }
}

uint64_t BOMCFArrayMaxRange(const __CFArray *a1)
{
  return 0;
}

BOOL CUIRenditionKeyHasIdentifier(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  char v3 = (int *)(a1 + 12);
  for (uint64_t i = 0xFFFFFFFFLL; ; --i)
  {
    int v5 = *v3++;
    if (v5 == a2) {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return i != 0;
}

uint64_t _revalidateIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 57))
  {
    uint64_t PagesForKey = _findPagesForKey(*(void *)a1, 0, *(void **)(a1 + 24), *(void *)(a1 + 32), a5, a6, a7, a8);
    *(void *)(a1 + 8) = PagesForKey;
    if (!PagesForKey)
    {
      *(unsigned char *)(a1 + 57) |= 1u;
      goto LABEL_12;
    }
    int IndexForKey = _findIndexForKey(*(void *)a1, PagesForKey, *(void **)(a1 + 24), *(void *)(a1 + 32), (BOOL *)(a1 + 56), v12, v13, v14);
    Page = *(void **)(a1 + 8);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)Page;
    *(_DWORD *)(a1 + 20) = IndexForKey;
    *(unsigned char *)(a1 + 57) &= ~1u;
    goto LABEL_9;
  }
  Page = *(void **)(a1 + 8);
  if (!Page)
  {
    int v10 = *(_DWORD *)(a1 + 16);
LABEL_8:
    Page = _findPage(*(void *)a1, v10, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 8) = Page;
    if (!Page) {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
  int v10 = *(_DWORD *)(a1 + 16);
  if (*(_DWORD *)Page != v10) {
    goto LABEL_8;
  }
LABEL_9:
  if (*(_DWORD *)(a1 + 20) < *((unsigned __int16 *)Page + 8)) {
    return 1;
  }
LABEL_12:
  uint64_t result = 0;
  *(unsigned char *)(a1 + 57) |= 1u;
  return result;
}

void sub_1A12FED58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A13013FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1A13016B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t _CUIColorGetSRGBWhite()
{
  if (_CUIColorGetSRGBWhite_onceToken != -1) {
    dispatch_once(&_CUIColorGetSRGBWhite_onceToken, &__block_literal_global_37);
  }
  return _CUIColorGetSRGBWhite_sWhiteColor;
}

uint64_t _CUIColorSpaceGetDisplayP3()
{
  if (_CUIColorSpaceGetDisplayP3___once != -1) {
    dispatch_once(&_CUIColorSpaceGetDisplayP3___once, &__block_literal_global_15);
  }
  return _CUIColorSpaceGetDisplayP3_sDisplayP3ColorSpace;
}

void sub_1A1303308()
{
}

int8x16_t _extractMetrics(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, int8x16_t *a6, void *a7, double *a8, int8x16_t *a9, double *a10, int8x16_t *a11)
{
  if (a2)
  {
    if (a1)
    {
      if (a3)
      {
        if (a4)
        {
          int v11 = *(_DWORD *)(a1 + 4);
          int v12 = *(_DWORD *)(a1 + 8);
          int v13 = *(_DWORD *)(a1 + 12);
          int v14 = *(_DWORD *)(a1 + 16);
          int v15 = *(_DWORD *)(a1 + 20);
          int v16 = *(_DWORD *)(a1 + 24);
          *a3 = (double)v11;
          a3[1] = (double)v14;
          *a4 = (double)v13;
          a4[1] = (double)v12;
          *(double *)result.i64 = (double)(v13 + v11 + v15);
          *(void *)a2 = result.i64[0];
          *(double *)(a2 + 8) = (double)(v14 + v12 + v16);
          if (a6)
          {
            if (a5)
            {
              unsigned int v18 = *(_DWORD *)a1;
              if (*(_DWORD *)a1 >= 2u)
              {
                double v19 = (double)*(int *)(a1 + 40);
                *a5 = (double)*(int *)(a1 + 28);
                a5[1] = v19;
                uint64_t v20 = *(void *)(a1 + 32);
                v21.i64[0] = (int)v20;
                v21.i64[1] = SHIDWORD(v20);
                int8x16_t v22 = (int8x16_t)vcvtq_f64_s64(v21);
                int8x16_t result = vextq_s8(v22, v22, 8uLL);
                *a6 = result;
                if (a7)
                {
                  if (v18 >= 3)
                  {
                    *(double *)result.i64 = *(double *)(a2 + 8) - (double)*(int *)(a1 + 56);
                    *a7 = result.i64[0];
                    if (a9)
                    {
                      if (a8)
                      {
                        if (v18 >= 4)
                        {
                          double v23 = (double)*(int *)(a1 + 88);
                          *a8 = (double)*(int *)(a1 + 76);
                          a8[1] = v23;
                          uint64_t v24 = *(void *)(a1 + 80);
                          v25.i64[0] = (int)v24;
                          v25.i64[1] = SHIDWORD(v24);
                          int8x16_t v26 = (int8x16_t)vcvtq_f64_s64(v25);
                          int8x16_t result = vextq_s8(v26, v26, 8uLL);
                          *a9 = result;
                          if (a11)
                          {
                            if (a10)
                            {
                              if (v18 >= 5)
                              {
                                double v27 = (double)*(int *)(a1 + 112);
                                *a10 = (double)*(int *)(a1 + 100);
                                a10[1] = v27;
                                uint64_t v28 = *(void *)(a1 + 104);
                                v29.i64[0] = (int)v28;
                                v29.i64[1] = SHIDWORD(v28);
                                int8x16_t v30 = (int8x16_t)vcvtq_f64_s64(v29);
                                int8x16_t result = vextq_s8(v30, v30, 8uLL);
                                *a11 = result;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _CUIColorSpaceGetSRGB()
{
  if (_CUIColorSpaceGetSRGB___once != -1) {
    dispatch_once(&_CUIColorSpaceGetSRGB___once, &__block_literal_global_3);
  }
  return _CUIColorSpaceGetSRGB_sSRGBColorSpace;
}

CFDataRef __compress_data_stream(const __CFData *a1, compression_stream_operation a2)
{
  unint64_t Length = CFDataGetLength(a1);
  size_t v5 = Length;
  if (a2 == COMPRESSION_STREAM_DECODE && !(Length >> 14))
  {
    uint64_t v6 = 2 * Length;
    uint64_t v7 = (uint8_t *)malloc_type_malloc(2 * Length, 0x977FF6F5uLL);
    __CFSetLastAllocationEventName();
    BytePtr = CFDataGetBytePtr(a1);
    size_t v9 = compression_decode_buffer(v7, 2 * v5, BytePtr, v5, 0, COMPRESSION_LZFSE);
    if (v9 && v9 != v6)
    {
      return CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v7, v9, kCFAllocatorMalloc);
    }
    free(v7);
  }
  memset(&v19, 0, sizeof(v19));
  compression_status v11 = compression_stream_init(&v19, a2, COMPRESSION_LZFSE);
  CFDataRef result = 0;
  if (v11 == COMPRESSION_STATUS_OK)
  {
    v19.size_t src_size = v5;
    int v12 = CFDataGetBytePtr(a1);
    BOOL v13 = a2 == COMPRESSION_STREAM_DECODE;
    BOOL v14 = a2 != COMPRESSION_STREAM_DECODE;
    v19.src_ptr = v12;
    if (v13) {
      size_t src_size = v19.src_size;
    }
    else {
      size_t src_size = v19.src_size >> 2;
    }
    int v16 = malloc_type_malloc(src_size, 0x68E2A627uLL);
    __CFSetLastAllocationEventName();
    uint64_t v17 = 0;
    while (1)
    {
      if ((unint64_t)v17 >= src_size)
      {
        src_size += src_size >> 1;
        int v16 = reallocf(v16, src_size);
        __CFSetLastAllocationEventName();
      }
      v19.dst_ptr = &v17[(void)v16];
      v19.dst_size = src_size - (void)v17;
      compression_status v18 = compression_stream_process(&v19, v14);
      if (v18 == COMPRESSION_STATUS_ERROR) {
        break;
      }
      uint64_t v17 = (uint8_t *)(v19.dst_ptr - (uint8_t *)v16);
      if (v18 == COMPRESSION_STATUS_END)
      {
        compression_stream_destroy(&v19);
        return CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)v16, (CFIndex)v17, kCFAllocatorMalloc);
      }
    }
    free(v16);
    compression_stream_destroy(&v19);
    return 0;
  }
  return result;
}

CFDataRef CUIUncompressDataWithLZFSE(const __CFData *a1)
{
  return __compress_data_stream(a1, COMPRESSION_STREAM_DECODE);
}

void __csiImageBlockRelease(id a1)
{
  if (a1 && !*((unsigned char *)a1 + 176)) {
    *((unsigned char *)a1 + 176) = 1;
  }
}

double CGPathCubicLength(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  *(double *)&v16[0].v = a1;
  double v17 = a2;
  *(double *)&v14[0].v = a3;
  double v15 = a4;
  *(double *)&v12[0].v = a5;
  double v13 = a6;
  *(double *)&v10[0].v = a7;
  double v11 = a8;
  CG::Cubic::Cubic((CG::Cubic *)v9, v16, v14, v12, v10);
  return CG::Cubic::length((CG::Cubic *)v9, 0.5);
}

double CG::Cubic::length(CG::Cubic *this, double a2)
{
  return cube::length(this, *(double *)this, *((double *)this + 1), *((double *)this + 2), *((double *)this + 3), *((double *)this + 4), *((double *)this + 5), *((double *)this + 6), *((double *)this + 7), a2);
}

double cube::length(cube *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v10 = (a5 - a3) * (a5 - a3) + (a4 - a2) * (a4 - a2);
  double v11 = (a9 - a7) * (a9 - a7) + (a8 - a6) * (a8 - a6);
  double v12 = 3.40282347e38;
  double v13 = 3.40282347e38;
  if (v10 > 0.0) {
    double v13 = 1.0 / sqrt(v10);
  }
  double v14 = v10 * v13;
  if (v11 > 0.0) {
    double v12 = 1.0 / sqrt(v11);
  }
  double v15 = v11 * v12;
  uint64_t v16 = fabs(v14 + v11 * v12);
  double v17 = 0.0;
  if (v16 <= 0x7FEFFFFFFFFFFFFFLL)
  {
    LODWORD(v18) = 0;
    uint64_t v19 = 1024;
    double v20 = 1.0;
    do
    {
      double v21 = (a7 - a5) * (a7 - a5) + (a6 - a4) * (a6 - a4);
      double v22 = 3.40282347e38;
      if (v21 > 0.0) {
        double v22 = 1.0 / sqrt(v21);
      }
      double v23 = (a9 - a3) * (a9 - a3) + (a8 - a2) * (a8 - a2);
      double v24 = 3.40282347e38;
      if (v23 > 0.0) {
        double v24 = 1.0 / sqrt(v23);
      }
      double v25 = v15 + v14 + v21 * v22;
      if (v25 - v23 * v24 > v20 * a10 && (int)v18 < 29)
      {
        double v20 = v20 * 0.5;
        *(double *)&v30[(int)v18] = v20;
        *(double *)&v30[(int)v18 + 203] = a8;
        *(double *)&v30[(int)v18 + 29] = a9;
        *(double *)&v30[(int)v18 + 232] = (a6 + a8) * 0.5;
        *(double *)&v30[(int)v18 + 58] = (a7 + a9) * 0.5;
        *(double *)&v30[(int)v18 + 261] = (a8 + a4 + a6 * 2.0) * 0.25;
        *(double *)&v30[(int)v18 + 87] = (a9 + a5 + a7 * 2.0) * 0.25;
        a8 = (a8 + a2 + (a6 + a4) * 3.0) * 0.125;
        *(double *)&v30[(int)v18 + 290] = a8;
        a9 = (a9 + a3 + (a7 + a5) * 3.0) * 0.125;
        *(double *)&v30[(int)v18 + 116] = a9;
        a6 = (a6 + a2 + a4 * 2.0) * 0.25;
        *(double *)&v30[(int)v18 + 145] = v15 * 0.5;
        a7 = (a7 + a3 + a5 * 2.0) * 0.25;
        double v27 = (a9 - a7) * (a9 - a7) + (a8 - a6) * (a8 - a6);
        if (v27 <= 0.0) {
          double v28 = 3.40282347e38;
        }
        else {
          double v28 = 1.0 / sqrt(v27);
        }
        a4 = (a4 + a2) * 0.5;
        a5 = (a5 + a3) * 0.5;
        double v14 = v14 * 0.5;
        double v15 = v27 * v28;
        *(double *)&v30[(int)v18 + 174] = v15;
        LODWORD(v18) = v18 + 1;
      }
      else
      {
        double v17 = v17 + (v25 + v23 * v24) * 0.5;
        if (!v18) {
          return v17;
        }
        uint64_t v18 = (int)v18 - 1;
        a2 = *(double *)&v30[v18 + 290];
        a3 = *(double *)&v30[v18 + 116];
        a4 = *(double *)&v30[v18 + 261];
        a5 = *(double *)&v30[v18 + 87];
        a6 = *(double *)&v30[v18 + 232];
        a7 = *(double *)&v30[v18 + 58];
        a8 = *(double *)&v30[v18 + 203];
        a9 = *(double *)&v30[v18 + 29];
        double v14 = *(double *)&v30[v18 + 174];
        double v15 = *(double *)&v30[v18 + 145];
        double v20 = *(double *)&v30[v18];
      }
      --v19;
    }
    while (v19);
    return 1.0;
  }
  return v17;
}

float64x2_t CG::Cubic::Cubic(CG::Cubic *this, const Point *a2, const Point *a3, const Point *a4, const Point *a5)
{
  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  *((_OWORD *)this + 3) = *(_OWORD *)&a5->v;
  float64x2_t v5 = *((float64x2_t *)this + 1);
  float64x2_t v6 = vsubq_f64(v5, *(float64x2_t *)this);
  *((double *)this + 8) = 3.0 * v6.f64[0];
  *((double *)this + 9) = vmuld_lane_f64(3.0, v6, 1);
  float64x2_t v7 = *((float64x2_t *)this + 2);
  float64x2_t v8 = *((float64x2_t *)this + 3);
  float64x2_t v9 = vsubq_f64(v7, v5);
  float64x2_t v10 = vsubq_f64(v9, v6);
  *((double *)this + 10) = 3.0 * v10.f64[0];
  *((double *)this + 11) = vmuld_lane_f64(3.0, v10, 1);
  float64x2_t result = vaddq_f64(v6, vsubq_f64(vsubq_f64(v8, v7), vaddq_f64(v9, v9)));
  *((float64x2_t *)this + 6) = result;
  return result;
}

double CGPathLineLength(double a1, double a2, double a3, double a4)
{
  return sqrt((a4 - a2) * (a4 - a2) + (a3 - a1) * (a3 - a1));
}

void sub_1A1307150(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 240), 8);
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1A1307B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __freeBitmapContextData(size_t a1, void *a2)
{
  if (munmap(a2, a1) < 0)
  {
    uint64_t v2 = __error();
    char v3 = strerror(*v2);
    _CUILog(4, (uint64_t)"CoreUI: CUICGBitmapContextCreate() munmap failed error:'%s'", v4, v5, v6, v7, v8, v9, (uint64_t)v3);
  }
}

NSMutableData *CUICreateClipStrokeKeyframeDataFromString(void *a1, float a2)
{
  id v3 = [a1 componentsSeparatedByString:@" "];
  float64x2_t result = (NSMutableData *)[v3 count];
  if (result)
  {
    unint64_t v5 = (unint64_t)result;
    if (objc_msgSend(objc_msgSend(v3, "firstObject"), "integerValue") || (((_BYTE)v5 - 1) & 3) != 0)
    {
      return 0;
    }
    else
    {
      uint64_t v6 = +[NSMutableData dataWithCapacity:v5 - 4];
      if (v5 >= 2)
      {
        for (unint64_t i = 1; i < v5; i += 4)
        {
          unsigned int v14 = 0;
          unsigned int v8 = objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i), "integerValue");
          int v13 = 0;
          unsigned int v14 = v8;
          objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i + 1), "floatValue");
          int v13 = v9;
          HIDWORD(v12) = 0;
          objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i + 2), "floatValue");
          *((float *)&v12 + 1) = v10 + a2;
          LODWORD(v12) = 0;
          objc_msgSend(objc_msgSend(v3, "objectAtIndexedSubscript:", i + 3, v12), "floatValue");
          *(float *)&uint64_t v12 = v11 + a2;
          -[NSMutableData appendBytes:length:](v6, "appendBytes:length:", &v14, 4, v12);
          [(NSMutableData *)v6 appendBytes:&v13 length:4];
          [(NSMutableData *)v6 appendBytes:(char *)&v12 + 4 length:4];
          [(NSMutableData *)v6 appendBytes:&v12 length:4];
        }
      }
      return v6;
    }
  }
  return result;
}

void sub_1A1308648(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A1308794(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t __resolvedDesignSystemForInputSystem(uint64_t result)
{
  if (!result)
  {
    unint64_t v1 = CUICurrentPlatform();
    if (v1 > 5) {
      return 1;
    }
    else {
      return qword_1A139EAD8[v1];
    }
  }
  return result;
}

void sub_1A1309C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t _CUIColorSpaceGetGrayGamma2_2()
{
  if (_CUIColorSpaceGetGrayGamma2_2___once != -1) {
    dispatch_once(&_CUIColorSpaceGetGrayGamma2_2___once, &__block_literal_global_9);
  }
  return _CUIColorSpaceGetGrayGamma2_2_sGenericGrayColorSpace;
}

void ____getDeviceTraits_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v9 = +[NSMutableArray array];
  id v10 = +[NSMutableArray array];
  uint64_t v11 = (void *)MGCopyAnswer();
  __getDeviceTraits___deviceIdiom = 0;
  __getDeviceTraits___deviceSubtype = 0;
  __getDeviceTraits___deviceDisplayGamut = 0;
  __getDeviceTraits___deviceMemoryClass = 0;
  __getDeviceTraits___deviceGraphicsClass = 0;
  uint64_t v18 = &OBJC_METACLASS___CUIStructuredThemeStore;
  __getDeviceTraits___deviceGraphicsFallbackOrder = 0;
  __getDeviceTraits___deviceSubtypeFallbackOrder = 0;
  if (!v11)
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: MGCopyAnswer returned nil", v12, v13, v14, v15, v16, v17, a9);
    return;
  }
  uint64_t v19 = v11;
  id v20 = [v11 objectForKey:@"ArtworkDeviceIdiom"];
  if ([v20 length])
  {
    double v27 = v19;
    double v28 = (const char *)[v20 UTF8String];
    int64x2_t v29 = "universal";
    if ("universal")
    {
      int8x16_t v30 = &gThemeIdioms;
      while (strcasecmp(v28, v29))
      {
        int64x2_t v29 = (const char *)v30[5];
        v30 += 3;
        if (!v29) {
          goto LABEL_7;
        }
      }
      uint64_t v31 = *v30;
      __getDeviceTraits___deviceIdiom = *v30;
    }
    else
    {
LABEL_7:
      uint64_t v31 = __getDeviceTraits___deviceIdiom;
    }
    uint64_t v19 = v27;
    if (!v31 && !strcasecmp(v28, "reality")) {
      __getDeviceTraits___deviceIdiom = 8;
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkDeviceIdiom' from MGCopyAnswer got '%@'", v21, v22, v23, v24, v25, v26, (uint64_t)v19);
  }
  id v32 = objc_msgSend(objc_msgSend(v19, "objectForKey:", @"ArtworkDeviceSubType"), "integerValue");
  __getDeviceTraits___deviceSubtype = (uint64_t)v32;
  if (__getDeviceTraits___deviceIdiom == 5) {
    CUIWatchSubTypeFallbackOrder((uint64_t)v32, v10);
  }
  objc_msgSend(v10, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 0));
  __getDeviceTraits___deviceSubtypeFallbackOrder = (uint64_t)v10;
  __getDeviceTraits___deviceMemoryClass = (uint64_t)objc_msgSend(objc_msgSend(v19, "objectForKey:", @"DevicePerformanceMemoryClass"), "integerValue");
  id v33 = [v19 objectForKey:@"ArtworkDisplayGamut"];
  if ([v33 length])
  {
    uint64_t v40 = (const char *)[v33 UTF8String];
    uint64_t v41 = "sRGB";
    if ("sRGB")
    {
      uint64_t v42 = v40;
      uint64_t v43 = &gThemeDisplayGamuts;
      while (strcasecmp(v42, v41))
      {
        uint64_t v41 = (const char *)v43[5];
        v43 += 3;
        if (!v41) {
          goto LABEL_26;
        }
      }
      __getDeviceTraits___deviceDisplayGamut = *v43;
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkDisplayGamut' from MGCopyAnswer got '%@'", v34, v35, v36, v37, v38, v39, (uint64_t)v19);
  }
LABEL_26:
  id v44 = [v19 objectForKey:@"GraphicsFeatureSetClass"];
  if (v44)
  {
    uint64_t v51 = v44;
    uint64_t v52 = (const char *)[v44 UTF8String];
    uint64_t v53 = "GLES2,0";
    if ("GLES2,0")
    {
      uint64_t v54 = &gThemeGraphicsFeatureSetClasses_Legacy;
      while (strcasecmp(v52, v53))
      {
        uint64_t v53 = (const char *)v54[5];
        v54 += 3;
        if (!v53) {
          goto LABEL_31;
        }
      }
    }
    else
    {
LABEL_31:
      uint64_t v55 = "GLES2,0";
      if (!"GLES2,0")
      {
LABEL_35:
        if ([v51 length]) {
          _CUILog(4, (uint64_t)"CoreUI: CUICatalog: Failed to parse value of 'kMGArtworkGraphicsFeatureSetClass' from MGCopyAnswer: '%@'", v56, v57, v58, v59, v60, v61, (uint64_t)v51);
        }
        goto LABEL_39;
      }
      uint64_t v54 = &gThemeGraphicsFeatureSetClasses;
      while (strcasecmp(v52, v55))
      {
        uint64_t v55 = (const char *)v54[5];
        v54 += 3;
        if (!v55) {
          goto LABEL_35;
        }
      }
    }
    __getDeviceTraits___deviceGraphicsClass = *v54;
    [v51 length];
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkGraphicsFeatureSetClass' from MGCopyAnswer got '%@'", v45, v46, v47, v48, v49, v50, (uint64_t)v19);
  }
LABEL_39:
  id v62 = [v19 objectForKey:@"GraphicsFeatureSetFallbacks"];
  if (v62 && (uint64_t v69 = v62, (unint64_t)[v62 length] >= 2))
  {
    uint64_t v96 = v19;
    uint64_t v97 = v69;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    id v70 = [v69 componentsSeparatedByString:@":"];
    id v71 = [v70 countByEnumeratingWithState:&v102 objects:v107 count:16];
    if (!v71) {
      goto LABEL_56;
    }
    id v72 = v71;
    char v73 = 0;
    uint64_t v74 = *(void *)v103;
    do
    {
      for (unint64_t i = 0; i != v72; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v103 != v74) {
          objc_enumerationMutation(v70);
        }
        uint64_t v76 = (const char *)[*(id *)(*((void *)&v102 + 1) + 8 * i) UTF8String];
        uint64_t v77 = "GLES2,0";
        if ("GLES2,0")
        {
          uint64_t v78 = v76;
          uint64_t v79 = &gThemeGraphicsFeatureSetClasses_Legacy;
          while (strcasecmp(v78, v77))
          {
            uint64_t v77 = (const char *)v79[5];
            v79 += 3;
            if (!v77) {
              goto LABEL_52;
            }
          }
          uint64_t v80 = *v79;
          objc_msgSend(v9, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *v79));
          v73 |= v80 > 0;
        }
LABEL_52:
        ;
      }
      id v72 = [v70 countByEnumeratingWithState:&v102 objects:v107 count:16];
    }
    while (v72);
    if ((v73 & 1) == 0 || ![v9 count])
    {
LABEL_56:
      [v9 removeAllObjects];
      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      id v81 = [v97 componentsSeparatedByString:@":"];
      id v82 = [v81 countByEnumeratingWithState:&v98 objects:v106 count:16];
      if (v82)
      {
        id v83 = v82;
        uint64_t v84 = *(void *)v99;
        do
        {
          for (j = 0; j != v83; j = (char *)j + 1)
          {
            if (*(void *)v99 != v84) {
              objc_enumerationMutation(v81);
            }
            uint64_t v86 = (const char *)[*(id *)(*((void *)&v98 + 1) + 8 * (void)j) UTF8String];
            uint64_t v87 = "GLES2,0";
            if ("GLES2,0")
            {
              uint64_t v88 = v86;
              uint64_t v89 = &gThemeGraphicsFeatureSetClasses;
              while (strcasecmp(v88, v87))
              {
                uint64_t v87 = (const char *)v89[5];
                v89 += 3;
                if (!v87) {
                  goto LABEL_67;
                }
              }
              objc_msgSend(v9, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", *v89));
            }
LABEL_67:
            ;
          }
          id v83 = [v81 countByEnumeratingWithState:&v98 objects:v106 count:16];
        }
        while (v83);
      }
    }
    uint64_t v18 = &OBJC_METACLASS___CUIStructuredThemeStore;
    uint64_t v19 = v96;
    if (![v9 count]) {
      _CUILog(4, (uint64_t)"CoreUI: CUICatalog: Failed to parse value of 'kMGArtworkGraphicsFeatureSetFallbacks' from MGCopyAnswer: '%@'", v90, v91, v92, v93, v94, v95, (uint64_t)v97);
    }
  }
  else
  {
    _CUILog(3, (uint64_t)"CoreUI: CUICatalog: couldn't get 'kMGArtworkGraphicsFeatureSetFallbacks' from MGCopyAnswer got '%@'", v63, v64, v65, v66, v67, v68, (uint64_t)v19);
  }

  if ([v9 count]) {
    v18[17].cache = v9;
  }
}

void sub_1A130A730(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A130AA04(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t CUIValidateIdiomSubtypes(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  switch(a1)
  {
    case 0:
    case 4:
    case 6:
    case 7:
      goto LABEL_2;
    case 1:
    case 2:
      uint64_t result = 1;
      if (v8 > 2419)
      {
        if (v8 <= 2731)
        {
          if (v8 > 2555)
          {
            if (v8 == 2556 || v8 == 2622 || v8 == 2688) {
              return result;
            }
          }
          else if (v8 == 2420 || v8 == 2436 || v8 == 2532)
          {
            return result;
          }
        }
        else if (v8 > 2867)
        {
          if (v8 == 2868 || v8 == 3024 || v8 == 32401) {
            return result;
          }
        }
        else
        {
          BOOL v12 = (unint64_t)(v8 - 2752) > 0x2C || ((1 << (v8 + 64)) & 0x100004000001) == 0;
          if (!v12 || v8 == 2732) {
            return result;
          }
        }
      }
      else if (v8 > 2159)
      {
        BOOL v13 = (unint64_t)(v8 - 2224) > 0x2A || ((1 << (v8 + 80)) & 0x40000000401) == 0;
        if (!v13
          || (unint64_t)(v8 - 2340) <= 0x30 && ((1 << (v8 - 36)) & 0x1000000100001) != 0
          || v8 == 2160)
        {
          return result;
        }
      }
      else if (v8 > 1664)
      {
        if (v8 == 1665 || v8 == 1792 || v8 == 1964) {
          return result;
        }
      }
      else if ((unint64_t)(v8 - 568) < 3 || v8 == 163)
      {
        return result;
      }
      goto LABEL_2;
    case 3:
      uint64_t result = 1;
      if (v8 == 720 || v8 == 1088 || v8 == 3840) {
        return result;
      }
      goto LABEL_2;
    case 5:
      uint64_t result = 1;
      if (v8 > 483)
      {
        if ((unint64_t)(v8 - 484) <= 0x12 && ((1 << (v8 + 28)) & 0x41001) != 0) {
          return result;
        }
      }
      else
      {
        BOOL v11 = (unint64_t)(v8 - 384) > 0x3E || ((1 << (v8 + 0x80)) & 0x4000400000000041) == 0;
        if (!v11 || v8 == 320 || v8 == 340) {
          return result;
        }
      }
LABEL_2:
      uint64_t v9 = 0;
      *a2 = 0;
LABEL_3:
      if (v9 == v8) {
        return 1;
      }
      _CUILog(4, (uint64_t)"CoreUI: %s passed a device subtype '%d' and idiom '%d':%s that are not a matching pair, subtype is not valid with given idiom. Assuming subtype should be 0 instead.", a3, a4, a5, a6, a7, a8, (uint64_t)"_Bool CUIValidateIdiomSubtypes(NSInteger, NSUInteger *)");
      return 0;
    case 8:
      if (v8 != 3648) {
        goto LABEL_2;
      }
      uint64_t v9 = 3648;
      goto LABEL_3;
    default:
      return 1;
  }
}

const char *CUIDefaultThemeRenditionKeyFormat(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 4:
      return "tmfk";
    case 2:
      if (a2 >= 6)
      {
        if (a2 >= 0xB)
        {
          if (a2 == 11)
          {
            return "tmfk";
          }
          else if (a2 >= 0xD)
          {
            if (a2 == 13)
            {
              return "tmfk";
            }
            else if (a2 >= 0xF)
            {
              if (a2 == 15)
              {
                return "tmfk";
              }
              else if (a2 >= 0x11)
              {
                return "tmfk";
              }
              else
              {
                return "tmfk";
              }
            }
            else
            {
              return "tmfk";
            }
          }
          else
          {
            return "tmfk";
          }
        }
        else
        {
          return "tmfk";
        }
      }
      else
      {
        return "tmfk";
      }
    case 1:
      uint64_t v9 = "tmfk";
      id v10 = "tmfk";
      if (a2 < 0xF) {
        id v10 = "tmfk";
      }
      if (a2 != 13) {
        uint64_t v9 = v10;
      }
      if (a2 >= 0xD) {
        return v9;
      }
      else {
        return "tmfk";
      }
    default:
      _CUILog(4, (uint64_t)"CoreUI: Unable to provide key format for custom theme semantics", a3, a4, a5, a6, a7, a8, v8);
      return 0;
  }
}

uint64_t CUICurrentPlatform()
{
  return 1;
}

unint64_t BOMTreeGetValue(uint64_t a1, void *__s1, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t result = 0;
  BOOL v36 = 0;
  if (a1 && __s1)
  {
    if (!a3 && (*(unsigned char *)(a1 + 356) & 4) == 0) {
      return 0;
    }
    unint64_t result = _findPagesForKey(a1, 0, __s1, a3, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    unint64_t v15 = result;
    int IndexForKey = _findIndexForKey(a1, result, __s1, a3, &v36, v12, v13, v14);
    if (!v36) {
      return 0;
    }
    int v23 = IndexForKey;
    unsigned int v24 = bswap32(*(_DWORD *)(*(void *)(v15 + 24) + 8 * IndexForKey));
    unsigned int v25 = (*(_DWORD *)(a1 + 356) & 0x40) != 0 ? v24 : *(_DWORD *)(*(void *)(v15 + 24) + 8 * IndexForKey);
    unint64_t result = BOMStorageSizeOfBlock(*(void *)a1, v25, v17, v18, v19, v20, v21, v22);
    if (result)
    {
      unint64_t v31 = result;
      id v32 = *(void **)(a1 + 320);
      if (v32)
      {
        if (result <= *(unsigned int *)(a1 + 328)) {
          goto LABEL_19;
        }
        free(*(void **)(a1 + 320));
        *(void *)(a1 + 320) = 0;
        unint64_t v33 = (2 * *(_DWORD *)(a1 + 328));
        if (v31 <= v33) {
          unint64_t result = v33;
        }
        else {
          unint64_t result = v31;
        }
        *(_DWORD *)(a1 + 328) = result;
      }
      else
      {
        *(_DWORD *)(a1 + 328) = result;
        unint64_t result = result;
      }
      id v32 = BOM_malloc(result);
      *(void *)(a1 + 320) = v32;
LABEL_19:
      unsigned int v34 = bswap32(*(_DWORD *)(*(void *)(v15 + 24) + 8 * v23));
      if ((*(_DWORD *)(a1 + 356) & 0x40) != 0) {
        unsigned int v35 = v34;
      }
      else {
        unsigned int v35 = *(_DWORD *)(*(void *)(v15 + 24) + 8 * v23);
      }
      if (!BOMStorageCopyFromBlock(*(void *)a1, v35, v32, v26, v27, v28, v29, v30)) {
        return *(void *)(a1 + 320);
      }
      return 0;
    }
  }
  return result;
}

void sub_1A130C504(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1A130C828(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1A130CE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A130CF34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A130D1C8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t CUIBitVectorSetBit(os_unfair_lock_s *a1, unsigned int a2)
{
  os_unfair_lock_lock(a1);
  if (a2 >> 5 >= a1[1]._os_unfair_lock_opaque)
  {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v4 = 1;
    a1[(a2 >> 5) + 2]._os_unfair_lock_opaque |= 1 << a2;
  }
  os_unfair_lock_unlock(a1);
  return v4;
}

uint64_t CUIBitVectorSetBitRange(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3)
{
  os_unfair_lock_lock(a1);
  if (a2 >= a3)
  {
LABEL_5:
    os_unfair_lock_unlock(a1);
    return 1;
  }
  else
  {
    uint32_t os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
    while (a2 >> 5 < os_unfair_lock_opaque)
    {
      a1[(a2 >> 5) + 2]._os_unfair_lock_opaque |= 1 << a2;
      if (a3 == ++a2) {
        goto LABEL_5;
      }
    }
    os_unfair_lock_unlock(a1);
    return 0xFFFFFFFFLL;
  }
}

_DWORD *CUIBitVectorCreate(unsigned int a1)
{
  if (a1 <= 1) {
    int v1 = 1;
  }
  else {
    int v1 = a1;
  }
  unsigned int v2 = ((v1 - 1) >> 5) + 1;
  id v3 = malloc_type_malloc(4 * v2 + 8, 0x7EDDED84uLL);
  bzero(v3, 4 * v2 + 8);
  __CFSetLastAllocationEventName();
  *id v3 = 0;
  v3[1] = v2;
  return v3;
}

void *CUIBitVectorCopy(unsigned int *a1)
{
  uint64_t v2 = a1[1];
  id v3 = malloc_type_malloc(4 * v2 + 8, 0x7EDDED84uLL);
  bzero(v3, 4 * v2 + 8);
  __CFSetLastAllocationEventName();
  *id v3 = 0;
  v3[1] = v2;
  size_t v4 = 4 * a1[1] + 8;
  return memcpy(v3, a1, v4);
}

void CUIBitVectorDestroy(os_unfair_lock_s *a1)
{
  if (a1)
  {
    os_unfair_lock_lock(a1);
    free(a1);
  }
}

uint64_t BOMTreeFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if ((*(unsigned char *)(result + 356) & 1) != 0 && BOMTreeCommit(result))
    {
      return 1;
    }
    else
    {
      for (uint64_t i = 32; i != 288; i += 8)
      {
        id v3 = *(_WORD **)(v1 + i);
        if (v3)
        {
          if ((v3[2] & 2) != 0) {
            _WritePage(v1, *(void *)(v1 + i));
          }
          _FreePage(v1, v3);
          *(void *)(v1 + i) = 0;
        }
      }
      _FreePage(v1, *(void **)(v1 + 24));
      *(void *)(v1 + 24) = 0;
      size_t v4 = *(void **)(v1 + 8);
      if (v4 && (*(unsigned char *)(v1 + 356) & 0x20) != 0)
      {
        free(v4);
        *(void *)(v1 + 8) = 0;
      }
      unint64_t v5 = *(const void **)(v1 + 296);
      if (v5)
      {
        CFRelease(v5);
        *(void *)(v1 + 296) = 0;
      }
      uint64_t v6 = *(void **)(v1 + 336);
      if (v6)
      {
        free(v6);
        *(void *)(v1 + 336) = 0;
      }
      uint64_t v7 = *(void **)(v1 + 320);
      if (v7) {
        free(v7);
      }
      free((void *)v1);
      return 0;
    }
  }
  return result;
}

void _FreePage(uint64_t a1, void *a2)
{
  if (a2)
  {
    *(_DWORD *)a2 = -1;
    *((void *)a2 + 1) = -1;
    *((void *)a2 + 4) = 0;
    if ((*(unsigned char *)(a1 + 356) & 0x40) == 0) {
      free(*((void **)a2 + 3));
    }
    free(a2);
  }
}

void sub_1A130E698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A130E778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id __PerformBlockWithThemeRefCache_block_invoke()
{
  id result = objc_alloc_init((Class)NSMutableDictionary);
  PerformBlockWithThemeRefCache___themeRefsByUniqueKey = (uint64_t)result;
  return result;
}

uint64_t __CUIVectorGlyphClipStrokeKeyframesAtom_block_invoke()
{
  uint64_t result = CGSVGAtomFromString();
  CUIVectorGlyphClipStrokeKeyframesAtom_atom = result;
  return result;
}

uint64_t __CUISVGNodeCanBeRepresentedAsPath_block_invoke(uint64_t result, uint64_t a2, int a3, unsigned char *a4)
{
  if (!a3)
  {
    uint64_t v5 = result;
    uint64_t result = CGSVGNodeGetType();
    if (result != 2)
    {
      if (result != 3) {
        return result;
      }
      goto LABEL_4;
    }
    CGSVGNodeGetAttributeMap();
    uint64_t result = CGSVGAttributeMapGetAttribute();
    if (result)
    {
      uint64_t result = CGSVGAttributeGetPaint();
      if (result)
      {
        uint64_t result = CGSVGPaintGetType();
        if ((int)result >= 1)
        {
LABEL_4:
          *(unsigned char *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = 0;
          *a4 = 1;
        }
      }
    }
  }
  return result;
}

__IOSurface *__csiCompressImageProviderCopyIOSurfaceWithOptions(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  int v5 = 1111970369;
  uint64_t v6 = (id *)(a1 + 48);
  uint64_t v7 = (unsigned __int16 *)[objc_loadWeak((id *)(a1 + 48)) key];
  CUIRenditionKeyValueForAttribute(v7, 17);
  CUIRenditionKeyValueForAttribute(v7, 1);
  CUIRenditionKeyValueForAttribute(v7, 2);
  kdebug_trace();
  unint64_t v15 = (const char *)[*(id *)(a1 + 24) bytes];
  int v48 = 0;
  int valuePtr = 1111970369;
  uint64_t v16 = *(void *)(a1 + 8);
  uint64_t v17 = *(void *)(a1 + 16);
  uint64_t v18 = *((unsigned int *)v15 + 3);
  int v19 = *((_DWORD *)v15 + 4);
  if (a3)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(a3, @"kCGImageSurfaceFormatRequest", (const void **)&value)) {
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    }
  }
  int v20 = *((_DWORD *)v15 + 6);
  int v48 = v20;
  int v21 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
  if (v21 == 12 || v21 == 7)
  {
    CUIUpdatePixelFormatForATECompressedData(&v48, v8, v9, v10, v11, v12, v13, v14);
    int v21 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
    int v20 = v48;
  }
  if (v21 == 5 && (v20 == 1195454774 || v20 == 1380401751))
  {
    uint64_t v24 = 0;
    int v48 = 1095911234;
    int v20 = 1095911234;
    if (valuePtr == 1111970369) {
      goto LABEL_62;
    }
    goto LABEL_44;
  }
  LOBYTE(v24) = valuePtr == 1111970369;
  if (v20 == 1095911234 && valuePtr == 1111970369) {
    goto LABEL_75;
  }
  if (v20 != 1380401751)
  {
    if (v20 == 1195456544 && valuePtr == 1279340600) {
      goto LABEL_30;
    }
    if (v20 == 1195454774)
    {
      unsigned int v27 = *((_DWORD *)v15 + 7);
      if ((v27 & 0xF) != 6 || valuePtr != 843264104)
      {
        BOOL v28 = (v27 & 0xF) == 3 && valuePtr == 843264310;
        BOOL v29 = v28;
        if (a3 && !v29) {
          goto LABEL_73;
        }
      }
      int v5 = 843264104;
      int v30 = v27 & 0xF;
      if (v30 == 2)
      {
        int v5 = 843264310;
      }
      else if (v30 != 6)
      {
        -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), @"CUIThemeRendition.m", 1558, @"CoreUI: %s No supported surface type for this gray colorspace: %d in rendition '%@'", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", *((_DWORD *)v15 + 7) & 0xF, [objc_loadWeak(v6) name]);
        goto LABEL_73;
      }
      uint64_t v24 = 5;
      goto LABEL_62;
    }
    goto LABEL_44;
  }
  unsigned int v26 = *((_DWORD *)v15 + 7);
  if ((v26 & 0xF) == 4 && valuePtr == 1380411457) {
    goto LABEL_50;
  }
  if ((v26 & 0xF) != 3)
  {
    int v20 = 1380401751;
LABEL_44:
    if (a3) {
      goto LABEL_73;
    }
    if (v20 > 1195456543)
    {
      if (v20 != 1195456544)
      {
        if (v20 != 1380401717)
        {
          if (v20 == 1380401751)
          {
            unsigned int v26 = *((_DWORD *)v15 + 7);
            goto LABEL_50;
          }
          goto LABEL_71;
        }
        uint64_t v44 = 6;
LABEL_72:
        -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), @"CUIThemeRendition.m", 1569, @"CoreUI: %s No supported surface type for this block pixel format: %d in rendition '%@'", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", v44, [objc_loadWeak(v6) name]);
        goto LABEL_73;
      }
LABEL_30:
      uint64_t v24 = 2;
      int v5 = 1279340600;
      goto LABEL_62;
    }
    if (v20 != 1095911234)
    {
LABEL_71:
      -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), @"CUIThemeRendition.m", 1528, @"CoreUI: %s unknown pixel format %d rendition '%@'", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", *((unsigned int *)v15 + 6), [objc_loadWeak(v6) name]);
      uint64_t v44 = 0xFFFFFFFFLL;
      goto LABEL_72;
    }
    if ((v24 & 1) == 0)
    {
      uint64_t v44 = 1;
      goto LABEL_72;
    }
LABEL_75:
    uint64_t v24 = 0;
    goto LABEL_62;
  }
  int v20 = 1380401751;
  if (valuePtr != 1815491698) {
    goto LABEL_44;
  }
LABEL_50:
  if ((v26 & 0xF) != 3)
  {
    if ((v26 & 0xF) == 4)
    {
      uint64_t v24 = 4;
      int v5 = 1380411457;
      goto LABEL_62;
    }
    -[NSAssertionHandler handleFailureInFunction:file:lineNumber:description:](+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"), "handleFailureInFunction:file:lineNumber:description:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)"), @"CUIThemeRendition.m", 1545, @"CoreUI: %s No supported surface type for this color space: %d in rendition '%@'", "IOSurfaceRef __CUIImageProviderCopyIOSurfaceWithOptions(void *, CGImageProviderRef, CFDictionaryRef)", *((_DWORD *)v15 + 7) & 0xF, [objc_loadWeak(v6) name]);
LABEL_73:
    id v32 = 0;
    goto LABEL_74;
  }
  int v5 = 1815491698;
  uint64_t v24 = 4;
LABEL_62:
  int v31 = __bppFromBlockPixelFormat(v24);
  id v32 = 0;
  if (__PAIR64__(v19, v18) == v17)
  {
    int v33 = v31;
    uint64_t v46 = v16;
    int AlignedBytesPerRow = CGBitmapGetAlignedBytesPerRow();
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceWidth, v18);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceHeight, v19);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceBytesPerElement, v33);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfaceBytesPerRow, AlignedBytesPerRow);
    __CUICFMutableDictAddInt32Property(Mutable, kIOSurfacePixelFormat, v5);
    id v32 = IOSurfaceCreate(Mutable);
    IOSurfaceSetValue(v32, kIOSurfaceName, @"CoreUI image IOSurface");
    CFRelease(Mutable);
    if (!IOSurfaceLock(v32, 0, 0))
    {
      BOOL v36 = [_CSIRenditionBlockData alloc];
      BaseAddress = IOSurfaceGetBaseAddress(v32);
      uint64_t v38 = -[_CSIRenditionBlockData initWithBytes:pixelWidth:pixelHeight:sourceRowbytes:pixelFormat:](v36, (uint64_t)BaseAddress, v18, v19, *(void *)(a1 + 112), v24);
      uint64_t v42 = v38;
      if (v38)
      {
        strlcpy((char *)v38 + 48, v15 + 40, 0x80uLL);
        v42[2] = *((_DWORD *)v15 + 6);
      }
      BOOL v43 = -[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:]((uint64_t)v42, *(const UInt8 **)(a1 + 32), v46, v17, 0, v39, v40, v41);

      IOSurfaceUnlock(v32, 0, 0);
      if (!v43)
      {
        CFRelease(v32);
        goto LABEL_73;
      }
    }
  }
LABEL_74:
  kdebug_trace();
  return v32;
}

void __CUICFMutableDictAddInt32Property(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

uint64_t __csiCompressImageProviderCopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  CFNumberRef v5 = (id *)(a1 + 48);
  CFNumberRef v6 = (unsigned __int16 *)[objc_loadWeak((id *)(a1 + 48)) key];
  CUIRenditionKeyValueForAttribute(v6, 17);
  uint64_t v7 = 1;
  CUIRenditionKeyValueForAttribute(v6, 1);
  CUIRenditionKeyValueForAttribute(v6, 2);
  kdebug_trace();
  uint64_t v8 = (const char *)[*(id *)(a1 + 24) bytes];
  if (a3)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(a3, kCGImageBlockFormatRequest, (const void **)&value)
      && CFEqual((CFStringRef)value, kCGImageBlockFormatBGRx8))
    {
      if (*((_DWORD *)v8 + 6) != 1095911234) {
        goto LABEL_42;
      }
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v7 = 1;
    }
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *((unsigned int *)v8 + 3);
  uint64_t v11 = *((unsigned int *)v8 + 4);
  unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 8) - 2;
  BOOL v14 = (v12 >= 0xA || ((0x3CFu >> v12) & 1) == 0) && (v10 != v9 || v11 != HIDWORD(v9));
  uint64_t v15 = *(void *)(a1 + 8);
  int v16 = *((_DWORD *)v8 + 6);
  if (v16 <= 1195456543)
  {
    if (v16 == 1095911234) {
      goto LABEL_25;
    }
    if (v16 == 1195454774)
    {
      uint64_t v7 = 5;
      goto LABEL_25;
    }
  }
  else
  {
    switch(v16)
    {
      case 1195456544:
        uint64_t v7 = 2;
        goto LABEL_25;
      case 1380401717:
        uint64_t v7 = 6;
        goto LABEL_25;
      case 1380401751:
        uint64_t v7 = 4;
        goto LABEL_25;
    }
  }
  BOOL v43 = +[NSAssertionHandler currentHandler];
  uint64_t v42 = +[NSString stringWithUTF8String:"CGImageBlockSetRef __CUIImageProviderCopyImageBlockSetWithOptions(void *, CGImageProviderRef, CGRect, CGSize, CFDictionaryRef)"];
  [objc_loadWeak(v5) name];
  uint64_t v41 = "CGImageBlockSetRef __CUIImageProviderCopyImageBlockSetWithOptions(void *, CGImageProviderRef, CGRect, CGSize, CFDictionaryRef)";
  [(NSAssertionHandler *)v43 handleFailureInFunction:v42 file:@"CUIThemeRendition.m" lineNumber:1335 description:@"CoreUI: %s unknown pixel format %d rendition '%@'"];
  uint64_t v7 = 0xFFFFFFFFLL;
LABEL_25:
  if (v14)
  {
    uint64_t v17 = -[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v9, SHIDWORD(v9), *(void *)(a1 + 112), v7);
    int v21 = v17;
    if (v17)
    {
      strlcpy((char *)v17 + 48, v8 + 40, 0x80uLL);
      v21[2] = *((_DWORD *)v8 + 6);
    }
    if (-[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:]((uint64_t)v21, *(const UInt8 **)(a1 + 32), v15, v9, 1, v18, v19, v20))
    {
LABEL_38:
      BOOL v28 = (void *)CGImageBlockCreate();
      if (!v28) {
        goto LABEL_41;
      }
LABEL_45:
      value = v28;
      uint64_t v39 = CGImageBlockSetCreate();
      goto LABEL_46;
    }
  }
  else
  {
    if (_CSIAcquireCachedBlockData(a1, v7))
    {
      if (v7 <= 2 && objc_loadWeak((id *)(a1 + 8 * v7 + 56)))
      {
        BOOL v28 = (void *)CGImageBlockCreate();
      }
      else
      {
        _CUILog(4, (uint64_t)"CoreUI: image data is not available, returning a 1,1 image instead that is all black", v22, v23, v24, v25, v26, v27, (uint64_t)v41);
        BOOL v28 = (void *)CGImageBlockCreate();
      }
      if (!v28) {
        goto LABEL_41;
      }
      goto LABEL_45;
    }
    __bppFromBlockPixelFormat(v7);
    unsigned int v35 = -[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v10, v11, *(void *)(a1 + 112), v7);
    int v21 = v35;
    if (v35)
    {
      strlcpy((char *)v35 + 48, v8 + 40, 0x80uLL);
      v21[2] = *((_DWORD *)v8 + 6);
    }
    if (-[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:]((uint64_t)v21, *(const UInt8 **)(a1 + 32), 0, v10 | (v11 << 32), 1, v36, v37, v38))
    {
      _CSIStoreBlockData(a1, v21, v7);
      goto LABEL_38;
    }
  }

LABEL_41:
  _CUILog(4, (uint64_t)"CoreUI: couldn't create block from blockData", v29, v30, v31, v32, v33, v34, (uint64_t)v41);
LABEL_42:
  uint64_t v39 = 0;
LABEL_46:
  kdebug_trace();
  return v39;
}

BOOL _CSIAcquireCachedBlockData(uint64_t a1, uint64_t a2)
{
  size_t v4 = (os_unfair_lock_s *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained)
  {
    os_unfair_lock_unlock(v4);
    return 0;
  }
  CFNumberRef v6 = WeakRetained;
  if (a2)
  {
    if (a2 == 1)
    {
      uint64_t v7 = 64;
    }
    else
    {
      if (a2 != 2) {
        goto LABEL_11;
      }
      uint64_t v7 = 72;
    }
    id v9 = objc_loadWeakRetained((id *)(a1 + v7));
    if (!v9)
    {
LABEL_11:
      id v9 = [v6 copySharedBlockDataWithPixelFormat:a2];
      if (a2 == 2)
      {
        uint64_t v10 = (id *)(a1 + 72);
      }
      else
      {
        if (a2 != 1)
        {
          if ((a2 - 7) <= 0xFFFFFFFB) {
            _CUILog(4, (uint64_t)"CUIThemeRendition %s called with bogus pixel format %d", v11, v12, v13, v14, v15, v16, (uint64_t)"BOOL _CSIAcquireCachedBlockData(CSIHelper *, enum CSIRenditionBlockPixelFormat)");
          }
          goto LABEL_16;
        }
        uint64_t v10 = (id *)(a1 + 64);
      }
      goto LABEL_15;
    }
  }
  else
  {
    id v9 = objc_loadWeakRetained((id *)(a1 + 56));
    if (!v9)
    {
      id v9 = [v6 copySharedBlockDataWithPixelFormat:0];
      uint64_t v10 = (id *)(a1 + 56);
LABEL_15:
      objc_storeWeak(v10, v9);
    }
  }
LABEL_16:

  os_unfair_lock_unlock(v4);
  return v9 != 0;
}

void sub_1A130FF68(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t CUIUncompressDeepmap2ImageData(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL buffer in [%s]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  if (!a4)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL destination in [%s]", a3, 0, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  unsigned int v10 = a3;
  uint64_t v12 = a1;
  if ((int)a8 > 1195456543)
  {
    if (a8 != 1195456544)
    {
      int v13 = 1380401751;
      goto LABEL_10;
    }
  }
  else if (a8 != 1095911234)
  {
    int v13 = 1195454774;
LABEL_10:
    if (a8 == v13) {
      goto LABEL_11;
    }
    _CUILog(4, (uint64_t)"CoreUI: %s got unsupported pixel format [%d]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
LABEL_11:
  uint64_t v40 = 0;
  uint64_t v41 = &v40;
  uint64_t v42 = 0x2020000000;
  char v43 = 1;
  if (a3)
  {
    uint64_t v14 = a1[3];
    a2 = a1[4];
    BOOL v33 = *a1 == 1262699075;
    id v15 = [objc_alloc((Class)NSMutableArray) initWithCapacity:a3];
    uint64_t v16 = v12;
    v12 += 5;
  }
  else
  {
    BOOL v33 = 0;
    id v15 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = a6;
  }
  unsigned int v17 = 0;
  unint64_t v18 = 0;
  if (v10 <= 1) {
    int v19 = 1;
  }
  else {
    int v19 = v10;
  }
  int v34 = v19 - 1;
  do
  {
    if (v10)
    {
      if (v17 >= v10) {
        [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"Boolean CUIUncompressDeepmap2ImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)"] file:@"CUIDeepmap2Compression.m" lineNumber:401 description:@"Invalid chunk index"];
      }
      if (!v16 || v14 - 1 >= a6)
      {
        _CUILog(4, (uint64_t)"CoreUI: Invalid chunk rows of %lu in image of height %lu", a3, a4, a5, a6, a7, a8, v14);
        if (!v15) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
    }
    if (*v12 >= 2)
    {
      _CUILog(4, (uint64_t)"CoreUI: Encoded Deepmap 2.0 blob version %lu greater than decoder version %lu", a3, a4, a5, a6, a7, a8, *v12);
      *((unsigned char *)v41 + 24) = 0;
      if (!v15) {
        goto LABEL_43;
      }
LABEL_42:

      goto LABEL_43;
    }
    unsigned int v20 = v12[1];
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472;
    v38[2] = __CUIUncompressDeepmap2ImageData_block_invoke;
    v38[3] = &unk_1E5A519D0;
    v38[6] = v14;
    v38[7] = a7;
    v38[8] = a4;
    v38[9] = v18;
    v38[10] = v12;
    v38[11] = v12;
    unsigned int v39 = v20;
    v38[4] = &v40;
    v38[5] = a5;
    if (!v10)
    {
      __CUIUncompressDeepmap2ImageData_block_invoke((uint64_t)v38);
      goto LABEL_38;
    }
    if (!v15) {
      id v15 = objc_alloc_init((Class)NSMutableArray);
    }
    id v21 = [v38 copy];
    [v15 addObject:v21];

    if (v34 == v17) {
      break;
    }
    uint64_t v22 = (char *)v16 + a2;
    uint64_t v16 = (unsigned int *)((char *)v16 + a2 + 20);
    unsigned int v23 = *((_DWORD *)v22 + 8);
    if (v33)
    {
      unsigned int v23 = bswap32(v23);
      unsigned int v24 = bswap32(v16[4]);
    }
    else
    {
      unsigned int v24 = v16[4];
    }
    v18 += v14;
    uint64_t v14 = v23;
    a2 = v24;
    uint64_t v12 = v16 + 5;
    ++v17;
  }
  while (v18 < a6);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __CUIUncompressDeepmap2ImageData_block_invoke_2;
  block[3] = &unk_1E5A519A8;
  block[4] = v15;
  dispatch_apply((size_t)[v15 count], 0, block);

LABEL_38:
  if (*((unsigned char *)v41 + 24))
  {
    uint64_t v31 = 1;
    goto LABEL_44;
  }
  _CUILog(4, (uint64_t)"CoreUI: CUIUncompressDeepmap2ImageData() fails [version %lu].", v25, v26, v27, v28, v29, v30, 1);
LABEL_43:
  uint64_t v31 = 0;
LABEL_44:
  _Block_object_dispose(&v40, 8);
  return v31;
}

void sub_1A1310378(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void __CUIUncompressDeepmap2ImageData_block_invoke(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 88) + 8) <= 0x100000uLL)
  {
    if (vImageDeepmap2Decode()) {
      return;
    }
    _CUILog(4, (uint64_t)"CoreUI: vImageDeepmap2Decode() returned 0.", v3, v4, v5, v6, v7, v8, v9);
  }
  else
  {
    int v2 = vImageDeepmap2DecodeStreamCreate();
    if (!v2)
    {
      while (v2 != -1)
      {
        if (v2)
        {
          if (v2 != 1) {
            __CUIUncompressDeepmap2ImageData_block_invoke_cold_1();
          }
          if (!vImageDeepmap2DecodeStreamRelease()) {
            return;
          }
          break;
        }
        int v2 = vImageDeepmap2DecodeStreamProcess();
      }
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
}

id _CSIStoreBlockData(uint64_t a1, void *a2, int a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  if (a3)
  {
    if (a3 == 1)
    {
      uint64_t v7 = 64;
    }
    else
    {
      if (a3 != 2)
      {
LABEL_14:
        [objc_loadWeak((id *)(a1 + 48)) setSharedBlockData:a2];
        id v10 = a2;
        goto LABEL_15;
      }
      uint64_t v7 = 72;
    }
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + v7));
    if (WeakRetained) {
      goto LABEL_9;
    }
    if (a3 == 2) {
      uint64_t v8 = (id *)(a1 + 72);
    }
    else {
      uint64_t v8 = (id *)(a1 + 64);
    }
LABEL_13:
    objc_storeWeak(v8, a2);
    goto LABEL_14;
  }
  uint64_t v8 = (id *)(a1 + 56);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (!WeakRetained) {
    goto LABEL_13;
  }
LABEL_9:

  id v10 = WeakRetained;
LABEL_15:
  id v11 = v10;
  os_unfair_lock_unlock(v6);
  return v11;
}

uint64_t __bppFromBlockPixelFormat(uint64_t a1)
{
  if (a1 < 7) {
    return dword_1A139EEB8[(int)a1];
  }
  [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"unsigned int __bppFromBlockPixelFormat(enum CSIRenditionBlockPixelFormat)"], @"CUIThemeRendition.m", 488, @"CoreUI: %s unknown pixel format %d", "unsigned int __bppFromBlockPixelFormat(enum CSIRenditionBlockPixelFormat)", a1 file lineNumber description];
  return 0;
}

void sub_1A1310DA0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1A13111F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A13112BC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t ____hardware_supports_encoding_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  __hardware_supports_encoding_supportsASTC = result;
  return result;
}

void sub_1A13115E8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1A13116B4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1A1311848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __csiImageProviderReleaseData(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));

  *(void *)(a1 + 24) = 0;
  uint64_t v1 = *(void **)(a1 + 88);
  if (v1) {
    [(id)+[_CSIRenditionBlockData sharedCache]() removeObjectForKey:v1];
  }

  *(void *)(a1 + 88) = 0;
  int v2 = *(void **)(a1 + 96);
  if (v2) {
    [(id)+[_CSIRenditionBlockData sharedCache]() removeObjectForKey:v2];
  }

  *(void *)(a1 + 96) = 0;
  uint64_t v3 = *(void **)(a1 + 104);
  if (v3) {
    [(id)+[_CSIRenditionBlockData sharedCache]() removeObjectForKey:v3];
  }

  *(void *)(a1 + 104) = 0;
  objc_storeWeak((id *)(a1 + 56), 0);
  objc_storeWeak((id *)(a1 + 64), 0);
  objc_storeWeak((id *)(a1 + 72), 0);
  objc_storeWeak((id *)(a1 + 48), 0);
}

os_log_t __CUILogHandle_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreui", "framework");
  __handle = (uint64_t)result;
  return result;
}

uint64_t __csiCopyImageTextureDataWithOptions(uint64_t a1)
{
  int v2 = (unsigned __int16 *)[objc_loadWeak((id *)(a1 + 48)) key];
  CUIRenditionKeyValueForAttribute(v2, 17);
  CUIRenditionKeyValueForAttribute(v2, 1);
  CUIRenditionKeyValueForAttribute(v2, 2);
  kdebug_trace();
  int v3 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
  if (__hardware_supports_encoding_onceToken != -1) {
    dispatch_once(&__hardware_supports_encoding_onceToken, &__block_literal_global_660);
  }
  if (v3 != 7 || __hardware_supports_encoding_supportsASTC == 0)
  {
    uint64_t v5 = 0;
  }
  else
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v7 = objc_alloc_init(CSIATECHelper);
    uint64_t v8 = CUIATECompressedDataFromBuffer(*(void *)(a1 + 32) + 16, *(_DWORD *)(*(void *)(a1 + 32) + 8), (int *)&v7->glInternalFormat, (int *)&v7->metalPixelFormat, &v7->width, &v7->height, &v7->rowbytes, &v7->twiddled);
    v7->data = (__CFData *)v8;
    if (v8)
    {
      __CUICFMutableDictAddInt32Property(Mutable, @"width", v7->width);
      __CUICFMutableDictAddInt32Property(Mutable, @"height", v7->height);
      __CUICFMutableDictAddInt32Property(Mutable, @"rowBytes", v7->rowbytes);
      __CUICFMutableDictAddInt32Property(Mutable, @"glInternalFormat", v7->glInternalFormat);
      __CUICFMutableDictAddInt32Property(Mutable, @"pixelFormatGL", v7->glInternalFormat);
      __CUICFMutableDictAddInt32Property(Mutable, @"pixelFormatMetal", v7->metalPixelFormat);
      __CUICFMutableDictAddInt32Property(Mutable, @"mipmapLevelCount", 1);
      __CUICFMutableDictAddInt32Property(Mutable, @"faceCount", 1);
      CFDictionaryAddValue(Mutable, @"supportsTiledLayout", v7->twiddled);
      ColorSpace = (const void *)CGImageProviderGetColorSpace();
      CFDictionaryAddValue(Mutable, @"colorSpace", ColorSpace);
      uint64_t v5 = CGImageTextureDataCreate();
    }
    else
    {

      uint64_t v5 = 0;
    }
    CFRelease(Mutable);
  }
  kdebug_trace();
  return v5;
}

void sub_1A1311DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _dense_deallocate(uint64_t a1)
{
  int v2 = *(void ***)a1;
  (*(void (**)(void))(a1 + 56))();
  free(*v2);
  free(v2);
  *(void *)a1 = 0;
}

void *_dense_clear(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v2 = *(_DWORD *)(*a1 + 16);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void **)(*(void *)v1 + 8 * i);
      *(void *)(*(void *)v1 + 8 * i) = 0;
      if (v4)
      {
        do
        {
          uint64_t v5 = (void *)*v4;
          free(v4);
          uint64_t v4 = v5;
        }
        while (v5);
        int v2 = *(_DWORD *)(v1 + 16);
      }
    }
  }
  os_log_t result = *(void **)(v1 + 8);
  *(void *)(v1 + 8) = 0;
  if (result)
  {
    do
    {
      uint64_t v7 = (void *)*result;
      free(result);
      os_log_t result = v7;
    }
    while (v7);
  }
  return result;
}

void _UnRegisterThemeRef(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = ___UnRegisterThemeRef_block_invoke;
  v1[3] = &__block_descriptor_40_e20_v16__0__NSMapTable_8l;
  v1[4] = a1;
  __PerformBlockWithThemeRegistry((uint64_t)v1);
}

uint64_t BomSys_munmap(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

uint64_t BOMStorageFree(unsigned char *a1)
{
  if (!a1) {
    return 1;
  }
  if ((a1[1052] & 0x10) != 0 && BOMStorageCommit((uint64_t)a1)) {
    return 1;
  }
  int v3 = (void *)*((void *)a1 + 134);
  if (v3)
  {
    if (a1[1052])
    {
      free(v3);
      uint64_t v4 = (void *)*((void *)a1 + 135);
      if (v4) {
        free(v4);
      }
    }
  }
  uint64_t v5 = (void (**)(void))*((void *)a1 + 136);
  if (v5)
  {
    v5[4](*((void *)a1 + 136));
    free(v5);
  }
  if (*((void *)a1 + 130))
  {
    if ((*((_DWORD *)a1 + 263) & 8) != 0)
    {
      int v6 = *((_DWORD *)a1 + 263) & 3;
      int v7 = (*(uint64_t (**)(void))(*((void *)a1 + 140) + 104))(*(void *)(*((void *)a1 + 140) + 8));
      if (v6 != 2 && v7 == -1)
      {
        uint64_t v8 = __error();
        _BOMExceptionHandlerCall("munmap failed", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1505, *v8);
      }
    }
  }
  if (*((_DWORD *)a1 + 257) != -1) {
    (*(void (**)(void))(*((void *)a1 + 140) + 24))(*(void *)(*((void *)a1 + 140) + 8));
  }
  uint64_t v9 = (void *)*((void *)a1 + 141);
  if (v9) {
    free(v9);
  }
  free(a1);
  return 0;
}

uint64_t CUIBitVectorUnSetBit(os_unfair_lock_s *a1, unsigned int a2)
{
  os_unfair_lock_lock(a1);
  if (a2 >> 5 >= a1[1]._os_unfair_lock_opaque)
  {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v4 = 1;
    a1[(a2 >> 5) + 2]._os_unfair_lock_opaque &= ~(1 << a2);
  }
  os_unfair_lock_unlock(a1);
  return v4;
}

uint64_t CUIBitVectorNumberOfBitsSet(os_unfair_lock_s *a1)
{
  os_unfair_lock_lock(a1);
  uint64_t os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque)
  {
    LODWORD(v3) = 0;
    uint64_t v4 = a1 + 2;
    do
    {
      uint32_t v5 = v4->_os_unfair_lock_opaque;
      ++v4;
      uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
      v6.i16[0] = vaddlv_u8(v6);
      uint64_t v3 = (v6.i32[0] + v3);
      --os_unfair_lock_opaque;
    }
    while (os_unfair_lock_opaque);
  }
  else
  {
    uint64_t v3 = 0;
  }
  os_unfair_lock_unlock(a1);
  return v3;
}

uint64_t CUIBitVectorBucketValue(os_unfair_lock_s *a1, unsigned int a2)
{
  os_unfair_lock_lock(a1);
  uint64_t os_unfair_lock_opaque = a1[(a2 >> 5) + 2]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(a1);
  return os_unfair_lock_opaque;
}

_DWORD *CUIBitVectorBitAnd(os_unfair_lock_s *a1, os_unfair_lock_s *a2)
{
  os_unfair_lock_lock(a1);
  os_unfair_lock_lock(a2);
  uint64_t os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque == a2[1]._os_unfair_lock_opaque)
  {
    uint32_t v5 = malloc_type_malloc(4 * os_unfair_lock_opaque + 8, 0x7EDDED84uLL);
    bzero(v5, 4 * os_unfair_lock_opaque + 8);
    __CFSetLastAllocationEventName();
    _DWORD *v5 = 0;
    v5[1] = os_unfair_lock_opaque;
    if (a1[1]._os_unfair_lock_opaque)
    {
      uint64_t v6 = 2;
      do
      {
        v5[v6] = a2[v6]._os_unfair_lock_opaque & a1[v6]._os_unfair_lock_opaque;
        unint64_t v7 = v6++ - 1;
      }
      while (v7 < a1[1]._os_unfair_lock_opaque);
    }
  }
  else
  {
    uint32_t v5 = 0;
  }
  os_unfair_lock_unlock(a2);
  os_unfair_lock_unlock(a1);
  return v5;
}

_DWORD *CUIBitVectorBitOrForBucket(os_unfair_lock_s *a1, os_unfair_lock_s *a2, int a3)
{
  os_unfair_lock_lock(a1);
  os_unfair_lock_lock(a2);
  uint64_t os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque == a2[1]._os_unfair_lock_opaque)
  {
    unint64_t v7 = malloc_type_malloc(4 * os_unfair_lock_opaque + 8, 0x7EDDED84uLL);
    bzero(v7, 4 * os_unfair_lock_opaque + 8);
    __CFSetLastAllocationEventName();
    *unint64_t v7 = 0;
    v7[1] = os_unfair_lock_opaque;
    if (a1[1]._os_unfair_lock_opaque)
    {
      unint64_t v8 = 0;
      do
      {
        if (a3 == v8) {
          int v9 = a2[a3 + 2]._os_unfair_lock_opaque | a1[a3 + 2]._os_unfair_lock_opaque;
        }
        else {
          int v9 = a1[v8 + 2]._os_unfair_lock_opaque;
        }
        v7[v8++ + 2] = v9;
      }
      while (v8 < a1[1]._os_unfair_lock_opaque);
    }
    os_unfair_lock_unlock(a2);
  }
  else
  {
    os_unfair_lock_unlock(a2);
    unint64_t v7 = 0;
  }
  os_unfair_lock_unlock(a1);
  return v7;
}

_DWORD *CUIBitVectorToData(os_unfair_lock_s *a1, size_t *a2)
{
  os_unfair_lock_lock(a1);
  size_t v4 = 4 * a1[1]._os_unfair_lock_opaque + 4;
  *a2 = v4;
  uint32_t v5 = malloc_type_malloc(v4, 0x46EEF169uLL);
  uint64_t v6 = v5;
  _DWORD *v5 = a1[1]._os_unfair_lock_opaque;
  if (a1[1]._os_unfair_lock_opaque)
  {
    unint64_t v7 = 0;
    do
    {
      v5[v7 + 1] = a1[v7 + 2]._os_unfair_lock_opaque;
      ++v7;
    }
    while (v7 < a1[1]._os_unfair_lock_opaque);
  }
  __CFSetLastAllocationEventName();
  os_unfair_lock_unlock(a1);
  return v6;
}

BOOL CUIBitVectorEqual(os_unfair_lock_s *a1, os_unfair_lock_s *a2)
{
  os_unfair_lock_lock(a1);
  os_unfair_lock_lock(a2);
  uint64_t os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque == a2[1]._os_unfair_lock_opaque)
  {
    if (os_unfair_lock_opaque)
    {
      uint64_t v5 = os_unfair_lock_opaque - 1;
      uint64_t v6 = a1 + 2;
      unint64_t v7 = a2 + 2;
      do
      {
        uint32_t v9 = v6->_os_unfair_lock_opaque;
        ++v6;
        uint32_t v8 = v9;
        uint32_t v11 = v7->_os_unfair_lock_opaque;
        ++v7;
        uint32_t v10 = v11;
        BOOL v13 = v5-- != 0;
        BOOL v14 = v8 == v10;
      }
      while (v8 == v10 && v13);
    }
    else
    {
      BOOL v14 = 1;
    }
  }
  else
  {
    BOOL v14 = 0;
  }
  os_unfair_lock_unlock(a2);
  os_unfair_lock_unlock(a1);
  return v14;
}

unsigned char *CUIBitVectorToString(os_unfair_lock_s *a1)
{
  os_unfair_lock_lock(a1);
  int v2 = (34 * a1[1]._os_unfair_lock_opaque) | 1;
  uint64_t v3 = malloc_type_calloc((2 * a1[1]._os_unfair_lock_opaque + 32 * a1[1]._os_unfair_lock_opaque) | 1, 1uLL, 0x100004077774924uLL);
  signed int os_unfair_lock_opaque = a1[1]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque)
  {
    unint64_t v5 = 0;
    int v6 = 0;
    do
    {
      uint64_t v7 = 0;
      int v8 = v6;
      v3[v6] = 91;
      uint64_t v9 = (v6 + 1);
      uint32_t v10 = &v3[(int)v9];
      uint64_t v11 = v9 << 32;
      do
      {
        if ((a1[v5 + 2]._os_unfair_lock_opaque >> v7)) {
          char v12 = 49;
        }
        else {
          char v12 = 48;
        }
        v10[v7++] = v12;
        v11 += 0x100000000;
      }
      while (v7 != 32);
      v6 += 34;
      v3[v11 >> 32] = 93;
      ++v5;
    }
    while (v5 < a1[1]._os_unfair_lock_opaque);
    signed int os_unfair_lock_opaque = v8 + 34;
  }
  if (os_unfair_lock_opaque >= v2) {
    CUIBitVectorToString_cold_1();
  }
  __CFSetLastAllocationEventName();
  os_unfair_lock_unlock(a1);
  return v3;
}

CFDataRef CUIImageCompressedWithColorQuantization(uint64_t a1, uint64_t *a2, uint64_t a3, int *a4, __int16 *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  if (!*a2 || (v9 = a2[3]) == 0 || (v10 = a2[2]) == 0 || (unint64_t v11 = a2[1]) == 0)
  {
    _CUILog(4, (uint64_t)"CoreUI: invalid input image buffer in %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (uint64_t)"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)");
    return 0;
  }
  unint64_t v12 = 2 * (v9 / v10);
  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8;
  if ((v12 & 0xFFFFFFFFFFFFFFF8) > 0x20 || ((1 << (v12 & 0xF8)) & 0x100010100) == 0)
  {
    _CUILog(4, (uint64_t)"CoreUI: Unsupported bitsPerComponent: %lu %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, v12 & 0xFFFFFFFFFFFFFFF8);
    return 0;
  }
  if (v13 <= 8) {
    int v15 = 1095911234;
  }
  else {
    int v15 = 1380401751;
  }
  if (v13 <= 8) {
    __int16 v16 = 1;
  }
  else {
    __int16 v16 = 4;
  }
  *a4 = v15;
  *a5 = v16;
  *a6 = CGBitmapGetAlignedBytesPerRow();
  id v17 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:1024];
  unint64_t v18 = (char *)malloc_type_malloc(2 * v10 * v11, 0x7061895uLL);
  if (!v18)
  {
LABEL_86:

    return 0;
  }
  unint64_t v102 = 2 * v10 * v11;
  uint64_t v19 = 0;
  uint64_t v104 = 2 * v10;
  unint64_t v105 = v11;
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v110 = _D0;
  float32x2_t v24 = (float32x2_t)vdup_n_s32(0x461C4000u);
  int8x8_t v108 = (int8x8_t)vdup_n_s32(0x7800000u);
  int8x8_t v109 = (int8x8_t)vdup_n_s32(0x80007FFF);
  unint64_t v25 = a2[3] / (v12 >> 3);
  uint64_t v26 = 0;
  uint64_t v106 = v18;
  uint64_t v27 = v18;
  unint64_t v103 = v25;
  while (2)
  {
    uint64_t v28 = 0;
    uint64_t v107 = v26;
    unint64_t v29 = v25 * v26;
    uint64_t v30 = v19;
    do
    {
      unint64_t v31 = v29 + 4 * v28;
      uint64_t v32 = *a2;
      if (v13 < 9)
      {
        unint64_t v38 = bswap32(*(_DWORD *)(v32 + v31));
      }
      else
      {
        unint64_t v33 = v31 + 3;
        if (v13 == 32)
        {
          uint64_t v34 = v32 + 4 * v31;
          float v35 = *(float *)v34;
          float32x2_t v36 = *(float32x2_t *)(v34 + 4);
          float v37 = *(float *)(v32 + 4 * v33);
        }
        else
        {
          unsigned int v39 = (__int16 *)(v32 + 2 * v31);
          int v40 = *(__int16 *)(v32 + 2 * v33);
          BOOL v41 = (v40 & 0x7C00) == 0;
          if ((v40 & 0x7C00) != 0) {
            unsigned int v42 = (v40 << 13) | 0x70000000;
          }
          else {
            unsigned int v42 = v40 & 0x80007FFF;
          }
          float v43 = 1.9259e-34;
          if (v41) {
            float v44 = 4.2535e37;
          }
          else {
            float v44 = 1.9259e-34;
          }
          float v35 = v44 * *(float *)&v42;
          v45.i32[0] = *v39;
          v45.i32[1] = v39[1];
          int8x8_t v46 = (int8x8_t)vceqz_s32((int32x2_t)vand_s8(v45, (int8x8_t)0x7C0000007C00));
          float32x2_t v36 = vmul_f32((float32x2_t)vbsl_s8(v46, (int8x8_t)0x7E0000007E000000, v108), (float32x2_t)vorr_s8(vand_s8(vand_s8(v45, v109), v46), vbic_s8((int8x8_t)(*(void *)&vshl_n_s32((int32x2_t)v45, 0xDuLL) | 0x7000000070000000), v46)));
          int v47 = v39[2];
          BOOL v48 = (v47 & 0x7C00) == 0;
          if ((v47 & 0x7C00) != 0) {
            unsigned int v49 = (v47 << 13) | 0x70000000;
          }
          else {
            unsigned int v49 = v47 & 0x80007FFF;
          }
          if (v48) {
            float v43 = 4.2535e37;
          }
          float v37 = v43 * *(float *)&v49;
        }
        if ((float)(1.093 - v36.f32[0]) < 0.001
          || (float)(v36.f32[0] + 0.5118) < 0.001
          || (float)(1.0183 - v36.f32[1]) < 0.001
          || (float)(v36.f32[1] + 0.2267) < 0.001
          || (float)(1.0419 - v37) < 0.001
          || (float)(v37 + 0.3107) < 0.001)
        {
          goto LABEL_85;
        }
        float v50 = v35 * 10000.0;
        if (v35 > 1.0) {
          float v50 = 10000.0;
        }
        int8x8_t v51 = (int8x8_t)vcltz_f32(v36);
        int8x8_t v52 = (int8x8_t)vcgt_f32(v36, v110);
        float v53 = v37 * 10000.0;
        if (v37 > 1.0) {
          float v53 = 10000.0;
        }
        if (v35 >= 0.0) {
          float v54 = v50;
        }
        else {
          float v54 = 0.0;
        }
        unint64_t v55 = (unint64_t)v54;
        int8x8_t v56 = (int8x8_t)vmul_f32(v36, v24);
        if (v37 >= 0.0) {
          float v57 = v53;
        }
        else {
          float v57 = 0.0;
        }
        int8x16_t v58 = vandq_s8((int8x16_t)vshlq_u64(vcvtq_u64_f64(vcvtq_f64_f32((float32x2_t)vbic_s8(vbsl_s8(v52, (int8x8_t)v24, v56), v51))), (uint64x2_t)xmmword_1A139D080), (int8x16_t)xmmword_1A139D090);
        unint64_t v38 = v58.i64[0] | (v55 << 48) | (unsigned __int16)(unint64_t)v57 | v58.i64[1];
      }
      id v59 = objc_msgSend(v17, "objectForKey:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v38));
      if (v59)
      {
        unsigned __int16 v60 = (unsigned __int16)[v59 integerValue];
        uint64_t v19 = v30;
      }
      else
      {
        if ([v17 count] == (id)1024)
        {

          free(v106);
          return 0;
        }
        unsigned int v112 = v30 + 1;
        uint64_t v61 = +[NSNumber numberWithUnsignedShort:(unsigned __int16)v30];
        unsigned __int16 v111 = v30;
        unint64_t v62 = v10;
        uint64_t v63 = v61;
        uint64_t v64 = +[NSNumber numberWithUnsignedLongLong:v38];
        uint64_t v65 = v63;
        unint64_t v10 = v62;
        [v17 setObject:v65 forKey:v64];
        unsigned __int16 v60 = v111;
        uint64_t v19 = v112;
        uint64_t v30 = v112;
      }
      *(_WORD *)&v27[2 * v28++] = v60;
    }
    while (v10 != v28);
    uint64_t v26 = v107 + 1;
    v27 += v104;
    unint64_t v25 = v103;
    if (v107 + 1 != v105) {
      continue;
    }
    break;
  }
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, v102 + 8202);
  if (!Mutable)
  {
    _CUILog(4, (uint64_t)"CoreUI: encoding error in %s (line %lu)", v67, v68, v69, v70, v71, v72, (uint64_t)"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)");
LABEL_85:
    free(v106);
    goto LABEL_86;
  }
  char v73 = Mutable;
  *(void *)bytes = 0x1CAFEF00DLL;
  CFDataAppendBytes(Mutable, bytes, 8);
  *(_WORD *)uint64_t v118 = (unsigned __int16)[v17 count];
  CFDataAppendBytes(v73, v118, 2);
  id v74 = v17;
  id v75 = [v17 keysSortedByValueUsingComparator:&__block_literal_global];
  long long v114 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  id v76 = [v75 countByEnumeratingWithState:&v114 objects:v120 count:16];
  unint64_t v77 = v105;
  if (v76)
  {
    id v78 = v76;
    uint64_t v79 = *(void *)v115;
    do
    {
      for (uint64_t i = 0; i != v78; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v115 != v79) {
          objc_enumerationMutation(v75);
        }
        id v81 = *(void **)(*((void *)&v114 + 1) + 8 * i);
        if (v13 < 9)
        {
          *(_DWORD *)v113 = 0;
          *(_DWORD *)v113 = [v81 integerValue];
          id v82 = v73;
          CFIndex v83 = 4;
        }
        else
        {
          *(void *)v113 = 0;
          *(void *)v113 = [v81 integerValue];
          id v82 = v73;
          CFIndex v83 = 8;
        }
        CFDataAppendBytes(v82, v113, v83);
      }
      id v78 = [v75 countByEnumeratingWithState:&v114 objects:v120 count:16];
    }
    while (v78);
  }
  unsigned int v84 = 32 - __clz(*(unsigned __int16 *)v118 - 1);
  if (*(unsigned __int16 *)v118 == 1) {
    LOBYTE(v84) = 1;
  }
  int v85 = v84;
  unsigned int v86 = (v85 - 1) | ((v85 - 1) >> 1) | (((v85 - 1) | ((v85 - 1) >> 1)) >> 2);
  int v87 = v86 | (v86 >> 4);
  unsigned __int8 v88 = v87 + 1;
  if (v87 >= 0x10u) {
    [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)"] file:@"CUIColorQuantizationCompression.m" lineNumber:653 description:@"Bits per LUT index should be between [1, 16]."];
  }
  unint64_t v89 = __compact_bytes((unsigned __int16 *)v106, v10, v105, v85, v88);
  uint64_t v90 = v74;
  if (v89 > v102)
  {
    long long v99 = +[NSAssertionHandler currentHandler];
    long long v100 = +[NSString stringWithUTF8String:"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)"];
    long long v101 = v99;
    unint64_t v77 = v105;
    [(NSAssertionHandler *)v101 handleFailureInFunction:v100 file:@"CUIColorQuantizationCompression.m" lineNumber:657 description:@"Invalid palette size."];
  }
  if (v89 % v77) {
    [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)"] file:@"CUIColorQuantizationCompression.m" lineNumber:658 description:@"Compacted palette table size must be multiples of image height."];
  }
  CFDataAppendBytes(v73, (const UInt8 *)v106, v89);
  CFDataRef v97 = CUICompressedDataWithLZFSE(v73);
  if (!v97) {
    _CUILog(4, (uint64_t)"CoreUI: [%s] Failed to compress blob...", v91, v92, v93, v94, v95, v96, (uint64_t)"CFDataRef CUIImageCompressedWithColorQuantization(CGImageRef, vImage_Buffer, const CUIColorHistogramARGB *, u_int32_t *, short *, size_t *)");
  }
  CFRelease(v73);
  free(v106);

  return v97;
}

uint64_t __CUIImageCompressedWithColorQuantization_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = [a2 integerValue];
  if ((uint64_t)v5 > (uint64_t)[a3 integerValue]) {
    return 1;
  }
  id v7 = [a2 integerValue];
  if ((uint64_t)v7 >= (uint64_t)[a3 integerValue]) {
    return 0;
  }
  else {
    return -1;
  }
}

uint64_t __compact_bytes(unsigned __int16 *a1, uint64_t a2, unint64_t a3, char a4, int a5)
{
  if (!a3) {
    return 0;
  }
  unint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  unsigned __int16 v9 = ~(-1 << a4);
  unint64_t v10 = a1;
  do
  {
    v8 += a5;
    unsigned __int16 v11 = *a1++;
    *unint64_t v10 = *v10 & ~(v9 << (16 - v8)) | ((v11 & v9) << (16 - v8));
    v10 += v8 == 16;
    if (v8 == 16)
    {
      int v8 = 0;
      v7 += 2;
    }
    uint64_t v12 = v6 + 1;
    unsigned int v13 = (v8 - 1);
    BOOL v14 = v13 >= 0xF;
    uint64_t v15 = v7 + 2;
    __int16 v16 = &v10[v13 < 0xF];
    if (v14) {
      int v17 = v8;
    }
    else {
      int v17 = 0;
    }
    if (v14) {
      uint64_t v15 = v7;
    }
    if (v12 == a2)
    {
      unint64_t v10 = v16;
      int v8 = v17;
      uint64_t v7 = v15;
      uint64_t v6 = 0;
    }
    else
    {
      ++v6;
    }
    if (v12 == a2) {
      ++v5;
    }
  }
  while (v5 < a3);
  return v7;
}

uint64_t CUIUncompressQuantizedImageData()
{
  uint64_t v0 = off_1EF485210();
  int v8 = v6;
  if (v6 != 1095911234 && v6 != 1380401751)
  {
    _CUILog(4, (uint64_t)"CoreUI: %s got unsupported pixel format [%d]", v2, v3, v4, v5, v6, v7, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  uint64_t v10 = v5;
  uint64_t v11 = v4;
  uint64_t v12 = v3;
  uint64_t v13 = v2;
  size_t v14 = v1;
  uint64_t v15 = (const uint8_t *)v0;
  memset(&stream, 0, sizeof(stream));
  if (compression_stream_init(&stream, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE)) {
    goto LABEL_13;
  }
  stream.src_ptr = v15;
  stream.size_t src_size = v14;
  uint64_t v63 = 0;
  stream.dst_ptr = (uint8_t *)&v63;
  stream.dst_size = 8;
  if (compression_stream_process(&stream, 0) || v63 != -889262067) {
    goto LABEL_13;
  }
  if (HIDWORD(v63) >= 2)
  {
    _CUILog(4, (uint64_t)"[%s] Decoded version is higher than supported", v16, v17, v18, v19, v20, v21, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  unsigned __int16 v62 = 0;
  stream.dst_ptr = (uint8_t *)&v62;
  stream.dst_size = 2;
  if (compression_stream_process(&stream, 0)) {
    goto LABEL_13;
  }
  if (v62 > 0x1000u)
  {
    _CUILog(4, (uint64_t)"[%s] Decoded color count %u more than max number of colors allowed during decode...", v16, v17, v18, v19, v20, v21, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  char v23 = 2;
  if (v8 == 1380401751) {
    char v23 = 3;
  }
  size_t v24 = (unint64_t)v62 << v23;
  bzero(v65, 0x8000uLL);
  stream.dst_ptr = (uint8_t *)v65;
  stream.dst_size = v24;
  if (compression_stream_process(&stream, 0))
  {
LABEL_13:
    _CUILog(4, (uint64_t)"CoreUI: decoding error in %s (line %lu)", v16, v17, v18, v19, v20, v21, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  unsigned int v25 = __clz(v62 - 1) ^ 0x1F;
  if (v62 == 1) {
    unsigned int v25 = 0;
  }
  unsigned int v26 = v25 | (v25 >> 1) | ((v25 | (v25 >> 1)) >> 2);
  int v27 = (v26 | (v26 >> 4)) + 1;
  size_t v60 = (((((v26 | (v26 >> 4)) + 1) * v12 - 1) & 0xFFFFFFFFFFFFFFF0) + 16) >> 3;
  uint64_t v61 = (uint8_t *)malloc_type_malloc(v60, 0xB5E3FDBAuLL);
  if (!v61)
  {
    _CUILog(4, (uint64_t)"CoreUI: failed to allocate row buffer in %s", v28, v29, v30, v31, v32, v33, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  if (v11)
  {
    uint64_t v59 = 0;
    float32x4_t v58 = (float32x4_t)vdupq_n_s32(0x461C4000u);
    float32x4_t v57 = (float32x4_t)vdupq_n_s32(0x7800000u);
    while (1)
    {
      stream.dst_ptr = v61;
      stream.dst_size = v60;
      if (compression_stream_process(&stream, 0) > COMPRESSION_STATUS_END)
      {
        _CUILog(4, (uint64_t)"CoreUI: decoding error in %s (line %lu)", v34, v35, v36, v37, v38, v39, (uint64_t)"Boolean CUIUncompressQuantizedImageData(const u_int8_t *, u_int64_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
        goto LABEL_39;
      }
      if (v12) {
        break;
      }
LABEL_35:
      bzero(v61, v60);
      v13 += v10;
      if (++v59 == v11) {
        goto LABEL_36;
      }
    }
    char v40 = 0;
    uint64_t v41 = 0;
    unsigned int v42 = v62;
    uint64_t v43 = 1;
    float v44 = v61;
    while (1)
    {
      uint64_t v45 = (*(unsigned __int16 *)v44 >> (16 - (v27 + v40))) & ~(-1 << v27);
      if (v45 >= v42) {
        break;
      }
      v40 += v27;
      BOOL v46 = v40 == 16;
      if (v40 == 16) {
        char v40 = 0;
      }
      if (v8 == 1380401751)
      {
        unint64_t v47 = *(void *)&v65[2 * v45];
        *(float *)&unsigned int v48 = (float)HIWORD(v47) / 10000.0;
        v49.f32[0] = (float)WORD2(v47);
        float v50 = fTo16FRoundTable[COERCE_UNSIGNED_INT((float)WORD1(v47) / 10000.0) >> 23];
        float32_t v51 = (float)(v50 + (float)((float)((float)((float)WORD1(v47) / 10000.0) * 5.1923e33) * 1.9259e-34)) - v50;
        float v52 = fTo16FRoundTable[v48 >> 23];
        v49.f32[1] = v51;
        v49.f32[2] = (float)(unsigned __int16)v47;
        v49.f32[3] = (float)((float)((float)(*(float *)&v48 * 5.1923e33) * 1.9259e-34) + v52) - v52;
        float32x4_t v53 = vdivq_f32(v49, v58);
        uint32x4_t v54 = (uint32x4_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v53), (int32x4_t)vmulq_f32(v49, v57));
        float v55 = vmuls_lane_f32(5.1923e33, v53, 2);
        v53.f32[0] = (float)((float)(fTo16FRoundTable[(unsigned __int32)v53.i32[0] >> 23]
                                   + (float)((float)(5.1923e33 * v53.f32[0]) * 1.9259e-34))
                           - fTo16FRoundTable[(unsigned __int32)v53.i32[0] >> 23])
                   * 1.9259e-34;
        float v56 = fTo16FRoundTable[(unsigned __int32)v53.i32[2] >> 23];
        v53.f32[1] = (float)WORD1(v47) / 10000.0;
        v53.i64[1] = __PAIR64__(v48, (float)((float)((float)(v55 * 1.9259e-34) + v56) - v56) * 1.9259e-34);
        *(int16x4_t *)(v13 + 8 * v41) = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v54, (uint32x4_t)xmmword_1A139D0C0), (int8x16_t)xmmword_1A139D0D0), vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)v53, (uint32x4_t)xmmword_1A139D0A0), (int8x16_t)xmmword_1A139D0B0)));
      }
      else
      {
        *(_DWORD *)(v13 + v43 - 1) = bswap32(v65[v45]);
      }
      v44 += 2 * v46;
      ++v41;
      v43 += 4;
      if (v12 == v41) {
        goto LABEL_35;
      }
    }
    _CUILog(4, (uint64_t)"CoreUI: colorTableIdx [%u] no less than color count [%u] in %s", 125829120, v35, v36, v37, v38, v39, v45);
LABEL_39:
    free(v61);
    return 0;
  }
LABEL_36:
  free(v61);
  compression_stream_destroy(&stream);
  return 1;
}

double _CUIRGBToHSB(double *a1, double *a2, double *a3, double a4, double a5, double a6)
{
  if (a4 < a5 || a4 < a6)
  {
    if (a5 >= a4) {
      double v7 = a4;
    }
    else {
      double v7 = a5;
    }
    if (a4 >= a6) {
      double v8 = a6;
    }
    else {
      double v8 = a4;
    }
    BOOL v9 = a5 < a4 || a5 < a6;
    if (v9) {
      double v10 = a6;
    }
    else {
      double v10 = a5;
    }
    if (v9) {
      double v11 = v7;
    }
    else {
      double v11 = v8;
    }
  }
  else
  {
    if (a5 >= a6) {
      double v11 = a6;
    }
    else {
      double v11 = a5;
    }
    double v10 = a4;
  }
  double v12 = 0.0;
  if (v10 <= 0.0)
  {
    double v14 = 0.0;
  }
  else
  {
    double v13 = v10 - v11;
    double v14 = (v10 - v11) / v10;
    if (v14 != 0.0)
    {
      double v15 = (v10 - a5) / v13;
      double v16 = (v10 - a6) / v13;
      if (v10 == a4)
      {
        if (v11 == a5) {
          double v12 = v16 + 5.0;
        }
        else {
          double v12 = 1.0 - v15;
        }
      }
      else
      {
        BOOL v18 = v10 == a5;
        double v19 = (v10 - a4) / v13;
        if (v18)
        {
          if (v11 == a6) {
            double v12 = v19 + 1.0;
          }
          else {
            double v12 = 3.0 - v16;
          }
        }
        else if (v11 == a4)
        {
          double v12 = v15 + 3.0;
        }
        else
        {
          double v12 = 5.0 - v19;
        }
      }
    }
  }
  *a3 = v10;
  double result = v12 / 6.0;
  *a1 = v12 / 6.0;
  *a2 = v14;
  return result;
}

double *_CUIHSBToRGB(double *result, double *a2, double *a3, double a4, double a5, double a6)
{
  double v6 = a4 * 6.0;
  BOOL v7 = a4 == 1.0;
  double v8 = 0.0;
  if (!v7) {
    double v8 = v6;
  }
  uint64_t v9 = (uint64_t)v8;
  double v10 = v8 - (double)(uint64_t)v8;
  double v11 = (1.0 - a5) * a6;
  double v12 = (1.0 - a5 * v10) * a6;
  double v13 = (1.0 - a5 * (1.0 - v10)) * a6;
  double v14 = a6;
  double v15 = v13;
  switch(v9)
  {
    case 0:
      goto LABEL_10;
    case 1:
      double v14 = v12;
      double v15 = a6;
      goto LABEL_10;
    case 2:
      double v14 = v11;
      double v15 = a6;
      double v11 = v13;
      goto LABEL_10;
    case 3:
      double v14 = v11;
      double v15 = v12;
      goto LABEL_8;
    case 4:
      double v14 = v13;
      double v15 = v11;
LABEL_8:
      double v11 = a6;
      goto LABEL_10;
    case 5:
      double v14 = a6;
      double v15 = v11;
      double v11 = v12;
LABEL_10:
      *double result = v14;
      *a2 = v15;
      *a3 = v11;
      break;
    default:
      return result;
  }
  return result;
}

double *_CUICreateColorByAdjustingTemperature(int a1, double *a2, double *a3, double *a4, double a5, double a6, double a7)
{
  double v13 = fmax(fmin((double)a1, 40000.0), 1000.0);
  double v14 = v13 / 100.0;
  if (v13 / 100.0 <= 66.0)
  {
    double v16 = log(v13 / 100.0) * 0.390081579 + -0.631841444;
    double v15 = 1.0;
  }
  else
  {
    double v15 = fmax(fmin(pow(v14 + -60.0, -0.133204759) * 1.29293619, 1.0), 0.0);
    double v16 = pow(v14 + -60.0, -0.0755148492) * 1.12989086;
  }
  double v17 = 1.0;
  if (v14 < 66.0)
  {
    double v17 = 0.0;
    if (v14 > 19.0) {
      double v17 = fmax(fmin(log(v14 + -10.0) * 0.543206789 + -1.19625409, 1.0), 0.0);
    }
  }
  double v25 = 0.0;
  _CUIRGBToHSB(&v27, &v26, &v25, a5, a6, a7);
  double v23 = 0.0;
  double v24 = 0.0;
  _CUIRGBToHSB(&v24, &v23, &v22, v15 * a5, fmax(fmin(v16, 1.0), 0.0) * a6, v17 * a7);
  double v19 = v23;
  double v18 = v24;
  double v20 = v25;
  return _CUIHSBToRGB(a2, a3, a4, v18, v19, v20);
}

uint64_t CGPathQuadraticLength(double a1, double a2, double a3, double a4, double a5, double a6)
{
  *(double *)&v12[0].v = a1;
  double v13 = a2;
  *(double *)&v10[0].v = a3;
  double v11 = a4;
  *(double *)&v8[0].v = a5;
  double v9 = a6;
  CG::Quadratic::Quadratic((CG::Quadratic *)v7, v12, v10, v8);
  return CG::Quadratic::length((CG::Quadratic *)v7, 0);
}

void sub_1A13142DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1314558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A13148AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_1A1314D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1314EE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1315260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1315530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1315A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1315BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1315D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A13161F0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1A1316828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A1316A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A13171B0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1A1317834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A13189E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double _segmentForValue(void *a1, int a2, char a3, double a4)
{
  unsigned int v4 = a2 - 1;
  if (a2 == 1) {
    return *(double *)a1;
  }
  if (!a2) {
    _segmentForValue_cold_1();
  }
  double v5 = *(double *)a1;
  if (*(double *)a1 <= a4)
  {
    if (*(double *)&a1[v4] >= a4)
    {
      unsigned int v7 = 1;
      do
      {
        if (*(double *)&a1[v7] > a4) {
          break;
        }
        ++v7;
      }
      while (v7 <= v4);
      return *(double *)&a1[v7 - 1];
    }
    else if (a3)
    {
      return *(double *)&a1[v4];
    }
    else
    {
      return *(double *)&a1[a2 - 2];
    }
  }
  return v5;
}

double _segmentForGlyphContinuousSize(char a1, double a2)
{
  return _segmentForValue(kCoreThemeContinuousGlyphInternalSizes, 6, a1, a2);
}

double _segmentForGlyphContinuousWeight(char a1, double a2)
{
  return _segmentForValue(kCoreThemeContinuousGlyphWeights, 9, a1, a2);
}

uint64_t _snapToDiscreteSizeForSize(double a1)
{
  if (a1 <= 1.0) {
    return 1;
  }
  if (a1 >= 1.647) {
    return 3;
  }
  double v1 = 0.2;
  double v2 = 0.2;
  if (a1 >= 0.2)
  {
    double v1 = 2.0;
    double v2 = 2.0;
    if (a1 <= 2.0)
    {
      for (uint64_t i = 1; i != 6; ++i)
      {
        if (kCoreThemeContinuousGlyphInternalSizes[i] > a1) {
          break;
        }
      }
      double v1 = kCoreThemeContinuousGlyphInternalSizes[(i - 1)];
      double v2 = kCoreThemeContinuousGlyphInternalSizes[i];
    }
  }
  uint64_t v4 = 0;
  if ((v1 + v2) * 0.5 > a1) {
    double v5 = v1;
  }
  else {
    double v5 = v2;
  }
  while (*(double *)&kCoreThemeContinuousGlyphSizes[v4] != v5)
  {
    if (++v4 == 3) {
      return 0;
    }
  }
  return kCoreThemeDiscreteGlyphSizes[v4];
}

uint64_t _snapToDiscreteWeightForWeight(double a1)
{
  double v1 = -0.8;
  double v2 = -0.8;
  if (a1 >= -0.8)
  {
    double v1 = 0.62;
    double v2 = 0.62;
    if (a1 <= 0.62)
    {
      for (uint64_t i = 1; i != 9; ++i)
      {
        if (kCoreThemeContinuousGlyphWeights[i] > a1) {
          break;
        }
      }
      double v1 = kCoreThemeContinuousGlyphWeights[(i - 1)];
      double v2 = kCoreThemeContinuousGlyphWeights[i];
    }
  }
  uint64_t v4 = 0;
  if ((v1 + v2) * 0.5 > a1) {
    double v5 = v1;
  }
  else {
    double v5 = v2;
  }
  while (kCoreThemeContinuousGlyphWeights[v4] != v5)
  {
    if (++v4 == 9) {
      return 0;
    }
  }
  return kCoreThemeDiscreteGlyphWeights[v4];
}

uint64_t pk_compressData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, unint64_t a7, uint64_t a8)
{
  if (4 * a4 + 12 >= a7)
  {
    _CUILog(4, (uint64_t)"compressData: destinatinon buffer size %ld too small for y index (%ld)\n", a3, a4, a5, (uint64_t)a6, a7, a8, a7);
    return 0;
  }
  uint64_t v10 = 2 * a3;
  if (a2 != 5) {
    uint64_t v10 = a3;
  }
  if (a2 == 6) {
    uint64_t v11 = 4 * a3;
  }
  else {
    uint64_t v11 = v10;
  }
  *a6 = a2;
  a6[1] = v11;
  a6[2] = a4;
  double v26 = a6 + 3;
  double v12 = &a6[a4 + 3];
  if (a4)
  {
    uint64_t v14 = 0;
    double v15 = (uint64_t (*)(uint64_t, uint64_t, unsigned int *))compress_line_32;
    if (a2 == 3) {
      double v15 = (uint64_t (*)(uint64_t, uint64_t, unsigned int *))compress_line_16;
    }
    if (a2 < 3) {
      double v15 = (uint64_t (*)(uint64_t, uint64_t, unsigned int *))compress_line_8;
    }
    double v24 = v15;
    unint64_t v25 = 4 * (v11 + 1 + ((unint64_t)(v11 + 1) >> 1));
    size_t v16 = -1;
    double v17 = &a6[a4 + 3];
    uint64_t v23 = a4;
    while (1)
    {
      int v18 = v17 - a6;
      if ((char *)v17 - (char *)a6 + v25 > a7) {
        break;
      }
      uint64_t v19 = v11;
      int v20 = v24(a1, v11, v17);
      if (v16 == v20 && !memcmp(v12, v17, v16))
      {
        int v18 = v12 - a6;
        int v21 = (int)v17;
      }
      else
      {
        size_t v16 = v20;
        int v21 = v17 + v20;
        double v12 = v17;
        double v17 = (unsigned int *)((char *)v17 + v20);
      }
      uint64_t v11 = v19;
      a4 = v23;
      v26[v14++] = v18;
      a1 += a5;
      if (v23 == v14) {
        return (v21 - a6);
      }
    }
    _CUILog(4, (uint64_t)"compressData: overflow: %ld bytes in %ld byte buffer at scanline %ld (of %ld).\n", a3, a4, a5, (uint64_t)a6, a7, a8, (char *)v17 - (char *)a6);
    return 0;
  }
  int v21 = a6 + 12 + 4 * a4;
  return (v21 - a6);
}

uint64_t compress_line_8(char *__src, uint64_t a2, unsigned int *a3)
{
  if (a2 < 1) {
    return 0;
  }
  double v5 = __src;
  uint64_t v6 = 0;
  unsigned int v7 = &__src[a2];
  double v8 = &__src[a2 - 1];
  double v9 = __src;
  do
  {
    char v11 = *v9++;
    char v10 = v11;
    if (v9 >= v7)
    {
      int v12 = 0;
      int v14 = 1;
    }
    else
    {
      int v12 = 0;
      uint64_t v13 = v8 - v5;
      int v14 = 1;
      do
      {
        if (*v9 == v10)
        {
          ++v14;
        }
        else
        {
          if (v14 > 9) {
            goto LABEL_12;
          }
          v12 += v14;
          int v14 = 1;
          char v10 = *v9;
        }
        ++v9;
        --v13;
      }
      while (v13);
      double v9 = v7;
    }
LABEL_12:
    if (v14 <= 9) {
      int v15 = v14;
    }
    else {
      int v15 = 0;
    }
    unsigned int v16 = v15 + v12;
    if (v15 + v12 >= 1)
    {
      *a3 = v16;
      double v17 = (char *)(a3 + 1);
      memcpy(v17, v5, (v15 + v12));
      uint64_t v6 = v6 + v16 + 4;
      a3 = (unsigned int *)&v17[v16];
    }
    if (v14 >= 10)
    {
      *a3 = v14 | 0x80000000;
      *((unsigned char *)a3 + 4) = v10;
      uint64_t v6 = (v6 + 5);
      a3 = (unsigned int *)((char *)a3 + 5);
    }
    double v5 = v9;
  }
  while (v9 < v7);
  return v6;
}

uint64_t compress_line_16(unsigned __int16 *__src, uint64_t a2, unsigned int *a3)
{
  if (a2 < 1)
  {
    int v6 = 0;
  }
  else
  {
    double v5 = __src;
    int v6 = 0;
    unsigned int v7 = &__src[a2];
    double v8 = __src;
    do
    {
      unsigned __int16 v10 = *v8++;
      unsigned __int16 v9 = v10;
      if (v8 >= v7)
      {
        int v11 = 0;
        int v12 = 1;
      }
      else
      {
        int v11 = 0;
        int v12 = 1;
        do
        {
          if (*v8 == v9)
          {
            ++v12;
          }
          else
          {
            if (v12 > 5) {
              break;
            }
            v11 += v12;
            int v12 = 1;
            unsigned __int16 v9 = *v8;
          }
          ++v8;
        }
        while (v8 < v7);
      }
      if (v12 <= 5) {
        int v13 = v12;
      }
      else {
        int v13 = 0;
      }
      unsigned int v14 = v13 + v11;
      if (v13 + v11 >= 1)
      {
        *a3 = v14;
        int v15 = (char *)(a3 + 1);
        memcpy(v15, v5, 2 * (v13 + v11));
        v6 += v14 + 2;
        a3 = (unsigned int *)&v15[2 * v14];
      }
      if (v12 >= 6)
      {
        *a3 = v12 | 0x80000000;
        *((_WORD *)a3 + 2) = v9;
        v6 += 3;
        a3 = (unsigned int *)((char *)a3 + 6);
      }
      double v5 = v8;
    }
    while (v8 < v7);
  }
  return (2 * v6);
}

uint64_t compress_line_32(char *__src, uint64_t a2, unsigned int *a3)
{
  if (a2 < 1)
  {
    int v6 = 0;
  }
  else
  {
    double v5 = __src;
    int v6 = 0;
    unsigned int v7 = &__src[4 * a2];
    double v8 = (unsigned int *)__src;
    do
    {
      unsigned int v10 = *v8++;
      unsigned int v9 = v10;
      if (v8 >= (unsigned int *)v7)
      {
        int v11 = 0;
        int v12 = 1;
      }
      else
      {
        int v11 = 0;
        int v12 = 1;
        do
        {
          if (*v8 == v9)
          {
            ++v12;
          }
          else
          {
            if (v12 > 3) {
              break;
            }
            v11 += v12;
            int v12 = 1;
            unsigned int v9 = *v8;
          }
          ++v8;
        }
        while (v8 < (unsigned int *)v7);
      }
      if (v12 <= 3) {
        int v13 = v12;
      }
      else {
        int v13 = 0;
      }
      unsigned int v14 = v13 + v11;
      if (v13 + v11 >= 1)
      {
        *a3 = v14;
        int v15 = (char *)(a3 + 1);
        memcpy(v15, v5, (int)(4 * v14));
        v6 += v14 + 1;
        a3 = (unsigned int *)&v15[4 * v14];
      }
      if (v12 >= 4)
      {
        *a3 = v12 | 0x80000000;
        a3[1] = v9;
        a3 += 2;
        v6 += 2;
      }
      double v5 = (char *)v8;
    }
    while (v8 < (unsigned int *)v7);
  }
  return (4 * v6);
}

int *pk_decompressData(int *result, uint64_t a2, unsigned int a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  int v8 = *result;
  int v9 = 4 * a5;
  unsigned int v10 = 2 * a3;
  int v11 = 2 * a5;
  if (*result != 5) {
    int v11 = a5;
  }
  if (v8 != 5) {
    unsigned int v10 = a3;
  }
  if (v8 == 6)
  {
    uint64_t v12 = 4 * a3;
  }
  else
  {
    int v9 = v11;
    uint64_t v12 = v10;
  }
  if (a6 >= 1)
  {
    int v15 = a6;
    double v17 = result;
    int v18 = (unsigned int *)&result[a4 + 3];
    uint64_t v19 = (v12 + v9);
    int v20 = __decompressRLE32;
    if (v8 == 3) {
      int v20 = __decompressRLE16;
    }
    if (v8 >= 3) {
      int v21 = v20;
    }
    else {
      int v21 = __decompressRLE8;
    }
    do
    {
      unsigned int v23 = *v18++;
      LODWORD(v22) = v23;
      unsigned int v24 = bswap32(v23);
      if (a8) {
        uint64_t v22 = v24;
      }
      else {
        uint64_t v22 = v22;
      }
      double result = (int *)v21((uint64_t)v17 + v22, a2, v12, v19, a8);
      a2 += a7;
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t __decompressRLE8(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  if (a4 >= 1)
  {
    int v9 = (unsigned int *)result;
    int v10 = 0;
    do
    {
      uint64_t v12 = v9 + 1;
      unsigned int v11 = *v9;
      unsigned int v13 = bswap32(*v9);
      if (a5) {
        unsigned int v11 = v13;
      }
      int v14 = v11 & 0xFFFFFF;
      int v15 = (v11 & 0xFFFFFF) + v10;
      if (HIBYTE(v11) == 128)
      {
        if (v15 > a3)
        {
          int v16 = a4 - v10;
          if (a4 - v10 >= v14) {
            int v16 = v14;
          }
          int v17 = v16 - ((a3 - v10) & ~((a3 - v10) >> 31));
          double result = CGBlt_fillBytes();
          a2 += v17;
        }
        int v9 = (unsigned int *)((char *)v9 + 5);
      }
      else
      {
        if (v15 > a3)
        {
          int v18 = a4 - v10;
          if (a4 - v10 >= v14) {
            int v18 = v14;
          }
          int v19 = v18 - ((a3 - v10) & ~((a3 - v10) >> 31));
          double result = CGBlt_copyBytes();
          a2 += v19;
        }
        int v9 = (unsigned int *)((char *)v12 + v14);
      }
      int v10 = v15;
    }
    while (v15 < a4);
  }
  return result;
}

uint64_t __decompressRLE16(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  if (a4 >= 1)
  {
    int v9 = (unsigned int *)result;
    int v10 = 0;
    do
    {
      uint64_t v12 = v9 + 1;
      unsigned int v11 = *v9;
      unsigned int v13 = bswap32(*v9);
      if (a5) {
        unsigned int v11 = v13;
      }
      int v14 = v11 & 0xFFFFFF;
      int v15 = (v11 & 0xFFFFFF) + v10;
      if (HIBYTE(v11) == 128)
      {
        if (v15 > a3)
        {
          int v16 = a4 - v10;
          if (a4 - v10 >= v14) {
            int v16 = v14;
          }
          int v17 = v16 - ((a3 - v10) & ~((a3 - v10) >> 31));
          double result = CGBlt_fillBytes();
          a2 += 2 * v17;
        }
        int v9 = (unsigned int *)((char *)v9 + 6);
      }
      else
      {
        if (v15 > a3)
        {
          int v18 = a4 - v10;
          if (a4 - v10 >= v14) {
            int v18 = v14;
          }
          int v19 = v18 - ((a3 - v10) & ~((a3 - v10) >> 31));
          double result = CGBlt_copyBytes();
          a2 += 2 * v19;
        }
        int v9 = (unsigned int *)((char *)v12 + 2 * v14);
      }
      int v10 = v15;
    }
    while (v15 < a4);
  }
  return result;
}

uint64_t __decompressRLE32(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  if (a4 >= 1)
  {
    int v9 = (unsigned int *)result;
    int v10 = 0;
    do
    {
      unsigned int v11 = *v9;
      unsigned int v12 = bswap32(*v9);
      if (a5) {
        unsigned int v11 = v12;
      }
      int v13 = v11 & 0xFFFFFF;
      int v14 = (v11 & 0xFFFFFF) + v10;
      if (HIBYTE(v11) == 128)
      {
        if (v14 > a3)
        {
          int v15 = a4 - v10;
          if (a4 - v10 >= v13) {
            int v15 = v13;
          }
          int v16 = v15 - ((a3 - v10) & ~((a3 - v10) >> 31));
          double result = CGBlt_fillBytes();
          a2 += 4 * v16;
        }
        v9 += 2;
      }
      else
      {
        if (v14 > a3)
        {
          int v17 = a4 - v10;
          if (a4 - v10 >= v13) {
            int v17 = v13;
          }
          int v18 = v17 - ((a3 - v10) & ~((a3 - v10) >> 31));
          double result = CGBlt_copyBytes();
          a2 += 4 * v18;
        }
        v9 += v13 + 1;
      }
      int v10 = v14;
    }
    while (v14 < a4);
  }
  return result;
}

void CStdException::CStdException(CStdException *this, uint64_t a2)
{
  *(void *)this = &unk_1EF485F50;
  *((void *)this + 1) = a2;
  CStdException::m_SaveLastErrorCode = a2;
}

void CStdException::~CStdException(CStdException *this)
{
}

uint64_t CStdException::ErrorCode(CStdException *this)
{
  return *((void *)this + 1);
}

char *CStdException::ErrorString(CStdException *this, char *a2)
{
  return a2;
}

uint64_t CStdException::ErrorMessageOut(CStdException *this)
{
  return *((void *)this + 1);
}

__CFData *CUIImageCompressedWithHEVC(CGImageRef image, _DWORD *a2, __int16 *a3, size_t *a4, double a5)
{
  CGImageRef v9 = image;
  BOOL v10 = a5 > 1.0 || a5 <= 0.0;
  if (a2) {
    *a2 = 1095911234;
  }
  if (a3) {
    *a3 = 1;
  }
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent < 9) {
    goto LABEL_20;
  }
  ColorSpace = CGImageGetColorSpace(v9);
  if (CGColorSpaceGetModel(ColorSpace))
  {
    CFStringRef v13 = kCGColorSpaceDisplayP3;
    int v14 = CGColorSpaceCreateWithName(kCGColorSpaceDisplayP3);
    if (a2) {
      *a2 = 1095911234;
    }
    if (a3)
    {
      __int16 v15 = 3;
LABEL_18:
      *a3 = v15;
    }
  }
  else
  {
    CFStringRef v13 = kCGColorSpaceGenericGrayGamma2_2;
    int v14 = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
    if (a2) {
      *a2 = 1195456544;
    }
    if (a3)
    {
      __int16 v15 = 2;
      goto LABEL_18;
    }
  }
  CGImageRef v9 = CUIConvertDeepImageTo8(v9, v14);
  CFRelease(v14);
  if (!v9)
  {
    CStringPtr = CFStringGetCStringPtr(v13, 0x600u);
    _CUILog(4, (uint64_t)"CoreUI: Failed to convert source image to 8-bit color channel with %s colorspace in HEVC compression.", v32, v33, v34, v35, v36, v37, (uint64_t)CStringPtr);
    return 0;
  }
LABEL_20:
  if (a4) {
    *a4 = CGImageGetBytesPerRow(v9);
  }
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    if (BitsPerComponent >= 9 && v9) {
      CFRelease(v9);
    }
    uint64_t v31 = "CoreUI: Failed to allocate buffer for HEVC image destination.";
    goto LABEL_45;
  }
  unsigned int v23 = Mutable;
  v50[0] = kCGImageMetadataShouldExcludeXMP;
  v50[1] = @"kCGImageMetadataShouldExcludeGPS";
  v51[0] = &unk_1EF4A69A0;
  v51[1] = &unk_1EF4A69A0;
  CGImageDestinationRef v24 = CGImageDestinationCreateWithData(Mutable, @"public.heic", 1uLL, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:v51 forKeys:v50 count:2]);
  if (!v24)
  {
    if (BitsPerComponent >= 9 && v9) {
      CFRelease(v9);
    }
    CFRelease(v23);
    uint64_t v31 = "CoreUI: Failed to instantiate HEVC image destination.";
    goto LABEL_45;
  }
  double v26 = v24;
  *(float *)&double v25 = a5;
  v48[0] = kCGImageDestinationLossyCompressionQuality;
  if (v10) {
    *(float *)&double v25 = *(float *)"fff?";
  }
  v49[0] = +[NSNumber numberWithFloat:v25];
  v49[1] = &unk_1EF4A69A0;
  v48[1] = @"kCGImageDestinationChromaSubSamplingX";
  v48[2] = @"kCGImageDestinationChromaSubSamplingY";
  v49[2] = &unk_1EF4A69A0;
  CGImageDestinationAddImage(v26, v9, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:v49 forKeys:v48 count:3]);
  if (!CGImageDestinationFinalize(v26))
  {
    if (BitsPerComponent >= 9 && v9) {
      CFRelease(v9);
    }
    CFRelease(v26);
    CFRelease(v23);
    uint64_t v31 = "CoreUI: Failed to write to HEVC image destination.";
LABEL_45:
    _CUILog(4, (uint64_t)v31, v17, v18, v19, v20, v21, v22, v45);
    return 0;
  }
  CFRelease(v26);
  *(_DWORD *)bytes = 1;
  CFIndex Length = CFDataGetLength(v23);
  *(_DWORD *)&bytes[4] = Length;
  uint64_t v28 = CFDataCreateMutable(kCFAllocatorDefault, Length + 8);
  uint64_t v29 = v28;
  if (v28)
  {
    CFDataAppendBytes(v28, bytes, 8);
    BytePtr = CFDataGetBytePtr(v23);
    CFDataAppendBytes(v29, BytePtr, Length);
    if (BitsPerComponent >= 9 && v9) {
      CFRelease(v9);
    }
    CFRelease(v23);
  }
  else
  {
    if (BitsPerComponent >= 9 && v9) {
      CFRelease(v9);
    }
    CFRelease(v23);
    _CUILog(4, (uint64_t)"CoreUI: Failed to allocate buffer for encoded payload in HEVC compression.", v39, v40, v41, v42, v43, v44, v45);
  }
  return v29;
}

CFDataRef CUIUncompressHEVCInfoData(uint64_t a1, void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2)
  {
    int v9 = a4;
    if (a4 == 1095911234 || a4 == 1195456544)
    {
      CFDataRef result = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)(a1 + 8), *(unsigned int *)(a1 + 4), kCFAllocatorNull);
      if (!result) {
        return result;
      }
      unsigned int v12 = result;
      CFStringRef v13 = CGImageSourceCreateWithData(result, 0);
      if (v13)
      {
        uint64_t v20 = v13;
        ImageAtIndex = CGImageSourceCreateImageAtIndex(v13, 0, 0);
        if (ImageAtIndex)
        {
          uint64_t v28 = ImageAtIndex;
          vImagePixelCount Width = CGImageGetWidth(ImageAtIndex);
          size_t Height = CGImageGetHeight(v28);
          size_t BytesPerRow = CGImageGetBytesPerRow(v28);
          uint32_t BitsPerComponent = CGImageGetBitsPerComponent(v28);
          uint32_t BitsPerPixel = CGImageGetBitsPerPixel(v28);
          ColorSpace = CGImageGetColorSpace(v28);
          uint64_t v61 = ColorSpace;
          if (v9 == 1195456544 || CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelMonochrome)
          {
            vImagePixelCount v32 = Height;
            uint64_t v36 = malloc_type_malloc(BytesPerRow * Height, 0x3EAC2956uLL);
            CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(v28);
            __CFSetLastAllocationEventName();
            uint64_t v35 = v36;
            int v33 = 1;
            if (!v35)
            {
              float32x4_t v58 = 0;
              goto LABEL_34;
            }
          }
          else
          {
            vImagePixelCount v32 = Height;
            int v33 = 0;
            CGBitmapInfo BitmapInfo = 8196;
            size_t BytesPerRow = a3;
            uint64_t v35 = a2;
          }
          float32x4_t v58 = v35;
          srcs.data = v35;
          srcs.height = v32;
          srcs.width = Width;
          srcs.rowBytes = BytesPerRow;
          srcFormat.bitsPerComponent = BitsPerComponent;
          srcFormat.bitsPerPixel = BitsPerPixel;
          srcFormat.colorSpace = v61;
          srcFormat.bitmapInfo = BitmapInfo;
          memset(&srcFormat.version, 0, 20);
          if (MEMORY[0x1A6231AB0](&srcs, &srcFormat, 0, v28, 768))
          {
            _CUILog(4, (uint64_t)"CoreUI: Failed to get buffer from HEVC CGImage.", v37, v38, v39, v40, v41, v42, v57);
            goto LABEL_34;
          }
          if (v33)
          {
            if (v9 != 1195456544 && CGColorSpaceGetModel(v61)) {
              [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"Boolean CUIUncompressHEVCInfoData(const u_int8_t *, u_int8_t *, size_t, u_int32_t)"] file:@"CUIHEVCCompression.m" lineNumber:285 description:@"Only need to convert to GRAY pixel format"];
            }
            vImage_Error error = 0;
            *(void *)&destFormat.bitsPerComponent = 0x1000000008;
            destFormat.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
            destFormat.bitmapInfo = 4100;
            memset(&destFormat.version, 0, 20);
            dests.data = a2;
            dests.height = v32;
            dests.width = Width;
            dests.rowBytes = a3;
            uint64_t v43 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0x110u, &error);
            if (!v43 || error)
            {
              _CUILog(4, (uint64_t)"CoreUI: Failed to create image format converter (at %s:%lu)", v44, v45, v46, v47, v48, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/CoreUI/CoreTheme/ImageUtils/CUIHEVCCompression.m");
              goto LABEL_33;
            }
            float v50 = v43;
            vImage_Error error = vImageConvert_AnyToAny(v43, &srcs, &dests, 0, 0x110u);
            vImageConverter_Release(v50);
            if (error)
            {
              _CUILog(4, (uint64_t)"CoreUI: Failed to convert to destination image format (at %s:%lu)", v51, v52, v53, v54, v55, v56, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/CoreUI/CoreTheme/ImageUtils/CUIHEVCCompression.m");
LABEL_33:
              int v33 = 1;
LABEL_34:
              CFRelease(v28);
              CFRelease(v20);
              CFRelease(v12);
              if (v33) {
                free(v58);
              }
              return 0;
            }
            CFRelease(v28);
            CFRelease(v20);
            CFRelease(v12);
            free(v58);
          }
          else
          {
            CFRelease(v28);
            CFRelease(v20);
            CFRelease(v12);
          }
          return (CFDataRef)1;
        }
        _CUILog(4, (uint64_t)"CoreUI: Failed to instantiate CGImage from HEVC data.", v22, v23, v24, v25, v26, v27, v57);
        CFRelease(v20);
      }
      else
      {
        _CUILog(4, (uint64_t)"CoreUI: Failed to instantiate CGSourceRef from HEVC data.", v14, v15, v16, v17, v18, v19, v57);
      }
      CFRelease(v12);
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: Unsupported pixel format: %u (at %s:%lu).", a3, a4, a5, a6, a7, a8, a4);
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: Invalid input to %s.", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressHEVCInfoData(const u_int8_t *, u_int8_t *, size_t, u_int32_t)");
  }
  return 0;
}

unsigned __int16 *CUIFillRenditionKeyForCARKeyArray(unsigned __int16 *result, uint64_t a2, uint64_t a3)
{
  if (!result || !a2) {
    CUIFillRenditionKeyForCARKeyArray_cold_1();
  }
  unsigned int v5 = *(_DWORD *)(a3 + 8);
  if (v5)
  {
    int v6 = result;
    int v7 = 0;
    do
    {
      CFDataRef result = CUIRenditionKeySetValueForAttribute(v6, *(unsigned __int16 *)(a3 + 4 * (unsigned __int16)v7 + 12), *(unsigned __int16 *)(a2 + 2 * (unsigned __int16)v7), (unsigned __int16)(v5 + 1));
      ++v7;
      unsigned int v5 = *(_DWORD *)(a3 + 8);
    }
    while (v5 > (unsigned __int16)v7);
  }
  return result;
}

uint64_t CUIRenditionKeyIndexForAttribute(unsigned __int16 *a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *a1;
  if (!a1[1] && v3 == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v6 = a1 + 3;
  while (v3 != a2)
  {
    int v7 = *v6;
    int v3 = *(v6 - 1);
    uint64_t result = (result + 1);
    v6 += 2;
    if (v7) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v3 == 0;
    }
    if (v8) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t CUIRenditionKeyFormatRemoveAttribute(uint64_t result, int a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v3 = 0;
    while (*(_DWORD *)(result + 12 + 4 * v3) != a2)
    {
      if (v2 == ++v3) {
        return result;
      }
    }
    if ((int)v3 + 1 < v2)
    {
      do
      {
        *(_DWORD *)(result + 4 * v3 + 12) = *(_DWORD *)(result + 16 + 4 * v3);
        ++v3;
      }
      while (v2 - 1 != v3);
    }
    *(_DWORD *)(result + 8) = v2 - 1;
  }
  return result;
}

uint64_t CUIFillCARKeyArrayForRenditionKey(uint64_t a1, int *a2, uint64_t a3)
{
  return CUIFillCARKeyArrayForRenditionKey2(a1, a2, a3, 0);
}

void CUIRenditionKeyStandardize(void *a1, unsigned __int16 *a2, uint64_t a3)
{
  memset(v14, 0, 92);
  unsigned int v6 = *(_DWORD *)(a3 + 8);
  if (v6 - 23 > 0xFFFFFFE7)
  {
    int v7 = v14;
  }
  else
  {
    int v7 = malloc_type_calloc(v6 + 3, 4uLL, 0x100004052888210uLL);
    unsigned int v6 = *(_DWORD *)(a3 + 8);
  }
  BOOL v8 = v7;
  if (v6)
  {
    uint64_t v9 = v6;
    BOOL v10 = (int *)(a3 + 12);
    BOOL v8 = v7;
    do
    {
      int v12 = *v10++;
      __int16 v11 = v12;
      unsigned int v13 = CUIRenditionKeyValueForAttribute(a2, (unsigned __int16)v12);
      if (v13)
      {
        *BOOL v8 = v11;
        v8[1] = v13;
        v8 += 2;
      }
      --v9;
    }
    while (v9);
  }
  *(_DWORD *)BOOL v8 = 0;
  CUIRenditionKeyCopy(a1, v7, (unsigned __int16)(*(_WORD *)(a3 + 8) + 1));
  if (v7 != (_WORD *)v14) {
    free(v7);
  }
}

uint64_t CUICompareRenditionKey(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a3 + 8);
  if (!v4) {
    return 0;
  }
  int v7 = (unsigned __int16 *)(a3 + 12);
  while (1)
  {
    int v8 = *v7;
    v7 += 2;
    unsigned int v9 = CUIRenditionKeyValueForAttribute(a1, v8);
    unsigned int v10 = CUIRenditionKeyValueForAttribute(a2, v8);
    uint64_t v11 = v9 > v10 ? 1 : v3;
    uint64_t v3 = v9 < v10 ? -1 : v11;
    if (v9 != v10) {
      break;
    }
    if (!--v4) {
      return 0;
    }
  }
  return v3;
}

uint64_t CUIMinScaleForTargetPlatform(uint64_t a1)
{
  if ((a1 & 0xFFFFFFFFFFFFFFFELL) == 4) {
    return 2;
  }
  else {
    return 1;
  }
}

double CUIPointSizeForDimensionForVectorGlyph(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = (char *)&__VectorGlyphDimension2ToPointSizeTableEmbedded + 8 * a2;
  uint64_t v3 = (char *)&__VectorGlyphDimension2ToPointSizeTableWatch + 8 * a2;
  uint64_t v4 = (char *)&__VectorGlyphDimension2ToPointSizeTableForMac + 8 * a2;
  if (a1) {
    uint64_t v4 = (char *)&__VectorGlyphDimension2ToPointSizeTableEmbedded + 8 * a2;
  }
  if (a1 != 4) {
    uint64_t v3 = v4;
  }
  if (a1 != 5) {
    uint64_t v2 = v3;
  }
  return *(double *)v2;
}

uint64_t CUIMinDimensionForVectorGlyph()
{
  return 0;
}

uint64_t CUIMaxDimensionForVectorGlyph(uint64_t a1)
{
  if (a1 == 4) {
    return 1;
  }
  else {
    return 3;
  }
}

uint64_t CUIPreferredVectorGlyphConfigurationsForPlatform(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 6) {
    return (uint64_t)*(&off_1E5A51840 + a1);
  }
  _CUILog(4, (uint64_t)"CoreUI: CUIPreferredVectorGlyphConfigurationsForPlatform() called with an unknown platform '%d'", a3, a4, a5, a6, a7, a8, a1);
  return 0;
}

__CFString *CUIPlatformNameForPlatform(uint64_t a1)
{
  switch(a1)
  {
    case 0:
      uint64_t result = kCUIPlatformMac[0];
      break;
    case 1:
      uint64_t result = (__CFString *)kCUIPlatformiOS;
      break;
    case 2:
      uint64_t result = (__CFString *)kCUIPlatformMaciOS;
      break;
    case 3:
      uint64_t result = (__CFString *)kCUIPlatformAppleTV;
      break;
    case 4:
      uint64_t result = (__CFString *)kCUIPlatformWatch;
      break;
    case 5:
      uint64_t result = (__CFString *)kCUIPlatformVision;
      break;
    default:
      uint64_t result = &stru_1EF488038;
      break;
  }
  return result;
}

const char *CUICGBlendModeFromLSRDescription(void *a1)
{
  uint64_t result = (const char *)[a1 UTF8String];
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = 0;
    while (strcasecmp((const char *)gCGBlendModeDescriptions[v3 + 1], v2))
    {
      v3 += 3;
      if (v3 == 84) {
        return 0;
      }
    }
    return (const char *)LODWORD(gCGBlendModeDescriptions[v3]);
  }
  return result;
}

__CFString *CUIBlendModeLSRDescriptionFromCGBlendMode(int a1)
{
  uint64_t v1 = 0;
  while (gCGBlendModeDescriptions[v1] != a1)
  {
    v1 += 3;
    if (v1 == 84) {
      return @"normal";
    }
  }
  return (__CFString *)+[NSString stringWithUTF8String:gCGBlendModeDescriptions[v1 + 1]];
}

__CFString *CUIBlendModeDescriptionFromCGBlendMode(int a1)
{
  uint64_t v1 = 0;
  while (gCGBlendModeDescriptions[v1] != a1)
  {
    v1 += 3;
    if (v1 == 84) {
      return @"Normal";
    }
  }
  return (__CFString *)+[NSString stringWithUTF8String:gCGBlendModeDescriptions[v1 + 2]];
}

const char *CUIThemeAttributeNameToString(int a1)
{
  if ((a1 - 1) > 0x1B) {
    return "UNKNOWN";
  }
  else {
    return off_1E5A51870[a1 - 1];
  }
}

id CUIKeyFormatToArrayString(uint64_t a1)
{
  id v2 = +[NSMutableArray array];
  if (*(_DWORD *)(a1 + 8))
  {
    int v3 = 0;
    do
      objc_msgSend(v2, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", CUIThemeAttributeNameToString(*(_DWORD *)(a1 + 4 * (unsigned __int16)v3++ + 12))));
    while (*(_DWORD *)(a1 + 8) > (unsigned __int16)v3);
  }
  return v2;
}

CFDataRef CUICompressedDataWithLZFSE(const __CFData *a1)
{
  return __compress_data_stream(a1, COMPRESSION_STREAM_ENCODE);
}

uint64_t CreateFile(char *a1, int a2)
{
  return CreateFileOptionalLogging(a1, a2, 1);
}

uint64_t CreateFileOptionalLogging(char *a1, int a2, int a3)
{
  if (a2 && a2 != 1538)
  {
    if (a3) {
      fwrite("Error: Only GENERIC_READ or CREATE_ALWAYS supported at this time\n", 0x41uLL, 1uLL, __stderrp);
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = 511;
  if (a2 != 1538) {
    uint64_t v5 = 0;
  }
  uint64_t result = open(a1, a2, v5);
  if ((result & 0x80000000) != 0)
  {
    if (a3)
    {
      int v7 = __stderrp;
      int v8 = __error();
      unsigned int v9 = strerror(*v8);
      fprintf(v7, "Failed to open file: %s [%s]\n", a1, v9);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CloseHandle(int a1)
{
  if ((close(a1) & 0x80000000) == 0) {
    return 1;
  }
  id v2 = __stderrp;
  int v3 = __error();
  uint64_t v4 = strerror(*v3);
  fprintf(v2, "Failed to close File Stream [%s]\n", v4);
  return 0;
}

uint64_t ReadFile(int a1, void *a2, size_t a3, _DWORD *a4)
{
  ssize_t v5 = read(a1, a2, a3);
  if (v5 < 0)
  {
    int v7 = __stderrp;
    int v8 = __error();
    unsigned int v9 = strerror(*v8);
    fprintf(v7, "Error while reading file: [%s]\n", v9);
    return 0;
  }
  else
  {
    *a4 = v5;
    return 1;
  }
}

unint64_t SetFilePointer(int a1, off_t a2, unint64_t *a3, int a4)
{
  if (a3)
  {
    unint64_t result = lseek(a1, a2 | (*a3 << 32), a4);
    if ((result & 0x8000000000000000) == 0)
    {
      *a3 = HIDWORD(result);
      return result;
    }
  }
  else
  {
    unint64_t result = lseek(a1, a2, a4);
    if ((result & 0x8000000000000000) == 0) {
      return result;
    }
  }
  unsigned int v6 = __stderrp;
  int v7 = __error();
  int v8 = strerror(*v7);
  fprintf(v6, "Error while seeking: [%s]\n", v8);
  return 0;
}

void *File::CopyToBuffer(File *this, const void *a2, size_t a3)
{
  uint64_t v3 = *((unsigned int *)this + 2);
  if ((uint64_t)(v3 + a3) >= 2049) {
    File::CopyToBuffer();
  }
  int v4 = a3;
  unint64_t result = memcpy((char *)this + v3 + 12, a2, a3);
  *((_DWORD *)this + 2) += v4;
  return result;
}

uint64_t File::BufferedWrite(File *this, const void *a2, int64_t a3)
{
  size_t v6 = *((unsigned int *)this + 2);
  if ((uint64_t)(v6 + a3) <= 2048) {
    goto LABEL_5;
  }
  if (v6)
  {
    write(*((_DWORD *)this + 515), (char *)this + 12, v6);
    *((_DWORD *)this + 2) = 0;
  }
  if (a3 > 2048) {
    a3 += write(*((_DWORD *)this + 515), a2, a3);
  }
  else {
LABEL_5:
  }
    File::CopyToBuffer(this, a2, a3);
  return a3;
}

uint64_t File::AppendUTF16StringCore(File *this, unsigned __int16 *a2, unsigned int a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = *((void *)this + 258);
  uint64_t v7 = a3;
  while (1)
  {
    unsigned int v9 = *a2++;
    __int16 v8 = v9;
    unsigned int v10 = bswap32(v9) >> 16;
    if (v6 != 1) {
      __int16 v8 = v10;
    }
    __int16 v13 = v8;
    uint64_t v11 = File::BufferedWrite(this, &v13, 2);
    if (v11 == -1) {
      break;
    }
    v5 += v11;
    if (!--v7) {
      return v5;
    }
  }
  return -1;
}

uint64_t File::AppendZerosCore(File *this, size_t size)
{
  if (!size) {
    return 0;
  }
  int v4 = malloc_type_malloc(size, 0xE8C0764CuLL);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  bzero(v4, size);
  uint64_t v6 = File::BufferedWrite(this, v5, size);
  free(v5);
  return v6;
}

void File::File(File *this, int a2, uint64_t a3)
{
  *(void *)this = &unk_1EF487078;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 515) = a2;
  *((void *)this + 258) = a3;
}

void File::HandleWriteOperationResults(File *this, uint64_t a2)
{
  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(1uLL);
  }
}

void File::AppendCString(File *this, char *__s)
{
  size_t v4 = strlen(__s);
  uint64_t v5 = (File *)File::BufferedWrite(this, __s, v4);
  File::HandleWriteOperationResults(v5, (uint64_t)v5);
}

uint64_t File::AppendAsPString(uint64_t a1, char *__s, int a3)
{
  size_t v6 = strlen(__s);
  if (v6 >= 0x100)
  {
    exception = __cxa_allocate_exception(1uLL);
  }
  size_t v7 = v6;
  (*(void (**)(uint64_t, void))(*(void *)a1 + 64))(a1, v6);
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, size_t))(*(void *)a1 + 48))(a1, __s, v7);
  if (a3 == 2)
  {
LABEL_8:
    unsigned int v9 = *(uint64_t (**)(uint64_t, void))(*(void *)a1 + 64);
    return v9(a1, 0);
  }
  else if (a3 == 4)
  {
    switch((v7 + 1) & 3)
    {
      case 1:
        (*(void (**)(uint64_t, void))(*(void *)a1 + 64))(a1, 0);
        goto LABEL_7;
      case 2:
LABEL_7:
        (*(void (**)(uint64_t, void))(*(void *)a1 + 64))(a1, 0);
        goto LABEL_8;
      case 3:
        goto LABEL_8;
      default:
        return result;
    }
  }
  return result;
}

void File::AppendUTF16String(File *this, unsigned __int16 *a2, unsigned int a3)
{
  appended = (File *)File::AppendUTF16StringCore(this, a2, a3);
  File::HandleWriteOperationResults(appended, (uint64_t)appended);
}

void File::AppendBytes(File *this, void *a2, int64_t a3)
{
  uint64_t v3 = (File *)File::BufferedWrite(this, a2, a3);
  File::HandleWriteOperationResults(v3, (uint64_t)v3);
}

void File::AppendZeros(File *this, size_t a2)
{
  appended = (File *)File::AppendZerosCore(this, a2);
  File::HandleWriteOperationResults(appended, (uint64_t)appended);
}

void File::AppendUInt8(File *this, char a2)
{
  char v3 = a2;
  id v2 = (File *)File::BufferedWrite(this, &v3, 1);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

void File::AppendUInt16(File *this, __int16 a2)
{
  __int16 v3 = a2;
  if (*((void *)this + 258) != 1) {
    __int16 v3 = __rev16(a2);
  }
  id v2 = (File *)File::BufferedWrite(this, &v3, 2);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

void File::AppendUInt32(File *this, unsigned int a2)
{
  unsigned int v3 = a2;
  if (*((void *)this + 258) != 1) {
    unsigned int v3 = bswap32(a2);
  }
  id v2 = (File *)File::BufferedWrite(this, &v3, 4);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

void File::AppendFloat64(File *this, double a2)
{
  unint64_t v3 = *(void *)&a2;
  if (*((void *)this + 258) != 1) {
    unint64_t v3 = bswap64(*(unint64_t *)&a2);
  }
  id v2 = (File *)File::BufferedWrite(this, &v3, 8);
  File::HandleWriteOperationResults(v2, (uint64_t)v2);
}

size_t ByteCounter::AppendAsPString(uint64_t a1, char *__s, int a3)
{
  size_t result = strlen(__s);
  if (result >= 0x100)
  {
    exception = __cxa_allocate_exception(1uLL);
  }
  uint64_t v6 = result + *(void *)(a1 + 2072) + 1;
  *(void *)(a1 + 2072) = v6;
  if (a3 == 2)
  {
LABEL_6:
    uint64_t v7 = 1;
LABEL_7:
    *(void *)(a1 + 2072) = v6 + v7;
  }
  else if (a3 == 4)
  {
    uint64_t v7 = 3;
    switch(((_BYTE)result + 1) & 3)
    {
      case 1:
        goto LABEL_7;
      case 2:
        uint64_t v7 = 2;
        goto LABEL_7;
      case 3:
        goto LABEL_6;
      default:
        return result;
    }
  }
  return result;
}

void File::~File(File *this)
{
  File::~File(this);
  JUMPOUT(0x1A6230DF0);
}

{
  int v2;
  size_t v3;

  *(void *)this = &unk_1EF487078;
  id v2 = *((_DWORD *)this + 515);
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)this + 2);
    if (v3)
    {
      write(v2, (char *)this + 12, v3);
      *((_DWORD *)this + 2) = 0;
    }
  }
}

uint64_t File::GetCurrentBytePosition(File *this)
{
  return *((_DWORD *)this + 2) + SetFilePointer(*((_DWORD *)this + 515), 0, 0, 1);
}

void ByteCounter::~ByteCounter(ByteCounter *this)
{
  File::~File(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t ByteCounter::GetCurrentBytePosition(ByteCounter *this)
{
  return *((void *)this + 259);
}

size_t ByteCounter::AppendCString(ByteCounter *this, char *__s)
{
  size_t result = strlen(__s);
  *((void *)this + 259) += result;
  return result;
}

uint64_t ByteCounter::AppendUTF16String(uint64_t this, unsigned __int16 *a2, int a3)
{
  *(void *)(this + 2072) += (2 * a3);
  return this;
}

uint64_t ByteCounter::AppendBytes(uint64_t this, void *a2, uint64_t a3)
{
  *(void *)(this + 2072) += a3;
  return this;
}

uint64_t ByteCounter::AppendZeros(uint64_t this, uint64_t a2)
{
  *(void *)(this + 2072) += a2;
  return this;
}

uint64_t ByteCounter::AppendUInt8(uint64_t this)
{
  return this;
}

uint64_t ByteCounter::AppendUInt16(uint64_t this)
{
  *(void *)(this + 2072) += 2;
  return this;
}

uint64_t ByteCounter::AppendUInt32(uint64_t this)
{
  *(void *)(this + 2072) += 4;
  return this;
}

uint64_t ByteCounter::AppendFloat64(uint64_t this, double a2)
{
  *(void *)(this + 2072) += 8;
  return this;
}

void __clang_call_terminate(void *a1)
{
}

__CFData *CUIImageCompressedWithJPEGandLZFSE(CGImageRef image, _DWORD *a2, __int16 *a3, size_t *a4, double a5)
{
  CGImageRef v9 = image;
  BOOL v10 = a5 > 1.0 || a5 <= 0.0;
  if (a2) {
    *a2 = 1095911234;
  }
  if (a3) {
    *a3 = 1;
  }
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent < 9) {
    goto LABEL_20;
  }
  ColorSpace = CGImageGetColorSpace(v9);
  if (CGColorSpaceGetModel(ColorSpace))
  {
    __int16 v13 = CGColorSpaceCreateWithName(kCGColorSpaceDisplayP3);
    if (a2) {
      *a2 = 1095911234;
    }
    if (a3)
    {
      __int16 v14 = 3;
LABEL_18:
      *a3 = v14;
    }
  }
  else
  {
    __int16 v13 = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
    if (a2) {
      *a2 = 1195456544;
    }
    if (a3)
    {
      __int16 v14 = 2;
      goto LABEL_18;
    }
  }
  CGImageRef v9 = CUIConvertDeepImageTo8(v9, v13);
  CFRelease(v13);
  if (!v9) {
    return 0;
  }
LABEL_20:
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(v9);
  __int16 BitmapInfo = CGImageGetBitmapInfo(v9);
  unsigned int Width = CGImageGetWidth(v9);
  *(void *)bytes = 0;
  CFIndex length = 0;
  unsigned int v56 = 0;
  if (AlphaInfo > kCGImageAlphaNoneSkipFirst)
  {
    _CUILog(4, (uint64_t)"CoreUI: need to do something here", v17, v18, v19, v20, v21, v22, (uint64_t)v49.data);
    uint64_t v24 = 0;
LABEL_31:
    int v25 = 32;
    int v26 = 1;
    CGImageAlphaInfo AlphaInfo = kCGImageAlphaNoneSkipLast;
    goto LABEL_32;
  }
  if (((1 << AlphaInfo) & 0x2A) != 0)
  {
    if ((BitmapInfo & 0x7000) == 0x2000) {
      uint64_t v24 = 0;
    }
    else {
      uint64_t v24 = 3;
    }
    goto LABEL_31;
  }
  if (((1 << AlphaInfo) & 0x54) != 0)
  {
    if ((BitmapInfo & 0x7000) == 0x2000) {
      uint64_t v24 = 3;
    }
    else {
      uint64_t v24 = 0;
    }
    int v25 = 32;
    int v26 = 1;
    CGImageAlphaInfo AlphaInfo = kCGImageAlphaNoneSkipFirst;
  }
  else
  {
    int v26 = 0;
    uint64_t v24 = AlphaInfo;
    int v25 = 24;
  }
LABEL_32:
  memset(&src, 0, sizeof(src));
  memset(&v49, 0, sizeof(v49));
  LODWORD(space[0]) = 8;
  HIDWORD(space[0]) = v25;
  space[1] = CGImageGetColorSpace(v9);
  CGImageAlphaInfo v27 = CGImageGetAlphaInfo(v9);
  CGBitmapInfo v28 = CGImageGetBitmapInfo(v9);
  char v29 = v28 | v27;
  unsigned long long v51 = v28 | (unsigned __int128)v27;
  uint64_t RenderingIntent = CGImageGetRenderingIntent(v9);
  uint64_t v30 = MEMORY[0x1A6231AB0](&src, space, 0, v9, 256);
  if (BitsPerComponent >= 9) {
    CGImageRelease(v9);
  }
  if (v30) {
    return 0;
  }
  LODWORD(v51) = v51 & ~(v29 & 0x1F) | AlphaInfo;
  int v33 = (CGImage *)MEMORY[0x1A6231B60](&src, space, 0, 0, 0, 0);
  if (!v33) {
    return 0;
  }
  uint64_t v34 = v33;
  if (a4) {
    *a4 = CGImageGetBytesPerRow(v33);
  }
  float v35 = a5;
  uint64_t v36 = CGImageGetColorSpace(v34);
  if (v36 != space[1])
  {
    CGImageRef CopyWithColorSpace = CGImageCreateCopyWithColorSpace(v34, space[1]);
    CGImageRelease(v34);
    uint64_t v34 = CopyWithColorSpace;
  }
  space[1] = 0;
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  v59[0] = kCGImageMetadataShouldExcludeXMP;
  v59[1] = @"kCGImageMetadataShouldExcludeGPS";
  v60[0] = &unk_1EF4A69B8;
  v60[1] = &unk_1EF4A69B8;
  uint64_t v39 = CGImageDestinationCreateWithData(Mutable, @"public.jpeg", 1uLL, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v60, v59, 2, v49.data, v49.height, *(_OWORD *)&v49.width, space[0]));
  v57[0] = kCGImageDestinationLossyCompressionQuality;
  LODWORD(v40) = *(_DWORD *)"fff?";
  if (!v10) {
    *(float *)&double v40 = v35;
  }
  v58[0] = +[NSNumber numberWithFloat:v40];
  v58[1] = &unk_1EF4A69B8;
  v57[1] = @"kCGImageDestinationChromaSubSamplingX";
  v57[2] = @"kCGImageDestinationChromaSubSamplingY";
  v58[2] = &unk_1EF4A69B8;
  CGImageDestinationAddImage(v39, v34, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:v58 forKeys:v57 count:3]);
  CGImageDestinationFinalize(v39);
  CFRelease(v34);
  *(_DWORD *)bytes = 0;
  unsigned int v41 = CFDataGetLength(Mutable);
  HIDWORD(length) = Width;
  unsigned int v56 = v41;
  uint64_t v42 = Width;
  uint64_t v43 = (uint8_t *)malloc_type_malloc(src.height * Width, 0x8E4428C2uLL);
  __CFSetLastAllocationEventName();
  uint64_t v44 = 0;
  LODWORD(length) = 0;
  if (!v26) {
    goto LABEL_50;
  }
  v49.height = src.height;
  v49.width = src.width;
  v49.rowBytes = src.width;
  v49.data = malloc_type_malloc(src.width * src.height, 0xF57DD6EEuLL);
  __CFSetLastAllocationEventName();
  if (!vImageExtractChannel_ARGB8888(&src, &v49, v24, 0x100u))
  {
    unsigned int v45 = compression_encode_buffer(v43, src.height * v42, (const uint8_t *)v49.data, v49.rowBytes * v49.height, 0, COMPRESSION_LZFSE);
    LODWORD(length) = v45;
    if (v45)
    {
      free(v49.data);
      uint64_t v44 = v45;
LABEL_50:
      uint64_t v31 = CFDataCreateMutable(kCFAllocatorDefault, v44 + v41 + 20);
      CFDataAppendBytes(v31, bytes, 20);
      CFDataAppendBytes(v31, v43, length);
      BytePtr = CFDataGetBytePtr(Mutable);
      CFIndex v47 = CFDataGetLength(Mutable);
      CFDataAppendBytes(v31, BytePtr, v47);
      goto LABEL_51;
    }
  }
  free(v49.data);
  uint64_t v31 = 0;
LABEL_51:
  free(src.data);
  free(v43);
  CFRelease(v39);
  CFRelease(Mutable);
  if (v31)
  {
    CFIndex v48 = CFDataGetLength(v31);
    if (v48 > (int64_t)(src.height * HIDWORD(length)))
    {
      CFRelease(v31);
      return 0;
    }
  }
  return v31;
}

BOOL CUIUncompressJPEGandLZFSEInfoData(const UInt8 *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 1))
  {
    _CUILog(4, (uint64_t)"CoreUI: not expecting to a JPEG-LZFSE image with a chunk count != 0", a3, a4, a5, a6, a7, a8, v46);
    return 0;
  }
  else
  {
    int v9 = a6;
    int v10 = a5;
    int v11 = a4;
    CFDataRef v15 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, &a1[*((unsigned int *)a1 + 2) + 20], *((unsigned int *)a1 + 4), kCFAllocatorNull);
    uint64_t v16 = CGImageSourceCreateWithData(v15, 0);
    if (v16)
    {
      uint64_t v17 = v16;
      ImageAtIndex = CGImageSourceCreateImageAtIndex(v16, 0, 0);
      BOOL v8 = (BOOL)ImageAtIndex;
      if (ImageAtIndex)
      {
        uint64_t v80 = 0;
        id v81 = &v80;
        uint64_t v82 = 0x2020000000;
        uint64_t v83 = 0;
        uint64_t v74 = 0;
        id v75 = (const vImage_Buffer *)&v74;
        uint64_t v76 = 0x4010000000;
        unint64_t v77 = &unk_1A13C9C2D;
        long long v78 = 0u;
        long long v79 = 0u;
        uint64_t v64 = 0;
        uint64_t v65 = &v64;
        uint64_t v66 = 0x4810000000;
        uint64_t v67 = &unk_1A13C9C2D;
        uint64_t v70 = 0;
        long long v73 = 0u;
        memset(&newSrc, 0, sizeof(newSrc));
        uint64_t v59 = 0;
        size_t v60 = &v59;
        uint64_t v61 = 0x2020000000;
        uint64_t v62 = 0;
        uint64_t v55 = 0;
        unsigned int v56 = &v55;
        uint64_t v57 = 0x2020000000;
        uint64_t v58 = 0;
        uint64_t v51 = 0;
        uint64_t v52 = &v51;
        uint64_t v53 = 0x2020000000;
        char v54 = 0;
        int v68 = v11;
        int v69 = v10;
        int v71 = v9;
        int v72 = 0;
        *(void *)&long long v73 = 0;
        CGColorSpaceRef ColorSpace = CGImageGetColorSpace(ImageAtIndex);
        int v26 = v65;
        v65[5] = (uint64_t)ColorSpace;
        *((_DWORD *)v26 + 16) = 0;
        CGImageAlphaInfo v27 = v75;
        v75[1].rowBytes = a3;
        v27[1].data = a2;
        v50[0] = _NSConcreteStackBlock;
        v50[1] = 3221225472;
        void v50[2] = __CUIUncompressJPEGandLZFSEInfoData_block_invoke;
        v50[3] = &unk_1E5A51958;
        v50[4] = &v80;
        v50[5] = &v74;
        v50[6] = &v64;
        v50[7] = v8;
        v48[0] = _NSConcreteStackBlock;
        v48[1] = 3221225472;
        v48[2] = __CUIUncompressJPEGandLZFSEInfoData_block_invoke_2;
        void v48[3] = &unk_1E5A51980;
        int v49 = v9;
        v48[4] = &v51;
        v48[5] = &v55;
        v48[8] = v8;
        v48[9] = a1;
        v48[6] = &v59;
        v48[7] = a1;
        id v28 = objc_alloc_init((Class)NSMutableArray);
        [v28 addObject:v50];
        [v28 addObject:v48];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = __CUIUncompressJPEGandLZFSEInfoData_block_invoke_3;
        block[3] = &unk_1E5A519A8;
        block[4] = v28;
        dispatch_apply((size_t)[v28 count], 0, block);

        if (!v60[3] || v81[3])
        {
          _CUILog(4, (uint64_t)"CoreUI: Couldn't decompress the alpha channel or decode JPEG of a JPEG-LZFSE image %zu:%zd", v29, v30, v31, v32, v33, v34, v60[3]);
        }
        else
        {
          newSrc.data = (void *)v56[3];
          newSrc.height = CGImageGetHeight((CGImageRef)v8);
          vImagePixelCount Width = CGImageGetWidth((CGImageRef)v8);
          size_t v36 = *((unsigned int *)a1 + 3);
          newSrc.width = Width;
          newSrc.rowBytes = v36;
          vImage_Error v37 = vImageOverwriteChannels_ARGB8888(&newSrc, v75 + 1, v75 + 1, *((unsigned char *)v52 + 24), 0x10u);
          v81[3] = v37;
          if (v37)
          {
            _CUILog(4, (uint64_t)"CoreUI: Couldn't clip to alpha of a JPEG-LZFSE image %zd", v38, v39, v40, v41, v42, v43, v37);
          }
          else
          {
            vImage_Error v44 = vImageClipToAlpha_RGBA8888(v75 + 1, v75 + 1, 0x10u);
            v81[3] = v44;
          }
        }
        free((void *)v56[3]);
        CFRelease((CFTypeRef)v8);
        if (v60[3]) {
          BOOL v8 = v81[3] == 0;
        }
        else {
          BOOL v8 = 0;
        }
        _Block_object_dispose(&v51, 8);
        _Block_object_dispose(&v55, 8);
        _Block_object_dispose(&v59, 8);
        _Block_object_dispose(&v64, 8);
        _Block_object_dispose(&v74, 8);
        _Block_object_dispose(&v80, 8);
      }
      else
      {
        _CUILog(4, (uint64_t)"CoreUI: Couldn't get the jpeg CGImageFrom from the data of a JPEG-LZFSE image", v19, v20, v21, v22, v23, v24, v46);
      }
      CFRelease(v17);
    }
    else
    {
      BOOL v8 = 0;
    }
    CFRelease(v15);
  }
  return v8;
}

void sub_1A131C5E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a52, 8);
  _Block_object_dispose((const void *)(v52 - 208), 8);
  _Block_object_dispose((const void *)(v52 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t __CUIUncompressJPEGandLZFSEInfoData_block_invoke(void *a1)
{
  uint64_t result = MEMORY[0x1A6231AB0](*(void *)(a1[5] + 8) + 32, *(void *)(a1[6] + 8) + 32, 0, a1[7], 768);
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

void __CUIUncompressJPEGandLZFSEInfoData_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = *(_DWORD *)(a1 + 80);
  if ((v9 & 0x1Fu) <= 6)
  {
    int v11 = 1 << (v9 & 0x1F);
    if ((v11 & 0x2A) != 0)
    {
      int v15 = v9 & 0x7000;
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
      if (v15 == 0x2000)
      {
LABEL_5:
        char v14 = 8;
LABEL_8:
        *(unsigned char *)(v13 + 24) = v14;
        uint64_t v16 = (const uint8_t *)(*(void *)(a1 + 56) + 20);
        size_t Height = CGImageGetHeight(*(CGImageRef *)(a1 + 64));
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = malloc_type_malloc(Height* *(unsigned int *)(*(void *)(a1 + 72) + 12), 0x582AC792uLL);
        __CFSetLastAllocationEventName();
        uint64_t v18 = *(uint8_t **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        size_t v19 = CGImageGetHeight(*(CGImageRef *)(a1 + 64));
        *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = compression_decode_buffer(v18, v19* *(unsigned int *)(*(void *)(a1 + 72) + 12), v16, *(unsigned int *)(*(void *)(a1 + 72) + 8), 0, COMPRESSION_LZFSE);
        return;
      }
    }
    else
    {
      if ((v11 & 0x54) == 0) {
        return;
      }
      int v12 = v9 & 0x7000;
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
      if (v12 != 0x2000) {
        goto LABEL_5;
      }
    }
    char v14 = 1;
    goto LABEL_8;
  }
  _CUILog(4, (uint64_t)"CoreUI: not expecting to get an AlphaOnly image don't know how to handle this", a3, a4, a5, a6, a7, a8, a9);
}

uint64_t __CUIUncompressJPEGandLZFSEInfoData_block_invoke_3(uint64_t a1, uint64_t a2)
{
  id v2 = (uint64_t (*)(void))*((void *)[*(id *)(a1 + 32) objectAtIndex:a2] + 2);
  return v2();
}

void _CUISetPattern(CGContext *a1, CGPattern *a2)
{
  if (a2)
  {
    CGFloat components = 1.0;
    Pattern = CGColorSpaceCreatePattern(0);
    CGContextSetFillColorSpace(a1, Pattern);
    CGContextSetFillPattern(a1, a2, &components);
    CGContextSetStrokeColorSpace(a1, Pattern);
    CGContextSetStrokePattern(a1, a2, &components);
    CGColorSpaceRelease(Pattern);
  }
}

void drawPatternBitmap(CGImageRef image, CGContextRef c)
{
  v2.origin.x = 0.0;
  v2.origin.y = 0.0;
  v2.size.width = 1.0;
  v2.size.height = 1.0;
  CGContextDrawImage(c, v2, image);
}

__CFData *__CUIImageCompressedWithDeepmap2(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v20 = 0;
  uint64_t v21 = a3;
  int v22 = a4;
  uint64_t Buffer = vImageDeepmap2EncodeCreateBuffer();
  if (!Buffer)
  {
    char v14 = "CoreUI: vImageDeepmap2EncodeCreateBuffer() returned 0.";
LABEL_7:
    _CUILog(4, (uint64_t)v14, v6, v7, v8, v9, v10, v11, v16);
    return 0;
  }
  CFIndex v12 = Buffer;
  [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"CFDataRef __CUIImageCompressedWithDeepmap2(vImage_Buffer, vImageDeepmap2PixelFormat, vImageDeepmap2CompressionOptions)"] file:@"CUIDeepmap2Compression.m" lineNumber:173 description:@"Expects non-null pointer."];
  if ((v21 - 1) >= 4)
  {
    uint64_t v16 = v21;
    char v14 = "CoreUI: vImageDeepmap2EncodeCreateBuffer() returned unrecognized compression method: %lu [%s]";
    goto LABEL_7;
  }
  *(_DWORD *)bytes = 1;
  int v18 = a2;
  CFIndex v19 = v12;
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, v12 + 16);
  CFDataAppendBytes(Mutable, bytes, 16);
  CFDataAppendBytes(Mutable, v20, v12);
  free(v20);
  return Mutable;
}

id CUIImageCompressedWithDeepmap2(unsigned int *a1, void *a2, uint64_t a3, _DWORD *a4, __int16 *a5, uint64_t *a6, _DWORD *a7, uint64_t a8)
{
  if (!*a2 || !a2[3] || !a2[2] || !a2[1])
  {
    _CUILog(4, (uint64_t)"CoreUI: invalid input image buffer in %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap2(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
    return 0;
  }
  if (*a1 != 8 && *a1 != 16)
  {
    _CUILog(4, (uint64_t)"CoreUI: unsupported bpc for Deepmap 2.0 compression: %d [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, *a1);
    return 0;
  }
  if (!*((void *)a1 + 1))
  {
    _CUILog(4, (uint64_t)"CoreUI: Missing image color space to perform Deemap 2.0 compression [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap2(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
    return 0;
  }
  if ((int)a3 > 1195456543)
  {
    if (a3 == 1195456544)
    {
      __int16 v11 = 2;
      int v10 = 2;
      goto LABEL_22;
    }
    if (a3 == 1380401751)
    {
      int v10 = 20;
      __int16 v11 = 4;
      goto LABEL_22;
    }
LABEL_27:
    _CUILog(4, (uint64_t)"CoreUI: Unrecognized input pixel format: %d [%s]", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, a3);
    return 0;
  }
  if (a3 == 1095911234)
  {
    int v10 = 4;
    __int16 v11 = 1;
    goto LABEL_22;
  }
  if (a3 != 1195454774) {
    goto LABEL_27;
  }
  int v10 = 18;
  __int16 v11 = 6;
LABEL_22:
  *a4 = a3;
  *a5 = v11;
  *a6 = CGBitmapGetAlignedBytesPerRow();
  id v12 = objc_alloc_init((Class)NSMutableArray);
  unint64_t v15 = a2[1];
  unint64_t v14 = a2[2];
  if (v15 * v14 < 0x100000)
  {
    long long v17 = *((_OWORD *)a2 + 1);
    long long v31 = *(_OWORD *)a2;
    long long v32 = v17;
    int v18 = __CUIImageCompressedWithDeepmap2((uint64_t)&v31, v10, 0x100000000, 10);
    if (v18)
    {
      int v25 = v18;
      [v12 addObject:v18];
      CFRelease(v25);
      *a7 = a2[1];
      return v12;
    }
  }
  else
  {
    if (v14 <= 0x100000) {
      unint64_t v16 = 0x100000 / v14;
    }
    else {
      unint64_t v16 = 1;
    }
    if (!v15)
    {
LABEL_36:
      *a7 = v16;
      return v12;
    }
    uint64_t v26 = *a2;
    while (1)
    {
      unint64_t v27 = v15 >= v16 ? v16 : v15;
      *a2 = v26;
      a2[1] = v27;
      long long v28 = *((_OWORD *)a2 + 1);
      long long v31 = *(_OWORD *)a2;
      long long v32 = v28;
      uint64_t v29 = __CUIImageCompressedWithDeepmap2((uint64_t)&v31, v10, 0x100000000, 10);
      if (!v29) {
        break;
      }
      uint64_t v30 = v29;
      [v12 addObject:v29];
      CFRelease(v30);
      v26 += a2[3] * v27;
      v15 -= v27;
      if (!v15) {
        goto LABEL_36;
      }
    }
  }
  _CUILog(4, (uint64_t)"CoreUI: Deepmap 2.0 compressed failed in %s [%s:%lu]", v19, v20, v21, v22, v23, v24, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap2(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");

  return 0;
}

uint64_t __CUIUncompressDeepmap2ImageData_block_invoke_2(uint64_t a1, uint64_t a2)
{
  CGRect v2 = (uint64_t (*)(void))*((void *)[*(id *)(a1 + 32) objectAtIndex:a2] + 2);
  return v2();
}

uint64_t _CUIColorSpaceGetGenericRGB()
{
  if (_CUIColorSpaceGetGenericRGB___once != -1) {
    dispatch_once(&_CUIColorSpaceGetGenericRGB___once, &__block_literal_global_1);
  }
  return _CUIColorSpaceGetGenericRGB_sGenericRGBColorSpace;
}

uint64_t _CUIColorSpaceGetExtendedRangeSRGB()
{
  if (_CUIColorSpaceGetExtendedRangeSRGB___once != -1) {
    dispatch_once(&_CUIColorSpaceGetExtendedRangeSRGB___once, &__block_literal_global_12);
  }
  return _CUIColorSpaceGetExtendedRangeSRGB_sExtendedRangeSRGBColorSpace;
}

uint64_t _CUIColorSpaceGetExtendedGray()
{
  if (_CUIColorSpaceGetExtendedGray___once != -1) {
    dispatch_once(&_CUIColorSpaceGetExtendedGray___once, &__block_literal_global_18);
  }
  return _CUIColorSpaceGetExtendedGray_sExtendedGrayColorSpace;
}

uint64_t _CUIColorSpaceGetExtendedLinearSRGB()
{
  if (_CUIColorSpaceGetExtendedLinearSRGB___once != -1) {
    dispatch_once(&_CUIColorSpaceGetExtendedLinearSRGB___once, &__block_literal_global_21);
  }
  return _CUIColorSpaceGetExtendedLinearSRGB_sExtendedLinearSRGBColorSpace;
}

uint64_t _CUIColorGetSRGBClear()
{
  if (_CUIColorGetSRGBClear_onceToken != -1) {
    dispatch_once(&_CUIColorGetSRGBClear_onceToken, &__block_literal_global_40);
  }
  return _CUIColorGetSRGBClear_sClearColor;
}

const char *__SetBoolConfigFromEnvironment(BOOL *a1, char *a2)
{
  uint64_t result = getenv(a2);
  if (result)
  {
    size_t v4 = result;
    uint64_t result = (const char *)strncasecmp(result, "NO", 2uLL);
    if (result)
    {
      uint64_t result = (const char *)strncasecmp(v4, "0", 1uLL);
      BOOL v5 = result != 0;
      if (!a1) {
        return result;
      }
    }
    else
    {
      BOOL v5 = 0;
      if (!a1) {
        return result;
      }
    }
    *a1 = v5;
  }
  return result;
}

uint64_t __sliceSort(void *a1, void *a2)
{
  [a1 rectValue];
  double v4 = v3;
  double v6 = v5;
  double v8 = v7;
  double v10 = v9;
  [a2 rectValue];
  double v12 = v6 + v10;
  double v15 = v13 + v14;
  double v16 = v4 + v8;
  double v18 = v11 + v17;
  uint64_t v19 = -1;
  if (v6 < v13) {
    uint64_t v20 = 1;
  }
  else {
    uint64_t v20 = -1;
  }
  if (v16 > v18) {
    uint64_t v21 = 1;
  }
  else {
    uint64_t v21 = -1;
  }
  if (v16 != v18) {
    uint64_t v20 = v21;
  }
  if (v4 >= v11) {
    uint64_t v22 = 1;
  }
  else {
    uint64_t v22 = -1;
  }
  if (v4 != v11) {
    uint64_t v20 = v22;
  }
  if (v12 < v15) {
    uint64_t v19 = 1;
  }
  if (v12 == v15) {
    return v20;
  }
  else {
    return v19;
  }
}

char *CUIConvertCompressionTypeToString(unsigned int a1)
{
  if (a1 > 0xC) {
    return 0;
  }
  else {
    return off_1E5A51B50[a1];
  }
}

const char *CUIConvertPixelFormatToString(int a1)
{
  if (a1 > 1246774598)
  {
    if (a1 <= 1380401716)
    {
      if (a1 == 1246774599) {
        return "JPEG";
      }
      if (a1 == 1346651680) {
        return "PDF";
      }
    }
    else
    {
      switch(a1)
      {
        case 1380401717:
          return "RGB5";
        case 1398163232:
          return "SVG";
        case 1380401751:
          return "RGBW";
      }
    }
  }
  else if (a1 <= 1195454773)
  {
    if (a1 == 1095911234) {
      return "ARGB";
    }
    if (a1 == 1145132097) {
      return "DATA";
    }
  }
  else
  {
    switch(a1)
    {
      case 1195454774:
        return "GA16";
      case 1195456544:
        return "GA8";
      case 1212500294:
        return "HEIF";
    }
  }
  return "(Unknown)";
}

uint64_t CUILogLogToStderr(uint64_t result)
{
  __logToStderr = result;
  return result;
}

uint64_t CUILogHandle()
{
  if (__onceToken != -1) {
    dispatch_once(&__onceToken, &__block_literal_global_3);
  }
  return __handle;
}

uint64_t CUILogEnableRenditionLog(uint64_t result)
{
  __renditionLogginEnabled = result;
  return result;
}

BOOL CSIEqualMetrics(uint64_t a1, uint64_t a2)
{
  if (!NSEqualSizes(*(NSSize *)a1, *(NSSize *)a2) || !NSEqualSizes(*(NSSize *)(a1 + 16), *(NSSize *)(a2 + 16))) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = *(void *)(a2 + 40);
  return NSEqualSizes(*(NSSize *)&v4, *(NSSize *)&v6);
}

void sub_1A1323674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class initMDLMaterial()
{
  __NSGetFrameworkReference();
  Class result = objc_getClass("MDLMaterial");
  classMDLMaterial = (uint64_t)result;
  if (!result) {
    initMDLMaterial_cold_1();
  }
  getMDLMaterialClass = MDLMaterialFunction;
  return result;
}

void __NSGetFrameworkReference()
{
  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
  id v0 = [(id)__NSGetFrameworkReference_table objectForKey:@"ModelIO"];
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
  if (!v0)
  {
    uint64_t v1 = __NSLoadFramework(@"ModelIO");
    if (v1)
    {
      CGRect v2 = v1;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
      id v3 = (id)__NSGetFrameworkReference_table;
      if (!__NSGetFrameworkReference_table)
      {
        id v3 = [objc_alloc((Class)NSMapTable) initWithKeyOptions:0 valueOptions:2 capacity:0];
        __NSGetFrameworkReference_table = (uint64_t)v3;
      }
      if (![v3 objectForKey:@"ModelIO"]) {
        [(id)__NSGetFrameworkReference_table setObject:v2 forKey:@"ModelIO"];
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock);
    }
  }
}

const char *__NSLoadFramework(void *a1)
{
  uint64_t v7 = 0;
  v8[0] = 0;
  v8[1] = 0;
  if (a1)
  {
    Class result = (const char *)[a1 UTF8String];
    CGRect v2 = result;
    if (!result) {
      return result;
    }
  }
  else
  {
    CGRect v2 = "AppKit";
  }
  id v3 = (const char **)v8;
  uint64_t v4 = "/System/Library/Frameworks/";
  while (1)
  {
    if (snprintf(__str, 0x400uLL, "%s%s.framework/%s", v4, v2, v2) <= 1023)
    {
      Class result = (const char *)dlopen(__str, 2);
      if (result) {
        break;
      }
    }
    uint64_t v5 = *v3++;
    uint64_t v4 = v5;
    if (!v5) {
      return 0;
    }
  }
  return result;
}

uint64_t MDLMaterialFunction()
{
  return classMDLMaterial;
}

Class initMDLTexture()
{
  __NSGetFrameworkReference();
  Class result = objc_getClass("MDLTexture");
  classMDLTexture = (uint64_t)result;
  if (!result) {
    initMDLTexture_cold_1();
  }
  getMDLTextureClass = MDLTextureFunction;
  return result;
}

uint64_t MDLTextureFunction()
{
  return classMDLTexture;
}

Class initMDLTextureSampler()
{
  __NSGetFrameworkReference();
  Class result = objc_getClass("MDLTextureSampler");
  classMDLTextureSampler = (uint64_t)result;
  if (!result) {
    initMDLTextureSampler_cold_1();
  }
  getMDLTextureSamplerClass = MDLTextureSamplerFunction;
  return result;
}

uint64_t MDLTextureSamplerFunction()
{
  return classMDLTextureSampler;
}

Class initMDLMaterialProperty()
{
  __NSGetFrameworkReference();
  Class result = objc_getClass("MDLMaterialProperty");
  classMDLMaterialProperty = (uint64_t)result;
  if (!result) {
    initMDLMaterialProperty_cold_1();
  }
  getMDLMaterialPropertyClass = MDLMaterialPropertyFunction;
  return result;
}

uint64_t MDLMaterialPropertyFunction()
{
  return classMDLMaterialProperty;
}

Class initMDLSubmesh()
{
  __NSGetFrameworkReference();
  Class result = objc_getClass("MDLSubmesh");
  classMDLSubmesh = (uint64_t)result;
  if (!result) {
    initMDLSubmesh_cold_1();
  }
  getMDLSubmeshClass = MDLSubmeshFunction;
  return result;
}

uint64_t MDLSubmeshFunction()
{
  return classMDLSubmesh;
}

__CFData *CUIImageCompressedWithATECompression(CGImageRef image, uint64_t a2, unint64_t a3, _DWORD *a4, _DWORD *a5, _WORD *a6)
{
  CGImageRef v10 = image;
  int v80 = 0;
  *(void *)bytes = 0;
  if (a5) {
    *a5 = 1095911234;
  }
  if (a6) {
    *a6 = 1;
  }
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent >= 9)
  {
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(v10);
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
    double v14 = (CFStringRef *)&kCGColorSpaceGenericGrayGamma2_2;
    if (Model) {
      double v14 = (CFStringRef *)&kCGColorSpaceDisplayP3;
    }
    double v15 = CGColorSpaceCreateWithName(*v14);
    CGImageRef v10 = CUIConvertDeepImageTo8(v10, v15);
    CFRelease(v15);
    if (a6) {
      *a6 = 3;
    }
    if (!v10) {
      return 0;
    }
  }
  CFDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (a3 <= 5 && ((1 << a3) & 0x3A) != 0)
  {
    *a4 = 7;
    *(_OWORD *)cf = 0u;
    memset(v95, 0, 24);
    if (a2 == 4) {
      at_block_format_t v17 = at_block_format_astc_4x4_ldr;
    }
    else {
      at_block_format_t v17 = at_block_format_astc_8x8_ldr;
    }
    double v18 = CGImageGetColorSpace(v10);
    CGColorSpaceModel v19 = CGColorSpaceGetModel(v18);
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(v10);
    if (CGImageGetBitsPerComponent(v10) < 9)
    {
      if (v19)
      {
        if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && ((1 << AlphaInfo) & 0x61) != 0)
        {
          cf[0] = (CFTypeRef)0x2000000008;
          cf[1] = CGImageGetColorSpace(v10);
          at_texel_format_t v21 = at_texel_format_rgba8_unorm;
          LODWORD(v95[0]) = 5;
          *(void *)((char *)v95 + 12) = 0;
          *(void *)((char *)v95 + 4) = 0;
          CFRetain(cf[1]);
        }
        else
        {
          cf[0] = (CFTypeRef)0x2000000008;
          cf[1] = CGImageGetColorSpace(v10);
          LODWORD(v95[0]) = 1;
          *(void *)((char *)v95 + 12) = 0;
          *(void *)((char *)v95 + 4) = 0;
          CFRetain(cf[1]);
          at_texel_format_t v21 = at_texel_format_rgba8_unorm;
        }
      }
      else if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && ((1 << AlphaInfo) & 0x61) != 0)
      {
        cf[0] = (CFTypeRef)0x800000008;
        memset(v95, 0, 20);
        cf[1] = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
        at_texel_format_t v21 = at_texel_format_l8_unorm;
      }
      else
      {
        cf[0] = (CFTypeRef)0x1000000008;
        cf[1] = CGColorSpaceCreateDeviceGray();
        LODWORD(v95[0]) = 1;
        *(void *)((char *)v95 + 12) = 0;
        *(void *)((char *)v95 + 4) = 0;
        at_texel_format_t v21 = at_texel_format_la8_unorm;
      }
    }
    else if (v19)
    {
      cf[0] = (CFTypeRef)0x4000000010;
      cf[1] = 0;
      LODWORD(v95[0]) = 4097;
      *(void *)((char *)v95 + 12) = 0;
      *(void *)((char *)v95 + 4) = 0;
      at_texel_format_t v21 = at_texel_format_rgba16_unorm;
    }
    else if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && ((1 << AlphaInfo) & 0x61) != 0)
    {
      cf[0] = (CFTypeRef)0x1000000010;
      cf[1] = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      LODWORD(v95[0]) = 4096;
      *(void *)((char *)v95 + 12) = 0;
      *(void *)((char *)v95 + 4) = 0;
      at_texel_format_t v21 = at_texel_format_l16_unorm;
    }
    else
    {
      cf[0] = (CFTypeRef)0x2000000010;
      cf[1] = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      LODWORD(v95[0]) = 4097;
      *(void *)((char *)v95 + 12) = 0;
      *(void *)((char *)v95 + 4) = 0;
      at_texel_format_t v21 = at_texel_format_la16_unorm;
    }
    *(_OWORD *)uint64_t v92 = 0u;
    long long v93 = 0u;
    *(void *)&src.validSize.uint32_t z = 0;
    uint64_t v28 = MEMORY[0x1A6231AB0](v92, cf, &__ASTC_encodeToData_backgroundColor, v10, 256);
    if (cf[1]) {
      CFRelease(cf[1]);
    }
    if (v28) {
      goto LABEL_72;
    }
    theData = Mutable;
    size_t v78 = BitsPerComponent;
    CFAllocatorRef v75 = kCFAllocatorDefault;
    if (AlphaInfo > kCGImageAlphaNoneSkipFirst) {
      at_alpha_t v38 = at_alpha_premultiplied;
    }
    else {
      at_alpha_t v38 = dword_1A139E200[AlphaInfo];
    }
    uint32_t Width = CGImageGetWidth(v10);
    uint32_t Height = CGImageGetHeight(v10);
    uint64_t v42 = at_encoder_create(v21, v38, v17, v38, 0);
    *(at_size_t *)&long long v43 = at_encoder_get_block_dimensions(v42);
    char v44 = v43;
    char v45 = BYTE8(v43);
    unint64_t v46 = DWORD1(v43);
    *((void *)&v43 + 1) = Width | ((unint64_t)Height << 32);
    int v47 = 1;
    at_size_t block_counts = at_encoder_get_block_counts(v42, *(at_size_t *)((char *)&v43 + 8));
    uint32_t x = block_counts.x;
    uint32_t z = block_counts.z;
    *(_DWORD *)uint64_t v83 = 1554098963;
    uint64_t v49 = HIDWORD(*(void *)&block_counts.x);
    char v84 = v44;
    char v85 = v46;
    char v86 = v45;
    __int16 v87 = Width;
    char v88 = BYTE2(Width);
    __int16 v89 = Height;
    char v90 = BYTE2(Height);
    *(_WORD *)uint64_t v91 = 1;
    v91[2] = 0;
    CFDataRef Mutable = theData;
    CFDataAppendBytes(theData, v83, 16);
    uint64_t v50 = v49 * x;
    size_t block_size = at_encoder_get_block_size(v42);
    CFDataIncreaseLength(theData, block_size * v50 * z);
    MutableBytePtr = CFDataGetMutableBytePtr(theData);
    size_t v53 = at_encoder_get_block_size(v42);
    src.texels = v92[0];
    src.validSize.uint32_t x = Width;
    src.validSize.y = Height;
    src.validSize.uint32_t z = 1;
    src.rowBytes = *((void *)&v93 + 1);
    src.sliceBytes = 0;
    dest.blocks = MutableBytePtr + 16;
    dest.rowBytes = v53 * x;
    dest.sliceBytes = v53 * v50;
    float v54 = at_encoder_compress_texels(v42, &src, &dest, 0.0, at_flags_default);
    free(v92[0]);
  }
  else
  {
    *a4 = 12;
    if (a2 == 4) {
      at_block_format_t v23 = at_block_format_bc7;
    }
    else {
      at_block_format_t v23 = at_block_format_bc3;
    }
    *(_OWORD *)cf = 0u;
    memset(v95, 0, 24);
    uint64_t v24 = CGImageGetColorSpace(v10);
    CGColorSpaceModel v25 = CGColorSpaceGetModel(v24);
    CGImageAlphaInfo v26 = CGImageGetAlphaInfo(v10);
    if (CGImageGetBitsPerComponent(v10) < 9)
    {
      if (v25)
      {
        if (v26 <= kCGImageAlphaNoneSkipFirst && ((1 << v26) & 0x61) != 0)
        {
          cf[0] = (CFTypeRef)0x2000000008;
          cf[1] = CGImageGetColorSpace(v10);
          at_texel_format_t v27 = at_texel_format_rgba8_unorm;
          LODWORD(v95[0]) = 5;
          *(void *)((char *)v95 + 12) = 0;
          *(void *)((char *)v95 + 4) = 0;
          CFRetain(cf[1]);
        }
        else
        {
          cf[0] = (CFTypeRef)0x2000000008;
          cf[1] = CGImageGetColorSpace(v10);
          LODWORD(v95[0]) = 1;
          *(void *)((char *)v95 + 12) = 0;
          *(void *)((char *)v95 + 4) = 0;
          CFRetain(cf[1]);
          at_texel_format_t v27 = at_texel_format_rgba8_unorm;
        }
      }
      else if (v26 <= kCGImageAlphaNoneSkipFirst && ((1 << v26) & 0x61) != 0)
      {
        cf[0] = (CFTypeRef)0x800000008;
        memset(v95, 0, 20);
        cf[1] = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
        at_texel_format_t v27 = at_texel_format_l8_unorm;
      }
      else
      {
        cf[0] = (CFTypeRef)0x1000000008;
        cf[1] = CGColorSpaceCreateDeviceGray();
        LODWORD(v95[0]) = 1;
        *(void *)((char *)v95 + 12) = 0;
        *(void *)((char *)v95 + 4) = 0;
        at_texel_format_t v27 = at_texel_format_la8_unorm;
      }
    }
    else if (v25)
    {
      cf[0] = (CFTypeRef)0x4000000010;
      cf[1] = 0;
      LODWORD(v95[0]) = 4097;
      *(void *)((char *)v95 + 12) = 0;
      *(void *)((char *)v95 + 4) = 0;
      at_texel_format_t v27 = at_texel_format_rgba16_unorm;
    }
    else if (v26 <= kCGImageAlphaNoneSkipFirst && ((1 << v26) & 0x61) != 0)
    {
      cf[0] = (CFTypeRef)0x1000000010;
      cf[1] = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      LODWORD(v95[0]) = 4096;
      *(void *)((char *)v95 + 12) = 0;
      *(void *)((char *)v95 + 4) = 0;
      at_texel_format_t v27 = at_texel_format_l16_unorm;
    }
    else
    {
      cf[0] = (CFTypeRef)0x2000000010;
      cf[1] = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
      LODWORD(v95[0]) = 4097;
      *(void *)((char *)v95 + 12) = 0;
      *(void *)((char *)v95 + 4) = 0;
      at_texel_format_t v27 = at_texel_format_la16_unorm;
    }
    *(_OWORD *)uint64_t v92 = 0u;
    long long v93 = 0u;
    *(void *)&src.validSize.uint32_t z = 0;
    uint64_t v55 = MEMORY[0x1A6231AB0](v92, cf, &__ATE_encodeToData_backgroundColor, v10, 256);
    if (cf[1]) {
      CFRelease(cf[1]);
    }
    if (v55) {
      goto LABEL_72;
    }
    theDataa = Mutable;
    size_t v78 = BitsPerComponent;
    CFAllocatorRef v75 = kCFAllocatorDefault;
    if (v26 > kCGImageAlphaNoneSkipFirst) {
      at_alpha_t v56 = at_alpha_premultiplied;
    }
    else {
      at_alpha_t v56 = dword_1A139E200[v26];
    }
    unsigned int v57 = CGImageGetWidth(v10);
    unsigned int v58 = CGImageGetHeight(v10);
    uint64_t v59 = at_encoder_create(v27, v56, v23, v56, 0);
    unint64_t block_dimensions = (unint64_t)at_encoder_get_block_dimensions(v59);
    char v61 = block_dimensions;
    unint64_t v62 = HIDWORD(block_dimensions);
    unint64_t v63 = v57 | ((unint64_t)v58 << 32);
    *(void *)&v98.uint32_t x = v63;
    v98.uint32_t z = 1;
    at_size_t v97 = at_encoder_get_block_counts(v59, v98);
    uint32_t v64 = v97.x;
    uint32_t v65 = v97.z;
    *(_DWORD *)uint64_t v83 = 1128617025;
    char v66 = v23;
    uint64_t v67 = HIDWORD(*(void *)&v97.x);
    char v84 = v61;
    char v85 = v62;
    char v86 = 0;
    __int16 v87 = v57;
    char v88 = BYTE2(v57);
    __int16 v89 = v58;
    char v90 = BYTE2(v58);
    v91[0] = v66;
    *(_WORD *)&v91[1] = 0;
    CFDataAppendBytes(theDataa, v83, 16);
    uint64_t v68 = v67 * v64;
    uint64_t v69 = v68 * v65;
    CFDataRef Mutable = theDataa;
    size_t v70 = at_encoder_get_block_size(v59);
    CFDataIncreaseLength(theDataa, v70 * v69);
    int v71 = CFDataGetMutableBytePtr(theDataa);
    size_t v72 = at_encoder_get_block_size(v59);
    src.texels = v92[0];
    *(void *)&src.validSize.uint32_t x = v63;
    src.validSize.uint32_t z = 1;
    src.rowBytes = *((void *)&v93 + 1);
    src.sliceBytes = 0;
    dest.blocks = v71 + 16;
    dest.rowBytes = v72 * v64;
    dest.sliceBytes = v72 * v68;
    float v54 = at_encoder_compress_texels(v59, &src, &dest, 0.0, at_flags_print_debug_info);
    free(v92[0]);
  }
  size_t BitsPerComponent = v78;
  if (v54 >= 0.0)
  {
    size_t Length = CFDataGetLength(Mutable);
    uint64_t v30 = (uint8_t *)malloc_type_malloc(Length, 0x7BD4EDA8uLL);
    size_t v31 = CFDataGetLength(Mutable);
    BytePtr = CFDataGetBytePtr(Mutable);
    size_t v33 = CFDataGetLength(Mutable);
    size_t v34 = compression_encode_buffer(v30, v31, BytePtr, v33, 0, COMPRESSION_LZFSE);
    __CFSetLastAllocationEventName();
    uint64_t v22 = CFDataCreateMutable(v75, 0);
    if (v34)
    {
      *(_DWORD *)bytes = 1;
      *(_DWORD *)&UInt8 bytes[4] = v34;
      int v80 = CFDataGetLength(Mutable);
      CFDataAppendBytes(v22, bytes, 12);
      float v35 = v22;
      size_t v36 = v30;
      CFIndex v37 = v34;
    }
    else
    {
      *(_DWORD *)bytes = 0;
      int v80 = CFDataGetLength(Mutable);
      *(_DWORD *)&UInt8 bytes[4] = CFDataGetLength(Mutable);
      CFDataAppendBytes(v22, bytes, 12);
      uint64_t v39 = CFDataGetBytePtr(Mutable);
      CFIndex v37 = CFDataGetLength(Mutable);
      float v35 = v22;
      size_t v36 = v39;
    }
    CFDataAppendBytes(v35, v36, v37);
    free(v30);
    goto LABEL_73;
  }
LABEL_72:
  uint64_t v22 = 0;
LABEL_73:
  CFRelease(Mutable);
  if (BitsPerComponent >= 9) {
    CFRelease(v10);
  }
  return v22;
}

BOOL CUIExpandATECompressedDataIntoBuffer(uint64_t a1, int a2, void *a3, uint64_t a4, size_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a4;
  if (*(_DWORD *)a1)
  {
    double v13 = malloc_default_zone();
    double v14 = (uint8_t *)malloc_type_zone_memalign(v13, 0x40uLL, *(unsigned int *)(a1 + 8), 0x699A31C1uLL);
    __CFSetLastAllocationEventName();
    if (!compression_decode_buffer(v14, *(unsigned int *)(a1 + 8), (const uint8_t *)(a1 + 12), *(unsigned int *)(a1 + 4), 0, COMPRESSION_LZFSE))goto LABEL_37; {
    goto LABEL_6;
    }
  }
  double v15 = (uint8_t *)(a1 + 12);
  if (((a1 + 12) & 0x3F) != 0)
  {
    double v16 = malloc_default_zone();
    double v14 = (uint8_t *)malloc_type_zone_memalign(v16, 0x40uLL, *(unsigned int *)(a1 + 8), 0x86B7A138uLL);
    __CFSetLastAllocationEventName();
    memcpy(v14, (const void *)(a1 + 12), *(unsigned int *)(a1 + 8));
LABEL_6:
    double v15 = v14;
    goto LABEL_7;
  }
  double v14 = 0;
LABEL_7:
  at_texel_format_t v17 = at_texel_format_bgra8_unorm;
  if (v9 > 1195456543)
  {
    if (v9 == 1380401751) {
      goto LABEL_16;
    }
    unsigned __int16 v18 = 14368;
  }
  else
  {
    if (v9 == 1095911234) {
      goto LABEL_16;
    }
    unsigned __int16 v18 = 12598;
  }
  if (v9 != (v18 | 0x47410000))
  {
    _CUILog(4, (uint64_t)"CoreUI: %s got a pixelFormat that it doesn't understand", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"_Bool CUIExpandATECompressedDataIntoBuffer(const u_int8_t *, _Bool, u_int8_t *, enum CSIPixelFormat, size_t)");
    if (!v14) {
      return 0;
    }
    goto LABEL_37;
  }
  if (a2) {
    at_texel_format_t v17 = at_texel_format_l8_unorm;
  }
  else {
    at_texel_format_t v17 = at_texel_format_la8_unorm;
  }
LABEL_16:
  memset(&src, 0, sizeof(src));
  *(void *)&dest.validSize.uint32_t z = 0;
  int v19 = *v15;
  if (v19 == 19)
  {
    if (v15[1] != 171 || v15[2] != 161 || v15[3] != 92) {
      goto LABEL_36;
    }
    at_block_format_t v20 = at_block_format_invalid;
    int v21 = (16 * (v15[4] & 0xF)) | v15[5];
    if (v21 > 135)
    {
      if (v21 > 201)
      {
        if (v21 == 202)
        {
          at_block_format_t v20 = at_block_format_astc_12x10_ldr;
        }
        else if (v21 == 204)
        {
          at_block_format_t v20 = at_block_format_astc_12x12_ldr;
        }
      }
      else
      {
        switch(v21)
        {
          case 165:
            at_block_format_t v20 = at_block_format_astc_10x5_ldr;
            break;
          case 166:
            at_block_format_t v20 = at_block_format_astc_10x6_ldr;
            break;
          case 167:
          case 169:
            break;
          case 168:
            at_block_format_t v20 = at_block_format_astc_10x8_ldr;
            break;
          case 170:
            at_block_format_t v20 = at_block_format_astc_10x10_ldr;
            break;
          default:
            if (v21 == 136) {
              at_block_format_t v20 = at_block_format_astc_8x8_ldr;
            }
            break;
        }
      }
    }
    else if (v21 <= 100)
    {
      switch(v21)
      {
        case 'D':
          at_block_format_t v20 = at_block_format_astc_4x4_ldr;
          break;
        case 'T':
          at_block_format_t v20 = at_block_format_astc_5x4_ldr;
          break;
        case 'U':
          at_block_format_t v20 = at_block_format_astc_5x5_ldr;
          break;
      }
    }
    else if (v21 > 132)
    {
      if (v21 == 133)
      {
        at_block_format_t v20 = at_block_format_astc_8x5_ldr;
      }
      else if (v21 == 134)
      {
        at_block_format_t v20 = at_block_format_astc_8x6_ldr;
      }
    }
    else if (v21 == 101)
    {
      at_block_format_t v20 = at_block_format_astc_6x5_ldr;
    }
    else if (v21 == 102)
    {
      at_block_format_t v20 = at_block_format_astc_6x6_ldr;
    }
    CGImageAlphaInfo v26 = 0;
    int v24 = *(unsigned __int16 *)(v15 + 7) | (v15[9] << 16);
    int v25 = *((unsigned __int16 *)v15 + 5);
    at_block_format_t v23 = v15;
  }
  else
  {
    if (v19 != 65 || v15[1] != 84 || v15[2] != 69 || v15[3] != 67 || v15[6])
    {
LABEL_36:
      _CUILog(4, (uint64_t)"CoreUI: %s got data that is not ASTC or DXTC encoded %c%c%c%c", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"_Bool CUIExpandATECompressedDataIntoBuffer(const u_int8_t *, _Bool, u_int8_t *, enum CSIPixelFormat, size_t)");
LABEL_37:
      free(v14);
      return 0;
    }
    at_block_format_t v23 = 0;
    at_block_format_t v20 = *(unsigned __int16 *)(v15 + 13) | ((unint64_t)v15[15] << 16);
    int v24 = *(unsigned __int16 *)(v15 + 7) | (v15[9] << 16);
    int v25 = *((unsigned __int16 *)v15 + 5);
    CGImageAlphaInfo v26 = v15;
  }
  int v27 = v25 | (v15[12] << 16);
  if (a2)
  {
    at_alpha_t v28 = at_alpha_not_premultiplied;
    at_alpha_t v29 = at_alpha_not_premultiplied;
  }
  else
  {
    at_alpha_t v28 = at_alpha_premultiplied;
    at_alpha_t v29 = at_alpha_premultiplied;
  }
  uint64_t v30 = at_encoder_create(v17, v28, v20, v29, 0);
  dest.texels = a3;
  *(void *)&dest.validSize.uint32_t x = __PAIR64__(v27, v24);
  dest.validSize.uint32_t z = 1;
  dest.rowBytes = a5;
  dest.sliceBytes = 0;
  *(void *)&v40.uint32_t x = __PAIR64__(v27, v24);
  v40.uint32_t z = 1;
  unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v30, v40);
  unint64_t v32 = HIDWORD(block_counts);
  unsigned int v33 = block_counts;
  size_t v34 = at_encoder_get_block_size(v30) * block_counts;
  size_t block_size = at_encoder_get_block_size(v30);
  size_t v36 = v26 + 16;
  if (v23) {
    size_t v36 = v23 + 16;
  }
  src.blocks = v36;
  src.rowBytes = v34;
  src.sliceBytes = v32 * (unint64_t)v33 * block_size;
  at_error_t v37 = at_encoder_decompress_texels(v30, &src, &dest, at_flags_default);
  if (v14) {
    free(v14);
  }

  return v37 >= at_error_success;
}

void CUIUpdateImageProviderForATECompressedData(int a1, _DWORD *a2, int *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 <= 1195456543)
  {
    if (a1 != 1095911234)
    {
      if (a1 != 1195454774) {
        goto LABEL_10;
      }
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if (a1 == 1195456544)
  {
LABEL_8:
    *a2 = 8;
    int v8 = 2;
    goto LABEL_9;
  }
  if (a1 == 1380401751)
  {
LABEL_7:
    *a2 = 8;
    int v8 = 4;
LABEL_9:
    *a3 = v8;
    *a4 = 1;
    return;
  }
LABEL_10:
  _CUILog(4, (uint64_t)"CoreUI: %s got a pixelFormat that it doesn't understand", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"void CUIUpdateImageProviderForATECompressedData(enum CSIPixelFormat, u_int32_t *, u_int32_t *, CGImageComponentType *)");
}

void CUIUpdatePixelFormatForATECompressedData(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *a1;
  if (*a1 <= 1195456543)
  {
    if (v8 != 1095911234)
    {
      if (v8 != 1195454774) {
        goto LABEL_10;
      }
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if (v8 == 1195456544)
  {
LABEL_8:
    int v9 = 1195456544;
    goto LABEL_9;
  }
  if (v8 == 1380401751)
  {
LABEL_7:
    int v9 = 1095911234;
LABEL_9:
    *a1 = v9;
    return;
  }
LABEL_10:
  _CUILog(4, (uint64_t)"CoreUI: %s got a pixelFormat that it doesn't understand", a3, a4, a5, a6, a7, a8, (uint64_t)"void CUIUpdatePixelFormatForATECompressedData(enum CSIPixelFormat *)");
}

_CUISubrangeData *CUIATECompressedDataFromBuffer(uint64_t a1, int a2, int *a3, int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, CFBooleanRef *a8)
{
  double v13 = a3;
  if (!*(_DWORD *)a1)
  {
    char v24 = a1 + 12;
    int v23 = *(unsigned __int8 *)(a1 + 12);
    if (v23 == 19)
    {
      if (*(unsigned __int8 *)(a1 + 13) != 171 || *(unsigned __int8 *)(a1 + 14) != 161 || *(unsigned char *)(a1 + 15) != 92) {
        goto LABEL_49;
      }
      *a5 = *(unsigned __int16 *)(a1 + 19) | (*(unsigned __int8 *)(a1 + 21) << 16);
      *a6 = *(unsigned __int16 *)(a1 + 22) | (*(unsigned __int8 *)(a1 + 24) << 16);
      __ASTCBlockFormatToGLInternalFormat(*(unsigned __int8 *)(a1 + 16), *(unsigned char *)(a1 + 17), a3, a4);
      *a7 = 16 * ((*a5 + *(unsigned __int8 *)(a1 + 16) - 1) / *(unsigned __int8 *)(a1 + 16));
      *a8 = kCFBooleanFalse;
      BOOL v32 = (v24 & 0x3F) != 0;
      if ((v24 & 0x3F) != 0)
      {
        unsigned int v33 = malloc_default_zone();
        size_t v34 = malloc_type_zone_memalign(v33, 0x40uLL, *(unsigned int *)(a1 + 8), 0x199EF338uLL);
        __CFSetLastAllocationEventName();
        memcpy(v34, (const void *)(a1 + 28), *(unsigned int *)(a1 + 8) - 16);
        float v35 = v34;
      }
      else
      {
        float v35 = 0;
        size_t v34 = (void *)(a1 + 268);
      }
      id v61 = MTLCreateSystemDefaultDevice();
      if (v61)
      {
        unint64_t v62 = v61;
        unint64_t v63 = +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:*a4 width:*a5 height:*a6 mipmapped:0];
        [(MTLTextureDescriptor *)v63 setMipmapLevelCount:1];
        id v64 = [v62 newTextureLayoutWithDescriptor:v63 isHeapOrBufferBacked:0];
        id v65 = [v64 size];
        char v66 = malloc_default_zone();
        uint64_t v67 = malloc_type_zone_memalign(v66, (size_t)[v64 alignment], (size_t)v65, 0x2C273B7BuLL);
        __CFSetLastAllocationEventName();
        if (objc_opt_respondsToSelector()) {
          [v64 initializeTextureMemory:v67];
        }
        uint64_t v68 = *a7;
        uint64_t v69 = *a5;
        uint64_t v70 = *a6;
        memset(v83, 0, 24);
        v83[3] = v69;
        UInt8 v83[4] = v70;
        v83[5] = 1;
        [v64 copyFromLinearBytes:v34 linearOffset:0 linearBytesPerRow:v68 linearBytesPerImage:0 toTextureMemory:v67 textureSlice:0 textureLevel:0 textureRegion:v83];
        [v64 finalizeTextureMemory:v67];
        *a8 = kCFBooleanTrue;
        if (v35) {
          free(v35);
        }

        return (_CUISubrangeData *)+[NSData dataWithBytesNoCopy:v67 length:v65 freeWhenDone:1];
      }
    }
    else
    {
      if (v23 != 65
        || *(unsigned char *)(a1 + 13) != 84
        || *(unsigned char *)(a1 + 14) != 69
        || *(unsigned char *)(a1 + 15) != 67
        || *(unsigned char *)(a1 + 18))
      {
        goto LABEL_49;
      }
      LODWORD(stream.dst_ptr) = 0;
      *a5 = *(unsigned __int16 *)(a1 + 19) | (*(unsigned __int8 *)(a1 + 21) << 16);
      *a6 = *(unsigned __int16 *)(a1 + 22) | (*(unsigned __int8 *)(a1 + 24) << 16);
      __ATEBlockFormatToGLInternalFormat((at_block_format_t)(*(unsigned __int16 *)(a1 + 25) | ((unint64_t)*(unsigned __int8 *)(a1 + 27) << 16)), a4, a3, &stream, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8);
      *a7 = LODWORD(stream.dst_ptr) * ((*a5 + *(unsigned __int8 *)(a1 + 16) - 1) / *(unsigned __int8 *)(a1 + 16));
      *a8 = kCFBooleanFalse;
      BOOL v32 = (v24 & 0x3F) != 0;
      if ((v24 & 0x3F) != 0)
      {
        size_t v60 = malloc_default_zone();
        size_t v34 = malloc_type_zone_memalign(v60, 0x40uLL, *(unsigned int *)(a1 + 8), 0x1A426AA6uLL);
        __CFSetLastAllocationEventName();
        memcpy(v34, (const void *)(a1 + 28), *(unsigned int *)(a1 + 8) - 16);
      }
      else
      {
        size_t v34 = (void *)(a1 + 268);
      }
    }
    id v71 = objc_alloc((Class)NSData);
    uint64_t v72 = *(unsigned int *)(a1 + 8) - 16;
    return (_CUISubrangeData *)[v71 initWithBytesNoCopy:v34 length:v72 freeWhenDone:v32];
  }
  if (a2 != 7 || (memset(&stream, 0, sizeof(stream)), (id v15 = MTLCreateSystemDefaultDevice()) == 0))
  {
LABEL_6:
    at_texel_format_t v17 = malloc_default_zone();
    unsigned __int16 v18 = (unsigned __int8 *)malloc_type_zone_memalign(v17, 0x40uLL, *(unsigned int *)(a1 + 8), 0xF9378EAEuLL);
    __CFSetLastAllocationEventName();
    size_t v19 = compression_decode_buffer(v18, *(unsigned int *)(a1 + 8), (const uint8_t *)(a1 + 12), *(unsigned int *)(a1 + 4), 0, COMPRESSION_LZFSE);
    if (!v19)
    {
      free(v18);
      _CUILog(4, (uint64_t)"CoreUI: %s couldn't uncompress ASTC buffer %zu %u %u", v25, v26, v27, v28, v29, v30, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
      return 0;
    }
    size_t v20 = v19;
    int v21 = +[NSData dataWithBytesNoCopy:v18 length:v19 freeWhenDone:1];
    int v22 = *v18;
    if (v22 == 19)
    {
      if (v18[1] != 171 || v18[2] != 161 || v18[3] != 92) {
        goto LABEL_49;
      }
      *a5 = *(unsigned __int16 *)(v18 + 7) | (v18[9] << 16);
      *a6 = *((unsigned __int16 *)v18 + 5) | (v18[12] << 16);
      __ASTCBlockFormatToGLInternalFormat(v18[4], v18[5], v13, a4);
      unsigned int v36 = 16 * ((*a5 + v18[4] - 1) / v18[4]);
    }
    else
    {
      if (v22 != 65 || v18[1] != 84 || v18[2] != 69 || v18[3] != 67 || v18[6])
      {
LABEL_49:
        _CUILog(4, (uint64_t)"CoreUI: %s got an invalid Compressed Texture Header %c%c%c%c", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
        return 0;
      }
      LODWORD(stream.dst_ptr) = 0;
      *a5 = *(unsigned __int16 *)(v18 + 7) | (v18[9] << 16);
      *a6 = *((unsigned __int16 *)v18 + 5) | (v18[12] << 16);
      __ATEBlockFormatToGLInternalFormat((at_block_format_t)(*(unsigned __int16 *)(v18 + 13) | ((unint64_t)v18[15] << 16)), a4, v13, &stream, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8);
      unsigned int v36 = LODWORD(stream.dst_ptr) * ((*a5 + v18[4] - 1) / v18[4]);
    }
    *a7 = v36;
    *a8 = kCFBooleanFalse;
    return -[_CUISubrangeData initWithData:range:]([_CUISubrangeData alloc], "initWithData:range:", v21, 16, v20 - 16);
  }
  double v16 = v15;
  if (compression_stream_init(&stream, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE))
  {

    goto LABEL_6;
  }
  size_t v78 = v16;
  uint64_t v74 = a4;
  CFAllocatorRef v75 = a6;
  int v80 = a7;
  uint64_t v76 = a8;
  size_t v37 = *(unsigned int *)(a1 + 4);
  stream.src_ptr = (const uint8_t *)(a1 + 12);
  stream.size_t src_size = v37;
  at_alpha_t v38 = malloc_default_zone();
  size_t v39 = 16;
  at_size_t v40 = (unsigned __int8 *)malloc_type_zone_memalign(v38, 0x40uLL, 0x10uLL, 0xC928110FuLL);
  __CFSetLastAllocationEventName();
  uint64_t v41 = 0;
  id v42 = 0;
  id v77 = 0;
  long long v43 = 0;
  uint64_t v44 = 0;
  unsigned __int8 v45 = 0;
  long long v73 = v13;
  while (1)
  {
    stream.dst_ptr = v40;
    stream.dst_size = v39;
    compression_status v46 = compression_stream_process(&stream, 0);
    if (v46 == COMPRESSION_STATUS_ERROR)
    {
      free(v40);

      compression_stream_destroy(&stream);
      return 0;
    }
    compression_status v53 = v46;
    if (v41 || (uint8_t *)(stream.dst_ptr - v40) != (uint8_t *)16)
    {
      if (!v45) {
        CUIATECompressedDataFromBuffer_cold_1();
      }
      uint64_t v57 = *v80;
      uint64_t v58 = *a5;
      v81[0] = 0;
      v81[1] = v44;
      v81[2] = 0;
      v81[3] = v58;
      v81[4] = v45;
      v81[5] = 1;
      [v42 copyFromLinearBytes:v40 linearOffset:0 linearBytesPerRow:v57 linearBytesPerImage:0 toTextureMemory:v43 textureSlice:0 textureLevel:0 textureRegion:v81];
      v44 += v45;
      goto LABEL_47;
    }
    if (*v40 != 19 || v40[1] != 171 || v40[2] != 161 || v40[3] != 92)
    {
      _CUILog(4, (uint64_t)"CoreUI: %s got an invalid ASTC Header %c%c%c%c", v47, v48, v49, v50, v51, v52, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
      goto LABEL_53;
    }
    unsigned __int8 v45 = v40[5];
    if (!v45) {
      break;
    }
    uint64_t v79 = v44;
    *a5 = *(unsigned __int16 *)(v40 + 7) | (v40[9] << 16);
    *CFAllocatorRef v75 = *((unsigned __int16 *)v40 + 5) | (v40[12] << 16);
    __ASTCBlockFormatToGLInternalFormat(v40[4], v45, v13, v74);
    *int v80 = 16 * ((*a5 + v40[4] - 1) / v40[4]);
    *uint64_t v76 = kCFBooleanTrue;
    uint64_t v41 = +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:*v74 width:*a5 height:*v75 mipmapped:0];
    [(MTLTextureDescriptor *)v41 setMipmapLevelCount:1];
    id v42 = [v78 newTextureLayoutWithDescriptor:v41 isHeapOrBufferBacked:0];
    id v54 = [v42 size];
    uint64_t v55 = malloc_default_zone();
    id v77 = v54;
    long long v43 = malloc_type_zone_memalign(v55, (size_t)[v42 alignment], (size_t)v54, 0x8486CB5uLL);
    __CFSetLastAllocationEventName();
    size_t v39 = *v80;
    free(v40);
    at_alpha_t v56 = malloc_default_zone();
    at_size_t v40 = (unsigned __int8 *)malloc_type_zone_memalign(v56, 0x40uLL, v39, 0xBD5A217FuLL);
    __CFSetLastAllocationEventName();
    if (objc_opt_respondsToSelector()) {
      [v42 initializeTextureMemory:v43];
    }
    double v13 = v73;
    uint64_t v44 = v79;
LABEL_47:
    if (v53 == COMPRESSION_STATUS_END)
    {
      [v42 finalizeTextureMemory:v43];
      free(v40);
      compression_stream_destroy(&stream);

      return (_CUISubrangeData *)[objc_alloc((Class)NSData) initWithBytesNoCopy:v43 length:v77 freeWhenDone:1];
    }
  }
  _CUILog(4, (uint64_t)"CoreUI: %s got an invalid ASTC Header (astcHeader->blockdim_y == 0) ", v47, v48, v49, v50, v51, v52, (uint64_t)"CFDataRef CUIATECompressedDataFromBuffer(const u_int8_t *, int, uint32_t *, uint32_t *, uint32_t *, uint32_t *, uint32_t *, CFBooleanRef *)");
LABEL_53:

  return 0;
}

uint64_t __ASTCBlockFormatToGLInternalFormat(uint64_t result, unsigned __int8 a2, int *a3, int *a4)
{
  unsigned int v4 = (a2 | (16 * result));
  if (v4 > 0x87)
  {
    if ((a2 | (16 * result)) > 0xC9u)
    {
      if (v4 == 202)
      {
        int v5 = 217;
        int v6 = 37820;
      }
      else
      {
        if (v4 != 204) {
          return result;
        }
        int v5 = 218;
        int v6 = 37821;
      }
    }
    else
    {
      switch(a2 | (16 * result))
      {
        case 165:
          int v5 = 213;
          int v6 = 37816;
          break;
        case 166:
          int v5 = 214;
          int v6 = 37817;
          break;
        case 167:
        case 169:
          return result;
        case 168:
          int v5 = 215;
          int v6 = 37818;
          break;
        case 170:
          int v5 = 216;
          int v6 = 37819;
          break;
        default:
          if (v4 != 136) {
            return result;
          }
          int v5 = 212;
          int v6 = 37815;
          break;
      }
    }
  }
  else if ((a2 | (16 * result)) <= 0x64u)
  {
    switch(v4)
    {
      case 'D':
        int v5 = 204;
        int v6 = 37808;
        break;
      case 'T':
        int v5 = 205;
        int v6 = 37809;
        break;
      case 'U':
        int v5 = 206;
        int v6 = 37810;
        break;
      default:
        return result;
    }
  }
  else if ((a2 | (16 * result)) > 0x84u)
  {
    if (v4 == 133)
    {
      int v5 = 210;
      int v6 = 37813;
    }
    else
    {
      if (v4 != 134) {
        return result;
      }
      int v5 = 211;
      int v6 = 37814;
    }
  }
  else if (v4 == 101)
  {
    int v5 = 207;
    int v6 = 37811;
  }
  else
  {
    if (v4 != 102) {
      return result;
    }
    int v5 = 208;
    int v6 = 37812;
  }
  *a3 = v6;
  *a4 = v5;
  return result;
}

uint64_t __ATEBlockFormatToGLInternalFormat(at_block_format_t blockFormat, _DWORD *a2, int *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(blockFormat)
  {
    case at_block_format_bc1:
      *a3 = 33777;
      *a4 = 8;
      break;
    case at_block_format_bc2:
      *a4 = 16;
      int v10 = 33778;
      goto LABEL_13;
    case at_block_format_bc3:
      *a4 = 16;
      int v10 = 33779;
      goto LABEL_13;
    case at_block_format_bc4:
      *a4 = 16;
      int v10 = 36283;
      goto LABEL_13;
    case at_block_format_bc4s:
      *a4 = 2;
      int v10 = 36284;
      goto LABEL_13;
    case at_block_format_bc5:
      *a4 = 2;
      int v10 = 36285;
      goto LABEL_13;
    case at_block_format_bc5s:
      *a4 = 2;
      int v10 = 36286;
      goto LABEL_13;
    case at_block_format_bc6:
      *a4 = 16;
      int v10 = 36494;
      goto LABEL_13;
    case at_block_format_bc6u:
      *a4 = 16;
      int v10 = 36495;
      goto LABEL_13;
    case at_block_format_bc7:
      *a4 = 16;
      int v10 = 36492;
LABEL_13:
      *a3 = v10;
      break;
    default:
      _CUILog(4, (uint64_t)"CoreUI: %s got a blockFormat doesn't understand", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"void __ATEBlockFormatToGLInternalFormat(at_block_format_t, uint32_t *, uint32_t *, uint32_t *)");
      break;
  }
  uint64_t result = at_block_format_to_MTLPixelFormat(blockFormat);
  *a2 = result;
  return result;
}

uint64_t __CUISubtypeFromIndex(unint64_t a1, unsigned int a2)
{
  if (a1 == -1)
  {
    if (a2 >= 0x20) {
      return 0xFFFFFFFFLL;
    }
    else {
      return dword_1A139E258[a2];
    }
  }
  else if (a2)
  {
    switch(a1)
    {
      case 0uLL:
        uint64_t result = 1864;
        switch(a2)
        {
          case 0x1Au:
            return 1964;
          case 0x1Bu:
            return 2234;
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
            goto LABEL_25;
          case 0x1Fu:
            return 1665;
          case 0x20u:
            return result;
          default:
            if (a2 != 1) {
              goto LABEL_25;
            }
            return result;
        }
      case 3uLL:
        signed int v4 = a2 - 5;
        if (a2 - 5 >= 3) {
          goto LABEL_25;
        }
        int v5 = (unsigned int *)&unk_1A139E2D8;
        goto LABEL_16;
      case 4uLL:
        switch(a2)
        {
          case 0x17u:
            return 430;
          case 0x18u:
            return 484;
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
            goto LABEL_25;
          case 0x1Cu:
            return 502;
          case 0x1Du:
            return 446;
          case 0x1Eu:
            return 496;
          default:
            uint64_t result = 320;
            switch(a2)
            {
              case 8u:
                return result;
              case 9u:
                return 384;
              case 0xDu:
                return 340;
              case 0xEu:
                return 390;
              default:
                goto LABEL_25;
            }
        }
      case 5uLL:
        if (a2 != 1) {
          goto LABEL_25;
        }
        return 3648;
      default:
        if (a1 > 2 || a2 >= 0x1F || (signed int v4 = a2 - 1, ((0x313FFEFFu >> (a2 - 1)) & 1) == 0)) {
LABEL_25:
        }
          __CUISubtypeFromIndex_cold_1(a1);
        int v5 = (unsigned int *)&unk_1A139E2E4;
LABEL_16:
        uint64_t result = v5[v4];
        break;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t CUIParseDeploymentTarget(char *a1, int a2)
{
  signed int v4 = "any";
  if ("any")
  {
    int v5 = &gThemeDeploymentTargets;
    while (strcasecmp(a1, v4))
    {
      signed int v4 = (const char *)*((void *)v5 + 5);
      v5 += 6;
      if (!v4) {
        goto LABEL_5;
      }
    }
    return *v5;
  }
  else
  {
LABEL_5:
    id v6 = [objc_alloc((Class)NSString) initWithUTF8String:a1];
    id v7 = [v6 componentsSeparatedByString:@"."];
    id v8 = [v7 count];
    if (v8)
    {
      id v9 = v8;
      unsigned int v10 = objc_msgSend(objc_msgSend(v7, "objectAtIndexedSubscript:", 0), "intValue");
      if (v9 == (id)1) {
        signed int v11 = 0;
      }
      else {
        signed int v11 = objc_msgSend(objc_msgSend(v7, "objectAtIndexedSubscript:", 1), "intValue");
      }
    }
    else
    {
      signed int v11 = 0;
      unsigned int v10 = 0x7FFFFFFF;
    }

    if (a2 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = a2;
    }
    switch(v13)
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 7:
        if ((int)v10 < 10) {
          goto LABEL_53;
        }
        if (v10 == 10) {
          return 1;
        }
        if (v10 < 0xC) {
          return 2;
        }
        if (v10 == 12) {
          goto LABEL_35;
        }
        if (v10 < 0xE) {
          return 5;
        }
        if (v10 == 14) {
          return 6;
        }
        if (v10 < 0x10) {
          return 7;
        }
        if (v10 == 16) {
          return 8;
        }
        if (v10 <= 0x11) {
          goto LABEL_50;
        }
        if (v10 == 18) {
          goto LABEL_40;
        }
        goto LABEL_52;
      case 5:
        if ((int)v10 < 3) {
          goto LABEL_53;
        }
        if (v10 == 3) {
          return 1;
        }
        if (v10 < 5) {
          return 2;
        }
        if (v10 == 5)
        {
LABEL_35:
          BOOL v14 = v11 < 2;
          unsigned int v15 = 3;
          goto LABEL_36;
        }
        if (v10 < 7) {
          return 5;
        }
        if (v10 == 7) {
          return 6;
        }
        if (v10 < 9) {
          return 7;
        }
        if (v10 == 9) {
          return 8;
        }
        if (v10 <= 0xA)
        {
LABEL_50:
          BOOL v14 = v11 < 4;
          goto LABEL_33;
        }
        if (v10 == 11) {
          goto LABEL_40;
        }
        goto LABEL_52;
      case 8:
        if ((int)v10 > 1)
        {
          if (v10 == 2)
          {
LABEL_40:
            uint64_t result = 11;
          }
          else
          {
LABEL_52:
            fprintf(__stderrp, "assuming --deployment-target %s == --deployment-target any\n", a1);
LABEL_53:
            uint64_t result = 0;
          }
        }
        else
        {
          BOOL v14 = v11 < 1;
LABEL_33:
          unsigned int v15 = 9;
LABEL_36:
          if (v14) {
            uint64_t result = v15;
          }
          else {
            uint64_t result = v15 + 1;
          }
        }
        break;
      default:
        goto LABEL_52;
    }
  }
  return result;
}

uint64_t CUIWatchSubTypeFallbackOrder(uint64_t result, void *a2)
{
  if (result > 445)
  {
    if (result > 495)
    {
      if (result != 496 && result != 502) {
        return result;
      }
      objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 484));
    }
    else
    {
      if (result == 446)
      {
        uint64_t v3 = 430;
        goto LABEL_18;
      }
      if (result != 484) {
        return result;
      }
    }
    uint64_t v3 = 390;
LABEL_18:
    objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v3));
LABEL_19:
    objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 340));
    goto LABEL_20;
  }
  if (result > 389)
  {
    if (result != 390 && result != 430) {
      return result;
    }
    goto LABEL_19;
  }
  if (result != 340)
  {
    if (result != 384) {
      return result;
    }
    goto LABEL_21;
  }
LABEL_20:
  objc_msgSend(a2, "addObject:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 384));
LABEL_21:
  signed int v4 = +[NSNumber numberWithInteger:320];
  return (uint64_t)[a2 addObject:v4];
}

__CFString *OUTLINED_FUNCTION_0(uint64_t a1, uint64_t a2)
{
  return CUIPlatformNameForPlatform(a2);
}

__CFString *OUTLINED_FUNCTION_1(uint64_t a1, uint64_t a2)
{
  return CUIPlatformNameForPlatform(a2);
}

id NSStringToUTF16LEBytes(NSString *a1, unsigned int *a2)
{
  uint64_t v3 = [(NSString *)a1 dataUsingEncoding:2483028224];
  *a2 = [(NSData *)v3 length] >> 1;
  return (id)[(NSData *)v3 bytes];
}

CPSDString *NewCPSDStringFromNSString(NSString *a1)
{
  uint64_t v1 = [(NSString *)a1 dataUsingEncoding:2483028224];
  unsigned int v2 = [(NSData *)v1 length] >> 1;
  uint64_t v3 = [(NSData *)v1 bytes];
  signed int v4 = (CPSDString *)operator new();
  CPSDString::CPSDString(v4, v3, v2);
  return v4;
}

void sub_1A132F374(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x1010C4082113244);
  _Unwind_Resume(a1);
}

void CPSDString::CPSDString(CPSDString *this, const unsigned __int16 *a2, unsigned int a3)
{
  *((void *)this + 1) = 0;
  CPSDString::AllocateCharData(this, 1);
  **((_WORD **)this + 1) = 0;
  CPSDString::Init((void **)this, a2, a3, 1);
}

void sub_1A132F3F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 8);
  if (v3)
  {
    MEMORY[0x1A6230DD0](v3, 0x1000C80BDFB0063);
    *(void *)(v1 + 8) = 0;
  }
  _Unwind_Resume(exception_object);
}

void sub_1A132F4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A132F764()
{
}

void sub_1A132FA64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A132FDA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A132FF6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A133111C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A13313C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A13316C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A1331880(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A13319EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A13335C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *CPSDString::Init(void **this, const unsigned __int16 *a2, unsigned int a3, int a4)
{
  if (a3)
  {
    BOOL v7 = a2[a3 - 1] == 0;
    if (!a4) {
      goto LABEL_7;
    }
  }
  else
  {
    BOOL v7 = 0;
    if (!a4) {
      goto LABEL_7;
    }
  }
  if (!v7)
  {
    CPSDString::AllocateCharData((CPSDString *)this, a3 + 1);
    uint64_t result = memcpy(this[1], a2, (2 * *(_DWORD *)this - 2));
    *((_WORD *)this[1] + a3) = 0;
    return result;
  }
LABEL_7:
  CPSDString::AllocateCharData((CPSDString *)this, a3);
  id v9 = this[1];
  size_t v10 = (2 * *(_DWORD *)this);
  return memcpy(v9, a2, v10);
}

uint64_t CPSDString::AllocateCharData(CPSDString *this, int a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    MEMORY[0x1A6230DD0](v4, 0x1000C80BDFB0063);
    *((void *)this + 1) = 0;
  }
  *(_DWORD *)this = a2;
  uint64_t result = operator new[]();
  *((void *)this + 1) = result;
  return result;
}

uint64_t encodeRadiosity(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  unint64_t v10 = a1 - 0x10000;
  uint64_t result = 0xFFFFFFFFLL;
  if (v10 < 0xFFFFFFFFFFFF0001) {
    return result;
  }
  if ((unint64_t)(a2 - 0x10000) < 0xFFFFFFFFFFFF0001) {
    return result;
  }
  uint64_t v12 = 4 * a1;
  if (4 * a1 > a3) {
    return result;
  }
  BOOL v14 = (char *)a4;
  if (a9 == 20.0)
  {
    id v54 = (void *)a6;
    unint64_t v57 = a3;
    char v15 = 4;
    float v16 = 0.4574;
    float v17 = -0.3324;
    int v18 = 1060696910;
  }
  else
  {
    if (a9 != 40.0)
    {
      _CUILog(4, (uint64_t)"Invalid sigma=%.2f\n", a3, a4, a5, a6, a7, a8, COERCE__INT64(a9));
      return 0xFFFFFFFFLL;
    }
    id v54 = (void *)a6;
    unint64_t v57 = a3;
    char v15 = 5;
    float v16 = 0.22498;
    float v17 = -0.16248;
    int v18 = 1060748727;
  }
  uint64_t v19 = (1 << v15);
  unint64_t v20 = (unint64_t)(a1 + v19 - 1) >> v15;
  unint64_t v21 = (unint64_t)(a2 + v19 - 1) >> v15;
  size_t v22 = 4 * v20 * v21;
  size_t v23 = 8 * v20 * v21 + 12;
  unint64_t v52 = v20;
  char v24 = malloc_type_malloc(16 * a1, 0x100004052888210uLL);
  unint64_t v53 = v21;
  uint64_t v25 = (float *)malloc_type_calloc(v21 * v12, 4uLL, 0x100004052888210uLL);
  unint64_t v51 = v22;
  uint64_t v55 = (char *)malloc_type_calloc(v22, 4uLL, 0x100004052888210uLL);
  uint64_t v26 = malloc_type_malloc(v23, 0x2E1431D7uLL);
  uint64_t v27 = v25;
  if (!v24 || !v25 || (v55 ? (BOOL v28 = v26 == 0) : (BOOL v28 = 1), v28))
  {
    free(v25);
    free(v55);
    free(v24);
    free(v26);
    return 0xFFFFFFFFLL;
  }
  size_t v49 = v23;
  uint64_t v50 = (void *)a5;
  signed int v29 = v19 >> 2;
  uint64_t v30 = v26;
  char v31 = v15;
  at_alpha_t v56 = v27;
  bzero(v30, v23);
  unint64_t v32 = 0;
  *uint64_t v30 = a1;
  v30[1] = a2;
  int v33 = v19 - 1;
  v30[2] = v19;
  signed int v34 = 3 * (v19 >> 2);
  *((_DWORD *)v30 + 2) = v18;
  do
  {
    if ((int)(v33 & v32) >= v34 || (int)(v33 & v32) < v29) {
      float v36 = v17;
    }
    else {
      float v36 = v16;
    }
    __B[0] = v36;
    src.data = v14;
    src.height = 1;
    src.width = 4 * a1;
    src.rowBytes = 4 * a1;
    dest.data = v24;
    dest.height = 1;
    dest.width = 4 * a1;
    dest.rowBytes = 4 * a1;
    vImageConvert_Planar8toPlanarF(&src, &dest, 255.0, 0.0, 0);
    vDSP_vsma((const float *)v24, 1, __B, &v56[(v32 >> v31) * v12], 1, &v56[(v32 >> v31) * v12], 1, 4 * a1);
    ++v32;
    v14 += v57;
  }
  while (a2 != v32);
  size_t v37 = v30 + 6;
  if (v53)
  {
    uint64_t v38 = 0;
    size_t v39 = v56;
    at_size_t v40 = v55;
    do
    {
      if (a1)
      {
        unint64_t v41 = 0;
        id v42 = v39;
        do
        {
          uint64_t v43 = 0;
          if ((int)(v33 & v41) >= v34 || (int)(v33 & v41) < v29) {
            float v45 = v17;
          }
          else {
            float v45 = v16;
          }
          do
          {
            *(float *)&v40[16 * (v41 >> v31) + v43 * 4] = *(float *)&v40[16 * (v41 >> v31) + v43 * 4]
                                                        + (float)(v45 * v42[v43]);
            ++v43;
          }
          while (v43 != 4);
          ++v41;
          v42 += 4;
        }
        while (v41 != a1);
      }
      ++v38;
      v40 += 16 * v52;
      v39 += 4 * a1;
    }
    while (v38 != v53);
    if (v52)
    {
      uint64_t v46 = v51;
      if (v51 <= 1) {
        uint64_t v46 = 1;
      }
      uint64_t v47 = (float *)v55;
      do
      {
        float v48 = *v47++;
        *v37++ = vcvts_n_s32_f32(v48, 6uLL);
        --v46;
      }
      while (v46);
    }
  }
  free(v56);
  free(v55);
  free(v24);
  uint64_t result = 0;
  *uint64_t v50 = v30;
  *id v54 = v49;
  return result;
}

uint64_t decodeRadiosity(unsigned __int16 *a1, unint64_t a2, uint64_t a3, char *a4)
{
  if (a2 < 0xC) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v73 = v7;
  uint64_t v74 = v6;
  uint64_t v75 = v4;
  uint64_t v76 = v5;
  uint64_t v11 = a1[2];
  char v12 = -1;
  do
    ++v12;
  while (1 << v12 < (int)v11);
  uint64_t v13 = *a1;
  unint64_t v14 = (unint64_t)(v11 - 1 + v13) >> v12;
  uint64_t v68 = a1[1];
  unint64_t v15 = (unint64_t)(v11 - 1 + v68) >> v12;
  float v16 = (float *)malloc_type_calloc(3 * v11, 4uLL, 0x100004052888210uLL);
  size_t v17 = 4 * v13;
  uint64_t v70 = (float *)malloc_type_calloc(v15 * v17, 4uLL, 0x100004052888210uLL);
  unint64_t v71 = v15;
  size_t v18 = 4 * v14 * v15;
  uint64_t v19 = (char *)malloc_type_calloc(v18, 4uLL, 0x100004052888210uLL);
  unint64_t v20 = (float *)malloc_type_calloc(v17, 4uLL, 0x100004052888210uLL);
  id v65 = v19;
  if (v70) {
    BOOL v21 = v19 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  BOOL v22 = v21 || v16 == 0;
  uint64_t v69 = v20;
  BOOL v23 = v22 || v20 == 0;
  int v24 = v23;
  int v64 = v24;
  if (!v23)
  {
    if (v11)
    {
      uint64_t v25 = 0;
      uint64_t v26 = v16 + 2;
      do
      {
        double v27 = ((double)(int)v25 + 0.5 - (double)v11 * 0.5) / ((double)v11 * 0.5);
        double v28 = v27 * (v27 * -2.0);
        double v29 = *((float *)a1 + 2);
        float v30 = (v28 + v27 * (v27 * 3.0) * v27 + v27 * -5.0 + 4.0) * 0.125
            + (v27 + v27 * v27 + -(v27 * v27) * v27 + -1.0) * 0.5 * v29;
        float v31 = v27 * v27 * 0.5 + (1.0 - v27 * v27) * v29;
        *(v26 - 2) = v30;
        *(v26 - 1) = v31;
        *(float *)&double v27 = (v28 + v27 * (v27 * -3.0) * v27 + v27 * 5.0 + 4.0) * 0.125
                       + (v27 * v27 + v27 * v27 * v27 - v27 + -1.0) * 0.5 * v29;
        *uint64_t v26 = *(float *)&v27;
        v26 += 3;
        ++v25;
      }
      while (v11 != v25);
    }
    if (v18)
    {
      unint64_t v32 = (__int16 *)(a1 + 6);
      int v33 = (float *)v19;
      do
      {
        int v34 = *v32++;
        *v33++ = (float)v34 * 0.015625;
        --v18;
      }
      while (v18);
    }
    size_t v35 = 16 * v13;
    float v36 = v70;
    if (v71)
    {
      uint64_t v37 = 0;
      uint64_t v38 = v19;
      size_t v39 = v19 - 16;
      uint64_t v40 = 16 * v14;
      unint64_t v41 = v19 + 16;
      do
      {
        if (v13)
        {
          unint64_t v42 = 0;
          uint64_t v43 = v36;
          do
          {
            unint64_t v44 = v42 >> v12;
            int v45 = 3 * ((v11 - 1) & v42);
            if (v42 >> v12)
            {
              uint64_t v46 = 0;
              float v47 = v16[v45];
              do
              {
                v43[v46] = v43[v46] + (float)(v47 * *(float *)&v39[16 * v44 + v46 * 4]);
                ++v46;
              }
              while (v46 != 4);
            }
            uint64_t v48 = 0;
            float v49 = v16[v45 + 1];
            do
            {
              v43[v48] = v43[v48] + (float)(v49 * *(float *)&v38[16 * v44 + v48 * 4]);
              ++v48;
            }
            while (v48 != 4);
            if (v44 + 1 < v14)
            {
              uint64_t v50 = 0;
              float v51 = v16[v45 + 2];
              unint64_t v52 = &v41[16 * v44];
              do
              {
                v43[v50] = v43[v50] + (float)(v51 * *(float *)&v52[v50 * 4]);
                ++v50;
              }
              while (v50 != 4);
            }
            ++v42;
            v43 += 4;
          }
          while (v42 != v13);
        }
        ++v37;
        v39 += v40;
        float v36 = (float *)((char *)v36 + v35);
        v38 += v40;
        v41 += v40;
      }
      while (v37 != v71);
    }
    if (v68)
    {
      unint64_t v53 = 0;
      if (v17 <= 1) {
        uint64_t v54 = 1;
      }
      else {
        uint64_t v54 = 4 * v13;
      }
      uint64_t v66 = v54;
      do
      {
        uint64_t v55 = v69;
        bzero(v69, v35);
        unint64_t v56 = v53 >> v12;
        int v57 = 3 * ((v11 - 1) & v53);
        if (v53 >> v12)
        {
          float __B = v16[v57];
          vDSP_vsma(&v70[(v56 - 1) * v17], 1, &__B, v69, 1, v69, 1, 4 * v13);
        }
        float __B = v16[v57 + 1];
        vDSP_vsma(&v70[v56 * v17], 1, &__B, v69, 1, v69, 1, 4 * v13);
        if (v56 + 1 < v71)
        {
          float __B = v16[v57 + 2];
          vDSP_vsma(&v70[(v56 + 1) * v17], 1, &__B, v69, 1, v69, 1, 4 * v13);
        }
        uint64_t v58 = v66;
        uint64_t v59 = a4;
        if (v13)
        {
          do
          {
            float v60 = *v55++;
            int v61 = (int)(float)(v60 + 0.5);
            if (v61 >= 0xFF) {
              char v62 = -1;
            }
            else {
              char v62 = v61;
            }
            if (v61 >= 0) {
              char v63 = v62;
            }
            else {
              char v63 = 0;
            }
            *v59++ = v63;
            --v58;
          }
          while (v58);
        }
        ++v53;
        size_t v35 = 16 * v13;
        a4 += a3;
      }
      while (v53 != v68);
    }
  }
  free(v16);
  free(v70);
  free(v65);
  free(v69);
  return (v64 << 31 >> 31);
}

uint64_t CUIConvertToTXRPixelFormat(uint64_t a1)
{
  uint64_t v1 = 0;
  if (a1 > 109)
  {
    if (a1 > 151)
    {
      if (a1 == 555) {
        uint64_t v1 = 555;
      }
      else {
        uint64_t v1 = 0;
      }
      if (a1 == 553) {
        uint64_t v1 = 553;
      }
      if (a1 == 212) {
        uint64_t v2 = 212;
      }
      else {
        uint64_t v2 = 0;
      }
      if (a1 == 204) {
        uint64_t v2 = 204;
      }
      if (a1 <= 552) {
        uint64_t v1 = v2;
      }
      if (a1 == 194) {
        uint64_t v3 = 194;
      }
      else {
        uint64_t v3 = 0;
      }
      if (a1 == 186) {
        uint64_t v3 = 186;
      }
      if (a1 == 153) {
        uint64_t v4 = 153;
      }
      else {
        uint64_t v4 = 0;
      }
      if (a1 == 152) {
        uint64_t v4 = 152;
      }
      if (a1 <= 185) {
        uint64_t v3 = v4;
      }
      BOOL v5 = a1 <= 203;
LABEL_50:
      if (v5) {
        return v3;
      }
      return v1;
    }
    switch(a1)
    {
      case 110:
      case 112:
      case 115:
      case 125:
      case 130:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 140:
      case 141:
      case 142:
      case 143:
LABEL_9:
        uint64_t v1 = a1;
        break;
      default:
        return v1;
    }
  }
  else
  {
    if (a1 > 59)
    {
      if (a1 <= 79)
      {
        switch(a1)
        {
          case '<':
          case '>':
          case 'A':
          case 'F':
          case 'G':
          case 'H':
            goto LABEL_9;
          default:
            return v1;
        }
        return v1;
      }
      if (a1 == 105) {
        uint64_t v1 = 105;
      }
      else {
        uint64_t v1 = 0;
      }
      if (a1 == 93) {
        uint64_t v1 = 93;
      }
      if (a1 == 92) {
        uint64_t v1 = 92;
      }
      if (a1 == 90) {
        uint64_t v3 = 90;
      }
      else {
        uint64_t v3 = 0;
      }
      if (a1 == 81) {
        uint64_t v3 = 81;
      }
      if (a1 == 80) {
        uint64_t v3 = 80;
      }
      BOOL v5 = a1 <= 91;
      goto LABEL_50;
    }
    if (a1 <= 11)
    {
      if (a1 == 11) {
        uint64_t v1 = 11;
      }
      else {
        uint64_t v1 = 0;
      }
      if (a1 == 10) {
        uint64_t v1 = 10;
      }
      BOOL v6 = a1 == 1;
LABEL_63:
      if (v6) {
        return a1;
      }
    }
    else
    {
      switch(a1)
      {
        case 20:
        case 22:
        case 25:
        case 30:
        case 31:
        case 32:
          goto LABEL_9;
        case 21:
        case 23:
        case 24:
        case 26:
        case 27:
        case 28:
        case 29:
          return v1;
        default:
          if (a1 == 55) {
            uint64_t v1 = 55;
          }
          else {
            uint64_t v1 = 0;
          }
          BOOL v6 = a1 == 12;
          goto LABEL_63;
      }
    }
  }
  return v1;
}

uint64_t CUIConvertFromTXRPixelFormat(uint64_t a1)
{
  uint64_t v1 = 0;
  if (a1 <= 104)
  {
    if (a1 <= 59)
    {
      if (a1 <= 11)
      {
        if (a1 == 11) {
          uint64_t v1 = 11;
        }
        else {
          uint64_t v1 = 0;
        }
        if (a1 == 10) {
          uint64_t v1 = 10;
        }
        BOOL v5 = a1 == 1;
LABEL_56:
        if (v5) {
          return a1;
        }
      }
      else
      {
        switch(a1)
        {
          case 20:
          case 22:
          case 25:
          case 30:
          case 31:
          case 32:
            goto LABEL_9;
          case 21:
          case 23:
          case 24:
          case 26:
          case 27:
          case 28:
          case 29:
            return v1;
          default:
            if (a1 == 55) {
              uint64_t v1 = 55;
            }
            else {
              uint64_t v1 = 0;
            }
            BOOL v5 = a1 == 12;
            goto LABEL_56;
        }
      }
      return v1;
    }
    if (a1 <= 79)
    {
      switch(a1)
      {
        case '<':
        case '>':
        case 'A':
        case 'F':
        case 'G':
        case 'H':
          goto LABEL_9;
        default:
          return v1;
      }
      return v1;
    }
    if (a1 == 93) {
      uint64_t v1 = 93;
    }
    else {
      uint64_t v1 = 0;
    }
    if (a1 == 92) {
      uint64_t v1 = 92;
    }
    if (a1 == 90) {
      uint64_t v1 = 90;
    }
    if (a1 == 81) {
      uint64_t v3 = 81;
    }
    else {
      uint64_t v3 = 0;
    }
    if (a1 == 80) {
      uint64_t v3 = 80;
    }
    BOOL v4 = a1 <= 89;
    goto LABEL_43;
  }
  if (a1 > 151)
  {
    if (a1 == 555) {
      uint64_t v1 = 555;
    }
    else {
      uint64_t v1 = 0;
    }
    if (a1 == 553) {
      uint64_t v1 = 553;
    }
    if (a1 == 212) {
      uint64_t v2 = 212;
    }
    else {
      uint64_t v2 = 0;
    }
    if (a1 == 204) {
      uint64_t v2 = 204;
    }
    if (a1 <= 552) {
      uint64_t v1 = v2;
    }
    if (a1 == 194) {
      uint64_t v3 = 194;
    }
    else {
      uint64_t v3 = 0;
    }
    if (a1 == 186) {
      uint64_t v3 = 186;
    }
    if (a1 == 152) {
      uint64_t v3 = 152;
    }
    BOOL v4 = a1 <= 203;
LABEL_43:
    if (v4) {
      return v3;
    }
    return v1;
  }
  switch(a1)
  {
    case 110:
    case 112:
    case 115:
    case 125:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 140:
    case 141:
    case 142:
    case 143:
LABEL_9:
      uint64_t v1 = a1;
      break;
    case 111:
    case 113:
    case 114:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 126:
    case 127:
    case 128:
    case 129:
    case 136:
    case 137:
    case 138:
    case 139:
      return v1;
    default:
      if (a1 == 105) {
        uint64_t v1 = 105;
      }
      else {
        uint64_t v1 = 0;
      }
      break;
  }
  return v1;
}

CFDataRef CUIConvertImageToPixelFormat(CGImage *a1, int a2, int a3, uint64_t a4, uint64_t a5, void *a6, double a7, double a8)
{
  uint64_t v15 = CUIConvertToTXRPixelFormat(a5);
  id v16 = objc_alloc_init((Class)TXRDefaultBufferAllocator);
  uint64_t v47 = 0;
  id v17 = objc_alloc_init((Class)TXROptions);
  size_t v18 = v17;
  uint64_t v19 = 16;
  if (a2) {
    uint64_t v19 = 64;
  }
  [v17 setOriginOperation:v19 | a3];
  if (a4 == 2)
  {
    [v18 setColorSpaceHandling:0];
    uint64_t v20 = 1;
    [v18 setMultiplyAlpha:1];
  }
  else if (a4 == 1)
  {
    [v18 setColorSpaceHandling:0];
    uint64_t v20 = 1;
  }
  else
  {
    if (!a4) {
      [v18 setColorSpaceHandling:3];
    }
    uint64_t v20 = 0;
  }
  id v21 = [objc_alloc((Class)TXRImageIndependent) initWithCGImage:a1 bufferAllocator:v16 options:v18 error:&v47];

  if (!v21)
  {
    _CUILog(4, (uint64_t)"CoreUI: %s got error '%@' converting image", v22, v23, v24, v25, v26, v27, (uint64_t)"CFDataRef CUIConvertImageToPixelFormat(CGImageRef, BOOL, int32_t, _CUIThemeTextureInterpretation, CGSize, _CUIThemeTexturePixelFormat, size_t *)");
LABEL_21:
    CFDataRef v44 = 0;
    goto LABEL_22;
  }
  if (a7 != (double)CGImageGetWidth(a1) || a8 != (double)CGImageGetHeight(a1))
  {
    LODWORD(v28) = a7;
    HIDWORD(v28) = a8;
    double v46 = v28;
    id v35 = +[TXRDataScaler newImageFromSourceImage:scaledDimensions:bufferAllocattor:filter:error:](TXRDataScaler, "newImageFromSourceImage:scaledDimensions:bufferAllocattor:filter:error:", v21, v16, 1, &v47);
    if (v35)
    {
      id v36 = objc_msgSend(objc_alloc((Class)TXRImageIndependent), "initWithImage:dimensions:pixelFormat:", v35, objc_msgSend(v21, "pixelFormat"), v46);
      id v37 = +[TXRDataConverter newImageFromSourceImage:v36 newPixelFormat:v15 bufferAllocator:v16 gammaDegamma:v20 error:&v47];
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: %s got error '%@' scaling image", v29, v30, v31, v32, v33, v34, (uint64_t)"CFDataRef CUIConvertImageToPixelFormat(CGImageRef, BOOL, int32_t, _CUIThemeTextureInterpretation, CGSize, _CUIThemeTexturePixelFormat, size_t *)");
      id v37 = 0;
    }

    if (v37) {
      goto LABEL_18;
    }
    goto LABEL_20;
  }
  id v37 = +[TXRDataConverter newImageFromSourceImage:v21 newPixelFormat:v15 bufferAllocator:v16 gammaDegamma:v20 error:&v47];
  if (!v37)
  {
LABEL_20:
    _CUILog(4, (uint64_t)"CoreUI: %s got error '%@' converting scaled image", v38, v39, v40, v41, v42, v43, (uint64_t)"CFDataRef CUIConvertImageToPixelFormat(CGImageRef, BOOL, int32_t, _CUIThemeTextureInterpretation, CGSize, _CUIThemeTexturePixelFormat, size_t *)");
    goto LABEL_21;
  }
LABEL_18:
  *a6 = [v37 bytesPerRow];
  CFDataRef v44 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)objc_msgSend(objc_msgSend(objc_msgSend(v37, "buffer"), "map"), "bytes"), (CFIndex)objc_msgSend(v37, "bytesPerImage"));

LABEL_22:
  return v44;
}

uint64_t CUIGetFormatForFeatureSetAndPixelFormat(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = 1;
  uint64_t v9 = 1001;
  switch(*a2)
  {
    case 0:
      int v8 = 0;
      goto LABEL_5;
    case 1:
      break;
    case 2:
      uint64_t v9 = 1002;
      break;
    case 4:
      uint64_t v9 = 1003;
      break;
    case 5:
      uint64_t v9 = 1004;
      break;
    case 6:
      uint64_t v9 = 1005;
      break;
    case 7:
      uint64_t v9 = 1006;
      break;
    case 8:
      uint64_t v9 = 1007;
      break;
    case 9:
      uint64_t v9 = 1008;
      break;
    case 10:
      uint64_t v9 = 1009;
      break;
    default:
      int v8 = 1;
LABEL_5:
      uint64_t v9 = 3001;
      break;
  }
  if ((a1 & 0xFFFFFFFFFFFFFFFDLL) != 0) {
    uint64_t v10 = 1000;
  }
  else {
    uint64_t v10 = 3000;
  }
  if (a5)
  {
    id v11 = 0;
  }
  else
  {
    id v11 = objc_alloc_init((Class)TXROptions);
    [v11 setColorSpaceHandling:3];
  }
  id v12 = +[TXRDataConverter newPixelFormatSetForCGImage:a4 displayGamut:a3 == 1 options:v11];

  if (v8)
  {
    while (1)
    {
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      id v13 = [v12 countByEnumeratingWithState:&v22 objects:v26 count:16];
      if (v13)
      {
        id v14 = v13;
        uint64_t v15 = *(void *)v23;
LABEL_22:
        uint64_t v16 = 0;
        while (1)
        {
          if (*(void *)v23 != v15) {
            objc_enumerationMutation(v12);
          }
          id v17 = *(void **)(*((void *)&v22 + 1) + 8 * v16);
          +[TXRPixelFormatInfo isASTC:](TXRPixelFormatInfo, "isASTC:", [v17 unsignedIntegerValue]);
          [v17 unsignedIntegerValue];
          if (MTLGPUFamilySupportsSamplingFromPixelFormat()) {
            break;
          }
          if (v14 == (id)++v16)
          {
            id v14 = [v12 countByEnumeratingWithState:&v22 objects:v26 count:16];
            if (v14) {
              goto LABEL_22;
            }
            goto LABEL_30;
          }
        }
        id v18 = [v17 unsignedIntegerValue];
        if (v18) {
          goto LABEL_37;
        }
      }
LABEL_30:
      if (v9 == v10) {
        break;
      }
      if ((unint64_t)(v9 - 1002) > 8) {
        uint64_t v19 = 2;
      }
      else {
        uint64_t v19 = qword_1A139E3B0[v9 - 1002];
      }
      --v9;
      *a2 = v19;
    }
    *a2 = 0;
  }
  id v18 = objc_msgSend(objc_msgSend(v12, "lastObject"), "unsignedIntegerValue");
LABEL_37:
  uint64_t v20 = (uint64_t)v18;

  return CUIConvertFromTXRPixelFormat(v20);
}

void CPSDFile::CPSDFile(CPSDFile *this)
{
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((unsigned char *)this + 32) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_WORD *)this + 22) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 12) = 0;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
  *((_WORD *)this + 44) = 0;
  *(void *)this = &unk_1EF4870E8;
  *((void *)this + 14) = &unk_1EF485E10;
  *((void *)this + 16) = 0;
  *(void *)((char *)this + 134) = 0;
  *((_DWORD *)this + 38) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 20) = &unk_1EF4862C0;
  *((_DWORD *)this + 44) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = &unk_1EF486470;
  *((_DWORD *)this + 52) = 0;
  *((void *)this + 27) = 0;
  CPSDLayerAndMaskInfo::CPSDLayerAndMaskInfo((CPSDFile *)((char *)this + 224));
  *((unsigned char *)this + 392) = 0;
  *((void *)this + 1) = this;
  *((void *)this + 21) = this;
  *((void *)this + 29) = this;
  *((void *)this + 32) = this;
}

void CPSDImageResources::~CPSDImageResources(CPSDImageResources *this)
{
  *(void *)this = &unk_1EF486470;
  uint64_t v1 = (void *)*((void *)this + 3);
  if (v1)
  {
    do
    {
      uint64_t v2 = (void *)v1[37];
      (*(void (**)(void *))(*v1 + 8))(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

{
  void *v1;
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF486470;
  uint64_t v1 = (void *)*((void *)this + 3);
  if (v1)
  {
    do
    {
      uint64_t v2 = (void *)v1[37];
      (*(void (**)(void *))(*v1 + 8))(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
  JUMPOUT(0x1A6230DF0);
}

void CPSDColorModeData::~CPSDColorModeData(CPSDColorModeData *this)
{
  *(void *)this = &unk_1EF4862C0;
  uint64_t v1 = (void *)*((void *)this + 3);
  if (v1) {
    free(v1);
  }
}

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF4862C0;
  uint64_t v1 = (void *)*((void *)this + 3);
  if (v1) {
    free(v1);
  }
  JUMPOUT(0x1A6230DF0);
}

void CPSDImageLoad::~CPSDImageLoad(void **this)
{
  *this = &unk_1EF485EC0;
  CPSDImageLoad::DeAllocateChannelBuffers((CPSDImageLoad *)this);
  uint64_t v2 = this[12];
  if (v2)
  {
    free(v2);
    this[12] = 0;
    this[8] = 0;
  }
  free(this[2]);
  this[2] = 0;
}

void CPSDFile::~CPSDFile(CPSDFile *this)
{
  *(void *)this = &unk_1EF4870E8;
  CPSDLayerAndMaskInfo::~CPSDLayerAndMaskInfo((CPSDFile *)((char *)this + 224));
  *((void *)this + 24) = &unk_1EF486470;
  uint64_t v2 = (void *)*((void *)this + 27);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)v2[37];
      (*(void (**)(void *))(*v2 + 8))(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  *((void *)this + 20) = &unk_1EF4862C0;
  BOOL v4 = (void *)*((void *)this + 23);
  if (v4) {
    free(v4);
  }
  CPSDImageLoad::~CPSDImageLoad((void **)this);
}

{
  uint64_t vars8;

  CPSDFile::~CPSDFile(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDBaseComponent::SetFileObject(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

uint64_t CPSDLayerAndMaskInfo::SetFileObject(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  *(void *)(result + 32) = a2;
  return result;
}

void *CPSDFile::Init(CPSDFile *this, int a2, int a3, const unsigned __int8 *a4, size_t size)
{
  *((_DWORD *)this + 32) = 943870035;
  *((_WORD *)this + 66) = 1;
  *((_DWORD *)this + 36) = a3;
  *((_DWORD *)this + 37) = a2;
  *((_WORD *)this + 70) = 3;
  *((_DWORD *)this + 38) = 196616;
  CPSDImageResources::AddICCData((CPSDFile *)((char *)this + 192), a4, size);
  return CPSDFile::InitCompositeData(this);
}

CPSDBaseComponent *CPSDImageResources::AddICCData(CPSDBaseComponent *this, const unsigned __int8 *a2, size_t size)
{
  if (a2 && size)
  {
    BOOL v5 = this;
    uint64_t v7 = (uint64_t *)((char *)this + 24);
    uint64_t v6 = *((void *)this + 3);
    if (v6)
    {
      while (*(_WORD *)(v6 + 20) != 1039)
      {
        uint64_t v6 = *(void *)(v6 + 296);
        if (!v6) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      uint64_t v6 = operator new();
      *(void *)uint64_t v6 = &unk_1EF486AE0;
      *(_DWORD *)(v6 + 280) = 0;
      *(unsigned char *)(v6 + 22) = 0;
      *(void *)(v6 + 288) = 0;
      *(void *)(v6 + 296) = 0;
      *(_DWORD *)(v6 + 16) = 943868237;
      *(_WORD *)(v6 + 20) = 1039;
      uint64_t v8 = operator new();
      *(_DWORD *)(v8 + 16) = 0;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0;
      *(void *)(v8 + 40) = v6;
      *(void *)(v8 + 48) = 0;
      *(void *)uint64_t v8 = &unk_1EF486EC0;
      *(void *)(v6 + 288) = v8;
      uint64_t v9 = *v7;
      if (*v7)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = *(void *)(v9 + 296);
        }
        while (v9);
        uint64_t v7 = (uint64_t *)(v10 + 296);
      }
      *uint64_t v7 = v6;
    }
    id v11 = *(CPSDICCProfileResourceItem **)(v6 + 288);
    if (!v11)
    {
      exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
      CStdException::CStdException(exception, 3238789123);
    }
    CPSDICCProfileResourceItem::AddICCData(v11, a2, size);
    return CPSDImageResources::UpdateResourceSize(v5, v11);
  }
  return this;
}

void sub_1A1335D78(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *CPSDFile::InitCompositeData(CPSDFile *this)
{
  (*(void (**)(CPSDFile *, void, void, void, void, void, void))(*(void *)this + 48))(this, *((unsigned int *)this + 37), *((unsigned int *)this + 36), *((unsigned __int16 *)this + 70), *((unsigned __int16 *)this + 76), *((unsigned __int16 *)this + 77), *((void *)this + 23));
  int v2 = *((_DWORD *)this + 6);
  size_t v3 = *((_DWORD *)this + 37)
     * *((unsigned __int16 *)this + 70)
     * *((_DWORD *)this + 36)
     * (*((unsigned __int16 *)this + 76) >> 3);
  *((_DWORD *)this + 6) = v3;
  uint64_t result = (void *)*((void *)this + 2);
  if (!result || v2 != v3)
  {
    uint64_t result = malloc_type_realloc(result, v3, 0x26A5A854uLL);
    *((void *)this + 2) = result;
  }
  *((unsigned char *)this + 392) = 1;
  return result;
}

CPSDBaseComponent *CPSDFile::AddExtraAlphaChannel(CPSDFile *this, unsigned __int8 *a2, unsigned int a3, const CPSDString *a4)
{
  if ((unsigned __int16)(*((_WORD *)this + 70) + 1) > 0x38u
    || (char v8 = *((unsigned char *)this + 392),
        ++*((_WORD *)this + 70),
        CPSDFile::InitCompositeData(this),
        unsigned int v9 = *((_DWORD *)this + 37)
           * (unsigned __int16)(*((_WORD *)this + 70) - 1)
           * *((_DWORD *)this + 36)
           * (*((unsigned __int16 *)this + 76) >> 3),
        *((_DWORD *)this + 6) - v9 < a3))
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  memcpy((void *)(*((void *)this + 2) + v9), a2, a3);
  uint64_t result = CPSDImageResources::AddExtraChannelName((CPSDFile *)((char *)this + 192), a4);
  *((unsigned char *)this + 392) = v8;
  return result;
}

void sub_1A1335F38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

CPSDBaseComponent *CPSDImageResources::AddExtraChannelName(CPSDImageResources *this, const CPSDString *a2)
{
  BOOL v5 = (uint64_t *)((char *)this + 24);
  uint64_t v4 = *((void *)this + 3);
  if (v4)
  {
    while (*(_WORD *)(v4 + 20) != 1045)
    {
      uint64_t v4 = *(void *)(v4 + 296);
      if (!v4) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    uint64_t v4 = operator new();
    *(void *)uint64_t v4 = &unk_1EF486AE0;
    *(_DWORD *)(v4 + 280) = 0;
    *(unsigned char *)(v4 + 22) = 0;
    *(void *)(v4 + 288) = 0;
    *(void *)(v4 + 296) = 0;
    *(_DWORD *)(v4 + 16) = 943868237;
    *(_WORD *)(v4 + 20) = 1045;
    uint64_t v6 = operator new();
    *(_DWORD *)(v6 + 16) = 0;
    *(void *)(v6 + 24) = 0;
    *(void *)(v6 + 32) = 0;
    *(void *)(v6 + 40) = v4;
    *(void *)(v6 + 48) = 0;
    *(void *)uint64_t v6 = &unk_1EF486D40;
    *(void *)(v6 + 56) = 0;
    *(void *)(v6 + 64) = 0;
    *(void *)(v4 + 288) = v6;
    uint64_t v7 = *v5;
    if (*v5)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = *(void *)(v7 + 296);
      }
      while (v7);
      BOOL v5 = (uint64_t *)(v8 + 296);
    }
    uint64_t *v5 = v4;
  }
  unsigned int v9 = *(CPSDUnicodeChannelNames **)(v4 + 288);
  if (!v9)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  CPSDUnicodeChannelNames::AddName(v9, a2);
  return CPSDImageResources::UpdateResourceSize(this, v9);
}

void sub_1A13360BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void CPSDFile::AddLayerCore(CPSDFile *this, CPSDLayerRecord *a2, const UniChar **a3, char a4, int a5)
{
  *((_DWORD *)a2 + 16) = 943868237;
  *((_DWORD *)a2 + 17) = a5;
  *((unsigned char *)a2 + 72) = a4;
  *((unsigned char *)a2 + 74) = 8;
  uint64_t v8 = (CPSDLayerRecord *)((char *)a2 + 144);
  CPSDLayerBlendingRanges::Init((CPSDLayerRecord *)((char *)a2 + 144), 4u);
  CPSDString::CopyStringValue(a3, (char *)a2 + 200, 0x100u);
  LODWORD(a3) = CPSDBaseComponent::ComputeSize((CPSDLayerRecord *)((char *)a2 + 456));
  *((_DWORD *)a2 + 118) = a3;
  File::File((File *)v13, 0, 0);
  v13[0] = &unk_1EF485E50;
  uint64_t v14 = 0;
  CPSDLayerMaskData::Save((CPSDLayerRecord *)((char *)a2 + 80), (File *)v13);
  CPSDLayerBlendingRanges::Save(v8, (File *)v13);
  ByteCounter::AppendAsPString((uint64_t)v13, (char *)a2 + 200, 4);
  *((_DWORD *)a2 + 19) = v14 + a3;
  unint64_t v9 = *((void *)this + 35);
  if (v9 >= *((void *)this + 36))
  {
    uint64_t v10 = std::vector<CPSDLayerRecord>::__push_back_slow_path<CPSDLayerRecord>((uint64_t *)this + 34, (uint64_t)a2);
  }
  else
  {
    CPSDLayerRecord::CPSDLayerRecord(*((void *)this + 35), (uint64_t)a2);
    uint64_t v10 = v9 + 488;
    *((void *)this + 35) = v9 + 488;
  }
  *((void *)this + 35) = v10;
  ++*((_WORD *)this + 134);
  int v11 = CPSDBaseComponent::ComputeSize((CPSDFile *)((char *)this + 248));
  int v12 = (v11 & 1) + v11;
  *((_DWORD *)this + 66) = v12;
  *((_DWORD *)this + 60) = v12 + 4;
  *((unsigned char *)this + 392) = 1;
  File::~File((File *)v13);
}

void sub_1A1336264(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  File::~File((File *)va);
  _Unwind_Resume(a1);
}

uint64_t *CPSDLayerBlendingRanges::Init(CPSDLayerBlendingRanges *this, unsigned int a2)
{
  uint64_t v4 = (uint64_t *)((char *)this + 32);
  BOOL v5 = (void (***)(void))*((void *)this + 4);
  *(void *)((char *)this + 20) = 0xFFFF0000FFFFLL;
  uint64_t v6 = (void (***)(void))*((void *)this + 5);
  if (v6 != v5)
  {
    uint64_t v7 = v6 - 3;
    uint64_t v8 = v6 - 3;
    unint64_t v9 = v6 - 3;
    do
    {
      uint64_t v10 = *v9;
      v9 -= 3;
      (*v10)(v8);
      v7 -= 3;
      BOOL v11 = v8 == v5;
      uint64_t v8 = v9;
    }
    while (!v11);
  }
  *((void *)this + 5) = v5;
  uint64_t v12 = a2;
  uint64_t result = std::vector<CPSDChannelBlendingInfo>::resize(v4, a2);
  if (a2)
  {
    uint64_t v14 = (void *)(*v4 + 16);
    do
    {
      *uint64_t v14 = 0xFFFF0000FFFFLL;
      v14 += 3;
      --v12;
    }
    while (v12);
  }
  *((_DWORD *)this + 4) = 8 * a2 + 8;
  return result;
}

void CPSDString::CopyStringValue(const UniChar **this, char *a2, unsigned int a3)
{
  CFStringRef v5 = CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault, this[1], *(unsigned int *)this, kCFAllocatorNull);
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  CFStringGetCString(v5, a2, a3, SystemEncoding);
  CFRelease(v5);
}

uint64_t CPSDBaseComponent::ComputeSize(CPSDBaseComponent *this)
{
  File::File((File *)v4, 0, 0);
  v4[0] = &unk_1EF485E50;
  uint64_t v5 = 0;
  (*(void (**)(CPSDBaseComponent *, void *))(*(void *)this + 24))(this, v4);
  uint64_t v2 = v5;
  File::~File((File *)v4);
  return v2;
}

void sub_1A13364C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  File::~File((File *)va);
  _Unwind_Resume(a1);
}

uint64_t CPSDLayerMaskData::Save(CPSDLayerMaskData *this, File *a2)
{
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4))
  {
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 5));
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 6));
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 7));
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 8));
    (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 36));
    (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 37));
    uint64_t v5 = *(void *)a2;
    if (*((_DWORD *)this + 4) == 20)
    {
      uint64_t v6 = *((unsigned __int16 *)this + 19);
      uint64_t v7 = *(uint64_t (**)(File *, uint64_t))(v5 + 72);
      return v7(a2, v6);
    }
    else
    {
      (*(void (**)(File *, void))(v5 + 64))(a2, *((unsigned __int8 *)this + 57));
      (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 56));
      (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 10));
      (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 11));
      (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 12));
      uint64_t v8 = *((unsigned int *)this + 13);
      unint64_t v9 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80);
      return v9(a2, v8);
    }
  }
  return result;
}

uint64_t CPSDLayerBlendingRanges::Save(CPSDLayerBlendingRanges *this, File *a2)
{
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4) >= 8u)
  {
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 5));
    uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 6));
    unsigned int v5 = *((_DWORD *)this + 4) - 8;
    if (v5 >= 8)
    {
      unsigned int v6 = v5 >> 3;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 3) == v6)
      {
        uint64_t v7 = 0;
        if (v6 <= 1) {
          unsigned int v6 = 1;
        }
        uint64_t v8 = 24 * v6;
        do
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, File *))(*(void *)(*((void *)this + 4) + v7) + 24))(*((void *)this + 4) + v7, a2);
          v7 += 24;
        }
        while (v8 != v7);
      }
    }
  }
  return result;
}

void CPSDFile::AddLayer(CPSDFile *this, unsigned __int8 **a2, int a3, const UniChar **a4, char a5, int a6)
{
  uint64_t v12 = *((unsigned __int16 *)this + 134);
  CPSDLayerRecord::CPSDLayerRecord((CPSDLayerRecord *)v19);
  v19[2] = 0;
  v19[3] = *(void *)((char *)this + 36);
  __int16 v20 = 4;
  std::vector<CPSDChannelLengthInfo>::resize(v21, 4uLL);
  std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 296, ((uint64_t)(*((void *)this + 38) - *((void *)this + 37)) >> 3) + 1);
  id v13 = (CPSDLayerChannelGroup *)operator new();
  CPSDLayerChannelGroup::CPSDLayerChannelGroup(v13, (CPSDLayerRecord *)v19);
  CPSDLayerChannelGroup::Init((uint64_t)v13, a2, a3);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  *(void *)(*((void *)this + 37) + 8 * v12) = v13;
  do
  {
    uint64_t v16 = v21[0];
    int v17 = CPSDLayerChannelGroup::ComputeSizeForChannel(v13, v15);
    uint64_t v18 = v16 + v14;
    *(_WORD *)(v18 + 16) = v15 - 1;
    *(_DWORD *)(v18 + 20) = v17;
    ++v15;
    v14 += 24;
  }
  while (v15 != 4);
  CPSDFile::AddLayerCore(this, (CPSDLayerRecord *)v19, a4, a5, a6);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)v19);
}

void sub_1A1336A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x1A6230DF0](v9, 0x10A1C401A1F3E30);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<CPSDChannelLengthInfo>::resize(uint64_t *result, unint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *result) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    return (uint64_t *)std::vector<CPSDChannelLengthInfo>::__append(result, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *result + 24 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = v3 - 24;
      uint64_t v9 = (uint64_t (***)(void))(v3 - 24);
      uint64_t v10 = (uint64_t (***)(void))(v3 - 24);
      do
      {
        BOOL v11 = *v10;
        v10 -= 3;
        uint64_t result = (uint64_t *)(*v11)(v9);
        v8 -= 24;
        BOOL v12 = v9 == (uint64_t (***)(void))v7;
        uint64_t v9 = v10;
      }
      while (!v12);
    }
    v2[1] = v7;
  }
  return result;
}

void std::vector<CPSDLayerChannelGroup *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<CPSDLayerChannelGroup *>::__append((void **)a1, a2 - v2);
  }
}

uint64_t CPSDLayerChannelGroup::Init(uint64_t this, unsigned __int8 **a2, int a3)
{
  if (*(_DWORD *)(this + 24) != 4) {
    CPSDLayerChannelGroup::Init();
  }
  uint64_t v3 = 0;
  unint64_t v4 = (_DWORD *)(*(void *)(this + 32) + 48);
  do
  {
    BOOL v5 = a2[v3];
    *((_WORD *)v4 - 12) = 0;
    *unint64_t v4 = a3;
    *((void *)v4 - 1) = v5;
    ++v3;
    v4 += 14;
  }
  while (v3 != 4);
  return this;
}

uint64_t CPSDLayerChannelGroup::ComputeSizeForChannel(CPSDLayerChannelGroup *this, unsigned int a2)
{
  if (*((_DWORD *)this + 6) <= a2) {
    CPSDLayerChannelGroup::ComputeSizeForChannel();
  }
  unint64_t v2 = (CPSDBaseComponent *)(*((void *)this + 4) + 56 * a2);
  return CPSDBaseComponent::ComputeSize(v2);
}

void CPSDFile::AddLayer(uint64_t a1, uint64_t a2, const UniChar **a3, char a4, int a5)
{
  uint64_t v10 = *(unsigned __int16 *)(a1 + 268);
  CPSDLayerRecord::CPSDLayerRecord((CPSDLayerRecord *)v35);
  uint64_t v36 = 0;
  uint64_t v37 = *(void *)(a1 + 36);
  __int16 v38 = 4;
  std::vector<CPSDChannelLengthInfo>::resize(v39, 4uLL);
  std::vector<CPSDLayerChannelGroup *>::resize(a1 + 296, ((uint64_t)(*(void *)(a1 + 304) - *(void *)(a1 + 296)) >> 3) + 1);
  BOOL v11 = (CPSDLayerChannelGroup *)operator new();
  uint64_t v32 = v10;
  uint64_t v30 = a3;
  int v31 = a5;
  CPSDLayerChannelGroup::CPSDLayerChannelGroup(v11, (CPSDLayerRecord *)v35);
  uint64_t v12 = 0;
  size_t v13 = (*(_DWORD *)(a1 + 144) * *(_DWORD *)(a1 + 148));
  *(_OWORD *)uint64_t v33 = 0u;
  long long v34 = 0u;
  do
  {
    uint64_t v14 = (unsigned __int8 *)malloc_type_malloc(v13, 0x3F94555DuLL);
    v33[v12] = v14;
    uint64_t v15 = (double *)(a2 + 80);
    switch((int)v12)
    {
      case 0:
        goto LABEL_6;
      case 1:
        uint64_t v15 = (double *)(a2 + 56);
        goto LABEL_6;
      case 2:
        uint64_t v15 = (double *)(a2 + 64);
        goto LABEL_6;
      case 3:
        uint64_t v15 = (double *)(a2 + 72);
LABEL_6:
        float v16 = *v15;
        memset(v14, llroundf(v16), v13);
        break;
      default:
        break;
    }
    ++v12;
  }
  while (v12 != 4);
  CPSDLayerChannelGroup::Init((uint64_t)v11, v33, v13);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  *(void *)(*(void *)(a1 + 296) + 8 * v32) = v11;
  do
  {
    uint64_t v19 = v39[0];
    int v20 = CPSDLayerChannelGroup::ComputeSizeForChannel(v11, v18);
    uint64_t v21 = v19 + v17;
    *(_WORD *)(v21 + 16) = v18 - 1;
    *(_DWORD *)(v21 + 20) = v20;
    ++v18;
    v17 += 24;
  }
  while (v18 != 4);
  long long v22 = (CPSDActionDescriptor *)operator new();
  CPSDActionDescriptor::CPSDActionDescriptor(v22);
  *(void *)long long v22 = &unk_1EF486F10;
  *((void *)v22 + 15) = 0;
  CPSDObjectEffectsLayerInfo::InitWithGradient((uint64_t)v22, a2);
  CPSDAdditionalLayerInfoItem::SizeUpItem(v22);
  long long v23 = &v40;
  uint64_t v24 = v40;
  long long v25 = (CPSDActionDescriptor **)&v40;
  if (v40)
  {
    do
    {
      uint64_t v26 = v24;
      uint64_t v24 = *(void *)(v24 + 48);
    }
    while (v24);
    long long v25 = (CPSDActionDescriptor **)(v26 + 48);
  }
  *long long v25 = v22;
  uint64_t v27 = operator new();
  *(_DWORD *)(v27 + 16) = 0;
  *(_OWORD *)(v27 + 40) = 0u;
  *(_OWORD *)(v27 + 24) = 0u;
  *(void *)uint64_t v27 = &unk_1EF486958;
  *(void *)(v27 + 40) = 0x694F70613842494DLL;
  *(unsigned char *)(v27 + 56) = 0;
  CPSDAdditionalLayerInfoItem::SizeUpItem((CPSDAdditionalLayerInfoItem *)v27);
  uint64_t v28 = v40;
  if (v40)
  {
    do
    {
      uint64_t v29 = v28;
      uint64_t v28 = *(void *)(v28 + 48);
    }
    while (v28);
    long long v23 = (uint64_t *)(v29 + 48);
  }
  *long long v23 = v27;
  CPSDFile::AddLayerCore((CPSDFile *)a1, (CPSDLayerRecord *)v35, v30, a4, v31);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)v35);
}

void sub_1A1336F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  MEMORY[0x1A6230DF0](v10, 0x10B1C4032540B95);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)va);
  _Unwind_Resume(a1);
}

void CPSDObjectEffectsLayerInfo::InitWithGradient(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0x6C6678323842494DLL;
  *(void *)(a1 + 120) = 0x1000000000;
  *(_DWORD *)(a1 + 84) = 1853189228;
  uint64_t v4 = operator new();
  *(_DWORD *)(v4 + 16) = 0;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(void *)uint64_t v4 = &unk_1EF486658;
  *(_DWORD *)(v4 + 56) = 592474723;
  *(void *)(v4 + 64) = 0x4059000000000000;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v10, 1399024672, (CPSDActionBaseComponent *)v4);
  CPSDActionDescriptor::AdoptItem((CPSDActionDescriptor *)a1, (CPSDActionKeyedItem *)v10);
  uint64_t v5 = operator new();
  *(_DWORD *)(v5 + 16) = 0;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(void *)uint64_t v5 = &unk_1EF486340;
  *(unsigned char *)(v5 + 56) = 1;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v9, "masterFXSwitch", (CPSDActionBaseComponent *)v5);
  uint64_t v6 = CPSDActionDescriptor::AdoptItem((CPSDActionDescriptor *)a1, (CPSDActionKeyedItem *)v9);
  GradientOverlayObject = CPSDObjectEffectsLayerInfo::MakeGradientOverlayObject(v6, a2);
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v8, 1198671468, GradientOverlayObject);
  CPSDActionDescriptor::AdoptItem((CPSDActionDescriptor *)a1, (CPSDActionKeyedItem *)v8);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v8);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v9);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v10);
}

void sub_1A1337124(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v2 - 120));
  _Unwind_Resume(a1);
}

uint64_t CPSDAdditionalLayerInfoItem::SizeUpItem(CPSDAdditionalLayerInfoItem *this)
{
  int v2 = CPSDBaseComponent::ComputeSize(this);
  uint64_t v3 = v2 & 3;
  if ((v2 & 3) != 0)
  {
    size_t v4 = 4 - v3;
    uint64_t v6 = *((void *)this + 3);
    uint64_t v5 = (void *)*((void *)this + 4);
    size_t v7 = v6 + 4 - v3;
    *((void *)this + 3) = v7;
    uint64_t v8 = (char *)malloc_type_realloc(v5, v7, 0x1F095122uLL);
    *((void *)this + 4) = v8;
    bzero(&v8[v6], v4);
  }
  else
  {
    LODWORD(v4) = 0;
  }
  *((_DWORD *)this + 4) = v2 + v4 - 12;
  return (v2 + v4 - 12);
}

void CPSDFile::AddLayerGroupEnd(CPSDFile *this, const UniChar **a2, char a3, int a4)
{
}

void CPSDFile::AddSectionDivider(CPSDFile *this, int a2, const UniChar **a3, char a4, int a5)
{
  uint64_t v10 = *((unsigned __int16 *)this + 134);
  CPSDLayerRecord::CPSDLayerRecord((CPSDLayerRecord *)v23);
  __int16 v24 = 4;
  std::vector<CPSDChannelLengthInfo>::resize(v25, 4uLL);
  std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 296, ((uint64_t)(*((void *)this + 38) - *((void *)this + 37)) >> 3) + 1);
  uint64_t v11 = (CPSDLayerChannelGroup *)operator new();
  CPSDLayerChannelGroup::CPSDLayerChannelGroup(v11, (CPSDLayerRecord *)v23);
  memset(v22, 0, sizeof(v22));
  CPSDLayerChannelGroup::Init((uint64_t)v11, (unsigned __int8 **)v22, 0);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  *(void *)(*((void *)this + 37) + 8 * v10) = v11;
  do
  {
    uint64_t v14 = v25[0];
    int v15 = CPSDLayerChannelGroup::ComputeSizeForChannel(v11, v13);
    uint64_t v16 = v14 + v12;
    *(_WORD *)(v16 + 16) = v13 - 1;
    *(_DWORD *)(v16 + 20) = v15;
    ++v13;
    v12 += 24;
  }
  while (v13 != 4);
  uint64_t v17 = operator new();
  uint64_t v18 = v17;
  *(_DWORD *)(v17 + 16) = 0;
  *(_OWORD *)(v17 + 40) = 0u;
  *(_OWORD *)(v17 + 24) = 0u;
  *(void *)uint64_t v17 = &unk_1EF4864F0;
  *(_DWORD *)(v17 + 60) = 0;
  *(_DWORD *)(v17 + 64) = 0;
  *(void *)(v17 + 40) = 0x6C7363743842494DLL;
  *(_DWORD *)(v17 + 56) = a2;
  if ((a2 - 1) <= 1)
  {
    *(_DWORD *)(v17 + 16) = 12;
    *(_DWORD *)(v17 + 60) = 943868237;
    *(_DWORD *)(v17 + 64) = a5;
  }
  CPSDAdditionalLayerInfoItem::SizeUpItem((CPSDAdditionalLayerInfoItem *)v17);
  uint64_t v19 = v26;
  if (v26)
  {
    do
    {
      uint64_t v20 = v19;
      uint64_t v19 = *(void *)(v19 + 48);
    }
    while (v19);
    uint64_t v21 = (uint64_t *)(v20 + 48);
  }
  else
  {
    uint64_t v21 = &v26;
  }
  *uint64_t v21 = v18;
  CPSDFile::AddLayerCore(this, (CPSDLayerRecord *)v23, a3, a4, 1852797549);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)v23);
}

void sub_1A133740C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  CPSDLayerRecord::~CPSDLayerRecord((CPSDLayerRecord *)va);
  _Unwind_Resume(a1);
}

_WORD *CPSDFile::AddLayerGroupStart(CPSDFile *this)
{
  size_t v4 = 0;
  CPSDString::AllocateCharData((CPSDString *)&v3, 1);
  *size_t v4 = 0;
  CPSDFile::AddSectionDivider(this, 3, &v3, 255, 1885434739);
  uint64_t result = v4;
  if (v4) {
    return (_WORD *)MEMORY[0x1A6230DD0](v4, 0x1000C80BDFB0063);
  }
  return result;
}

void sub_1A13374C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x1A6230DD0](a10, 0x1000C80BDFB0063);
  }
  _Unwind_Resume(exception_object);
}

CPSDBaseComponent *CPSDFile::AddOrUpdateSlices(CPSDFile *this, int32x4_t *a2, int a3)
{
  return CPSDImageResources::AddOrUpdateSlices((CPSDFile *)((char *)this + 192), a2, a3, *((_DWORD *)this + 37), *((_DWORD *)this + 36));
}

CPSDBaseComponent *CPSDImageResources::AddOrUpdateSlices(CPSDImageResources *this, int32x4_t *a2, int a3, int a4, int a5)
{
  uint64_t v11 = (uint64_t *)((char *)this + 24);
  uint64_t v10 = *((void *)this + 3);
  if (v10)
  {
    while (*(_WORD *)(v10 + 20) != 1050)
    {
      uint64_t v10 = *(void *)(v10 + 296);
      if (!v10) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    uint64_t v10 = operator new();
    *(void *)uint64_t v10 = &unk_1EF486AE0;
    *(_DWORD *)(v10 + 280) = 0;
    *(unsigned char *)(v10 + 22) = 0;
    *(void *)(v10 + 288) = 0;
    *(void *)(v10 + 296) = 0;
    *(_DWORD *)(v10 + 16) = 943868237;
    *(_WORD *)(v10 + 20) = 1050;
    uint64_t v12 = (CPSDSlicesResourceItem *)operator new();
    CPSDSlicesResourceItem::CPSDSlicesResourceItem(v12, (CPSDImageResourceBlock *)v10, 0);
    *(void *)(v10 + 288) = v12;
    uint64_t v13 = *v11;
    if (*v11)
    {
      do
      {
        uint64_t v14 = v13;
        uint64_t v13 = *(void *)(v13 + 296);
      }
      while (v13);
      uint64_t v11 = (uint64_t *)(v14 + 296);
    }
    *uint64_t v11 = v10;
  }
  int v15 = *(CPSDSlicesResourceItem **)(v10 + 288);
  if (!v15)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  CPSDSlicesResourceItem::AddOrUpdateSlices(v15, a2, a3, a4, a5);
  return CPSDImageResources::UpdateResourceSize(this, v15);
}

void sub_1A133767C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

CPSDBaseComponent *CPSDFile::UpdateSliceNameAtIndex(CPSDFile *this, const unsigned __int16 *a2, int a3, unsigned int a4)
{
  return CPSDImageResources::UpdateSliceNameAtIndex((CPSDFile *)((char *)this + 192), a2, a3, a4);
}

CPSDBaseComponent *CPSDImageResources::UpdateSliceNameAtIndex(CPSDImageResources *this, const unsigned __int16 *a2, int a3, unsigned int a4)
{
  uint64_t v8 = (CPSDSlicesResourceItem *)CPSDImageResources::LookupResourceWithResID(this, 1050);
  CPSDSlicesResourceItem::UpdateSliceNameAtIndex(v8, a2, a3, a4);
  return CPSDImageResources::UpdateResourceSize(this, v8);
}

size_t CPSDFile::Dump(CPSDFile *this, __sFILE *__stream)
{
  fwrite("{ PSDFile: \n", 0xCuLL, 1uLL, __stream);
  fprintf(__stream, "Header: { %dx%d %d bps, %d channels, mode = %d }\n", *((_DWORD *)this + 36), *((_DWORD *)this + 37), *((unsigned __int16 *)this + 76), *((unsigned __int16 *)this + 70), *((unsigned __int16 *)this + 77));
  if (*((_DWORD *)this + 44)) {
    fprintf(__stream, "{ ColorModeData:       [ %d ] bytes }\n", *((_DWORD *)this + 44));
  }
  uint64_t v4 = *((void *)this + 27);
  if (v4) {
    (*(void (**)(uint64_t, __sFILE *))(*(void *)v4 + 40))(v4, __stream);
  }
  CPSDLayerAndMaskInfo::Dump((CPSDFile *)((char *)this + 224), __stream);
  return fwrite("}\n", 2uLL, 1uLL, __stream);
}

uint64_t CPSDHeader::Dump(CPSDHeader *this, __sFILE *a2)
{
  return fprintf(a2, "Header: { %dx%d %d bps, %d channels, mode = %d }\n", *((_DWORD *)this + 8), *((_DWORD *)this + 9), *((unsigned __int16 *)this + 20), *((unsigned __int16 *)this + 14), *((unsigned __int16 *)this + 21));
}

uint64_t CPSDColorModeData::Dump(uint64_t this, __sFILE *a2)
{
  if (*(_DWORD *)(this + 16)) {
    return fprintf(a2, "{ ColorModeData:       [ %d ] bytes }\n", *(_DWORD *)(this + 16));
  }
  return this;
}

uint64_t CPSDImageResources::Dump(CPSDImageResources *this, __sFILE *a2)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    return (*(uint64_t (**)(uint64_t, __sFILE *))(*(void *)result + 40))(result, a2);
  }
  return result;
}

uint64_t CPSDLayerAndMaskInfo::Dump(CPSDLayerAndMaskInfo *this, __sFILE *a2)
{
  fprintf(a2, "{ LayerAndMaskInfo: [%d bytes]\n", *((_DWORD *)this + 4));
  CPSDLayerInfo::Dump((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
  return fputc(125, a2);
}

uint64_t CPSDFile::Load(CPSDFile *this, uint64_t a2)
{
  if (!CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2)
    || !CPSDColorModeData::Load((CPSDFile *)((char *)this + 160), a2)
    || !CPSDImageResources::Load((CPSDFile *)((char *)this + 192), a2)
    || !CPSDLayerAndMaskInfo::Load((CPSDFile *)((char *)this + 224), a2))
  {
    return 0;
  }
  (*(void (**)(CPSDFile *, void, void, void, void, void, void))(*(void *)this + 48))(this, *((unsigned int *)this + 37), *((unsigned int *)this + 36), *((unsigned __int16 *)this + 70), *((unsigned __int16 *)this + 76), *((unsigned __int16 *)this + 77), *((void *)this + 23));
  return CPSDFile::LoadImageData(this, a2, 0);
}

uint64_t CPSDHeader::Load(CPSDHeader *this, int a2)
{
  int v13 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v13);
  LOBYTE(v4) = 0;
  unsigned int v5 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v5);
  if (v5 == 1397768760)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 2uLL, &v13);
    unsigned int v6 = *((unsigned __int16 *)this + 10);
    *((_WORD *)this + 10) = __rev16(v6);
    if (v6 != 256) {
      goto LABEL_9;
    }
    CPSDBaseComponent::ReadFile(a2, (char *)this + 22, 6uLL, &v13);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 2uLL, &v13);
    unsigned int v7 = bswap32(*((unsigned __int16 *)this + 14)) >> 16;
    *((_WORD *)this + 14) = v7;
    if ((unsigned __int16)(v7 - 25) < 0xFFE8u) {
      goto LABEL_9;
    }
    CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 4uLL, &v13);
    unsigned int v8 = bswap32(*((_DWORD *)this + 8));
    *((_DWORD *)this + 8) = v8;
    if (v8 - 30001 < 0xFFFF8AD0) {
      goto LABEL_9;
    }
    CPSDBaseComponent::ReadFile(a2, (char *)this + 36, 4uLL, &v13);
    unsigned int v9 = bswap32(*((_DWORD *)this + 9));
    *((_DWORD *)this + 9) = v9;
    if (v9 - 30001 < 0xFFFF8AD0) {
      goto LABEL_9;
    }
    CPSDBaseComponent::ReadFile(a2, (char *)this + 40, 2uLL, &v13);
    LOBYTE(v4) = 0;
    unsigned int v10 = bswap32(*((unsigned __int16 *)this + 20)) >> 16;
    *((_WORD *)this + 20) = v10;
    if (v10 <= 0x10 && ((1 << v10) & 0x10102) != 0)
    {
      CPSDBaseComponent::ReadFile(a2, (char *)this + 42, 2uLL, &v13);
      unsigned int v11 = bswap32(*((unsigned __int16 *)this + 21)) >> 16;
      *((_WORD *)this + 21) = v11;
      if (v11 > 9)
      {
LABEL_9:
        LOBYTE(v4) = 0;
        return v4;
      }
      if (v11 > 6) {
        LOBYTE(v4) = 1;
      }
      else {
        return (0x101010100uLL >> (8 * v11));
      }
    }
  }
  return v4;
}

uint64_t CPSDColorModeData::Load(CPSDColorModeData *this, int a2)
{
  int v13 = 0;
  int v4 = *(unsigned __int16 *)(*((void *)this + 1) + 154);
  unsigned int v5 = (unsigned int *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v13);
  unsigned int v6 = *((_DWORD *)this + 4);
  off_t v7 = bswap32(v6);
  *((_DWORD *)this + 4) = v7;
  if (!v6) {
    return 1;
  }
  if (v4 != 2 || v6 != 196608) {
    return SetFilePointer(a2, v7, 0, 1) != -1;
  }
  unsigned int v8 = (void *)*((void *)this + 3);
  if (v8)
  {
    free(v8);
    size_t v9 = *v5;
  }
  else
  {
    size_t v9 = 768;
  }
  uint64_t result = (uint64_t)malloc_type_malloc(v9, 0x366AB81EuLL);
  *((void *)this + 3) = result;
  if (result)
  {
    unsigned int v11 = *v5;
    if (v11)
    {
      unsigned int v12 = 0;
      do
      {
        CPSDBaseComponent::ReadFile(a2, (char *)(*((void *)this + 3) + v12), v11, &v13);
        v12 += v13;
        v11 -= v13;
      }
      while (v11);
    }
    return 1;
  }
  return result;
}

BOOL CPSDImageResources::Load(CPSDImageResources *this, uint64_t a2)
{
  unsigned int v15 = 0;
  int v4 = (_DWORD *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v15);
  unsigned int v5 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v5);
  if (!v5) {
    return 1;
  }
  int v6 = SetFilePointer(a2, 0, 0, 1);
  unsigned int v7 = *((_DWORD *)this + 4);
  if (v7 >= 2)
  {
    unsigned int v8 = (uint64_t *)((char *)this + 24);
    do
    {
      uint64_t v9 = operator new();
      *(void *)uint64_t v9 = &unk_1EF486AE0;
      *(_DWORD *)(v9 + 16) = 0;
      *(_WORD *)(v9 + 20) = 0;
      *(_DWORD *)(v9 + 280) = 0;
      *(unsigned char *)(v9 + 22) = 0;
      *(void *)(v9 + 288) = 0;
      *(void *)(v9 + 296) = 0;
      unsigned int v15 = 0;
      if (!CPSDImageResourceBlock::Load((CPSDImageResourceBlock *)v9, a2, &v15))
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      uint64_t v10 = *v8;
      unsigned int v11 = v8;
      if (*v8)
      {
        do
        {
          uint64_t v12 = v10;
          uint64_t v10 = *(void *)(v10 + 296);
        }
        while (v10);
        unsigned int v11 = (uint64_t *)(v12 + 296);
      }
      v7 -= v15;
      *unsigned int v11 = v9;
    }
    while (v7 > 1);
  }
  return !v7 || SetFilePointer(a2, (*v4 + v6), 0, 0) != -1;
}

void sub_1A1337E84(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDLayerAndMaskInfo::Load(CPSDLayerAndMaskInfo *this, uint64_t a2)
{
  int v14 = 0;
  int v4 = (unsigned int *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v14);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  uint64_t v5 = 1;
  int v6 = SetFilePointer(a2, 0, 0, 1);
  if (*((_DWORD *)this + 4))
  {
    int v7 = v6;
    if (!CPSDLayerInfo::Load((CPSDLayerAndMaskInfo *)((char *)this + 24), a2)) {
      return 0;
    }
    int v8 = SetFilePointer(a2, 0, 0, 1);
    if (*v4 < v8 - v7) {
      return 0;
    }
    CPSDGlobalLayerMaskInfo::Load((CPSDLayerAndMaskInfo *)((char *)this + 96), a2, *v4 - (v8 - v7));
    unsigned int v9 = SetFilePointer(a2, 0, 0, 1) - v7;
    unsigned int v10 = *((_DWORD *)this + 4);
    BOOL v11 = v10 >= v9;
    unsigned int v12 = v10 - v9;
    if (!v11) {
      return 0;
    }
    if (v12)
    {
      *((_DWORD *)this + 38) = v12;
      if (!CPSDAdditionalLayerInfo::Load((CPSDLayerAndMaskInfo *)((char *)this + 136), a2)) {
        return 0;
      }
      unsigned int v9 = *v4;
    }
    SetFilePointer(a2, v9 + v7, 0, 0);
  }
  return v5;
}

uint64_t CPSDFile::LoadImageData(CPSDFile *this, int a2, int a3)
{
  if (!*((unsigned char *)this + 32)) {
    return 0;
  }
  int v14 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 88, 2uLL, &v14);
  *((_WORD *)this + 44) = bswap32(*((unsigned __int16 *)this + 44)) >> 16;
  unsigned int v6 = *((unsigned __int16 *)this + 28);
  if (!a3 || (uint64_t result = 0, v6 <= 8))
  {
    unsigned int v8 = *((_DWORD *)this + 10) * v6;
    if ((v8 & 0xFFFFFFF8) >= v8) {
      int v9 = v8 >> 3;
    }
    else {
      int v9 = (v8 >> 3) + 1;
    }
    unsigned int v10 = SetFilePointer(a2, 0, 0, 1);
    unsigned int v11 = SetFilePointer(a2, 0, 0, 2) - v10;
    *((void *)this + 3) = v11;
    unsigned int v12 = (void *)*((void *)this + 2);
    if (v12)
    {
      free(v12);
      unsigned int v11 = *((_DWORD *)this + 6);
    }
    int v13 = malloc_type_malloc(v11, 0x16CD93EFuLL);
    *((void *)this + 2) = v13;
    if (!v13) {
      CPSDFile::LoadImageData();
    }
    SetFilePointer(a2, v10, 0, 0);
    CPSDBaseComponent::ReadFile(a2, *((char **)this + 2), *((unsigned int *)this + 6), &v14);
    CPSDImageLoad::AllocateChannelBuffers(this, v9);
    if (a3) {
      CPSDImageLoad::FillLayerImageChannelBuffers(this, v9);
    }
    else {
      CPSDImageLoad::FillCompositeImageChannelBuffers(this, v9);
    }
    CPSDImageLoad::CreatePlanarBitmap(this);
    CPSDImageLoad::DeAllocateChannelBuffers(this);
    SetFilePointer(a2, *((_DWORD *)this + 7) + v10, 0, 0);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::Save(CPSDFile *this, int a2)
{
  File::File((File *)v4, a2, 2);
  (*(void (**)(CPSDFile *, unsigned char *))(*(void *)this + 24))(this, v4);
  File::~File((File *)v4);
  return 1;
}

uint64_t CPSDFile::Save(void **this, File *a2)
{
  CPSDHeader::Save((CPSDHeader *)(this + 14), a2);
  CPSDColorModeData::Save((CPSDColorModeData *)(this + 20), a2);
  CPSDImageResources::Save((CPSDImageResources *)(this + 24), a2);
  CPSDLayerAndMaskInfo::Save((CPSDLayerAndMaskInfo *)(this + 28), a2);
  return CPSDFile::SaveImageData(this, a2);
}

uint64_t CPSDHeader::Save(CPSDHeader *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 10));
  (*(void (**)(File *, char *, uint64_t))(*(void *)a2 + 48))(a2, (char *)this + 22, 6);
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 14));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 8));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 9));
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 20));
  uint64_t v4 = *((unsigned __int16 *)this + 21);
  uint64_t v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 72);
  return v5(a2, v4);
}

uint64_t CPSDColorModeData::Save(CPSDColorModeData *this, File *a2)
{
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((void *)this + 3) && *((_DWORD *)this + 4))
  {
    uint64_t v5 = *(uint64_t (**)(File *))(*(void *)a2 + 48);
    return v5(a2);
  }
  return result;
}

uint64_t CPSDImageResources::Save(CPSDImageResources *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  uint64_t v4 = (*(uint64_t (**)(File *))(*(void *)a2 + 16))(a2);
  for (uint64_t i = (void *)*((void *)this + 3); i; uint64_t i = (void *)i[37])
    (*(void (**)(void *, File *))(*i + 24))(i, a2);
  uint64_t result = (*(uint64_t (**)(File *))(*(void *)a2 + 16))(a2);
  unint64_t v7 = *((unsigned int *)this + 4);
  if (v7 > result - v4)
  {
    unsigned int v8 = *(uint64_t (**)(File *, unint64_t))(*(void *)a2 + 56);
    return v8(a2, v7 - (result - v4));
  }
  return result;
}

uint64_t CPSDLayerAndMaskInfo::Save(CPSDLayerAndMaskInfo *this, File *a2)
{
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4))
  {
    CPSDLayerInfo::Save((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
    uint64_t result = CPSDGlobalLayerMaskInfo::Save((CPSDLayerAndMaskInfo *)((char *)this + 96), a2);
    for (uint64_t i = (CPSDResourceItem *)*((void *)this + 20); i; uint64_t i = (CPSDResourceItem *)*((void *)i + 6))
      uint64_t result = CPSDResourceItem::SaveItem(i, a2);
  }
  return result;
}

uint64_t CPSDFile::SaveImageData(void **this, File *a2)
{
  CPSDFile::CompositeImageData(this);
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 44));
  uint64_t v4 = this[2];
  uint64_t v5 = *((unsigned int *)this + 6);
  unsigned int v6 = *(uint64_t (**)(File *, void *, uint64_t))(*(void *)a2 + 48);
  return v6(a2, v4, v5);
}

uint64_t CPSDFile::LoadLayers(CPSDFile *this, uint64_t a2)
{
  if (!CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2)
    || !CPSDColorModeData::Load((CPSDFile *)((char *)this + 160), a2)
    || !CPSDImageResources::Load((CPSDFile *)((char *)this + 192), a2))
  {
    return 0;
  }
  return CPSDLayerAndMaskInfo::Load((CPSDFile *)((char *)this + 224), a2);
}

uint64_t CPSDLayerAndMaskInfo::LoadLayer(CPSDLayerAndMaskInfo *this, uint64_t a2)
{
  int v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v6);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  uint64_t v4 = 1;
  SetFilePointer(a2, 0, 0, 1);
  if (*((_DWORD *)this + 4)) {
    return CPSDLayerInfo::LoadLayer((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
  }
  return v4;
}

uint64_t CPSDFile::ValidateFormat(CPSDFile *this, int a2)
{
  return CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2);
}

BOOL CPSDFile::ValidateIsDrawable(CPSDFile *this)
{
  return *((_WORD *)this + 77) == 3 && *((unsigned __int16 *)this + 76) == 8;
}

uint64_t CPSDFile::GetImageInfo(CPSDFile *this, int a2, unsigned int *a3, unsigned int *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int16 *a7)
{
  unsigned int v14 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, 0, 0, 0);
  uint64_t result = CPSDHeader::Load((CPSDFile *)((char *)this + 112), a2);
  if (result)
  {
    if (a7) {
      *a7 = *((_WORD *)this + 70);
    }
    if (a3) {
      *a3 = *((_DWORD *)this + 36);
    }
    if (a4) {
      *a4 = *((_DWORD *)this + 37);
    }
    if (a6) {
      *a6 = *((_WORD *)this + 77);
    }
    if (a5) {
      *a5 = *((_WORD *)this + 76);
    }
    SetFilePointer(a2, v14, 0, 0);
    return 1;
  }
  return result;
}

BOOL CPSDFile::IsTaggedWithICCProfile(CPSDFile *this)
{
  uint64_t v1 = *((void *)this + 27);
  if (!v1) {
    return 0;
  }
  int v2 = (CPSDFile *)((char *)this + 192);
  uint64_t v3 = v1;
  while (*(_WORD *)(v3 + 20) != 1039)
  {
    uint64_t v3 = *(void *)(v3 + 296);
    if (!v3) {
      return 0;
    }
  }
  while (*(_WORD *)(v1 + 20) != 1041)
  {
    uint64_t v1 = *(void *)(v1 + 296);
    if (!v1) {
      return 1;
    }
  }
  uint64_t v4 = CPSDImageResources::LookupResourceWithResID(v2, 1041);
  return !(*(unsigned int (**)(uint64_t))(*(void *)v4 + 48))(v4);
}

uint64_t CPSDImageResources::LookupResourceWithResID(CPSDImageResources *this, int a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2)
  {
LABEL_4:
    fprintf(__stderrp, "CPSDImageResources::LookupResourceWithResID() failed to locate resource with resID=%d\n", a2);
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238395925);
  }
  while (*(unsigned __int16 *)(v2 + 20) != a2)
  {
    uint64_t v2 = *(void *)(v2 + 296);
    if (!v2) {
      goto LABEL_4;
    }
  }
  return *(void *)(v2 + 288);
}

void sub_1A1338A7C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDFile::GetICCProfile(CPSDFile *this)
{
  return CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1039);
}

uint64_t CPSDFile::GetGlobalLightAngle(CPSDFile *this)
{
  uint64_t v1 = *((void *)this + 27);
  if (!v1) {
    return 120;
  }
  uint64_t v2 = (CPSDFile *)((char *)this + 192);
  while (*(_WORD *)(v1 + 20) != 1037)
  {
    uint64_t v1 = *(void *)(v1 + 296);
    if (!v1) {
      return 120;
    }
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)CPSDImageResources::LookupResourceWithResID(v2, 1037) + 48);
  return v4();
}

uint64_t CPSDFile::GetGlobalLightAltitude(CPSDFile *this)
{
  uint64_t v1 = *((void *)this + 27);
  if (!v1) {
    return 30;
  }
  uint64_t v2 = (CPSDFile *)((char *)this + 192);
  while (*(_WORD *)(v1 + 20) != 1049)
  {
    uint64_t v1 = *(void *)(v1 + 296);
    if (!v1) {
      return 30;
    }
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)CPSDImageResources::LookupResourceWithResID(v2, 1049) + 48);
  return v4();
}

uint64_t CPSDFile::GetLayerBounds(uint64_t a1, unsigned int a2, int32x4_t *a3)
{
  if (*(unsigned __int16 *)(a1 + 268) <= a2) {
    return 0;
  }
  *a3 = vrev64q_s32(*(int32x4_t *)(*(void *)(a1 + 272) + 488 * a2 + 16));
  return 1;
}

uint64_t CPSDFile::LookupSliceWithNumber(CPSDFile *this, unsigned int a2)
{
  uint64_t v3 = CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1050);
  unsigned int v4 = *(_DWORD *)(v3 + 88) - 1;
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  return *(void *)(*(void *)(v3 + 104) + 8 * v4);
}

uint64_t CPSDFile::GetSliceCount(CPSDFile *this)
{
  uint64_t v1 = *((void *)this + 27);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (CPSDFile *)((char *)this + 192);
  while (*(_WORD *)(v1 + 20) != 1050)
  {
    uint64_t v1 = *(void *)(v1 + 296);
    if (!v1) {
      return 0;
    }
  }
  return *(unsigned int *)(CPSDImageResources::LookupResourceWithResID(v2, 1050) + 88);
}

uint64_t CPSDFile::GetLayerIsSectionDivider(CPSDFile *this, unsigned int a2, BOOL *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  return 1;
}

uint64_t CPSDFile::GetLayerSectionDividerType(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (FirstItemOfTypeID) {
    unsigned int v5 = *((_DWORD *)FirstItemOfTypeID + 14);
  }
  else {
    unsigned int v5 = 0;
  }
  *a3 = v5;
  return 1;
}

uint64_t CPSDFile::GetLayerIsVisible(CPSDFile *this, unsigned int a2, BOOL *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  unsigned int v3 = *(unsigned __int8 *)(*((void *)this + 34) + 488 * a2 + 74);
  uint64_t result = 1;
  *a3 = ((v3 >> 1) & 1) == 0;
  return result;
}

uint64_t CPSDFile::GetLayerOpacity(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  *a3 = *(unsigned char *)(*((void *)this + 34) + 488 * a2 + 72);
  return 1;
}

uint64_t CPSDFile::GetLayerGradientStyle(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetStyle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetStyle(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return CPSDOSTypeEnumerated::GetEnum(0);
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1417244773)
  {
    if (v1 <= ++v2) {
      return CPSDOSTypeEnumerated::GetEnum(0);
    }
  }
  return CPSDOSTypeEnumerated::GetEnum(*(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80));
}

uint64_t CPSDFile::GetLayerGradientAngle(CPSDFile *this, unsigned int a2, double *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetAngle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

double CPSDGradientDescriptor::GetAngle(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 0.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1097754476)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64);
    }
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientSmoothing(CPSDFile *this, unsigned int a2, double *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetSmoothness((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

double CPSDGradientDescriptor::GetSmoothness(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (v1)
  {
    unsigned __int16 v2 = 0;
    uint64_t v3 = *((void *)this + 12);
    while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1198678372)
    {
      if (v1 <= ++v2) {
        goto LABEL_5;
      }
    }
    uint64_t v4 = *(void *)(v3 + 88 * v2 + 80);
  }
  else
  {
LABEL_5:
    uint64_t v4 = 0;
  }
  unsigned int v5 = *(_DWORD *)(v4 + 88);
  if (!v5) {
    return 1.0;
  }
  unsigned __int16 v6 = 0;
  uint64_t v7 = *(void *)(v4 + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1231975538)
  {
    if (v5 <= ++v6) {
      return 1.0;
    }
  }
  uint64_t v8 = *(void *)(v7 + 88 * v6 + 80);
  if (v8) {
    return round(*(double *)(v8 + 56) * 0.000244140625);
  }
  else {
    return 1.0;
  }
}

uint64_t CPSDFile::GetLayerGradientColorStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    unsigned int v5 = *(_DWORD *)(result + 88);
    if (v5) {
      unsigned int v5 = *(_DWORD *)(result + 120);
    }
    *a3 = v5;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientColorStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!FirstItemOfTypeID) {
    return 0;
  }
  return CPSDGradientDescriptor::GetColorStopAtIndex(FirstItemOfTypeID, a3, a4, a5, a6);
}

uint64_t CPSDGradientDescriptor::GetColorStopAtIndex(CPSDGradientDescriptor *this, unsigned int a2, double *a3, double *a4, double *a5)
{
  uint64_t result = 0;
  if (a3 && a4 && a5)
  {
    uint64_t v7 = *((void *)this + 12);
    if (*(_DWORD *)(v7 + 60) == 1198678372)
    {
      unsigned int v8 = 0;
    }
    else
    {
      int v9 = 0;
      do
        unsigned int v8 = (unsigned __int16)++v9;
      while (*(_DWORD *)(v7 + 88 * (unsigned __int16)v9 + 60) != 1198678372);
    }
    uint64_t v10 = *(void *)(*(void *)(v7 + 88 * v8 + 80) + 96);
    if (*(_DWORD *)(v10 + 60) == 1131180659)
    {
      unsigned int v11 = 0;
    }
    else
    {
      int v12 = 0;
      do
        unsigned int v11 = (unsigned __int16)++v12;
      while (*(_DWORD *)(v10 + 88 * (unsigned __int16)v12 + 60) != 1131180659);
    }
    uint64_t v13 = *(void *)(*(void *)(*(void *)(v10 + 88 * v11 + 80) + 64) + 8 * a2);
    uint64_t v14 = *(void *)(v13 + 96);
    if (*(_DWORD *)(v14 + 60) == 1131180576)
    {
      unsigned int v15 = 0;
    }
    else
    {
      int v16 = 0;
      do
        unsigned int v15 = (unsigned __int16)++v16;
      while (*(_DWORD *)(v14 + 88 * (unsigned __int16)v16 + 60) != 1131180576);
    }
    unsigned __int16 v17 = 0;
    unsigned int v18 = *(_DWORD *)(v13 + 88);
    uint64_t v19 = *(void *)(v14 + 88 * v15 + 80);
    unsigned int v20 = *(_DWORD *)(v19 + 88);
    uint64_t v21 = *(void *)(v19 + 96);
    while (*(_DWORD *)(v21 + 88 * v17 + 60) != 1382293536)
    {
      if (v20 <= ++v17)
      {
        uint64_t v22 = 0;
        goto LABEL_21;
      }
    }
    uint64_t v22 = *(void *)(v21 + 88 * v17 + 80);
LABEL_21:
    unsigned __int16 v23 = 0;
    while (*(_DWORD *)(v21 + 88 * v23 + 60) != 1198681632)
    {
      if (v20 <= ++v23)
      {
        uint64_t v24 = 0;
        goto LABEL_26;
      }
    }
    uint64_t v24 = *(void *)(v21 + 88 * v23 + 80);
LABEL_26:
    if (*(_DWORD *)(v21 + 60) == 1114382368)
    {
      unsigned int v25 = 0;
    }
    else
    {
      int v26 = 0;
      do
        unsigned int v25 = (unsigned __int16)++v26;
      while (*(_DWORD *)(v21 + 88 * (unsigned __int16)v26 + 60) != 1114382368);
    }
    unsigned __int16 v27 = 0;
    unint64_t v28 = *(void *)(v22 + 56);
    uint64_t v29 = *(void *)(v24 + 56);
    uint64_t v30 = *(void *)(*(void *)(v21 + 88 * v25 + 80) + 56);
    *(void *)a3 = v28;
    *((void *)a3 + 1) = v29;
    *((void *)a3 + 2) = v30;
    a3[3] = 1.0;
    uint64_t v31 = *(void *)(v13 + 96);
    while (1)
    {
      unsigned __int16 v32 = v27;
      if (*(_DWORD *)(v31 + 88 * v27 + 60) == 1281586286) {
        break;
      }
      ++v27;
      if (v18 <= (unsigned __int16)(v32 + 1))
      {
        uint64_t v33 = 0;
        goto LABEL_35;
      }
    }
    uint64_t v33 = *(void *)(v31 + 88 * v27 + 80);
LABEL_35:
    if (*(_DWORD *)(v31 + 60) == 1298428014)
    {
      unsigned int v34 = 0;
    }
    else
    {
      int v35 = 0;
      do
        unsigned int v34 = (unsigned __int16)++v35;
      while (*(_DWORD *)(v31 + 88 * (unsigned __int16)v35 + 60) != 1298428014);
    }
    uint64_t v36 = *(void *)(v31 + 88 * v34 + 80);
    LODWORD(v28) = *(_DWORD *)(v33 + 56);
    double v37 = round((double)v28 * 0.000244140625 * 100.0) / 100.0;
    *a4 = v37;
    LODWORD(v37) = *(_DWORD *)(v36 + 56);
    *a5 = (double)*(unint64_t *)&v37 / 100.0;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientOpacityStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    unsigned int v5 = *(_DWORD *)(result + 88);
    if (v5) {
      unsigned int v5 = *(_DWORD *)(result + 124);
    }
    *a3 = v5;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientOpacityStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!FirstItemOfTypeID) {
    return 0;
  }
  return CPSDGradientDescriptor::GetOpacityStopAtIndex(FirstItemOfTypeID, a3, a4, a5, a6);
}

uint64_t CPSDGradientDescriptor::GetOpacityStopAtIndex(CPSDGradientDescriptor *this, unsigned int a2, double *a3, double *a4, double *a5)
{
  uint64_t result = 0;
  if (a3 && a4 && a5)
  {
    uint64_t v7 = *((void *)this + 12);
    if (*(_DWORD *)(v7 + 60) == 1198678372)
    {
      unsigned int v8 = 0;
    }
    else
    {
      int v9 = 0;
      do
        unsigned int v8 = (unsigned __int16)++v9;
      while (*(_DWORD *)(v7 + 88 * (unsigned __int16)v9 + 60) != 1198678372);
    }
    uint64_t v10 = *(void *)(*(void *)(v7 + 88 * v8 + 80) + 96);
    if (*(_DWORD *)(v10 + 60) == 1416785523)
    {
      unsigned int v11 = 0;
    }
    else
    {
      int v12 = 0;
      do
        unsigned int v11 = (unsigned __int16)++v12;
      while (*(_DWORD *)(v10 + 88 * (unsigned __int16)v12 + 60) != 1416785523);
    }
    uint64_t v13 = *(void *)(*(void *)(*(void *)(v10 + 88 * v11 + 80) + 64) + 8 * a2);
    uint64_t v14 = *(void *)(v13 + 96);
    int v15 = *(_DWORD *)(v14 + 60);
    if (v15 == 1332765556)
    {
      unsigned int v16 = 0;
    }
    else
    {
      int v17 = 0;
      do
        unsigned int v16 = (unsigned __int16)++v17;
      while (*(_DWORD *)(v14 + 88 * (unsigned __int16)v17 + 60) != 1332765556);
    }
    unsigned __int16 v18 = 0;
    unsigned int v19 = *(_DWORD *)(v13 + 88);
    double v20 = round(*(double *)(*(void *)(v14 + 88 * v16 + 80) + 64));
    *a3 = v20;
    while (*(_DWORD *)(v14 + 88 * v18 + 60) != 1281586286)
    {
      if (v19 <= ++v18)
      {
        uint64_t v21 = 0;
        goto LABEL_21;
      }
    }
    uint64_t v21 = *(void *)(v14 + 88 * v18 + 80);
LABEL_21:
    if (v15 == 1298428014)
    {
      unsigned int v22 = 0;
    }
    else
    {
      int v23 = 0;
      do
        unsigned int v22 = (unsigned __int16)++v23;
      while (*(_DWORD *)(v14 + 88 * (unsigned __int16)v23 + 60) != 1298428014);
    }
    uint64_t v24 = *(void *)(v14 + 88 * v22 + 80);
    LODWORD(v20) = *(_DWORD *)(v21 + 56);
    double v25 = round((double)*(unint64_t *)&v20 * 0.000244140625 * 100.0) / 100.0;
    *a4 = v25;
    LODWORD(v25) = *(_DWORD *)(v24 + 56);
    *a5 = (double)*(unint64_t *)&v25 / 100.0;
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerGradientBlendMode(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetBlendMode((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetBlendMode(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1114402381)
  {
    if (v1 <= ++v2) {
      return 0;
    }
  }
  uint64_t v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4) {
    return CPSDOSTypeEnumerated::GetEnum(v4);
  }
  else {
    return 0;
  }
}

uint64_t CPSDFile::GetLayerGradientIsReversed(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetIsReversed((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetIsReversed(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1383494259)
  {
    if (v1 <= ++v2) {
      return 0;
    }
  }
  uint64_t v4 = *(void *)(v3 + 88 * v2 + 80);
  if (v4) {
    return *(unsigned __int8 *)(v4 + 56);
  }
  else {
    return 0;
  }
}

uint64_t CPSDFile::GetLayerGradientIsDithered(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetIsDithered((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetIsDithered(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1148479602)
  {
    if (v1 <= ++v2) {
      return 0;
    }
  }
  uint64_t v4 = *(void *)(v3 + 88 * v2 + 80);
  if (v4) {
    return *(unsigned __int8 *)(v4 + 56);
  }
  else {
    return 0;
  }
}

uint64_t CPSDFile::GetLayerEffectGradientStyle(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!result) {
    return result;
  }
  unsigned int v5 = *(_DWORD *)(result + 88);
  if (!v5) {
    return 0;
  }
  unsigned __int16 v6 = 0;
  uint64_t v7 = *(void *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6) {
      return 0;
    }
  }
  uint64_t result = *(void *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetStyle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDObjectEffectsLayerInfo::GetEffect(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 88);
  if (!v2) {
    return 0;
  }
  unsigned __int16 v3 = 0;
  uint64_t v4 = *(void *)(a1 + 96);
  while (*(_DWORD *)(v4 + 88 * v3 + 60) != a2)
  {
    if (v2 <= ++v3) {
      return 0;
    }
  }
  return *(void *)(v4 + 88 * v3 + 80);
}

uint64_t CPSDFile::GetLayerEffectGradientAngle(CPSDFile *this, unsigned int a2, double *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!result) {
    return result;
  }
  unsigned int v5 = *(_DWORD *)(result + 88);
  if (!v5) {
    return 0;
  }
  unsigned __int16 v6 = 0;
  uint64_t v7 = *(void *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6) {
      return 0;
    }
  }
  uint64_t result = *(void *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetAngle((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerEffectGradientSmoothing(CPSDFile *this, unsigned int a2, double *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!result) {
    return result;
  }
  unsigned int v5 = *(_DWORD *)(result + 88);
  if (!v5) {
    return 0;
  }
  unsigned __int16 v6 = 0;
  uint64_t v7 = *(void *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6) {
      return 0;
    }
  }
  uint64_t result = *(void *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetSmoothness((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerEffectGradientColorStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!result) {
    return result;
  }
  unsigned int v5 = *(_DWORD *)(result + 88);
  if (!v5) {
    return 0;
  }
  unsigned __int16 v6 = 0;
  uint64_t v7 = *(void *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6) {
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v7 + 88 * v6 + 80);
  if (!v8) {
    return 0;
  }
  if (*(_DWORD *)(v8 + 88)) {
    unsigned int v9 = *(_DWORD *)(v8 + 120);
  }
  else {
    unsigned int v9 = 0;
  }
  *a3 = v9;
  return 1;
}

uint64_t CPSDFile::GetLayerEffectGradientColorStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!FirstItemOfTypeID) {
    return 0;
  }
  unsigned int v11 = *((_DWORD *)FirstItemOfTypeID + 22);
  if (!v11) {
    return 0;
  }
  unsigned __int16 v12 = 0;
  uint64_t v13 = FirstItemOfTypeID[12];
  while (*(_DWORD *)(v13 + 88 * v12 + 60) != 1198671468)
  {
    if (v11 <= ++v12) {
      return 0;
    }
  }
  uint64_t v14 = *(CPSDGradientDescriptor **)(v13 + 88 * v12 + 80);
  if (!v14) {
    return 0;
  }
  return CPSDGradientDescriptor::GetColorStopAtIndex(v14, a3, a4, a5, a6);
}

uint64_t CPSDFile::GetLayerEffectGradientOpacityStopCount(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!result) {
    return result;
  }
  unsigned int v5 = *(_DWORD *)(result + 88);
  if (!v5) {
    return 0;
  }
  unsigned __int16 v6 = 0;
  uint64_t v7 = *(void *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6) {
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v7 + 88 * v6 + 80);
  if (!v8) {
    return 0;
  }
  if (*(_DWORD *)(v8 + 88)) {
    unsigned int v9 = *(_DWORD *)(v8 + 124);
  }
  else {
    unsigned int v9 = 0;
  }
  *a3 = v9;
  return 1;
}

uint64_t CPSDFile::GetLayerEffectGradientOpacityStopAtIndex(CPSDFile *this, unsigned int a2, unsigned __int16 a3, double *a4, double *a5, double *a6)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!FirstItemOfTypeID) {
    return 0;
  }
  unsigned int v11 = *((_DWORD *)FirstItemOfTypeID + 22);
  if (!v11) {
    return 0;
  }
  unsigned __int16 v12 = 0;
  uint64_t v13 = FirstItemOfTypeID[12];
  while (*(_DWORD *)(v13 + 88 * v12 + 60) != 1198671468)
  {
    if (v11 <= ++v12) {
      return 0;
    }
  }
  uint64_t v14 = *(CPSDGradientDescriptor **)(v13 + 88 * v12 + 80);
  if (!v14) {
    return 0;
  }
  return CPSDGradientDescriptor::GetOpacityStopAtIndex(v14, a3, a4, a5, a6);
}

uint64_t CPSDFile::GetLayerEffectGradientIsReversed(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (!result) {
    return result;
  }
  unsigned int v5 = *(_DWORD *)(result + 88);
  if (!v5) {
    return 0;
  }
  unsigned __int16 v6 = 0;
  uint64_t v7 = *(void *)(result + 96);
  while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198671468)
  {
    if (v5 <= ++v6) {
      return 0;
    }
  }
  uint64_t result = *(void *)(v7 + 88 * v6 + 80);
  if (result)
  {
    *a3 = CPSDGradientDescriptor::GetIsReversed((CPSDGradientDescriptor *)result);
    return 1;
  }
  return result;
}

uint64_t CPSDFile::GetLayerEffectGradientBlendMode(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDObjectEffectsLayerInfo::GetBlendModeForEffect(result, 1198671468);
    return 1;
  }
  return result;
}

uint64_t CPSDObjectEffectsLayerInfo::GetBlendModeForEffect(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 88);
  if (!v2) {
    return 0;
  }
  unsigned __int16 v3 = 0;
  uint64_t v4 = *(void *)(a1 + 96);
  while (*(_DWORD *)(v4 + 88 * v3 + 60) != a2)
  {
    if (v2 <= ++v3) {
      return 0;
    }
  }
  uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
  if (!v5) {
    return 0;
  }
  unsigned int v6 = *(_DWORD *)(v5 + 88);
  if (!v6) {
    return CPSDOSTypeEnumerated::GetEnum(0);
  }
  unsigned __int16 v7 = 0;
  uint64_t v8 = *(void *)(v5 + 96);
  while (*(_DWORD *)(v8 + 88 * v7 + 60) != 1298407456)
  {
    if (v6 <= ++v7) {
      return CPSDOSTypeEnumerated::GetEnum(0);
    }
  }
  return CPSDOSTypeEnumerated::GetEnum(*(CPSDOSTypeEnumerated **)(v8 + 88 * v7 + 80));
}

uint64_t CPSDFile::GetLayerEffectOpacity(CPSDFile *this, unsigned int a2, double *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (result)
  {
    *a3 = CPSDObjectEffectsLayerInfo::GetOpacityForEffect(result, 1198671468);
    return 1;
  }
  return result;
}

double CPSDObjectEffectsLayerInfo::GetOpacityForEffect(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 88);
  double result = 0.0;
  if (v2)
  {
    unsigned __int16 v4 = 0;
    uint64_t v5 = *(void *)(a1 + 96);
    while (*(_DWORD *)(v5 + 88 * v4 + 60) != a2)
    {
      if (v2 <= ++v4) {
        return result;
      }
    }
    uint64_t v6 = *(void *)(v5 + 88 * v4 + 80);
    if (v6)
    {
      uint64_t v7 = *(void *)(v6 + 96);
      if (*(_DWORD *)(v7 + 60) == 1332765556)
      {
        unsigned int v8 = 0;
      }
      else
      {
        int v9 = 0;
        do
          unsigned int v8 = (unsigned __int16)++v9;
        while (*(_DWORD *)(v7 + 88 * (unsigned __int16)v9 + 60) != 1332765556);
      }
      return *(double *)(*(void *)(v7 + 88 * v8 + 80) + 64);
    }
  }
  return result;
}

uint64_t CPSDFile::GetLayerFillOpacity(CPSDFile *this, unsigned int a2, unsigned __int8 *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  if (FirstItemOfTypeID) {
    unsigned __int8 v5 = *((unsigned char *)FirstItemOfTypeID + 56);
  }
  else {
    unsigned __int8 v5 = -1;
  }
  *a3 = v5;
  return 1;
}

uint64_t CPSDFile::GetLayerBlendMode(CPSDFile *this, unsigned int a2, unsigned int *a3)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  *a3 = *(_DWORD *)(*((void *)this + 34) + 488 * a2 + 68);
  return 1;
}

uint64_t CPSDFile::GetLayerRecord(CPSDFile *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  else {
    return *((void *)this + 34) + 488 * a2;
  }
}

uint64_t CPSDFile::GetIndexOfFirstLayerNamed(CPSDFile *this, const UniChar **a2, int a3, int a4)
{
  unsigned int v4 = *((unsigned __int16 *)this + 134);
  signed int v5 = v4 - 1;
  int v6 = a3 & ~(a3 >> 31);
  if (a4 >= 0) {
    signed int v5 = a4;
  }
  if (v5 >= v6) {
    int v7 = a3 & ~(a3 >> 31);
  }
  else {
    int v7 = v5;
  }
  if (v5 <= v6) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = v5;
  }
  if (v7 >= (int)v4 || v8 >= v4) {
    return 0xFFFFFFFFLL;
  }
  if (v5 >= (uint64_t)v6) {
    uint64_t v12 = a3 & ~(a3 >> 31);
  }
  else {
    uint64_t v12 = v5;
  }
  uint64_t v13 = 488 * v12;
  while (1)
  {
    CPSDLayerRecord::GetLayerName((CPSDLayerRecord *)(*((void *)this + 34) + v13), __s1, 0x100u);
    CPSDString::CopyStringValue(a2, __s2, 0x100u);
    if (!strcmp(__s1, __s2)) {
      break;
    }
    v13 += 488;
    BOOL v15 = __OFSUB__(v12, v8);
    BOOL v14 = v12 - v8 < 0;
    ++v12;
    if (v14 == v15) {
      return 0xFFFFFFFFLL;
    }
  }
  return v12;
}

size_t CPSDLayerRecord::GetLayerName(CPSDLayerRecord *this, char *a2, unsigned int a3)
{
  signed int v5 = (char *)this + 200;
  size_t result = strlen((const char *)this + 200);
  if (a3) {
    *a2 = 0;
  }
  if (result)
  {
    if (result <= a3)
    {
      strlcpy(a2, v5, a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CPSDFile::GetLayerIndexOfParentGroup(CPSDFile *this, int a2)
{
  LODWORD(v2) = a2;
  int v4 = 0;
  while (1)
  {
    unsigned int v5 = v2 + 1;
    int v6 = *((unsigned __int16 *)this + 134);
    if ((int)v2 + 1 >= v6) {
      break;
    }
    if (v5 < v6)
    {
      if (FirstItemOfTypeID)
      {
        int v4 = *((_DWORD *)FirstItemOfTypeID + 14);
        if (v4 == 3) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        int v4 = 0;
      }
    }
    uint64_t v2 = (v2 + 1);
    if ((v4 - 1) <= 1) {
      return v2;
    }
  }
  return 0xFFFFFFFFLL;
}

void *CPSDFile::GetRangeOfChildLayers(void *this, unsigned int a2, int *a3, int *a4)
{
  int v6 = -1;
  *a3 = -1;
  *a4 = -1;
  if ((a2 & 0x80000000) != 0) {
    goto LABEL_19;
  }
  int v7 = this;
  if (*((unsigned __int16 *)this + 134) <= a2)
  {
    int v6 = -1;
    goto LABEL_19;
  }
  int v8 = 0;
  int v9 = 0;
  int v10 = a2 - 1;
  unint64_t v11 = a2;
  uint64_t v12 = 488 * a2 + 456;
  while (1)
  {
    if (v11 < *((unsigned __int16 *)v7 + 134))
    {
      if (!this)
      {
        int v9 = 0;
        goto LABEL_10;
      }
      int v9 = *((_DWORD *)this + 14);
    }
    if (v9 == 3)
    {
      int v13 = 1;
      goto LABEL_13;
    }
LABEL_10:
    int v13 = (v9 - 1) >= 2 ? 0 : -1;
LABEL_13:
    v8 += v13;
    if (!v8) {
      break;
    }
    *a3 = v10;
    *a4 = v11;
    int v14 = v11 - 1;
    v12 -= 488;
    if ((uint64_t)v11-- <= 0)
    {
      int v6 = v14 + 1;
      goto LABEL_19;
    }
  }
  int v6 = *a4;
LABEL_19:
  int v16 = *a3;
  if (v6 < *a3)
  {
    *a3 = v6;
    *a4 = v16;
  }
  return this;
}

void *CPSDFile::GetLayerEffectsInfo(CPSDFile *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  else {
}
  }

void *CPSDFile::GetColorFillInfo(CPSDFile *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 134) <= a2) {
    return 0;
  }
  else {
}
  }

uint64_t CPSDFile::GetXMPMetadataString(CPSDFile *this, char **a2, unsigned int *a3)
{
  unsigned int v5 = (const char **)CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1060);
  return CPSDXMPResourceItem::GetXMPString(v5, a2, a3);
}

uint64_t CPSDXMPResourceItem::GetXMPString(const char **this, char **a2, unsigned int *a3)
{
  uint64_t v3 = 0;
  if (a2 && a3)
  {
    int v7 = strnstr(this[6], "<x:xapmeta", *((unsigned int *)this + 4));
    int v8 = strnstr(this[6], "</x:xapmeta>", *((unsigned int *)this + 4));
    if (!v7)
    {
      int v7 = strnstr(this[6], "<x:xmpmeta", *((unsigned int *)this + 4));
      int v8 = strnstr(this[6], "</x:xmpmeta>", *((unsigned int *)this + 4));
    }
    uint64_t v3 = 1;
    if (v7 && v8)
    {
      int v9 = strchr(v8, 10);
      size_t v10 = v9 - v7 + 1;
      unint64_t v11 = (char *)malloc_type_malloc(v9 - v7 + 2, 0xE4A56501uLL);
      *a2 = v11;
      memcpy(v11, v7, v10);
      (*a2)[v10 + 1] = 48;
      *a3 = v10;
      return 1;
    }
  }
  return v3;
}

BOOL CPSDFile::HasCompositeImage(CPSDFile *this)
{
  return *((unsigned char *)this + 32) && *((void *)this + 12) != 0;
}

void CPSDFile::GetCompositeImage(CPSDFile *this)
{
  unsigned int v1 = (unsigned __int8 **)*((void *)this + 12);
  if (v1)
  {
    *((void *)this + 12) = 0;
    if (CPSDFile::IsTaggedWithICCProfile(this))
    {
      uint64_t v3 = CPSDImageResources::LookupResourceWithResID((CPSDFile *)((char *)this + 192), 1039);
      int v4 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3);
      int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
    }
    else
    {
      int v4 = 0;
      int v5 = 0;
    }
    int v6 = (CPSDCompositeImage *)operator new();
    CPSDCompositeImage::CPSDCompositeImage(v6, (CPSDFile *)((char *)this + 112), v1, *((unsigned __int8 *)this + 104), v5, v4);
  }
}

uint64_t CPSDBaseComponent::ReadFile(int a1, char *a2, size_t a3, _DWORD *a4)
{
  if (a3)
  {
    size_t v5 = a3;
    int v8 = 0;
    do
    {
      LODWORD(result) = ReadFile(a1, a2, v5, a4);
      if (!result || (uint64_t v10 = *a4, !v10))
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      v8 += v10;
      a2 += v10;
      v5 -= v10;
    }
    while (v5);
  }
  else
  {
    int v8 = 0;
    LOBYTE(result) = 1;
  }
  *a4 = v8;
  return result;
}

void sub_1A133A85C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDImageResourceBlock::Load(CPSDImageResourceBlock *this, uint64_t a2, unsigned int *a3)
{
  int v13 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v13);
  *a3 += v13;
  unsigned int v6 = bswap32(*((_DWORD *)this + 4));
  *((_DWORD *)this + 4) = v6;
  if (v6 != 943868237 && v6 != 1298486113)
  {
    fprintf(__stderrp, "CPSDImageResourceBlock::Load(): encountered unrecognized image resource block of type 0x%x\n", v6);
    return 0;
  }
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 2uLL, &v13);
  *a3 += v13;
  *((_WORD *)this + 10) = bswap32(*((unsigned __int16 *)this + 10)) >> 16;
  LoadPascalStringAsCString(a2, a3, (char *)this + 22, 2);
  int v8 = (_DWORD *)((char *)this + 280);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 280, 4uLL, &v13);
  *a3 += v13;
  int v9 = bswap32(*((_DWORD *)this + 70));
  *((_DWORD *)this + 70) = v9;
  if (!CPSDImageResourceBlock::CreateResourceItem(this, a2, v9)) {
    return 0;
  }
  *a3 += *v8;
  if ((*(unsigned char *)v8 & 1) == 0) {
    return 1;
  }
  char v12 = 0;
  uint64_t v10 = 1;
  CPSDBaseComponent::ReadFile(a2, &v12, 1uLL, &v13);
  *a3 += v13;
  return v10;
}

CPSDBaseComponent *CPSDImageResources::UpdateResourceSize(CPSDBaseComponent *result, CPSDBaseComponent *this)
{
  if (this)
  {
    uint64_t v3 = *((void *)this + 5);
    if (!v3)
    {
      exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
      CStdException::CStdException(exception, 3238789123);
    }
    int v4 = result;
    int v5 = CPSDBaseComponent::ComputeSize(this);
    *((_DWORD *)this + 4) = v5;
    *(_DWORD *)(v3 + 280) = v5;
    uint64_t result = (CPSDBaseComponent *)CPSDBaseComponent::ComputeSize(v4);
    *((_DWORD *)v4 + 4) = result - 4;
  }
  return result;
}

void sub_1A133AB9C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *CPSDICCProfileResourceItem::AddICCData(CPSDICCProfileResourceItem *this, const unsigned __int8 *a2, size_t size)
{
  unsigned int v6 = (void *)*((void *)this + 6);
  if (v6) {
    free(v6);
  }
  uint64_t result = malloc_type_malloc(size, 0x123FEE07uLL);
  *((void *)this + 6) = result;
  if (result)
  {
    uint64_t result = memcpy(result, a2, size);
    *((_DWORD *)this + 4) = size;
  }
  return result;
}

uint64_t CPSDSlicesResourceItem::AddOrUpdateSlices(CPSDSlicesResourceItem *this, int32x4_t *a2, int a3, int a4, int a5)
{
  *((void *)this + 6) = 6;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = a5;
  *((_DWORD *)this + 16) = a4;
  if (*((_DWORD *)this + 22))
  {
    uint64_t v8 = *((void *)this + 12);
    if (v8)
    {
      uint64_t v9 = v8 - 16;
      uint64_t v10 = *(void *)(v8 - 8);
      if (v10)
      {
        uint64_t v11 = v8 - 176;
        uint64_t v12 = 176 * v10;
        do
        {
          CPSDSliceResource::~CPSDSliceResource((CPSDSliceResource *)(v11 + v12));
          v12 -= 176;
        }
        while (v12);
      }
      MEMORY[0x1A6230DD0](v9, 0x10B1C808814FAA7);
    }
  }
  uint64_t v13 = (a3 + 1);
  *((_DWORD *)this + 22) = v13;
  if (a3 == -1)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  uint64_t v14 = operator new[]();
  uint64_t v15 = 0;
  *(void *)uint64_t v14 = 176;
  *(void *)(v14 + 8) = v13;
  do
  {
    CPSDSliceResource::CPSDSliceResource((CPSDSliceResource *)(v14 + v15 + 16));
    v15 += 176;
  }
  while (176 * v13 != v15);
  *((void *)this + 12) = v14 + 16;
  if (a3)
  {
    uint64_t v16 = 0;
    int v17 = (int32x4_t *)(v14 + 244);
    do
    {
      *int v17 = vrev64q_s32(a2[v16]);
      v17[-1].i32[3] = 1;
      v17[-2].i32[1] = 2;
      *(int32x2_t *)((char *)&v17[-3].u64[1] + 4) = vdup_n_s32((int)v16++ + 2);
      v17 += 11;
    }
    while (a3 - 1 >= v16);
  }
  *(int32x4_t *)(v14 + 68) = vrev64q_s32(*(int32x4_t *)((char *)this + 52));
  return CPSDSlicesResourceItem::SortSlices(this);
}

void sub_1A133ADB8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDUnicodeChannelNames::AddName(CPSDUnicodeChannelNames *this, const CPSDString *a2)
{
  uint64_t v3 = (uint64_t *)((char *)this + 48);
  unint64_t v4 = *((void *)this + 7);
  if (v4 >= *((void *)this + 8))
  {
    uint64_t result = std::vector<CPSDString>::__push_back_slow_path<CPSDString const&>(v3, (uint64_t)a2);
  }
  else
  {
    std::vector<CPSDString>::__construct_one_at_end[abi:ne180100]<CPSDString const&>((uint64_t)v3, (uint64_t)a2);
    uint64_t result = v4 + 16;
  }
  *((void *)this + 7) = result;
  return result;
}

void *CPSDSlicesResourceItem::UpdateSliceNameAtIndex(CPSDSlicesResourceItem *this, const unsigned __int16 *a2, int a3, unsigned int a4)
{
  if (*((_DWORD *)this + 22) <= a4)
  {
    exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
    CStdException::CStdException(exception, 3238789123);
  }
  uint64_t v5 = *(void *)(*((void *)this + 13) + 8 * a4);
  CPSDString::AllocateCharData((CPSDString *)(v5 + 32), a3);
  unsigned int v6 = *(void **)(v5 + 40);
  size_t v7 = (2 * *(_DWORD *)(v5 + 32));
  return memcpy(v6, a2, v7);
}

void sub_1A133AEE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void CPSDImageResourceBlock::~CPSDImageResourceBlock(CPSDImageResourceBlock *this)
{
  *(void *)this = &unk_1EF486AE0;
  uint64_t v1 = *((void *)this + 36);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486AE0;
  uint64_t v1 = *((void *)this + 36);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDImageResourceBlock::Dump(CPSDImageResourceBlock *this, __sFILE *a2)
{
  (*(void (**)(void))(**((void **)this + 36) + 40))(*((void *)this + 36));
  uint64_t result = *((void *)this + 37);
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v4();
  }
  return result;
}

unint64_t LoadPascalStringAsCString(int a1, _DWORD *a2, char *a3, int a4)
{
  unsigned __int8 v12 = 0;
  int v11 = 0;
  unint64_t result = CPSDBaseComponent::ReadFile(a1, (char *)&v12, 1uLL, &v11);
  *a2 += v11;
  if (v12)
  {
    unint64_t result = CPSDBaseComponent::ReadFile(a1, a3, v12, &v11);
    *a2 += v11;
    int v9 = v12;
  }
  else
  {
    int v9 = 0;
  }
  a3[v9] = 0;
  if (a4 == 2)
  {
LABEL_8:
    unsigned int v10 = 1;
LABEL_9:
    unint64_t result = SetFilePointer(a1, v10, 0, 1);
    *a2 += v10;
  }
  else if (a4 == 4)
  {
    unsigned int v10 = 3;
    switch(((_BYTE)v9 + 1) & 3)
    {
      case 1:
        goto LABEL_9;
      case 2:
        unsigned int v10 = 2;
        goto LABEL_9;
      case 3:
        goto LABEL_8;
      default:
        return result;
    }
  }
  return result;
}

uint64_t CPSDImageResourceBlock::CreateResourceItem(CPSDImageResourceBlock *this, uint64_t a2, int a3)
{
  switch(*((_WORD *)this + 10))
  {
    case 0x40D:
      uint64_t v6 = operator new();
      uint64_t v7 = v6;
      *(_DWORD *)(v6 + 16) = a3;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 0;
      *(void *)(v6 + 40) = this;
      *(void *)uint64_t v6 = &unk_1EF486FA0;
      int v8 = 120;
      goto LABEL_11;
    case 0x40E:
    case 0x410:
    case 0x412:
    case 0x413:
    case 0x414:
    case 0x416:
    case 0x417:
    case 0x418:
      goto LABEL_5;
    case 0x40F:
      uint64_t v9 = operator new();
      uint64_t v7 = v9;
      *(_DWORD *)(v9 + 16) = a3;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 0;
      *(void *)(v9 + 40) = this;
      unsigned int v10 = &unk_1EF486EC0;
      goto LABEL_7;
    case 0x411:
      uint64_t v7 = operator new();
      *(_DWORD *)(v7 + 16) = a3;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(void *)(v7 + 40) = this;
      *(void *)uint64_t v7 = &unk_1EF486FE8;
      *(unsigned char *)(v7 + 48) = 1;
      goto LABEL_13;
    case 0x415:
      uint64_t v7 = operator new();
      *(_DWORD *)(v7 + 16) = a3;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(void *)(v7 + 40) = this;
      *(void *)(v7 + 48) = 0;
      *(void *)uint64_t v7 = &unk_1EF486D40;
      *(void *)(v7 + 56) = 0;
      *(void *)(v7 + 64) = 0;
      goto LABEL_13;
    case 0x419:
      uint64_t v6 = operator new();
      uint64_t v7 = v6;
      *(_DWORD *)(v6 + 16) = a3;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 0;
      *(void *)(v6 + 40) = this;
      *(void *)uint64_t v6 = &unk_1EF487030;
      int v8 = 30;
LABEL_11:
      *(_DWORD *)(v6 + 48) = v8;
      goto LABEL_13;
    case 0x41A:
      uint64_t v7 = operator new();
      CPSDSlicesResourceItem::CPSDSlicesResourceItem((CPSDSlicesResourceItem *)v7, this, a3);
      goto LABEL_13;
    default:
      if (*((_WORD *)this + 10) == 1060)
      {
        uint64_t v7 = operator new();
        CPSDXMPResourceItem::CPSDXMPResourceItem((CPSDXMPResourceItem *)v7, this, a3);
      }
      else
      {
LABEL_5:
        uint64_t v9 = operator new();
        uint64_t v7 = v9;
        *(_DWORD *)(v9 + 16) = a3;
        *(void *)(v9 + 24) = 0;
        *(void *)(v9 + 32) = 0;
        *(void *)(v9 + 40) = this;
        unsigned int v10 = &unk_1EF486918;
LABEL_7:
        *(void *)uint64_t v9 = v10;
        *(void *)(v9 + 48) = 0;
      }
LABEL_13:
      *((void *)this + 36) = v7;
      return CPSDResourceItem::LoadItem((CPSDResourceItem *)v7, a2);
  }
}

void sub_1A133B43C(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C40300736D0);
  _Unwind_Resume(a1);
}

CPSDResourceItem *CPSDImageResourceBlock::Save(CPSDImageResourceBlock *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 10));
  (*(void (**)(File *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)this + 22, 2);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 70));
  unint64_t result = (CPSDResourceItem *)*((void *)this + 36);
  if (result) {
    unint64_t result = (CPSDResourceItem *)CPSDResourceItem::SaveItem(result, a2);
  }
  if (*((unsigned char *)this + 280))
  {
    uint64_t v5 = *(uint64_t (**)(File *, void))(*(void *)a2 + 64);
    return (CPSDResourceItem *)v5(a2, 0);
  }
  return result;
}

uint64_t CPSDResourceItem::SaveItem(CPSDResourceItem *this, File *a2)
{
  uint64_t result = (*(uint64_t (**)(CPSDResourceItem *))(*(void *)this + 24))(this);
  if (*((void *)this + 4))
  {
    uint64_t v5 = *(uint64_t (**)(File *))(*(void *)a2 + 48);
    return v5(a2);
  }
  return result;
}

uint64_t CPSDResourceItem::LoadItem(CPSDResourceItem *this, uint64_t a2)
{
  int v4 = SetFilePointer(a2, 0, 0, 1);
  uint64_t result = (*(uint64_t (**)(CPSDResourceItem *, uint64_t))(*(void *)this + 16))(this, a2);
  if (result)
  {
    unsigned int v6 = SetFilePointer(a2, 0, 0, 1) - v4;
    return CPSDResourceItem::LoadUnparsedData(this, a2, v6);
  }
  return result;
}

BOOL CPSDResourceItem::LoadUnparsedData(CPSDResourceItem *this, int a2, unsigned int a3)
{
  unsigned int v4 = *((_DWORD *)this + 4);
  if (v4 >= a3)
  {
    *((void *)this + 3) = v4 - a3;
    if (v4 == a3)
    {
      return 1;
    }
    else
    {
      if (*((void *)this + 4)) {
        MEMORY[0x1A6230DD0](*((void *)this + 4), 0x1000C8077774924);
      }
      uint64_t v7 = (char *)operator new[]();
      *((void *)this + 4) = v7;
      int v8 = 0;
      CPSDBaseComponent::ReadFile(a2, v7, *((void *)this + 3), &v8);
      return *((void *)this + 3) == v8;
    }
  }
  else
  {
    *((void *)this + 3) = 0;
    puts("Error: Attempting to load more data than exists");
    return 0;
  }
}

uint64_t CPSDDummyResourceItem::Dump(CPSDDummyResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Resource: %d \t[ %d ] bytes }\n", *(unsigned __int16 *)(*((void *)this + 5) + 20), *((_DWORD *)this + 4));
}

uint64_t CPSDXMPResourceItem::Load(char **this, int a2)
{
  int v4 = 0;
  CPSDBaseComponent::ReadFile(a2, this[6], *((unsigned int *)this + 4), &v4);
  uint64_t result = 0;
  if (v4 == *((_DWORD *)this + 4))
  {
    this[6][v4] = 0;
    return 1;
  }
  return result;
}

uint64_t CPSDXMPResourceItem::Save(uint64_t this, File *a2)
{
  uint64_t v2 = *(void *)(this + 48);
  if (v2) {
    return (*(uint64_t (**)(File *, uint64_t, void))(*(void *)a2 + 48))(a2, v2, *(unsigned int *)(this + 16));
  }
  return this;
}

uint64_t CPSDXMPResourceItem::Dump(CPSDXMPResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Resource: XMP Metadata: \t[ %d ] bytes }\n", *((_DWORD *)this + 4));
}

BOOL CPSDDummyResourceItem::Load(CPSDDummyResourceItem *this, int a2)
{
  int v6 = 0;
  int v4 = (char *)malloc_type_malloc(*((unsigned int *)this + 4), 0xAD6A69A5uLL);
  *((void *)this + 6) = v4;
  CPSDBaseComponent::ReadFile(a2, v4, *((unsigned int *)this + 4), &v6);
  return v6 == *((_DWORD *)this + 4);
}

uint64_t CPSDDummyResourceItem::Save(uint64_t this, File *a2)
{
  uint64_t v2 = *(void *)(this + 48);
  if (v2) {
    return (*(uint64_t (**)(File *, uint64_t, void))(*(void *)a2 + 48))(a2, v2, *(unsigned int *)(this + 16));
  }
  return this;
}

uint64_t CPSDICCProfileResourceItem::Dump(CPSDICCProfileResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ ICC Profile: %d \t[ %d ] bytes }\n", *(unsigned __int16 *)(*((void *)this + 5) + 20), *((_DWORD *)this + 4));
}

BOOL CPSDICCProfileResourceItem::Load(CPSDICCProfileResourceItem *this, int a2)
{
  int v6 = 0;
  int v4 = (char *)malloc_type_malloc(*((unsigned int *)this + 4), 0xB9FD3D5FuLL);
  *((void *)this + 6) = v4;
  CPSDBaseComponent::ReadFile(a2, v4, *((unsigned int *)this + 4), &v6);
  return v6 == *((_DWORD *)this + 4);
}

uint64_t CPSDICCProfileResourceItem::Save(uint64_t this, File *a2)
{
  uint64_t v2 = *(void *)(this + 48);
  if (v2) {
    return (*(uint64_t (**)(File *, uint64_t, void))(*(void *)a2 + 48))(a2, v2, *(unsigned int *)(this + 16));
  }
  return this;
}

uint64_t CPSDICCUntaggedResourceItem::Dump(CPSDICCUntaggedResourceItem *this, __sFILE *a2)
{
  if (*((unsigned char *)this + 48)) {
    uint64_t v2 = "YES";
  }
  else {
    uint64_t v2 = "NO";
  }
  return fprintf(a2, "{ Untagged: %s }\n", v2);
}

BOOL CPSDICCUntaggedResourceItem::Load(CPSDICCUntaggedResourceItem *this, int a2)
{
  int v3 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 1uLL, &v3);
  return v3 == 1;
}

uint64_t CPSDICCUntaggedResourceItem::Save(CPSDICCUntaggedResourceItem *this, File *a2)
{
  return (*(uint64_t (**)(File *, char *, void))(*(void *)a2 + 48))(a2, (char *)this + 48, *((unsigned int *)this + 4));
}

uint64_t CPSDUnicodeChannelNames::Load(CPSDUnicodeChannelNames *this, int a2)
{
  unsigned int v12 = 0;
  if (*((_DWORD *)this + 4))
  {
    unsigned int v4 = 0;
    uint64_t v5 = (uint64_t *)((char *)this + 48);
    do
    {
      int v11 = 0;
      CPSDString::AllocateCharData((CPSDString *)&v10, 1);
      *int v11 = 0;
      CPSDString::Load(&v10, a2, &v12);
      unint64_t v6 = *((void *)this + 7);
      if (v6 >= *((void *)this + 8))
      {
        uint64_t v7 = std::vector<CPSDString>::__push_back_slow_path<CPSDString const&>(v5, (uint64_t)&v10);
      }
      else
      {
        std::vector<CPSDString>::__construct_one_at_end[abi:ne180100]<CPSDString const&>((uint64_t)v5, (uint64_t)&v10);
        uint64_t v7 = v6 + 16;
      }
      *((void *)this + 7) = v7;
      unsigned int v8 = v12;
      if (v11) {
        MEMORY[0x1A6230DD0](v11, 0x1000C80BDFB0063);
      }
      v4 += v8;
    }
    while (v4 < *((_DWORD *)this + 4));
  }
  return 1;
}

void sub_1A133BC44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x1A6230DD0](a11, 0x1000C80BDFB0063);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CPSDString::Load(char **this, int a2, unsigned int *a3)
{
  uint64_t v13 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v13, 4uLL, (_DWORD *)&v13 + 1);
  *a3 += HIDWORD(v13);
  int v6 = v13;
  unsigned int v7 = bswap32(v13);
  LODWORD(v13) = v7;
  if (v6)
  {
    if (v7 > 0xFF) {
      return 0;
    }
    CPSDString::AllocateCharData((CPSDString *)this, v7);
    CPSDBaseComponent::ReadFile(a2, this[1], (2 * *(_DWORD *)this), (_DWORD *)&v13 + 1);
    unint64_t v10 = HIDWORD(v13);
    *a3 += HIDWORD(v13);
    if (v10 >= 2)
    {
      unint64_t v11 = v10 >> 1;
      unsigned int v12 = this[1];
      do
      {
        *(_WORD *)unsigned int v12 = bswap32(*(unsigned __int16 *)v12) >> 16;
        v12 += 2;
        --v11;
      }
      while (v11);
    }
  }
  else
  {
    uint64_t v9 = this[1];
    if (v9)
    {
      MEMORY[0x1A6230DD0](v9, 0x1000C80BDFB0063);
      this[1] = 0;
    }
    *(_DWORD *)this = 0;
  }
  return 1;
}

uint64_t CPSDUnicodeChannelNames::Save(uint64_t this, File *a2)
{
  uint64_t v2 = *(void *)(this + 56) - *(void *)(this + 48);
  if (v2)
  {
    uint64_t v4 = this;
    uint64_t v5 = 0;
    unint64_t v6 = v2 >> 4;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    do
    {
      unsigned int v8 = (unsigned int *)(*(void *)(v4 + 48) + v5);
      (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *v8);
      this = (*(uint64_t (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)v8 + 1), *v8);
      v5 += 16;
      --v7;
    }
    while (v7);
  }
  return this;
}

uint64_t CPSDGlobalAngleResourceItem::Dump(CPSDGlobalAngleResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Global Angle: %d }\n", *((_DWORD *)this + 12));
}

BOOL CPSDGlobalAngleResourceItem::Load(CPSDGlobalAngleResourceItem *this, int a2)
{
  int v4 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v4);
  *((_DWORD *)this + 12) = bswap32(*((_DWORD *)this + 12));
  return v4 == 4;
}

uint64_t CPSDGlobalAngleResourceItem::Save(CPSDGlobalAngleResourceItem *this, File *a2)
{
  return (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 12));
}

uint64_t CPSDGlobalAltitudeResourceItem::Dump(CPSDGlobalAltitudeResourceItem *this, __sFILE *a2)
{
  return fprintf(a2, "{ Global Altitude: %d }\n", *((_DWORD *)this + 12));
}

BOOL CPSDGlobalAltitudeResourceItem::Load(CPSDGlobalAltitudeResourceItem *this, int a2)
{
  int v4 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v4);
  *((_DWORD *)this + 12) = bswap32(*((_DWORD *)this + 12));
  return v4 == 4;
}

uint64_t CPSDGlobalAltitudeResourceItem::Save(CPSDGlobalAltitudeResourceItem *this, File *a2)
{
  return (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 12));
}

void CPSDSlicesResourceItem::~CPSDSlicesResourceItem(CPSDSlicesResourceItem *this)
{
  *(void *)this = &unk_1EF486B20;
  if (*((_DWORD *)this + 12) < 7u)
  {
    if (*((_DWORD *)this + 22))
    {
      uint64_t v3 = *((void *)this + 12);
      if (v3)
      {
        uint64_t v4 = v3 - 16;
        uint64_t v5 = *(void *)(v3 - 8);
        if (v5)
        {
          uint64_t v6 = v3 - 176;
          uint64_t v7 = 176 * v5;
          do
          {
            CPSDSliceResource::~CPSDSliceResource((CPSDSliceResource *)(v6 + v7));
            v7 -= 176;
          }
          while (v7);
        }
        MEMORY[0x1A6230DD0](v4, 0x10B1C808814FAA7);
      }
      uint64_t v8 = *((void *)this + 13);
      if (v8) {
        MEMORY[0x1A6230DD0](v8, 0x20C8093837F09);
      }
    }
  }
  else
  {
    uint64_t v2 = *((void *)this + 14);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  uint64_t v9 = *((void *)this + 10);
  if (v9)
  {
    MEMORY[0x1A6230DD0](v9, 0x1000C80BDFB0063);
    *((void *)this + 10) = 0;
  }
  *(void *)this = &unk_1EF486200;
  uint64_t v10 = *((void *)this + 4);
  if (v10) {
    MEMORY[0x1A6230DD0](v10, 0x1000C8077774924);
  }
}

{
  uint64_t vars8;

  CPSDSlicesResourceItem::~CPSDSlicesResourceItem(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDSlicesResourceItem::Dump(CPSDSlicesResourceItem *this, __sFILE *a2)
{
  if (*((_DWORD *)this + 12) < 7u)
  {
    uint64_t result = fprintf(a2, "{ SLICES:   1051\t[%d Slices] bounds={%d,%d,%d,%d} [%d] bytes }\n", *((_DWORD *)this + 22), *((_DWORD *)this + 14), *((_DWORD *)this + 13), *((_DWORD *)this + 16), *((_DWORD *)this + 15), *((_DWORD *)this + 4));
    if (*((_DWORD *)this + 22))
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      do
      {
        fprintf(a2, "[%d]\t", v7);
        uint64_t result = (*(uint64_t (**)(uint64_t, __sFILE *))(*(void *)(*((void *)this + 12) + v6) + 40))(*((void *)this + 12) + v6, a2);
        ++v7;
        v6 += 176;
      }
      while (v7 < *((unsigned int *)this + 22));
    }
  }
  else
  {
    fprintf(a2, "{ SLICES:   1051\t v%d ActionDescriptor [%d] bytes }\n", *((_DWORD *)this + 12), *((_DWORD *)this + 4));
    uint64_t v4 = *(uint64_t (**)(void))(**((void **)this + 14) + 56);
    return v4();
  }
  return result;
}

uint64_t CPSDSlicesResourceItem::Load(CPSDSlicesResourceItem *this, uint64_t a2)
{
  unsigned int v17 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v17);
  unsigned int v16 = v17;
  unsigned int v4 = bswap32(*((_DWORD *)this + 12));
  *((_DWORD *)this + 12) = v4;
  if (v4 < 7)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 52, 0x10uLL, &v17);
    v16 += v17;
    *(int8x16_t *)((char *)this + 52) = vrev32q_s8(*(int8x16_t *)((char *)this + 52));
    CPSDString::Load((char **)this + 9, a2, &v16);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 88, 4uLL, &v17);
    v16 += v17;
    unsigned int v9 = *((_DWORD *)this + 22);
    uint64_t v10 = bswap32(v9);
    *((_DWORD *)this + 22) = v10;
    if (!v9) {
      return CPSDSlicesResourceItem::SortSlices(this);
    }
    unint64_t v11 = (void *)operator new[]();
    uint64_t v12 = 0;
    *unint64_t v11 = 176;
    v11[1] = v10;
    do
    {
      CPSDSliceResource::CPSDSliceResource((CPSDSliceResource *)&v11[v12 + 2]);
      v12 += 22;
    }
    while (22 * v10 != v12);
    *((void *)this + 12) = v11 + 2;
    if (*((_DWORD *)this + 22))
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      while (1)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(*(void *)(*((void *)this + 12) + v13)
                                                                             + 48))(*((void *)this + 12) + v13, a2, &v16);
        if (!result) {
          break;
        }
        ++v14;
        v13 += 176;
        if (v14 >= *((unsigned int *)this + 22)) {
          return CPSDSlicesResourceItem::SortSlices(this);
        }
      }
    }
    else
    {
      return CPSDSlicesResourceItem::SortSlices(this);
    }
  }
  else
  {
    unsigned int v15 = 0;
    CPSDBaseComponent::ReadFile(a2, (char *)&v15, 4uLL, &v16);
    v16 += v17;
    unsigned int v5 = v15;
    unsigned int v6 = bswap32(v15);
    unsigned int v15 = v6;
    if (v5 == 0x10000000)
    {
      unint64_t v7 = (CPSDActionDescriptor *)operator new();
      CPSDActionDescriptor::CPSDActionDescriptor(v7);
      *((void *)this + 14) = v7;
      *((_DWORD *)this + 22) = 0;
      return (*(uint64_t (**)(CPSDActionDescriptor *, uint64_t))(*(void *)v7 + 16))(v7, a2);
    }
    else
    {
      fprintf(__stderrp, "CPSDSlicesResourceItem::Load(): unexpected descriptor version (%d) encountered.\n", v6);
      return 0;
    }
  }
  return result;
}

void sub_1A133C4FC(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C4022C5DBF1);
  _Unwind_Resume(a1);
}

uint64_t CPSDSlicesResourceItem::SortSlices(CPSDSlicesResourceItem *this)
{
  if (!*((_DWORD *)this + 22) || !*((void *)this + 12)) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    MEMORY[0x1A6230DD0](v2, 0x20C8093837F09);
  }
  uint64_t v3 = (void *)operator new[]();
  *((void *)this + 13) = v3;
  size_t v4 = *((unsigned int *)this + 22);
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
      *(void *)(*((void *)this + 13) + 8 * i) = *((void *)this + 12) + 176 * i;
    uint64_t v3 = (void *)*((void *)this + 13);
  }
  else
  {
    size_t v4 = 0;
  }
  qsort(v3, v4, 8uLL, (int (__cdecl *)(const void *, const void *))slice_cmp_fn);
  return 1;
}

uint64_t CPSDSlicesResourceItem::Save(CPSDSlicesResourceItem *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 12));
  PSDRect::Save((PSDRect *)((char *)this + 52), a2);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 18));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 10), *((unsigned int *)this + 18));
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 22));
  if (*((_DWORD *)this + 22))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, File *))(*(void *)(*((void *)this + 12) + v5) + 24))(*((void *)this + 12) + v5, a2);
      ++v6;
      v5 += 176;
    }
    while (v6 < *((unsigned int *)this + 22));
  }
  return result;
}

uint64_t PSDRect::Save(PSDRect *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *(_DWORD *)this);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 1));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 2));
  uint64_t v4 = *((unsigned int *)this + 3);
  uint64_t v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80);
  return v5(a2, v4);
}

uint64_t slice_cmp_fn(const void *a1, const void *a2)
{
  uint64_t v2 = *(_DWORD **)a1;
  uint64_t v3 = *(_DWORD **)a2;
  unsigned int v4 = *(_DWORD *)(*(void *)a1 + 56);
  unsigned int v5 = *(_DWORD *)(*(void *)a2 + 56);
  BOOL v6 = v4 >= v5;
  if (v4 == v5 && (v7 = v2[13], v8 = v3[13], BOOL v6 = v7 >= v8, v7 == v8))
  {
    unsigned int v9 = v2[15];
    unsigned int v10 = v3[15];
    BOOL v6 = v9 >= v10;
    if (v9 == v10) {
      BOOL v6 = v2[16] >= v3[16];
    }
    unsigned int v11 = 1;
  }
  else
  {
    unsigned int v11 = -1;
  }
  if (v6) {
    return -v11;
  }
  else {
    return v11;
  }
}

uint64_t CPSDSliceResource::Load(CPSDSliceResource *this, int a2, unsigned int *a3)
{
  int v8 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 0xCuLL, &v8);
  *a3 += v8;
  *((int8x8_t *)this + 2) = vrev32_s8(*(int8x8_t *)((char *)this + 16));
  unsigned int v6 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 6) = bswap32(v6);
  if (v6 == 0x1000000)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 4uLL, &v8);
    *((_DWORD *)this + 7) = bswap32(*((_DWORD *)this + 7));
  }
  CPSDString::Load((char **)this + 4, a2, a3);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 0x14uLL, &v8);
  *a3 += v8;
  *((int8x16_t *)this + 3) = vrev32q_s8(*((int8x16_t *)this + 3));
  *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
  CPSDString::Load((char **)this + 9, a2, a3);
  CPSDString::Load((char **)this + 11, a2, a3);
  CPSDString::Load((char **)this + 13, a2, a3);
  CPSDString::Load((char **)this + 15, a2, a3);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 136, 1uLL, &v8);
  *a3 += v8;
  CPSDString::Load((char **)this + 18, a2, a3);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 160, 8uLL, &v8);
  *a3 += v8;
  *((int8x8_t *)this + 20) = vrev32_s8(*(int8x8_t *)((char *)this + 160));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 168, 1uLL, &v8);
  *a3 += v8;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 169, 1uLL, &v8);
  *a3 += v8;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 170, 1uLL, &v8);
  *a3 += v8;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 171, 1uLL, &v8);
  *a3 += v8;
  return 1;
}

uint64_t CPSDSliceResource::Save(CPSDSliceResource *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 5));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 6));
  if (*((_DWORD *)this + 6) == 1) {
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 7));
  }
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 8));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 5), *((unsigned int *)this + 8));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 12));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 13));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 15));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 16));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 18));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 10), *((unsigned int *)this + 18));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 22));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 12), *((unsigned int *)this + 22));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 26));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 14), *((unsigned int *)this + 26));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 30));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 16), *((unsigned int *)this + 30));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 136));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 36));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 19), *((unsigned int *)this + 36));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 40));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 41));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 168));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 169));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 170));
  uint64_t v4 = *((unsigned __int8 *)this + 171);
  unsigned int v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 64);
  return v5(a2, v4);
}

uint64_t CPSDSliceResource::Dump(CPSDSliceResource *this, __sFILE *a2)
{
  int v5 = *((_DWORD *)this + 8);
  uint64_t v4 = (const UniChar **)((char *)this + 32);
  if (v5) {
    CPSDString::CopyStringValue(v4, v7, 0x100u);
  }
  return fprintf(a2, " |  {%d,%d,%d,%d} \t[ %s ]\ttype=%d \thoriz=%d, vert=%d\t|\n", *((_DWORD *)this + 13), *((_DWORD *)this + 14), *((_DWORD *)this + 15), *((_DWORD *)this + 16), v7, *((_DWORD *)this + 12), *((_DWORD *)this + 40), *((_DWORD *)this + 41));
}

void CPSDPathsResourceItem::~CPSDPathsResourceItem(CPSDPathsResourceItem *this)
{
  *(void *)this = &unk_1EF486A18;
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    MEMORY[0x1A6230DD0](v2, 0x20C8093837F09);
  }
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)v3[3];
      (*(void (**)(void *))(*v3 + 8))(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
}

{
  uint64_t vars8;

  CPSDPathsResourceItem::~CPSDPathsResourceItem(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDPathsResourceItem::Load(CPSDPathsResourceItem *this, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)this + 4);
  if ((float)v2 / 26.0 >= 1.0)
  {
    uint64_t v5 = 0;
    unsigned int v6 = (uint64_t *)((char *)this + 24);
    while (2)
    {
      int v17 = 0;
      unsigned __int16 v16 = 0;
      CPSDBaseComponent::ReadFile(a2, (char *)&v16, 2uLL, &v17);
      unsigned int v7 = bswap32(v16);
      unsigned __int16 v16 = HIWORD(v7);
      int v8 = v17;
      switch(HIWORD(v7))
      {
        case 0u:
        case 3u:
          uint64_t v10 = operator new();
          *(_WORD *)(v10 + 16) = v16;
          *(void *)(v10 + 24) = 0;
          *(void *)(v10 + 32) = 0;
          unsigned int v11 = (unsigned int (**)(uint64_t, void))&unk_1EF486D00;
          *(void *)uint64_t v10 = &unk_1EF486D00;
          *(void *)(v10 + 40) = 0;
          *(void *)(v10 + 48) = 0;
          ++*((_WORD *)this + 16);
          goto LABEL_10;
        case 1u:
        case 2u:
        case 4u:
        case 5u:
          uint64_t v9 = operator new();
          uint64_t v10 = v9;
          *(_WORD *)(v9 + 16) = v16;
          *(void *)(v9 + 24) = 0;
          unsigned int v11 = (unsigned int (**)(uint64_t, void))&unk_1EF486730;
          goto LABEL_9;
        case 6u:
          uint64_t v10 = operator new();
          unsigned __int16 v12 = v16;
          unsigned int v11 = (unsigned int (**)(uint64_t, void))&unk_1EF4864B0;
          *(void *)uint64_t v10 = &unk_1EF4864B0;
          *(_WORD *)(v10 + 16) = v12;
          *(void *)(v10 + 24) = 0;
          goto LABEL_10;
        case 7u:
          uint64_t v9 = operator new();
          uint64_t v10 = v9;
          *(_WORD *)(v9 + 16) = v16;
          *(void *)(v9 + 24) = 0;
          unsigned int v11 = (unsigned int (**)(uint64_t, void))&unk_1EF4865B8;
          goto LABEL_9;
        case 8u:
          uint64_t v9 = operator new();
          uint64_t v10 = v9;
          *(_WORD *)(v9 + 16) = v16;
          *(void *)(v9 + 24) = 0;
          unsigned int v11 = (unsigned int (**)(uint64_t, void))&unk_1EF486998;
LABEL_9:
          *(void *)uint64_t v9 = v11;
LABEL_10:
          if (!v11[2](v10, a2)) {
            goto LABEL_17;
          }
          uint64_t v13 = v6;
          if (!*v6) {
            goto LABEL_14;
          }
          if (v5)
          {
            uint64_t v13 = (uint64_t *)(v5 + 24);
LABEL_14:
            *uint64_t v13 = v10;
          }
          unsigned int v2 = v2 - v8 - 24;
          uint64_t v5 = v10;
          if ((float)v2 / 26.0 < 1.0) {
            return 1;
          }
          continue;
        default:
LABEL_17:
          exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
          CStdException::CStdException(exception, 3238395925);
      }
    }
  }
  return 1;
}

void sub_1A133D478(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDPathsResourceItem::Save(uint64_t this, File *a2)
{
  for (uint64_t i = *(void **)(this + 24); i; uint64_t i = (void *)i[3])
    this = (*(uint64_t (**)(void *, File *))(*i + 24))(i, a2);
  return this;
}

uint64_t CPSDPathsResourceItem::GenerateSubpathResources(CPSDPathsResourceItem *this)
{
  *((void *)this + 5) = operator new[]();
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    unsigned __int16 v3 = 0;
    unsigned __int16 v4 = 0;
    do
    {
      unsigned int v5 = *(unsigned __int16 *)(v2 + 16);
      if (v5 <= 5)
      {
        if (((1 << v5) & 0x36) == 0)
        {
          unsigned int v6 = (void *)operator new();
          *(void *)(*((void *)this + 5) + 8 * v3) = v6;
          *unsigned int v6 = &unk_1EF4861B8;
          if (*(_WORD *)(v2 + 16)) {
            BOOL v7 = *(unsigned __int16 *)(v2 + 16) == 3;
          }
          else {
            BOOL v7 = 1;
          }
          char v8 = v7;
          uint64_t v9 = *(void *)(*((void *)this + 5) + 8 * v3);
          *(unsigned char *)(v9 + 16) = v8;
          *(_WORD *)(v9 + 18) = *(_WORD *)(v2 + 32);
          uint64_t v10 = operator new[]();
          unsigned __int16 v4 = 0;
          *(void *)(*(void *)(*((void *)this + 5) + 8 * v3) + 24) = v10;
          goto LABEL_18;
        }
        *(void *)(*(void *)(*(void *)(*((void *)this + 5) + 8 * v3) + 24) + 8 * v4++) = v2;
      }
      if (v4)
      {
        if (*(unsigned __int16 *)(*(void *)(*((void *)this + 5) + 8 * v3) + 18) == v4) {
          ++v3;
        }
      }
      else
      {
        unsigned __int16 v4 = 0;
      }
LABEL_18:
      uint64_t v2 = *(void *)(v2 + 24);
    }
    while (v2);
  }
  return 1;
}

uint64_t CPSDPathsResourceItem::GetSubpath(CPSDPathsResourceItem *this, unsigned int a2)
{
  if (!*((void *)this + 5)) {
    CPSDPathsResourceItem::GenerateSubpathResources(this);
  }
  if (*((unsigned __int16 *)this + 16) <= a2) {
    return 0;
  }
  else {
    return *(void *)(*((void *)this + 5) + 8 * a2);
  }
}

uint64_t CPSDPathsResourceItem::Dump(CPSDPathsResourceItem *this, __sFILE *a2, unsigned int a3)
{
  unsigned int v6 = (const char *)operator new[]();
  BOOL v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ PathsResourceItem:\n", v6);
  fprintf(a2, "%s\tFillStartsWithAllPixels:\n", v7);
  fprintf(a2, "%s\tSubpaths[%d]\n", v7, *((unsigned __int16 *)this + 16));
  if (*((_WORD *)this + 16))
  {
    unint64_t v9 = 0;
    uint64_t v10 = a3 + 2;
    do
    {
      fprintf(a2, "%s\t===== Subpath %d =====\n", v7, v9);
      if (!*((void *)this + 5)) {
        CPSDPathsResourceItem::GenerateSubpathResources(this);
      }
      unint64_t v11 = *((unsigned __int16 *)this + 16);
      if (v9 < v11)
      {
        uint64_t v12 = *(void *)(*((void *)this + 5) + 8 * v9);
        if (v12)
        {
          (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(void *)v12 + 48))(v12, a2, v10);
          unint64_t v11 = *((unsigned __int16 *)this + 16);
        }
      }
      ++v9;
    }
    while (v9 < v11);
  }
  return fprintf(a2, "%s} // End of PathsResourceItem\n", v7);
}

uint64_t CPSDPathResource::Dump(CPSDPathResource *this, __sFILE *a2, unsigned int a3)
{
  unsigned int v6 = (const char *)operator new[]();
  BOOL v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Bezier Path:\n", v6);
  fprintf(a2, "%s\tKnots[%d]:\n", v7, *((unsigned __int16 *)this + 9));
  if (*((_WORD *)this + 9))
  {
    unint64_t v9 = 0;
    do
    {
      fprintf(a2, "%s\t[%d]: ", v7, v9);
      uint64_t v10 = *(void *)(*((void *)this + 3) + 8 * v9);
      (*(void (**)(uint64_t, __sFILE *))(*(void *)v10 + 40))(v10, a2);
      ++v9;
    }
    while (v9 < *((unsigned __int16 *)this + 9));
  }
  return fprintf(a2, "%s} // End Bezier Path\n", v7);
}

uint64_t CPSDPathResource::GetBezierKnot(uint64_t a1, unsigned int a2, _OWORD *a3, _OWORD *a4, _OWORD *a5)
{
  unsigned int v5 = *(_OWORD **)(*(void *)(a1 + 24) + 8 * a2);
  *a4 = v5[2];
  *a3 = v5[3];
  *a5 = v5[4];
  return 1;
}

uint64_t CPSDPathDataRecord::Load(CPSDPathDataRecord *this, int a2)
{
  int v3 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, (v3 + 24), 0, 0);
  return 1;
}

uint64_t CPSDPathDataRecord::Save(CPSDPathDataRecord *this, File *a2)
{
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  if (*((_WORD *)this + 8) == 6)
  {
    unsigned int v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 56);
    return v5(a2, 24);
  }
  return result;
}

uint64_t CPSDSubpathLengthRecord::Load(CPSDSubpathLengthRecord *this, int a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 2uLL, &v5);
  *((_WORD *)this + 16) = bswap32(*((unsigned __int16 *)this + 16)) >> 16;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 34, 0x16uLL, &v5);
  return 1;
}

uint64_t CPSDSubpathLengthRecord::Save(CPSDSubpathLengthRecord *this, File *a2)
{
  CPSDPathDataRecord::Save(this, a2);
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 16));
  unsigned __int16 v4 = *(uint64_t (**)(File *, char *, uint64_t))(*(void *)a2 + 48);
  return v4(a2, (char *)this + 34, 22);
}

uint64_t CPSDBezierKnotRecord::Load(CPSDBezierKnotRecord *this, int a2)
{
  uint64_t v4 = 0;
  uint64_t v10 = 0;
  unsigned int v9 = 0;
  do
  {
    CPSDBaseComponent::ReadFile(a2, (char *)&v9, 4uLL, (_DWORD *)&v10 + 1);
    CPSDBaseComponent::ReadFile(a2, (char *)&v10, 4uLL, (_DWORD *)&v10 + 1);
    unsigned int v5 = bswap32(v9);
    double v6 = (double)v5 * 0.0000000596046448;
    unsigned int v9 = v5;
    LODWORD(v10) = bswap32(v10);
    BOOL v7 = (double *)((char *)this + v4);
    v7[4] = (double)v10 * 0.0000000596046448;
    v7[5] = v6;
    v4 += 16;
  }
  while (v4 != 48);
  return 1;
}

uint64_t CPSDBezierKnotRecord::Save(CPSDBezierKnotRecord *this, File *a2)
{
  CPSDPathDataRecord::Save(this, a2);
  for (uint64_t i = 0; i != 48; i += 16)
  {
    LODWORD(v4) = vcvtd_n_u64_f64(*(double *)((char *)this + i + 40), 0x18uLL);
    (*(void (**)(File *, uint64_t))(*(void *)a2 + 80))(a2, v4);
    LODWORD(v6) = vcvtd_n_u64_f64(*(double *)((char *)this + i + 32), 0x18uLL);
    uint64_t result = (*(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80))(a2, v6);
  }
  return result;
}

uint64_t CPSDBezierKnotRecord::Dump(CPSDBezierKnotRecord *this, __sFILE *a2)
{
  int v2 = *((unsigned __int16 *)this + 8);
  BOOL v3 = v2 == 4 || v2 == 1;
  uint64_t v4 = "YES";
  if (!v3) {
    uint64_t v4 = "NO";
  }
  return fprintf(a2, "Anchor: (%f, %f)\tCtrlPt1: (%f, %f)\tCtrlPt2:(%f,%f), <isLinked: %s >\n", *((double *)this + 6), *((double *)this + 7), *((double *)this + 4), *((double *)this + 5), *((double *)this + 8), *((double *)this + 9), v4);
}

uint64_t CPSDClipboardRecord::Load(CPSDClipboardRecord *this, int a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v8, 4uLL, (_DWORD *)&v8 + 1);
  LODWORD(v8) = bswap32(v8);
  *((double *)this + 4) = (double)v8 * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v7 + 4, 4uLL, (_DWORD *)&v8 + 1);
  HIDWORD(v7) = bswap32(HIDWORD(v7));
  *((double *)this + 5) = (double)HIDWORD(v7) * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v7, 4uLL, (_DWORD *)&v8 + 1);
  LODWORD(v7) = bswap32(v7);
  *((double *)this + 6) = (double)v7 * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v6 + 4, 4uLL, (_DWORD *)&v8 + 1);
  HIDWORD(v6) = bswap32(HIDWORD(v6));
  *((double *)this + 7) = (double)HIDWORD(v6) * 0.0000000596046448;
  CPSDBaseComponent::ReadFile(a2, (char *)&v6, 4uLL, (_DWORD *)&v8 + 1);
  LODWORD(v6) = bswap32(v6);
  *((double *)this + 8) = (double)v6 * 0.0000000596046448;
  int v4 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, (v4 + 2), 0, 0);
  return 1;
}

uint64_t CPSDClipboardRecord::Save(CPSDClipboardRecord *this, File *a2)
{
  CPSDPathDataRecord::Save(this, a2);
  LODWORD(v4) = vcvtd_n_u64_f64(*((double *)this + 4), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(void *)a2 + 80))(a2, v4);
  LODWORD(v5) = vcvtd_n_u64_f64(*((double *)this + 5), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(void *)a2 + 80))(a2, v5);
  LODWORD(v6) = vcvtd_n_u64_f64(*((double *)this + 6), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(void *)a2 + 80))(a2, v6);
  LODWORD(v7) = vcvtd_n_u64_f64(*((double *)this + 7), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(void *)a2 + 80))(a2, v7);
  LODWORD(v8) = vcvtd_n_u64_f64(*((double *)this + 8), 0x18uLL);
  (*(void (**)(File *, uint64_t))(*(void *)a2 + 80))(a2, v8);
  unsigned int v9 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 56);
  return v9(a2, 4);
}

uint64_t CPSDInitialFillRecord::Load(CPSDInitialFillRecord *this, int a2)
{
  int v8 = 0;
  unsigned __int16 v7 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v7, 2uLL, &v8);
  int v4 = v7;
  unsigned __int16 v7 = __rev16(v7);
  *((unsigned char *)this + 32) = v4 == 256;
  int v5 = SetFilePointer(a2, 0, 0, 1);
  SetFilePointer(a2, (v5 + 22), 0, 0);
  return 1;
}

uint64_t CPSDInitialFillRecord::Save(CPSDInitialFillRecord *this, File *a2)
{
  CPSDPathDataRecord::Save(this, a2);
  (*(void (**)(File *, BOOL))(*(void *)a2 + 72))(a2, *((unsigned char *)this + 32) != 0);
  int v4 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 56);
  return v4(a2, 22);
}

uint64_t CPSDAdditionalLayerInfo::Load(CPSDAdditionalLayerInfo *this, uint64_t a2)
{
  int v4 = SetFilePointer(a2, 0, 0, 1);
  int v5 = *((_DWORD *)this + 4);
  if ((v5 - 1) < 0xB) {
    return 0;
  }
  int v6 = v4;
  int v8 = (uint64_t *)((char *)this + 24);
  uint64_t v7 = *((void *)this + 3);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  if (v5)
  {
    unsigned int v9 = v5 + v6;
    do
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      CPSDBaseComponent::ReadFile(a2, (char *)&v24, 4uLL, (_DWORD *)&v24 + 1);
      LODWORD(v24) = bswap32(v24);
      CPSDBaseComponent::ReadFile(a2, (char *)&v23 + 4, 4uLL, (_DWORD *)&v24 + 1);
      HIDWORD(v23) = bswap32(HIDWORD(v23));
      CPSDBaseComponent::ReadFile(a2, (char *)&v23, 4uLL, (_DWORD *)&v24 + 1);
      LODWORD(v23) = bswap32(v23);
      if (SHIDWORD(v23) <= 1818654769)
      {
        switch(HIDWORD(v23))
        {
          case 0x4764466C:
            uint64_t v10 = operator new();
            CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v10);
            *(void *)(v10 + 120) = 0;
            *(void *)uint64_t v10 = &unk_1EF486770;
            *(_DWORD *)(v10 + 128) = 0;
            goto LABEL_23;
          case 0x536F436F:
            uint64_t v10 = operator new();
            CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v10);
            *(void *)uint64_t v10 = &unk_1EF486270;
            *(_DWORD *)(v10 + 120) = 0;
            goto LABEL_23;
          case 0x694F7061:
            uint64_t v10 = operator new();
            *(_DWORD *)(v10 + 16) = 0;
            *(_OWORD *)(v10 + 24) = 0u;
            *(_OWORD *)(v10 + 40) = 0u;
            *(void *)uint64_t v10 = &unk_1EF486958;
            *(unsigned char *)(v10 + 56) = -1;
            goto LABEL_23;
        }
      }
      else if (SHIDWORD(v23) > 1819635304)
      {
        if (HIDWORD(v23) == 1986884459)
        {
          uint64_t v10 = operator new();
          *(_DWORD *)(v10 + 16) = 0;
          *(_OWORD *)(v10 + 24) = 0u;
          *(_OWORD *)(v10 + 40) = 0u;
          *(void *)uint64_t v10 = &unk_1EF486530;
          *(void *)(v10 + 56) = &unk_1EF486A18;
          *(void *)(v10 + 80) = 0;
          *(_WORD *)(v10 + 88) = 0;
          *(void *)(v10 + 96) = 0;
          *(void *)(v10 + 104) = 0;
          goto LABEL_23;
        }
        if (HIDWORD(v23) == 1819635305)
        {
          uint64_t v10 = operator new();
          *(_DWORD *)(v10 + 16) = 0;
          *(_OWORD *)(v10 + 24) = 0u;
          *(_OWORD *)(v10 + 40) = 0u;
          *(void *)uint64_t v10 = &unk_1EF486890;
          *(_DWORD *)(v10 + 56) = 0;
          goto LABEL_23;
        }
      }
      else
      {
        if (HIDWORD(v23) == 1818654770)
        {
          uint64_t v10 = operator new();
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v10);
          *(void *)uint64_t v10 = &unk_1EF486F10;
          *(void *)(v10 + 120) = 0;
          goto LABEL_23;
        }
        if (HIDWORD(v23) == 1819501428)
        {
          uint64_t v10 = operator new();
          *(_DWORD *)(v10 + 16) = 0;
          *(_OWORD *)(v10 + 24) = 0u;
          *(_OWORD *)(v10 + 40) = 0u;
          *(void *)uint64_t v10 = &unk_1EF4864F0;
          *(void *)(v10 + 56) = 0;
          *(_DWORD *)(v10 + 64) = 0;
          goto LABEL_23;
        }
      }
      uint64_t v10 = operator new();
      *(_DWORD *)(v10 + 16) = 0;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0;
      *(void *)uint64_t v10 = &unk_1EF486F60;
      *(void *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
LABEL_23:
      int v11 = HIDWORD(v23);
      *(_DWORD *)(v10 + 16) = v23;
      *(_DWORD *)(v10 + 40) = v24;
      *(_DWORD *)(v10 + 44) = v11;
      CPSDResourceItem::LoadItem((CPSDResourceItem *)v10, a2);
      uint64_t v12 = *v8;
      uint64_t v13 = (uint64_t *)((char *)this + 24);
      if (*v8)
      {
        do
        {
          uint64_t v14 = v12;
          uint64_t v12 = *(void *)(v12 + 48);
        }
        while (v12);
        uint64_t v13 = (uint64_t *)(v14 + 48);
      }
      *uint64_t v13 = v10;
      unsigned int v15 = SetFilePointer(a2, 0, 0, 1);
      if (v15 > v9)
      {
        _CUILog(1, (uint64_t)"Additional Layer Info Size is Recorded Incorrectly in File: recorded size = %d, bytes read = %d.\n", v16, v17, v18, v19, v20, v21, *((unsigned int *)this + 4));
        return 0;
      }
      if ((v23 & 3) != 0) {
        unsigned int v15 = SetFilePointer(a2, 4 - (v23 & 3), 0, 1);
      }
    }
    while (v9 != v15);
  }
  SetFilePointer(a2, (*((_DWORD *)this + 4) + v6), 0, 0);
  return 1;
}

void sub_1A133E5DC(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C402C48CE55);
  _Unwind_Resume(a1);
}

uint64_t CPSDAdditionalLayerInfo::Save(uint64_t this, File *a2)
{
  for (uint64_t i = *(CPSDResourceItem **)(this + 24); i; uint64_t i = (CPSDResourceItem *)*((void *)i + 6))
    this = CPSDResourceItem::SaveItem(i, a2);
  return this;
}

void *CPSDAdditionalLayerInfo::GetFirstItemOfTypeID(CPSDAdditionalLayerInfo *this, const std::type_info *a2)
{
  for (uint64_t i = (void *)*((void *)this + 3); i; uint64_t i = (void *)i[6])
  {
    if (std::type_info::operator==[abi:ne180100](*(void *)(*i - 8), (uint64_t)a2)) {
      break;
    }
  }
  return i;
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

uint64_t CPSDAdditionalLayerInfoItem::Save(CPSDAdditionalLayerInfoItem *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 10));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 11));
  uint64_t v4 = *((unsigned int *)this + 4);
  int v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80);
  return v5(a2, v4);
}

void CPSDLayerAndMaskInfo::CPSDLayerAndMaskInfo(CPSDLayerAndMaskInfo *this)
{
  *(void *)this = &unk_1EF4867C0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = &unk_1EF485F08;
  *((_DWORD *)this + 10) = 0;
  *((_WORD *)this + 22) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = &unk_1EF486BE0;
  *((_DWORD *)this + 28) = 0;
  *((_WORD *)this + 58) = 0;
  *((_WORD *)this + 63) = 0;
  *((unsigned char *)this + 128) = 0;
  *((_DWORD *)this + 33) = 0;
  bzero((char *)this + 118, 8uLL);
  *((void *)this + 17) = &unk_1EF486B60;
  *((_DWORD *)this + 38) = 0;
  *((void *)this + 20) = 0;
}

uint64_t CPSDLayerAndMaskInfo::SkipPast(CPSDLayerAndMaskInfo *this, uint64_t a2)
{
  int v9 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v9);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  int v4 = SetFilePointer(a2, 0, 0, 1);
  int v5 = *((_DWORD *)this + 4);
  if (v5)
  {
    int v6 = v4;
    uint64_t v7 = *((void *)this + 4);
    if (*(unsigned __int16 *)(v7 + 152) < 9u)
    {
      CPSDLayerInfo::LoadLayerInfo((CPSDLayerAndMaskInfo *)((char *)this + 24), a2);
      int v5 = *((_DWORD *)this + 4);
    }
    else if (*(unsigned __int16 *)(v7 + 154) < *(unsigned __int16 *)(v7 + 140))
    {
      *(unsigned char *)(v7 + 104) = 1;
    }
    SetFilePointer(a2, (v5 + v6), 0, 0);
  }
  return 1;
}

uint64_t CPSDLayerInfo::Load(CPSDLayerInfo *this, uint64_t a2)
{
  uint64_t result = CPSDLayerInfo::LoadLayerInfo(this, a2);
  if (result)
  {
    std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 48, *((unsigned __int16 *)this + 10));
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    unint64_t v7 = *((unsigned __int16 *)this + 10);
    *((_WORD *)this + 10) = 0;
    do
    {
      unint64_t v8 = v6;
      if (v7 == v6) {
        break;
      }
      int v9 = (CPSDLayerChannelGroup *)operator new();
      CPSDLayerChannelGroup::CPSDLayerChannelGroup(v9, (CPSDLayerRecord *)(*((void *)this + 3) + v5));
      *(void *)(*((void *)this + 6) + 8 * v8) = v9;
      unint64_t v6 = v8 + 1;
      *((_WORD *)this + 10) = v8 + 1;
      uint64_t v10 = *(void *)(*((void *)this + 6) + 8 * v8);
      v5 += 488;
    }
    while ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v10 + 16))(v10, a2));
    return v8 >= v7;
  }
  return result;
}

void sub_1A133EA50(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10A1C401A1F3E30);
  _Unwind_Resume(a1);
}

uint64_t CPSDGlobalLayerMaskInfo::Load(CPSDGlobalLayerMaskInfo *this, int a2, unsigned int a3)
{
  int v6 = SetFilePointer(a2, 0, 0, 1);
  int v17 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v17);
  unsigned int v7 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v7);
  if (v7)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 2uLL, &v17);
    *((_WORD *)this + 10) = bswap32(*((unsigned __int16 *)this + 10)) >> 16;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 22, 8uLL, &v17);
    *(int8x8_t *)((char *)this + 22) = vrev16_s8(*(int8x8_t *)((char *)this + 22));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 30, 2uLL, &v17);
    *((_WORD *)this + 15) = bswap32(*((unsigned __int16 *)this + 15)) >> 16;
    CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 1uLL, &v17);
  }
  int v8 = SetFilePointer(a2, 0, 0, 1) - v6;
  int v16 = 0;
  do
  {
    char v15 = -1;
    CPSDBaseComponent::ReadFile(a2, &v15, 1uLL, &v16);
    int v9 = v16;
    int v10 = *((_DWORD *)this + 9) + v16;
    *((_DWORD *)this + 9) = v10;
    unsigned int v11 = v8 + v10;
  }
  while (v9 == 1 && v11 < a3 && v15 == 0);
  if (v9 == 1)
  {
    SetFilePointer(a2, -1, 0, 1);
    --*((_DWORD *)this + 9);
  }
  return 1;
}

uint64_t CPSDLayerInfo::Save(CPSDLayerInfo *this, File *a2)
{
  uint64_t result = CPSDLayerInfo::SaveLayerInfo(this, a2);
  uint64_t v5 = *((unsigned __int16 *)this + 10);
  if (v5 == (uint64_t)(*((void *)this + 7) - *((void *)this + 6)) >> 3 && v5 != 0)
  {
    unint64_t v7 = 0;
    do
    {
      uint64_t v8 = *(void *)(*((void *)this + 6) + 8 * v7);
      uint64_t result = (*(uint64_t (**)(uint64_t, File *))(*(void *)v8 + 24))(v8, a2);
      ++v7;
    }
    while (v7 < *((unsigned __int16 *)this + 10));
  }
  return result;
}

uint64_t CPSDGlobalLayerMaskInfo::Save(CPSDGlobalLayerMaskInfo *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*((_DWORD *)this + 4))
  {
    (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 10));
    (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 11));
    (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 12));
    (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 13));
    (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 14));
    (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 15));
    (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 32));
  }
  uint64_t v4 = *((unsigned int *)this + 9);
  uint64_t v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 56);
  return v5(a2, v4);
}

uint64_t CPSDLayerInfo::LoadLayer(CPSDLayerInfo *this, uint64_t a2)
{
  int v4 = SetFilePointer(a2, 0, 0, 1);
  if (!CPSDLayerInfo::LoadLayerInfo(this, a2)) {
    return 0;
  }
  uint64_t v5 = 1;
  int v6 = SetFilePointer(a2, 0, 0, 1);
  off_t v7 = (*((_DWORD *)this + 4) + v4);
  if (v6 != v7) {
    SetFilePointer(a2, v7, 0, 0);
  }
  return v5;
}

uint64_t CPSDLayerInfo::Dump(CPSDLayerInfo *this, __sFILE *a2)
{
  uint64_t result = fprintf(a2, "{ LayerInfo: %d layers [%d bytes]\n", *((unsigned __int16 *)this + 10), *((_DWORD *)this + 4));
  if (*((_WORD *)this + 10))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      CPSDLayerRecord::GetLayerName((CPSDLayerRecord *)(*((void *)this + 3) + v5), v9, 0x100u);
      {
        off_t v7 = "Group";
      }
      else
      {
        off_t v7 = "Layer";
      }
      fprintf(a2, "\n  ================ %s: [ %s ] ==================\n", v7, v9);
      (*(void (**)(uint64_t, __sFILE *))(*(void *)(*((void *)this + 3) + v5) + 40))(*((void *)this + 3) + v5, a2);
      uint64_t v8 = *(void *)(*((void *)this + 6) + 8 * v6);
      uint64_t result = (*(uint64_t (**)(uint64_t, __sFILE *))(*(void *)v8 + 40))(v8, a2);
      ++v6;
      v5 += 488;
    }
    while (v6 < *((unsigned __int16 *)this + 10));
  }
  return result;
}

void CPSDChannelData::~CPSDChannelData(CPSDChannelData *this)
{
  *(void *)this = &unk_1EF486078;
  if (*((_WORD *)this + 12))
  {
    uint64_t v2 = *((void *)this + 4);
    if (v2) {
      MEMORY[0x1A6230DD0](v2, 0x1000C80BDFB0063);
    }
  }
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
  }
}

{
  uint64_t vars8;

  CPSDChannelData::~CPSDChannelData(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDChannelData::UnpackImageInPosition(CPSDChannelData *this, unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  unsigned int v12 = a10;
  uint64_t v14 = (unsigned __int16 *)*((void *)this + 4);
  uint64_t v13 = (const unsigned __int8 *)*((void *)this + 5);
  unsigned int v15 = *((_DWORD *)this + 5);
  if (v15 >= a8) {
    unsigned int v16 = a8;
  }
  else {
    unsigned int v16 = *((_DWORD *)this + 5);
  }
  if (v15 >= a6) {
    unsigned int v17 = a6;
  }
  else {
    unsigned int v17 = *((_DWORD *)this + 5);
  }
  if (a10 >= a4) {
    unsigned int v12 = a4;
  }
  if (v15)
  {
    uint64_t v18 = (unsigned __int16)(*((_DWORD *)this + 12) / v15);
    if (!v17) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v18 = 0;
    if (!v17) {
      goto LABEL_17;
    }
  }
  do
  {
    if (*((_WORD *)this + 12))
    {
      unsigned int v20 = *v14++;
      uint64_t v19 = v20;
    }
    else
    {
      uint64_t v19 = v18;
    }
    v13 += v19;
    --v17;
  }
  while (v17);
LABEL_17:
  *((unsigned char *)this + 52) = 1;
  if (v16)
  {
    uint64_t v21 = a3;
    unsigned int v22 = &a2[a9 + v12 * (unint64_t)a3];
    if (a3 >= a7) {
      unsigned __int16 v23 = a7;
    }
    else {
      unsigned __int16 v23 = a3;
    }
    size_t v24 = v23;
    do
    {
      if (*((_WORD *)this + 12))
      {
        unsigned int v25 = *v14++;
        uint64_t v18 = v25;
      }
      CPSDChannelData::UnpackRowBits(this, v13, (unsigned __int16)v18, v22, v24, a5);
      v13 += v18;
      v22 += v21;
      --v16;
    }
    while (v16);
  }
  return 1;
}

uint64_t CPSDChannelData::UnpackRowBits(CPSDChannelData *this, const unsigned __int8 *a2, int a3, unsigned __int8 *__b, size_t __n, int a6)
{
  unsigned int v6 = __n;
  off_t v7 = __b;
  uint64_t v8 = a2;
  if (*((_WORD *)this + 12))
  {
    int v10 = a3;
    if (a3 && __n)
    {
      int v11 = 0;
      int v25 = a6;
      do
      {
        uint64_t v13 = v8 + 1;
        int v12 = *(char *)v8;
        if (v12 < 0)
        {
          if (v12 == -128)
          {
            --v10;
            ++v8;
            continue;
          }
          unsigned __int16 v19 = 1 - v12;
          int v20 = v8[1];
          LODWORD(v14) = v19;
          if (v19 >= v6) {
            unsigned int v21 = v6;
          }
          else {
            unsigned int v21 = v19;
          }
          unsigned int v22 = (v11 - a6 + v19) & ~((v11 - a6 + v19) >> 31);
          if (v21 >= v22) {
            unsigned int v23 = v22;
          }
          else {
            unsigned int v23 = v21;
          }
          if (v23)
          {
            memset(v7, v8[1], (__int16)v23);
            a6 = v25;
          }
          if (*((unsigned char *)this + 52) && v20) {
            *((unsigned char *)this + 52) = 0;
          }
          v8 += 2;
          v10 -= 2;
          int v18 = (__int16)v23;
          v7 += (__int16)v23;
        }
        else
        {
          uint64_t v14 = *(char *)v8 + 1;
          int v15 = a6 - v11;
          if (v14 >= v6) {
            unsigned int v16 = v6;
          }
          else {
            unsigned int v16 = *(char *)v8 + 1;
          }
          if (v16 >= ((v14 - v15) & ~(((int)v14 - v15) >> 31))) {
            __int16 v17 = (v14 - v15) & ~(unsigned __int16)(((int)v14 - v15) >> 31);
          }
          else {
            __int16 v17 = v16;
          }
          if (v17)
          {
            memcpy(v7, &v13[(unsigned __int16)(v15 & ~(unsigned __int16)(v15 >> 31))], v17);
            a6 = v25;
          }
          uint64_t v8 = &v13[v14];
          int v10 = v10 - 1 - v14;
          int v18 = v17;
          v7 += v17;
          if (*((unsigned char *)this + 52)) {
            *((unsigned char *)this + 52) = 0;
          }
        }
        v6 -= v18;
        v11 += v14;
      }
      while ((_WORD)v10 && v6);
    }
  }
  else
  {
    memcpy(__b, &a2[a6], __n);
    if (*((unsigned char *)this + 52)) {
      *((unsigned char *)this + 52) = 0;
    }
  }
  return 1;
}

BOOL CPSDChannelData::Load(CPSDChannelData *this, uint64_t a2, int a3, int a4)
{
  int v14 = 0;
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = a4;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 2uLL, &v14);
  int v6 = v14;
  unsigned int v7 = bswap32(*((unsigned __int16 *)this + 12)) >> 16;
  *((_WORD *)this + 12) = v7;
  if (v7)
  {
    if (v7 != 1)
    {
      printf("Error - Unhandled compression type.  We currently handle 'Run Length Encoding' and 'no compression' only.");
      return 0;
    }
    uint64_t v8 = (char *)operator new[]();
    *((void *)this + 4) = v8;
    CPSDBaseComponent::ReadFile(a2, v8, (2 * *((_DWORD *)this + 5)), &v14);
    v6 += v14;
    uint64_t v9 = *((unsigned int *)this + 5);
    if (v9)
    {
      LODWORD(v10) = 0;
      int v11 = (_WORD *)*((void *)this + 4);
      do
      {
        unsigned int v12 = bswap32((unsigned __int16)*v11);
        *v11++ = HIWORD(v12);
        uint64_t v10 = v10 + HIWORD(v12);
        --v9;
      }
      while (v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
  }
  else
  {
    uint64_t v10 = (*((_DWORD *)this + 4) - 2);
  }
  (*(void (**)(CPSDChannelData *, uint64_t, uint64_t))(*(void *)this + 56))(this, a2, v10);
  return v10 + v6 == *((_DWORD *)this + 4);
}

uint64_t CPSDChannelData::Save(CPSDChannelData *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 12));
  if (*((_WORD *)this + 12) && *((_DWORD *)this + 5))
  {
    unint64_t v4 = 0;
    do
      (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *(unsigned __int16 *)(*((void *)this + 4) + 2 * v4++));
    while (v4 < *((unsigned int *)this + 5));
  }
  uint64_t v5 = *(uint64_t (**)(CPSDChannelData *, File *))(*(void *)this + 64);
  return v5(this, a2);
}

uint64_t CPSDChannelData::LoadChannelData(uint64_t this, int a2, int a3)
{
  uint64_t v3 = this;
  *(_DWORD *)(this + 48) = a3;
  if (a3)
  {
    int v6 = 0;
    uint64_t v5 = (char *)operator new[]();
    *(void *)(v3 + 40) = v5;
    this = CPSDBaseComponent::ReadFile(a2, v5, *(unsigned int *)(v3 + 48), &v6);
    if (v6 != *(_DWORD *)(v3 + 48)) {
      CPSDChannelData::LoadChannelData();
    }
  }
  else
  {
    *(void *)(this + 40) = 0;
  }
  return this;
}

uint64_t CPSDChannelData::SaveChannelData(uint64_t this, File *a2)
{
  if (*(_DWORD *)(this + 48)) {
    return (*(uint64_t (**)(File *, void))(*(void *)a2 + 48))(a2, *(void *)(this + 40));
  }
  return this;
}

BOOL CPSDLayerChannelGroup::Load(CPSDLayerChannelGroup *this, uint64_t a2)
{
  if (!*((_DWORD *)this + 6)) {
    return 1;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  do
  {
    uint64_t v7 = *((void *)this + 2);
    uint64_t v8 = *(void *)(v7 + 40) + v4;
    int v9 = *(unsigned __int16 *)(v8 + 16);
    if (v9 == 65533)
    {
      int v10 = *(_DWORD *)(v7 + 128);
      int v11 = *(_DWORD *)(v7 + 120);
    }
    else if (v9 == 65534)
    {
      int v10 = *(_DWORD *)(v7 + 108);
      int v11 = *(_DWORD *)(v7 + 100);
    }
    else
    {
      int v10 = *(_DWORD *)(v7 + 24);
      int v11 = *(_DWORD *)(v7 + 16);
    }
    int v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)(*((void *)this + 4) + v5) + 48))(*((void *)this + 4) + v5, a2, *(unsigned int *)(v8 + 20), (v10 - v11));
    BOOL result = v12 != 0;
    if (!v12) {
      break;
    }
    ++v6;
    v5 += 56;
    v4 += 24;
  }
  while (v6 < *((unsigned int *)this + 6));
  return result;
}

uint64_t CPSDLayerChannelGroup::Save(uint64_t this, File *a2)
{
  if (*(_DWORD *)(this + 24))
  {
    uint64_t v3 = this;
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      this = (*(uint64_t (**)(uint64_t, File *))(*(void *)(*(void *)(v3 + 32) + v4) + 24))(*(void *)(v3 + 32) + v4, a2);
      ++v5;
      v4 += 56;
    }
    while (v5 < *(unsigned int *)(v3 + 24));
  }
  return this;
}

void CPSDLayerInfo::~CPSDLayerInfo(CPSDLayerInfo *this)
{
  *(void *)this = &unk_1EF485F08;
  uint64_t v4 = (char *)this + 48;
  uint64_t v2 = (void *)*((void *)this + 6);
  uint64_t v3 = (void *)*((void *)v4 + 1);
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  unint64_t v5 = 0;
  do
  {
    uint64_t v6 = v2[v5];
    if (v6)
    {
      (*(void (**)(void))(*(void *)v6 + 8))(v2[v5]);
      uint64_t v2 = (void *)*((void *)this + 6);
      uint64_t v3 = (void *)*((void *)this + 7);
    }
    ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_7:
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
LABEL_8:
  uint64_t v7 = (void **)((char *)this + 24);
  std::vector<CPSDLayerRecord>::__destroy_vector::operator()[abi:ne180100](&v7);
}

{
  uint64_t vars8;

  CPSDLayerInfo::~CPSDLayerInfo(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDLayerInfo::LoadLayerInfo(CPSDLayerInfo *this, uint64_t a2)
{
  uint64_t v6 = (void (***)(void))*((void *)this + 3);
  uint64_t v4 = (void (***)(void))*((void *)this + 4);
  unint64_t v5 = (uint64_t *)((char *)this + 24);
  if (v4 != v6)
  {
    uint64_t v7 = v4 - 61;
    uint64_t v8 = v4 - 61;
    do
    {
      (**v8)(v8);
      v7 -= 61;
      BOOL v9 = v8 == v6;
      v8 -= 61;
    }
    while (!v9);
  }
  int v18 = 0;
  *((void *)this + 4) = v6;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v18);
  unsigned int v10 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v10);
  if (!v10) {
    return 1;
  }
  unsigned __int16 v17 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v17, 2uLL, &v18);
  int v11 = v17;
  int v12 = (int)bswap32(v17) >> 16;
  unsigned __int16 v17 = __rev16(v17);
  if (v12 < 0)
  {
    int v12 = -v12;
    *((_WORD *)this + 10) = v12;
    uint64_t v13 = (_WORD *)((char *)this + 20);
    *(unsigned char *)(*((void *)this + 1) + 104) = 1;
  }
  else
  {
    *((_WORD *)this + 10) = v12;
    uint64_t v13 = (_WORD *)((char *)this + 20);
    if (!v11) {
      return 1;
    }
  }
  std::vector<CPSDLayerRecord>::resize(v5, (unsigned __int16)v12);
  if (!*v13) {
    return 1;
  }
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  while (1)
  {
    (*(void (**)(uint64_t, void))(*(void *)(*((void *)this + 3) + v14) + 32))(*((void *)this + 3) + v14, *((void *)this + 1));
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*((void *)this + 3) + v14) + 16))(*((void *)this + 3) + v14, a2);
    if (!result) {
      break;
    }
    ++v15;
    v14 += 488;
    if (v15 >= (unsigned __int16)*v13) {
      return 1;
    }
  }
  return result;
}

uint64_t *std::vector<CPSDLayerRecord>::resize(uint64_t *result, unint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[1];
  unint64_t v4 = 0x4FBCDA3AC10C9715 * ((v3 - *result) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    return (uint64_t *)std::vector<CPSDLayerRecord>::__append(result, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *result + 488 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = v3 - 488;
      BOOL v9 = (uint64_t (***)(void))(v3 - 488);
      do
      {
        uint64_t result = (uint64_t *)(**v9)(v9);
        v8 -= 488;
        BOOL v10 = v9 == (uint64_t (***)(void))v7;
        v9 -= 61;
      }
      while (!v10);
    }
    v2[1] = v7;
  }
  return result;
}

uint64_t CPSDLayerInfo::SaveLayerInfo(CPSDLayerInfo *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  if (*(unsigned char *)(*((void *)this + 1) + 104)) {
    int v4 = -*((unsigned __int16 *)this + 10);
  }
  else {
    LOWORD(v4) = *((_WORD *)this + 10);
  }
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 72))(a2, (unsigned __int16)v4);
  uint64_t v6 = *((unsigned __int16 *)this + 10);
  if (0x4FBCDA3AC10C9715 * ((uint64_t)(*((void *)this + 4) - *((void *)this + 3)) >> 3) == v6 && v6 != 0)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, File *))(*(void *)(*((void *)this + 3) + v8) + 24))(*((void *)this + 3) + v8, a2);
      ++v9;
      v8 += 488;
    }
    while (v9 < *((unsigned __int16 *)this + 10));
  }
  return result;
}

void CPSDLayerInfo::CreateImageAtLayer(CPSDLayerInfo *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 10) >= a2)
  {
    if (CPSDFile::IsTaggedWithICCProfile(*((CPSDFile **)this + 1)))
    {
      uint64_t v4 = CPSDImageResources::LookupResourceWithResID((CPSDImageResources *)(*((void *)this + 1) + 192), 1039);
      BOOL v5 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 56))(v4);
      int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 48))(v4);
    }
    else
    {
      BOOL v5 = 0;
      int v6 = 0;
    }
    uint64_t v7 = (CPSDLayerImage *)operator new();
    CPSDLayerImage::CPSDLayerImage(v7, (CPSDLayerRecord *)(*((void *)this + 3) + 488 * a2), *(CPSDLayerChannelGroup **)(*((void *)this + 6) + 8 * a2), *(_WORD *)(*((void *)this + 1) + 154), *(unsigned __int16 *)(*((void *)this + 1) + 152), v6, v5);
  }
}

void CPSDLayerInfo::CreateImageAtLayerWithSlice(CPSDLayerInfo *this, unsigned int a2, CPSDSliceResource *a3)
{
  if (*((unsigned __int16 *)this + 10) >= a2)
  {
    int32x4_t v9 = vrev64q_s32(*(int32x4_t *)((char *)a3 + 52));
    if (CPSDFile::IsTaggedWithICCProfile(*((CPSDFile **)this + 1)))
    {
      uint64_t v5 = CPSDImageResources::LookupResourceWithResID((CPSDImageResources *)(*((void *)this + 1) + 192), 1039);
      int v6 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5);
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
    }
    else
    {
      int v6 = 0;
      int v7 = 0;
    }
    uint64_t v8 = (CPSDLayerSliceImage *)operator new();
    CPSDLayerSliceImage::CPSDLayerSliceImage(v8, (CPSDLayerRecord *)(*((void *)this + 3) + 488 * a2), *(CPSDLayerChannelGroup **)(*((void *)this + 6) + 8 * a2), (PSDRect *)&v9, *(_WORD *)(*((void *)this + 1) + 154), *(unsigned __int16 *)(*((void *)this + 1) + 152), v7, v6);
  }
}

void CPSDLayerRecord::CPSDLayerRecord(CPSDLayerRecord *this)
{
  *(void *)this = &unk_1EF4860D0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_WORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = &unk_1EF486300;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 18) = &unk_1EF486C70;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 57) = &unk_1EF486B60;
  *((_DWORD *)this + 118) = 0;
  *((void *)this + 60) = 0;
  bzero((char *)this + 200, 0x100uLL);
}

void CPSDAdditionalLayerInfo::~CPSDAdditionalLayerInfo(CPSDAdditionalLayerInfo *this)
{
  *(void *)this = &unk_1EF486B60;
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486B60;
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x1A6230DF0);
}

void CPSDLayerBlendingRanges::~CPSDLayerBlendingRanges(CPSDLayerBlendingRanges *this)
{
  *(void *)this = &unk_1EF486C70;
  uint64_t v1 = (void **)((char *)this + 32);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  *(void *)this = &unk_1EF486C70;
  uint64_t v2 = (void **)((char *)this + 32);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1A6230DF0](this, 0x10A1C40D16F0FACLL);
}

void CPSDLayerRecord::~CPSDLayerRecord(CPSDLayerRecord *this)
{
  *(void *)this = &unk_1EF4860D0;
  *((void *)this + 57) = &unk_1EF486B60;
  uint64_t v2 = *((void *)this + 60);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 18) = &unk_1EF486C70;
  uint64_t v3 = (void **)((char *)this + 176);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 40);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](&v3);
}

{
  uint64_t vars8;

  CPSDLayerRecord::~CPSDLayerRecord(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDLayerRecord::Dump(CPSDLayerRecord *this, __sFILE *a2)
{
  fprintf(a2, "{    Rect: { %d,%d,%d,%d } x %d Channels\n", *((_DWORD *)this + 5), *((_DWORD *)this + 4), *((_DWORD *)this + 7), *((_DWORD *)this + 6), *((unsigned __int16 *)this + 16));
  uint64_t v4 = "No";
  if ((*((unsigned char *)this + 74) & 2) == 0) {
    uint64_t v4 = "Yes";
  }
  fprintf(a2, "     Visible: %s\t\t\t\t\tExtraDataSize: [%d bytes]\n", v4, *((_DWORD *)this + 19));
  if (*((_WORD *)this + 16))
  {
    int v5 = 0;
    int v6 = (int *)(*((void *)this + 5) + 20);
    uint64_t v7 = *((unsigned __int16 *)this + 16);
    do
    {
      int v8 = *v6;
      v6 += 6;
      v5 += v8;
      --v7;
    }
    while (v7);
  }
  else
  {
    int v5 = 0;
  }
  if (*((_WORD *)this + 16))
  {
    unsigned int v10 = 0;
    uint64_t v11 = *((unsigned __int16 *)this + 16);
    int v12 = (int *)(*((void *)this + 5) + 20);
    do
    {
      int v13 = *v12;
      v12 += 6;
      v10 += v13;
      --v11;
    }
    while (v11);
    float v14 = (float)v10;
  }
  else
  {
    float v14 = 0.0;
  }
  unsigned int v9 = 4
     * *((unsigned __int16 *)this + 16)
     * (*((_DWORD *)this + 7) - *((_DWORD *)this + 5))
     * (*((_DWORD *)this + 6) - *((_DWORD *)this + 4));
  fprintf(a2, "     Channels:   [%d bytes]\t\tUncompressed: [%d bytes]\tRatio: %f\n", v5, v9, (float)(v14 / (float)v9));
  uint64_t v15 = *((unsigned __int16 *)this + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 6) - *((void *)this + 5)) >> 3) == v15 && v15 != 0)
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    do
    {
      fprintf(a2, "          Channel %d:\t%8d bytes, id=%d ", v18, *(_DWORD *)(*((void *)this + 5) + v17 + 20), *(__int16 *)(*((void *)this + 5) + v17 + 16));
      switch(*(_WORD *)(*((void *)this + 5) + v17 + 16))
      {
        case 0xFFFE:
          unsigned __int16 v19 = "(user supplied layer mask or vector mask)";
          size_t v20 = 41;
          break;
        case 0xFFFF:
          unsigned __int16 v19 = "(transparency mask)";
          size_t v20 = 19;
          break;
        case 0:
          unsigned __int16 v19 = "(R)";
          goto LABEL_25;
        case 1:
          unsigned __int16 v19 = "(G)";
          goto LABEL_25;
        case 2:
          unsigned __int16 v19 = "(B)";
LABEL_25:
          size_t v20 = 3;
          break;
        default:
          unsigned __int16 v19 = "(real layer mask)";
          size_t v20 = 17;
          break;
      }
      fwrite(v19, v20, 1uLL, a2);
      fputc(10, a2);
      ++v18;
      v17 += 24;
    }
    while (v18 < *((unsigned __int16 *)this + 16));
  }
  char v36 = 0;
  unsigned int v35 = bswap32(*((_DWORD *)this + 17));
  int v21 = *((unsigned __int8 *)this + 72);
  unsigned int v22 = (CPSDLayerRecord *)((char *)this + 456);
  if (FirstItemOfTypeID) {
    int v24 = *((unsigned __int8 *)FirstItemOfTypeID + 56);
  }
  else {
    int v24 = 255;
  }
  fprintf(a2, "     BlendModeKey: '%s'\tOpacity: %d\tFill Opacity: %d (out of 255)\n", (const char *)&v35, v21, v24);
  CPSDLayerMaskData::Dump((_DWORD *)this + 20, a2);
  if (v25) {
    (*(void (**)(void *, __sFILE *))(*v25 + 40))(v25, a2);
  }
  if (v26)
  {
    unsigned __int16 v27 = v26;
    fwrite("{ Section Divider Type: ", 0x18uLL, 1uLL, a2);
    int v28 = *((_DWORD *)v27 + 14);
    switch(v28)
    {
      case 3:
        uint64_t v29 = "Bounding section divider, hidden in the UI";
        size_t v30 = 42;
        break;
      case 2:
        uint64_t v29 = "Closed \"folder\"";
        size_t v30 = 15;
        break;
      case 1:
        uint64_t v29 = "Open \"folder\"";
        size_t v30 = 13;
        break;
      default:
        uint64_t v29 = "Any other type of layer";
        size_t v30 = 23;
        break;
    }
    fwrite(v29, v30, 1uLL, a2);
    fwrite(" }\n", 3uLL, 1uLL, a2);
  }
  if (v31) {
    (*(void (**)(void *, __sFILE *))(*v31 + 40))(v31, a2);
  }
  if (v32) {
    (*(void (**)(void *, __sFILE *))(*v32 + 40))(v32, a2);
  }
  if (v33) {
    (*(void (**)(void *, __sFILE *))(*v33 + 40))(v33, a2);
  }
  return fputc(125, a2);
}

_DWORD *CPSDLayerMaskData::Dump(_DWORD *this, __sFILE *a2)
{
  int v2 = this[4];
  if (v2) {
    return (_DWORD *)fprintf(a2, "{ LayerMaskData: {%d,%d,%d,%d} size=%d }\n", this[5], this[6], this[7], this[8], v2);
  }
  return this;
}

uint64_t CPSDLayerRecord::Load(CPSDLayerRecord *this, uint64_t a2)
{
  int v11 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v11);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v11);
  *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 4uLL, &v11);
  *((_DWORD *)this + 6) = bswap32(*((_DWORD *)this + 6));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 4uLL, &v11);
  *((_DWORD *)this + 7) = bswap32(*((_DWORD *)this + 7));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 2uLL, &v11);
  unsigned int v4 = *((unsigned __int16 *)this + 16);
  unint64_t v5 = __rev16(v4);
  *((_WORD *)this + 16) = v5;
  if (v4 && (std::vector<CPSDChannelLengthInfo>::resize((uint64_t *)this + 5, v5), *((_WORD *)this + 16)))
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*((void *)this + 5) + v6) + 16))(*((void *)this + 5) + v6, a2);
      if (!result) {
        break;
      }
      ++v7;
      v6 += 24;
      if (v7 >= *((unsigned __int16 *)this + 16)) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    CPSDBaseComponent::ReadFile(a2, (char *)this + 64, 4uLL, &v11);
    *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 68, 4uLL, &v11);
    *((_DWORD *)this + 17) = bswap32(*((_DWORD *)this + 17));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 72, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 73, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 74, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 75, 1uLL, &v11);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 76, 4uLL, &v11);
    *((_DWORD *)this + 19) = bswap32(*((_DWORD *)this + 19));
    unsigned int v9 = *((_DWORD *)this + 19) + SetFilePointer(a2, 0, 0, 1);
    CPSDLayerMaskData::Load((CPSDLayerRecord *)((char *)this + 80), a2);
    CPSDLayerBlendingRanges::Load((CPSDLayerRecord *)((char *)this + 144), a2);
    LoadPascalStringAsCString(a2, &v11, (char *)this + 200, 4);
    unsigned int v10 = SetFilePointer(a2, 0, 0, 1);
    if (v9 >= v10)
    {
      *((_DWORD *)this + 118) = v9 - v10;
      CPSDAdditionalLayerInfo::Load((CPSDLayerRecord *)((char *)this + 456), a2);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CPSDLayerMaskData::Load(CPSDLayerMaskData *this, int a2)
{
  int v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v6);
  unsigned int v4 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = bswap32(v4);
  if (v4)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v6);
    *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 4uLL, &v6);
    *((_DWORD *)this + 6) = bswap32(*((_DWORD *)this + 6));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 28, 4uLL, &v6);
    *((_DWORD *)this + 7) = bswap32(*((_DWORD *)this + 7));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 32, 4uLL, &v6);
    *((_DWORD *)this + 8) = bswap32(*((_DWORD *)this + 8));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 36, 1uLL, &v6);
    CPSDBaseComponent::ReadFile(a2, (char *)this + 37, 1uLL, &v6);
    if (*((_DWORD *)this + 4) == 20)
    {
      CPSDBaseComponent::ReadFile(a2, (char *)this + 38, 2uLL, &v6);
      *((_WORD *)this + 19) = bswap32(*((unsigned __int16 *)this + 19)) >> 16;
    }
    else
    {
      CPSDBaseComponent::ReadFile(a2, (char *)this + 57, 1uLL, &v6);
      CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 1uLL, &v6);
      CPSDBaseComponent::ReadFile(a2, (char *)this + 40, 4uLL, &v6);
      *((_DWORD *)this + 10) = bswap32(*((_DWORD *)this + 10));
      CPSDBaseComponent::ReadFile(a2, (char *)this + 44, 4uLL, &v6);
      *((_DWORD *)this + 11) = bswap32(*((_DWORD *)this + 11));
      CPSDBaseComponent::ReadFile(a2, (char *)this + 48, 4uLL, &v6);
      *((_DWORD *)this + 12) = bswap32(*((_DWORD *)this + 12));
      CPSDBaseComponent::ReadFile(a2, (char *)this + 52, 4uLL, &v6);
      *((_DWORD *)this + 13) = bswap32(*((_DWORD *)this + 13));
    }
  }
  return 1;
}

uint64_t CPSDLayerBlendingRanges::Load(CPSDLayerBlendingRanges *this, uint64_t a2)
{
  int v6 = (void (***)(void))*((void *)this + 4);
  unsigned int v4 = (void (***)(void))*((void *)this + 5);
  unint64_t v5 = (uint64_t *)((char *)this + 32);
  if (v4 != v6)
  {
    unint64_t v7 = v4 - 3;
    int v8 = v4 - 3;
    unsigned int v9 = v4 - 3;
    do
    {
      unsigned int v10 = *v9;
      v9 -= 3;
      (*v10)(v8);
      v7 -= 3;
      BOOL v11 = v8 == v6;
      int v8 = v9;
    }
    while (!v11);
  }
  int v23 = 0;
  *((void *)this + 5) = v6;
  int v12 = (_DWORD *)((char *)this + 16);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v23);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  int v13 = SetFilePointer(a2, 0, 0, 1);
  if (*((_DWORD *)this + 4) < 8u
    || (CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v23),
        *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5)),
        CPSDBaseComponent::ReadFile(a2, (char *)this + 24, 4uLL, &v23),
        *((_DWORD *)this + 6) = bswap32(*((_DWORD *)this + 6)),
        unsigned int v14 = *((_DWORD *)this + 4) - 8,
        v14 < 8))
  {
LABEL_13:
    uint64_t v19 = 1;
    int v20 = SetFilePointer(a2, 0, 0, 1);
    off_t v21 = (*v12 + v13);
    if (v20 != v21) {
      SetFilePointer(a2, v21, 0, 0);
    }
  }
  else
  {
    unsigned int v15 = v14 >> 3;
    std::vector<CPSDChannelBlendingInfo>::resize(v5, v14 >> 3);
    uint64_t v16 = 0;
    if (v15 <= 1) {
      unsigned int v17 = 1;
    }
    else {
      unsigned int v17 = v15;
    }
    uint64_t v18 = 24 * v17;
    while ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(*v5 + v16) + 16))(*v5 + v16, a2))
    {
      v16 += 24;
      if (v18 == v16) {
        goto LABEL_13;
      }
    }
    return 0;
  }
  return v19;
}

uint64_t CPSDLayerRecord::Save(CPSDLayerRecord *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 5));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 6));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 7));
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 16));
  uint64_t v4 = *((unsigned __int16 *)this + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 6) - *((void *)this + 5)) >> 3) == v4 && v4 != 0)
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      (*(void (**)(uint64_t, File *))(*(void *)(*((void *)this + 5) + v6) + 24))(*((void *)this + 5) + v6, a2);
      ++v7;
      v6 += 24;
    }
    while (v7 < *((unsigned __int16 *)this + 16));
  }
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 16));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 17));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 72));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 73));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 74));
  (*(void (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 75));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 19));
  CPSDLayerMaskData::Save((CPSDLayerRecord *)((char *)this + 80), a2);
  CPSDLayerBlendingRanges::Save((CPSDLayerRecord *)((char *)this + 144), a2);
  uint64_t result = (*(uint64_t (**)(File *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)this + 200, 4);
  for (uint64_t i = (CPSDResourceItem *)*((void *)this + 60); i; uint64_t i = (CPSDResourceItem *)*((void *)i + 6))
    uint64_t result = CPSDResourceItem::SaveItem(i, a2);
  return result;
}

uint64_t CPSDLayerRecord::SeekPast(CPSDLayerRecord *this, int a2)
{
  if (*((_WORD *)this + 16))
  {
    unint64_t v4 = 0;
    uint64_t v5 = 20;
    do
    {
      if (SetFilePointer(a2, *(unsigned int *)(*((void *)this + 5) + v5), 0, 1) == -1)
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      ++v4;
      v5 += 24;
    }
    while (v4 < *((unsigned __int16 *)this + 16));
  }
  return 1;
}

void sub_1A13410FC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *CPSDLayerRecord::GetUnicodeLayerName(CPSDLayerRecord *this, unsigned int *a2)
{
  if (result)
  {
    if (a2) {
      *a2 = *((_DWORD *)result + 14);
    }
    return (void *)result[8];
  }
  return result;
}

BOOL CPSDLayerRecord::GetTransparencyMask(CPSDLayerRecord *this)
{
  unint64_t v1 = *((unsigned __int16 *)this + 16);
  if (!*((_WORD *)this + 16)) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 5);
  if (*(__int16 *)(v2 + 16) == -1) {
    return 1;
  }
  uint64_t v3 = (__int16 *)(v2 + 40);
  uint64_t v4 = 1;
  do
  {
    unint64_t v5 = v4;
    if (v1 == v4) {
      break;
    }
    int v6 = *v3;
    v3 += 12;
    ++v4;
  }
  while (v6 != -1);
  return v5 < v1;
}

uint64_t CPSDImageLoad::DeAllocateChannelBuffers(CPSDImageLoad *this)
{
  if (*((void *)this + 10))
  {
    if (!*((_WORD *)this + 22)) {
      goto LABEL_6;
    }
    unint64_t v2 = 0;
    do
      free(*(void **)(*((void *)this + 10) + 8 * v2++));
    while (v2 < *((unsigned __int16 *)this + 22));
    if (*((void *)this + 10)) {
LABEL_6:
    }
      MEMORY[0x1A6230DD0]();
    *((void *)this + 10) = 0;
  }
  return 1;
}

uint64_t CPSDImageLoad::Initialize(CPSDImageLoad *this, int a2, int a3, __int16 a4, __int16 a5, __int16 a6, unsigned __int8 *a7)
{
  *((_DWORD *)this + 9) = a3;
  *((_DWORD *)this + 10) = a2;
  *((_WORD *)this + 22) = a4;
  *((_WORD *)this + 28) = a5;
  *((_WORD *)this + 29) = a6;
  *((unsigned char *)this + 32) = 1;
  *((void *)this + 8) = a7;
  return 1;
}

uint64_t CPSDImageLoad::CreatePlanarBitmap(CPSDImageLoad *this)
{
  unint64_t v2 = *((unsigned __int16 *)this + 28);
  unsigned int v3 = *((_DWORD *)this + 10);
  uint64_t v4 = (void *)*((void *)this + 12);
  if (v4)
  {
    free(v4);
    *((void *)this + 12) = 0;
  }
  if (*((_WORD *)this + 22))
  {
    unint64_t v5 = v2 >> 3;
    unint64_t v6 = (-(v3 * (v2 >> 3)) & 3) + v3 * (unint64_t)(v2 >> 3);
    unint64_t v7 = malloc_type_malloc(8 * v5 * (unint64_t)*((unsigned __int16 *)this + 22), 0xB4D708C9uLL);
    size_t v8 = v6 * *((unsigned int *)this + 9);
    *((void *)this + 6) = v8;
    if (*((unsigned __int16 *)this + 22) >= 4u && *((_WORD *)this + 29) == 3)
    {
      if (*((unsigned char *)this + 104))
      {
        uint64_t v9 = *((void *)this + 10);
        unsigned int v10 = malloc_type_malloc(v8, 0x8CBE3C66uLL);
        *unint64_t v7 = v10;
        memcpy(v10, *(const void **)(v9 + 24), *((void *)this + 6));
        unsigned int v11 = *((unsigned __int16 *)this + 22);
        if (*((_WORD *)this + 22))
        {
          uint64_t v12 = 0;
          uint64_t v13 = *((void *)this + 10);
          unsigned int v14 = v7 + 1;
          do
          {
            if (v12 != 3)
            {
              unsigned int v15 = malloc_type_malloc(*((void *)this + 6), 0x9675BA3EuLL);
              *v14++ = v15;
              memcpy(v15, *(const void **)(v13 + 8 * v12), *((void *)this + 6));
              unsigned int v11 = *((unsigned __int16 *)this + 22);
            }
            ++v12;
          }
          while (v12 < v11);
        }
        goto LABEL_16;
      }
    }
    else if (!*((_WORD *)this + 22))
    {
LABEL_16:
      *((void *)this + 12) = v7;
      return 1;
    }
    unint64_t v16 = 0;
    do
    {
      unsigned int v17 = malloc_type_malloc(*((void *)this + 6), 0xE3B25454uLL);
      v7[v16] = v17;
      memcpy(v17, *(const void **)(*((void *)this + 10) + 8 * v16++), *((void *)this + 6));
    }
    while (v16 < *((unsigned __int16 *)this + 22));
    goto LABEL_16;
  }
  return 1;
}

uint64_t CPSDImageLoad::AllocateChannelBuffers(CPSDImageLoad *this, int a2)
{
  *((void *)this + 10) = operator new[]();
  if (*((_WORD *)this + 22))
  {
    uint64_t v4 = 0;
    int v5 = (-a2 & 3) + a2;
    uint64_t v6 = 8 * *((unsigned __int16 *)this + 22);
    do
    {
      *(void *)(*((void *)this + 10) + v4) = 0;
      v4 += 8;
    }
    while (v6 != v4);
    unint64_t v7 = 0;
    do
    {
      *(void *)(*((void *)this + 10) + 8 * v7) = malloc_type_malloc((*((_DWORD *)this + 9) * v5), 0x9407C846uLL);
      if (!*(void *)(*((void *)this + 10) + 8 * v7))
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395909);
      }
      ++v7;
    }
    while (v7 < *((unsigned __int16 *)this + 22));
  }
  return 1;
}

void sub_1A134149C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDImageLoad::FillLayerImageChannelBuffers(CPSDImageLoad *this, unsigned int a2)
{
  if (!*((_WORD *)this + 22)) {
    return 1;
  }
  unint64_t v4 = 0;
  unsigned int v5 = *((_DWORD *)this + 7);
  for (uint64_t i = 20; ; i += 24)
  {
    unsigned int v7 = *(_DWORD *)(*((void *)this + 9) + i);
    if (v7 < 5)
    {
      bzero(*(void **)(*((void *)this + 10) + 8 * v4), *((_DWORD *)this + 9) * a2);
      goto LABEL_9;
    }
    int v8 = *((_DWORD *)this + 9) * a2;
    if (*((_WORD *)this + 44) == 1)
    {
      ChannelByteCounts = (unsigned __int16 *)CPSDImageLoad::GetChannelByteCounts(this);
      if (CPSDImageLoad::UncompressChannelImageData(this, ChannelByteCounts, *(unsigned __int8 **)(*((void *)this + 10) + 8 * v4), a2) != v8)
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      goto LABEL_9;
    }
    if (*((_WORD *)this + 44)) {
      break;
    }
    memcpy(*(void **)(*((void *)this + 10) + 8 * v4), (const void *)(*((void *)this + 2) + v5), *((_DWORD *)this + 9) * a2);
    *((_DWORD *)this + 7) += v8;
LABEL_9:
    unsigned int v10 = *((_DWORD *)this + 7);
    if (v10 != v7 + v5)
    {
      *((_DWORD *)this + 7) = v7 + v5;
      unsigned int v10 = v7 + v5;
    }
    ++v4;
    unsigned int v5 = v10;
    if (v4 >= *((unsigned __int16 *)this + 22)) {
      return 1;
    }
  }
  return 0;
}

void sub_1A1341604(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t CPSDImageLoad::FillCompositeImageChannelBuffers(CPSDImageLoad *this, unsigned int a2)
{
  size_t v3 = *((_DWORD *)this + 9) * a2;
  if (*((_WORD *)this + 44) == 1)
  {
    unsigned int v7 = (void *)operator new[]();
    int v8 = v7;
    if (*((_WORD *)this + 22))
    {
      bzero(v7, 8 * *((unsigned __int16 *)this + 22));
      unint64_t v9 = 0;
      do
        v8[v9++] = CPSDImageLoad::GetChannelByteCounts(this);
      while (v9 < *((unsigned __int16 *)this + 22));
      if (*((_WORD *)this + 22))
      {
        unint64_t v10 = 0;
        do
        {
          if (CPSDImageLoad::UncompressChannelImageData(this, (unsigned __int16 *)v8[v10], *(unsigned __int8 **)(*((void *)this + 10) + 8 * v10), a2) != v3)
          {
            exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
            CStdException::CStdException(exception, 3238395925);
          }
          ++v10;
        }
        while (v10 < *((unsigned __int16 *)this + 22));
      }
    }
    MEMORY[0x1A6230DD0](v8, 0x10C80436913F5);
    return 1;
  }
  if (!*((_WORD *)this + 44))
  {
    if (*((_WORD *)this + 22))
    {
      unint64_t v4 = 0;
      unsigned int v5 = *((_DWORD *)this + 7);
      do
      {
        memcpy(*(void **)(*((void *)this + 10) + 8 * v4), (const void *)(*((void *)this + 2) + v5), v3);
        unsigned int v5 = *((_DWORD *)this + 7) + v3;
        *((_DWORD *)this + 7) = v5;
        ++v4;
      }
      while (v4 < *((unsigned __int16 *)this + 22));
    }
    return 1;
  }
  return 0;
}

void sub_1A134179C()
{
}

void sub_1A1341848(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void CPSDFile::CompositeImageData(void **this)
{
  if (*((unsigned char *)this + 392))
  {
    bzero(this[2], 3 * *((_DWORD *)this + 37) * *((_DWORD *)this + 36) * (*((unsigned __int16 *)this + 76) >> 3));
    int64_t v3 = (unsigned char *)this[35] - (unsigned char *)this[34];
    if (v3)
    {
      uint64_t v4 = 0;
      unint64_t v5 = v3 / 488;
      if (v5 <= 1) {
        uint64_t v6 = 1;
      }
      else {
        uint64_t v6 = v5;
      }
      do
      {
        int v7 = *((unsigned __int16 *)this + 44);
        if (*((_WORD *)this + 44))
        {
          printf("Error - Can't generate composite data, unimplemented compression mode.");
        }
        else
        {
          uint64_t v8 = *((void *)this[37] + v4);
          unint64_t v9 = *(unsigned __int8 **)(*(void *)(v8 + 32) + 40);
          for (uint64_t i = 1; i != 4; ++i)
          {
            uint64_t v11 = *(void *)(v8 + 32) + 56 * i;
            uint64_t v12 = *(unsigned int *)(v11 + 48);
            if (v12)
            {
              uint64_t v13 = *(unsigned __int8 **)(v11 + 40);
              int v14 = v12 * v7;
              unsigned int v15 = v9;
              do
              {
                unint64_t v16 = this[2];
                unsigned int v17 = *v13++;
                float v18 = (float)v17;
                unsigned int v19 = *v15++;
                float v20 = (double)v19 / 255.0;
                LOBYTE(v2) = v16[v14];
                float v2 = (float)LODWORD(v2);
                v16[v14++] = (int)(float)((float)((float)(1.0 - v20) * v2) + (float)(v18 * v20));
                --v12;
              }
              while (v12);
            }
            ++v7;
          }
        }
        ++v4;
      }
      while (v4 != v6);
    }
    *((unsigned char *)this + 392) = 0;
  }
}

void *CPSDImageLoad::GetChannelByteCounts(CPSDImageLoad *this)
{
  float v2 = (void *)operator new[]();
  uint64_t v3 = *((unsigned int *)this + 9);
  uint64_t v4 = *((unsigned int *)this + 7);
  memcpy(v2, (const void *)(*((void *)this + 2) + v4), 2 * (v3 & 0x7FFF));
  *((_DWORD *)this + 7) = v4 + 2 * (v3 & 0x7FFF);
  if (v3)
  {
    unint64_t v5 = v2;
    do
    {
      _WORD *v5 = bswap32((unsigned __int16)*v5) >> 16;
      ++v5;
      --v3;
    }
    while (v3);
  }
  return v2;
}

uint64_t CPSDImageLoad::UncompressChannelImageData(CPSDImageLoad *this, unsigned __int16 *a2, unsigned __int8 *__b, unsigned int a4)
{
  if (!a2) {
    CPSDImageLoad::UncompressChannelImageData();
  }
  uint64_t v4 = __b;
  if (!__b) {
    CPSDImageLoad::UncompressChannelImageData();
  }
  int v8 = *((_DWORD *)this + 9);
  if (v8)
  {
    unint64_t v9 = 0;
    int v10 = v8 * a4;
    do
    {
      if (CPSDImageLoad::UncompressChannelScanLine(this, v4, a2[v9]) != a4)
      {
        exception = (CStdException *)__cxa_allocate_exception(0x10uLL);
        CStdException::CStdException(exception, 3238395925);
      }
      v10 -= a4;
      v4 += a4;
      ++v9;
    }
    while (v9 < *((unsigned int *)this + 9));
  }
  else
  {
    int v10 = 0;
  }
  MEMORY[0x1A6230DD0](a2, 0x1000C80BDFB0063);
  return *((_DWORD *)this + 9) * a4 - v10;
}

void sub_1A1341B54()
{
}

void sub_1A1341BD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CPSDImageLoad::UncompressChannelScanLine(CPSDImageLoad *this, unsigned __int8 *__b, int a3)
{
  if (a3)
  {
    unsigned __int16 v5 = 0;
    while (1)
    {
      uint64_t v6 = *((void *)this + 2);
      uint64_t v7 = *((unsigned int *)this + 7);
      unsigned int v8 = v7 + 1;
      *((_DWORD *)this + 7) = v7 + 1;
      int v9 = *(char *)(v6 + v7);
      int v10 = a3 - 1;
      if ((v9 & 0x80000000) == 0) {
        break;
      }
      if (v9 != -128)
      {
        __int16 v12 = 1 - v9;
        *((_DWORD *)this + 7) = v7 + 2;
        int v10 = a3 - 2;
        size_t v11 = (unsigned __int16)(1 - v9);
        memset(__b, *(unsigned __int8 *)(v6 + v8), v11);
        goto LABEL_7;
      }
LABEL_8:
      a3 = v10;
      if (!(_WORD)v10) {
        return v5;
      }
    }
    size_t v11 = *(char *)(v6 + v7) + 1;
    memcpy(__b, (const void *)(v6 + v8), v11);
    *((_DWORD *)this + 7) += v11;
    v10 -= v11;
    __int16 v12 = v11;
LABEL_7:
    v5 += v12;
    __b += v11;
    goto LABEL_8;
  }
  return 0;
}

uint64_t CPSDChannelImage::DeAllocateChannelBuffers(CPSDChannelImage *this)
{
  if (*((void *)this + 6))
  {
    if (!*((_WORD *)this + 12)) {
      goto LABEL_6;
    }
    unint64_t v2 = 0;
    do
      free(*(void **)(*((void *)this + 6) + 8 * v2++));
    while (v2 < *((unsigned __int16 *)this + 12));
    if (*((void *)this + 6)) {
LABEL_6:
    }
      MEMORY[0x1A6230DD0]();
    *((void *)this + 6) = 0;
  }
  return 1;
}

uint64_t CPSDChannelImage::AllocateChannelBuffers(CPSDChannelImage *this)
{
  unint64_t v2 = (void *)operator new[]();
  *((void *)this + 6) = v2;
  uint64_t v3 = *((unsigned __int16 *)this + 12);
  bzero(v2, 8 * v3);
  if (v3)
  {
    unint64_t v4 = 0;
    do
    {
      unsigned int v5 = *((_DWORD *)this + 3) * *((_DWORD *)this + 5);
      if (v5 <= 4) {
        size_t v6 = 4;
      }
      else {
        size_t v6 = v5;
      }
      *(void *)(*((void *)this + 6) + 8 * v4++) = malloc_type_calloc(v6, 1uLL, 0xAB40E959uLL);
    }
    while (v4 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

CPSDMeshedARGBStream *CPSDChannelImage::CreateChannelStream(CPSDChannelImage *this)
{
  CPSDChannelImage::DeAllocateChannelBuffers(this);
  (*(void (**)(CPSDChannelImage *))(*(void *)this + 56))(this);
  (*(void (**)(CPSDChannelImage *))(*(void *)this + 64))(this);
  unint64_t v2 = (CPSDMeshedARGBStream *)operator new();
  CPSDMeshedARGBStream::CPSDMeshedARGBStream(v2, this);
  return v2;
}

void sub_1A1341E84(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C4035EE323ALL);
  _Unwind_Resume(a1);
}

CPSDAlphaChannelStream *CPSDChannelImage::CreateAlphaStream(CPSDChannelImage *this, unsigned int a2)
{
  if (!*((void *)this + 6))
  {
    CPSDChannelImage::DeAllocateChannelBuffers(this);
    (*(void (**)(CPSDChannelImage *))(*(void *)this + 56))(this);
    (*(void (**)(CPSDChannelImage *))(*(void *)this + 64))(this);
  }
  unint64_t v4 = (CPSDAlphaChannelStream *)operator new();
  CPSDAlphaChannelStream::CPSDAlphaChannelStream(v4, this, a2);
  return v4;
}

void sub_1A1341F60(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C4068A33497);
  _Unwind_Resume(a1);
}

void CPSDLayerImage::CPSDLayerImage(CPSDLayerImage *this, CPSDLayerRecord *a2, CPSDLayerChannelGroup *a3, __int16 a4, int a5, int a6, unsigned __int8 *a7)
{
  int v7 = *((_DWORD *)a2 + 6);
  int v8 = *((_DWORD *)a2 + 4);
  unint64_t v9 = *((unsigned __int16 *)a2 + 16);
  if (*((_WORD *)a2 + 16))
  {
    uint64_t v10 = *((void *)a2 + 5);
    if (*(__int16 *)(v10 + 16) == -1)
    {
      BOOL v14 = 1;
    }
    else
    {
      unint64_t v11 = 0;
      __int16 v12 = (__int16 *)(v10 + 40);
      while (v9 - 1 != v11)
      {
        int v13 = *v12;
        v12 += 12;
        ++v11;
        if (v13 == -1) {
          goto LABEL_10;
        }
      }
      unint64_t v11 = *((unsigned __int16 *)a2 + 16);
LABEL_10:
      BOOL v14 = v11 < v9;
    }
  }
  else
  {
    BOOL v14 = 0;
  }
  int v15 = *((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 2) = v15;
  *((_DWORD *)this + 3) = v7 - v8;
  *((_WORD *)this + 9) = a5;
  *((_DWORD *)this + 5) = (v15 * a5) >> 3;
  *((_WORD *)this + 12) = v9;
  *((_WORD *)this + 13) = a4;
  *((unsigned char *)this + 28) = v14;
  *((_DWORD *)this + 8) = a6;
  *((void *)this + 5) = a7;
  *((void *)this + 6) = 0;
  *(void *)this = &unk_1EF485F88;
  *((void *)this + 7) = a2;
  *((void *)this + 8) = a3;
  __int16 v16 = 0;
  if (v9)
  {
    unsigned int v17 = (__int16 *)(*((void *)a2 + 5) + 16);
    unint64_t v18 = v9;
    do
    {
      int v19 = *v17;
      v17 += 12;
      if (v19 < -1) {
        ++v16;
      }
      --v18;
    }
    while (v18);
  }
  *((_WORD *)this + 8) = (v9 - v16) * a5;
}

uint64_t CPSDLayerImage::GetComponentChannels(CPSDLayerImage *this)
{
  if (*((_WORD *)this + 12))
  {
    __int16 v1 = 0;
    unint64_t v2 = (__int16 *)(*(void *)(*((void *)this + 7) + 40) + 16);
    uint64_t v3 = *((unsigned __int16 *)this + 12);
    do
    {
      int v4 = *v2;
      v2 += 12;
      if (v4 < -1) {
        ++v1;
      }
      --v3;
    }
    while (v3);
  }
  else
  {
    __int16 v1 = 0;
  }
  return (unsigned __int16)(*((_WORD *)this + 12) - v1);
}

uint64_t CPSDLayerImage::AllocateChannelBuffers(CPSDLayerImage *this)
{
  unint64_t v2 = (void *)operator new[]();
  *((void *)this + 6) = v2;
  uint64_t v3 = *((unsigned __int16 *)this + 12);
  bzero(v2, 8 * v3);
  if (v3)
  {
    unint64_t v4 = 0;
    do
    {
      unsigned int v5 = ((*(unsigned int (**)(CPSDLayerImage *, unint64_t))(*(void *)this + 40))(this, v4)
          * *((unsigned __int16 *)this + 9)) >> 3;
      if ((*(unsigned int (**)(CPSDLayerImage *, unint64_t))(*(void *)this + 48))(this, v4) * v5 < 5) {
        unsigned int v6 = 4;
      }
      else {
        unsigned int v6 = (*(uint64_t (**)(CPSDLayerImage *, unint64_t))(*(void *)this + 48))(this, v4) * v5;
      }
      *(void *)(*((void *)this + 6) + 8 * v4++) = malloc_type_calloc(v6, 1uLL, 0xEA0AD297uLL);
    }
    while (v4 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

uint64_t CPSDLayerImage::FillChannelBuffers(CPSDLayerImage *this)
{
  if (*((_WORD *)this + 12))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      unsigned int v4 = ((*(unsigned int (**)(CPSDLayerImage *, unint64_t))(*(void *)this + 40))(this, v3)
          * *((unsigned __int16 *)this + 9)) >> 3;
      unsigned int v5 = (CPSDChannelData *)(*(void *)(*((void *)this + 8) + 32) + v2);
      unsigned int v6 = *(unsigned __int8 **)(*((void *)this + 6) + 8 * v3);
      unsigned int v7 = (*(uint64_t (**)(CPSDLayerImage *, unint64_t))(*(void *)this + 48))(this, v3);
      CPSDChannelData::UnpackImageInPosition(v5, v6, v4, v7, 0, 0, v4, v7, 0, 0);
      ++v3;
      v2 += 56;
    }
    while (v3 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

uint64_t CPSDLayerImage::Dump(CPSDLayerImage *this, __sFILE *a2)
{
  return fprintf(a2, "{\tLayerImage:\t{A=%d, BPS=%d, BPP=%d} {size: %d x %d x %d} = \t[%d] bytes }\n", *((unsigned __int8 *)this + 28), *((unsigned __int16 *)this + 9), *((unsigned __int16 *)this + 8), *((_DWORD *)this + 5), *((_DWORD *)this + 3), *((unsigned __int16 *)this + 12), *((_DWORD *)this + 3) * *((_DWORD *)this + 5) * *((unsigned __int16 *)this + 12));
}

uint64_t CPSDLayerImage::GetChannelImageWidth(CPSDLayerImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 7);
  int v3 = *(unsigned __int16 *)(*(void *)(v2 + 40) + 24 * a2 + 16);
  if (v3 == 65533)
  {
    int v4 = *(_DWORD *)(v2 + 132);
    int v5 = *(_DWORD *)(v2 + 124);
  }
  else if (v3 == 65534)
  {
    int v4 = *(_DWORD *)(v2 + 112);
    int v5 = *(_DWORD *)(v2 + 104);
  }
  else
  {
    int v4 = *(_DWORD *)(v2 + 28);
    int v5 = *(_DWORD *)(v2 + 20);
  }
  return (v4 - v5);
}

uint64_t CPSDLayerImage::GetChannelImageHeight(CPSDLayerImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 7);
  int v3 = *(unsigned __int16 *)(*(void *)(v2 + 40) + 24 * a2 + 16);
  if (v3 == 65533)
  {
    int v4 = *(_DWORD *)(v2 + 128);
    int v5 = *(_DWORD *)(v2 + 120);
  }
  else if (v3 == 65534)
  {
    int v4 = *(_DWORD *)(v2 + 108);
    int v5 = *(_DWORD *)(v2 + 100);
  }
  else
  {
    int v4 = *(_DWORD *)(v2 + 24);
    int v5 = *(_DWORD *)(v2 + 16);
  }
  return (v4 - v5);
}

void CPSDLayerSliceImage::CPSDLayerSliceImage(CPSDLayerSliceImage *this, CPSDLayerRecord *a2, CPSDLayerChannelGroup *a3, PSDRect *a4, __int16 a5, int a6, int a7, unsigned __int8 *a8)
{
  int v8 = *((_DWORD *)a4 + 2);
  int v9 = *(_DWORD *)a4;
  int v10 = *((_DWORD *)a4 + 1);
  unint64_t v11 = *((unsigned __int16 *)a2 + 16);
  if (*((_WORD *)a2 + 16))
  {
    uint64_t v12 = *((void *)a2 + 5);
    if (*(__int16 *)(v12 + 16) == -1)
    {
      BOOL v16 = 1;
    }
    else
    {
      unint64_t v13 = 0;
      BOOL v14 = (__int16 *)(v12 + 40);
      while (v11 - 1 != v13)
      {
        int v15 = *v14;
        v14 += 12;
        ++v13;
        if (v15 == -1) {
          goto LABEL_10;
        }
      }
      unint64_t v13 = *((unsigned __int16 *)a2 + 16);
LABEL_10:
      BOOL v16 = v13 < v11;
    }
  }
  else
  {
    BOOL v16 = 0;
  }
  int v17 = *((_DWORD *)a4 + 3) - v10;
  *((_DWORD *)this + 2) = v17;
  *((_DWORD *)this + 3) = v8 - v9;
  *((_WORD *)this + 9) = a6;
  unsigned int v18 = (v17 * a6) >> 3;
  *((_DWORD *)this + 5) = v18;
  *((_WORD *)this + 12) = v11;
  *((_WORD *)this + 13) = a5;
  *((unsigned char *)this + 28) = v16;
  *((_DWORD *)this + 8) = a7;
  *((void *)this + 5) = a8;
  *((void *)this + 6) = 0;
  *(void *)this = &unk_1EF4865F8;
  *((void *)this + 7) = a2;
  *((void *)this + 8) = a3;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = v18;
  __int16 v19 = 0;
  if (v11)
  {
    float v20 = (__int16 *)(*((void *)a2 + 5) + 16);
    unint64_t v21 = v11;
    do
    {
      int v22 = *v20;
      v20 += 12;
      if (v22 < -1) {
        ++v19;
      }
      --v21;
    }
    while (v21);
  }
  *((_WORD *)this + 8) = (v11 - v19) * a6;
  int v24 = *((_DWORD *)a2 + 4);
  int v23 = *((_DWORD *)a2 + 5);
  int v26 = *((_DWORD *)a2 + 6);
  int v25 = *((_DWORD *)a2 + 7);
  int v27 = v10 & ~(v10 >> 31);
  int v28 = v9 & ~(v9 >> 31);
  *(_DWORD *)a4 = v28;
  *((_DWORD *)a4 + 1) = v27;
  int v29 = v28 - v24;
  if (v28 > v24) {
    int v24 = v28;
  }
  *((_DWORD *)this + 18) = (v27 - v23) & ~((v27 - v23) >> 31);
  *((_DWORD *)this + 19) = v29 & ~(v29 >> 31);
  if (v27 > v23) {
    int v23 = v27;
  }
  if (*((_DWORD *)a4 + 3) < v25) {
    int v25 = *((_DWORD *)a4 + 3);
  }
  if (v23 > v25) {
    int v25 = v23;
  }
  if (*((_DWORD *)a4 + 2) < v26) {
    int v26 = *((_DWORD *)a4 + 2);
  }
  if (v24 > v26) {
    int v26 = v24;
  }
  *((_DWORD *)this + 20) = v23 - v27;
  *((_DWORD *)this + 21) = v24 - v28;
  *((_DWORD *)this + 22) = ((v25 - v23) * a6) >> 3;
  *((_DWORD *)this + 23) = v26 - v24;
}

uint64_t CPSDLayerSliceImage::GetComponentChannels(CPSDLayerSliceImage *this)
{
  if (*((_WORD *)this + 12))
  {
    __int16 v1 = 0;
    uint64_t v2 = (__int16 *)(*(void *)(*((void *)this + 7) + 40) + 16);
    uint64_t v3 = *((unsigned __int16 *)this + 12);
    do
    {
      int v4 = *v2;
      v2 += 12;
      if (v4 < -1) {
        ++v1;
      }
      --v3;
    }
    while (v3);
  }
  else
  {
    __int16 v1 = 0;
  }
  return (unsigned __int16)(*((_WORD *)this + 12) - v1);
}

uint64_t CPSDLayerSliceImage::FillChannelBuffers(CPSDLayerSliceImage *this)
{
  if (*((_WORD *)this + 12))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      CPSDChannelData::UnpackImageInPosition((CPSDChannelData *)(*(void *)(*((void *)this + 8) + 32) + v2), *(unsigned __int8 **)(*((void *)this + 6) + 8 * v3++), *((_DWORD *)this + 5), *((_DWORD *)this + 3), *((_DWORD *)this + 18), *((_DWORD *)this + 19), *((_DWORD *)this + 22), *((_DWORD *)this + 23), *((_DWORD *)this + 20), *((_DWORD *)this + 21));
      v2 += 56;
    }
    while (v3 < *((unsigned __int16 *)this + 12));
  }
  return 1;
}

uint64_t CPSDLayerSliceImage::IsEmptyImage(CPSDLayerSliceImage *this)
{
  return *(unsigned __int8 *)(*(void *)(*((void *)this + 8) + 32) + 52);
}

void CPSDCompositeImage::CPSDCompositeImage(CPSDCompositeImage *this, CPSDHeader *a2, unsigned __int8 **a3, int a4, int a5, unsigned __int8 *a6)
{
  int v7 = *((_DWORD *)a2 + 8);
  int v6 = *((_DWORD *)a2 + 9);
  unsigned int v8 = *((unsigned __int16 *)a2 + 21);
  unsigned int v9 = *((unsigned __int16 *)a2 + 14);
  int v10 = *((unsigned __int16 *)a2 + 20);
  *((_DWORD *)this + 2) = v6;
  *((_DWORD *)this + 3) = v7;
  *((_WORD *)this + 9) = v10;
  *((_DWORD *)this + 5) = (v6 * v10) >> 3;
  *((_WORD *)this + 12) = v9;
  *((_WORD *)this + 13) = v8;
  *((unsigned char *)this + 28) = a4;
  *((_DWORD *)this + 8) = a5;
  *((void *)this + 5) = a6;
  *((void *)this + 6) = a3;
  *(void *)this = &unk_1EF486418;
  if (v9 >= v8) {
    __int16 v11 = v8;
  }
  else {
    __int16 v11 = v9;
  }
  if (v8 < v9) {
    __int16 v12 = v8 + 1;
  }
  else {
    __int16 v12 = v9;
  }
  if (a4) {
    __int16 v11 = v12;
  }
  if (((1 << v8) & 0x1A) != 0) {
    __int16 v13 = v11;
  }
  else {
    __int16 v13 = v9;
  }
  if (v8 > 4) {
    __int16 v13 = v9;
  }
  *((_WORD *)this + 8) = v13 * v10;
}

uint64_t CPSDCompositeImage::GetComponentChannels(CPSDCompositeImage *this)
{
  unsigned int v1 = *((unsigned __int16 *)this + 13);
  if (v1 > 4 || ((1 << v1) & 0x1A) == 0)
  {
    return *((unsigned __int16 *)this + 12);
  }
  else
  {
    unsigned int v3 = *((unsigned __int16 *)this + 12);
    if (v3 >= v1) {
      unsigned __int16 v4 = *((_WORD *)this + 13);
    }
    else {
      unsigned __int16 v4 = *((_WORD *)this + 12);
    }
    if (v1 < v3) {
      unsigned __int16 v5 = v1 + 1;
    }
    else {
      unsigned __int16 v5 = *((_WORD *)this + 12);
    }
    if (!*((unsigned char *)this + 28)) {
      return v4;
    }
  }
  return v5;
}

CPSDMeshedARGBStream *CPSDCompositeImage::CreateChannelStream(CPSDCompositeImage *this)
{
  uint64_t v2 = (CPSDMeshedARGBStream *)operator new();
  CPSDMeshedARGBStream::CPSDMeshedARGBStream(v2, this);
  return v2;
}

void sub_1A1342760(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C4035EE323ALL);
  _Unwind_Resume(a1);
}

uint64_t CPSDChannelLengthInfo::Load(CPSDChannelLengthInfo *this, int a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 2uLL, &v5);
  *((_WORD *)this + 8) = bswap32(*((unsigned __int16 *)this + 8)) >> 16;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v5);
  *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
  return 1;
}

uint64_t CPSDChannelLengthInfo::Save(CPSDChannelLengthInfo *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 72))(a2, *((unsigned __int16 *)this + 8));
  uint64_t v4 = *((unsigned int *)this + 5);
  int v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80);
  return v5(a2, v4);
}

uint64_t CPSDLayerMaskData::GetMaskCount(CPSDLayerMaskData *this)
{
  int v1 = *((_DWORD *)this + 4);
  if (v1 == 36) {
    return 2;
  }
  else {
    return v1 == 20;
  }
}

uint64_t CPSDVectorMaskData::Load(CPSDVectorMaskData *this, uint64_t a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 104, 4uLL, &v5);
  *((_DWORD *)this + 26) = bswap32(*((_DWORD *)this + 26));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 108, 4uLL, &v5);
  *((_DWORD *)this + 27) = bswap32(*((_DWORD *)this + 27));
  *((_DWORD *)this + 18) = *((_DWORD *)this + 4) & ~(*((int *)this + 4) >> 31);
  CPSDPathsResourceItem::Load((CPSDVectorMaskData *)((char *)this + 56), a2);
  return 1;
}

uint64_t CPSDVectorMaskData::Save(CPSDVectorMaskData *this, File *a2)
{
  CPSDAdditionalLayerInfoItem::Save(this, a2);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 26));
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 27));
  for (uint64_t i = (void *)*((void *)this + 10); i; uint64_t i = (void *)i[3])
    uint64_t result = (*(uint64_t (**)(void *, File *))(*i + 24))(i, a2);
  return result;
}

size_t CPSDVectorMaskData::Dump(CPSDVectorMaskData *this, __sFILE *a2)
{
  fprintf(a2, "{ VectorMaskData: version=%d", *((_DWORD *)this + 26));
  int v4 = *((_DWORD *)this + 27);
  if (v4) {
    int v5 = "YES";
  }
  else {
    int v5 = "NO";
  }
  if ((v4 & 2) != 0) {
    int v6 = "NO";
  }
  else {
    int v6 = "YES";
  }
  if ((v4 & 3) != 0) {
    int v7 = "NO";
  }
  else {
    int v7 = "YES";
  }
  fprintf(a2, "  <isInverted: %s >  <isLinked: %s >  <isEnabled: %s >\n", v5, v6, v7);
  CPSDPathsResourceItem::Dump((CPSDVectorMaskData *)((char *)this + 56), a2, 1u);
  return fwrite("} // End VectorMaskData\n", 0x18uLL, 1uLL, a2);
}

uint64_t *std::vector<CPSDChannelBlendingInfo>::resize(uint64_t *result, unint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *result) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    return (uint64_t *)std::vector<CPSDChannelBlendingInfo>::__append(result, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *result + 24 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = v3 - 24;
      unsigned int v9 = (uint64_t (***)(void))(v3 - 24);
      int v10 = (uint64_t (***)(void))(v3 - 24);
      do
      {
        __int16 v11 = *v10;
        v10 -= 3;
        uint64_t result = (uint64_t *)(*v11)(v9);
        v8 -= 24;
        BOOL v12 = v9 == (uint64_t (***)(void))v7;
        unsigned int v9 = v10;
      }
      while (!v12);
    }
    v2[1] = v7;
  }
  return result;
}

uint64_t CPSDChannelBlendingInfo::Load(CPSDChannelBlendingInfo *this, int a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 16, 4uLL, &v5);
  *((_DWORD *)this + 4) = bswap32(*((_DWORD *)this + 4));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 20, 4uLL, &v5);
  *((_DWORD *)this + 5) = bswap32(*((_DWORD *)this + 5));
  return 1;
}

uint64_t CPSDChannelBlendingInfo::Save(CPSDChannelBlendingInfo *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 4));
  uint64_t v4 = *((unsigned int *)this + 5);
  int v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80);
  return v5(a2, v4);
}

uint64_t CPSDActionBaseComponent::Dump(CPSDActionBaseComponent *this, __sFILE *a2)
{
  return fputs("Dump: ActionBaseComponent\n", a2);
}

{
  return (*(uint64_t (**)(CPSDActionBaseComponent *, __sFILE *, void))(*(void *)this + 48))(this, a2, 0);
}

void CPSDOSTypeList::~CPSDOSTypeList(CPSDOSTypeList *this)
{
  *(void *)this = &unk_1EF485FE8;
  uint64_t v4 = (char *)this + 64;
  uint64_t v2 = (void *)*((void *)this + 8);
  uint64_t v3 = (void *)*((void *)v4 + 1);
  if (v3 == v2)
  {
    uint64_t v2 = v3;
  }
  else
  {
    uint64_t v5 = 0;
    int v6 = 0;
    do
    {
      uint64_t v7 = v2[v5];
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        uint64_t v2 = (void *)*((void *)this + 8);
        uint64_t v3 = (void *)*((void *)this + 9);
      }
      uint64_t v5 = (unsigned __int16)++v6;
    }
    while ((unsigned __int16)v6 < (unint64_t)(v3 - v2));
  }
  *((_DWORD *)this + 14) = 0;
  if (v2)
  {
    *((void *)this + 9) = v2;
    operator delete(v2);
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  uint64_t vars8;

  CPSDOSTypeList::~CPSDOSTypeList(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDOSTypeList::Load(CPSDOSTypeList *this, uint64_t a2)
{
  int v20 = 0;
  uint64_t v4 = (unsigned int *)((char *)this + 56);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v20);
  unint64_t v5 = bswap32(*((_DWORD *)this + 14));
  *((_DWORD *)this + 14) = v5;
  int v6 = (void *)((char *)this + 64);
  std::vector<CPSDLayerChannelGroup *>::resize((uint64_t)this + 64, v5);
  if (*((_DWORD *)this + 14))
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char *)this + 60;
    do
    {
      CPSDBaseComponent::ReadFile(a2, v8, 4uLL, &v20);
      uint64_t v15 = 0;
      int v16 = bswap32(*(_DWORD *)v8);
      *(_DWORD *)uint64_t v8 = v16;
      if (v16 > 1651470187)
      {
        if (v16 > 1701737836)
        {
          if (v16 == 1701737837)
          {
            uint64_t v15 = operator new();
            *(_DWORD *)(v15 + 16) = 0;
            *(_OWORD *)(v15 + 24) = 0u;
            *(_OWORD *)(v15 + 40) = 0u;
            *(void *)uint64_t v15 = &unk_1EF486848;
            *(void *)(v15 + 56) = 0;
            *(_DWORD *)(v15 + 64) = 0;
            *(_DWORD *)(v15 + 80) = 0;
            *(void *)(v15 + 88) = 0;
          }
          else if (v16 == 1819242087)
          {
            uint64_t v15 = operator new();
            *(_DWORD *)(v15 + 16) = 0;
            *(_OWORD *)(v15 + 24) = 0u;
            *(_OWORD *)(v15 + 40) = 0u;
            *(void *)uint64_t v15 = &unk_1EF486388;
            *(_DWORD *)(v15 + 56) = 0;
          }
        }
        else if (v16 == 1651470188)
        {
          uint64_t v15 = operator new();
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(void *)uint64_t v15 = &unk_1EF486340;
          *(unsigned char *)(v15 + 56) = 0;
        }
        else if (v16 == 1685026146)
        {
          uint64_t v15 = operator new();
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(void *)uint64_t v15 = &unk_1EF486170;
          *(void *)(v15 + 56) = 0;
        }
      }
      else if (v16 > 1433302085)
      {
        if (v16 == 1433302086)
        {
          uint64_t v15 = operator new();
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(void *)uint64_t v15 = &unk_1EF486658;
          *(_DWORD *)(v15 + 56) = 0;
          *(void *)(v15 + 64) = 0;
        }
        else if (v16 == 1449938035)
        {
          uint64_t v15 = operator new();
          *(_DWORD *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(_OWORD *)(v15 + 40) = 0u;
          *(void *)uint64_t v15 = &unk_1EF485FE8;
          *(_OWORD *)(v15 + 56) = 0u;
          *(_OWORD *)(v15 + 72) = 0u;
        }
      }
      else if (v16 == 1331849827)
      {
        uint64_t v15 = operator new();
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v15);
      }
      else if (v16 == 1413830740)
      {
        uint64_t v15 = operator new();
        CPSDOSTypeText::CPSDOSTypeText((CPSDOSTypeText *)v15);
      }
      *(void *)(*v6 + 8 * v7) = v15;
      uint64_t v17 = *(void *)(*v6 + 8 * v7);
      if (v17)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 16))(v17, a2);
      }
      else
      {
        unsigned int v19 = bswap32(*(_DWORD *)v8);
        _CUILog(1, (uint64_t)"Error parsing gradient fill info: The OSType \"%.4s\" cannot be parsed.\n", v9, v10, v11, v12, v13, v14, (uint64_t)&v19);
      }
      ++v7;
    }
    while (v7 < *v4);
  }
  return 1;
}

void sub_1A1343228(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C4022C5DBF1);
  _Unwind_Resume(a1);
}

uint64_t CPSDOSTypeList::Save(CPSDOSTypeList *this, File *a2)
{
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 14))
  {
    unint64_t v5 = 0;
    do
    {
      (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 15));
      uint64_t result = *(void *)(*((void *)this + 8) + 8 * v5);
      if (result) {
        uint64_t result = (*(uint64_t (**)(uint64_t, File *))(*(void *)result + 24))(result, a2);
      }
      ++v5;
    }
    while (v5 < *((unsigned int *)this + 14));
  }
  return result;
}

uint64_t CPSDOSTypeList::Dump(CPSDOSTypeList *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = operator new[]();
  unint64_t v7 = (const char *)v6;
  if (a3)
  {
    int v8 = 0;
    do
      *(unsigned char *)(v6 + (unsigned __int16)v8++) = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "List { Number of Items = %d:\n", *((_DWORD *)this + 14));
  if (*((_DWORD *)this + 14))
  {
    int v9 = 0;
    uint64_t v10 = a3 + 2;
    do
    {
      uint64_t v11 = *(void *)(*((void *)this + 8) + 8 * (unsigned __int16)v9);
      (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(void *)v11 + 48))(v11, a2, v10);
      ++v9;
    }
    while (*((_DWORD *)this + 14) > (unsigned __int16)v9);
  }
  return fprintf(a2, "%s} // End of List\n", v7);
}

uint64_t CPSDOSTypeInteger::Load(CPSDOSTypeInteger *this, int a2)
{
  int v4 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v4);
  *((_DWORD *)this + 14) = bswap32(*((_DWORD *)this + 14));
  return 1;
}

uint64_t CPSDOSTypeInteger::Save(CPSDOSTypeInteger *this, File *a2)
{
  return (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
}

uint64_t CPSDOSTypeInteger::Dump(CPSDOSTypeInteger *this, __sFILE *a2)
{
  return fprintf(a2, "Integer { %d }\n", *((_DWORD *)this + 14));
}

uint64_t CPSDOSTypeDouble::Dump(CPSDOSTypeDouble *this, __sFILE *a2)
{
  return fprintf(a2, "Double { %f }\n", *((double *)this + 7));
}

uint64_t CPSDOSTypeDouble::Load(CPSDOSTypeDouble *this, int a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)&v4, 8uLL, &v5);
  *((void *)this + 7) = bswap64(v4);
  return 1;
}

uint64_t CPSDOSTypeDouble::Save(CPSDOSTypeDouble *this, File *a2)
{
  return (*(uint64_t (**)(File *, double))(*(void *)a2 + 88))(a2, *((double *)this + 7));
}

uint64_t CPSDOSTypeBoolean::Load(CPSDOSTypeBoolean *this, int a2)
{
  int v3 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 1uLL, &v3);
  return 1;
}

uint64_t CPSDOSTypeBoolean::Save(CPSDOSTypeBoolean *this, File *a2)
{
  return (*(uint64_t (**)(File *, void))(*(void *)a2 + 64))(a2, *((unsigned __int8 *)this + 56));
}

uint64_t CPSDOSTypeBoolean::Dump(CPSDOSTypeBoolean *this, __sFILE *a2)
{
  return fprintf(a2, "Boolean { %d }\n", *((unsigned __int8 *)this + 56));
}

uint64_t CPSDOSTypeUnitFloat::Load(CPSDOSTypeUnitFloat *this, int a2)
{
  int v6 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v6);
  *((_DWORD *)this + 14) = bswap32(*((_DWORD *)this + 14));
  CPSDBaseComponent::ReadFile(a2, (char *)&v5, 8uLL, &v6);
  *((void *)this + 8) = bswap64(v5);
  return 1;
}

uint64_t CPSDOSTypeUnitFloat::Save(CPSDOSTypeUnitFloat *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  v4.n128_u64[0] = *((void *)this + 8);
  unint64_t v5 = *(uint64_t (**)(File *, __n128))(*(void *)a2 + 88);
  return v5(a2, v4);
}

uint64_t CPSDOSTypeUnitFloat::Dump(CPSDOSTypeUnitFloat *this, __sFILE *a2)
{
  unsigned int v3 = bswap32(*((_DWORD *)this + 14));
  return fprintf(a2, "Unit Float { Units = '%s', Double value = %f }\n", (const char *)&v3, *((double *)this + 8));
}

void CPSDOSTypeText::~CPSDOSTypeText(CPSDOSTypeText *this)
{
  *(void *)this = &unk_1EF486030;
  uint64_t v2 = *((void *)this + 8);
  if (v2)
  {
    MEMORY[0x1A6230DD0](v2, 0x1000C80BDFB0063);
    *((void *)this + 8) = 0;
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  uint64_t vars8;

  CPSDOSTypeText::~CPSDOSTypeText(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDOSTypeText::Load(char **this, int a2)
{
  unsigned int v3 = 0;
  return CPSDString::Load(this + 7, a2, &v3);
}

uint64_t CPSDOSTypeText::Save(CPSDOSTypeText *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  uint64_t v4 = *((void *)this + 8);
  uint64_t v5 = *((unsigned int *)this + 14);
  int v6 = *(uint64_t (**)(File *, uint64_t, uint64_t))(*(void *)a2 + 40);
  return v6(a2, v4, v5);
}

uint64_t CPSDOSTypeText::Dump(const UniChar **this, __sFILE *a2)
{
  CPSDString::CopyStringValue(this + 7, v4, 0x100u);
  return fprintf(a2, "Text { %s }\n", v4);
}

uint64_t CPSDOSTypeEnumerated::Load(CPSDOSTypeEnumerated *this, int a2)
{
  int v9 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v9);
  unsigned int v4 = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = bswap32(v4);
  if (v4)
  {
    uint64_t v5 = (char *)operator new[]();
    *((void *)this + 9) = v5;
    CPSDBaseComponent::ReadFile(a2, v5, *((unsigned int *)this + 14), &v9);
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 64, 4uLL, &v9);
    *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
  }
  CPSDBaseComponent::ReadFile(a2, (char *)this + 60, 4uLL, &v9);
  unsigned int v6 = *((_DWORD *)this + 15);
  *((_DWORD *)this + 15) = bswap32(v6);
  if (v6)
  {
    unint64_t v7 = (char *)operator new[]();
    *((void *)this + 11) = v7;
    CPSDBaseComponent::ReadFile(a2, v7, *((unsigned int *)this + 15), &v9);
    *(unsigned char *)(*((void *)this + 11) + *((unsigned int *)this + 15)) = 0;
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 80, 4uLL, &v9);
    *((_DWORD *)this + 20) = bswap32(*((_DWORD *)this + 20));
  }
  return 1;
}

uint64_t CPSDOSTypeEnumerated::Save(CPSDOSTypeEnumerated *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 14)) {
    (*(void (**)(File *, void))(*(void *)a2 + 48))(a2, *((void *)this + 9));
  }
  else {
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 16));
  }
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 15));
  if (*((_DWORD *)this + 15))
  {
    uint64_t v4 = *((void *)this + 11);
    uint64_t v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 48);
    return v5(a2, v4);
  }
  else
  {
    uint64_t v7 = *((unsigned int *)this + 20);
    int v8 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80);
    return v8(a2, v7);
  }
}

uint64_t CPSDOSTypeEnumerated::Dump(CPSDOSTypeEnumerated *this, __sFILE *__stream)
{
  if (*((_DWORD *)this + 16)) {
    fprintf(__stream, "TypeID = '%s', ");
  }
  else {
    fprintf(__stream, "TypeID string = %s, ");
  }
  if (*((_DWORD *)this + 20)) {
    return fprintf(__stream, "Enum = '%s' }\n");
  }
  else {
    return fprintf(__stream, "Enum string = %s }\n");
  }
}

void CPSDActionKeyedItem::CPSDActionKeyedItem(CPSDActionKeyedItem *this, int a2, CPSDActionBaseComponent *a3)
{
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(void *)this = &unk_1EF486570;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = a2;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 10) = a3;
  CPSDActionKeyedItem::SetItem(this, a3);
}

void sub_1A1343D4C(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

BOOL CPSDActionKeyedItem::SetItem(CPSDActionKeyedItem *this, CPSDActionBaseComponent *a2)
{
  *((void *)this + 10) = a2;
  if (!a2) {
    __cxa_bad_typeid();
  }
  if (result)
  {
    int v5 = 1433302086;
LABEL_17:
    *((_DWORD *)this + 18) = v5;
    return result;
  }
  if (result)
  {
    int v5 = 1651470188;
    goto LABEL_17;
  }
  if (result)
  {
    int v5 = 1685026146;
    goto LABEL_17;
  }
  if (result)
  {
    int v5 = 1819242087;
    goto LABEL_17;
  }
  if (result)
  {
    int v5 = 1413830740;
    goto LABEL_17;
  }
  if (result)
  {
    int v5 = 1701737837;
    goto LABEL_17;
  }
  if (result
  {
    int v5 = 1331849827;
    goto LABEL_17;
  }
  if (result)
  {
    int v5 = 1449938035;
    goto LABEL_17;
  }
  return result;
}

void CPSDActionKeyedItem::CPSDActionKeyedItem(CPSDActionKeyedItem *this, const char *__s, CPSDActionBaseComponent *a3)
{
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(void *)this = &unk_1EF486570;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 10) = a3;
  if (__s)
  {
    int v6 = strlen(__s);
    *((_DWORD *)this + 14) = v6;
    uint64_t v7 = (char *)malloc_type_malloc((v6 + 1), 0x2D3EBADAuLL);
    *((void *)this + 8) = v7;
    strcpy(v7, __s);
  }
  CPSDActionKeyedItem::SetItem(this, a3);
}

void sub_1A1343FD8(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

void CPSDActionKeyedItem::~CPSDActionKeyedItem(CPSDActionKeyedItem *this)
{
  *(void *)this = &unk_1EF486570;
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x1A6230DD0](v2, 0x1000C8077774924);
  }
  uint64_t v3 = *((void *)this + 10);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  uint64_t vars8;

  CPSDActionKeyedItem::~CPSDActionKeyedItem(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDActionKeyedItem::Load(CPSDActionKeyedItem *this, uint64_t a2)
{
  int v18 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v18);
  unsigned int v4 = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = bswap32(v4);
  if (v4)
  {
    int v5 = (char *)operator new[]();
    *((void *)this + 8) = v5;
    CPSDBaseComponent::ReadFile(a2, v5, *((unsigned int *)this + 14), &v18);
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 60, 4uLL, &v18);
    *((_DWORD *)this + 15) = bswap32(*((_DWORD *)this + 15));
  }
  CPSDBaseComponent::ReadFile(a2, (char *)this + 72, 4uLL, &v18);
  int v12 = bswap32(*((_DWORD *)this + 18));
  *((_DWORD *)this + 18) = v12;
  if (v12 <= 1651470187)
  {
    if (v12 > 1433302085)
    {
      if (v12 == 1433302086)
      {
        uint64_t v13 = operator new();
        *(_DWORD *)(v13 + 16) = 0;
        *(_OWORD *)(v13 + 24) = 0u;
        *(_OWORD *)(v13 + 40) = 0u;
        *(void *)uint64_t v13 = &unk_1EF486658;
        *(_DWORD *)(v13 + 56) = 0;
        *(void *)(v13 + 64) = 0;
        goto LABEL_39;
      }
      if (v12 == 1449938035)
      {
        uint64_t v13 = operator new();
        *(_DWORD *)(v13 + 16) = 0;
        *(_OWORD *)(v13 + 24) = 0u;
        *(_OWORD *)(v13 + 40) = 0u;
        *(void *)uint64_t v13 = &unk_1EF485FE8;
        *(_OWORD *)(v13 + 56) = 0u;
        *(_OWORD *)(v13 + 72) = 0u;
        goto LABEL_39;
      }
      goto LABEL_27;
    }
    if (v12 != 1331849827)
    {
      if (v12 == 1413830740)
      {
        uint64_t v13 = operator new();
        CPSDOSTypeText::CPSDOSTypeText((CPSDOSTypeText *)v13);
LABEL_39:
        *((void *)this + 10) = v13;
        (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 16))(v13, a2);
        return 1;
      }
      goto LABEL_27;
    }
    int v14 = *((_DWORD *)this + 15);
    if (v14 <= 1232229223)
    {
      switch(v14)
      {
        case 1148343144:
          uint64_t v13 = operator new();
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
          uint64_t v15 = &unk_1EF486D80;
          goto LABEL_38;
        case 1198671468:
          uint64_t v13 = operator new();
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
          *(void *)uint64_t v13 = &unk_1EF486A90;
          *(void *)(v13 + 120) = 0;
          goto LABEL_39;
        case 1232226156:
          uint64_t v13 = operator new();
          CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
          uint64_t v15 = &unk_1EF486C20;
          goto LABEL_38;
      }
    }
    else if (v14 > 1399801448)
    {
      if (v14 == 1399801449)
      {
        uint64_t v13 = operator new();
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
        uint64_t v15 = &unk_1EF486E70;
        goto LABEL_38;
      }
      if (v14 == 1700946540)
      {
        uint64_t v13 = operator new();
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
        uint64_t v15 = &unk_1EF486DD0;
        goto LABEL_38;
      }
    }
    else
    {
      if (v14 == 1232229224)
      {
        uint64_t v13 = operator new();
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
        uint64_t v15 = &unk_1EF486E20;
        goto LABEL_38;
      }
      if (v14 == 1332889452)
      {
        uint64_t v13 = operator new();
        CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
        uint64_t v15 = &unk_1EF486CB0;
LABEL_38:
        *(void *)uint64_t v13 = v15;
        goto LABEL_39;
      }
    }
    uint64_t v13 = operator new();
    CPSDActionDescriptor::CPSDActionDescriptor((CPSDActionDescriptor *)v13);
    goto LABEL_39;
  }
  if (v12 > 1701737836)
  {
    if (v12 == 1701737837)
    {
      uint64_t v13 = operator new();
      *(_DWORD *)(v13 + 16) = 0;
      *(_OWORD *)(v13 + 24) = 0u;
      *(_OWORD *)(v13 + 40) = 0u;
      *(void *)uint64_t v13 = &unk_1EF486848;
      *(void *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      *(_DWORD *)(v13 + 80) = 0;
      *(void *)(v13 + 88) = 0;
      goto LABEL_39;
    }
    if (v12 == 1819242087)
    {
      uint64_t v13 = operator new();
      *(_DWORD *)(v13 + 16) = 0;
      *(_OWORD *)(v13 + 24) = 0u;
      *(_OWORD *)(v13 + 40) = 0u;
      *(void *)uint64_t v13 = &unk_1EF486388;
      *(_DWORD *)(v13 + 56) = 0;
      goto LABEL_39;
    }
  }
  else
  {
    if (v12 == 1651470188)
    {
      uint64_t v13 = operator new();
      *(_DWORD *)(v13 + 16) = 0;
      *(_OWORD *)(v13 + 24) = 0u;
      *(_OWORD *)(v13 + 40) = 0u;
      *(void *)uint64_t v13 = &unk_1EF486340;
      *(unsigned char *)(v13 + 56) = 0;
      goto LABEL_39;
    }
    if (v12 == 1685026146)
    {
      uint64_t v13 = operator new();
      *(_DWORD *)(v13 + 16) = 0;
      *(_OWORD *)(v13 + 24) = 0u;
      *(_OWORD *)(v13 + 40) = 0u;
      *(void *)uint64_t v13 = &unk_1EF486170;
      *(void *)(v13 + 56) = 0;
      goto LABEL_39;
    }
  }
LABEL_27:
  *((void *)this + 10) = 0;
  _CUILog(1, (uint64_t)"in keyed item Error parsing gradient fill info: This OSType cannot be parsed.\n", v6, v7, v8, v9, v10, v11, v17);
  return 1;
}

void sub_1A1344714(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C4032540B95);
  _Unwind_Resume(a1);
}

uint64_t CPSDActionKeyedItem::Save(CPSDActionKeyedItem *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 14)) {
    (*(void (**)(File *, void))(*(void *)a2 + 48))(a2, *((void *)this + 8));
  }
  else {
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 15));
  }
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 18));
  uint64_t result = *((void *)this + 10);
  if (result)
  {
    int v5 = *(uint64_t (**)(void))(*(void *)result + 24);
    return v5();
  }
  return result;
}

size_t CPSDActionKeyedItem::Dump(CPSDActionKeyedItem *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = operator new[]();
  if (a3)
  {
    int v7 = 0;
    do
      *(unsigned char *)(v6 + (unsigned __int16)v7++) = 9;
    while (a3 > (unsigned __int16)v7);
  }
  if (*((_DWORD *)this + 15)) {
    fprintf(a2, "%s\tKey: '%s', \t");
  }
  else {
    fprintf(a2, "%s\tKey: \"%s\", \t");
  }
  uint64_t v8 = *((void *)this + 10);
  if (v8)
  {
    uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 48);
    return v9();
  }
  else
  {
    return fwrite("Unknown Key. Data could not be parsed.\n", 0x27uLL, 1uLL, a2);
  }
}

void CPSDActionDescriptor::~CPSDActionDescriptor(CPSDActionDescriptor *this)
{
  *(void *)this = &unk_1EF4866E0;
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    MEMORY[0x1A6230DF0](v2, 0x1000C4077774924);
    *((void *)this + 9) = 0;
  }
  unsigned int v4 = (void (***)(void))*((void *)this + 12);
  uint64_t v3 = (void (***)(void))*((void *)this + 13);
  if (v3 != v4)
  {
    int v5 = v3 - 11;
    uint64_t v6 = v3 - 11;
    int v7 = v3 - 11;
    do
    {
      uint64_t v8 = *v7;
      v7 -= 11;
      (*v8)(v6);
      v5 -= 11;
      BOOL v9 = v6 == v4;
      uint64_t v6 = v7;
    }
    while (!v9);
  }
  *((void *)this + 13) = v4;
  uint64_t v11 = (void **)((char *)this + 96);
  std::vector<CPSDActionKeyedItem>::__destroy_vector::operator()[abi:ne180100](&v11);
  uint64_t v10 = *((void *)this + 8);
  if (v10)
  {
    MEMORY[0x1A6230DD0](v10, 0x1000C80BDFB0063);
    *((void *)this + 8) = 0;
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  uint64_t vars8;

  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDActionDescriptor::Load(CPSDActionDescriptor *this, uint64_t a2)
{
  unsigned int v12 = 0;
  CPSDString::Load((char **)this + 7, a2, &v12);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 80, 4uLL, &v12);
  unsigned int v4 = *((_DWORD *)this + 20);
  *((_DWORD *)this + 20) = bswap32(v4);
  if (v4)
  {
    int v5 = (char *)operator new[]();
    *((void *)this + 9) = v5;
    CPSDBaseComponent::ReadFile(a2, v5, *((unsigned int *)this + 20), &v12);
  }
  else
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 84, 4uLL, &v12);
    *((_DWORD *)this + 21) = bswap32(*((_DWORD *)this + 21));
  }
  uint64_t v6 = (unsigned int *)((char *)this + 88);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 88, 4uLL, &v12);
  unint64_t v7 = bswap32(*((_DWORD *)this + 22));
  *((_DWORD *)this + 22) = v7;
  uint64_t v8 = (void *)((char *)this + 96);
  std::vector<CPSDActionKeyedItem>::resize((uint64_t *)this + 12, v7);
  if (*((_DWORD *)this + 22))
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)(*v8 + v9) + 16))(*v8 + v9, a2);
      ++v10;
      v9 += 88;
    }
    while (v10 < *v6);
  }
  return 1;
}

uint64_t *std::vector<CPSDActionKeyedItem>::resize(uint64_t *result, unint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[1];
  unint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((v3 - *result) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    return (uint64_t *)std::vector<CPSDActionKeyedItem>::__append(result, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *result + 88 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = v3 - 88;
      uint64_t v9 = (uint64_t (***)(void))(v3 - 88);
      unint64_t v10 = (uint64_t (***)(void))(v3 - 88);
      do
      {
        uint64_t v11 = *v10;
        v10 -= 11;
        uint64_t result = (uint64_t *)(*v11)(v9);
        v8 -= 88;
        BOOL v12 = v9 == (uint64_t (***)(void))v7;
        uint64_t v9 = v10;
      }
      while (!v12);
    }
    v2[1] = v7;
  }
  return result;
}

uint64_t CPSDActionDescriptor::Save(CPSDActionDescriptor *this, File *a2)
{
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  (*(void (**)(File *, void, void))(*(void *)a2 + 40))(a2, *((void *)this + 8), *((unsigned int *)this + 14));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 20));
  if (*((_DWORD *)this + 20)) {
    (*(void (**)(File *, void))(*(void *)a2 + 48))(a2, *((void *)this + 9));
  }
  else {
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 21));
  }
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 22));
  if (*((_DWORD *)this + 22))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, File *))(*(void *)(*((void *)this + 12) + v5) + 24))(*((void *)this + 12) + v5, a2);
      ++v6;
      v5 += 88;
    }
    while (v6 < *((unsigned int *)this + 22));
  }
  return result;
}

uint64_t CPSDActionDescriptor::DumpInset(const UniChar **this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = operator new[]();
  uint64_t v7 = (const char *)v6;
  if (a3)
  {
    int v8 = 0;
    do
      *(unsigned char *)(v6 + (unsigned __int16)v8++) = 9;
    while (a3 > (unsigned __int16)v8);
  }
  CPSDString::CopyStringValue(this + 7, v16, 0x100u);
  fprintf(a2, "%sDescriptor { CFStringRef Name = %s, ", v7, v16);
  if (*((_DWORD *)this + 20))
  {
    fwrite("ClassID", 7uLL, 1uLL, a2);
    if (*((_DWORD *)this + 20))
    {
      unint64_t v9 = 0;
      do
        fputc(*((unsigned __int8 *)this[9] + v9++), a2);
      while (v9 < *((unsigned int *)this + 20));
    }
    fwrite(", ", 2uLL, 1uLL, a2);
  }
  else
  {
    fprintf(a2, "ClassID = '%s', ", (const char *)this + 84);
  }
  fprintf(a2, "Number of Items = %d:\n", *((_DWORD *)this + 22));
  uint64_t v10 = *((unsigned int *)this + 22);
  if (0x2E8BA2E8BA2E8BA3 * (((char *)this[13] - (char *)this[12]) >> 3) == v10 && v10 != 0)
  {
    int v12 = 0;
    uint64_t v13 = a3 + 1;
    do
    {
      uint64_t v14 = (uint64_t)&this[12][44 * (unsigned __int16)v12];
      (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(void *)v14 + 48))(v14, a2, v13);
      ++v12;
    }
    while (*((_DWORD *)this + 22) > (unsigned __int16)v12);
  }
  return fprintf(a2, "%s}\n", v7);
}

uint64_t CPSDActionDescriptor::GetItemForKeyString(CPSDActionDescriptor *this, unsigned __int8 *a2)
{
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  CFStringRef v5 = CFStringCreateWithBytes(kCFAllocatorDefault, a2, 8, SystemEncoding, 0);
  unsigned int v6 = *((_DWORD *)this + 22);
  if (!v6)
  {
LABEL_7:
    CFRelease(v5);
    return 0;
  }
  unsigned __int16 v7 = 0;
  while (1)
  {
    unsigned int v8 = v7;
    unint64_t v9 = *(const UInt8 **)(*((void *)this + 12) + 88 * v7 + 64);
    if (v9) {
      break;
    }
LABEL_6:
    unsigned __int16 v7 = v8 + 1;
    if (v6 <= (unsigned __int16)(v8 + 1)) {
      goto LABEL_7;
    }
  }
  CFStringEncoding v10 = CFStringGetSystemEncoding();
  CFStringRef v11 = CFStringCreateWithBytes(kCFAllocatorDefault, v9, 8, v10, 0);
  CFComparisonResult v12 = CFStringCompare(v5, v11, 0);
  CFRelease(v11);
  if (v12)
  {
    unsigned int v6 = *((_DWORD *)this + 22);
    goto LABEL_6;
  }
  CFRelease(v5);
  return *(void *)(*((void *)this + 12) + 88 * v8 + 80);
}

void CPSDActionDescriptor::CPSDActionDescriptor(CPSDActionDescriptor *this)
{
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(void *)this = &unk_1EF4866E0;
  *((void *)this + 8) = 0;
  CPSDString::AllocateCharData((CPSDActionDescriptor *)((char *)this + 56), 1);
  **((_WORD **)this + 8) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
}

void sub_1A1345248(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

BOOL CPSDDropShadowDescriptor::Load(CPSDDropShadowDescriptor *this, uint64_t a2)
{
  CPSDActionDescriptor::Load(this, a2);
  unsigned int v3 = *((_DWORD *)this + 22);
  if (!v3) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *((void *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1148343144)
  {
    if (v3 <= ++v4) {
      return 0;
    }
  }
  return *(void *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDDropShadowDescriptor::DumpInset(CPSDDropShadowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  unsigned int v6 = (const char *)operator new[]();
  unsigned __int16 v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Drop Shadow:\n", v6);
  double Angle = CPSDDropShadowDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  double Distance = CPSDDropShadowDescriptor::GetDistance(this);
  fprintf(a2, "%s\tDistance: %f\n", v7, Distance);
  double BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Drop Shadow\n", v7);
}

double CPSDDropShadowDescriptor::GetAngle(CPSDDropShadowDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 0.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1818322796)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64);
    }
  }
  return result;
}

double CPSDDropShadowDescriptor::GetDistance(CPSDDropShadowDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 0.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1148417134)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64);
    }
  }
  return result;
}

double CPSDDropShadowDescriptor::GetBlurSize(CPSDDropShadowDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 0.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1651275122)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64);
    }
  }
  return result;
}

uint64_t CPSDDropShadowDescriptor::GetIsEnabled(CPSDDropShadowDescriptor *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (*(_DWORD *)(v1 + 60) == 1701732706)
  {
    unsigned int v2 = 0;
  }
  else
  {
    int v3 = 0;
    do
      unsigned int v2 = (unsigned __int16)++v3;
    while (*(_DWORD *)(v1 + 88 * (unsigned __int16)v3 + 60) != 1701732706);
  }
  return *(unsigned __int8 *)(*(void *)(v1 + 88 * v2 + 80) + 56);
}

double CPSDDropShadowDescriptor::GetColor(CPSDDropShadowDescriptor *this, double *a2)
{
  uint64_t v2 = *((void *)this + 12);
  if (*(_DWORD *)(v2 + 60) == 1131180576)
  {
    unsigned int v3 = 0;
  }
  else
  {
    int v4 = 0;
    do
      unsigned int v3 = (unsigned __int16)++v4;
    while (*(_DWORD *)(v2 + 88 * (unsigned __int16)v4 + 60) != 1131180576);
  }
  unsigned __int16 v5 = 0;
  uint64_t v6 = *(void *)(v2 + 88 * v3 + 80);
  unsigned int v7 = *(_DWORD *)(v6 + 88);
  uint64_t v8 = *(void *)(v6 + 96);
  while (*(_DWORD *)(v8 + 88 * v5 + 60) != 1382293536)
  {
    if (v7 <= ++v5)
    {
      uint64_t v9 = 0;
      goto LABEL_10;
    }
  }
  uint64_t v9 = *(void *)(v8 + 88 * v5 + 80);
LABEL_10:
  unsigned __int16 v10 = 0;
  while (*(_DWORD *)(v8 + 88 * v10 + 60) != 1198681632)
  {
    if (v7 <= ++v10)
    {
      uint64_t v11 = 0;
      goto LABEL_15;
    }
  }
  uint64_t v11 = *(void *)(v8 + 88 * v10 + 80);
LABEL_15:
  if (*(_DWORD *)(v8 + 60) == 1114382368)
  {
    unsigned int v12 = 0;
  }
  else
  {
    int v13 = 0;
    do
      unsigned int v12 = (unsigned __int16)++v13;
    while (*(_DWORD *)(v8 + 88 * (unsigned __int16)v13 + 60) != 1114382368);
  }
  double result = *(double *)(v9 + 56);
  uint64_t v15 = *(void *)(v11 + 56);
  uint64_t v16 = *(void *)(*(void *)(v8 + 88 * v12 + 80) + 56);
  *a2 = result;
  *((void *)a2 + 1) = v15;
  *((void *)a2 + 2) = v16;
  a2[3] = 1.0;
  return result;
}

uint64_t CPSDDropShadowDescriptor::GetBlendMode(CPSDDropShadowDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1298407456)
  {
    if (v1 <= ++v2) {
      return 0;
    }
  }
  int v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4) {
    return CPSDOSTypeEnumerated::GetEnum(v4);
  }
  else {
    return 0;
  }
}

uint64_t CPSDOSTypeEnumerated::GetEnum(CPSDOSTypeEnumerated *this)
{
  if (!*((_DWORD *)this + 15)) {
    return *((unsigned int *)this + 20);
  }
  uint64_t v1 = 1282240116;
  unsigned __int16 v2 = (const char *)*((void *)this + 11);
  if (strcmp(v2, "linearBurn"))
  {
    if (!strcmp(v2, "darkerColor"))
    {
      return 1282240117;
    }
    else if (!strcmp(v2, "linearDodge"))
    {
      return 1282240118;
    }
    else if (!strcmp(v2, "lighterColor"))
    {
      return 1282240119;
    }
    else if (!strcmp(v2, "vividLight"))
    {
      return 1282240120;
    }
    else if (!strcmp(v2, "linearLight"))
    {
      return 1282240121;
    }
    else if (!strcmp(v2, "pinLight"))
    {
      return 1282240122;
    }
    else if (!strcmp(v2, "hardMix"))
    {
      return 1282240123;
    }
    else if (!strcmp(v2, "blendSubtraction"))
    {
      return 1282240124;
    }
    else if (!strcmp(v2, "blendDivide"))
    {
      return 1282240125;
    }
    else
    {
      return 1316121964;
    }
  }
  return v1;
}

double CPSDDropShadowDescriptor::GetOpacity(CPSDDropShadowDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 100.0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1332765556)
  {
    if (v1 <= ++v2) {
      return 100.0;
    }
  }
  uint64_t v4 = *(void *)(v3 + 88 * v2 + 80);
  if (v4) {
    return round(*(double *)(v4 + 64));
  }
  else {
    return 100.0;
  }
}

uint64_t CPSDDropShadowDescriptor::UseGlobalLightAngle(CPSDDropShadowDescriptor *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (*(_DWORD *)(v1 + 60) == 1969712231)
  {
    unsigned int v2 = 0;
  }
  else
  {
    int v3 = 0;
    do
      unsigned int v2 = (unsigned __int16)++v3;
    while (*(_DWORD *)(v1 + 88 * (unsigned __int16)v3 + 60) != 1969712231);
  }
  return *(unsigned __int8 *)(*(void *)(v1 + 88 * v2 + 80) + 56);
}

double CPSDDropShadowDescriptor::GetSpread(CPSDDropShadowDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 0.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1131113844)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64);
    }
  }
  return result;
}

BOOL CPSDInnerShadowDescriptor::Load(CPSDInnerShadowDescriptor *this, uint64_t a2)
{
  CPSDActionDescriptor::Load(this, a2);
  unsigned int v3 = *((_DWORD *)this + 22);
  if (!v3) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *((void *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1232229224)
  {
    if (v3 <= ++v4) {
      return 0;
    }
  }
  return *(void *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDInnerShadowDescriptor::DumpInset(CPSDInnerShadowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = (const char *)operator new[]();
  unsigned int v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Inner Shadow:\n", v6);
  double Angle = CPSDDropShadowDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  double Distance = CPSDDropShadowDescriptor::GetDistance(this);
  fprintf(a2, "%s\tDistance: %f\n", v7, Distance);
  double BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Inner Shadow\n", v7);
}

BOOL CPSDInnerGlowDescriptor::Load(CPSDInnerGlowDescriptor *this, uint64_t a2)
{
  CPSDActionDescriptor::Load(this, a2);
  unsigned int v3 = *((_DWORD *)this + 22);
  if (!v3) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *((void *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1232226156)
  {
    if (v3 <= ++v4) {
      return 0;
    }
  }
  return *(void *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDInnerGlowDescriptor::DumpInset(CPSDInnerGlowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = (const char *)operator new[]();
  unsigned int v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Inner Glow:\n", v6);
  double BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Inner Glow\n", v7);
}

BOOL CPSDOuterGlowDescriptor::Load(CPSDOuterGlowDescriptor *this, uint64_t a2)
{
  CPSDActionDescriptor::Load(this, a2);
  unsigned int v3 = *((_DWORD *)this + 22);
  if (!v3) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *((void *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1332889452)
  {
    if (v3 <= ++v4) {
      return 0;
    }
  }
  return *(void *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDOuterGlowDescriptor::DumpInset(CPSDOuterGlowDescriptor *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = (const char *)operator new[]();
  unsigned int v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Outer Glow:\n", v6);
  double BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Outer Glow\n", v7);
}

BOOL CPSDBevelEmbossDescriptor::Load(CPSDBevelEmbossDescriptor *this, uint64_t a2)
{
  CPSDActionDescriptor::Load(this, a2);
  unsigned int v3 = *((_DWORD *)this + 22);
  if (!v3) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *((void *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1700946540)
  {
    if (v3 <= ++v4) {
      return 0;
    }
  }
  return *(void *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDBevelEmbossDescriptor::DumpInset(CPSDBevelEmbossDescriptor *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = (const char *)operator new[]();
  unsigned int v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Bevel & Emboss:\n", v6);
  double Angle = CPSDDropShadowDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  double BlurSize = CPSDDropShadowDescriptor::GetBlurSize(this);
  fprintf(a2, "%s\tBlur Size: %f\n", v7, BlurSize);
  return fprintf(a2, "%s} // End Bevel & Emboss\n", v7);
}

uint64_t CPSDBevelEmbossDescriptor::GetBevelDirection(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1651928132)
  {
    if (v1 <= ++v2) {
      return 0;
    }
  }
  unsigned __int16 v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4) {
    return CPSDOSTypeEnumerated::GetEnum(v4);
  }
  else {
    return 0;
  }
}

double CPSDBevelEmbossDescriptor::GetHighlightColor(CPSDBevelEmbossDescriptor *this, double *a2)
{
  uint64_t v2 = *((void *)this + 12);
  if (*(_DWORD *)(v2 + 60) == 1751608387)
  {
    unsigned int v3 = 0;
  }
  else
  {
    int v4 = 0;
    do
      unsigned int v3 = (unsigned __int16)++v4;
    while (*(_DWORD *)(v2 + 88 * (unsigned __int16)v4 + 60) != 1751608387);
  }
  unsigned __int16 v5 = 0;
  uint64_t v6 = *(void *)(v2 + 88 * v3 + 80);
  unsigned int v7 = *(_DWORD *)(v6 + 88);
  uint64_t v8 = *(void *)(v6 + 96);
  while (*(_DWORD *)(v8 + 88 * v5 + 60) != 1382293536)
  {
    if (v7 <= ++v5)
    {
      uint64_t v9 = 0;
      goto LABEL_10;
    }
  }
  uint64_t v9 = *(void *)(v8 + 88 * v5 + 80);
LABEL_10:
  unsigned __int16 v10 = 0;
  while (*(_DWORD *)(v8 + 88 * v10 + 60) != 1198681632)
  {
    if (v7 <= ++v10)
    {
      uint64_t v11 = 0;
      goto LABEL_15;
    }
  }
  uint64_t v11 = *(void *)(v8 + 88 * v10 + 80);
LABEL_15:
  if (*(_DWORD *)(v8 + 60) == 1114382368)
  {
    unsigned int v12 = 0;
  }
  else
  {
    int v13 = 0;
    do
      unsigned int v12 = (unsigned __int16)++v13;
    while (*(_DWORD *)(v8 + 88 * (unsigned __int16)v13 + 60) != 1114382368);
  }
  double result = *(double *)(v9 + 56);
  uint64_t v15 = *(void *)(v11 + 56);
  uint64_t v16 = *(void *)(*(void *)(v8 + 88 * v12 + 80) + 56);
  *a2 = result;
  *((void *)a2 + 1) = v15;
  *((void *)a2 + 2) = v16;
  a2[3] = 1.0;
  return result;
}

uint64_t CPSDBevelEmbossDescriptor::GetHighlightBlendMode(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1751608397)
  {
    if (v1 <= ++v2) {
      return 0;
    }
  }
  int v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4) {
    return CPSDOSTypeEnumerated::GetEnum(v4);
  }
  else {
    return 0;
  }
}

double CPSDBevelEmbossDescriptor::GetHighlightOpacity(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 100.0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1751608399)
  {
    if (v1 <= ++v2) {
      return 100.0;
    }
  }
  uint64_t v4 = *(void *)(v3 + 88 * v2 + 80);
  if (v4) {
    return round(*(double *)(v4 + 64));
  }
  else {
    return 100.0;
  }
}

double CPSDBevelEmbossDescriptor::GetShadowColor(CPSDBevelEmbossDescriptor *this, double *a2)
{
  uint64_t v2 = *((void *)this + 12);
  if (*(_DWORD *)(v2 + 60) == 1935963971)
  {
    unsigned int v3 = 0;
  }
  else
  {
    int v4 = 0;
    do
      unsigned int v3 = (unsigned __int16)++v4;
    while (*(_DWORD *)(v2 + 88 * (unsigned __int16)v4 + 60) != 1935963971);
  }
  unsigned __int16 v5 = 0;
  uint64_t v6 = *(void *)(v2 + 88 * v3 + 80);
  unsigned int v7 = *(_DWORD *)(v6 + 88);
  uint64_t v8 = *(void *)(v6 + 96);
  while (*(_DWORD *)(v8 + 88 * v5 + 60) != 1382293536)
  {
    if (v7 <= ++v5)
    {
      uint64_t v9 = 0;
      goto LABEL_10;
    }
  }
  uint64_t v9 = *(void *)(v8 + 88 * v5 + 80);
LABEL_10:
  unsigned __int16 v10 = 0;
  while (*(_DWORD *)(v8 + 88 * v10 + 60) != 1198681632)
  {
    if (v7 <= ++v10)
    {
      uint64_t v11 = 0;
      goto LABEL_15;
    }
  }
  uint64_t v11 = *(void *)(v8 + 88 * v10 + 80);
LABEL_15:
  if (*(_DWORD *)(v8 + 60) == 1114382368)
  {
    unsigned int v12 = 0;
  }
  else
  {
    int v13 = 0;
    do
      unsigned int v12 = (unsigned __int16)++v13;
    while (*(_DWORD *)(v8 + 88 * (unsigned __int16)v13 + 60) != 1114382368);
  }
  double result = *(double *)(v9 + 56);
  uint64_t v15 = *(void *)(v11 + 56);
  uint64_t v16 = *(void *)(*(void *)(v8 + 88 * v12 + 80) + 56);
  *a2 = result;
  *((void *)a2 + 1) = v15;
  *((void *)a2 + 2) = v16;
  a2[3] = 1.0;
  return result;
}

uint64_t CPSDBevelEmbossDescriptor::GetShadowBlendMode(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1935963981)
  {
    if (v1 <= ++v2) {
      return 0;
    }
  }
  int v4 = *(CPSDOSTypeEnumerated **)(v3 + 88 * v2 + 80);
  if (v4) {
    return CPSDOSTypeEnumerated::GetEnum(v4);
  }
  else {
    return 0;
  }
}

double CPSDBevelEmbossDescriptor::GetShadowOpacity(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (!v1) {
    return 100.0;
  }
  unsigned __int16 v2 = 0;
  uint64_t v3 = *((void *)this + 12);
  while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1935963983)
  {
    if (v1 <= ++v2) {
      return 100.0;
    }
  }
  uint64_t v4 = *(void *)(v3 + 88 * v2 + 80);
  if (v4) {
    return round(*(double *)(v4 + 64));
  }
  else {
    return 100.0;
  }
}

double CPSDBevelEmbossDescriptor::GetAltitude(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 30.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1281453156)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64);
    }
  }
  return result;
}

double CPSDBevelEmbossDescriptor::GetSoftenSize(CPSDBevelEmbossDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 0.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1399223406)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64);
    }
  }
  return result;
}

BOOL CPSDColorOverlayDescriptor::Load(CPSDColorOverlayDescriptor *this, uint64_t a2)
{
  CPSDActionDescriptor::Load(this, a2);
  unsigned int v3 = *((_DWORD *)this + 22);
  if (!v3) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *((void *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1399801449)
  {
    if (v3 <= ++v4) {
      return 0;
    }
  }
  return *(void *)(v5 + 88 * v4 + 80) != 0;
}

uint64_t CPSDColorOverlayDescriptor::DumpInset(CPSDColorOverlayDescriptor *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v5 = (const char *)operator new[]();
  uint64_t v6 = v5;
  if (a3)
  {
    int v7 = 0;
    do
      v5[(unsigned __int16)v7++] = 9;
    while (a3 > (unsigned __int16)v7);
  }
  fprintf(a2, "%s{ Color Overlay:\n", v5);
  return fprintf(a2, "%s} // End Color Overlay\n", v6);
}

uint64_t CPSDGradientDescriptor::Load(CPSDGradientDescriptor *this, uint64_t a2)
{
  CPSDActionDescriptor::Load(this, a2);
  unsigned int v3 = *((_DWORD *)this + 22);
  if (!v3) {
    return 0;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *((void *)this + 12);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1198678372)
  {
    if (v3 <= ++v4) {
      return 0;
    }
  }
  uint64_t v6 = *(void *)(v5 + 88 * v4 + 80);
  if (!v6) {
    return 0;
  }
  unsigned int v7 = *(_DWORD *)(v6 + 88);
  if (!v7) {
    return 0;
  }
  unsigned __int16 v8 = 0;
  uint64_t v9 = *(void *)(v6 + 96);
  while (*(_DWORD *)(v9 + 88 * v8 + 60) != 1131180659)
  {
    if (v7 <= ++v8) {
      return 0;
    }
  }
  uint64_t v10 = *(void *)(v9 + 88 * v8 + 80);
  if (!v10) {
    return 0;
  }
  unsigned __int16 v11 = 0;
  while (*(_DWORD *)(v9 + 88 * v11 + 60) != 1416785523)
  {
    uint64_t result = 0;
    if (v7 <= ++v11) {
      return result;
    }
  }
  uint64_t v13 = *(void *)(v9 + 88 * v11 + 80);
  if (!v13) {
    return 0;
  }
  int v14 = *(_DWORD *)(v13 + 56);
  *((_DWORD *)this + 30) = *(_DWORD *)(v10 + 56);
  *((_DWORD *)this + 31) = v14;
  return 1;
}

uint64_t CPSDGradientDescriptor::DumpInset(CPSDGradientDescriptor *this, __sFILE *a2, unsigned int a3)
{
  uint64_t v6 = (const char *)operator new[]();
  unsigned int v7 = v6;
  if (a3)
  {
    int v8 = 0;
    do
      v6[(unsigned __int16)v8++] = 9;
    while (a3 > (unsigned __int16)v8);
  }
  fprintf(a2, "%s{ Gradient:\n", v6);
  CPSDGradientDescriptor::GetName(this, (CPSDString *)&v31);
  CPSDString::CopyStringValue(&v31, v34, 0x100u);
  fprintf(a2, "%s\tName: %s\n", v7, v34);
  fprintf(a2, "%s\tStyle: ", v7);
  int Style = CPSDGradientDescriptor::GetStyle(this);
  if (Style <= 1282306591)
  {
    if (Style == 1097754476)
    {
      uint64_t v10 = "Angular (Sweep)\n";
      size_t v11 = 16;
      goto LABEL_16;
    }
    if (Style != 1148022372) {
      goto LABEL_44;
    }
    uint64_t v10 = "Diamond\n";
    size_t v11 = 8;
LABEL_16:
    fwrite(v10, v11, 1uLL, a2);
    goto LABEL_17;
  }
  switch(Style)
  {
    case 1382444131:
      uint64_t v10 = "Reflected\n";
      size_t v11 = 10;
      goto LABEL_16;
    case 1382312992:
      uint64_t v10 = "Radial\n";
      goto LABEL_14;
    case 1282306592:
      uint64_t v10 = "Linear\n";
LABEL_14:
      size_t v11 = 7;
      goto LABEL_16;
  }
LABEL_44:
  fprintf(a2, "%d, Style not recognized\n", Style);
LABEL_17:
  unsigned int v12 = *((_DWORD *)this + 22);
  if (v12)
  {
    unsigned __int16 v13 = 0;
    uint64_t v14 = *((void *)this + 12);
    while (*(_DWORD *)(v14 + 88 * v13 + 60) != 1332114292)
    {
      if (v12 <= ++v13) {
        goto LABEL_24;
      }
    }
    if (*(void *)(v14 + 88 * v13 + 80))
    {
      v33[0] = 0.0;
      double v30 = 0.0;
      CPSDGradientDescriptor::GetOffset((uint64_t)this, v33, &v30);
      fprintf(a2, "%s\tOffset: (%f,%f)\n", v7, v33[0], v30);
    }
  }
LABEL_24:
  double Angle = CPSDGradientDescriptor::GetAngle(this);
  fprintf(a2, "%s\tAngle: %f\n", v7, Angle);
  double Scale = CPSDGradientDescriptor::GetScale(this);
  fprintf(a2, "%s\tScale: %.0f%%\n", v7, Scale * 100.0);
  int IsReversed = CPSDGradientDescriptor::GetIsReversed(this);
  int IsDithered = CPSDGradientDescriptor::GetIsDithered(this);
  unsigned int v19 = "YES";
  if (IsReversed) {
    int v20 = "YES";
  }
  else {
    int v20 = "NO";
  }
  if (!IsDithered) {
    unsigned int v19 = "NO";
  }
  fprintf(a2, "%s\tReverse: %s, Dither: %s\n", v7, v20, v19);
  fprintf(a2, "%s\tType: ", v7);
  int Type = CPSDGradientDescriptor::GetType(this);
  if (Type == 1)
  {
    int v22 = "Noise\n";
    goto LABEL_33;
  }
  if (!Type)
  {
    int v22 = "Solid\n";
LABEL_33:
    fwrite(v22, 6uLL, 1uLL, a2);
    goto LABEL_35;
  }
  fprintf(a2, "%d, Type not recognized\n", 2);
LABEL_35:
  double Smoothness = CPSDGradientDescriptor::GetSmoothness(this);
  fprintf(a2, "%s\tSmoothness: %.0f%%\n", v7, Smoothness * 100.0);
  fprintf(a2, "%s\tColor stops[%d]:\n", v7, *((_DWORD *)this + 30));
  if (*((_DWORD *)this + 30))
  {
    int v24 = 0;
    int v25 = 0;
    do
    {
      double v29 = 0.0;
      double v30 = 0.0;
      CPSDGradientDescriptor::GetColorStopAtIndex(this, (unsigned __int16)v25, v33, &v30, &v29);
      fprintf(a2, "%s\t\t[%d]: RGB: (%f, %f, %f), Location: %f, Midpoint: %f\n", v7, v24, v33[0], v33[1], v33[2], v30, v29);
      int v24 = (unsigned __int16)++v25;
    }
    while (*((_DWORD *)this + 30) > (unsigned __int16)v25);
  }
  fprintf(a2, "%s\tOpacity stops[%d]:\n", v7, *((_DWORD *)this + 31));
  if (*((_DWORD *)this + 31))
  {
    int v26 = 0;
    int v27 = 0;
    do
    {
      v33[0] = 0.0;
      double v29 = 0.0;
      double v30 = 0.0;
      CPSDGradientDescriptor::GetOpacityStopAtIndex(this, (unsigned __int16)v27, v33, &v30, &v29);
      fprintf(a2, "%s\t\t[%d]: Opacity: %.0f%%, Location: %f, Midpoint: %f\n", v7, v26, v33[0], v30, v29);
      int v26 = (unsigned __int16)++v27;
    }
    while (*((_DWORD *)this + 31) > (unsigned __int16)v27);
  }
  fprintf(a2, "%s} // End Gradient\n", v7);
  uint64_t result = v32;
  if (v32) {
    return MEMORY[0x1A6230DD0](v32, 0x1000C80BDFB0063);
  }
  return result;
}

void sub_1A1346AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19) {
    MEMORY[0x1A6230DD0](a19, 0x1000C80BDFB0063);
  }
  _Unwind_Resume(exception_object);
}

void *CPSDGradientDescriptor::GetName@<X0>(CPSDGradientDescriptor *this@<X0>, CPSDString *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 12);
  if (*(_DWORD *)(v3 + 60) == 1198678372)
  {
    unsigned int v4 = 0;
  }
  else
  {
    int v5 = 0;
    do
      unsigned int v4 = (unsigned __int16)++v5;
    while (*(_DWORD *)(v3 + 88 * (unsigned __int16)v5 + 60) != 1198678372);
  }
  uint64_t v6 = *(void *)(*(void *)(v3 + 88 * v4 + 80) + 96);
  if (*(_DWORD *)(v6 + 60) == 1315774496)
  {
    unsigned int v7 = 0;
  }
  else
  {
    int v8 = 0;
    do
      unsigned int v7 = (unsigned __int16)++v8;
    while (*(_DWORD *)(v6 + 88 * (unsigned __int16)v8 + 60) != 1315774496);
  }
  uint64_t v9 = *(void *)(v6 + 88 * v7 + 80);
  *((void *)a2 + 1) = 0;
  uint64_t v10 = *(const void **)(v9 + 64);
  CPSDString::AllocateCharData(a2, *(_DWORD *)(v9 + 56));
  size_t v11 = (void *)*((void *)a2 + 1);
  size_t v12 = (2 * *(_DWORD *)a2);
  return memcpy(v11, v10, v12);
}

uint64_t CPSDGradientDescriptor::GetOffset(uint64_t this, double *a2, double *a3)
{
  unsigned int v3 = *(_DWORD *)(this + 88);
  if (!v3) {
    goto LABEL_11;
  }
  unsigned __int16 v4 = 0;
  uint64_t v5 = *(void *)(this + 96);
  while (*(_DWORD *)(v5 + 88 * v4 + 60) != 1332114292)
  {
    if (v3 <= ++v4) {
      goto LABEL_11;
    }
  }
  uint64_t v6 = *(void *)(v5 + 88 * v4 + 80);
  if (v6)
  {
    unsigned __int16 v7 = 0;
    unsigned int v8 = *(_DWORD *)(v6 + 88);
    uint64_t v9 = *(void *)(v6 + 96);
    while (*(_DWORD *)(v9 + 88 * v7 + 60) != 1215461998)
    {
      if (v8 <= ++v7)
      {
        uint64_t v10 = 0;
        goto LABEL_14;
      }
    }
    uint64_t v10 = *(void *)(v9 + 88 * v7 + 80);
LABEL_14:
    if (*(_DWORD *)(v9 + 60) == 1450341475)
    {
      unsigned int v12 = 0;
    }
    else
    {
      int v13 = 0;
      do
        unsigned int v12 = (unsigned __int16)++v13;
      while (*(_DWORD *)(v9 + 88 * (unsigned __int16)v13 + 60) != 1450341475);
    }
    uint64_t v14 = *(void *)(v9 + 88 * v12 + 80);
    *a2 = *(double *)(v10 + 64);
    uint64_t v11 = *(void *)(v14 + 64);
  }
  else
  {
LABEL_11:
    *a2 = 0.0;
    uint64_t v11 = 0;
  }
  *(void *)a3 = v11;
  return this;
}

double CPSDGradientDescriptor::GetScale(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  double result = 1.0;
  if (v1)
  {
    unsigned __int16 v3 = 0;
    uint64_t v4 = *((void *)this + 12);
    while (*(_DWORD *)(v4 + 88 * v3 + 60) != 1399024672)
    {
      if (v1 <= ++v3) {
        return result;
      }
    }
    uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
    if (v5) {
      return *(double *)(v5 + 64) / 100.0;
    }
  }
  return result;
}

uint64_t CPSDGradientDescriptor::GetType(CPSDGradientDescriptor *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (v1)
  {
    unsigned __int16 v2 = 0;
    uint64_t v3 = *((void *)this + 12);
    while (*(_DWORD *)(v3 + 88 * v2 + 60) != 1198678372)
    {
      if (v1 <= ++v2) {
        goto LABEL_5;
      }
    }
    uint64_t v4 = *(void *)(v3 + 88 * v2 + 80);
  }
  else
  {
LABEL_5:
    uint64_t v4 = 0;
  }
  unsigned int v5 = *(_DWORD *)(v4 + 88);
  if (v5)
  {
    unsigned __int16 v6 = 0;
    uint64_t v7 = *(void *)(v4 + 96);
    while (*(_DWORD *)(v7 + 88 * v6 + 60) != 1198679110)
    {
      if (v5 <= ++v6) {
        goto LABEL_11;
      }
    }
    unsigned int v8 = *(CPSDOSTypeEnumerated **)(v7 + 88 * v6 + 80);
  }
  else
  {
LABEL_11:
    unsigned int v8 = 0;
  }
  int Enum = CPSDOSTypeEnumerated::GetEnum(v8);
  if (Enum == 1131171443) {
    unsigned int v10 = 1;
  }
  else {
    unsigned int v10 = 2;
  }
  if (Enum == 1131639891) {
    return 0;
  }
  else {
    return v10;
  }
}

uint64_t CPSDGradientFillInfo::Load(CPSDGradientFillInfo *this, uint64_t a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 128, 4uLL, &v5);
  *((_DWORD *)this + 32) = bswap32(*((_DWORD *)this + 32));
  return CPSDGradientDescriptor::Load(this, a2);
}

uint64_t CPSDGradientFillInfo::Save(CPSDGradientFillInfo *this, File *a2)
{
  CPSDAdditionalLayerInfoItem::Save(this, a2);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 32));
  return CPSDActionDescriptor::Save(this, a2);
}

size_t CPSDGradientFillInfo::Dump(CPSDGradientFillInfo *this, __sFILE *a2)
{
  fprintf(a2, "{ GradientFillInfo: version=%d\n", *((_DWORD *)this + 32));
  fputs("Dump: ActionBaseComponent\n", a2);
  return fwrite("} // End GradientFillInfo\n", 0x1AuLL, 1uLL, a2);
}

uint64_t CPSDColorFillInfo::Load(CPSDColorFillInfo *this, uint64_t a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 120, 4uLL, &v5);
  *((_DWORD *)this + 30) = bswap32(*((_DWORD *)this + 30));
  CPSDActionDescriptor::Load(this, a2);
  return 1;
}

uint64_t CPSDColorFillInfo::Save(CPSDColorFillInfo *this, File *a2)
{
  CPSDAdditionalLayerInfoItem::Save(this, a2);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 30));
  return CPSDActionDescriptor::Save(this, a2);
}

size_t CPSDColorFillInfo::Dump(CPSDColorFillInfo *this, __sFILE *a2)
{
  fprintf(a2, "{ ColorFillInfo: version=%d\n", *((_DWORD *)this + 30));
  return fwrite("} // End ColorFillInfo\n", 0x17uLL, 1uLL, a2);
}

void CPSDObjectEffectsLayerInfo::~CPSDObjectEffectsLayerInfo(CPSDObjectEffectsLayerInfo *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

CPSDActionKeyedItem *CPSDObjectEffectsLayerInfo::MakeOffsetItem(CPSDObjectEffectsLayerInfo *this, float a2, float a3)
{
  int v5 = (CPSDActionDescriptor *)operator new();
  CPSDActionDescriptor::CPSDActionDescriptor(v5);
  *((_DWORD *)v5 + 21) = 1349415968;
  uint64_t v6 = operator new();
  *(_DWORD *)(v6 + 16) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(void *)uint64_t v6 = &unk_1EF486658;
  *(_DWORD *)(v6 + 56) = 592474723;
  *(double *)(v6 + 64) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v11, 1215461998, (CPSDActionBaseComponent *)v6);
  CPSDActionDescriptor::AdoptItem(v5, (CPSDActionKeyedItem *)v11);
  uint64_t v7 = operator new();
  *(_DWORD *)(v7 + 16) = 0;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(void *)uint64_t v7 = &unk_1EF486658;
  *(_DWORD *)(v7 + 56) = 592474723;
  *(double *)(v7 + 64) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v10, 1450341475, (CPSDActionBaseComponent *)v7);
  CPSDActionDescriptor::AdoptItem(v5, (CPSDActionKeyedItem *)v10);
  unsigned int v8 = (CPSDActionKeyedItem *)operator new();
  CPSDActionKeyedItem::CPSDActionKeyedItem(v8, 1332114292, v5);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v10);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v11);
  return v8;
}

void sub_1A1347264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  uint64_t v21 = v20;
  MEMORY[0x1A6230DF0](v21, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a9);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a20);
  _Unwind_Resume(a1);
}

uint64_t CPSDActionDescriptor::AdoptItem(CPSDActionDescriptor *this, CPSDActionKeyedItem *a2)
{
  unint64_t v3 = *((void *)this + 13);
  if (v3 >= *((void *)this + 14))
  {
    uint64_t result = std::vector<CPSDActionKeyedItem>::__push_back_slow_path<CPSDActionKeyedItem>((uint64_t *)this + 12, (uint64_t)a2);
  }
  else
  {
    *(_DWORD *)(v3 + 16) = 0;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    uint64_t v4 = *((void *)a2 + 1);
    *(void *)unint64_t v3 = &unk_1EF486570;
    *(void *)(v3 + 8) = v4;
    long long v5 = *((_OWORD *)a2 + 1);
    *(void *)(v3 + 32) = *((void *)a2 + 4);
    *(_OWORD *)(v3 + 16) = v5;
    *(_OWORD *)(v3 + 40) = *(_OWORD *)((char *)a2 + 40);
    long long v6 = *(_OWORD *)((char *)a2 + 56);
    *(_OWORD *)(v3 + 72) = *(_OWORD *)((char *)a2 + 72);
    *(_OWORD *)(v3 + 56) = v6;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 8) = 0;
    uint64_t result = v3 + 88;
  }
  *((void *)this + 13) = result;
  ++*((_DWORD *)this + 22);
  return result;
}

CPSDActionKeyedItem *CPSDObjectEffectsLayerInfo::MakeRGBColor(CPSDObjectEffectsLayerInfo *this, double a2, double a3, double a4)
{
  uint64_t v7 = (CPSDActionDescriptor *)operator new();
  CPSDActionDescriptor::CPSDActionDescriptor(v7);
  *((_DWORD *)v7 + 21) = 1380401731;
  uint64_t v8 = operator new();
  *(_DWORD *)(v8 + 16) = 0;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(void *)uint64_t v8 = &unk_1EF486170;
  *(double *)(v8 + 56) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v15, 1382293536, (CPSDActionBaseComponent *)v8);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v15);
  uint64_t v9 = operator new();
  *(_DWORD *)(v9 + 16) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *(void *)uint64_t v9 = &unk_1EF486170;
  *(double *)(v9 + 56) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v14, 1198681632, (CPSDActionBaseComponent *)v9);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v14);
  uint64_t v10 = operator new();
  *(_DWORD *)(v10 + 16) = 0;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(void *)uint64_t v10 = &unk_1EF486170;
  *(double *)(v10 + 56) = a4;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v13, 1114382368, (CPSDActionBaseComponent *)v10);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v13);
  uint64_t v11 = (CPSDActionKeyedItem *)operator new();
  CPSDActionKeyedItem::CPSDActionKeyedItem(v11, 1131180576, v7);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v13);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v14);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v15);
  return v11;
}

void sub_1A1347574(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v4 = v2;
  MEMORY[0x1A6230DF0](v4, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v3 - 152));
  _Unwind_Resume(a1);
}

CPSDActionDescriptor *CPSDObjectEffectsLayerInfo::MakeColorStopObject(CPSDObjectEffectsLayerInfo *this, int a2, int a3, double a4, double a5, double a6)
{
  uint64_t v11 = (CPSDActionDescriptor *)operator new();
  CPSDActionDescriptor::CPSDActionDescriptor(v11);
  *((_DWORD *)v11 + 21) = 1131180660;
  RGBColor = CPSDObjectEffectsLayerInfo::MakeRGBColor(v12, a4, a5, a6);
  CPSDActionDescriptor::AdoptItem(v11, RGBColor);
  uint64_t v14 = operator new();
  *(_DWORD *)(v14 + 16) = 0;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(void *)uint64_t v14 = &unk_1EF486848;
  *(void *)(v14 + 56) = 0;
  *(void *)(v14 + 88) = 0;
  *(_DWORD *)(v14 + 64) = 1131180665;
  *(_DWORD *)(v14 + 80) = 1433629267;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v20, 1417244773, (CPSDActionBaseComponent *)v14);
  CPSDActionDescriptor::AdoptItem(v11, (CPSDActionKeyedItem *)v20);
  uint64_t v15 = operator new();
  *(_DWORD *)(v15 + 16) = 0;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(void *)uint64_t v15 = &unk_1EF486388;
  *(_DWORD *)(v15 + 56) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v19, 1281586286, (CPSDActionBaseComponent *)v15);
  CPSDActionDescriptor::AdoptItem(v11, (CPSDActionKeyedItem *)v19);
  uint64_t v16 = operator new();
  *(_DWORD *)(v16 + 16) = 0;
  *(_OWORD *)(v16 + 24) = 0u;
  *(_OWORD *)(v16 + 40) = 0u;
  *(void *)uint64_t v16 = &unk_1EF486388;
  *(_DWORD *)(v16 + 56) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v18, 1298428014, (CPSDActionBaseComponent *)v16);
  CPSDActionDescriptor::AdoptItem(v11, (CPSDActionKeyedItem *)v18);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v18);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v19);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v20);
  return v11;
}

void sub_1A1347804(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v2 - 168));
  _Unwind_Resume(a1);
}

CPSDActionDescriptor *CPSDObjectEffectsLayerInfo::MakeTransparencyStopObject(CPSDObjectEffectsLayerInfo *this, int a2, int a3, float a4)
{
  uint64_t v7 = (CPSDActionDescriptor *)operator new();
  CPSDActionDescriptor::CPSDActionDescriptor(v7);
  *((_DWORD *)v7 + 21) = 1416785491;
  uint64_t v8 = operator new();
  *(_DWORD *)(v8 + 16) = 0;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(void *)uint64_t v8 = &unk_1EF486658;
  *(_DWORD *)(v8 + 56) = 592474723;
  *(double *)(v8 + 64) = a4;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v14, 1332765556, (CPSDActionBaseComponent *)v8);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v14);
  uint64_t v9 = operator new();
  *(_DWORD *)(v9 + 16) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *(void *)uint64_t v9 = &unk_1EF486388;
  *(_DWORD *)(v9 + 56) = a2;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v13, 1281586286, (CPSDActionBaseComponent *)v9);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v13);
  uint64_t v10 = operator new();
  *(_DWORD *)(v10 + 16) = 0;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(void *)uint64_t v10 = &unk_1EF486388;
  *(_DWORD *)(v10 + 56) = a3;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v12, 1298428014, (CPSDActionBaseComponent *)v10);
  CPSDActionDescriptor::AdoptItem(v7, (CPSDActionKeyedItem *)v12);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v12);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v13);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v14);
  return v7;
}

void sub_1A1347A30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)va1);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v2 - 136));
  _Unwind_Resume(a1);
}

CPSDOSTypeList *CPSDObjectEffectsLayerInfo::MakeColorStopList(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new();
  uint64_t v4 = (CPSDOSTypeList *)v3;
  *(_DWORD *)(v3 + 16) = 0;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(void *)uint64_t v3 = &unk_1EF485FE8;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_DWORD *)(v3 + 60) = 1331849827;
  uint64_t v5 = *(void *)(a2 + 96) - *(void *)(a2 + 88);
  if (v5)
  {
    uint64_t v6 = 0;
    unint64_t v7 = v5 >> 5;
    if (v7 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7;
    }
    do
    {
      uint64_t v9 = *(void *)(a2 + 88) + v6;
      ColorStopObject = CPSDObjectEffectsLayerInfo::MakeColorStopObject((CPSDObjectEffectsLayerInfo *)v3, *(_DWORD *)(v9 + 24), *(_DWORD *)(v9 + 28), *(double *)v9, *(double *)(v9 + 8), *(double *)(v9 + 16));
      CPSDOSTypeList::AdoptItem(v4, ColorStopObject);
      v6 += 32;
      --v8;
    }
    while (v8);
  }
  return v4;
}

void CPSDOSTypeList::AdoptItem(CPSDOSTypeList *this, CPSDActionBaseComponent *a2)
{
  unint64_t v6 = *((void *)this + 10);
  uint64_t v4 = (char *)this + 80;
  unint64_t v5 = v6;
  unint64_t v7 = (void *)*((void *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = (void **)(v4 - 16);
    uint64_t v10 = *((void *)v4 - 2);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - v10;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
      uint64_t v13 = v11 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerChannelGroup *>>((uint64_t)v4, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *(void *)uint64_t v16 = a2;
    uint64_t v8 = v16 + 8;
    unsigned int v19 = (char *)*((void *)this + 8);
    int v18 = (char *)*((void *)this + 9);
    if (v18 != v19)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      int v18 = (char *)*v9;
    }
    *((void *)this + 8) = v16;
    *((void *)this + 9) = v8;
    *((void *)this + 10) = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *unint64_t v7 = a2;
    uint64_t v8 = v7 + 1;
  }
  *((void *)this + 9) = v8;
  ++*((_DWORD *)this + 14);
}

CPSDOSTypeList *CPSDObjectEffectsLayerInfo::MakeTransparencyStopList(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new();
  uint64_t v4 = (CPSDOSTypeList *)v3;
  *(_DWORD *)(v3 + 16) = 0;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(void *)uint64_t v3 = &unk_1EF485FE8;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_DWORD *)(v3 + 60) = 1331849827;
  uint64_t v5 = *(void *)(a2 + 120) - *(void *)(a2 + 112);
  if (v5)
  {
    uint64_t v6 = 0;
    unint64_t v7 = v5 >> 4;
    if (v7 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7;
    }
    do
    {
      uint64_t v9 = *(void *)(a2 + 112) + v6;
      float v10 = *(double *)v9;
      TransparencyStopObject = CPSDObjectEffectsLayerInfo::MakeTransparencyStopObject((CPSDObjectEffectsLayerInfo *)v3, *(_DWORD *)(v9 + 8), *(_DWORD *)(v9 + 12), v10);
      CPSDOSTypeList::AdoptItem(v4, TransparencyStopObject);
      v6 += 16;
      --v8;
    }
    while (v8);
  }
  return v4;
}

CPSDActionKeyedItem *CPSDObjectEffectsLayerInfo::MakeGradientDescriptor(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (CPSDActionDescriptor *)operator new();
  CPSDActionDescriptor::CPSDActionDescriptor(v3, "Gradient", 1198679150);
  uint64_t v4 = (CPSDActionKeyedItem *)operator new();
  uint64_t v5 = (CPSDOSTypeText *)operator new();
  CPSDOSTypeText::CPSDOSTypeText(v5, "Custom");
  CPSDActionKeyedItem::CPSDActionKeyedItem(v4, 1315774496, v5);
  CPSDActionDescriptor::AdoptItem(v3, v4);
  uint64_t v6 = operator new();
  *(_DWORD *)(v6 + 16) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(void *)uint64_t v6 = &unk_1EF486848;
  *(void *)(v6 + 56) = 0;
  *(void *)(v6 + 88) = 0;
  *(_DWORD *)(v6 + 64) = 1198679110;
  *(_DWORD *)(v6 + 80) = 1131639891;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v18, 1198679110, (CPSDActionBaseComponent *)v6);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v18);
  uint64_t v7 = operator new();
  uint64_t v8 = *(void *)(a2 + 8);
  *(_DWORD *)(v7 + 16) = 0;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(void *)uint64_t v7 = &unk_1EF486170;
  *(void *)(v7 + 56) = v8;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v17, 1231975538, (CPSDActionBaseComponent *)v7);
  uint64_t v9 = CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v17);
  ColorStopList = CPSDObjectEffectsLayerInfo::MakeColorStopList(v9, a2);
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v16, 1131180659, ColorStopList);
  uint64_t v11 = CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v16);
  TransparencyStopList = CPSDObjectEffectsLayerInfo::MakeTransparencyStopList(v11, a2);
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v15, 1416785523, TransparencyStopList);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v15);
  uint64_t v13 = (CPSDActionKeyedItem *)operator new();
  CPSDActionKeyedItem::CPSDActionKeyedItem(v13, 1198678372, v3);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v15);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v16);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v17);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v18);
  return v13;
}

void sub_1A1347F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  MEMORY[0x1A6230DF0](v31, 0x10B1C40DEC6B036);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a9);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a20);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a31);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v32 - 136));
  _Unwind_Resume(a1);
}

void CPSDActionDescriptor::CPSDActionDescriptor(CPSDActionDescriptor *this, const char *a2, int a3)
{
  CPSDActionDescriptor::CPSDActionDescriptor(this);
  *(_DWORD *)(v6 + 84) = a3;
  CPSDString::CPSDString((CPSDString *)&v7, a2);
  CPSDString::operator=((CPSDActionDescriptor *)((char *)this + 56), (uint64_t)&v7);
  if (v8) {
    MEMORY[0x1A6230DD0](v8, 0x1000C80BDFB0063);
  }
}

void sub_1A13480C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x1A6230DD0](a10, 0x1000C80BDFB0063);
  }
  CPSDActionDescriptor::~CPSDActionDescriptor(v10);
  _Unwind_Resume(a1);
}

void CPSDOSTypeText::CPSDOSTypeText(CPSDOSTypeText *this, const char *a2)
{
  CPSDOSTypeText::CPSDOSTypeText(this);
  CPSDString::CPSDString((CPSDString *)&v4, a2);
  CPSDString::operator=((CPSDOSTypeText *)((char *)this + 56), (uint64_t)&v4);
  if (v5) {
    MEMORY[0x1A6230DD0](v5, 0x1000C80BDFB0063);
  }
}

void sub_1A1348160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x1A6230DD0](a10, 0x1000C80BDFB0063);
  }
  CPSDOSTypeText::~CPSDOSTypeText(v10);
  _Unwind_Resume(a1);
}

CPSDActionDescriptor *CPSDObjectEffectsLayerInfo::MakeGradientOverlayObject(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (CPSDActionDescriptor *)operator new();
  CPSDActionDescriptor::CPSDActionDescriptor(v3);
  *((_DWORD *)v3 + 21) = 1198671468;
  uint64_t v4 = operator new();
  *(_DWORD *)(v4 + 16) = 0;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(void *)uint64_t v4 = &unk_1EF486340;
  *(unsigned char *)(v4 + 56) = 1;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v31, 1701732706, (CPSDActionBaseComponent *)v4);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v31);
  uint64_t v5 = operator new();
  *(_DWORD *)(v5 + 16) = 0;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(void *)uint64_t v5 = &unk_1EF486848;
  *(void *)(v5 + 56) = 0;
  *(void *)(v5 + 88) = 0;
  *(_DWORD *)(v5 + 64) = 1114402381;
  *(_DWORD *)(v5 + 80) = 1316121964;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v30, 1298407456, (CPSDActionBaseComponent *)v5);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v30);
  uint64_t v6 = operator new();
  *(_DWORD *)(v6 + 16) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(void *)uint64_t v6 = &unk_1EF486658;
  *(_DWORD *)(v6 + 56) = 592474723;
  *(void *)(v6 + 64) = 0x4059000000000000;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v29, 1332765556, (CPSDActionBaseComponent *)v6);
  uint64_t v7 = CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v29);
  GradientDescriptor = CPSDObjectEffectsLayerInfo::MakeGradientDescriptor(v7, a2);
  CPSDActionDescriptor::AdoptItem(v3, GradientDescriptor);
  uint64_t v9 = operator new();
  uint64_t v10 = *(void *)a2;
  *(_DWORD *)(v9 + 16) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *(void *)uint64_t v9 = &unk_1EF486658;
  *(_DWORD *)(v9 + 56) = 591490663;
  *(void *)(v9 + 64) = v10;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v28, 1097754476, (CPSDActionBaseComponent *)v9);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v28);
  uint64_t v11 = operator new();
  int v12 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(v11 + 16) = 0;
  *(_OWORD *)(v11 + 24) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(void *)uint64_t v11 = &unk_1EF486848;
  *(void *)(v11 + 56) = 0;
  *(void *)(v11 + 88) = 0;
  *(_DWORD *)(v11 + 64) = 1198679124;
  *(_DWORD *)(v11 + 80) = v12;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v27, 1417244773, (CPSDActionBaseComponent *)v11);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v27);
  uint64_t v13 = operator new();
  char v14 = *(unsigned char *)(a2 + 16);
  *(_DWORD *)(v13 + 16) = 0;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *(void *)uint64_t v13 = &unk_1EF486340;
  *(unsigned char *)(v13 + 56) = v14;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v26, 1383494259, (CPSDActionBaseComponent *)v13);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v26);
  uint64_t v15 = operator new();
  char v16 = *(unsigned char *)(a2 + 17);
  *(_DWORD *)(v15 + 16) = 0;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(void *)uint64_t v15 = &unk_1EF486340;
  *(unsigned char *)(v15 + 56) = v16;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v25, 1148479602, (CPSDActionBaseComponent *)v15);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v25);
  uint64_t v17 = operator new();
  char v18 = *(unsigned char *)(a2 + 18);
  *(_DWORD *)(v17 + 16) = 0;
  *(_OWORD *)(v17 + 24) = 0u;
  *(_OWORD *)(v17 + 40) = 0u;
  *(void *)uint64_t v17 = &unk_1EF486340;
  *(unsigned char *)(v17 + 56) = v18;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v24, 1097623406, (CPSDActionBaseComponent *)v17);
  CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v24);
  uint64_t v19 = operator new();
  *(_DWORD *)(v19 + 16) = 0;
  *(_OWORD *)(v19 + 24) = 0u;
  *(_OWORD *)(v19 + 40) = 0u;
  *(void *)uint64_t v19 = &unk_1EF486658;
  *(_DWORD *)(v19 + 56) = 592474723;
  *(void *)(v19 + 64) = 0x4059000000000000;
  CPSDActionKeyedItem::CPSDActionKeyedItem((CPSDActionKeyedItem *)v23, 1399024672, (CPSDActionBaseComponent *)v19);
  uint64_t v20 = (CPSDObjectEffectsLayerInfo *)CPSDActionDescriptor::AdoptItem(v3, (CPSDActionKeyedItem *)v23);
  OffsetItem = CPSDObjectEffectsLayerInfo::MakeOffsetItem(v20, 0.0, 0.0);
  CPSDActionDescriptor::AdoptItem(v3, OffsetItem);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v23);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v24);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v25);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v26);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v27);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v28);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v29);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v30);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)v31);
  return v3;
}

void sub_1A1348680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a10);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a21);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a32);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a43);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a54);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&a65);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)&STACK[0x218]);
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v65 - 208));
  CPSDActionKeyedItem::~CPSDActionKeyedItem((CPSDActionKeyedItem *)(v65 - 120));
  _Unwind_Resume(a1);
}

uint64_t CPSDObjectEffectsLayerInfo::Load(CPSDObjectEffectsLayerInfo *this, uint64_t a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 120, 4uLL, &v5);
  *((_DWORD *)this + 30) = bswap32(*((_DWORD *)this + 30));
  CPSDBaseComponent::ReadFile(a2, (char *)this + 124, 4uLL, &v5);
  *((_DWORD *)this + 31) = bswap32(*((_DWORD *)this + 31));
  CPSDActionDescriptor::Load(this, a2);
  return 1;
}

uint64_t CPSDObjectEffectsLayerInfo::Save(CPSDObjectEffectsLayerInfo *this, File *a2)
{
  CPSDAdditionalLayerInfoItem::Save(this, a2);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 30));
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 31));
  return CPSDActionDescriptor::Save(this, a2);
}

size_t CPSDObjectEffectsLayerInfo::Dump(CPSDObjectEffectsLayerInfo *this, __sFILE *a2)
{
  fprintf(a2, "{ ObjectEffectsLayerInfo: objectEffectsVersion=%d, descriptorVersion=%d\n", *((_DWORD *)this + 30), *((_DWORD *)this + 31));
  double Scale = CPSDGradientDescriptor::GetScale(this);
  fprintf(a2, "\tScale: %.0f%%\n", Scale * 100.0);
  uint64_t ItemForKeyString = CPSDActionDescriptor::GetItemForKeyString(this, "masterFXSwitch");
  if (ItemForKeyString && *(unsigned char *)(ItemForKeyString + 56)) {
    uint64_t v6 = "YES";
  }
  else {
    uint64_t v6 = "NO";
  }
  fprintf(a2, "\tMasterFXSwitch: %s\n", v6);
  fwrite("\tEffects:\n", 0xAuLL, 1uLL, a2);
  unsigned int v7 = *((_DWORD *)this + 22);
  if (v7)
  {
    unsigned __int16 v8 = 0;
    uint64_t v9 = *((void *)this + 12);
    while (*(_DWORD *)(v9 + 88 * v8 + 60) != 1198671468)
    {
      if (v7 <= ++v8) {
        goto LABEL_14;
      }
    }
    uint64_t v10 = *(void *)(v9 + 88 * v8 + 80);
    if (v10)
    {
      fwrite("\t\tGradient Overlay", 0x12uLL, 1uLL, a2);
      unsigned int BlendModeForEffect = CPSDObjectEffectsLayerInfo::GetBlendModeForEffect((uint64_t)this, 1198671468);
      int IsEnabledForEffect = CPSDObjectEffectsLayerInfo::GetIsEnabledForEffect((uint64_t)this, 1198671468);
      uint64_t v13 = "YES";
      if (!IsEnabledForEffect) {
        uint64_t v13 = "NO";
      }
      fprintf(a2, " <isEnabled: %s>\n", v13);
      unsigned int v24 = bswap32(BlendModeForEffect);
      double OpacityForEffect = CPSDObjectEffectsLayerInfo::GetOpacityForEffect((uint64_t)this, 1198671468);
      fprintf(a2, "\t\t\tBlend Mode: '%.4s'\n\t\t\tOpacity: %.0f%%\n", (const char *)&v24, OpacityForEffect);
      (*(void (**)(uint64_t, __sFILE *, uint64_t))(*(void *)v10 + 48))(v10, a2, 3);
      unsigned int v7 = *((_DWORD *)this + 22);
      if (!v7) {
        return fwrite("} // End ObjectEffectsLayerInfo\n", 0x20uLL, 1uLL, a2);
      }
    }
LABEL_14:
    unsigned __int16 v15 = 0;
    uint64_t v16 = *((void *)this + 12);
    while (*(_DWORD *)(v16 + 88 * v15 + 60) != 1148343144)
    {
      if (v7 <= ++v15) {
        return fwrite("} // End ObjectEffectsLayerInfo\n", 0x20uLL, 1uLL, a2);
      }
    }
    uint64_t v17 = *(CPSDDropShadowDescriptor **)(v16 + 88 * v15 + 80);
    if (v17)
    {
      fwrite("\t\tDrop Shadow", 0xDuLL, 1uLL, a2);
      unsigned int BlendMode = CPSDDropShadowDescriptor::GetBlendMode(v17);
      int v19 = CPSDObjectEffectsLayerInfo::GetIsEnabledForEffect((uint64_t)this, 1148343144);
      uint64_t v20 = "YES";
      if (!v19) {
        uint64_t v20 = "NO";
      }
      fprintf(a2, " <isEnabled: %s>\n", v20);
      unsigned int v23 = bswap32(BlendMode);
      double Opacity = CPSDDropShadowDescriptor::GetOpacity(v17);
      fprintf(a2, "\t\t\tBlend Mode: '%.4s'\n\t\t\tOpacity: %.0f%%\n", (const char *)&v23, Opacity);
      (*(void (**)(CPSDDropShadowDescriptor *, __sFILE *, uint64_t))(*(void *)v17 + 56))(v17, a2, 3);
    }
  }
  return fwrite("} // End ObjectEffectsLayerInfo\n", 0x20uLL, 1uLL, a2);
}

uint64_t CPSDObjectEffectsLayerInfo::GetMasterEffectsSwitch(CPSDObjectEffectsLayerInfo *this)
{
  uint64_t result = CPSDActionDescriptor::GetItemForKeyString(this, "masterFXSwitch");
  if (result) {
    return *(unsigned __int8 *)(result + 56);
  }
  return result;
}

uint64_t CPSDObjectEffectsLayerInfo::GetIsEnabledForEffect(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 88);
  if (!v2) {
    return 0;
  }
  unsigned __int16 v3 = 0;
  uint64_t v4 = *(void *)(a1 + 96);
  while (*(_DWORD *)(v4 + 88 * v3 + 60) != a2)
  {
    if (v2 <= ++v3) {
      return 0;
    }
  }
  uint64_t v5 = *(void *)(v4 + 88 * v3 + 80);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = *(void *)(v5 + 96);
  if (*(_DWORD *)(v6 + 60) == 1701732706)
  {
    unsigned int v7 = 0;
  }
  else
  {
    int v9 = 0;
    do
      unsigned int v7 = (unsigned __int16)++v9;
    while (*(_DWORD *)(v6 + 88 * (unsigned __int16)v9 + 60) != 1701732706);
  }
  return *(unsigned __int8 *)(*(void *)(v6 + 88 * v7 + 80) + 56);
}

uint64_t CPSDUnicodeLayerName::Load(CPSDUnicodeLayerName *this, int a2)
{
  unsigned int v9 = 0;
  uint64_t v4 = (_DWORD *)((char *)this + 56);
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v9);
  unsigned int v5 = bswap32(*((_DWORD *)this + 14));
  *((_DWORD *)this + 14) = v5;
  uint64_t result = (uint64_t)malloc_type_calloc(v5 + 1, 2uLL, 0x1000040BDFB0063uLL);
  *((void *)this + 8) = result;
  if (result)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)result, (2 * *v4), &v9);
    if (v9 >= 2)
    {
      unint64_t v7 = (unint64_t)v9 >> 1;
      unsigned __int16 v8 = (_WORD *)*((void *)this + 8);
      do
      {
        *unsigned __int16 v8 = bswap32((unsigned __int16)*v8) >> 16;
        ++v8;
        --v7;
      }
      while (v7);
    }
    return 1;
  }
  return result;
}

uint64_t CPSDUnicodeLayerName::Load(CPSDUnicodeLayerName *this, int a2, int a3)
{
  *((_DWORD *)this + 14) = a3;
  uint64_t result = (uint64_t)malloc_type_calloc((a3 + 1), 2uLL, 0x1000040BDFB0063uLL);
  *((void *)this + 8) = result;
  if (result)
  {
    unsigned int v8 = 0;
    fprintf(__stderrp, "length of unicode string: %d\n", *((_DWORD *)this + 14));
    CPSDBaseComponent::ReadFile(a2, *((char **)this + 8), (2 * *((_DWORD *)this + 14)), &v8);
    if (v8 >= 2)
    {
      unint64_t v6 = (unint64_t)v8 >> 1;
      unint64_t v7 = (_WORD *)*((void *)this + 8);
      do
      {
        *unint64_t v7 = bswap32((unsigned __int16)*v7) >> 16;
        ++v7;
        --v6;
      }
      while (v6);
    }
    return 1;
  }
  return result;
}

uint64_t CPSDUnicodeLayerName::Save(CPSDUnicodeLayerName *this, File *a2)
{
  CPSDAdditionalLayerInfoItem::Save(this, a2);
  (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  uint64_t v4 = *((void *)this + 8);
  uint64_t v5 = *((unsigned int *)this + 14);
  unint64_t v6 = *(uint64_t (**)(File *, uint64_t, uint64_t))(*(void *)a2 + 40);
  return v6(a2, v4, v5);
}

void CPSDUnicodeLayerName::~CPSDUnicodeLayerName(CPSDUnicodeLayerName *this)
{
  *(void *)this = &unk_1EF486890;
  unsigned int v2 = (void *)*((void *)this + 8);
  if (v2) {
    free(v2);
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  uint64_t vars8;

  CPSDUnicodeLayerName::~CPSDUnicodeLayerName(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(CPSDAdditionalLayerInfoItem *this)
{
  *(void *)this = &unk_1EF486F60;
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1EF486200;
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
  }
}

{
  uint64_t vars8;

  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDSectionDivider::Load(CPSDSectionDivider *this, int a2)
{
  int v5 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 4uLL, &v5);
  *((_DWORD *)this + 14) = bswap32(*((_DWORD *)this + 14));
  if (*((_DWORD *)this + 4) >= 0xCu)
  {
    CPSDBaseComponent::ReadFile(a2, (char *)this + 60, 4uLL, &v5);
    *((_DWORD *)this + 15) = bswap32(*((_DWORD *)this + 15));
    CPSDBaseComponent::ReadFile(a2, (char *)this + 64, 4uLL, &v5);
    *((_DWORD *)this + 16) = bswap32(*((_DWORD *)this + 16));
  }
  return 1;
}

uint64_t CPSDSectionDivider::Save(CPSDSectionDivider *this, File *a2)
{
  CPSDAdditionalLayerInfoItem::Save(this, a2);
  uint64_t result = (*(uint64_t (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 14));
  if (*((_DWORD *)this + 4) >= 0xCu)
  {
    (*(void (**)(File *, void))(*(void *)a2 + 80))(a2, *((unsigned int *)this + 15));
    uint64_t v5 = *((unsigned int *)this + 16);
    unint64_t v6 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 80);
    return v6(a2, v5);
  }
  return result;
}

uint64_t CPSDFillOpacityObject::Load(CPSDFillOpacityObject *this, int a2)
{
  int v3 = 0;
  CPSDBaseComponent::ReadFile(a2, (char *)this + 56, 1uLL, &v3);
  return 1;
}

uint64_t CPSDFillOpacityObject::Save(CPSDFillOpacityObject *this, File *a2)
{
  CPSDAdditionalLayerInfoItem::Save(this, a2);
  uint64_t v4 = *((unsigned __int8 *)this + 56);
  uint64_t v5 = *(uint64_t (**)(File *, uint64_t))(*(void *)a2 + 64);
  return v5(a2, v4);
}

uint64_t CPSDBaseComponent::Dump(CPSDBaseComponent *this, __sFILE *a2)
{
  return fputs("Dump: BaseComponent\n", a2);
}

uint64_t CPSDChannelImage::GetComponentChannels(CPSDChannelImage *this)
{
  return *((unsigned __int16 *)this + 12);
}

uint64_t CPSDChannelImage::GetChannelImageWidth(CPSDChannelImage *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t CPSDChannelImage::GetChannelImageHeight(CPSDChannelImage *this)
{
  return *((unsigned int *)this + 3);
}

void CPSDLayerImage::~CPSDLayerImage(CPSDLayerImage *this)
{
  *(void *)this = &unk_1EF486118;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF486118;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDLayerSliceImage::~CPSDLayerSliceImage(CPSDLayerSliceImage *this)
{
  *(void *)this = &unk_1EF486118;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF486118;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
  JUMPOUT(0x1A6230DF0);
}

size_t CPSDLayerSliceImage::Dump(CPSDLayerSliceImage *this, __sFILE *__stream)
{
  return fwrite("LayerSliceImage ", 0x10uLL, 1uLL, __stream);
}

void CPSDCompositeImage::~CPSDCompositeImage(CPSDCompositeImage *this)
{
  *(void *)this = &unk_1EF486118;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF486118;
  CPSDChannelImage::DeAllocateChannelBuffers(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDCompositeImage::FillChannelBuffers(CPSDCompositeImage *this)
{
  return 1;
}

void CPSDHeader::~CPSDHeader(CPSDHeader *this)
{
}

uint64_t CPSDImageResourceBlock::Load(CPSDImageResourceBlock *this)
{
  return 1;
}

void CPSDDummyResourceItem::~CPSDDummyResourceItem(CPSDDummyResourceItem *this)
{
  CPSDDummyResourceItem::~CPSDDummyResourceItem(this);
  JUMPOUT(0x1A6230DF0);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1EF486918;
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    MEMORY[0x1A6230DD0](v2, 0x1000C8077774924);
  }
  *(void *)this = &unk_1EF486200;
  int v3 = *((void *)this + 4);
  if (v3) {
    MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
  }
}

void CPSDICCProfileResourceItem::~CPSDICCProfileResourceItem(CPSDICCProfileResourceItem *this)
{
  CPSDICCProfileResourceItem::~CPSDICCProfileResourceItem(this);
  JUMPOUT(0x1A6230DF0);
}

{
  void *v2;
  uint64_t v3;

  *(void *)this = &unk_1EF486EC0;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2) {
    free(v2);
  }
  *(void *)this = &unk_1EF486200;
  int v3 = *((void *)this + 4);
  if (v3) {
    MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
  }
}

uint64_t CPSDICCProfileResourceItem::GetProfileSize(CPSDICCProfileResourceItem *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t CPSDICCProfileResourceItem::GetProfile(CPSDICCProfileResourceItem *this)
{
  return *((void *)this + 6);
}

void CPSDICCUntaggedResourceItem::~CPSDICCUntaggedResourceItem(CPSDICCUntaggedResourceItem *this)
{
  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDICCUntaggedResourceItem::GetUntagged(CPSDICCUntaggedResourceItem *this)
{
  return *((unsigned __int8 *)this + 48);
}

void CPSDGlobalAngleResourceItem::~CPSDGlobalAngleResourceItem(CPSDGlobalAngleResourceItem *this)
{
  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDGlobalAngleResourceItem::GetGlobalAngle(CPSDGlobalAngleResourceItem *this)
{
  return *((unsigned int *)this + 12);
}

void CPSDGlobalAltitudeResourceItem::~CPSDGlobalAltitudeResourceItem(CPSDGlobalAltitudeResourceItem *this)
{
  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDGlobalAltitudeResourceItem::GetGlobalAltitude(CPSDGlobalAltitudeResourceItem *this)
{
  return *((unsigned int *)this + 12);
}

void CPSDSliceResource::~CPSDSliceResource(CPSDSliceResource *this)
{
  CPSDSliceResource::~CPSDSliceResource(this);
  JUMPOUT(0x1A6230DF0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(void *)this = &unk_1EF4863D0;
  uint64_t v2 = *((void *)this + 19);
  if (v2)
  {
    MEMORY[0x1A6230DD0](v2, 0x1000C80BDFB0063);
    *((void *)this + 19) = 0;
  }
  int v3 = *((void *)this + 16);
  if (v3)
  {
    MEMORY[0x1A6230DD0](v3, 0x1000C80BDFB0063);
    *((void *)this + 16) = 0;
  }
  uint64_t v4 = *((void *)this + 14);
  if (v4)
  {
    MEMORY[0x1A6230DD0](v4, 0x1000C80BDFB0063);
    *((void *)this + 14) = 0;
  }
  uint64_t v5 = *((void *)this + 12);
  if (v5)
  {
    MEMORY[0x1A6230DD0](v5, 0x1000C80BDFB0063);
    *((void *)this + 12) = 0;
  }
  unint64_t v6 = *((void *)this + 10);
  if (v6)
  {
    MEMORY[0x1A6230DD0](v6, 0x1000C80BDFB0063);
    *((void *)this + 10) = 0;
  }
  unint64_t v7 = *((void *)this + 5);
  if (v7)
  {
    MEMORY[0x1A6230DD0](v7, 0x1000C80BDFB0063);
    *((void *)this + 5) = 0;
  }
}

uint64_t CPSDSliceResource::Load(CPSDSliceResource *this)
{
  return 0;
}

void CPSDUnicodeChannelNames::~CPSDUnicodeChannelNames(CPSDUnicodeChannelNames *this)
{
  CPSDUnicodeChannelNames::~CPSDUnicodeChannelNames(this);
  JUMPOUT(0x1A6230DF0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_1EF486D40;
  int v3 = (void **)((char *)this + 48);
  std::vector<CPSDString>::__destroy_vector::operator()[abi:ne180100](&v3);
  *(void *)this = &unk_1EF486200;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    MEMORY[0x1A6230DD0](v2, 0x1000C8077774924);
  }
}

void CPSDPathDataRecord::~CPSDPathDataRecord(CPSDPathDataRecord *this)
{
}

void CPSDSubpathLengthRecord::~CPSDSubpathLengthRecord(CPSDSubpathLengthRecord *this)
{
}

void CPSDBezierKnotRecord::~CPSDBezierKnotRecord(CPSDBezierKnotRecord *this)
{
}

void CPSDClipboardRecord::~CPSDClipboardRecord(CPSDClipboardRecord *this)
{
}

void CPSDInitialFillRecord::~CPSDInitialFillRecord(CPSDInitialFillRecord *this)
{
}

void CPSDPathResource::~CPSDPathResource(CPSDPathResource *this)
{
  *(void *)this = &unk_1EF4861B8;
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x20C8093837F09);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF4861B8;
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x20C8093837F09);
  }
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDPathResource::Load(CPSDPathResource *this)
{
  return 1;
}

uint64_t CPSDPathResource::Dump(CPSDPathResource *this, __sFILE *a2)
{
  return (*(uint64_t (**)(CPSDPathResource *, __sFILE *, void))(*(void *)this + 48))(this, a2, 0);
}

uint64_t CPSDResourceItem::Load(CPSDResourceItem *this)
{
  return 1;
}

void CPSDXMPResourceItem::~CPSDXMPResourceItem(CPSDXMPResourceItem *this)
{
  CPSDXMPResourceItem::~CPSDXMPResourceItem(this);
  JUMPOUT(0x1A6230DF0);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1EF4866A0;
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    MEMORY[0x1A6230DD0](v2, 0x1000C8077774924);
  }
  *(void *)this = &unk_1EF486200;
  int v3 = *((void *)this + 4);
  if (v3) {
    MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
  }
}

void CPSDChannelLengthInfo::~CPSDChannelLengthInfo(CPSDChannelLengthInfo *this)
{
}

void CPSDLayerMaskData::~CPSDLayerMaskData(CPSDLayerMaskData *this)
{
}

void CPSDVectorMaskData::~CPSDVectorMaskData(CPSDVectorMaskData *this)
{
  *(void *)this = &unk_1EF486530;
  CPSDPathsResourceItem::~CPSDPathsResourceItem((CPSDVectorMaskData *)((char *)this + 56));
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF486530;
  CPSDPathsResourceItem::~CPSDPathsResourceItem((CPSDVectorMaskData *)((char *)this + 56));
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDChannelBlendingInfo::~CPSDChannelBlendingInfo(CPSDChannelBlendingInfo *this)
{
}

void CPSDOSTypeInteger::~CPSDOSTypeInteger(CPSDOSTypeInteger *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDOSTypeDouble::~CPSDOSTypeDouble(CPSDOSTypeDouble *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDOSTypeBoolean::~CPSDOSTypeBoolean(CPSDOSTypeBoolean *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDOSTypeUnitFloat::~CPSDOSTypeUnitFloat(CPSDOSTypeUnitFloat *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDOSTypeEnumerated::~CPSDOSTypeEnumerated(CPSDOSTypeEnumerated *this)
{
  CPSDOSTypeEnumerated::~CPSDOSTypeEnumerated(this);
  JUMPOUT(0x1A6230DF0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF486848;
  if (*((_DWORD *)this + 14))
  {
    uint64_t v2 = *((void *)this + 9);
    if (v2) {
      MEMORY[0x1A6230DD0](v2, 0x1000C8077774924);
    }
  }
  if (*((_DWORD *)this + 15))
  {
    int v3 = *((void *)this + 11);
    if (v3) {
      MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
    }
  }
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
}

uint64_t CPSDUnicodeLayerName::Dump(const UniChar **this, __sFILE *a2)
{
  CPSDUnicodeLayerName::CopyStringValue(this, v5, 0x100u);
  return fprintf(a2, "{ UnicodeLayerName: %s mUnicodeLayerNameLength=%u }\n", v5, *((_DWORD *)this + 14));
}

void CPSDSectionDivider::~CPSDSectionDivider(CPSDSectionDivider *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDFillOpacityObject::~CPSDFillOpacityObject(CPSDFillOpacityObject *this)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDDropShadowDescriptor::~CPSDDropShadowDescriptor(CPSDDropShadowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDInnerShadowDescriptor::~CPSDInnerShadowDescriptor(CPSDInnerShadowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDInnerGlowDescriptor::~CPSDInnerGlowDescriptor(CPSDInnerGlowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDOuterGlowDescriptor::~CPSDOuterGlowDescriptor(CPSDOuterGlowDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDBevelEmbossDescriptor::~CPSDBevelEmbossDescriptor(CPSDBevelEmbossDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDColorOverlayDescriptor::~CPSDColorOverlayDescriptor(CPSDColorOverlayDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDGradientDescriptor::~CPSDGradientDescriptor(CPSDGradientDescriptor *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDGradientFillInfo::~CPSDGradientFillInfo(CPSDGradientFillInfo *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

void CPSDColorFillInfo::~CPSDColorFillInfo(CPSDColorFillInfo *this)
{
  CPSDActionDescriptor::~CPSDActionDescriptor(this);
  JUMPOUT(0x1A6230DF0);
}

uint64_t CPSDChannelData::Load(CPSDChannelData *this)
{
  return 0;
}

uint64_t CPSDChannelData::Dump(CPSDChannelData *this, __sFILE *a2)
{
  return fprintf(a2, "[%d] bytes;", *((_DWORD *)this + 4));
}

void CPSDLayerChannelGroup::~CPSDLayerChannelGroup(CPSDLayerChannelGroup *this)
{
  CPSDLayerChannelGroup::~CPSDLayerChannelGroup(this);
  JUMPOUT(0x1A6230DF0);
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(void *)this = &unk_1EF4869D8;
  uint64_t v1 = *((void *)this + 4);
  if (v1)
  {
    uint64_t v2 = v1 - 16;
    int v3 = *(void *)(v1 - 8);
    if (v3)
    {
      uint64_t v4 = v1 - 56;
      uint64_t v5 = 56 * v3;
      do
      {
        CPSDChannelData::~CPSDChannelData((CPSDChannelData *)(v4 + v5));
        v5 -= 56;
      }
      while (v5);
    }
    MEMORY[0x1A6230DD0](v2, 0x10B1C8014B8BDFCLL);
  }
}

size_t CPSDLayerChannelGroup::Dump(CPSDLayerChannelGroup *this, __sFILE *__stream)
{
  fwrite("ChannelData: {", 0xEuLL, 1uLL, __stream);
  if (*((_DWORD *)this + 6))
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      fprintf(__stream, "[%d] = ", v5);
      (*(void (**)(uint64_t, __sFILE *))(*(void *)(*((void *)this + 4) + v4) + 40))(*((void *)this + 4) + v4, __stream);
      ++v5;
      v4 += 56;
    }
    while (v5 < *((unsigned int *)this + 6));
  }
  return fwrite("}\n", 2uLL, 1uLL, __stream);
}

void CPSDGlobalLayerMaskInfo::~CPSDGlobalLayerMaskInfo(CPSDGlobalLayerMaskInfo *this)
{
}

uint64_t CPSDGlobalLayerMaskInfo::Load(CPSDGlobalLayerMaskInfo *this, int a2)
{
  return 1;
}

void CPSDLayerAndMaskInfo::~CPSDLayerAndMaskInfo(CPSDLayerAndMaskInfo *this)
{
  CPSDLayerAndMaskInfo::~CPSDLayerAndMaskInfo(this);
  JUMPOUT(0x1A6230DF0);
}

{
  uint64_t v2;

  *(void *)this = &unk_1EF4867C0;
  *((void *)this + 17) = &unk_1EF486B60;
  uint64_t v2 = *((void *)this + 20);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  CPSDLayerInfo::~CPSDLayerInfo((CPSDLayerAndMaskInfo *)((char *)this + 24));
}

uint64_t CPSDPathsResourceItem::Dump(CPSDPathsResourceItem *this, __sFILE *a2)
{
  return (*(uint64_t (**)(CPSDPathsResourceItem *, __sFILE *, void))(*(void *)this + 48))(this, a2, 0);
}

uint64_t CPSDImageLoad::Dump(CPSDImageLoad *this, __sFILE *a2)
{
  return fprintf(a2, "PSDImageLoad: { %dx%d x %d channels, mode = %d }\n", *((_DWORD *)this + 9), *((_DWORD *)this + 10), *((unsigned __int16 *)this + 22), *((unsigned __int16 *)this + 29));
}

uint64_t std::vector<CPSDLayerRecord>::__push_back_slow_path<CPSDLayerRecord>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x4FBCDA3AC10C9715 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x864B8A7DE6D1D6) {
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x4FBCDA3AC10C9715 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x4325C53EF368EBLL) {
    unint64_t v9 = 0x864B8A7DE6D1D6;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerRecord>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  char v14 = &v10[488 * v4];
  uint64_t v16 = &v10[488 * v9];
  CPSDLayerRecord::CPSDLayerRecord((uint64_t)v14, a2);
  unsigned __int16 v15 = v14 + 488;
  std::vector<CPSDLayerRecord>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_1A134A3B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CPSDLayerRecord::CPSDLayerRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = &unk_1EF4860D0;
  *(void *)(a1 + 8) = v4;
  long long v5 = *(_OWORD *)(a2 + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  uint64_t v6 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = &unk_1EF486300;
  *(void *)(a1 + 88) = v6;
  long long v7 = *(_OWORD *)(a2 + 96);
  long long v8 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 122) = *(_OWORD *)(a2 + 122);
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 112) = v8;
  uint64_t v9 = *(void *)(a2 + 152);
  *(void *)(a1 + 144) = &unk_1EF486C70;
  *(void *)(a1 + 152) = v9;
  uint64_t v10 = *(void *)(a2 + 160);
  LODWORD(v9) = *(_DWORD *)(a2 + 168);
  *(void *)(a1 + 176) = 0;
  uint64_t v11 = a1 + 176;
  *(_DWORD *)(v11 - 8) = v9;
  *(void *)(v11 - 16) = v10;
  *(void *)(v11 + 8) = 0;
  *(void *)(v11 + 16) = 0;
  std::vector<CPSDChannelBlendingInfo>::__init_with_size[abi:ne180100]<CPSDChannelBlendingInfo*,CPSDChannelBlendingInfo*>((char *)v11, *(void *)(a2 + 176), *(void *)(a2 + 184), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 184) - *(void *)(a2 + 176)) >> 3));
  long long v12 = *(_OWORD *)(a2 + 200);
  long long v13 = *(_OWORD *)(a2 + 216);
  long long v14 = *(_OWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v14;
  *(_OWORD *)(a1 + 216) = v13;
  *(_OWORD *)(a1 + 200) = v12;
  long long v15 = *(_OWORD *)(a2 + 264);
  long long v16 = *(_OWORD *)(a2 + 280);
  long long v17 = *(_OWORD *)(a2 + 312);
  *(_OWORD *)(a1 + 296) = *(_OWORD *)(a2 + 296);
  *(_OWORD *)(a1 + 312) = v17;
  *(_OWORD *)(a1 + 264) = v15;
  *(_OWORD *)(a1 + 280) = v16;
  long long v18 = *(_OWORD *)(a2 + 328);
  long long v19 = *(_OWORD *)(a2 + 344);
  long long v20 = *(_OWORD *)(a2 + 376);
  *(_OWORD *)(a1 + 360) = *(_OWORD *)(a2 + 360);
  *(_OWORD *)(a1 + 376) = v20;
  *(_OWORD *)(a1 + 328) = v18;
  *(_OWORD *)(a1 + 344) = v19;
  long long v21 = *(_OWORD *)(a2 + 392);
  long long v22 = *(_OWORD *)(a2 + 408);
  long long v23 = *(_OWORD *)(a2 + 440);
  *(_OWORD *)(a1 + 424) = *(_OWORD *)(a2 + 424);
  *(_OWORD *)(a1 + 440) = v23;
  *(_OWORD *)(a1 + 392) = v21;
  *(_OWORD *)(a1 + 408) = v22;
  *(void *)(a1 + 456) = &unk_1EF486B60;
  *(_DWORD *)(a1 + 472) = *(_DWORD *)(a2 + 472);
  *(_DWORD *)(a2 + 472) = 0;
  *(void *)(a1 + 480) = *(void *)(a2 + 480);
  *(void *)(a2 + 480) = 0;
  return a1;
}

void sub_1A134A57C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

char *std::vector<CPSDChannelBlendingInfo>::__init_with_size[abi:ne180100]<CPSDChannelBlendingInfo*,CPSDChannelBlendingInfo*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<CPSDChannelBlendingInfo>::__vallocate[abi:ne180100](result, a4);
    long long v7 = (void *)*((void *)v6 + 1);
    if (a2 != a3)
    {
      uint64_t v8 = *((void *)v6 + 1);
      do
      {
        uint64_t v9 = *(void *)(a2 + 8);
        *long long v7 = &unk_1EF486BA0;
        v7[1] = v9;
        v7[2] = *(void *)(a2 + 16);
        a2 += 24;
        v7 += 3;
        v8 += 24;
      }
      while (a2 != a3);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1A134A630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<CPSDChannelBlendingInfo>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_1A134A740(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::vector<CPSDChannelBlendingInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 24;
      long long v7 = v4 - 24;
      uint64_t v8 = v4 - 24;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 24;
        (*v9)(v7);
        v6 -= 24;
        BOOL v10 = v7 == v2;
        long long v7 = v8;
      }
      while (!v10);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<CPSDLayerRecord>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDLayerRecord>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerRecord>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x864B8A7DE6D1D7) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(488 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDLayerRecord>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 0; a3 + i != a5; CPSDLayerRecord::CPSDLayerRecord(i + a7, i + a3))
    i -= 488;
  return a6;
}

uint64_t std::__split_buffer<CPSDLayerRecord>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 488;
    (**(void (***)(void))(i - 488))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<CPSDChannelLengthInfo>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 24 * a2;
      uint64_t v14 = *(void *)(result - 8);
      do
      {
        *(void *)uint64_t v7 = &unk_1EF4868D8;
        *(_WORD *)(v7 + 16) = 0;
        *(_DWORD *)(v7 + 20) = 0;
        v14 += 24;
        v7 += 24;
      }
      while (v7 != v13);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    v18[4] = result;
    if (v11) {
      long long v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>(result, v11);
    }
    else {
      long long v12 = 0;
    }
    long long v15 = &v12[24 * v8];
    v18[0] = v12;
    v18[1] = v15;
    void v18[3] = &v12[24 * v11];
    long long v16 = &v15[24 * a2];
    long long v17 = v15;
    do
    {
      *(void *)long long v17 = &unk_1EF4868D8;
      *((_WORD *)v17 + 8) = 0;
      *((_DWORD *)v17 + 5) = 0;
      v15 += 24;
      v17 += 24;
    }
    while (v17 != v16);
    v18[2] = v16;
    std::vector<CPSDChannelLengthInfo>::__swap_out_circular_buffer(a1, v18);
    return std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer((uint64_t)v18);
  }
  return result;
}

void sub_1A134ABB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<CPSDChannelLengthInfo>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      *(void *)(v6 - 16) = *(void *)(v2 + v5 - 16);
      *(void *)(v6 - 24) = &unk_1EF4868D8;
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      v5 -= 24;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 24);
    *(void *)(a1 + 16) = i - 24;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<CPSDLayerChannelGroup *>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerChannelGroup *>>(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v10];
    long long v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    long long v16 = &v14[8 * a2];
    long long v18 = (char *)*a1;
    long long v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      long long v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerChannelGroup *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

void CPSDLayerChannelGroup::CPSDLayerChannelGroup(CPSDLayerChannelGroup *this, CPSDLayerRecord *a2)
{
  *(void *)this = &unk_1EF4869D8;
  *((void *)this + 2) = a2;
  uint64_t v3 = *((unsigned __int16 *)a2 + 16);
  *((_DWORD *)this + 6) = v3;
  uint64_t v4 = (void *)operator new[]();
  *uint64_t v4 = 56;
  v4[1] = v3;
  uint64_t v5 = v4 + 2;
  if (v3)
  {
    uint64_t v6 = v4 + 2;
    uint64_t v7 = v4 + 2;
    do
    {
      *uint64_t v7 = &unk_1EF486078;
      v7[2] = 0;
      *((_WORD *)v7 + 12) = 0;
      v7[4] = 0;
      v7[5] = 0;
      *((_DWORD *)v7 + 12) = 0;
      v6 += 7;
      v7 += 7;
    }
    while (v7 != &v5[7 * v3]);
  }
  *((void *)this + 4) = v5;
}

void CPSDResourceItem::~CPSDResourceItem(CPSDResourceItem *this)
{
  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486200;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x1A6230DD0](v1, 0x1000C8077774924);
  }
  JUMPOUT(0x1A6230DF0);
}

void CPSDSlicesResourceItem::CPSDSlicesResourceItem(CPSDSlicesResourceItem *this, CPSDImageResourceBlock *a2, int a3)
{
  *((_DWORD *)this + 4) = a3;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = a2;
  *(void *)this = &unk_1EF486B20;
  *((void *)this + 10) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  CPSDString::AllocateCharData((CPSDSlicesResourceItem *)((char *)this + 72), 1);
  **((_WORD **)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = 0;
}

void sub_1A134B040(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_1EF486200;
  uint64_t v3 = v1[4];
  if (v3) {
    MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void CPSDXMPResourceItem::CPSDXMPResourceItem(CPSDXMPResourceItem *this, CPSDImageResourceBlock *a2, int a3)
{
  *((_DWORD *)this + 4) = a3;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = a2;
  *(void *)this = &unk_1EF4866A0;
  *((void *)this + 6) = operator new[]();
}

void sub_1A134B0EC(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_1EF486200;
  uint64_t v3 = v1[4];
  if (v3) {
    MEMORY[0x1A6230DD0](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<CPSDString>::__construct_one_at_end[abi:ne180100]<CPSDString const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  v3[1] = 0;
  uint64_t v4 = *(const void **)(a2 + 8);
  CPSDString::AllocateCharData((CPSDString *)v3, *(_DWORD *)a2);
  uint64_t result = memcpy(v3[1], v4, (2 * *(_DWORD *)v3));
  *(void *)(a1 + 8) = v3 + 2;
  return result;
}

void sub_1A134B18C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<CPSDString>::__push_back_slow_path<CPSDString const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDString>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = (void **)&v10[16 * v4];
  v15[0] = v10;
  v15[1] = v11;
  long long v16 = v11;
  long long v17 = &v10[16 * v9];
  v11[1] = 0;
  unint64_t v12 = *(const void **)(a2 + 8);
  CPSDString::AllocateCharData((CPSDString *)v11, *(_DWORD *)a2);
  memcpy(v11[1], v12, (2 * *(_DWORD *)v11));
  v16 += 2;
  std::vector<CPSDString>::__swap_out_circular_buffer(a1, v15);
  uint64_t v13 = a1[1];
  std::__split_buffer<CPSDString>::~__split_buffer((uint64_t)v15);
  return v13;
}

void sub_1A134B290(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CPSDString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CPSDString>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDString>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>,std::reverse_iterator<CPSDString*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v17 = a6;
  *((void *)&v17 + 1) = a7;
  long long v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  Point v14[2] = &v17;
  char v15 = 0;
  if (a3 == a5)
  {
    uint64_t v12 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      int v10 = *(_DWORD *)(v9 - 16);
      v9 -= 16;
      *(void *)(v7 - 8) = 0;
      uint64_t v11 = *(const void **)(v9 + 8);
      CPSDString::AllocateCharData((CPSDString *)(v7 - 16), v10);
      memcpy(*(void **)(v7 - 8), v11, (2 * *(_DWORD *)(v7 - 16)));
      uint64_t v7 = *((void *)&v17 + 1) - 16;
      *((void *)&v17 + 1) -= 16;
    }
    while (v9 != a5);
    uint64_t v12 = v17;
  }
  char v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

void sub_1A134B414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

uint64_t std::_AllocatorDestroyRangeReverse<std::allocator<CPSDString>,std::reverse_iterator<CPSDString*>>::operator()[abi:ne180100](uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(result + 8) + 8);
  while (v1 != v2)
  {
    uint64_t result = *(void *)(v1 + 8);
    if (result)
    {
      uint64_t result = MEMORY[0x1A6230DD0](result, 0x1000C80BDFB0063);
      *(void *)(v1 + 8) = 0;
    }
    v1 += 16;
  }
  return result;
}

uint64_t std::__split_buffer<CPSDString>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<CPSDString>::__destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      *(void *)(v4 + 16) = v2 - 16;
      uint64_t result = *(void *)(v2 - 8);
      if (result)
      {
        uint64_t result = MEMORY[0x1A6230DD0](result, 0x1000C80BDFB0063);
        *(void *)(v2 - 8) = 0;
        uint64_t v2 = *(void *)(v4 + 16);
      }
      else
      {
        v2 -= 16;
      }
    }
    while (v2 != a2);
  }
  return result;
}

void CPSDSliceResource::CPSDSliceResource(CPSDSliceResource *this)
{
  *(void *)this = &unk_1EF4863D0;
  *((void *)this + 5) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 32), 1);
  **((_WORD **)this + 5) = 0;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 72), 1);
  **((_WORD **)this + 10) = 0;
  *((void *)this + 12) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 88), 1);
  **((_WORD **)this + 12) = 0;
  *((void *)this + 14) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 104), 1);
  **((_WORD **)this + 14) = 0;
  *((void *)this + 16) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 120), 1);
  **((_WORD **)this + 16) = 0;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 19) = 0;
  CPSDString::AllocateCharData((CPSDSliceResource *)((char *)this + 144), 1);
  **((_WORD **)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
}

void sub_1A134B74C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[16];
  if (v3)
  {
    MEMORY[0x1A6230DD0](v3, 0x1000C80BDFB0063);
    v1[16] = 0;
  }
  uint64_t v4 = v1[14];
  if (v4)
  {
    MEMORY[0x1A6230DD0](v4, 0x1000C80BDFB0063);
    v1[14] = 0;
  }
  uint64_t v5 = v1[12];
  if (v5)
  {
    MEMORY[0x1A6230DD0](v5, 0x1000C80BDFB0063);
    v1[12] = 0;
  }
  uint64_t v6 = v1[10];
  if (v6)
  {
    MEMORY[0x1A6230DD0](v6, 0x1000C80BDFB0063);
    v1[10] = 0;
  }
  uint64_t v7 = v1[5];
  if (v7)
  {
    MEMORY[0x1A6230DD0](v7, 0x1000C80BDFB0063);
    void v1[5] = 0;
  }
  _Unwind_Resume(exception_object);
}

void std::vector<CPSDLayerRecord>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void (***)(void))**a1;
  if (v2)
  {
    uint64_t v4 = (void (***)(void))v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 61;
      uint64_t v7 = v4 - 61;
      do
      {
        (**v7)(v7);
        v6 -= 61;
        BOOL v8 = v7 == v2;
        v7 -= 61;
      }
      while (!v8);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

CPSDLayerRecord *std::vector<CPSDLayerRecord>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = a1[2];
  uint64_t result = (CPSDLayerRecord *)a1[1];
  if (0x4FBCDA3AC10C9715 * ((v5 - (uint64_t)result) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v12 = (CPSDLayerRecord *)((char *)result + 488 * a2);
      uint64_t v13 = 488 * a2;
      do
      {
        CPSDLayerRecord::CPSDLayerRecord(result);
        uint64_t result = (CPSDLayerRecord *)(v14 + 488);
        v13 -= 488;
      }
      while (v13);
      uint64_t result = v12;
    }
    a1[1] = (uint64_t)result;
  }
  else
  {
    uint64_t v7 = 0x4FBCDA3AC10C9715 * (((uint64_t)result - *a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x864B8A7DE6D1D6) {
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = 0x4FBCDA3AC10C9715 * ((v5 - *a1) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x4325C53EF368EBLL) {
      unint64_t v10 = 0x864B8A7DE6D1D6;
    }
    else {
      unint64_t v10 = v8;
    }
    void v19[4] = v4;
    if (v10) {
      uint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDLayerRecord>>(v4, v10);
    }
    else {
      uint64_t v11 = 0;
    }
    char v15 = (CPSDLayerRecord *)&v11[488 * v7];
    v19[0] = v11;
    v19[1] = v15;
    v19[3] = &v11[488 * v10];
    uint64_t v16 = 488 * a2;
    long long v17 = (char *)v15 + 488 * a2;
    do
    {
      CPSDLayerRecord::CPSDLayerRecord(v15);
      char v15 = (CPSDLayerRecord *)(v18 + 488);
      v16 -= 488;
    }
    while (v16);
    v19[2] = v17;
    std::vector<CPSDLayerRecord>::__swap_out_circular_buffer(a1, v19);
    return (CPSDLayerRecord *)std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)v19);
  }
  return result;
}

void sub_1A134BA40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CPSDLayerRecord>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CPSDChannelBlendingInfo>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = &v7[3 * a2];
      uint64_t v14 = *(void *)(result - 8);
      do
      {
        *uint64_t v7 = &unk_1EF486BA0;
        v7[2] = 0;
        v14 += 24;
        v7 += 3;
      }
      while (v7 != v13);
      uint64_t v7 = v13;
    }
    a1[1] = (uint64_t)v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    v18[4] = result;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDChannelBlendingInfo>>(result, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    char v15 = &v12[24 * v8];
    v18[0] = v12;
    v18[1] = v15;
    void v18[3] = &v12[24 * v11];
    uint64_t v16 = &v15[24 * a2];
    long long v17 = v15;
    do
    {
      *(void *)long long v17 = &unk_1EF486BA0;
      *((void *)v17 + 2) = 0;
      v15 += 24;
      v17 += 24;
    }
    while (v17 != v16);
    v18[2] = v16;
    std::vector<CPSDChannelBlendingInfo>::__swap_out_circular_buffer(a1, v18);
    return std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer((uint64_t)v18);
  }
  return result;
}

void sub_1A134BBC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CPSDChannelLengthInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<CPSDChannelBlendingInfo>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      *(void *)(v6 - 16) = *(void *)(v2 + v5 - 16);
      *(void *)(v6 - 24) = &unk_1EF486BA0;
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      v5 -= 24;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void CPSDOSTypeText::CPSDOSTypeText(CPSDOSTypeText *this)
{
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(void *)this = &unk_1EF486030;
  *((void *)this + 8) = 0;
  CPSDString::AllocateCharData((CPSDOSTypeText *)((char *)this + 56), 1);
  **((_WORD **)this + 8) = 0;
}

void sub_1A134BCDC(_Unwind_Exception *a1)
{
  CPSDAdditionalLayerInfoItem::~CPSDAdditionalLayerInfoItem(v1);
  _Unwind_Resume(a1);
}

void std::vector<CPSDActionKeyedItem>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 88;
      uint64_t v7 = v4 - 88;
      uint64_t v8 = v4 - 88;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 88;
        (*v9)(v7);
        v6 -= 88;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<CPSDActionKeyedItem>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (0x2E8BA2E8BA2E8BA3 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 88 * a2;
      uint64_t v14 = 88 * a2;
      uint64_t v15 = v7 + 56;
      do
      {
        *(_DWORD *)(v15 - 40) = 0;
        *(_OWORD *)(v15 - 32) = 0uLL;
        *(_OWORD *)(v15 - 16) = 0uLL;
        *(void *)(v15 - 56) = &unk_1EF486570;
        *(void *)(v15 + 24) = 0;
        v7 += 88;
        *(void *)uint64_t v15 = 0;
        *(void *)(v15 + 8) = 0;
        *(_DWORD *)(v15 + 16) = 0;
        v15 += 88;
        v14 -= 88;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x2E8BA2E8BA2E8BALL) {
      std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x2E8BA2E8BA2E8BA3 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x1745D1745D1745DLL) {
      unint64_t v11 = 0x2E8BA2E8BA2E8BALL;
    }
    else {
      unint64_t v11 = v9;
    }
    v20[4] = result;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDActionKeyedItem>>(result, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v16 = &v12[88 * v8];
    v20[0] = v12;
    v20[1] = v16;
    v20[3] = &v12[88 * v11];
    uint64_t v17 = 88 * a2;
    uint64_t v18 = &v16[88 * a2];
    uint64_t v19 = v16 + 56;
    do
    {
      *((_DWORD *)v19 - 10) = 0;
      *((_OWORD *)v19 - 2) = 0uLL;
      *((_OWORD *)v19 - 1) = 0uLL;
      *((void *)v19 - 7) = &unk_1EF486570;
      *((void *)v19 + 3) = 0;
      v16 += 88;
      *(void *)uint64_t v19 = 0;
      *((void *)v19 + 1) = 0;
      *((_DWORD *)v19 + 4) = 0;
      v19 += 88;
      v17 -= 88;
    }
    while (v17);
    v20[2] = v18;
    std::vector<CPSDActionKeyedItem>::__swap_out_circular_buffer(a1, v20);
    return std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)v20);
  }
  return result;
}

void sub_1A134BF6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<CPSDActionKeyedItem>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 != *result)
  {
    uint64_t v5 = v4 - 88;
    do
    {
      *(void *)(v4 - 88) = &unk_1EF486570;
      v4 -= 88;
      *(_DWORD *)(v4 + 16) = 0;
      *(_OWORD *)(v4 + 24) = 0uLL;
      *(_OWORD *)(v4 + 40) = 0uLL;
      *(void *)(v4 + 8) = *(void *)(v3 - 80);
      long long v6 = *(_OWORD *)(v3 - 72);
      *(void *)(v4 + 32) = *(void *)(v3 - 56);
      *(_OWORD *)(v4 + 16) = v6;
      *(_OWORD *)(v4 + 40) = *(_OWORD *)(v3 - 48);
      long long v7 = *(_OWORD *)(v3 - 32);
      *(_OWORD *)(v4 + 72) = *(_OWORD *)(v3 - 16);
      *(_OWORD *)(v4 + 56) = v7;
      *(void *)(v3 - 8) = 0;
      *(void *)(v3 - 24) = 0;
      v5 -= 88;
      v3 -= 88;
    }
    while (v3 != v2);
  }
  a2[1] = v4;
  uint64_t v8 = *result;
  *uint64_t result = v4;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDActionKeyedItem>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(88 * a2);
}

uint64_t std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 88);
    *(void *)(a1 + 16) = i - 88;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<CPSDActionKeyedItem>::__push_back_slow_path<CPSDActionKeyedItem>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL) {
    std::vector<CPSDChannelBlendingInfo>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  v16[4] = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CPSDActionKeyedItem>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = &v10[88 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[88 * v9];
  *((_DWORD *)v11 + 4) = 0;
  *(_OWORD *)(v11 + 24) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(void *)unint64_t v11 = &unk_1EF486570;
  *((void *)v11 + 1) = *(void *)(a2 + 8);
  long long v12 = *(_OWORD *)(a2 + 16);
  *((void *)v11 + 4) = *(void *)(a2 + 32);
  *((_OWORD *)v11 + 1) = v12;
  *(_OWORD *)(v11 + 40) = *(_OWORD *)(a2 + 40);
  long long v13 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v11 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v11 + 56) = v13;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 64) = 0;
  Point v16[2] = v11 + 88;
  std::vector<CPSDActionKeyedItem>::__swap_out_circular_buffer(a1, v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_1A134C25C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CPSDActionKeyedItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void CPSDString::CPSDString(CPSDString *this, const char *a2)
{
  *((void *)this + 1) = 0;
  CPSDString::AllocateCharData(this, 1);
  **((_WORD **)this + 1) = 0;
  unsigned int v4 = strlen(a2) + 1;
  CPSDString::AllocateCharData(this, v4);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((void *)this + 1);
    do
    {
      char v7 = *a2++;
      *(unsigned char *)(v6 + v5) = v7;
      *(unsigned char *)(v6 + (v5 + 1)) = 0;
      v5 += 2;
    }
    while (2 * v4 != v5);
  }
}

void sub_1A134C2F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 8);
  if (v3)
  {
    MEMORY[0x1A6230DD0](v3, 0x1000C80BDFB0063);
    *(void *)(v1 + 8) = 0;
  }
  _Unwind_Resume(exception_object);
}

CPSDString *CPSDString::operator=(CPSDString *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    MEMORY[0x1A6230DD0](v4, 0x1000C80BDFB0063);
    *((void *)this + 1) = 0;
  }
  uint64_t v5 = *(const void **)(a2 + 8);
  CPSDString::AllocateCharData(this, *(_DWORD *)a2);
  memcpy(*((void **)this + 1), v5, (2 * *(_DWORD *)this));
  return this;
}

void std::vector<CPSDString>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    std::vector<CPSDString>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t std::vector<CPSDString>::__base_destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); i != a2; i -= 16)
  {
    uint64_t result = *(void *)(i - 8);
    if (result)
    {
      uint64_t result = MEMORY[0x1A6230DD0](result, 0x1000C80BDFB0063);
      *(void *)(i - 8) = 0;
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

void CPSDUnicodeLayerName::CopyStringValue(const UniChar **this, char *a2, unsigned int a3)
{
  CFStringRef v5 = CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault, this[8], *((unsigned int *)this + 14), kCFAllocatorNull);
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  CFStringGetCString(v5, a2, a3, SystemEncoding);
  CFRelease(v5);
}

__CFData *__CUIImageCompressedWithDeepmap(uint64_t a1, int a2, uint64_t a3, int a4)
{
  long long v20 = 0;
  uint64_t v21 = a3;
  int v22 = a4;
  uint64_t Buffer = vImageDeepmapEncodeCreateBuffer();
  if (!Buffer)
  {
    uint64_t v14 = "CoreUI: DeepmapEncodeImageCreateBuffer() returned 0.";
LABEL_7:
    _CUILog(4, (uint64_t)v14, v6, v7, v8, v9, v10, v11, v16);
    return 0;
  }
  CFIndex v12 = Buffer;
  [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"CFDataRef __CUIImageCompressedWithDeepmap(vImage_Buffer, vImageDeepmapPixelFormat, vImageDeepmapCompressionOptions)"] file:@"CUIDeepmapCompression.m" lineNumber:124 description:@"Expects non-null pointer."];
  if ((v21 - 1) >= 4)
  {
    uint64_t v16 = v21;
    uint64_t v14 = "CoreUI: vImageDeepmapEncodeCreateBuffer() returned unrecognized compression method: %lu [%s]";
    goto LABEL_7;
  }
  *(_DWORD *)bytes = 5;
  int v18 = a2;
  CFIndex v19 = v12;
  CFDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, v12 + 16);
  CFDataAppendBytes(Mutable, bytes, 16);
  CFDataAppendBytes(Mutable, v20, v12);
  free(v20);
  return Mutable;
}

id CUIImageCompressedWithDeepmap(unsigned int *a1, long long *a2, uint64_t a3, _DWORD *a4, __int16 *a5, uint64_t *a6, _DWORD *a7, uint64_t a8)
{
  if (*(void *)a2 && *((void *)a2 + 3) && *((void *)a2 + 2) && *((void *)a2 + 1))
  {
    if (*a1 == 8 || *a1 == 16)
    {
      if (*((void *)a1 + 1))
      {
        if ((int)a3 > 1195456543)
        {
          if (a3 == 1195456544)
          {
            __int16 v11 = 2;
            int v10 = 2;
          }
          else
          {
            if (a3 != 1380401751)
            {
LABEL_35:
              _CUILog(4, (uint64_t)"CoreUI: Unrecognized input pixel format: %d [%s]", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, a3);
              return 0;
            }
            int v10 = 20;
            __int16 v11 = 4;
          }
        }
        else
        {
          if (a3 != 1095911234)
          {
            if (a3 == 1195454774)
            {
              int v10 = 18;
              __int16 v11 = 6;
              goto LABEL_22;
            }
            goto LABEL_35;
          }
          int v10 = 4;
          __int16 v11 = 1;
        }
LABEL_22:
        *a4 = a3;
        *a5 = v11;
        *a6 = CGBitmapGetAlignedBytesPerRow();
        id v12 = objc_alloc_init((Class)NSMutableArray);
        unint64_t v14 = *((void *)a2 + 1);
        if (v14 * *((void *)a2 + 3) < 0x5000)
        {
          long long v29 = a2[1];
          long long v32 = *a2;
          long long v33 = v29;
          double v30 = __CUIImageCompressedWithDeepmap((uint64_t)&v32, v10, 0x100000000, 10);
          if (!v30)
          {
LABEL_36:
            _CUILog(4, (uint64_t)"CoreUI: Deepmap compressed failed in %s [%s:%lu]", v21, v22, v23, v24, v25, v26, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");

            return 0;
          }
          uint64_t v31 = v30;
          [v12 addObject:v30];
          CFRelease(v31);
          unint64_t v28 = *((void *)a2 + 1);
        }
        else
        {
          unint64_t v15 = (v14 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64;
          unint64_t v16 = (v14 / 3);
          if (!(v14 / 3)) {
            CUIImageCompressedWithDeepmap_cold_1();
          }
          if (v14)
          {
            uint64_t v17 = *(void *)a2;
            do
            {
              uint64_t v18 = v14 >= v16 ? v16 : v14;
              *(void *)a2 = v17;
              *((void *)a2 + 1) = v18;
              long long v19 = a2[1];
              long long v32 = *a2;
              long long v33 = v19;
              long long v20 = __CUIImageCompressedWithDeepmap((uint64_t)&v32, v10, 0x100000000, 10);
              if (!v20) {
                goto LABEL_36;
              }
              int v27 = v20;
              [v12 addObject:v20];
              CFRelease(v27);
              v17 += *((void *)a2 + 3) * v18;
              v14 -= v18;
            }
            while (v14);
          }
          unint64_t v28 = v15 >> 1;
        }
        *a7 = v28;
        return v12;
      }
      _CUILog(4, (uint64_t)"CoreUI: Missing image color space to perform Deemap compression [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: unsupported bpc for Deepmap compression: %d [%s].", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, *a1);
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: invalid input image buffer in %s", a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"NSArray<NSData *> *CUIImageCompressedWithDeepmap(vImage_CGImageFormat, vImage_Buffer, u_int32_t, u_int32_t *, short *, size_t *, u_int32_t *)");
  }
  return 0;
}

uint64_t CUIUncompressDeepmapImageData(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL buffer in [%s]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  if (!a4)
  {
    _CUILog(4, (uint64_t)"CoreUI: Received NULL destination in [%s]", a3, 0, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
  unsigned int v10 = a3;
  id v12 = a1;
  if ((int)a8 > 1195456543)
  {
    if (a8 != 1195456544)
    {
      int v13 = 1380401751;
      goto LABEL_10;
    }
  }
  else if (a8 != 1095911234)
  {
    int v13 = 1195454774;
LABEL_10:
    if (a8 == v13) {
      goto LABEL_11;
    }
    _CUILog(4, (uint64_t)"CoreUI: %s got unsupported pixel format [%d]", a3, a4, a5, a6, a7, a8, (uint64_t)"Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)");
    return 0;
  }
LABEL_11:
  uint64_t v41 = 0;
  uint64_t v42 = &v41;
  uint64_t v43 = 0x2020000000;
  char v44 = 1;
  if (a3)
  {
    uint64_t v14 = a1[3];
    a2 = a1[4];
    BOOL v34 = *a1 == 1262699075;
    id v15 = [objc_alloc((Class)NSMutableArray) initWithCapacity:a3];
    unint64_t v16 = v12;
    v12 += 5;
  }
  else
  {
    BOOL v34 = 0;
    id v15 = 0;
    unint64_t v16 = 0;
    uint64_t v14 = a6;
  }
  unsigned int v17 = 0;
  unint64_t v18 = 0;
  if (v10 <= 1) {
    int v19 = 1;
  }
  else {
    int v19 = v10;
  }
  int v35 = v19 - 1;
  do
  {
    if (v10)
    {
      if (v17 >= v10) {
        [+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler") handleFailureInFunction:+[NSString stringWithUTF8String:"Boolean CUIUncompressDeepmapImageData(const u_int8_t *, u_int64_t, u_int32_t, u_int8_t *, size_t, size_t, size_t, u_int32_t)"] file:@"CUIDeepmapCompression.m" lineNumber:358 description:@"Invalid chunk index"];
      }
      if (!v16 || v14 - 1 >= a6)
      {
        _CUILog(4, (uint64_t)"CoreUI: Invalid chunk rows of %lu in image of height %lu", a3, a4, a5, a6, a7, a8, v14);
        if (!v15) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
    }
    if (*v12 >= 6)
    {
      _CUILog(4, (uint64_t)"CoreUI: Encoded Deepmap blob version %lu greater than decoder version %lu", a3, a4, a5, a6, a7, a8, *v12);
      *((unsigned char *)v42 + 24) = 0;
      if (!v15) {
        goto LABEL_43;
      }
LABEL_42:

      goto LABEL_43;
    }
    unsigned int v20 = v12[1];
    v39[0] = _NSConcreteStackBlock;
    v39[1] = 3221225472;
    v39[2] = __CUIUncompressDeepmapImageData_block_invoke;
    v39[3] = &unk_1E5A519D0;
    v39[6] = v14;
    v39[7] = a7;
    v39[8] = a4;
    v39[9] = v18;
    v39[10] = v12;
    v39[11] = v12;
    unsigned int v40 = v20;
    v39[4] = &v41;
    v39[5] = a5;
    if (!v10)
    {
      __CUIUncompressDeepmapImageData_block_invoke((uint64_t)v39);
      goto LABEL_38;
    }
    if (!v15) {
      id v15 = objc_alloc_init((Class)NSMutableArray);
    }
    id v21 = [v39 copy];
    [v15 addObject:v21];

    if (v35 == v17) {
      break;
    }
    uint64_t v22 = (char *)v16 + a2;
    unint64_t v16 = (unsigned int *)((char *)v16 + a2 + 20);
    unsigned int v23 = *((_DWORD *)v22 + 8);
    if (v34)
    {
      unsigned int v23 = bswap32(v23);
      unsigned int v24 = bswap32(v16[4]);
    }
    else
    {
      unsigned int v24 = v16[4];
    }
    v18 += v14;
    uint64_t v14 = v23;
    a2 = v24;
    id v12 = v16 + 5;
    ++v17;
  }
  while (v18 < a6);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __CUIUncompressDeepmapImageData_block_invoke_2;
  block[3] = &unk_1E5A519A8;
  block[4] = v15;
  dispatch_apply((size_t)[v15 count], 0, block);

LABEL_38:
  if (*((unsigned char *)v42 + 24))
  {
    uint64_t v31 = 1;
    goto LABEL_44;
  }
  _CUILog(4, (uint64_t)"CoreUI: CUIUncompressDeepmapImageData() fails.", v25, v26, v27, v28, v29, v30, v33);
LABEL_43:
  uint64_t v31 = 0;
LABEL_44:
  _Block_object_dispose(&v41, 8);
  return v31;
}

void sub_1A134D434(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __CUIUncompressDeepmapImageData_block_invoke(uint64_t a1)
{
  uint64_t result = vImageDeepmapDecodeStreamCreate();
  if (!result)
  {
    while (result != -1)
    {
      if (result)
      {
        if (result != 1) {
          __CUIUncompressDeepmapImageData_block_invoke_cold_1();
        }
        uint64_t result = vImageDeepmapDecodeStreamRelease();
        if (result) {
          break;
        }
        return result;
      }
      uint64_t result = vImageDeepmapDecodeStreamProcess();
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

uint64_t __CUIUncompressDeepmapImageData_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t (*)(void))*((void *)[*(id *)(a1 + 32) objectAtIndex:a2] + 2);
  return v2();
}

Class initMDLMeshBufferMap()
{
  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
  id v0 = [(id)__NSGetFrameworkReference_table_0 objectForKey:@"ModelIO"];
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
  if (!v0)
  {
    uint64_t v1 = __NSLoadFramework(@"ModelIO");
    if (v1)
    {
      uint64_t v2 = v1;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
      id v3 = (id)__NSGetFrameworkReference_table_0;
      if (!__NSGetFrameworkReference_table_0)
      {
        id v3 = [objc_alloc((Class)NSMapTable) initWithKeyOptions:0 valueOptions:2 capacity:0];
        __NSGetFrameworkReference_table_0 = (uint64_t)v3;
      }
      if (![v3 objectForKey:@"ModelIO"]) {
        [(id)__NSGetFrameworkReference_table_0 setObject:v2 forKey:@"ModelIO"];
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_0);
    }
  }
  Class result = objc_getClass("MDLMeshBufferMap");
  classMDLMeshBufferMap = (uint64_t)result;
  if (!result) {
    initMDLMeshBufferMap_cold_1();
  }
  getMDLMeshBufferMapClass = MDLMeshBufferMapFunction;
  return result;
}

uint64_t MDLMeshBufferMapFunction()
{
  return classMDLMeshBufferMap;
}

void CPSDMeshedARGBStream::CPSDMeshedARGBStream(CPSDMeshedARGBStream *this, CPSDChannelImage *a2)
{
  *((void *)this + 1) = a2;
  unsigned int v2 = (*((_DWORD *)a2 + 2) * *((unsigned __int16 *)a2 + 8) + 7) >> 3;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 5) = v2;
  *((_DWORD *)this + 6) = 0;
  *(void *)this = &unk_1EF486810;
  id v3 = (uint64_t *)*((void *)a2 + 6);
  int v4 = *((unsigned __int8 *)a2 + 28);
  *((unsigned char *)this + 64) = *((unsigned char *)a2 + 28) != 0;
  if (v4)
  {
    uint64_t v5 = *v3++;
    uint64_t v6 = (uint64_t *)((char *)this + 40);
    *((void *)this + 4) = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t *)((char *)this + 32);
  }
  *uint64_t v6 = *v3;
  v6[1] = v3[1];
  v6[2] = v3[2];
}

uint64_t CPSDMeshedARGBStream::convert(uint64_t this, unsigned __int8 *a2)
{
  uint64_t v2 = (*(_DWORD *)(this + 24) * *(_DWORD *)(this + 16));
  uint64_t v3 = *(void *)(this + 8);
  if (*(unsigned char *)(this + 64))
  {
    int v4 = (uint64_t *)(this + 40);
    uint64_t v5 = (unsigned __int8 *)(*(void *)(this + 32) + v2);
  }
  else
  {
    uint64_t v5 = 0;
    int v4 = (uint64_t *)(this + 32);
  }
  if (*(_DWORD *)(v3 + 8))
  {
    unint64_t v6 = 0;
    unint64_t v7 = *(unsigned __int16 *)(v3 + 18);
    uint64_t v9 = v4[1];
    uint64_t v8 = v4[2];
    uint64_t v10 = *v4;
    uint64_t v11 = (v7 >> 3);
    do
    {
      if (*(unsigned char *)(this + 64))
      {
        *a2 = *v5;
        a2 += v11;
        v5 += v11;
      }
      *a2 = *(unsigned char *)(v10 + v2);
      a2[v11] = *(unsigned char *)(v9 + v2);
      id v12 = &a2[v11 + v11];
      *id v12 = *(unsigned char *)(v8 + v2);
      a2 = &v12[v11];
      ++v6;
      v2 += v11;
    }
    while (v6 < *(unsigned int *)(*(void *)(this + 8) + 8));
  }
  return this;
}

unint64_t CPSDMeshedARGBStream::GetBytes(CPSDMeshedARGBStream *this, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 % *((unsigned int *)this + 5))
  {
    _CUILog(1, (uint64_t)"ERROR (CPSDMeshedARGBStream): count is not a multiple of bytesPerRow.", a3, a4, a5, a6, a7, a8, v14);
    return 0;
  }
  if (!a3) {
    return 0;
  }
  unint64_t v8 = 0;
  unsigned int v13 = *((_DWORD *)this + 6);
  do
  {
    if (v13 >= *(_DWORD *)(*((void *)this + 1) + 12)) {
      break;
    }
    (*(void (**)(CPSDMeshedARGBStream *, char *))(*(void *)this + 24))(this, &a2[v8]);
    v8 += *((unsigned int *)this + 5);
    unsigned int v13 = *((_DWORD *)this + 6) + 1;
    *((_DWORD *)this + 6) = v13;
  }
  while (v8 < a3);
  return v8;
}

uint64_t CPSDMeshedARGBStream::SkipBytes(CPSDMeshedARGBStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *((unsigned int *)this + 5);
  if (a2 % v8)
  {
    _CUILog(1, (uint64_t)"ERROR (CPSDMeshedARGBStream): count is not a multiple of bytesPerRow.", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
  else
  {
    unsigned int v9 = *((_DWORD *)this + 6) + a2 / v8;
    if (v9 >= *(_DWORD *)(*((void *)this + 1) + 12)) {
      unsigned int v9 = *(_DWORD *)(*((void *)this + 1) + 12);
    }
    *((_DWORD *)this + 6) = v9;
  }
  return a2;
}

CGImageRef CPSDMeshedARGBStream::CreateCGImageRef(CPSDMeshedARGBStream *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*(_WORD *)(v1 + 26) != 3) {
    return 0;
  }
  int v2 = *(unsigned __int16 *)(v1 + 18);
  BOOL v3 = v2 == 16 || v2 == 8;
  if (!v3 || *(unsigned __int16 *)(v1 + 24) < 3u || !*(_DWORD *)(v1 + 8) || !*(_DWORD *)(v1 + 12)) {
    return 0;
  }
  CGBitmapInfo v5 = 4 * (*(unsigned char *)(v1 + 28) != 0);
  unint64_t v6 = (CGColorSpace *)(*(uint64_t (**)(CPSDMeshedARGBStream *))(*(void *)this + 32))(this);
  if (v6)
  {
    SRGB = v6;
    CFAutorelease(v6);
  }
  else
  {
    SRGB = (CGColorSpace *)_CUIColorSpaceGetSRGB();
  }
  Sequential = CGDataProviderCreateSequential(this, &psdStreamCallbacks);
  CGImageRef v10 = CGImageCreate(*(unsigned int *)(*((void *)this + 1) + 8), *(unsigned int *)(*((void *)this + 1) + 12), *(unsigned __int16 *)(*((void *)this + 1) + 18), *(unsigned __int16 *)(*((void *)this + 1) + 16), *((unsigned int *)this + 5), SRGB, v5, Sequential, 0, 0, kCGRenderingIntentDefault);
  CGDataProviderRelease(Sequential);
  return v10;
}

CGColorSpaceRef CPSDMeshedARGBStream::GetColorSpace(CPSDMeshedARGBStream *this)
{
  uint64_t v1 = *((void *)this + 1);
  CFIndex v2 = *(unsigned int *)(v1 + 32);
  if (!v2) {
    return 0;
  }
  BOOL v3 = *(const UInt8 **)(v1 + 40);
  if (!v3) {
    return 0;
  }
  size_t v4 = *(unsigned __int16 *)(v1 + 26);
  if (v4 != 1)
  {
    if (v4 == 4)
    {
      size_t v4 = 4;
    }
    else if (v4 == 3)
    {
      size_t v4 = 3;
    }
    else
    {
      size_t v4 = *(unsigned __int16 *)(v1 + 24);
    }
  }
  CFDataRef v6 = CFDataCreate(kCFAllocatorDefault, v3, v2);
  unint64_t v7 = CGDataProviderCreateWithCFData(v6);
  CGColorSpaceRef ICCBased = CGColorSpaceCreateICCBased(v4, 0, v7, 0);
  CGDataProviderRelease(v7);
  CFRelease(v6);
  return ICCBased;
}

void CPSDAlphaChannelStream::CPSDAlphaChannelStream(CPSDAlphaChannelStream *this, CPSDChannelImage *a2, uint64_t a3)
{
  *((void *)this + 1) = a2;
  unsigned int v3 = (*((_DWORD *)a2 + 2) * *((unsigned __int16 *)a2 + 8) + 7) >> 3;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 5) = v3;
  *((_DWORD *)this + 6) = 0;
  *(void *)this = &unk_1EF486A60;
  *((void *)this + 4) = *(void *)(*((void *)a2 + 6) + 8 * a3);
  *((_DWORD *)this + 10) = a3;
  *((_DWORD *)this + 4) = ((*(unsigned int (**)(CPSDChannelImage *, uint64_t))(*(void *)a2 + 40))(a2, a3)
                         * *((unsigned __int16 *)a2 + 9)) >> 3;
}

void sub_1A134E1DC(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_1EF486240;
  uint64_t v3 = v1[1];
  if (v3) {
    CPSDAlphaChannelStream::CPSDAlphaChannelStream(v3);
  }
  _Unwind_Resume(exception_object);
}

CGImageRef CPSDAlphaChannelStream::CreateCGImageRef(CPSDAlphaChannelStream *this)
{
  long long v12 = xmmword_1A139EA00;
  CFIndex v2 = (_WORD *)*((void *)this + 1);
  if (v2[13] != 3 || v2[9] != 8 || (unsigned __int16)v2[12] < 4u) {
    return 0;
  }
  unsigned int v3 = (*(uint64_t (**)(_WORD *, void))(*(void *)v2 + 40))(v2, *((unsigned int *)this + 10));
  unsigned int v4 = (*(uint64_t (**)(void, void))(**((void **)this + 1) + 48))(*((void *)this + 1), *((unsigned int *)this + 10));
  if (!v3 || v4 == 0) {
    return 0;
  }
  unsigned int v8 = v4;
  LODWORD(v5) = *((_DWORD *)this + 4);
  unsigned int v9 = CGDataProviderCreateWithData(this, *((const void **)this + 4), (unint64_t)((double)v4 * (double)v5), (CGDataProviderReleaseDataCallback)alphaStreamReleaseData);
  size_t v10 = *(unsigned __int16 *)(*((void *)this + 1) + 18);
  CGImageRef v11 = CGImageMaskCreate(v3, v8, v10, v10, *((unsigned int *)this + 4), v9, (const CGFloat *)&v12, 0);
  CGDataProviderRelease(v9);
  return v11;
}

uint64_t alphaStreamReleaseData(uint64_t result, const void *a2)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CPSDMeshedARGBStream::~CPSDMeshedARGBStream(CPSDMeshedARGBStream *this)
{
  *(void *)this = &unk_1EF486240;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486240;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x1A6230DF0);
}

void CPSDAlphaChannelStream::~CPSDAlphaChannelStream(CPSDAlphaChannelStream *this)
{
  *(void *)this = &unk_1EF486240;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1EF486240;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x1A6230DF0);
}

uint64_t psdRewind(uint64_t result)
{
  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t psdRelease(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

double CUIEdgeInsetsInsetRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8 = a1 + a6;
  double v9 = a3 - (a8 + a6);
  double v10 = v9 * 0.5;
  if (v9 > 0.0) {
    double v10 = -0.0;
  }
  return v8 + v10;
}

double CUIEdgeInsetsOutsetRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8 = a1 - a6;
  double v9 = a3 - (-a6 - a8);
  double v10 = v9 * 0.5;
  if (v9 > 0.0) {
    double v10 = -0.0;
  }
  return v8 + v10;
}

double CUIEdgeInsetsMake(double a1, double a2, double a3, double a4)
{
  return a4;
}

double CUIEdgeInsetsToCGRect(double a1, double a2)
{
  return a2;
}

double CUIEdgeInsetsFromCGRect(double a1, double a2, double a3, double a4)
{
  return a4;
}

BOOL CUIEdgeInsetsEqualToEdgeInsets(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  return a2 == a6 && a3 == a7 && a4 == a8 && a1 == a5;
}

BOOL CUIEdgeInsetsValid(double a1, double a2, double a3, double a4)
{
  return a2 != -INFINITY || a3 != INFINITY || a4 != INFINITY || a1 != -INFINITY;
}

void sub_1A135209C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A1352194(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A13523E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A1352480(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A1352540(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1A13526A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double CUIGetSVGAttributeUnitScale(uint64_t a1)
{
  if (!a1) {
    return 1.0;
  }
  uint64_t v1 = (void *)CGSVGAttributeCopyString();
  if ([v1 hasSuffix:@"mm"])
  {
    double v2 = 2.83464567;
  }
  else if ([v1 hasSuffix:@"cm"])
  {
    double v2 = 28.3464567;
  }
  else if ([v1 hasSuffix:@"in"])
  {
    double v2 = 72.0;
  }
  else
  {
    double v2 = 1.0;
  }

  return v2;
}

uint64_t CUIAccumulateSVGShapesIntoJoinedPath()
{
  return CGSVGNodeEnumerate();
}

void __CUIAccumulateSVGShapesIntoJoinedPath_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3)
  {
    uint64_t v23 = v3;
    uint64_t v24 = v4;
    if (CGSVGNodeGetType() == 2)
    {
      if (CGSVGShapeNodeGetPath())
      {
        CGPath = (const CGPath *)CGSVGPathCreateCGPath();
        memset(&v22, 0, sizeof(v22));
        CUISVGNodeGetTransform((uint64_t)&v22);
        long long v7 = *(_OWORD *)(a1 + 48);
        long long v8 = *(_OWORD *)(a1 + 64);
        *(_OWORD *)&t1.a = *(_OWORD *)(a1 + 32);
        *(_OWORD *)&t1.c = v7;
        *(_OWORD *)&t1.tuint32_t x = v8;
        memset(&v21, 0, sizeof(v21));
        CGAffineTransform t2 = v22;
        CGAffineTransformConcat(&v21, &t1, &t2);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        long long v13 = *(_OWORD *)&v21.a;
        long long v14 = *(_OWORD *)&v21.c;
        long long v9 = *(_OWORD *)(a1 + 32);
        long long v10 = *(_OWORD *)(a1 + 48);
        long long v15 = *(_OWORD *)&v21.tx;
        long long v16 = v9;
        block[2] = __CUIAccumulateSVGShapesIntoJoinedPath_block_invoke_2;
        block[3] = &__block_descriptor_136_e36_v16__0r__CGPathElement_i__CGPoint__8l;
        block[4] = *(void *)(a1 + 80);
        long long v11 = *(_OWORD *)(a1 + 64);
        long long v17 = v10;
        long long v18 = v11;
        CGPathApplyWithBlock(CGPath, block);
        CGPathRelease(CGPath);
      }
    }
  }
}

CGAffineTransform *CUISVGNodeGetTransform@<X0>(uint64_t a1@<X8>)
{
  long long v4 = *(_OWORD *)&CGAffineTransformIdentity.c;
  long long v5 = *(_OWORD *)&CGAffineTransformIdentity.a;
  *(_OWORD *)a1 = *(_OWORD *)&CGAffineTransformIdentity.a;
  *(_OWORD *)(a1 + 16) = v4;
  long long v3 = *(_OWORD *)&CGAffineTransformIdentity.tx;
  *(_OWORD *)(a1 + 32) = v3;
  Class result = (CGAffineTransform *)CGSVGNodeFindAttribute();
  if (result)
  {
    Class result = (CGAffineTransform *)CGSVGAttributeGetFloats();
    if (result)
    {
      *(_OWORD *)&t1.a = v5;
      *(_OWORD *)&t1.c = v4;
      *(_OWORD *)&t1.tuint32_t x = v3;
      CGAffineTransform t2 = v8;
      return CGAffineTransformConcat((CGAffineTransform *)a1, &t1, &t2);
    }
  }
  return result;
}

void __CUIAccumulateSVGShapesIntoJoinedPath_block_invoke_2(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      BOOL IsEmpty = CGPathIsEmpty(*(CGPathRef *)(a1 + 32));
      long long v5 = *(CGPath **)(a1 + 32);
      if (!IsEmpty) {
        goto LABEL_13;
      }
      CFDataRef v6 = *(double **)(a2 + 8);
      CGFloat v7 = *v6;
      CGFloat v8 = v6[1];
      CGPathMoveToPoint(v5, (const CGAffineTransform *)(a1 + 40), v7, v8);
      break;
    case 1:
      long long v5 = *(CGPath **)(a1 + 32);
LABEL_13:
      CGPoint CurrentPoint = CGPathGetCurrentPoint(v5);
      uint64_t v24 = *(double **)(a2 + 8);
      double v25 = *v24;
      double v26 = v24[1];
      if (vabdd_f64(CurrentPoint.x, *(double *)(a1 + 120) + v26 * *(double *)(a1 + 104) + *(double *)(a1 + 88) * *v24) > 0.00000011920929
        || vabdd_f64(CurrentPoint.y, *(double *)(a1 + 128) + v26 * *(double *)(a1 + 112) + *(double *)(a1 + 96) * v25) > 0.00000011920929)
      {
        uint64_t v27 = *(CGPath **)(a1 + 32);
        CGPathAddLineToPoint(v27, (const CGAffineTransform *)(a1 + 40), v25, v26);
      }
      break;
    case 2:
      long long v9 = *(CGPath **)(a1 + 32);
      long long v10 = *(double **)(a2 + 8);
      CGFloat v11 = *v10;
      CGFloat v12 = v10[1];
      CGFloat v13 = v10[2];
      CGFloat v14 = v10[3];
      CGPathAddQuadCurveToPoint(v9, (const CGAffineTransform *)(a1 + 40), v11, v12, v13, v14);
      break;
    case 3:
      long long v15 = *(CGPath **)(a1 + 32);
      long long v16 = *(double **)(a2 + 8);
      CGFloat v17 = *v16;
      CGFloat v18 = v16[1];
      CGFloat v19 = v16[2];
      CGFloat v20 = v16[3];
      CGFloat v21 = v16[4];
      CGFloat v22 = v16[5];
      CGPathAddCurveToPoint(v15, (const CGAffineTransform *)(a1 + 40), v17, v18, v19, v20, v21, v22);
      break;
    default:
      return;
  }
}

void CUIAccumulateSVGShapesIntoPath(uint64_t a1, uint64_t a2, CGPath *a3)
{
  CompoundCGPath = (const CGPath *)CGSVGNodeCreateCompoundCGPath();
  CGPathAddPath(a3, 0, CompoundCGPath);
  CGPathRelease(CompoundCGPath);
}

CGMutablePathRef CUICreateJoinedPathFromSVGNode()
{
  CGMutablePathRef Mutable = CGPathCreateMutable();
  CGSVGNodeEnumerate();
  return Mutable;
}

id CUIStringFromClipStrokeKeyframeData(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v2 = [a1 length];
  id v3 = 0;
  if (v2)
  {
    unint64_t v4 = (unint64_t)v2;
    if ((v2 & 0xF) == 0)
    {
      id v3 = +[NSMutableString string];
      [v3 appendString:@"0"];
      for (unint64_t i = 0; i < v4; i += 16)
      {
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        objc_msgSend(a1, "getBytes:range:", (char *)&v8 + 4, i, 4);
        objc_msgSend(a1, "getBytes:range:", &v8, i + 4, 4);
        objc_msgSend(a1, "getBytes:range:", (char *)&v7 + 4, i + 8, 4);
        objc_msgSend(a1, "getBytes:range:", &v7, i + 12, 4);
        [v3 appendString:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @" %u %f %f %f", HIDWORD(v8), *(float *)&v8, *((float *)&v7 + 1), *(float *)&v7)];
      }
    }
  }
  return v3;
}

id CUIAddClipStrokeKeyframeDataToNode(uint64_t a1, void *a2)
{
  id result = CUIStringFromClipStrokeKeyframeData(a2);
  if (result)
  {
    if (CUIVectorGlyphClipStrokeKeyframesAtom_onceToken != -1) {
      dispatch_once(&CUIVectorGlyphClipStrokeKeyframesAtom_onceToken, &__block_literal_global_5);
    }
    CGSVGAttributeCreateWithString();
    CGSVGNodeSetAttribute();
    return (id)CGSVGAttributeRelease();
  }
  return result;
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void CUIAddPathToSVGShapeNode(uint64_t a1, void *a2)
{
  [a2 path];
  unint64_t v4 = (const void *)CGSVGPathCreateWithCGPath();
  CGSVGShapeNodeSetPath();
  CUIAddClipStrokeKeyframeDataToNode(a1, [a2 clipStrokeKeyframes]);
  CFRelease(v4);
}

id CUICreateSubpathArrayFromCGPath(const CGPath *a1)
{
  if (!a1) {
    return 0;
  }
  id v2 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0];
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2020000000;
  v5[3] = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = __CUICreateSubpathArrayFromCGPath_block_invoke;
  v4[3] = &unk_1E5A51DD0;
  v4[4] = v2;
  v4[5] = v5;
  CGPathApplyWithBlock(a1, v4);
  _Block_object_dispose(v5, 8);
  return v2;
}

void sub_1A1352F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CUICreateSubpathArrayFromCGPath_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    if (*(_DWORD *)a2 == 4) {
      return;
    }
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CGPathCreateMutable();
  }
  switch(*(_DWORD *)a2)
  {
    case 0:
      unint64_t v4 = *(CGPath **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      long long v5 = *(double **)(a2 + 8);
      CGFloat v6 = *v5;
      CGFloat v7 = v5[1];
      CGPathMoveToPoint(v4, 0, v6, v7);
      break;
    case 1:
      uint64_t v8 = *(CGPath **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      long long v9 = *(double **)(a2 + 8);
      CGFloat v10 = *v9;
      CGFloat v11 = v9[1];
      CGPathAddLineToPoint(v8, 0, v10, v11);
      break;
    case 2:
      CGFloat v12 = *(CGPath **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      CGFloat v13 = *(double **)(a2 + 8);
      CGFloat v14 = *v13;
      CGFloat v15 = v13[1];
      CGFloat v16 = v13[2];
      CGFloat v17 = v13[3];
      CGPathAddQuadCurveToPoint(v12, 0, v14, v15, v16, v17);
      break;
    case 3:
      CGFloat v18 = *(CGPath **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      CGFloat v19 = *(double **)(a2 + 8);
      CGFloat v20 = *v19;
      CGFloat v21 = v19[1];
      CGFloat v22 = v19[2];
      CGFloat v23 = v19[3];
      CGFloat v24 = v19[4];
      CGFloat v25 = v19[5];
      CGPathAddCurveToPoint(v18, 0, v20, v21, v22, v23, v24, v25);
      break;
    case 4:
      double v26 = *(CGPath **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      if (v26)
      {
        CGPathCloseSubpath(v26);
        [*(id *)(a1 + 32) addObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];
        CGPathRelease(*(CGPathRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
      }
      break;
    default:
      return;
  }
}

id CUICreateSubpathsFromSVGNode(id result)
{
  if (result)
  {
    id v1 = CUICreatePathFromSVGNode(result, (long long *)&CGAffineTransformIdentity);
    id v2 = [v1 createSubpaths];

    return v2;
  }
  return result;
}

vImage_Error CUIComputeImageColorHistogramARGB(CGImage *a1, const vImage_Buffer *a2, vImagePixelCount *a3)
{
  histogram[0] = a3;
  histogram[1] = a3 + 1024;
  histogram[2] = a3 + 2048;
  histogram[3] = a3 + 3072;
  if (CGImageGetBitsPerComponent(a1) < 9) {
    return vImageHistogramCalculation_ARGB8888(a2, histogram, 0x100u);
  }
  else {
    return vImageHistogramCalculation_ARGBFFFF(a2, histogram, 0x400u, 0.0, 1.0, 0x100u);
  }
}

BOOL CUIColorHistogramARGBIsMonochrome(uint64_t a1)
{
  return !memcmp((const void *)(a1 + 0x2000), (const void *)(a1 + 0x4000), 0x2000uLL)
      && memcmp((const void *)(a1 + 0x4000), (const void *)(a1 + 24576), 0x2000uLL) == 0;
}

double CUIColorHistogramARGBIntersection(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  int64x2_t v3 = 0uLL;
  int64x2_t v4 = 0uLL;
  int64x2_t v5 = 0uLL;
  do
  {
    int64x2_t v6 = *(int64x2_t *)(a1 + v2 + 0x2000);
    int64x2_t v7 = *(int64x2_t *)(a2 + v2 + 0x2000);
    int64x2_t v8 = *(int64x2_t *)(a1 + v2 + 0x4000);
    int64x2_t v9 = *(int64x2_t *)(a2 + v2 + 0x4000);
    int64x2_t v10 = *(int64x2_t *)(a1 + v2 + 24576);
    int64x2_t v11 = *(int64x2_t *)(a2 + v2 + 24576);
    int64x2_t v5 = vaddq_s64(vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v7, (uint64x2_t)v6), (int8x16_t)v6, (int8x16_t)v7), v5), vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v9, (uint64x2_t)v8), (int8x16_t)v8, (int8x16_t)v9), (int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v11, (uint64x2_t)v10), (int8x16_t)v10, (int8x16_t)v11)));
    int64x2_t v4 = vaddq_s64(vaddq_s64(v6, v4), vaddq_s64(v8, v10));
    int64x2_t v3 = vaddq_s64(vaddq_s64(v7, v3), vaddq_s64(v9, v11));
    v2 += 16;
  }
  while (v2 != 0x2000);
  unint64_t v12 = vaddvq_s64(v5);
  unint64_t v13 = vaddvq_s64(v4);
  unint64_t v14 = vaddvq_s64(v3);
  if (v13 >= v14) {
    unint64_t v15 = v14;
  }
  else {
    unint64_t v15 = v13;
  }
  return (double)v12 / (double)v15;
}

id CUIStartFocusRingInternal()
{
  return +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
}

void DrawThemeImageWithOperation(void *a1, CGContextRef c, CGBlendMode a3, int a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9)
{
  CGContextSaveGState(c);
  if (a4) {
    +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
  }
  if (a3) {
    CGContextSetBlendMode(c, a3);
  }
  double v18 = fabs(a9);
  if (v18 != 1.0) {
    CGContextSetAlpha(c, v18);
  }
  CGFloat v19 = (CGImage *)[a1 image];
  if (v19)
  {
    v21.origin.uint32_t x = a5;
    v21.origin.y = a6;
    v21.size.width = a7;
    v21.size.height = a8;
    CGContextDrawImage(c, v21, v19);
  }
  if (a4) {
    +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
  }
  CGContextRestoreGState(c);
}

void DrawOnePartElementFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12, int a13, void *a14)
{
  if ([a8 isTiled])
  {
    id v26 = [a8 imageForSliceIndex:a13];
    [a8 scale];
    double v28 = v27;
    if (a5 < 0.0) {
      a12 = kCGBlendModeSourceAtop;
    }
    v44.origin.uint32_t x = a1;
    v44.origin.y = a2;
    v44.size.width = a3;
    v44.size.height = a4;
    if (!NSIsEmptyRect(v44))
    {
      CGContextSaveGState(a9);
      if (a10)
      {
        +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
        _CUITileImageWithOperation(v26, a9, a12, a1, a2, a3, a4, v28, a5);
        +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
      }
      else
      {
        _CUITileImageWithOperation(v26, a9, a12, a1, a2, a3, a4, v28, a5);
      }
      CGContextRestoreGState(a9);
    }
  }
  else
  {
    unsigned int v29 = [a8 isScaled];
    id v30 = [a8 imageForSliceIndex:a13];
    uint64_t v31 = v30;
    if (v29)
    {
      if (a5 >= 0.0) {
        CGBlendMode v32 = a12;
      }
      else {
        CGBlendMode v32 = kCGBlendModeSourceAtop;
      }
      double v33 = a1;
      double v34 = a2;
      CGFloat v35 = a3;
      CGFloat v36 = a4;
      double v37 = a9;
      double v38 = a5;
    }
    else
    {
      [a8 scale];
      double v40 = v39;
      v45.origin.uint32_t x = a1;
      v45.origin.y = a2;
      v45.size.width = a3;
      v45.size.height = a4;
      if (NSIsEmptyRect(v45)) {
        return;
      }
      if (a5 < 0.0) {
        a12 = kCGBlendModeSourceAtop;
      }
      [v31 size];
      CGFloat v35 = v41;
      CGFloat v36 = v42;
      double v33 = a1 + floor((a3 - v41 * a6 / v40) * 0.5);
      double v34 = a2 + floor((a4 - v42 * a6 / v40) * 0.5);
      id v30 = v31;
      double v37 = a9;
      double v38 = a5;
      CGBlendMode v32 = a12;
    }
    DrawOnePartImageWithOperation(v30, v37, v32, a10, a14, v33, v34, v35, v36, v38);
  }
}

void DrawOnePartImageWithOperation(void *a1, CGContext *a2, CGBlendMode a3, int a4, void *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10)
{
  if (!NSIsEmptyRect(*(NSRect *)&a6))
  {
    double v27 = a10;
    CGContextSaveGState(a2);
    if (a4) {
      +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
    }
    v29.origin.CGFloat x = a6;
    v29.origin.CGFloat y = a7;
    v29.size.CGFloat width = a8;
    v29.size.CGFloat height = a9;
    CGContextClipToRect(a2, v29);
    ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(a2);
    CGFloat x = ClipBoundingBox.origin.x;
    CGFloat y = ClipBoundingBox.origin.y;
    CGFloat width = ClipBoundingBox.size.width;
    CGFloat height = ClipBoundingBox.size.height;
    if (a3) {
      CGContextSetBlendMode(a2, a3);
    }
    double v24 = fabs(v27);
    if (v24 != 1.0) {
      CGContextSetAlpha(a2, v24);
    }
    v31.origin.CGFloat x = x;
    v31.origin.CGFloat y = y;
    v31.size.CGFloat width = width;
    v31.size.CGFloat height = height;
    if (!CGRectIsEmpty(v31))
    {
      CGFloat v25 = (CGImage *)[a1 image];
      id v26 = v25;
      if (a5) {
        id v26 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v25 withScale:1 cache:1.0];
      }
      else {
        CGImageRetain(v25);
      }
      v32.origin.CGFloat x = a6;
      v32.origin.CGFloat y = a7;
      v32.size.CGFloat width = a8;
      v32.size.CGFloat height = a9;
      CGContextDrawImage(a2, v32, v26);
      CGImageRelease(v26);
    }
    if (a4) {
      +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
    }
    CGContextRestoreGState(a2);
  }
}

void DrawOnePartMaskFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, uint64_t a6, void *a7, CGContext *a8, int a9, uint64_t a10, CGBlendMode a11, int a12)
{
  id v20 = [a7 maskForSliceIndex:a12];
  if (a5 >= 0.0) {
    CGBlendMode v21 = a11;
  }
  else {
    CGBlendMode v21 = kCGBlendModeSourceAtop;
  }
  DrawOnePartImageWithOperation(v20, a8, v21, a9, 0, a1, a2, a3, a4, a5);
}

void DrawAbsoluteAnimationFrameWithOperation(void *a1, CGContext *a2, CGBlendMode a3, int a4, double a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, uint64_t a11, uint64_t a12)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  Point v12[2] = __DrawAbsoluteAnimationFrameWithOperation_block_invoke;
  v12[3] = &__block_descriptor_40_e8_q16__0q8l;
  *(double *)&v12[4] = a5;
  DrawQualifiedAnimationFrameWithOperation((uint64_t)v12, a1, a2, a3, a4, a6, a7, a8, a9, a10, a12, 0);
}

unint64_t __DrawAbsoluteAnimationFrameWithOperation_block_invoke(uint64_t a1, uint64_t a2)
{
  return vcvtmd_s64_f64(fmod(*(long double *)(a1 + 32), (double)a2));
}

void DrawQualifiedAnimationFrameWithOperation(uint64_t a1, void *a2, CGContext *a3, CGBlendMode a4, int a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, uint64_t a11, void *a12)
{
  double v21 = a6;
  if (!NSIsEmptyRect(*(NSRect *)&a6))
  {
    double v61 = a10;
    CGFloat v23 = +[CUIImage imageWithCGImage:](CUIImage, "imageWithCGImage:", [a2 unslicedImage]);
    [(CUIImage *)v23 size];
    double v25 = v24;
    double v27 = v26;
    objc_msgSend(objc_msgSend(a2, "imageForSliceIndex:", 0), "size");
    double v30 = v28;
    double v31 = v29;
    if (v28 >= v25)
    {
      double v34 = 0.0;
      if (v29 == 0.0) {
        double v33 = 1.0;
      }
      else {
        double v33 = v27 / v29 + -1.0;
      }
      double v32 = v29;
    }
    else
    {
      double v32 = 0.0;
      if (v28 == 0.0) {
        double v33 = 1.0;
      }
      else {
        double v33 = v25 / v28 + -1.0;
      }
      double v34 = v30;
    }
    uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 16))(a1, (uint64_t)v33);
    CGFloat v36 = [(CUIImage *)v23 image];
    if (v36)
    {
      uint64_t v43 = v36;
      double v44 = v34 * (double)v35;
      double v45 = v32 * (double)v35;
      if (a12)
      {
        double v46 = v44;
        [a2 scale];
        uint64_t v47 = (CGImage *)objc_msgSend(a12, "newFlattenedImageFromShapeCGImage:withScale:cache:", v43, 1);
        double v44 = v46;
        if (v47) {
          uint64_t v43 = v47;
        }
      }
      double v48 = v45;
      double v49 = v30;
      double v50 = v31;
      float v51 = CGImageCreateWithImageInRect(v43, *(CGRect *)&v44);
      if (!v51)
      {
        v63.origin.CGFloat x = v21;
        v63.origin.CGFloat y = a7;
        v63.size.CGFloat width = a8;
        v63.size.CGFloat height = a9;
        NSStringFromRect(v63);
        _CUILog(4, (uint64_t)"CoreUI: error %s got a invalid subimage '%@' for rendition %@", v52, v53, v54, v55, v56, v57, (uint64_t)"void DrawQualifiedAnimationFrameWithOperation(CFIndex (^)(NSInteger), NSRect, CUIThemeRendition *, CGContextRef, CGBlendMode, CGFloat, CUIFocusRingType, CGColorRef, CUIShapeEffectStack *)");
      }
      double v58 = v21 + floor(a8 * 0.5 - v30 * 0.5);
      if (a8 > v30)
      {
        double v21 = v58;
        a8 = v30;
      }
      double v59 = a7 + floor(a9 * 0.5 - v31 * 0.5);
      if (a9 > v31)
      {
        a7 = v59;
        a9 = v31;
      }
      CGContextSaveGState(a3);
      if (a5) {
        +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
      }
      if (a4) {
        CGContextSetBlendMode(a3, a4);
      }
      double v60 = fabs(v61);
      if (v60 != 1.0) {
        CGContextSetAlpha(a3, v60);
      }
      v64.origin.CGFloat x = v21;
      v64.origin.CGFloat y = a7;
      v64.size.CGFloat width = a8;
      v64.size.CGFloat height = a9;
      CGContextDrawImage(a3, v64, v51);
      if (a5) {
        +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
      }
      CGContextRestoreGState(a3);
      CGImageRelease(v51);
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: error %s got a couldn't find an image for %@", v37, v38, v39, v40, v41, v42, (uint64_t)"void DrawQualifiedAnimationFrameWithOperation(CFIndex (^)(NSInteger), NSRect, CUIThemeRendition *, CGContextRef, CGBlendMode, CGFloat, CUIFocusRingType, CGColorRef, CUIShapeEffectStack *)");
    }
  }
}

void DrawAnimationFrameMappedFrom0_1RangedValue(void *a1, CGContext *a2, CGBlendMode a3, int a4, double a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, uint64_t a11, void *a12)
{
  if (a5 < 0.0) {
    a5 = 0.0;
  }
  if (a5 > 1.0) {
    a5 = 1.0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  Point v12[2] = __DrawAnimationFrameMappedFrom0_1RangedValue_block_invoke;
  v12[3] = &__block_descriptor_40_e8_q16__0q8l;
  *(double *)&v12[4] = a5;
  DrawQualifiedAnimationFrameWithOperation((uint64_t)v12, a1, a2, a3, a4, a6, a7, a8, a9, a10, (uint64_t)a12, a12);
}

void DrawThreePartElementFromRenditionWithOperation(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12, int a13, int a14, int a15, void *a16)
{
  id v27 = [a8 imageForSliceIndex:a13];
  id v28 = [a8 imageForSliceIndex:a14];
  id v29 = [a8 imageForSliceIndex:a15];
  BOOL v30 = [a8 type] == (id)2;
  [a8 scale];
  DrawThreePartImageWithOperation(v27, v29, v28, v30, a9, a12, a10, a16, a1, a2, a3, a4, v31, a5, a6);
}

void DrawThreePartImageWithOperation(void *a1, void *a2, void *a3, int a4, CGContext *a5, CGBlendMode a6, int a7, void *a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15)
{
  if (a12 == 0.0 || a11 == 0.0) {
    return;
  }
  double v25 = a12;
  [a1 size];
  double v30 = v29;
  double v32 = v31;
  [a2 size];
  double v85 = v34;
  double v86 = v33;
  char v90 = 0;
  uint64_t v91 = 0;
  uint64_t v92 = 0;
  CGContextSaveGState(a5);
  if (a7) {
    +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
  }
  if (a6) {
    CGContextSetBlendMode(a5, a6);
  }
  double v35 = fabs(a14);
  if (v35 != 1.0) {
    CGContextSetAlpha(a5, v35);
  }
  double v84 = a13;
  double v36 = a15 / a13;
  if (!a4)
  {
    double v49 = v36 * v30;
    double v50 = v36 * v32;
    double v51 = v36 * v86;
    double v52 = a11;
    if (v50 == 0.0)
    {
      double v53 = a10;
    }
    else
    {
      double v53 = a10;
      if (v25 - v50 != 0.0)
      {
        double v54 = a9;
        double v55 = a10;
        double v56 = v25;
        *(NSRect *)(&v52 - 2) = NSInsetRect(*(NSRect *)(&v52 - 2), 0.0, (v25 - v50) * 0.5);
        double v58 = v57;
        double v25 = v59;
        double v53 = floor(v60 + 0.001);
LABEL_29:
        double v65 = v52 * 0.5;
        double v66 = ceil(v52 * 0.5);
        if (v49 <= v52 * 0.5) {
          double v67 = v49;
        }
        else {
          double v67 = v66;
        }
        double v68 = floor(v65);
        if (v51 <= v65) {
          double v69 = v36 * v86;
        }
        else {
          double v69 = v68;
        }
        double aRectb = v52;
        if (v49 + v51 > v52)
        {
          double v49 = v67;
          double v51 = v69;
        }
        uint64_t v70 = (CGImage *)objc_msgSend(a1, "image", *(void *)&v84);
        unint64_t v71 = v70;
        if (a8) {
          unint64_t v71 = (CGImage *)[a8 newFlattenedImageFromShapeCGImage:v70 withScale:1 cache:a15];
        }
        else {
          CGImageRetain(v70);
        }
        char v90 = v71;
        uint64_t v74 = (CGImage *)[a2 image];
        uint64_t v75 = v74;
        if (a8) {
          uint64_t v75 = (CGImage *)[a8 newFlattenedImageFromShapeCGImage:v74 withScale:1 cache:a15];
        }
        else {
          CGImageRetain(v74);
        }
        uint64_t v91 = v75;
        uint64_t v79 = (CGImage *)[a3 image];
        int v80 = v79;
        if (a8) {
          int v80 = (CGImage *)[a8 newFlattenedImageFromShapeCGImage:v79 withScale:1 cache:a15];
        }
        else {
          CGImageRetain(v79);
        }
        [a3 size];
        v93.origin.CGFloat x = v58 + v49;
        v93.origin.CGFloat y = v53;
        v93.size.CGFloat width = aRectb - v49 - v51;
        v93.size.CGFloat height = v25;
        uint64_t v92 = v80;
        CGRectGetMaxY(v93);
        CGContextDrawImages();
        for (uint64_t i = 0; i != 24; i += 8)
          CGImageRelease(*(CGImage **)((char *)&v90 + i));
        goto LABEL_61;
      }
    }
    double v58 = a9;
    goto LABEL_29;
  }
  double v37 = v36 * v32;
  double v38 = v36 * v30;
  double v39 = v36 * v85;
  double v40 = a11;
  if (v38 == 0.0)
  {
    double v41 = a10;
    goto LABEL_17;
  }
  double v41 = a10;
  if (v40 - v38 == 0.0)
  {
LABEL_17:
    double v48 = a9;
    goto LABEL_18;
  }
  double v42 = a9;
  double v43 = a10;
  double v44 = v25;
  *(NSRect *)(&v40 - 2) = NSInsetRect(*(NSRect *)(&v40 - 2), (v40 - v38) * 0.5, 0.0);
  double v41 = v45;
  double v25 = v46;
  double v48 = floor(v47 + 0.001);
LABEL_18:
  CGFloat aRecta = v40;
  if (v37 + v39 > v25)
  {
    double v61 = v25 * 0.5;
    if (v37 <= v25 * 0.5) {
      double v62 = v37;
    }
    else {
      double v62 = v25 * 0.5;
    }
    double v37 = ceil(v62);
    if (v39 <= v61) {
      double v61 = v36 * v85;
    }
    double v39 = floor(v61);
  }
  NSRect v63 = (CGImage *)objc_msgSend(a1, "image", *(void *)&v84);
  CGRect v64 = v63;
  if (a8) {
    CGRect v64 = (CGImage *)[a8 newFlattenedImageFromShapeCGImage:v63 withScale:1 cache:a15];
  }
  else {
    CGImageRetain(v63);
  }
  char v90 = v64;
  uint64_t v72 = (CGImage *)[a2 image];
  uint64_t v73 = v72;
  if (a8) {
    uint64_t v73 = (CGImage *)[a8 newFlattenedImageFromShapeCGImage:v72 withScale:1 cache:a15];
  }
  else {
    CGImageRetain(v72);
  }
  uint64_t v91 = v73;
  if (v25 - (v39 + v37) <= 0.0)
  {
    uint64_t v78 = 2;
  }
  else
  {
    uint64_t v76 = (CGImage *)[a3 image];
    id v77 = v76;
    if (a8) {
      id v77 = (CGImage *)[a8 newFlattenedImageFromShapeCGImage:v76 withScale:1 cache:a15];
    }
    else {
      CGImageRetain(v76);
    }
    [a3 size];
    v94.origin.CGFloat x = v48;
    v94.origin.CGFloat y = v41 + v39;
    v94.size.CGFloat width = aRecta;
    v94.size.CGFloat height = v25 - (v39 + v37);
    uint64_t v92 = v77;
    CGRectGetMaxY(v94);
    uint64_t v78 = 3;
  }
  uint64_t v82 = &v90;
  CGContextDrawImages();
  do
  {
    uint64_t v83 = *v82++;
    CGImageRelease(v83);
    --v78;
  }
  while (v78);
LABEL_61:
  if (a7) {
    +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
  }
  CGContextRestoreGState(a5);
}

void DrawThreePartMaskFromRenditionWithOperation(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12)
{
  id v22 = [a8 maskForSliceIndex:0];
  id v23 = [a8 maskForSliceIndex:2];
  id v24 = [a8 maskForSliceIndex:1];
  BOOL v25 = [a8 type] == (id)2;
  [a8 scale];
  DrawThreePartImageWithOperation(v22, v23, v24, v25, a9, a12, a10, 0, a1, a2, a3, a4, v26, a5, a6);
}

void DrawPulsedElementFromRenditionKey(uint64_t a1, void *a2, CGContext *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  id v24 = (void *)_LookupStructuredThemeProvider(a1, a2);
  if (a10 > 1.0 && (objc_msgSend(v24, "canGetRenditionWithKey:", objc_msgSend(a2, "keyList")) & 1) == 0) {
    [a2 setThemeScale:1];
  }
  id v25 = objc_msgSend(v24, "renditionWithKey:", objc_msgSend(a2, "keyList"));
  id v26 = [v25 type];
  if ((unint64_t)v26 >= 3)
  {
    _CUILog(4, (uint64_t)"Can only pulse one- and three-part renditions", v27, v28, v29, v30, v31, v32, a15);
  }
  else
  {
    id v33 = v26;
    unint64_t v34 = 0x1E5A50000uLL;
    if (a4) {
      +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
    }
    CGContextBeginTransparencyLayer(a3, 0);
    char v35 = objc_opt_respondsToSelector();
    uint64_t v36 = 0;
    if (v35)
    {
      LOWORD(v36) = (unsigned __int16)[a2 themeLayer];
      [a2 setThemeLayer:3];
      uint64_t v36 = (unsigned __int16)v36;
    }
    id v37 = [v25 imageForSliceIndex:0];
    double v38 = v37;
    if (v33)
    {
      BOOL v39 = v33 == (id)2;
      id v40 = [v25 imageForSliceIndex:2];
      char v52 = v35;
      int v41 = a4;
      uint64_t v42 = v36;
      id v43 = [v25 imageForSliceIndex:1];
      [v25 scale];
      double v44 = v40;
      unint64_t v34 = 0x1E5A50000;
      DrawThreePartImageWithOperation(v38, v44, v43, v39, a3, kCGBlendModeCopy, 0, 0, a5, a6, a7, a8, v45, 1.0 - a9, a10);
      id v46 = objc_msgSend(v24, "renditionWithKey:", objc_msgSend(a2, "keyList"));
      id v47 = [v46 imageForSliceIndex:0];
      id v48 = [v46 imageForSliceIndex:2];
      id v49 = [v46 imageForSliceIndex:1];
      double v50 = v46;
      uint64_t v36 = v42;
      a4 = v41;
      char v35 = v52;
      [v50 scale];
      DrawThreePartImageWithOperation(v47, v48, v49, v39, a3, kCGBlendModePlusLighter, 0, 0, a5, a6, a7, a8, v51, a9, a10);
    }
    else
    {
      DrawThemeImageWithOperation(v37, a3, kCGBlendModeCopy, 0, a5, a6, a7, a8, 1.0 - a9);
      DrawThemeImageWithOperation(objc_msgSend(objc_msgSend(v24, "renditionWithKey:", objc_msgSend(a2, "keyList")), "imageForSliceIndex:", 0), a3, kCGBlendModeNormal, 0, a5, a6, a7, a8, a9);
    }
    CGContextEndTransparencyLayer(a3);
    if (a4) {
      [*(id *)(v34 + 2960) raise:NSGenericException format:@"Focus Ring drawing not supported"];
    }
    if (v35)
    {
      [a2 setThemeLayer:v36];
    }
  }
}

void DrawNinePartElementFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12, void *a13)
{
  unsigned __int8 v20 = [a8 edgesOnly];
  uint64_t v36 = [_CUINineImagePieces alloc];
  if (v20) {
    id v21 = 0;
  }
  else {
    id v21 = [a8 imageForSliceIndex:4];
  }
  id v22 = [a8 imageForSliceIndex:0];
  id v23 = [a8 imageForSliceIndex:1];
  id v24 = [a8 imageForSliceIndex:2];
  id v25 = [a8 imageForSliceIndex:5];
  id v26 = [a8 imageForSliceIndex:8];
  id v27 = [a8 imageForSliceIndex:7];
  id v28 = [a8 imageForSliceIndex:6];
  id v29 = [a8 imageForSliceIndex:3];
  LOBYTE(v31) = [a8 isTiled];
  id v37 = [(_CUINineImagePieces *)v36 initWithCenter:v21 topLeft:v22 top:v23 topRight:v24 right:v25 bottomRight:v26 bottom:v27 bottomLeft:v28 left:v29 tileCenterAndEdges:v31];
  [a8 scale];
  DrawNinePartImageWithOperation(v37, a9, a12, a10, a13, a1, a2, a3, a4, v30, a5, a6);
}

void DrawNinePartImageWithOperation(void *a1, CGContext *a2, CGBlendMode a3, int a4, void *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9, double a10, double a11, double a12)
{
  if (!NSIsEmptyRect(*(NSRect *)&a6))
  {
    uint64_t v208 = 0;
    memset(v207, 0, sizeof(v207));
    CGContextSaveGState(a2);
    if (a4 == 1) {
      +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
    }
    v214.origin.CGFloat x = a6;
    v214.origin.CGFloat y = a7;
    v214.size.CGFloat width = a8;
    v214.size.CGFloat height = a9;
    CGContextClipToRect(a2, v214);
    ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(a2);
    CGFloat y = ClipBoundingBox.origin.y;
    CGFloat rect = ClipBoundingBox.origin.x;
    CGFloat r2_16 = ClipBoundingBox.size.height;
    CGFloat r2_24 = ClipBoundingBox.size.width;
    if (a3) {
      CGContextSetBlendMode(a2, a3);
    }
    double v24 = fabs(a11);
    if (v24 != 1.0) {
      CGContextSetAlpha(a2, v24);
    }
    id v25 = [a1 topLeft];
    [v25 size];
    double v172 = a10;
    double v26 = a12 / a10;
    double r1_16 = a12 / a10 * v27;
    double v29 = a12 / a10 * v28;
    double v30 = (CGImage *)[v25 image];
    uint64_t v31 = v30;
    if (a5) {
      uint64_t v31 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v30 withScale:1 cache:a12];
    }
    else {
      CGImageRetain(v30);
    }
    double v180 = a9;
    double v32 = a7 + a9 - v29;
    v216.origin.CGFloat x = a6;
    v216.origin.CGFloat y = v32;
    v216.size.CGFloat width = r1_16;
    v216.size.CGFloat height = v29;
    v252.origin.CGFloat y = y;
    v252.origin.CGFloat x = rect;
    v252.size.CGFloat height = r2_16;
    v252.size.CGFloat width = r2_24;
    CGRect v217 = CGRectIntersection(v216, v252);
    double r2 = a12;
    CGFloat r2_8 = a7;
    double r1_8 = v29;
    if (CGRectIsEmpty(v217))
    {
      CGImageRelease(v31);
      uint64_t v33 = 0;
    }
    else
    {
      CGFloat v210 = a6;
      double v211 = a7 + a9 - v29;
      double v212 = r1_16;
      double v213 = v29;
      *(CGFloat *)uint64_t v209 = a6;
      *(double *)&v209[1] = v211;
      *(double *)&v209[2] = r1_16;
      *(double *)&v209[3] = v29;
      uint64_t v33 = 1;
      *(void *)&v207[0] = v31;
    }
    id v34 = [a1 topRight];
    [v34 size];
    double v35 = v26;
    double v37 = v26 * v36;
    double v39 = v26 * v38;
    double v181 = a8;
    double r1_24 = a6 + a8;
    double v40 = a6 + a8 - v26 * v36;
    int v41 = (CGImage *)[v34 image];
    uint64_t v42 = v41;
    if (a5) {
      uint64_t v42 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v41 withScale:1 cache:r2];
    }
    else {
      CGImageRetain(v41);
    }
    v218.origin.CGFloat x = v40;
    v218.origin.CGFloat y = v32;
    v218.size.CGFloat width = v37;
    v218.size.CGFloat height = v39;
    v253.origin.CGFloat y = y;
    v253.origin.CGFloat x = rect;
    v253.size.CGFloat height = r2_16;
    v253.size.CGFloat width = r2_24;
    CGRect v219 = CGRectIntersection(v218, v253);
    if (CGRectIsEmpty(v219))
    {
      CGImageRelease(v42);
    }
    else
    {
      id v43 = &v210 + 4 * v33;
      *id v43 = v40;
      v43[1] = v32;
      v43[2] = v37;
      v43[3] = v39;
      double v44 = (double *)&v209[4 * v33];
      double *v44 = v40;
      v44[1] = v32;
      v44[2] = v37;
      v44[3] = v39;
      double v45 = (void *)((unint64_t)v207 | (8 * v33++));
      void *v45 = v42;
    }
    id v46 = [a1 bottomLeft];
    [v46 size];
    double v48 = v26 * v47;
    double v50 = v26 * v49;
    double v51 = (CGImage *)[v46 image];
    char v52 = v51;
    if (a5) {
      char v52 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v51 withScale:1 cache:r2];
    }
    else {
      CGImageRetain(v51);
    }
    v220.origin.CGFloat x = a6;
    v220.origin.CGFloat y = r2_8;
    v220.size.CGFloat width = v48;
    v220.size.CGFloat height = v50;
    v254.origin.CGFloat y = y;
    v254.origin.CGFloat x = rect;
    v254.size.CGFloat height = r2_16;
    v254.size.CGFloat width = r2_24;
    CGRect v221 = CGRectIntersection(v220, v254);
    if (CGRectIsEmpty(v221))
    {
      CGImageRelease(v52);
    }
    else
    {
      double v53 = &v210 + 4 * v33;
      *double v53 = a6;
      v53[1] = r2_8;
      v53[2] = v48;
      v53[3] = v50;
      *((void *)v207 + v33) = v52;
      double v54 = (CGFloat *)&v209[4 * v33];
      *double v54 = a6;
      v54[1] = r2_8;
      ++v33;
      v54[2] = v48;
      v54[3] = v50;
    }
    id v55 = [a1 bottomRight];
    [v55 size];
    double v57 = v26 * v56;
    double v58 = (CGImage *)[v55 image];
    double v59 = v58;
    double v179 = a6;
    if (a5) {
      double v59 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v58 withScale:1 cache:r2];
    }
    else {
      CGImageRetain(v58);
    }
    double v60 = r1_24 - v57;
    v222.origin.CGFloat x = r1_24 - v57;
    v255.size.CGFloat height = r2_16;
    v222.origin.CGFloat y = r2_8;
    v222.size.CGFloat width = v57;
    v222.size.CGFloat height = v50;
    v255.origin.CGFloat y = y;
    v255.origin.CGFloat x = rect;
    v255.size.CGFloat width = r2_24;
    CGRect v223 = CGRectIntersection(v222, v255);
    double v178 = v50;
    if (CGRectIsEmpty(v223))
    {
      CGImageRelease(v59);
    }
    else
    {
      double v61 = &v210 + 4 * v33;
      CGFloat *v61 = v60;
      v61[1] = r2_8;
      v61[2] = v57;
      v61[3] = v50;
      *((void *)v207 + v33) = v59;
      double v62 = (CGFloat *)&v209[4 * v33];
      CGFloat *v62 = v60;
      v62[1] = r2_8;
      ++v33;
      v62[2] = v57;
      v62[3] = v50;
    }
    id v63 = [a1 top];
    [v63 size];
    double v65 = v64;
    double v67 = v35 * v66;
    double v68 = a6 + r1_16;
    v224.origin.CGFloat x = v179 + r1_16;
    v224.origin.CGFloat y = v32;
    double r1_16a = v181 - r1_16 - v37;
    v224.size.CGFloat width = r1_16a;
    v224.size.CGFloat height = v67;
    v256.origin.CGFloat y = y;
    v256.origin.CGFloat x = rect;
    v256.size.CGFloat height = r2_16;
    v256.size.CGFloat width = r2_24;
    CGRect v225 = CGRectIntersection(v224, v256);
    CGFloat x = v225.origin.x;
    CGFloat width = v225.size.width;
    v225.origin.CGFloat y = v32;
    v225.size.CGFloat height = v67;
    if (CGRectIsEmpty(v225))
    {
      double v71 = v180;
    }
    else
    {
      unsigned int v72 = [a1 tileCenterAndEdges];
      uint64_t v73 = (CGImage *)[v63 image];
      uint64_t v74 = v73;
      if (v72)
      {
        double v75 = v35 * v65;
        if (a5) {
          uint64_t v74 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v73 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v73);
        }
        double v71 = v180;
        v226.origin.CGFloat x = x;
        v226.origin.CGFloat y = v32;
        v226.size.CGFloat width = width;
        v226.size.CGFloat height = v67;
        CGFloat MaxY = CGRectGetMaxY(v226);
        *((void *)v207 + v33) = v74;
        id v77 = (CGFloat *)&v209[4 * v33];
        *id v77 = x;
        v77[1] = MaxY - v67;
        v77[2] = v75;
        v77[3] = v67;
        uint64_t v78 = &v210 + 4 * v33;
        *uint64_t v78 = x;
        v78[1] = v32;
        v78[2] = width;
        v78[3] = v67;
        ++v33;
      }
      else
      {
        if (a5) {
          uint64_t v74 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v73 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v73);
        }
        double v71 = v180;
        uint64_t v79 = &v210 + 4 * v33;
        *uint64_t v79 = x;
        v79[1] = v32;
        v79[2] = width;
        v79[3] = v67;
        *((void *)v207 + v33) = v74;
        int v80 = (double *)&v209[4 * v33];
        *int v80 = x;
        v80[1] = v32;
        ++v33;
        v80[2] = width;
        v80[3] = v67;
      }
    }
    id v81 = [a1 bottom];
    [v81 size];
    double v83 = v82;
    double v85 = v35 * v84;
    CGFloat r1 = v68;
    v227.origin.CGFloat x = v68;
    v257.size.CGFloat height = r2_16;
    v227.origin.CGFloat y = r2_8;
    v227.size.CGFloat width = r1_16a;
    v227.size.CGFloat height = v85;
    v257.origin.CGFloat y = y;
    v257.origin.CGFloat x = rect;
    v257.size.CGFloat width = r2_24;
    CGRect v228 = CGRectIntersection(v227, v257);
    CGFloat v86 = v228.origin.x;
    CGFloat v87 = v228.size.width;
    v228.origin.CGFloat y = r2_8;
    v228.size.CGFloat height = v85;
    if (CGRectIsEmpty(v228))
    {
      double v88 = r2_8;
      CGFloat v89 = v179;
    }
    else
    {
      unsigned int v90 = [a1 tileCenterAndEdges];
      uint64_t v91 = (CGImage *)[v81 image];
      uint64_t v92 = v91;
      CGFloat v89 = v179;
      if (v90)
      {
        double v93 = v35 * v83;
        if (a5) {
          uint64_t v92 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v91 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v91);
        }
        v229.origin.CGFloat x = v86;
        double v88 = r2_8;
        v229.origin.CGFloat y = r2_8;
        v229.size.CGFloat width = v87;
        v229.size.CGFloat height = v85;
        CGFloat v94 = CGRectGetMaxY(v229);
        *((void *)v207 + v33) = v92;
        uint64_t v95 = (CGFloat *)&v209[4 * v33];
        *uint64_t v95 = v86;
        v95[1] = v94 - v85;
        v95[2] = v93;
        _OWORD v95[3] = v85;
        uint64_t v96 = &v210 + 4 * v33;
        *uint64_t v96 = v86;
        v96[1] = r2_8;
        v96[2] = v87;
        v96[3] = v85;
        ++v33;
      }
      else
      {
        if (a5) {
          uint64_t v92 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v91 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v91);
        }
        double v88 = r2_8;
        at_size_t v97 = &v210 + 4 * v33;
        *at_size_t v97 = v86;
        v97[1] = r2_8;
        v97[2] = v87;
        v97[3] = v85;
        *((void *)v207 + v33) = v92;
        at_size_t v98 = (CGFloat *)&v209[4 * v33];
        *at_size_t v98 = v86;
        v98[1] = r2_8;
        ++v33;
        v98[2] = v87;
        v98[3] = v85;
      }
    }
    id v99 = [a1 left];
    [v99 size];
    double v101 = v100;
    double v103 = v35 * v102;
    double v104 = v88 + v178;
    double v105 = v71 - v178 - r1_8;
    v230.origin.CGFloat x = v89;
    v230.origin.CGFloat y = v88 + v178;
    v230.size.CGFloat width = v103;
    v230.size.CGFloat height = v105;
    v258.origin.CGFloat y = y;
    v258.origin.CGFloat x = rect;
    v258.size.CGFloat height = r2_16;
    v258.size.CGFloat width = r2_24;
    CGRect v231 = CGRectIntersection(v230, v258);
    CGFloat v106 = v231.origin.y;
    CGFloat height = v231.size.height;
    v231.origin.CGFloat x = v89;
    v231.size.CGFloat width = v103;
    if (!CGRectIsEmpty(v231))
    {
      unsigned int v108 = [a1 tileCenterAndEdges];
      int8x8_t v109 = (CGImage *)[v99 image];
      float32x2_t v110 = v109;
      if (v108)
      {
        double v111 = v35 * v101;
        if (a5) {
          float32x2_t v110 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v109 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v109);
        }
        v232.origin.CGFloat x = v89;
        v232.origin.CGFloat y = v106;
        v232.size.CGFloat width = v103;
        v232.size.CGFloat height = height;
        CGFloat v112 = CGRectGetMaxY(v232);
        *((void *)v207 + v33) = v110;
        v113 = (CGFloat *)&v209[4 * v33];
        CGFloat *v113 = v89;
        v113[1] = v112 - v111;
        v113[2] = v103;
        v113[3] = v111;
        long long v114 = &v210 + 4 * v33;
        *long long v114 = v89;
        v114[1] = v106;
        v114[2] = v103;
        v114[3] = height;
        ++v33;
      }
      else
      {
        if (a5) {
          float32x2_t v110 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v109 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v109);
        }
        long long v115 = &v210 + 4 * v33;
        *long long v115 = v89;
        v115[1] = v106;
        v115[2] = v103;
        v115[3] = height;
        *((void *)v207 + v33) = v110;
        long long v116 = (CGFloat *)&v209[4 * v33];
        *long long v116 = v89;
        v116[1] = v106;
        ++v33;
        v116[2] = v103;
        v116[3] = height;
      }
    }
    id v117 = [a1 right];
    [v117 size];
    double v119 = v118;
    double v121 = v35 * v120;
    v233.origin.CGFloat x = r1_24 - v35 * v120;
    double v122 = v233.origin.x;
    v233.origin.CGFloat y = v104;
    v233.size.CGFloat width = v121;
    v233.size.CGFloat height = v105;
    v259.origin.CGFloat y = y;
    v259.origin.CGFloat x = rect;
    v259.size.CGFloat height = r2_16;
    v259.size.CGFloat width = r2_24;
    CGRect v234 = CGRectIntersection(v233, v259);
    CGFloat v123 = v234.origin.y;
    CGFloat v124 = v234.size.height;
    v234.origin.CGFloat x = v122;
    v234.size.CGFloat width = v121;
    if (!CGRectIsEmpty(v234))
    {
      unsigned int v125 = [a1 tileCenterAndEdges];
      uint64_t v126 = (CGImage *)[v117 image];
      uint64_t v127 = v126;
      if (v125)
      {
        double v128 = v35 * v119;
        if (a5) {
          uint64_t v127 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v126 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v126);
        }
        v235.origin.CGFloat x = v122;
        v235.origin.CGFloat y = v123;
        v235.size.CGFloat width = v121;
        v235.size.CGFloat height = v124;
        CGFloat v129 = CGRectGetMaxY(v235);
        *((void *)v207 + v33) = v127;
        v130 = (double *)&v209[4 * v33];
        double *v130 = v122;
        v130[1] = v129 - v128;
        v130[2] = v121;
        v130[3] = v128;
        v131 = &v210 + 4 * v33;
        CGFloat *v131 = v122;
        v131[1] = v123;
        v131[2] = v121;
        v131[3] = v124;
        ++v33;
      }
      else
      {
        if (a5) {
          uint64_t v127 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v126 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v126);
        }
        v132 = &v210 + 4 * v33;
        CGFloat *v132 = v122;
        v132[1] = v123;
        v132[2] = v121;
        v132[3] = v124;
        *((void *)v207 + v33) = v127;
        v133 = (CGFloat *)&v209[4 * v33];
        CGFloat *v133 = v122;
        v133[1] = v123;
        ++v33;
        v133[2] = v121;
        v133[3] = v124;
      }
    }
    id v134 = [a1 center];
    CGFloat v135 = v181;
    if (!v134) {
      goto LABEL_76;
    }
    uint64_t v136 = v134;
    v236.size.CGFloat width = r1_16a;
    v236.size.CGFloat height = v180 - r1_8 - v178;
    v236.origin.CGFloat x = r1;
    v236.origin.CGFloat y = v104;
    v260.origin.CGFloat y = y;
    v260.origin.CGFloat x = rect;
    v260.size.CGFloat height = r2_16;
    v260.size.CGFloat width = r2_24;
    CGRect v237 = CGRectIntersection(v236, v260);
    CGFloat v137 = v237.origin.x;
    CGFloat v138 = v237.origin.y;
    CGFloat v139 = v237.size.width;
    CGFloat v140 = v237.size.height;
    if (!CGRectIsEmpty(v237))
    {
      unsigned int v142 = [a1 tileCenterAndEdges];
      v143 = (CGImage *)[v136 image];
      uint64_t v144 = v143;
      if (v142)
      {
        if (a5)
        {
          double v145 = r2;
          uint64_t v144 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v143 withScale:1 cache:r2];
        }
        else
        {
          CGImageRetain(v143);
          double v145 = r2;
        }
        [v136 size];
        double v147 = v146 * v145 / v172;
        double v149 = v148 * v145 / v172;
        v238.origin.CGFloat x = v137;
        v238.origin.CGFloat y = v138;
        v238.size.CGFloat width = v139;
        v238.size.CGFloat height = v140;
        CGFloat v150 = CGRectGetMaxY(v238);
        *((void *)v207 + v33) = v144;
        uint64_t v151 = (CGFloat *)&v209[4 * v33];
        *uint64_t v151 = v137;
        v151[1] = v150 - v149;
        v151[2] = v147;
        v151[3] = v149;
        v152 = &v210 + 4 * v33;
        CGFloat *v152 = v137;
        v152[1] = v138;
        v152[2] = v139;
        v152[3] = v140;
        CGFloat v135 = v181;
      }
      else
      {
        if (a5) {
          uint64_t v144 = (CGImage *)[a5 newFlattenedImageFromShapeCGImage:v143 withScale:1 cache:r2];
        }
        else {
          CGImageRetain(v143);
        }
        int v153 = &v210 + 4 * v33;
        *int v153 = v137;
        v153[1] = v138;
        v153[2] = v139;
        v153[3] = v140;
        int v154 = (CGFloat *)&v209[4 * v33];
        *int v154 = v137;
        v154[1] = v138;
        v154[2] = v139;
        v154[3] = v140;
        *((void *)v207 + v33) = v144;
      }
      ++v33;
      CGContextDrawImages();
      CGFloat v141 = r2_8;
    }
    else
    {
LABEL_76:
      CGContextDrawImages();
      CGFloat v141 = r2_8;
      if (!v33) {
        goto LABEL_90;
      }
    }
    unsigned int v155 = (CGImage **)v207;
    do
    {
      v156 = *v155++;
      CGImageRelease(v156);
      --v33;
    }
    while (v33);
LABEL_90:
    if (a4)
    {
      if (a4 == 1)
      {
        NSExceptionName v157 = NSGenericException;
LABEL_95:
        +[NSException raise:v157 format:@"Focus Ring drawing not supported"];
        goto LABEL_96;
      }
      if (a4 == 2)
      {
        v239.origin.CGFloat x = v89;
        v239.origin.CGFloat y = v141;
        v239.size.CGFloat width = v135;
        v239.size.CGFloat height = v180;
        CGRect r2_8a = CGRectInset(v239, 3.0, 3.0);
        CGRect v240 = CGRectInset(r2_8a, 1.0, 1.0);
        CGFloat v158 = v89;
        CGFloat v159 = v240.origin.x;
        CGFloat v160 = v240.origin.y;
        CGFloat recta = v240.origin.y;
        CGFloat v161 = v240.size.width;
        CGFloat v162 = v240.size.height;
        v240.origin.CGFloat x = v158;
        v240.origin.CGFloat y = v141;
        v240.size.CGFloat width = v135;
        v240.size.CGFloat height = v180;
        CGFloat MinX = CGRectGetMinX(v240);
        v241.origin.CGFloat x = v159;
        v241.origin.CGFloat y = v160;
        v241.size.CGFloat width = v161;
        v241.size.CGFloat height = v162;
        CGFloat v163 = CGRectGetMaxY(v241);
        v242.origin.CGFloat x = v158;
        v242.origin.CGFloat y = v141;
        v242.size.CGFloat width = v135;
        v242.size.CGFloat height = v180;
        rects.origin.CGFloat x = MinX;
        rects.origin.CGFloat y = v163;
        rects.size.CGFloat width = CGRectGetWidth(v242);
        rects.size.CGFloat height = 4.0;
        v243.origin.CGFloat x = v158;
        v243.origin.CGFloat y = v141;
        v243.size.CGFloat width = v135;
        v243.size.CGFloat height = v180;
        CGFloat v164 = CGRectGetMaxX(v243) + -4.0;
        CGFloat r2a = v159;
        v244.origin.CGFloat x = v159;
        v244.origin.CGFloat y = recta;
        v244.size.CGFloat width = v161;
        v244.size.CGFloat height = v162;
        CGFloat MinY = CGRectGetMinY(v244);
        v245.origin.CGFloat x = v158;
        v245.origin.CGFloat y = v141;
        v245.size.CGFloat width = v135;
        v245.size.CGFloat height = v180;
        CGFloat v195 = v164;
        CGFloat v196 = MinY;
        uint64_t v197 = 0x4010000000000000;
        CGFloat v198 = CGRectGetHeight(v245);
        v246.origin.CGFloat x = v158;
        v246.origin.CGFloat y = v141;
        v246.size.CGFloat width = v135;
        v246.size.CGFloat height = v180;
        CGFloat v166 = CGRectGetMinX(v246);
        v247.origin.CGFloat x = v158;
        v247.origin.CGFloat y = v141;
        v247.size.CGFloat width = v135;
        v247.size.CGFloat height = v180;
        CGFloat v167 = CGRectGetMinY(v247);
        v248.origin.CGFloat x = v158;
        v248.origin.CGFloat y = v141;
        v248.size.CGFloat width = v135;
        v248.size.CGFloat height = v180;
        CGFloat v199 = v166;
        CGFloat v200 = v167;
        CGFloat v201 = CGRectGetWidth(v248);
        uint64_t v202 = 0x4010000000000000;
        v249.origin.CGFloat x = v158;
        v249.origin.CGFloat y = v141;
        v249.size.CGFloat width = v135;
        v249.size.CGFloat height = v180;
        CGFloat v168 = CGRectGetMinX(v249);
        v250.origin.CGFloat x = r2a;
        v250.origin.CGFloat y = recta;
        v250.size.CGFloat width = v161;
        v250.size.CGFloat height = v162;
        CGFloat v169 = CGRectGetMinY(v250);
        v251.origin.CGFloat x = v158;
        v251.origin.CGFloat y = v141;
        v251.size.CGFloat width = v135;
        v251.size.CGFloat height = v180;
        CGFloat v203 = v168;
        CGFloat v204 = v169;
        uint64_t v205 = 0x4010000000000000;
        CGFloat v206 = CGRectGetHeight(v251);
        +[NSException raise:NSGenericException format:@"Focus Ring drawing not supported"];
        DeviceRGB = CGColorSpaceCreateDeviceRGB();
        *(_OWORD *)CGFloat components = xmmword_1A139EB08;
        long long v193 = unk_1A139EB18;
        v171 = CGColorCreate(DeviceRGB, components);
        CGContextSetFillColorWithColor(a2, v171);
        CGContextClipToRects(a2, &rects, 4uLL);
        CGContextFillRect(a2, r2_8a);
        CGColorSpaceRelease(DeviceRGB);
        CGColorRelease(v171);
        NSExceptionName v157 = NSGenericException;
        goto LABEL_95;
      }
    }
LABEL_96:
    CGContextRestoreGState(a2);
  }
}

void DrawNinePartMaskFromRenditionWithOperation(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, uint64_t a7, void *a8, CGContext *a9, int a10, uint64_t a11, CGBlendMode a12)
{
  uint64_t v33 = [_CUINineImagePieces alloc];
  id v19 = [a8 maskForSliceIndex:4];
  id v20 = [a8 maskForSliceIndex:0];
  id v21 = [a8 maskForSliceIndex:1];
  id v22 = [a8 maskForSliceIndex:2];
  id v23 = [a8 maskForSliceIndex:5];
  id v24 = [a8 maskForSliceIndex:8];
  id v25 = [a8 maskForSliceIndex:7];
  id v26 = [a8 maskForSliceIndex:6];
  id v27 = [a8 maskForSliceIndex:3];
  LOBYTE(v29) = [a8 isTiled];
  id v34 = [(_CUINineImagePieces *)v33 initWithCenter:v19 topLeft:v20 top:v21 topRight:v22 right:v23 bottomRight:v24 bottom:v25 bottomLeft:v26 left:v27 tileCenterAndEdges:v29];
  [a8 scale];
  DrawNinePartImageWithOperation(v34, a9, a12, a10, 0, a1, a2, a3, a4, v28, a5, a6);
}

void _CUITileImageWithOperation(void *a1, CGContext *a2, CGBlendMode a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, double a8, double a9)
{
  if (a1 && !NSIsEmptyRect(*(NSRect *)&a4))
  {
    CGContextSaveGState(a2);
    if (a3) {
      CGContextSetBlendMode(a2, a3);
    }
    CGContextSetAlpha(a2, fabs(a9));
    [a1 size];
    v17.origin.CGFloat x = a4;
    v17.origin.CGFloat y = a5;
    v17.size.CGFloat width = a6;
    v17.size.CGFloat height = a7;
    CGRectGetMaxY(v17);
    [a1 image];
    CGContextDrawImages();
    CGContextRestoreGState(a2);
  }
}

void sub_1A13577CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1A13578C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

id __RunTimeThemeRefForBytes_block_invoke(void *a1, void *a2)
{
  id v4 = [a2 objectForKey:a1[4]];
  if (v4)
  {
    id result = [v4 unsignedIntegerValue];
    *(void *)(*(void *)(a1[5] + 8) + 24) = result;
  }
  else
  {
    int64x2_t v6 = [[CUIStructuredThemeStore alloc] initWithBytes:a1[7] length:a1[8]];
    if (v6)
    {
      int64x2_t v7 = v6;
      *(void *)(*(void *)(a1[5] + 8) + 24) = _RegisterThemeProvider(v6);

      int64x2_t v8 = +[NSNumber numberWithUnsignedInteger:*(void *)(*(void *)(a1[5] + 8) + 24)];
      uint64_t v9 = a1[4];
      return [a2 setObject:v8 forKey:v9];
    }
    else
    {
      id result = [objc_alloc((Class)NSString) initWithFormat:@"RunTimeThemeRefForBytes() failed to initialize CUIStructuredThemeStore"];
      *(void *)(*(void *)(a1[6] + 8) + 40) = result;
    }
  }
  return result;
}

id __FacetCache_block_invoke()
{
  id result = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:20];
  FacetCache_facetCache = (uint64_t)result;
  return result;
}

id __RecentlyUsedFacetCacheKeys_block_invoke()
{
  id result = [objc_alloc((Class)NSMutableArray) initWithCapacity:20];
  RecentlyUsedFacetCacheKeys_facetCacheKeys = (uint64_t)result;
  return result;
}

void FrameIntersectionWithAxis(double *a1, double *a2, double a3, double a4, double a5, double a6, long double a7)
{
  double v13 = remainder(a7, 360.0);
  if (v13 <= 90.0)
  {
    if (v13 >= -90.0)
    {
      double v15 = a6 * 0.5;
      double v16 = a4 + a6 * 0.5;
      if (v13 == 0.0)
      {
        double v17 = a3 + a5;
        a4 = a4 + a6 * 0.5;
        goto LABEL_13;
      }
      char v19 = 0;
      double v18 = a5 * 0.5;
      double v17 = a3 + a5 * 0.5;
LABEL_11:
      if (fabs(v13) == 90.0)
      {
        double v16 = a4 + a6;
        a3 = v17;
        if (v13 < 0.0) {
          goto LABEL_14;
        }
      }
      else
      {
        double v22 = tan(v13 * 3.14159265 / 180.0);
        double v23 = v18 * v22;
        if (fabs(v18 * v22) <= v15)
        {
          a4 = v16 - v23;
          double v17 = a3 + a5;
          double v16 = v16 + v23;
        }
        else
        {
          a3 = v17 - v15 / v22;
          double v17 = v17 + v15 / v22;
          double v16 = a4 + a6;
          if (v22 < 0.0)
          {
            if ((v19 & 1) == 0) {
              goto LABEL_14;
            }
            goto LABEL_13;
          }
        }
        if (v19) {
          goto LABEL_14;
        }
      }
LABEL_13:
      double v20 = v17;
      double v21 = v16;
      double v17 = a3;
      double v16 = a4;
      a3 = v20;
      a4 = v21;
      goto LABEL_14;
    }
    double v14 = 180.0;
  }
  else
  {
    double v14 = -180.0;
  }
  double v13 = v13 + v14;
  double v15 = a6 * 0.5;
  double v16 = a4 + a6 * 0.5;
  if (v13 != 0.0)
  {
    double v18 = a5 * 0.5;
    double v17 = a3 + a5 * 0.5;
    char v19 = 1;
    goto LABEL_11;
  }
  double v17 = a3 + a5;
  a4 = a4 + a6 * 0.5;
LABEL_14:
  *a1 = v17;
  a1[1] = v16;
  *a2 = a3;
  a2[1] = a4;
}

id LinearGradientShaderFunction(void *a1, double *a2, void *a3)
{
  id result = [a1 _smoothedGradientColorAtLocation:*a2];
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

void GradientEvaluatorRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

Class initMDLVertexAttribute()
{
  __NSGetFrameworkReference_0();
  Class result = objc_getClass("MDLVertexAttribute");
  classMDLVertexAttribute = (uint64_t)result;
  if (!result) {
    initMDLVertexAttribute_cold_1();
  }
  getMDLVertexAttributeClass = MDLVertexAttributeFunction;
  return result;
}

void __NSGetFrameworkReference_0()
{
  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
  id v0 = [(id)__NSGetFrameworkReference_table_1 objectForKey:@"ModelIO"];
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
  if (!v0)
  {
    id v1 = __NSLoadFramework(@"ModelIO");
    if (v1)
    {
      uint64_t v2 = v1;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
      id v3 = (id)__NSGetFrameworkReference_table_1;
      if (!__NSGetFrameworkReference_table_1)
      {
        id v3 = [objc_alloc((Class)NSMapTable) initWithKeyOptions:0 valueOptions:2 capacity:0];
        __NSGetFrameworkReference_table_1 = (uint64_t)v3;
      }
      if (![v3 objectForKey:@"ModelIO"]) {
        [(id)__NSGetFrameworkReference_table_1 setObject:v2 forKey:@"ModelIO"];
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_1);
    }
  }
}

uint64_t MDLVertexAttributeFunction()
{
  return classMDLVertexAttribute;
}

Class initMDLVertexBufferLayout()
{
  __NSGetFrameworkReference_0();
  Class result = objc_getClass("MDLVertexBufferLayout");
  classMDLVertexBufferLayout = (uint64_t)result;
  if (!result) {
    initMDLVertexBufferLayout_cold_1();
  }
  getMDLVertexBufferLayoutClass = MDLVertexBufferLayoutFunction;
  return result;
}

uint64_t MDLVertexBufferLayoutFunction()
{
  return classMDLVertexBufferLayout;
}

Class initMDLVertexDescriptor()
{
  __NSGetFrameworkReference_0();
  Class result = objc_getClass("MDLVertexDescriptor");
  classMDLVertexDescriptor = (uint64_t)result;
  if (!result) {
    initMDLVertexDescriptor_cold_1();
  }
  getMDLVertexDescriptorClass = MDLVertexDescriptorFunction;
  return result;
}

uint64_t MDLVertexDescriptorFunction()
{
  return classMDLVertexDescriptor;
}

Class initMDLMesh()
{
  __NSGetFrameworkReference_0();
  Class result = objc_getClass("MDLMesh");
  classMDLMesh = (uint64_t)result;
  if (!result) {
    initMDLMesh_cold_1();
  }
  getMDLMeshClass = MDLMeshFunction;
  return result;
}

uint64_t MDLMeshFunction()
{
  return classMDLMesh;
}

uint64_t CUIThemeInfoVersion()
{
  return 1;
}

BOOL __copyBlock(uint64_t a1, uint64_t a2, const char *a3)
{
  unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, a3);
  if (!NamedBlock) {
    return 1;
  }
  unsigned int v7 = NamedBlock;
  uint64_t v8 = BOMStorageNewNamedBlock(a2, a3);
  size_t v15 = BOMStorageSizeOfBlock(a1, v7, v9, v10, v11, v12, v13, v14);
  double v16 = malloc_type_malloc(v15, 0xD26F2467uLL);
  if (BOMStorageCopyFromBlock(a1, v7, v16, v17, v18, v19, v20, v21))
  {
    free(v16);
    return 0;
  }
  int v27 = BOMStorageCopyToBlock(a2, v8, v16, v15, v22, v23, v24, v25);
  free(v16);
  if (v27) {
    return 0;
  }
  return BOMStorageCommit(a2) == 0;
}

uint64_t __copyTree(uint64_t a1, uint64_t a2, const char *a3, int a4)
{
  uint64_t v7 = BOMTreeOpenWithName(a1, a3, 0);
  if (!v7) {
    return 1;
  }
  uint64_t v8 = v7;
  if (BOMTreePageSize(v7) <= 0x400) {
    a4 = BOMTreePageSize(v8);
  }
  char v9 = BOMTreeUsesNumericKeys(v8);
  uint64_t v10 = BOMTreeNewWithOptions(a2, 0, a3, a4, v9);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = (uint64_t)v10;
  uint64_t v12 = BOMTreeIteratorNew(v8, 0, 0, 0);
  if (!v12) {
    return 0;
  }
  for (uint64_t i = v12;
        !BOMTreeIteratorIsAtEnd((uint64_t)i, v13, v14, v15, v16, v17, v18, v19);
        BOMTreeIteratorNext((uint64_t)i, v56, v57, v58, v59, v60, v61, v62))
  {
    double v28 = (void *)BOMTreeIteratorKey((uint64_t)i, v21, v22, v23, v24, v25, v26, v27);
    unint64_t v36 = BOMTreeIteratorKeySize((uint64_t)i, v29, v30, v31, v32, v33, v34, v35);
    double v44 = (const void *)BOMTreeIteratorValue((uint64_t)i, v37, v38, v39, v40, v41, v42, v43);
    size_t v52 = BOMTreeIteratorValueSize((uint64_t)i, v45, v46, v47, v48, v49, v50, v51);
    BOMTreeSetValue(v11, v28, v36, v44, v52, v53, v54, v55);
  }
  BOOL v63 = BOMStorageCommit(a2) == 0;
  BOMTreeIteratorFree(i);
  BOMTreeFree(v11);
  return v63;
}

Class initMDLAsset()
{
  os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
  id v0 = [(id)__NSGetFrameworkReference_table_2 objectForKey:@"ModelIO"];
  os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
  if (!v0)
  {
    id v1 = __NSLoadFramework(@"ModelIO");
    if (v1)
    {
      uint64_t v2 = v1;
      os_unfair_lock_lock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
      id v3 = (id)__NSGetFrameworkReference_table_2;
      if (!__NSGetFrameworkReference_table_2)
      {
        id v3 = [objc_alloc((Class)NSMapTable) initWithKeyOptions:0 valueOptions:2 capacity:0];
        __NSGetFrameworkReference_table_2 = (uint64_t)v3;
      }
      if (![v3 objectForKey:@"ModelIO"]) {
        [(id)__NSGetFrameworkReference_table_2 setObject:v2 forKey:@"ModelIO"];
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__NSGetFrameworkReference_frameworkCacheLock_2);
    }
  }
  Class result = objc_getClass("MDLAsset");
  classMDLAsset = (uint64_t)result;
  if (!result) {
    initMDLAsset_cold_1();
  }
  getMDLAssetClass = MDLAssetFunction;
  return result;
}

uint64_t MDLAssetFunction()
{
  return classMDLAsset;
}

vImage_Error CUIConvertCGImageFormat(CGImage *a1, CGColorSpace *a2, const vImage_CGImageFormat *a3, vImage_Buffer *a4)
{
  memset(&srcs, 0, sizeof(srcs));
  srcFormat.bitsPerComponent = CGImageGetBitsPerComponent(a1);
  srcFormat.bitsPerPixel = CGImageGetBitsPerPixel(a1);
  srcFormat.colorSpace = a2;
  srcFormat.bitmapInfo = CGImageGetBitmapInfo(a1);
  memset(&srcFormat.version, 0, 20);
  vImage_Error v8 = MEMORY[0x1A6231AB0](&srcs, &srcFormat, 0, a1, 256);
  vImage_Error error = v8;
  if (v8)
  {
    _CUILog(4, (uint64_t)"CoreUI: CUIConvertCGImageFormat() [vImageBuffer_InitWithCGImage] failed error:'%d'", v9, v10, v11, v12, v13, v14, v8);
  }
  else
  {
    vImageConverterRef v15 = vImageConverter_CreateWithCGImageFormat(&srcFormat, a3, 0, 0x100u, &error);
    if (error)
    {
      _CUILog(4, (uint64_t)"CoreUI: CUIConvertCGImageFormat() [vImageConverter_CreateWithCGImageFormat] failed error:'%d'", v16, v17, v18, v19, v20, v21, error);
    }
    else
    {
      uint64_t v23 = v15;
      if (!a4->rowBytes) {
        a4->rowBytes = CGBitmapGetAlignedBytesPerRow();
      }
      if (!a4->data) {
        a4->data = (void *)CGBitmapAllocateData();
      }
      vImage_Error error = vImageConvert_AnyToAny(v23, &srcs, a4, 0, 0x100u);
      free(srcs.data);
      if (error) {
        _CUILog(4, (uint64_t)"CoreUI: CUIConvertCGImageFormat() [vImageConvert_AnyToAny] failed error:'%d'", v24, v25, v26, v27, v28, v29, error);
      }
      vImageConverter_Release(v23);
    }
  }
  return error;
}

uint64_t CUICGImageGetAlphaInfo(CGImage *a1)
{
  uint64_t AlphaInfo = CGImageGetAlphaInfo(a1);
  uint64_t v3 = AlphaInfo;
  if AlphaInfo < 8 && ((0xE1u >> AlphaInfo)) {
    return dword_1A139EC10[(int)AlphaInfo];
  }
  memset(&src, 0, sizeof(src));
  int v15 = 0;
  v11[0] = 0x2000000008;
  v11[1] = _CUIColorSpaceGetSRGB();
  int v12 = 8194;
  uint64_t v14 = 0;
  uint64_t v13 = 0;
  if (!MEMORY[0x1A6231AB0](&src, v11, 0, a1, 256))
  {
    dest.CGFloat height = src.height;
    dest.vImagePixelCount width = src.width;
    dest.rowBytes = src.width;
    dest.data = malloc_type_malloc(src.width * src.height, 0xB4F88C1BuLL);
    if (vImageExtractChannel_ARGB8888(&src, &dest, 3, 0))
    {
LABEL_5:
      free(src.data);
      free(dest.data);
      return v3;
    }
    if (dest.height)
    {
      uint64_t v5 = 0;
      data = (unsigned __int8 *)dest.data;
      while (1)
      {
        uint64_t v7 = data;
        vImagePixelCount width = dest.width;
        if (dest.width) {
          break;
        }
LABEL_13:
        ++v5;
        data += dest.rowBytes;
        if (v5 == dest.height) {
          goto LABEL_14;
        }
      }
      while (1)
      {
        int v9 = *v7++;
        if (v9 != 255) {
          goto LABEL_5;
        }
        if (!--width) {
          goto LABEL_13;
        }
      }
    }
LABEL_14:
    free(src.data);
    free(dest.data);
    if ((v3 - 1) < 4) {
      return dword_1A139EC30[(int)v3 - 1];
    }
  }
  return v3;
}

uint64_t CUIImageIsMonochrome(CGImage *a1)
{
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  if (CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelMonochrome) {
    return 1;
  }
  memset(&srcARGB, 0, sizeof(srcARGB));
  int v22 = 0;
  memset(&destB, 0, sizeof(destB));
  v18[0] = 0x2000000008;
  v18[1] = _CUIColorSpaceGetSRGB();
  int v19 = 8194;
  uint64_t v21 = 0;
  uint64_t v20 = 0;
  if (!MEMORY[0x1A6231AB0](&srcARGB, v18, 0, a1, 256))
  {
    v14.vImagePixelCount height = srcARGB.height;
    v14.vImagePixelCount width = srcARGB.width;
    destR.vImagePixelCount height = srcARGB.height;
    destR.vImagePixelCount width = srcARGB.width;
    destA.vImagePixelCount height = srcARGB.height;
    destA.vImagePixelCount width = srcARGB.width;
    destB.vImagePixelCount height = srcARGB.height;
    destB.vImagePixelCount width = srcARGB.width;
    v14.size_t rowBytes = srcARGB.width;
    destR.size_t rowBytes = srcARGB.width;
    destA.size_t rowBytes = srcARGB.width;
    destB.size_t rowBytes = srcARGB.width;
    destB.data = malloc_type_malloc(srcARGB.width * srcARGB.height, 0xB5B2A470uLL);
    destA.data = malloc_type_malloc(srcARGB.width * srcARGB.height, 0x6EC18429uLL);
    destR.data = malloc_type_malloc(srcARGB.width * srcARGB.height, 0xE02BC0E1uLL);
    v14.data = malloc_type_malloc(srcARGB.width * srcARGB.height, 0x2779B308uLL);
    if (!vImageConvert_ARGB8888toPlanar8(&srcARGB, &destA, &destR, &v14, &destB, 0))
    {
      vImagePixelCount height = destA.height;
      if (!destA.height)
      {
LABEL_12:
        free(srcARGB.data);
        free(destA.data);
        uint64_t v3 = 1;
        goto LABEL_13;
      }
      vImagePixelCount width = destA.width;
      size_t rowBytes = destA.rowBytes;
      size_t v8 = v14.rowBytes;
      data = (char *)destR.data;
      size_t v10 = destR.rowBytes;
      int v9 = (char *)destA.data;
      uint64_t v11 = (char *)v14.data;
      vImagePixelCount v12 = v14.width;
      while (!memcmp(v9, data, width) && !memcmp(v11, data, v12))
      {
        v11 += v8;
        data += v10;
        v9 += rowBytes;
        if (!--height) {
          goto LABEL_12;
        }
      }
    }
    free(srcARGB.data);
    free(destA.data);
    uint64_t v3 = 0;
LABEL_13:
    free(destR.data);
    free(v14.data);
    free(destB.data);
    return v3;
  }
  return 0;
}

CGFloat CUICalcNonAlphaAreaOfImage(CGImage *a1)
{
  memset(&src, 0, sizeof(src));
  double x = CGRectZero.origin.x;
  CGFloat y = CGRectZero.origin.y;
  size_t Width = CGImageGetWidth(a1);
  double v5 = (double)Width;
  size_t Height = CGImageGetHeight(a1);
  uint64_t v7 = (char *)malloc_type_malloc((unint64_t)((double)Width * (double)Height), 0x8BE3499DuLL);
  v32[0] = 0x2000000008;
  v32[1] = _CUIColorSpaceGetSRGB();
  int v33 = 8195;
  memset(v35, 0, sizeof(v35));
  uint64_t v34 = 0;
  if (MEMORY[0x1A6231AB0](&src, v32, 0, a1, 256)
    || (dest.vImagePixelCount width = src.width,
        dest.size_t rowBytes = src.width,
        dest.data = v7,
        dest.vImagePixelCount height = src.height,
        vImage_Error v8 = vImageExtractChannel_ARGB8888(&src, &dest, 0, 0),
        free(src.data),
        v8))
  {
    free(v7);
  }
  else
  {
    double v10 = (double)Height;
    double v11 = y;
    if (Height)
    {
      uint64_t v12 = 0;
      uint64_t v13 = v7;
      double v11 = y;
      double v10 = (double)Height;
      while (!Width)
      {
LABEL_11:
        double v11 = v11 + 1.0;
        double v10 = v10 + -1.0;
        ++v12;
        v13 += (unint64_t)v5;
        if ((double)(int)v12 >= (double)Height) {
          goto LABEL_12;
        }
      }
      uint64_t v14 = 0;
      while (!v13[v14])
      {
        if ((double)(int)++v14 >= v5) {
          goto LABEL_11;
        }
      }
    }
LABEL_12:
    LODWORD(v15) = (int)(v10 + v11 + -1.0);
    if (v11 <= (double)(int)v15)
    {
      uint64_t v15 = (int)v15;
      uint64_t v25 = &v7[(unint64_t)v5 * (int)v15];
      while (!Width)
      {
LABEL_28:
        double v10 = v10 + -1.0;
        --v15;
        v25 -= (unint64_t)v5;
        if (v11 > (double)(int)v15) {
          goto LABEL_13;
        }
      }
      uint64_t v26 = 0;
      while (!v25[v26])
      {
        if ((double)(int)++v26 >= v5) {
          goto LABEL_28;
        }
      }
    }
LABEL_13:
    double v16 = (double)Width;
    double v17 = CGRectZero.origin.x;
    if (Width)
    {
      uint64_t v18 = 0;
      double v19 = v11 + v10;
      uint64_t v20 = &v7[(unint64_t)v5 * (int)v11];
      double v17 = CGRectZero.origin.x;
      double v16 = (double)Width;
      while (1)
      {
        int v21 = (int)v11 + 1;
        int v22 = v20;
        if (v19 > (double)(int)v11) {
          break;
        }
LABEL_18:
        double v17 = v17 + 1.0;
        double v16 = v16 + -1.0;
        ++v18;
        ++v20;
        if ((double)(int)v18 >= v5) {
          goto LABEL_19;
        }
      }
      while (!*v22)
      {
        v22 += (unint64_t)v5;
        double v23 = (double)v21++;
        if (v19 <= v23) {
          goto LABEL_18;
        }
      }
    }
LABEL_19:
    LODWORD(v24) = (int)(v16 + v17 + -1.0);
    if (v17 <= (double)(int)v24)
    {
      double v27 = v11 + v10;
      uint64_t v24 = (int)v24;
      while (1)
      {
        int v28 = (int)v11 + 1;
        uint64_t v29 = &v7[(unint64_t)v5 * (int)v11];
        if (v27 > (double)(int)v11) {
          break;
        }
LABEL_34:
        double v16 = v16 + -1.0;
        if (v17 > (double)(int)--v24) {
          goto LABEL_20;
        }
      }
      while (!v29[v24])
      {
        v29 += (unint64_t)v5;
        double v30 = (double)v28++;
        if (v27 <= v30) {
          goto LABEL_34;
        }
      }
    }
LABEL_20:
    free(v7);
    v38.origin.double x = CGRectZero.origin.x;
    v38.origin.CGFloat y = y;
    v38.size.vImagePixelCount width = (double)Width;
    v38.size.vImagePixelCount height = (double)Height;
    v37.double x = v17;
    v37.CGFloat y = v11;
    if (CGRectContainsPoint(v38, v37)) {
      return v17;
    }
    else {
      return CGPointZero.x;
    }
  }
  return x;
}

uint64_t CUICalculateExtrusionMaskOfImage()
{
  return 29;
}

void CUIDrawExtrudedImageInContext(CGContext *a1, int a2, CGImageRef image, CGFloat a4, CGFloat a5, double a6, double a7)
{
  double Width = (double)CGImageGetWidth(image);
  double Height = (double)CGImageGetHeight(image);
  double v19 = a5 + a7;
  if ((a2 & 0x10) != 0) {
    __drawTextureInContext(a1, image, 0.0, 0.0, Width, 1.0, a4, v19);
  }
  double v18 = Height + -1.0;
  if ((a2 & 8) != 0) {
    __drawTextureInContext(a1, image, 0.0, v18, Width, 1.0, a4, a5 + -1.0);
  }
  if (a2) {
    __drawTextureInContext(a1, image, 0.0, 0.0, 1.0, Height, a4 + -1.0, a5);
  }
  double v16 = Width + -1.0;
  double v17 = a4 + a6;
  if ((a2 & 4) != 0) {
    __drawTextureInContext(a1, image, v16, 0.0, 1.0, Height, v17, a5);
  }
  if ((~a2 & 0x11) == 0) {
    __drawTextureInContext(a1, image, 0.0, 0.0, 1.0, 1.0, a4 + -1.0, v19);
  }
  if ((~a2 & 9) == 0) {
    __drawTextureInContext(a1, image, 0.0, v18, 1.0, 1.0, a4 + -1.0, a5 + -1.0);
  }
  if ((~a2 & 0x14) == 0) {
    __drawTextureInContext(a1, image, v16, 0.0, 1.0, 1.0, v17, v19);
  }
  if ((~a2 & 0xC) == 0)
  {
    __drawTextureInContext(a1, image, v16, v18, 1.0, 1.0, v17, a5 + -1.0);
  }
}

void __drawTextureInContext(CGContext *a1, CGImageRef image, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  if (image)
  {
    uint64_t v13 = CGImageCreateWithImageInRect(image, *(CGRect *)&a3);
    v15.origin.double x = a7;
    v15.origin.CGFloat y = a8;
    v15.size.vImagePixelCount width = a5;
    v15.size.vImagePixelCount height = a6;
    CGContextDrawImage(a1, v15, v13);
    CGImageRelease(v13);
  }
}

CGImage *CUIConvertDeepImageTo8(CGImage *a1, CGColorSpace *a2)
{
  dest.data = 0;
  vImage_Error v21 = 0;
  dest.size_t rowBytes = 0;
  vImagePixelCount Height = CGImageGetHeight(a1);
  dest.vImagePixelCount height = Height;
  vImagePixelCount Width = CGImageGetWidth(a1);
  dest.vImagePixelCount width = Width;
  LODWORD(v22) = 8;
  unsigned int v6 = 8 * CGImageGetBitsPerPixel(a1);
  DWORD1(v22) = v6 / CGImageGetBitsPerComponent(a1);
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(a1);
  *(_DWORD *)double v23 = AlphaInfo & 0xFFFFF0FF;
  *((void *)&v22 + 1) = a2;
  memset(&v23[4], 0, 20);
  memset(&srcs, 0, sizeof(srcs));
  memset(&dests, 0, sizeof(dests));
  *((_DWORD *)&srcFormat.renderingIntent + 1) = 0;
  uint32_t BitsPerComponent = CGImageGetBitsPerComponent(a1);
  srcFormat.bitsPerComponent = BitsPerComponent;
  uint32_t BitsPerPixel = CGImageGetBitsPerPixel(a1);
  srcFormat.bitsPerPixel = BitsPerPixel;
  srcFormat.colorSpace = CGImageGetColorSpace(a1);
  srcFormat.bitmapInfo = CGImageGetBitmapInfo(a1);
  srcFormat.version = 0;
  srcFormat.decode = CGImageGetDecode(a1);
  srcFormat.renderingIntent = CGImageGetRenderingIntent(a1);
  if (MEMORY[0x1A6231AB0](&srcs, &srcFormat, 0, a1, 0)) {
    return 0;
  }
  int v10 = BitsPerPixel / BitsPerComponent;
  *(_OWORD *)&destFormat.bitsPerComponent = v22;
  *(_OWORD *)&destFormat.bitmapInfo = *(_OWORD *)v23;
  BOOL v11 = (int)(BitsPerPixel / BitsPerComponent) > 4 || v10 == 2;
  if (v11) {
    int v12 = 8448;
  }
  else {
    int v12 = 4096;
  }
  if (v11) {
    uint32_t v13 = 32;
  }
  else {
    uint32_t v13 = 16;
  }
  destFormat.bitmapInfo = AlphaInfo & 0xFFFF80FF | v12;
  destFormat.decode = srcFormat.decode;
  *(void *)&destFormat.renderingIntent = *(void *)&v23[16];
  if (v11) {
    char v14 = 5;
  }
  else {
    char v14 = 4;
  }
  destFormat.bitsPerComponent = v13;
  destFormat.bitsPerPixel = v10 << v14;
  vImage_Error error = MEMORY[0x1A6231AA0](&dests, Height, Width);
  if (error)
  {
    free(srcs.data);
    return 0;
  }
  CGRect v15 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
  if (error) {
    goto LABEL_19;
  }
  double v16 = v15;
  vImage_Error error = vImageConvert_AnyToAny(v15, &srcs, &dests, 0, 0);
  if (error)
  {
    vImageConverter_Release(v16);
LABEL_19:
    free(srcs.data);
    free(dests.data);
    goto LABEL_20;
  }
  dest.size_t rowBytes = CGBitmapGetAlignedBytesPerRow();
  dest.data = (void *)CGBitmapAllocateData();
  switch(v10)
  {
    case 1:
      vImage_Error v20 = vImageConvert_Planar16UtoPlanar8_dithered(&dests, &dest, 268435458, 0);
      break;
    case 3:
      vImage_Error v20 = vImageConvert_RGB16UtoRGB888_dithered(&dests, &dest, 268435458, 0);
      break;
    case 4:
      vImage_Error v20 = vImageConvert_ARGB16UtoARGB8888_dithered(&dests, &dest, 268435458, 0, 0);
      break;
    default:
      vImage_Error error = -21778;
      goto LABEL_33;
  }
  vImage_Error error = v20;
LABEL_33:
  free(srcs.data);
  if (dests.data) {
    free(dests.data);
  }
  if (v16) {
    vImageConverter_Release(v16);
  }
LABEL_20:
  vImage_Error v21 = error;
  if (error) {
    return 0;
  }
  double v17 = (CGImage *)MEMORY[0x1A6231B60](&dest, &v22, 0, 0, 256, &v21);
  if (CGImageGetColorSpace(v17) != a2)
  {
    CGImageRef CopyWithColorSpace = CGImageCreateCopyWithColorSpace(v17, a2);
    CGImageRelease(v17);
    return CopyWithColorSpace;
  }
  return v17;
}

BOOL CUIImageIsWideGamut(CGImage *a1)
{
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  if (!CGColorSpaceIsWideGamutRGB(ColorSpace)) {
    return 0;
  }
  if (__CUIImageIsInsideSRGB___onceToken != -1) {
    dispatch_once(&__CUIImageIsInsideSRGB___onceToken, &__block_literal_global_9);
  }
  return !__CUIImageIsInsideSRGB___imageIsInsideSRGB || !__CUIImageIsInsideSRGB___imageIsInsideSRGB(a1);
}

vImage_Error CUIGetRGBAImageBuffer(CGImage *a1, uint64_t a2, vImage_Buffer *a3)
{
  if (CGImageGetBitsPerComponent(a1) < 9)
  {
    uint64_t SRGB = _CUIColorSpaceGetSRGB();
    *(void *)a2 = 0x2000000008;
    *(void *)(a2 + 8) = SRGB;
    *(_DWORD *)(a2 + 16) = 2;
    *(void *)(a2 + 28) = 0;
    *(void *)(a2 + 20) = 0;
    JUMPOUT(0x1A6231AB0);
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  uint64_t ExtendedRangeSRGB = _CUIColorSpaceGetExtendedRangeSRGB();
  *(void *)a2 = 0x8000000020;
  *(void *)(a2 + 8) = ExtendedRangeSRGB;
  *(_DWORD *)(a2 + 16) = 8452;
  *(void *)(a2 + 28) = 0;
  *(void *)(a2 + 20) = 0;
  long long v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v11.bitsPerComponent = *(_OWORD *)a2;
  *(_OWORD *)&v11.bitmapInfo = v8;
  *(void *)&v11.renderingIntent = *(void *)(a2 + 32);
  return CUIConvertCGImageFormat(a1, ColorSpace, &v11, a3);
}

void CUIDeallocateRGBAImageBuffer(uint64_t a1, void **a2)
{
  if (*a2)
  {
    if (*(_DWORD *)a1 == 8) {
      free(*a2);
    }
    else {
      CGBitmapFreeData();
    }
    *a2 = 0;
  }
  id v4 = *(const void **)(a1 + 8);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t CUISDFTexturesSupported()
{
  return 0;
}

uint64_t CUICreateSDFEdgeTextureFromImage()
{
  return 0;
}

uint64_t CUICreateSDFGradientTextureFromImage()
{
  return 0;
}

uint64_t CUICreateSDFEdgeTexturePixelFormat()
{
  return 55;
}

uint64_t CUICreateSDFGradientTexturePixelFormat()
{
  return 32;
}

BOOL CUIEqualRenditionKeys(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3)
{
  return CUICompareRenditionKey(a1, a2, a3) == 0;
}

id CUIPlaceHolderRendition(uint64_t a1, uint64_t a2)
{
  id result = (id)CUIPlaceHolderRendition_placeHolderRendition;
  if (!CUIPlaceHolderRendition_placeHolderRendition)
  {
    int v4 = 0;
    uint64_t v3 = 3538945;
    id result = objc_msgSend((id)_LookupStructuredThemeProvider(0, a2), "renditionWithKey:", &v3);
    CUIPlaceHolderRendition_placeHolderRendition = (uint64_t)result;
  }
  return result;
}

void sub_1A136A244(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *__csiBlockDataProviderGetBytePointer(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 48);
  uint64_t v3 = (unsigned __int16 *)[objc_loadWeak((id *)(a1 + 48)) key];
  CUIRenditionKeyValueForAttribute(v3, 17);
  CUIRenditionKeyValueForAttribute(v3, 1);
  CUIRenditionKeyValueForAttribute(v3, 2);
  kdebug_trace();
  int v4 = (unsigned int *)[*(id *)(a1 + 24) bytes];
  double v5 = v4;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = v4[3];
  uint64_t v8 = v4[4];
  unsigned int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 8) - 2;
  BOOL v11 = (v9 >= 0xA || ((0x3CFu >> v9) & 1) == 0) && (v7 != v6 || v8 != HIDWORD(v6));
  uint64_t v12 = *(void *)(a1 + 8);
  int v13 = v4[6];
  if (v13 <= 1195456543)
  {
    if (v13 == 1095911234)
    {
      int v14 = 1;
      uint64_t v15 = 1;
      if (!v11) {
        goto LABEL_25;
      }
      goto LABEL_37;
    }
    if (v13 == 1195454774)
    {
      int v14 = 0;
      uint64_t v15 = 5;
      if (v11) {
        goto LABEL_37;
      }
      goto LABEL_25;
    }
LABEL_36:
    uint64_t v42 = +[NSAssertionHandler currentHandler];
    uint64_t v41 = +[NSString stringWithUTF8String:"const void * _Nullable __CUIBlockDataProviderGetBytePointer(void * _Nullable)"];
    [objc_loadWeak(v2) name];
    uint64_t v40 = "const void * _Nullable __CUIBlockDataProviderGetBytePointer(void * _Nullable)";
    [(NSAssertionHandler *)v42 handleFailureInFunction:v41 file:@"CUIThemeRendition.m" lineNumber:1707 description:@"CoreUI: %s unknown pixel format %d rendition '%@'"];
    int v14 = 0;
    uint64_t v15 = 0xFFFFFFFFLL;
    if (!v11) {
      goto LABEL_25;
    }
LABEL_37:
    uint64_t v34 = (char *)-[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v6, SHIDWORD(v6), *(void *)(a1 + 112), v15);
    uint64_t v35 = (uint64_t)v34;
    if (v34)
    {
      strlcpy(v34 + 48, (const char *)v5 + 40, 0x80uLL);
      *(_DWORD *)(v35 + 8) = v5[6];
      -[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:](v35, *(const UInt8 **)(a1 + 32), v12, v6, 1, v36, v37, v38);
      double v23 = *(void **)(v35 + 16);
    }
    else
    {
      double v23 = 0;
    }
    *(void *)(a1 + 80) = v35;
    goto LABEL_40;
  }
  if (v13 == 1195456544)
  {
    uint64_t v15 = 2;
    int v14 = 1;
    if (v11) {
      goto LABEL_37;
    }
    goto LABEL_25;
  }
  if (v13 == 1380401717)
  {
    int v14 = 0;
    uint64_t v15 = 6;
    if (v11) {
      goto LABEL_37;
    }
    goto LABEL_25;
  }
  if (v13 != 1380401751) {
    goto LABEL_36;
  }
  int v14 = 0;
  uint64_t v15 = 4;
  if (v11) {
    goto LABEL_37;
  }
LABEL_25:
  if (_CSIAcquireCachedBlockData(a1, v15))
  {
    if (v14 && (Weak = objc_loadWeak((id *)(a1 + 8 * v15 + 56))) != 0)
    {
      double v23 = (void *)(Weak[2]
                   + 4 * (v5[6] == 1095911234) * *(_DWORD *)(a1 + 8)
                   + Weak[4] * *(unsigned int *)(a1 + 12));
    }
    else
    {
      _CUILog(4, (uint64_t)"CoreUI: image data is not available, returning a 1,1 image instead that is all black", v16, v17, v18, v19, v20, v21, (uint64_t)v40);
      double v23 = &__CUIBlockDataProviderGetBytePointer___imageData;
    }
  }
  else
  {
    uint64_t v24 = v7 | (v8 << 32);
    int v25 = __bppFromBlockPixelFormat(v15);
    uint64_t v26 = -[_CSIRenditionBlockData initWithPixelWidth:pixelHeight:sourceRowbytes:pixelFormat:]([_CSIRenditionBlockData alloc], v7, v8, *(void *)(a1 + 112), v15);
    double v30 = v26;
    if (v26)
    {
      strlcpy((char *)v26 + 48, (const char *)v5 + 40, 0x80uLL);
      v30[2] = v5[6];
    }
    -[_CSIRenditionBlockData expandCSIBitmapData:fromSlice:makeReadOnly:]((uint64_t)v30, *(const UInt8 **)(a1 + 32), 0, v24, 1, v27, v28, v29);
    uint64_t v31 = _CSIStoreBlockData(a1, v30, v15);
    if (v31)
    {
      uint64_t v32 = v31[2];
      uint64_t v33 = v31[4];
    }
    else
    {
      uint64_t v32 = 0;
      uint64_t v33 = 0;
    }
    double v23 = (void *)(v32 + (*(_DWORD *)(a1 + 8) * v25) + v33 * *(unsigned int *)(a1 + 12));
    *(void *)(a1 + 80) = v31;
  }
LABEL_40:
  kdebug_trace();
  return v23;
}

uint64_t __csiBlockDataReleaseBytePointer(uint64_t a1)
{
  *(void *)(a1 + 80) = 0;
  return _objc_release_x1();
}

const UInt8 *__csiTextureDataLockData(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex *a4)
{
  *a4 = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  CFDataRef v5 = *(const __CFData **)(a1 + 40);
  return CFDataGetBytePtr(v5);
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

float64x2_t CG::Quadratic::Quadratic(CG::Quadratic *this, const Point *a2, const Point *a3, const Point *a4)
{
  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  float64x2_t v4 = *((float64x2_t *)this + 1);
  float64x2_t v5 = vsubq_f64(v4, *(float64x2_t *)this);
  *((double *)this + 6) = v5.f64[0] + v5.f64[0];
  *((double *)this + 7) = v5.f64[1] + v5.f64[1];
  float64x2_t result = vsubq_f64(vsubq_f64(*((float64x2_t *)this + 2), v4), v5);
  *((float64x2_t *)this + 4) = result;
  return result;
}

BOOL CG::Quadratic::is_flat(CG::Quadratic *this, double a2)
{
  double v2 = *((double *)this + 2);
  if (*(double *)this != v2 || *((double *)this + 1) != *((double *)this + 3))
  {
    double v3 = *((double *)this + 4);
    if (v2 != v3)
    {
      double v4 = *((double *)this + 5);
      double v5 = *((double *)this + 3);
      return (v4 - v5 + *((double *)this + 1) - v5) * (v4 - v5 + *((double *)this + 1) - v5)
           + (*(double *)this - v2 + v3 - v2) * (*(double *)this - v2 + v3 - v2) < a2 * 16.0 * a2;
    }
    double v5 = *((double *)this + 3);
    double v4 = *((double *)this + 5);
    if (v5 != v4) {
      return (v4 - v5 + *((double *)this + 1) - v5) * (v4 - v5 + *((double *)this + 1) - v5)
    }
           + (*(double *)this - v2 + v3 - v2) * (*(double *)this - v2 + v3 - v2) < a2 * 16.0 * a2;
  }
  return 1;
}

uint64_t CG::Quadratic::length(CG::Quadratic *this, int a2)
{
  uint64_t result = CG::Quadratic::is_flat(this, 0.5);
  if (a2 <= 32 && !result)
  {
    CG::Quadratic::split(this, 0.5, (uint64_t)v5);
    CG::Quadratic::length((CG::Quadratic *)v5, a2 + 1);
    return CG::Quadratic::length((CG::Quadratic *)&v6, a2 + 1);
  }
  return result;
}

double CG::Quadratic::split@<D0>(CG::Quadratic *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  double v3 = *((double *)this + 2);
  double v4 = *((double *)this + 3);
  double v5 = *((double *)this + 1);
  double v6 = *(double *)this + (v3 - *(double *)this) * a2;
  double v7 = v5 + (v4 - v5) * a2;
  double v8 = *((double *)this + 4);
  double v9 = *((double *)this + 5);
  double v10 = v3 + (v8 - v3) * a2;
  double v11 = v4 + (v9 - v4) * a2;
  double v12 = v6 + (v10 - v6) * a2;
  double v13 = v7 + (v11 - v7) * a2;
  double v14 = v6 - *(double *)this;
  double v15 = v11 - v13 + v11 - v13;
  *(void *)a3 = *(void *)this;
  *(double *)(a3 + 8) = v5;
  *(double *)(a3 + 16) = v6;
  *(double *)(a3 + 24) = v7;
  *(double *)(a3 + 32) = v12;
  *(double *)(a3 + 40) = v13;
  *(double *)(a3 + 48) = v14 + v14;
  *(double *)(a3 + 56) = v7 - v5 + v7 - v5;
  *(double *)(a3 + 64) = v12 - v6 - v14;
  *(double *)(a3 + 72) = v13 - v7 - (v7 - v5);
  *(double *)(a3 + 80) = v12;
  *(double *)(a3 + 88) = v13;
  *(double *)(a3 + 96) = v10;
  *(double *)(a3 + 104) = v11;
  *(double *)(a3 + 112) = v8;
  *(double *)(a3 + 120) = v9;
  double result = v9 - v11 - (v11 - v13);
  *(double *)(a3 + 128) = v10 - v12 + v10 - v12;
  *(double *)(a3 + 136) = v15;
  *(double *)(a3 + 144) = v8 - v10 - (v10 - v12);
  *(double *)(a3 + 152) = result;
  return result;
}

__CFString *CUIEffectBlendModeToString(int a1)
{
  double result = @"<unknown>";
  if (a1 > 1749838195)
  {
    if (a1 > 1852797548)
    {
      if (a1 > 1935766559)
      {
        int v3 = 1984719219;
        double v4 = @"CUIEffectBlendModeVividLight";
        double v13 = @"CUIEffectBlendModeVibrantColorSourceOver";
        if (a1 != 1986229103) {
          double v13 = @"<unknown>";
        }
        if (a1 == 1986227573) {
          double v14 = @"CUIEffectBlendModeVibrantColorMultiply";
        }
        else {
          double v14 = v13;
        }
        if (a1 != 1984719220) {
          double v4 = v14;
        }
        int v7 = 1935766560;
        double v8 = @"CUIEffectBlendModeSaturation";
        double v9 = @"CUIEffectBlendModeScreen";
        int v10 = 1935897198;
        BOOL v11 = a1 == 1936553316;
        double v12 = @"CUIEffectBlendModeExclusion";
        goto LABEL_24;
      }
      int v3 = 1884055923;
      uint64_t v24 = @"CUIEffectBlendModePassThrough";
      int v25 = @"CUIEffectBlendModeSoftLight";
      if (a1 != 1934387572) {
        int v25 = @"<unknown>";
      }
      if (a1 != 1885434739) {
        uint64_t v24 = v25;
      }
      if (a1 == 1884055924) {
        double v4 = @"CUIEffectBlendModePinLight";
      }
      else {
        double v4 = v24;
      }
      int v7 = 1852797549;
      double v8 = @"CUIEffectBlendModeNormal";
      int v22 = 1870030194;
      double v23 = @"CUIEffectBlendModeOverlay";
    }
    else
    {
      if (a1 > 1818391149)
      {
        int v3 = 1818850404;
        double v4 = @"CUIEffectBlendModeLighten";
        double v5 = @"CUIEffectBlendModeMultiply";
        if (a1 != 1836411936) {
          double v5 = @"<unknown>";
        }
        if (a1 == 1819634976) {
          double v6 = @"CUIEffectBlendModeLuminosity";
        }
        else {
          double v6 = v5;
        }
        if (a1 != 1818850405) {
          double v4 = v6;
        }
        int v7 = 1818391150;
        double v8 = @"CUIEffectBlendModeLinearBurn";
        double v9 = @"CUIEffectBlendModeLinearDodge";
        int v10 = 1818518631;
        BOOL v11 = a1 == 1818706796;
        double v12 = @"CUIEffectBlendModeLighterColor";
LABEL_24:
        if (!v11) {
          double v12 = @"<unknown>";
        }
        if (a1 != v10) {
          double v9 = v12;
        }
        goto LABEL_55;
      }
      int v3 = 1752524063;
      uint64_t v20 = @"CUIEffectBlendModeColorBurn";
      uint64_t v21 = @"CUIEffectBlendModeLinearLight";
      if (a1 != 1816947060) {
        uint64_t v21 = @"<unknown>";
      }
      if (a1 != 1768188278) {
        uint64_t v20 = v21;
      }
      if (a1 == 1752524064) {
        double v4 = @"CUIEffectBlendModeHue";
      }
      else {
        double v4 = v20;
      }
      int v7 = 1749838196;
      double v8 = @"CUIEffectBlendModeHardLight";
      int v22 = 1749903736;
      double v23 = @"CUIEffectBlendModeHardMix";
    }
    if (a1 == v22) {
      double v9 = v23;
    }
    else {
      double v9 = @"<unknown>";
    }
LABEL_55:
    if (a1 == v7) {
      uint64_t v16 = v8;
    }
    else {
      uint64_t v16 = v9;
    }
LABEL_68:
    if (a1 <= v3) {
      return v16;
    }
    else {
      return v4;
    }
  }
  if (a1 > 1668246641)
  {
    if (a1 > 1684633119)
    {
      int v3 = 1717856629;
      uint64_t v26 = @"CUIEffectBlendModeSubtract";
      if (a1 != 1718842722) {
        uint64_t v26 = @"<unknown>";
      }
      if (a1 == 1717856630) {
        double v4 = @"CUIEffectBlendModeDivide";
      }
      else {
        double v4 = v26;
      }
      uint64_t v16 = @"CUIEffectBlendModeColorDodge";
      BOOL v17 = a1 == 1684751212;
      uint64_t v18 = @"CUIEffectBlendModeDarkerColor";
      int v19 = 1684633120;
    }
    else
    {
      int v3 = 1684629093;
      double v15 = @"CUIEffectBlendModeDissolve";
      if (a1 != 1684632435) {
        double v15 = @"<unknown>";
      }
      if (a1 == 1684629094) {
        double v4 = @"CUIEffectBlendModeDifference";
      }
      else {
        double v4 = v15;
      }
      uint64_t v16 = @"CUIEffectBlendModeColor";
      BOOL v17 = a1 == 1684107883;
      uint64_t v18 = @"CUIEffectBlendModeDarken";
      int v19 = 1668246642;
    }
    if (!v17) {
      uint64_t v18 = @"<unknown>";
    }
    if (a1 != v19) {
      uint64_t v16 = v18;
    }
    goto LABEL_68;
  }
  switch(a1)
  {
    case 0:
      double result = @"CUIEffectBlendModeSourceOver";
      break;
    case 16:
      double result = @"CUIEffectBlendModeClear";
      break;
    case 17:
      double result = @"CUIEffectBlendModeCopy";
      break;
    case 18:
      double result = @"CUIEffectBlendModeSourceIn";
      break;
    case 19:
      double result = @"CUIEffectBlendModeSourceOut";
      break;
    case 20:
      double result = @"CUIEffectBlendModeSourceAtop";
      break;
    case 21:
      double result = @"CUIEffectBlendModeDestinationOver";
      break;
    case 22:
      double result = @"CUIEffectBlendModeDestinationIn";
      break;
    case 23:
      double result = @"CUIEffectBlendModeDestinationOut";
      break;
    case 24:
      double result = @"CUIEffectBlendModeDestinationAtop";
      break;
    case 25:
      double result = @"CUIEffectBlendModeXOR";
      break;
    case 26:
      double result = @"CUIEffectBlendModePlusDarker";
      break;
    case 27:
      double result = @"CUIEffectBlendModePlusLighter";
      break;
    default:
      return result;
  }
  return result;
}

__CFString *CUIEffectBlendModeDescription(int a1)
{
  if (a1) {
    int v1 = a1;
  }
  else {
    int v1 = 1852797549;
  }
  if ("Normal")
  {
    if (v1 == *(_DWORD *)"mron") {
      return (__CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    }
    for (uint64_t i = &off_1E5A58D38; *i; i += 3)
    {
      int v3 = *((_DWORD *)i - 4);
      if (v1 == v3) {
        return (__CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
      }
    }
  }
  return @"<unknown>";
}

__CFString *CUIEffectBevelStyleDescription(int a1)
{
  if ("Outer")
  {
    if (!a1) {
      return (__CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    }
    for (uint64_t i = &off_1E5A59260; *i; i += 3)
    {
      int v2 = *((_DWORD *)i - 4);
      if (v2 == a1) {
        return (__CFString *)+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
      }
    }
  }
  return @"<unknown>";
}

CFStringRef CUICopyFingerPrintForImage(CGImage *a1)
{
  memset(&srcs, 0, sizeof(srcs));
  srcFormat.bitsPerComponent = CGImageGetBitsPerComponent(a1);
  srcFormat.bitsPerPixel = CGImageGetBitsPerPixel(a1);
  srcFormat.colorSpace = CGImageGetColorSpace(a1);
  srcFormat.bitmapInfo = CGImageGetBitmapInfo(a1);
  memset(&srcFormat.version, 0, 20);
  vImage_Error v2 = MEMORY[0x1A6231AB0](&srcs, &srcFormat, 0, a1, 256);
  CFStringRef result = 0;
  vImage_Error error = v2;
  if (!v2)
  {
    *(void *)&destFormat.bitsPerComponent = 0x800000008;
    memset(&destFormat.bitmapInfo, 0, 24);
    destFormat.colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericGrayGamma2_2);
    CGFloat backgroundColor = 0.0;
    vImageConverterRef v4 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, &backgroundColor, 0x100u, &error);
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    if (!error)
    {
      int v7 = v4;
      dests.vImagePixelCount height = srcs.height;
      dests.vImagePixelCount width = srcs.width;
      dests.size_t rowBytes = srcs.width * destFormat.bitsPerPixel;
      dests.data = malloc_type_calloc(dests.rowBytes * srcs.height, 1uLL, 0x8379E552uLL);
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      vImage_Error error = vImageConvert_AnyToAny(v7, &srcs, &dests, 0, 0x110u);
      if (!error)
      {
        *(int64x2_t *)&dest.vImagePixelCount height = vdupq_n_s64(8uLL);
        dest.size_t rowBytes = 8;
        dest.data = v21;
        uint64_t v5 = 0;
        uint64_t v6 = 0;
        vImage_Error error = vImageScale_Planar8(&dests, &dest, 0, 0x120u);
        if (!error)
        {
          if (dest.height)
          {
            uint64_t v8 = 0;
            uint64_t v9 = 0;
            uint64_t v6 = 0;
            uint64_t v5 = 0;
            int v10 = v21;
            do
            {
              if (dest.width)
              {
                uint64_t v11 = 0;
                do
                {
                  BOOL v12 = (unint64_t)(v8 + v11 + 1) <= 0x40
                     && v10[v11] < v10[v11 + 1];
                  BOOL v13 = dest.width + v8 + v11 <= 0x40
                     && v10[v11] < v10[dest.width + v11];
                  uint64_t v5 = v12 | (2 * v5);
                  uint64_t v6 = v13 | (2 * v6);
                  ++v11;
                }
                while (dest.width != v11);
              }
              ++v9;
              v10 += dest.width;
              v8 += dest.width;
            }
            while (v9 != dest.height);
          }
          else
          {
            uint64_t v5 = 0;
            uint64_t v6 = 0;
          }
        }
        free(dests.data);
      }
      vImageConverter_Release(v7);
    }
    free(srcs.data);
    CGColorSpaceRelease(destFormat.colorSpace);
    if (error) {
      return 0;
    }
    else {
      return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%llx%llx", v5, v6);
    }
  }
  return result;
}

BOOL _CUIDebugUseSimplifiedTextAntialiasing()
{
  if (__CUIDebugAllowDebugging___once != -1) {
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_24);
  }
  if (!__CUIDebugAllowDebugging___AllowDebugPrefs) {
    return 0;
  }
  id v0 = +[NSUserDefaults standardUserDefaults];
  return [(NSUserDefaults *)v0 BOOLForKey:@"CUIUseSimplifiedTextAntialiasing"];
}

uint64_t _CUIDebugUseSimplifiedTextEffects()
{
  if (__CUIDebugAllowDebugging___once != -1) {
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_24);
  }
  if (!__CUIDebugAllowDebugging___AllowDebugPrefs) {
    return 1;
  }
  id v0 = [+[NSUserDefaults standardUserDefaults] objectForKey:@"CUIUseSimplifiedTextEffects"];
  if (!v0) {
    return 1;
  }
  return (uint64_t)[v0 BOOLValue];
}

id _CUIDebugAllowHardwareRendering()
{
  if (__CUIDebugAllowDebugging___once != -1) {
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_24);
  }
  if (!__CUIDebugAllowDebugging___AllowDebugPrefs) {
    return 0;
  }
  id v0 = [+[NSUserDefaults standardUserDefaults] objectForKey:@"CUIAllowHardwareRendering"];
  if (!v0) {
    return 0;
  }
  return [v0 BOOLValue];
}

BOOL _CUIDebugUseStandardRendering()
{
  if (__CUIDebugAllowDebugging___once != -1) {
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_24);
  }
  if (!__CUIDebugAllowDebugging___AllowDebugPrefs) {
    return 0;
  }
  id v0 = +[NSUserDefaults standardUserDefaults];
  return [(NSUserDefaults *)v0 BOOLForKey:@"CUIUseStandardRendering"];
}

BOOL _CUIDebugShowGraphicVariantMetrics()
{
  if (__CUIDebugAllowDebugging___once != -1) {
    dispatch_once(&__CUIDebugAllowDebugging___once, &__block_literal_global_24);
  }
  if (!__CUIDebugAllowDebugging___AllowDebugPrefs) {
    return 0;
  }
  id v0 = +[NSUserDefaults standardUserDefaults];
  return [(NSUserDefaults *)v0 BOOLForKey:@"CUIShowGraphicVariantMetrics"];
}

const void *CUIConstantToMapID(void *key)
{
  if (InitializeDictionaries(void)::sMutexInitConstantsDict == -1)
  {
    if (key) {
      return CFDictionaryGetValue((CFDictionaryRef)gConstants, key);
    }
  }
  else
  {
    dispatch_once(&InitializeDictionaries(void)::sMutexInitConstantsDict, &__block_literal_global_18);
    if (key) {
      return CFDictionaryGetValue((CFDictionaryRef)gConstants, key);
    }
  }
  return 0;
}

CFDictionaryRef ___ZL22InitializeDictionariesv_block_invoke()
{
  off_1EF485218();
  memcpy(v2, off_1E5A5CB70, sizeof(v2));
  memcpy(__dst, &unk_1A139F040, sizeof(__dst));
  gConstants = (uint64_t)CFDictionaryCreate(kCFAllocatorDefault, v2, __dst, 1229, &kCFTypeDictionaryKeyCallBacks, 0);
  CFDictionaryRef result = CFDictionaryCreate(kCFAllocatorDefault, __dst, v2, 1229, 0, &kCFTypeDictionaryValueCallBacks);
  gIDs = (uint64_t)result;
  return result;
}

void sub_1A1376C5C(_Unwind_Exception *a1)
{
  MEMORY[0x1A6230DF0](v1, 0x10B1C407992E97CLL);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PSDGradientColorStop>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a2);
}

CGContext *CreateARGBBitmapContext(CGFloat a1, CGFloat a2, CGFloat a3)
{
  uint64_t v6 = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);
  if (v6)
  {
    BOOL v13 = v6;
    BitmapContext = CreateBitmapContext(4, v6, 2, a1, a2, a3, v8, v9, v10, v11, v12);
    CGColorSpaceRelease(v13);
    return BitmapContext;
  }
  else
  {
    _CUILog(4, (uint64_t)"CoreUI: CreateARGBBitmapContext() couldln't lookup colorspace kCGColorSpaceSRGB", v7, v8, v9, v10, v11, v12, v16);
    return 0;
  }
}

CGContext *CreateBitmapContext(uint64_t a1, CGColorSpaceRef space, uint64_t a3, CGFloat a4, CGFloat a5, CGFloat a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v20 = CUICGBitmapContextCreate((unint64_t)(a4 * a6), (unint64_t)(a5 * a6), 8uLL, (unint64_t)(a4 * a6) * a1, space, a3, a10, a11);
  if (!v20) {
    _CUILog(4, (uint64_t)"CoreUI: CreateBitmapContext() Context not created!", v14, v15, v16, v17, v18, v19, v22);
  }
  CGContextScaleCTM(v20, a6, a6);
  v23.origin.double x = 0.0;
  v23.origin.CGFloat y = 0.0;
  v23.size.vImagePixelCount width = a4;
  v23.size.vImagePixelCount height = a5;
  CGContextClearRect(v20, v23);
  return v20;
}

unint64_t CUIGetChannelDataForImage(CGImage *a1, void **a2, CGFloat a3, CGFloat a4)
{
  ARGBBitmapContext = CreateARGBBitmapContext(a3, a4, 1.0);
  if (ARGBBitmapContext)
  {
    uint64_t v9 = ARGBBitmapContext;
    size_t Width = CGImageGetWidth(a1);
    size_t Height = CGImageGetHeight(a1);
    v31.size.vImagePixelCount width = (double)Width;
    v31.size.vImagePixelCount height = (double)Height;
    v31.origin.double x = 0.0;
    v31.origin.CGFloat y = 0.0;
    CGContextDrawImage(v9, v31, a1);
    Data = CGBitmapContextGetData(v9);
    if (Data)
    {
      unint64_t v13 = (unint64_t)a3;
      unint64_t v14 = (unint64_t)a4;
      src.data = Data;
      src.vImagePixelCount height = (unint64_t)a4;
      src.vImagePixelCount width = (unint64_t)a3;
      src.size_t rowBytes = 4 * (unint64_t)a3;
      uint64_t v15 = malloc_type_malloc(src.rowBytes * (unint64_t)a4, 0x96826F0EuLL);
      dest.data = v15;
      dest.vImagePixelCount height = (unint64_t)a4;
      dest.vImagePixelCount width = (unint64_t)a3;
      dest.size_t rowBytes = src.rowBytes;
      if (vImageUnpremultiplyData_ARGB8888(&src, &dest, 0))
      {
        uint64_t v16 = v15;
      }
      else
      {
        uint64_t v18 = 0;
        unint64_t v17 = v14 * v13;
        do
          a2[v18++] = malloc_type_malloc(v14 * v13, 0xC0EBB067uLL);
        while (v18 != 4);
        uint64_t v19 = malloc_type_malloc(v14 * v13, 0xAA606C00uLL);
        destA.data = *a2;
        destA.vImagePixelCount height = (unint64_t)a4;
        destA.vImagePixelCount width = (unint64_t)a3;
        destA.size_t rowBytes = (unint64_t)a3;
        uint64_t v20 = malloc_type_malloc(v14 * v13, 0x14244FFDuLL);
        destR.data = a2[1];
        destR.vImagePixelCount height = (unint64_t)a4;
        destR.vImagePixelCount width = (unint64_t)a3;
        destR.size_t rowBytes = (unint64_t)a3;
        uint64_t v21 = malloc_type_malloc(v14 * v13, 0xBA518CB1uLL);
        destG.data = a2[2];
        destG.vImagePixelCount height = (unint64_t)a4;
        destG.vImagePixelCount width = (unint64_t)a3;
        destG.size_t rowBytes = (unint64_t)a3;
        uint64_t v22 = malloc_type_malloc(v14 * v13, 0x15196A3CuLL);
        destB.data = a2[3];
        destB.vImagePixelCount height = (unint64_t)a4;
        destB.vImagePixelCount width = (unint64_t)a3;
        destB.size_t rowBytes = (unint64_t)a3;
        vImage_Error v23 = vImageConvert_ARGB8888toPlanar8(&dest, &destA, &destR, &destG, &destB, 0);
        free(v15);
        if (!v23) {
          goto LABEL_12;
        }
        free(v19);
        free(v20);
        free(v21);
        uint64_t v16 = v22;
      }
      free(v16);
    }
    unint64_t v17 = 0;
LABEL_12:
    CGContextRelease(v9);
    return v17;
  }
  return 0;
}

double _CUIEffectiveScaleForContext(CGContext *a1)
{
  if (!a1) {
    return 1.0;
  }
  CGContextGetCTM(&v4, a1);
  double v1 = v4.a * v4.d - v4.b * v4.c;
  double v2 = sqrt(v1);
  double result = sqrt(-v1);
  if (v1 >= 0.0) {
    return v2;
  }
  return result;
}

uint64_t _CUICreateNewContinuousRoundedRect(__n128 a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  return _CGPathCreateWithContinuousRoundedRect(0, a1, a2, a3, a4, a5, a5.n128_f64[0]);
}

void sub_1A1378F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CUIRenditionKey *CUICreateRenditionKeyWithShapeEffectState(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 a6)
{
  if (a1 > 0x17) {
    __int16 v6 = 0;
  }
  else {
    __int16 v6 = *(_WORD *)&aLumnrcsrevokra[2 * a1 + 60];
  }
  __int16 v7 = 0;
  __int16 v8 = 1;
  switch(a2)
  {
    case 1:
      __int16 v7 = 2;
      goto LABEL_9;
    case 2:
      __int16 v7 = 4;
      goto LABEL_9;
    case 3:
      __int16 v7 = 1;
      goto LABEL_9;
    case 4:
      goto LABEL_14;
    case 5:
      __int16 v7 = 5;
      goto LABEL_9;
    default:
LABEL_9:
      if (a4 == 1)
      {
        __int16 v8 = 1;
      }
      else if (a4 == 2)
      {
        __int16 v8 = 2;
      }
      else
      {
        __int16 v8 = 0;
      }
LABEL_14:
      v12[0] = 1;
      v12[1] = v6;
      Point v12[2] = 2;
      if (a5 == 1) {
        __int16 v9 = 179;
      }
      else {
        __int16 v9 = 178;
      }
      v12[3] = v9;
      v12[4] = 10;
      void v12[5] = v7;
      v12[6] = 6;
      v12[7] = v8;
      v12[8] = 14;
      v12[9] = a3 == 1;
      v12[10] = 8;
      v12[11] = a6;
      v12[12] = 12;
      if (a5 == 144) {
        __int16 v10 = 2;
      }
      else {
        __int16 v10 = 1;
      }
      v12[13] = v10;
      int v13 = 0;
      return [[CUIRenditionKey alloc] initWithKeyList:v12];
  }
}

void __GetShapeEffectCIContextOptions_block_invoke()
{
  CGMutablePathRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(Mutable, @"CoreUI", &__kCFBooleanTrue);
  CFDictionaryAddValue(Mutable, kCIContextWorkingColorSpace, kCFNull);
  CFDictionaryAddValue(Mutable, kCIContextCacheIntermediates, kCFBooleanFalse);
  if (_CUIDebugAllowHardwareRendering()) {
    CFBooleanRef v1 = kCFBooleanFalse;
  }
  else {
    CFBooleanRef v1 = (CFBooleanRef)&unk_1EF4A6B50;
  }
  CFDictionaryAddValue(Mutable, kCIContextUseSoftwareRenderer, v1);
  gCIContextOptions = (uint64_t)Mutable;
}

uint64_t CGBitmapDataProviderReleaseData()
{
  return CGBitmapFreeData();
}

void sub_1A1382330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

uint64_t CUIGetDeviceArtworkDisplayGamut()
{
  if (__getDeviceTraits___getDeviceTraits_once != -1) {
    dispatch_once(&__getDeviceTraits___getDeviceTraits_once, &__block_literal_global_505);
  }
  return __getDeviceTraits___deviceDisplayGamut;
}

uint64_t __blockSetRetain(uint64_t a1, uint64_t a2)
{
  return _CGImageBlockSetRetain(a2);
}

uint64_t __blockSetRelease()
{
  return CGImageBlockSetRelease();
}

uint64_t _StreamSys_init_read(unint64_t a1, uint64_t a2)
{
  uint64_t v16 = 0;
  if (!(a1 | a2) || BomSys_init(&v16, a2)) {
    return 0xFFFFFFFFLL;
  }
  BomSys_set_read(v16, (uint64_t)__StreamSys_read, v3, v4, v5, v6, v7, v8);
  BomSys_set_close(v16, (uint64_t)__StreamSys_close, v10, v11, v12, v13, v14, v15);
  uint64_t result = 0;
  if (a1) {
    *(void *)a1 = v16;
  }
  return result;
}

CFIndex __StreamSys_read(__CFReadStream *a1, int a2, UInt8 *buffer, CFIndex bufferLength)
{
  return CFReadStreamRead(a1, buffer, bufferLength);
}

uint64_t __StreamSys_close(__CFReadStream *a1)
{
  return 0;
}

uint64_t _StreamSys_init_write(unint64_t a1, uint64_t a2)
{
  uint64_t v16 = 0;
  if (!(a1 | a2) || BomSys_init(&v16, a2)) {
    return 0xFFFFFFFFLL;
  }
  BomSys_set_write(v16, (uint64_t)__StreamSys_write, v3, v4, v5, v6, v7, v8);
  BomSys_set_close(v16, (uint64_t)__StreamSys_close, v10, v11, v12, v13, v14, v15);
  uint64_t result = 0;
  if (a1) {
    *(void *)a1 = v16;
  }
  return result;
}

CFIndex __StreamSys_write(__CFWriteStream *a1, int a2, UInt8 *buffer, CFIndex bufferLength)
{
  return CFWriteStreamWrite(a1, buffer, bufferLength);
}

uint64_t _BOMFileNewFromCFReadStreamSys(void *a1, long long *a2, char a3)
{
  if (BOMFileNewFromFDWithSys(a1, 0, a3, "r", a2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t _BOMFileNewFromCFWriteStreamSys(void *a1, long long *a2, char a3)
{
  if (BOMFileNewFromFDWithSys(a1, 0, a3, "w", a2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

BOOL sub_1A138A3E4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void sub_1A138A3F8()
{
}

void sub_1A138A440()
{
}

void sub_1A138A46C()
{
}

uint64_t sub_1A138A4B0()
{
  uint64_t v1 = 0x70616C7265766FLL;
  if (*v0 != 1) {
    uint64_t v1 = 0x7265746661;
  }
  if (*v0) {
    return v1;
  }
  else {
    return 0x65726F666562;
  }
}

unint64_t sub_1A138A508()
{
  unint64_t result = qword_1E953FD38;
  if (!qword_1E953FD38)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E953FD38);
  }
  return result;
}

ValueMetadata *type metadata accessor for BezierPath()
{
  return &type metadata for BezierPath;
}

uint64_t initializeBufferWithCopyOfBuffer for BezierPath.Segment(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a1 = *a2;
  uint64_t v3 = v2 + 16;
  swift_retain();
  return v3;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for BezierPath.Segment(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for BezierPath.Segment(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 64) = v3;
  return result;
}

ValueMetadata *type metadata accessor for BezierPath.Segment()
{
  return &type metadata for BezierPath.Segment;
}

unsigned char *__swift_memcpy1_1(unsigned char *result, unsigned char *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for BezierPath.Segment.RelativePosition(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for BezierPath.Segment.RelativePosition(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    *__n128 result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1A138A78CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 2;
        break;
    }
  }
  return result;
}

uint64_t sub_1A138A7B4(unsigned __int8 *a1)
{
  return *a1;
}

unsigned char *sub_1A138A7BC(unsigned char *result, char a2)
{
  *__n128 result = a2;
  return result;
}

ValueMetadata *type metadata accessor for BezierPath.Segment.RelativePosition()
{
  return &type metadata for BezierPath.Segment.RelativePosition;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t sub_1A138A7E0(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1A138A800(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 16) = v3;
  return result;
}

void type metadata accessor for CGPoint(uint64_t a1)
{
}

void type metadata accessor for CGMutablePath(uint64_t a1)
{
}

uint64_t sub_1A138A850(uint64_t a1)
{
  type metadata accessor for CGPath(255);
  *(void *)(a1 + 16) = v2;
  return 0;
}

void type metadata accessor for CGPath(uint64_t a1)
{
}

uint64_t sub_1A138A898(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)(a1 + 8)) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t sub_1A138A8DC(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)__n128 result = a2 - 2;
    *(void *)(result + 8) = 0;
    if (a3 >= 2) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)(result + 8) = 0;
    }
  }
  return result;
}

void type metadata accessor for CGPathElement(uint64_t a1)
{
}

void type metadata accessor for CGPathElementType(uint64_t a1)
{
}

void sub_1A138A940(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }
}

void *BOMBufferAllocate(size_t a1)
{
  uint64_t v2 = BOM_malloczero(0x48uLL);
  int v3 = malloc_type_valloc(a1, 0xA28A8515uLL);
  v2[3] = v3;
  *uint64_t v2 = a1;
  if (v3)
  {
    __CFSetLastAllocationEventName();
  }
  else
  {
    free(v2);
    return 0;
  }
  return v2;
}

void BOMBufferDeallocate(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    a1[8] = 0;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
}

void *BOMBufferPoolAllocate(size_t a1, unint64_t a2)
{
  uint64_t v4 = BOM_malloczero(0xA0uLL);
  if (pthread_cond_init((pthread_cond_t *)v4 + 1, 0)) {
    goto LABEL_4;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(v4 + 12), 0))
  {
    pthread_cond_destroy((pthread_cond_t *)v4 + 1);
LABEL_4:
    free(v4);
    return 0;
  }
  *uint64_t v4 = 0;
  v4[1] = 0;
  v4[2] = a2;
  v4[3] = a1;
  v4[4] = 0;
  v4[5] = v4 + 4;
  if (a2 >= 0x40) {
    a2 = 64;
  }
  if (a2)
  {
    while (1)
    {
      unsigned int v6 = BOMBufferAllocate(a1);
      if (!v6) {
        break;
      }
      --v4[2];
      BOMBufferPoolAddBuffer((uint64_t)v4, (uint64_t)v6);
      if (!--a2) {
        return v4;
      }
    }
    BOMBufferPoolDeallocate((uint64_t)v4);
    return 0;
  }
  return v4;
}

void BOMBufferPoolDeallocate(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)) && !pthread_mutex_unlock(v2))
    {
      pthread_cond_destroy((pthread_cond_t *)(a1 + 48));
      pthread_mutex_destroy(v2);
      while (1)
      {
        uint64_t v3 = *(void *)(a1 + 32);
        if (!v3) {
          break;
        }
        uint64_t v4 = *(void *)(v3 + 56);
        uint64_t v5 = *(void **)(v3 + 64);
        if (v4)
        {
          *(void *)(v4 + 64) = v5;
          uint64_t v5 = *(void **)(v3 + 64);
        }
        else
        {
          *(void *)(a1 + 40) = v5;
        }
        void *v5 = v4;
        BOMBufferDeallocate((void **)v3);
      }
      *(void *)(a1 + 64) = 0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      free((void *)a1);
    }
  }
}

uint64_t BOMBufferPoolAddBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 96);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!result)
  {
    unsigned int v6 = (void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a2 + 56) = v7;
    if (v7) {
      int v8 = (void *)(v7 + 64);
    }
    else {
      int v8 = (void *)(a1 + 40);
    }
    *int v8 = a2 + 56;
    *unsigned int v6 = a2;
    *(void *)(a2 + 64) = v6;
    *(int64x2_t *)a1 = vaddq_s64(*(int64x2_t *)a1, vdupq_n_s64(1uLL));
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  }
  return result;
}

void *BOMBufferPoolRequestBuffer(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 96))) {
    return 0;
  }
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (v5) {
      break;
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6)
    {
      *(void *)(a1 + 16) = v6 - 1;
      ++*(void *)a1;
      pthread_mutex_unlock(v2);
      uint64_t v7 = BOMBufferAllocate(*(void *)(a1 + 24));
      if (v7) {
        return v7;
      }
      if (pthread_mutex_lock(v2)) {
        return 0;
      }
      ++*(void *)(a1 + 16);
      --*(void *)a1;
    }
    else if (pthread_cond_wait((pthread_cond_t *)(a1 + 48), v2))
    {
      return 0;
    }
  }
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v3 + 56);
  __int16 v9 = *(void **)(v3 + 64);
  if (v8)
  {
    *(void *)(v8 + 64) = v9;
    __int16 v9 = *(void **)(v3 + 64);
  }
  else
  {
    *(void *)(a1 + 40) = v9;
  }
  void *v9 = v8;
  *(void *)(a1 + 8) = v5 - 1;
  pthread_mutex_unlock(v2);
  pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  return (void *)v3;
}

uint64_t BOMBufferPoolReturnBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 96);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!result)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v6 = a1 + 32;
    *(void *)(a2 + 56) = v7;
    uint64_t v8 = (void *)(v7 + 64);
    if (v7) {
      __int16 v9 = v8;
    }
    else {
      __int16 v9 = (void *)(v6 + 8);
    }
    void *v9 = a2 + 56;
    *(void *)uint64_t v6 = a2;
    *(void *)(a2 + 64) = v6;
    ++*(void *)(v6 - 24);
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(v6 + 16));
  }
  return result;
}

char *BOMBufferFIFOCreate()
{
  id v0 = (char *)BOM_malloczero(0x88uLL);
  if (!pthread_cond_init((pthread_cond_t *)(v0 + 24), 0))
  {
    if (!pthread_mutex_init((pthread_mutex_t *)(v0 + 72), 0))
    {
      *(void *)id v0 = 0;
      *((void *)v0 + 1) = 0;
      *((void *)v0 + 2) = v0 + 8;
      return v0;
    }
    pthread_cond_destroy((pthread_cond_t *)(v0 + 24));
  }
  free(v0);
  return 0;
}

void BOMBufferFIFODestroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 72);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
    {
      if (*(void *)a1)
      {
        uint64_t v10 = BOMExceptionHandlerMessage("Attempting to destroy a non-empty FIFO!", v3, v4, v5, v6, v7, v8, v9, v12);
        uint64_t v11 = __error();
        _BOMFatalException(v10, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMBufferManager.c", 311, *v11);
      }
      if (!pthread_mutex_unlock(v2))
      {
        pthread_cond_destroy((pthread_cond_t *)(a1 + 24));
        pthread_mutex_destroy(v2);
        free((void *)a1);
      }
    }
  }
}

uint64_t BOMBufferFIFOEnqueue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 72);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  if (!result)
  {
    *(void *)(a2 + 56) = 0;
    uint64_t v6 = *(void **)(a1 + 16);
    *(void *)(a2 + 64) = v6;
    *uint64_t v6 = a2;
    *(void *)(a1 + 16) = a2 + 56;
    ++*(void *)a1;
    pthread_mutex_unlock(v4);
    return pthread_cond_broadcast((pthread_cond_t *)(a1 + 24));
  }
  return result;
}

uint64_t BOMBufferFIFODequeue(uint64_t *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9))) {
    return 0;
  }
  while (1)
  {
    uint64_t v3 = *a1;
    if (*a1) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 3), v2)) {
      return 0;
    }
  }
  uint64_t v4 = a1[1];
  uint64_t v6 = *(void *)(v4 + 56);
  uint64_t v7 = *(void **)(v4 + 64);
  if (v6)
  {
    *(void *)(v6 + 64) = v7;
    uint64_t v7 = *(void **)(v4 + 64);
  }
  else
  {
    a1[2] = (uint64_t)v7;
  }
  *uint64_t v7 = v6;
  uint64_t v8 = v3 - 1;
  *a1 = v3 - 1;
  pthread_mutex_unlock(v2);
  uint64_t v9 = (pthread_cond_t *)(a1 + 3);
  if (v8) {
    pthread_cond_signal(v9);
  }
  else {
    pthread_cond_broadcast(v9);
  }
  return v4;
}

uint64_t BOMBufferFIFOCount(uint64_t *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9))) {
    return 0;
  }
  uint64_t v3 = *a1;
  pthread_mutex_unlock(v2);
  return v3;
}

void __defaultHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 24)) {
    _CUILog(4, (uint64_t)"[%s:%u] %s", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 16));
  }
  else {
    _CUILog(4, (uint64_t)"%s", a3, a4, a5, a6, a7, a8, *(void *)a1);
  }
  if (*(unsigned char *)(a1 + 8)) {
    abort();
  }
}

void _BOMFatalException(void *a1, const char *a2, int a3, int a4)
{
  uint64_t v8 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))__BOMGlobalExceptionHandler();
  if (!a1) {
    a1 = __BOMExceptionMessageString();
  }
  uint64_t v11 = a1;
  uint64_t v12 = 0;
  if (v8) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = __defaultHandler;
  }
  LOBYTE(v12) = 1;
  if (a2) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = "";
  }
  uint64_t v13 = v10;
  int v14 = a3;
  int v15 = a4;
  ((void (*)(void **))v9)(&v11);
  abort();
}

void *__BOMGlobalExceptionHandler()
{
  if (__BOMExceptionHandlerKey___onceHandler != -1) {
    dispatch_once(&__BOMExceptionHandlerKey___onceHandler, &__block_literal_global_21);
  }
  pthread_key_t v0 = __BOMExceptionHandlerKey___key;
  return pthread_getspecific(v0);
}

void *__BOMExceptionMessageString()
{
  if (__BOMExceptionMessageString___onceMessage != -1) {
    dispatch_once(&__BOMExceptionMessageString___onceMessage, &__block_literal_global_6);
  }
  pthread_key_t v0 = pthread_getspecific(__BOMExceptionMessageString___key);
  if (!v0)
  {
    pthread_key_t v0 = malloc_type_calloc(0x1000uLL, 1uLL, 0x100004077774924uLL);
    __CFSetLastAllocationEventName();
    if (pthread_setspecific(__BOMExceptionMessageString___key, v0)) {
      _CUILog(4, (uint64_t)"__BOMExceptionMessageString couldn't pthread_setspecific", v1, v2, v3, v4, v5, v6, v8);
    }
  }
  return v0;
}

uint64_t (*_BOMExceptionHandlerCall(void *a1, unsigned __int8 a2, const char *a3, int a4, int a5))(void *)
{
  uint64_t result = (uint64_t (*)(void *))__BOMGlobalExceptionHandler();
  if (result)
  {
    uint64_t v11 = result;
    if (!a1) {
      a1 = __BOMExceptionMessageString();
    }
    v13[0] = a1;
    uint64_t v12 = "";
    v13[1] = a2;
    if (a3) {
      uint64_t v12 = a3;
    }
    v13[2] = v12;
    int v14 = a4;
    int v15 = a5;
    return (uint64_t (*)(void *))v11(v13);
  }
  return result;
}

char *BOMExceptionHandlerMessage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10 = (char *)__BOMExceptionMessageString();
  vsnprintf(v10, 0x1000uLL, a1, &a9);
  return v10;
}

uint64_t BOMFileNewFromFDWithSys(void *a1, uint64_t a2, char a3, unsigned __int8 *a4, long long *a5)
{
  uint64_t v10 = BOM_malloczero(0xF8uLL);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v10;
  if (a5)
  {
    if ((a3 & 0x10) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  a5 = BomSys_default();
  if ((a3 & 0x10) != 0) {
LABEL_4:
  }
    (*((void (**)(void, uint64_t, uint64_t, uint64_t))a5 + 4))(*((void *)a5 + 1), a2, 48, 1);
LABEL_5:
  *uint64_t v11 = *a4 == 119;
  void v11[2] = a2;
  if (_BOMFileInit(v11, a3 & 0xF, a5))
  {
LABEL_6:
    uint64_t v12 = v11;
LABEL_7:
    _freeBOMFile(v12);
    return 0xFFFFFFFFLL;
  }
  if ((a3 & 0x20) != 0)
  {
    if (getenv("BOM_ASYNC_DEBUG"))
    {
      gBOMAsyncDebug = 1;
    }
    else if (gBOMAsyncDebug != 1)
    {
LABEL_17:
      int v14 = BOM_malloczero(0xF8uLL);
      if (!v14) {
        goto LABEL_6;
      }
      int v15 = v14;
      if (*v11 == 1) {
        int v16 = 5;
      }
      else {
        int v16 = 4;
      }
      *(_DWORD *)int v14 = v16;
      v14[1] = v11;
      if (_BOMFileInit(v14, 0, a5))
      {
        uint64_t v12 = v15;
        goto LABEL_7;
      }
      uint64_t v11 = v15;
      goto LABEL_12;
    }
    fprintf(__stderrp, "async compression enabled for %d\n", a2);
    goto LABEL_17;
  }
LABEL_12:
  uint64_t result = 0;
  *a1 = v11;
  return result;
}

uint64_t _BOMFileInit(_DWORD *a1, int a2, long long *a3)
{
  if (!a3) {
    a3 = BomSys_default();
  }
  *((void *)a1 + 30) = a3;
  if (a2 == 4) {
    int v5 = 3;
  }
  else {
    int v5 = 0;
  }
  if (a2 == 5) {
    int v6 = 4;
  }
  else {
    int v6 = v5;
  }
  BOOL v7 = a2 == 1;
  if (a2 == 1) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v6;
  }
  int v9 = v7;
  a1[6] = v8;
  switch(*a1)
  {
    case 0:
    case 3:
      if (v9)
      {
        memset(__src, 0, 11);
        size_t Raw = _BOMFileReadRaw((uint64_t)a1, __src, 11);
        if (Raw == -1) {
          goto LABEL_52;
        }
        BOOL v8 = a1[6] == 1 && __src[0] == 31 && __src[1] == 139 && __src[2] == 8;
        a1[6] = v8;
        *((void *)a1 + 8) = Raw;
        a1[18] = 1;
        memcpy(a1 + 19, __src, Raw);
      }
      if ((v8 - 3) < 2) {
        return _BOMFileCompressionLibrary_Setup((uint64_t)a1, 0);
      }
      if (!v8) {
        return 0;
      }
      return _BOMFileSetupGzip((uint64_t)a1, 0);
    case 1:
    case 2:
      if ((v8 - 3) >= 2)
      {
        if (v8)
        {
          *(_DWORD *)&__src[7] = 196608;
          *(void *)__vImage_Buffer src = 559903;
          if (_BOMFileSetupGzip((uint64_t)a1, 1) || _BOMFileWriteRaw((uint64_t)a1, __src, 10) <= 9) {
            goto LABEL_52;
          }
        }
        return 0;
      }
      else
      {
        return _BOMFileCompressionLibrary_Setup((uint64_t)a1, 1);
      }
    case 4:
      if (gBufferPoolOnce != -1) {
        dispatch_once(&gBufferPoolOnce, &__block_literal_global_12_0);
      }
      int v15 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v15) {
        goto LABEL_52;
      }
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v15);
      *((void *)a1 + 11) = BOMBufferFIFOCreate();
      *((void *)a1 + 12) = 0;
      *((void *)a1 + 28) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 40), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 28), 0)) {
        goto LABEL_48;
      }
      int v16 = (pthread_t *)(a1 + 26);
      unint64_t v17 = (void *(__cdecl *)(void *))_asyncReadThread;
      goto LABEL_57;
    case 5:
      if (gBufferPoolOnce != -1) {
        dispatch_once(&gBufferPoolOnce, &__block_literal_global_22);
      }
      uint64_t v18 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v18) {
        goto LABEL_52;
      }
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v18);
      *((void *)a1 + 11) = BOMBufferFIFOCreate();
      *((void *)a1 + 12) = 0;
      *((void *)a1 + 28) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 40), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 28), 0))
      {
LABEL_48:
        uint64_t result = 1;
      }
      else
      {
        int v16 = (pthread_t *)(a1 + 26);
        unint64_t v17 = (void *(__cdecl *)(void *))_asyncWriteThread;
LABEL_57:
        uint64_t result = pthread_create(v16, 0, v17, a1) != 0;
      }
      break;
    default:
LABEL_52:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

void _freeBOMFile(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    free(v2);
    a1[4] = 0;
  }
  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    free(v3);
    a1[5] = 0;
  }
  uint64_t v4 = a1[11];
  if (v4) {
    BOMBufferFIFODestroy(v4);
  }
  free(a1);
}

BOOL BOMFileIsEOF(uint64_t a1)
{
  return *(unsigned char *)(a1 + 56) != 0;
}

uint64_t BOMFileClose(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v2 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) <= 1)
  {
    int v3 = *(_DWORD *)(a1 + 24);
    if ((v3 - 3) >= 2)
    {
      if (v3 == 1)
      {
        int v6 = *(z_stream **)(a1 + 32);
        uInt avail_out = v6->avail_out;
        if (avail_out) {
          goto LABEL_10;
        }
        BOOL v8 = 0;
        while (1)
        {
          CFIndex v11 = 0x20000 - avail_out;
          uint64_t v12 = *(UInt8 **)(a1 + 40);
          while (v11)
          {
            uint64_t v13 = _BOMFileWriteRaw(a1, v12, v11);
            v11 -= v13;
            v12 += v13;
            if (v13 == -1) {
              return 0xFFFFFFFFLL;
            }
          }
          v6->next_out = *(Bytef **)(a1 + 40);
          v6->uInt avail_out = 0x20000;
          if (v8) {
            break;
          }
LABEL_10:
          int v10 = deflate(v6, 4);
          if (v10)
          {
            if (v10 != 1) {
              return 0xFFFFFFFFLL;
            }
            uInt avail_out = v6->avail_out;
            BOOL v8 = 1;
          }
          else
          {
            uInt avail_out = v6->avail_out;
            BOOL v8 = avail_out != 0;
          }
        }
        uint64_t v14 = 0;
        uint64_t v15 = *(void *)(a1 + 48);
        *(void *)(a1 + 48) = v15;
        *(_DWORD *)buffer = v15;
        while (v14 != 4)
        {
          uint64_t v16 = _BOMFileWriteRaw(a1, buffer, 4 - v14);
          v14 += v16;
          if (v16 < 0) {
            return 0xFFFFFFFFLL;
          }
        }
        uint64_t v17 = 0;
        uLong total_in = v6->total_in;
        v6->uLong total_in = total_in;
        *(_DWORD *)uint64_t v38 = total_in;
        while (v17 != 4)
        {
          uint64_t v19 = _BOMFileWriteRaw(a1, v38, 4 - v17);
          v17 += v19;
          if (v19 < 0) {
            return 0xFFFFFFFFLL;
          }
        }
        deflateEnd(v6);
      }
    }
    else
    {
      uint64_t v4 = *(compression_stream **)(a1 + 32);
      if (v4->dst_size) {
        goto LABEL_28;
      }
      char v5 = 1;
      while (1)
      {
        CFIndex v21 = 0x20000 - v4->dst_size;
        uint64_t v22 = *(UInt8 **)(a1 + 40);
        while (v21)
        {
          uint64_t v23 = _BOMFileWriteRaw(a1, v22, v21);
          v21 -= v23;
          v22 += v23;
          if (v23 == -1) {
            return 0xFFFFFFFFLL;
          }
        }
        v4->dst_ptr = *(uint8_t **)(a1 + 40);
        v4->dst_size = 0x20000;
        if ((v5 & 1) == 0) {
          break;
        }
LABEL_28:
        char v5 = 1;
        uint64_t v20 = compression_stream_process(v4, 1);
        if (v20 == 1)
        {
          char v5 = 0;
        }
        else
        {
          uint64_t v9 = v20;
          if (v20 == -1) {
            return v9;
          }
        }
      }
      compression_stream_destroy(v4);
    }
    int v2 = *(_DWORD *)a1;
  }
  if (v2 == 3 || v2 == 0)
  {
    int v25 = *(_DWORD *)(a1 + 24);
    if ((v25 - 3) >= 2)
    {
      if (v25 == 1)
      {
        uint64_t v27 = *(void *)(a1 + 32);
        uint64_t v26 = *(void **)(a1 + 40);
        size_t v28 = *(unsigned int *)(v27 + 8);
        *(void *)(a1 + 64) = v28;
        *(_DWORD *)(a1 + 72) = 0;
        memmove(v26, *(const void **)v27, v28);
        if (inflateEnd(*(z_streamp *)(a1 + 32))) {
          return 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      compression_stream_destroy(*(compression_stream **)(a1 + 32));
    }
  }
  int v29 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 0xFFFFFFFE) == 4)
  {
    if (v29 == 4)
    {
      if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
      {
        uint64_t v31 = *(void *)(a1 + 96);
        if (v31)
        {
          BOMBufferPoolReturnBuffer(gBufferPool, v31);
          *(void *)(a1 + 96) = 0;
        }
        while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 88)))
        {
          uint64_t v32 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
          BOMBufferPoolReturnBuffer(gBufferPool, v32);
        }
        int v33 = *(_DWORD *)(a1 + 224);
        if (!v33)
        {
          int v33 = 1;
          *(_DWORD *)(a1 + 224) = 1;
        }
        if (gBOMAsyncDebug == 1)
        {
          fwrite("waiting for async read thread to finish...", 0x2AuLL, 1uLL, __stderrp);
          int v33 = *(_DWORD *)(a1 + 224);
        }
        if (v33 != 2)
        {
          while (!pthread_cond_wait((pthread_cond_t *)(a1 + 112), (pthread_mutex_t *)(a1 + 160)))
          {
            if (*(_DWORD *)(a1 + 224) == 2) {
              goto LABEL_65;
            }
          }
          return 0xFFFFFFFFLL;
        }
LABEL_65:
        if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)) && !pthread_join(*(pthread_t *)(a1 + 104), 0))
        {
          while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 88)))
          {
            uint64_t v34 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
            BOMBufferPoolReturnBuffer(gBufferPool, v34);
          }
          if (gBOMAsyncDebug != 1) {
            goto LABEL_71;
          }
LABEL_70:
          fwrite("done\n", 5uLL, 1uLL, __stderrp);
LABEL_71:
          int v29 = *(_DWORD *)a1;
          goto LABEL_72;
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (v29 == 5)
    {
      double v30 = *(void **)(a1 + 96);
      if (v30)
      {
        *(void *)(a1 + 96) = 0;
      }
      else
      {
        double v30 = BOMBufferPoolRequestBuffer(gBufferPool);
        v30[1] = 0;
        v30[2] = 0;
      }
      *((_DWORD *)v30 + 12) |= 1u;
      BOMBufferFIFOEnqueue(*(void *)(a1 + 88), (uint64_t)v30);
      if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
      {
        int v36 = *(_DWORD *)(a1 + 224);
        if (!v36)
        {
          int v36 = 1;
          *(_DWORD *)(a1 + 224) = 1;
        }
        if (gBOMAsyncDebug == 1)
        {
          fwrite("waiting for async write thread to finish...", 0x2BuLL, 1uLL, __stderrp);
          int v36 = *(_DWORD *)(a1 + 224);
        }
        if (v36 != 2)
        {
          while (!pthread_cond_wait((pthread_cond_t *)(a1 + 112), (pthread_mutex_t *)(a1 + 160)))
          {
            if (*(_DWORD *)(a1 + 224) == 2) {
              goto LABEL_91;
            }
          }
          return 0xFFFFFFFFLL;
        }
LABEL_91:
        if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)) && !pthread_join(*(pthread_t *)(a1 + 104), 0))
        {
          if (gBOMAsyncDebug == 1) {
            fwrite("async write thread terminated. Draining FIFO...", 0x2FuLL, 1uLL, __stderrp);
          }
          while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 88)))
          {
            uint64_t v37 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
            BOMBufferPoolReturnBuffer(gBufferPool, v37);
          }
          if ((gBOMAsyncDebug & 1) == 0) {
            goto LABEL_71;
          }
          goto LABEL_70;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
LABEL_72:
  switch(v29)
  {
    case 0:
    case 1:
      uint64_t v9 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 240) + 24))(*(void *)(*(void *)(a1 + 240) + 8), *(unsigned int *)(a1 + 8));
      *(_DWORD *)(a1 + 8) = -1;
      break;
    case 2:
      CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 8));
      goto LABEL_78;
    case 3:
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 8));
LABEL_78:
      uint64_t v9 = 0;
      goto LABEL_79;
    case 4:
    case 5:
      uint64_t v9 = BOMFileClose(*(void *)(a1 + 8));
LABEL_79:
      *(void *)(a1 + 8) = 0;
      break;
    default:
      uint64_t v9 = 0;
      break;
  }
  _freeBOMFile((void *)a1);
  return v9;
}

size_t BOMFileRead(uint64_t a1, UInt8 *buffer, unint64_t bufferLength)
{
  if (!a1) {
    return -1;
  }
  unint64_t v3 = bufferLength;
  uint64_t v4 = buffer;
  int v6 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
LABEL_5:
    if (!bufferLength) {
      return 0;
    }
    if (!buffer) {
      return -1;
    }
    int v7 = *(_DWORD *)(a1 + 24);
    if ((v7 - 3) < 2)
    {
      uint64_t v20 = *(compression_stream **)(a1 + 32);
      v20->dst_ptr = buffer;
      v20->size_t dst_size = bufferLength;
      while (1)
      {
        int v21 = *(unsigned __int8 *)(a1 + 56);
        if (v20->src_size) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v21 == 0;
        }
        if (v22)
        {
          uint64_t Raw = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 40), 0x20000);
          if (Raw)
          {
            if (Raw == -1) {
              goto LABEL_57;
            }
            v20->src_ptr = *(const uint8_t **)(a1 + 40);
            v20->size_t src_size = Raw;
            int v21 = *(unsigned __int8 *)(a1 + 56);
          }
          else
          {
            int v21 = 1;
            *(unsigned char *)(a1 + 56) = 1;
          }
        }
        compression_status v24 = compression_stream_process(v20, v21 != 0);
        if (v24 == COMPRESSION_STATUS_END) {
          break;
        }
        if (v24 == COMPRESSION_STATUS_ERROR)
        {
LABEL_57:
          *(unsigned char *)(a1 + 56) = 1;
          return -1;
        }
        size_t dst_size = v20->dst_size;
        if (!dst_size) {
          return v3 - dst_size;
        }
      }
      size_t dst_size = v20->dst_size;
    }
    else
    {
      if (!v7)
      {
        unint64_t v25 = *(void *)(a1 + 64);
        if (v25)
        {
          if (*(_DWORD *)(a1 + 72)) {
            uint64_t v26 = (char *)(a1 + 76);
          }
          else {
            uint64_t v26 = *(char **)(a1 + 40);
          }
          if (v25 >= bufferLength) {
            size_t v28 = bufferLength;
          }
          else {
            size_t v28 = *(void *)(a1 + 64);
          }
          memcpy(buffer, v26, v28);
          uint64_t v29 = *(void *)(a1 + 64);
          v3 -= v28;
          *(_DWORD *)(a1 + 236) -= v28;
          v4 += v28;
          *(void *)(a1 + 64) = v29 - v28;
          if (v29 != v28) {
            memmove(v26, &v26[v28], v29 - v28);
          }
        }
        else
        {
          size_t v28 = 0;
        }
        uint64_t v30 = _BOMFileReadRaw(a1, v4, v3);
        uint64_t v10 = v30;
        if (v30 != -1)
        {
          if (!v30) {
            *(unsigned char *)(a1 + 56) = 1;
          }
          return v30 + v28;
        }
        return v10;
      }
      if (v7 != 1) {
        return -1;
      }
      BOOL v8 = *(z_stream **)(a1 + 32);
      v8->next_out = buffer;
      v8->uInt avail_out = bufferLength;
      while (1)
      {
        if (!v8->avail_in && !*(unsigned char *)(a1 + 56))
        {
          uint64_t v9 = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 40), 0x20000);
          uint64_t v10 = v9;
          if (v9)
          {
            if (v9 == -1) {
              return v10;
            }
          }
          else
          {
            *(unsigned char *)(a1 + 56) = 1;
          }
          *(_DWORD *)(a1 + 236) = v9;
          v8->avail_in = v9;
          v8->next_in = *(Bytef **)(a1 + 40);
        }
        int v11 = inflate(v8, 0);
        if (v11)
        {
          if (v11 != 1) {
            goto LABEL_57;
          }
          *(unsigned char *)(a1 + 56) = 1;
        }
        size_t dst_size = v8->avail_out;
        if (!dst_size || dst_size != v3) {
          break;
        }
        if (*(unsigned char *)(a1 + 56))
        {
          size_t dst_size = v3;
          return v3 - dst_size;
        }
      }
    }
    return v3 - dst_size;
  }
  if (v6 != 4)
  {
    if (v6 != 3) {
      return -1;
    }
    goto LABEL_5;
  }
  uint64_t v10 = 0;
  if (!bufferLength) {
    goto LABEL_38;
  }
  while (1)
  {
    uint64_t v13 = *(void **)(a1 + 96);
    if (!v13)
    {
      uint64_t v13 = (void *)BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
      *(void *)(a1 + 96) = v13;
    }
    uint64_t v14 = v13[1];
    if (v3 >= v13[2] - v14) {
      size_t v15 = v13[2] - v14;
    }
    else {
      size_t v15 = v3;
    }
    memcpy(v4, (const void *)(v13[3] + v14), v15);
    uint64_t v16 = v13[2];
    size_t v17 = v13[1] + v15;
    v13[1] = v17;
    v10 += v15;
    if (v16 != v17) {
      goto LABEL_37;
    }
    if (!v17)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 160))) {
        goto LABEL_38;
      }
      int v19 = *(_DWORD *)(a1 + 224);
      int v18 = *(_DWORD *)(a1 + 228);
      if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160))) {
        goto LABEL_38;
      }
      if ((v19 - 1) <= 1) {
        break;
      }
    }
    BOMBufferPoolReturnBuffer(gBufferPool, (uint64_t)v13);
    *(void *)(a1 + 96) = 0;
LABEL_37:
    v4 += v15;
    v3 -= v15;
    if (!v3) {
      goto LABEL_38;
    }
  }
  if (v18)
  {
    *__error() = v18;
    return -1;
  }
LABEL_38:
  *(void *)(a1 + 16) += v10;
  return v10;
}

unint64_t BOMFileWrite(uint64_t a1, UInt8 *buffer, unint64_t bufferLength)
{
  if (!a1) {
    return -1;
  }
  unint64_t v3 = bufferLength;
  uint64_t v4 = buffer;
  if ((*(_DWORD *)a1 - 1) < 2)
  {
    if (!bufferLength) {
      return 0;
    }
    if (!buffer) {
      return -1;
    }
    int v6 = *(_DWORD *)(a1 + 24);
    if ((v6 - 3) >= 2)
    {
      if (v6 == 1)
      {
        int v21 = *(z_stream **)(a1 + 32);
        v21->next_in = buffer;
        v21->avail_in = bufferLength;
        if (bufferLength)
        {
          uInt avail_out = v21->avail_out;
          if (avail_out) {
            goto LABEL_44;
          }
          while (1)
          {
            CFIndex v24 = 0x20000 - avail_out;
            unint64_t v25 = *(UInt8 **)(a1 + 40);
            uint64_t v8 = -1;
            while (v24)
            {
              uint64_t v26 = _BOMFileWriteRaw(a1, v25, v24);
              v25 += v26;
              v24 -= v26;
              if (v26 < 0) {
                return v8;
              }
            }
            v21->uInt avail_out = 0x20000;
            v21->next_out = *(Bytef **)(a1 + 40);
            if (!v21->avail_in) {
              break;
            }
LABEL_44:
            if (deflate(v21, 0)) {
              return -1;
            }
            uInt avail_out = v21->avail_out;
          }
        }
        *(void *)(a1 + 48) = crc32(*(void *)(a1 + 48), v4, v3);
        return v3;
      }
      else
      {
        if (v6) {
          return -1;
        }
        uint64_t v7 = 0;
        uint64_t v8 = -1;
        while (v3)
        {
          uint64_t v9 = _BOMFileWriteRaw(a1, v4, v3);
          v7 += v9;
          v3 -= v9;
          if (v9 < 0) {
            return v8;
          }
        }
        return v7;
      }
    }
    size_t v17 = *(compression_stream **)(a1 + 32);
    uint64_t v16 = *(uint8_t **)(a1 + 40);
    v17->src_ptr = buffer;
    v17->size_t src_size = bufferLength;
    v17->dst_ptr = v16;
    v17->size_t dst_size = 0x20000;
    while (compression_stream_process(v17, 0) != COMPRESSION_STATUS_ERROR)
    {
      CFIndex v18 = 0x20000 - v17->dst_size;
      int v19 = *(UInt8 **)(a1 + 40);
      while (v18)
      {
        uint64_t v20 = _BOMFileWriteRaw(a1, v19, v18);
        v19 += v20;
        v18 -= v20;
        if (v20 < 0) {
          return -1;
        }
      }
      v17->dst_ptr = *(uint8_t **)(a1 + 40);
      v17->size_t dst_size = 0x20000;
      if (!v17->src_size) {
        return v3;
      }
    }
    return -1;
  }
  if (*(_DWORD *)a1 != 5) {
    return -1;
  }
  uint64_t v8 = 0;
  if (!bufferLength) {
    goto LABEL_26;
  }
  while (1)
  {
    uint64_t v10 = *(void **)(a1 + 96);
    if (v10)
    {
      uint64_t v11 = v10[1];
    }
    else
    {
      uint64_t v10 = BOMBufferPoolRequestBuffer(gBufferPool);
      uint64_t v11 = 0;
      v10[1] = 0;
      Point v10[2] = 0;
      *(void *)(a1 + 96) = v10;
    }
    if (v3 >= *v10 - v11) {
      size_t v12 = *v10 - v11;
    }
    else {
      size_t v12 = v3;
    }
    memcpy((void *)(v10[3] + v11), v4, v12);
    int64x2_t v13 = vaddq_s64(*(int64x2_t *)(v10 + 1), vdupq_n_s64(v12));
    *(int64x2_t *)(v10 + 1) = v13;
    v8 += v12;
    if (*v10 != v13.i64[0]) {
      goto LABEL_25;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 160))) {
      goto LABEL_26;
    }
    int v15 = *(_DWORD *)(a1 + 224);
    int v14 = *(_DWORD *)(a1 + 228);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160))) {
      goto LABEL_26;
    }
    if ((v15 - 1) <= 1) {
      break;
    }
    BOMBufferFIFOEnqueue(*(void *)(a1 + 88), (uint64_t)v10);
    *(void *)(a1 + 96) = 0;
LABEL_25:
    v4 += v12;
    v3 -= v12;
    if (!v3) {
      goto LABEL_26;
    }
  }
  if (v14)
  {
    *__error() = v14;
    return -1;
  }
LABEL_26:
  *(void *)(a1 + 16) += v8;
  return v8;
}

uint64_t _BOMFileReadRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 3)
    {
      CFIndex v7 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1)
    {
      CFIndex v7 = -1;
    }
    else
    {
      CFIndex v7 = (*(uint64_t (**)(void, void, UInt8 *, CFIndex))(*(void *)(a1 + 240) + 40))(*(void *)(*(void *)(a1 + 240) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    uint64_t v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1) {
      break;
    }
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(void *)(a1 + 16) += v6;
  if (v7 < 0) {
    return -1;
  }
  else {
    return v6;
  }
}

uint64_t _BOMFileSetupGzip(uint64_t a1, int a2)
{
  char v5 = (z_streamp *)(a1 + 32);
  uint64_t v4 = *(z_stream **)(a1 + 32);
  if (!v4)
  {
    uint64_t v4 = (z_stream *)BOM_malloc(0x70uLL);
    z_streamp *v5 = v4;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v6 = *(Bytef **)(a1 + 40);
  if (!v6)
  {
    uint64_t v6 = (Bytef *)BOM_malloc(0x20000uLL);
    *(void *)(a1 + 40) = v6;
    uint64_t v4 = *(z_stream **)(a1 + 32);
    if (!v6)
    {
      free(*(void **)(a1 + 32));
      goto LABEL_14;
    }
  }
  v4->zalloc = 0;
  (*v5)->zfree = 0;
  (*v5)->opaque = 0;
  CFIndex v7 = *v5;
  if (a2)
  {
    *CFIndex v7 = 0;
    (*v5)->next_out = v6;
    (*v5)->avail_in = 0;
    (*v5)->uInt avail_out = 0x20000;
    if (deflateInit2_(*v5, -1, 8, -15, 8, 0, "1.2.12", 112))
    {
LABEL_7:
      free(*(void **)(a1 + 32));
      free(*(void **)(a1 + 40));
      v5[1] = 0;
LABEL_14:
      z_streamp *v5 = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *CFIndex v7 = v6;
    size_t v8 = *(void *)(a1 + 64);
    if (v8)
    {
      if (*(_DWORD *)(a1 + 72)) {
        uint64_t v9 = (Bytef *)(a1 + 76);
      }
      else {
        uint64_t v9 = v6;
      }
      memcpy(**(void ***)(a1 + 32), v9, v8);
      *(_DWORD *)(*(void *)(a1 + 32) + 8) = *(void *)(a1 + 64);
      *(void *)(a1 + 64) = 0;
    }
    else
    {
      (*v5)->avail_in = 0;
    }
    (*v5)->next_out = 0;
    (*v5)->uInt avail_out = 0;
    if (inflateInit2_(*v5, 47, "1.2.12", 112)) {
      goto LABEL_7;
    }
  }
  uLong v11 = crc32(0, 0, 0);
  uint64_t result = 0;
  *(void *)(a1 + 48) = v11;
  *(unsigned char *)(a1 + 56) = 0;
  return result;
}

uint64_t _BOMFileCompressionLibrary_Setup(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v4 = BOM_malloc(0x28uLL);
    *(void *)(a1 + 32) = v4;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
  }
  if (!*(void *)(a1 + 40))
  {
    char v5 = BOM_malloc(0x20000uLL);
    *(void *)(a1 + 40) = v5;
    if (!v5) {
      goto LABEL_12;
    }
  }
  int v6 = *(_DWORD *)(a1 + 24);
  switch(v6)
  {
    case 1:
      compression_algorithm v7 = COMPRESSION_ZLIB;
      break;
    case 4:
      compression_algorithm v7 = COMPRESSION_LZFSE;
      break;
    case 3:
      compression_algorithm v7 = 2304;
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  if (compression_stream_init(*(compression_stream **)(a1 + 32), (compression_stream_operation)(a2 == 0), v7))
  {
LABEL_12:
    free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    return 0xFFFFFFFFLL;
  }
  uLong v9 = crc32(0, 0, 0);
  uint64_t result = 0;
  *(void *)(a1 + 48) = v9;
  *(unsigned char *)(a1 + 56) = 0;
  return result;
}

uint64_t _BOMFileWriteRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 2)
    {
      CFIndex v7 = CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1 == 1)
    {
      CFIndex v7 = (*(uint64_t (**)(void, void, UInt8 *, CFIndex))(*(void *)(a1 + 240) + 48))(*(void *)(*(void *)(a1 + 240) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    else
    {
      CFIndex v7 = -1;
    }
    uint64_t v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1) {
      break;
    }
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(void *)(a1 + 16) += v6;
  if (v7 < 0) {
    return -1;
  }
  else {
    return v6;
  }
}

void *_initBufferPool()
{
  uint64_t result = BOMBufferPoolAllocate(gBOMAsyncBufferSize, gBOMAsyncBufferCount);
  if (!result)
  {
    uint64_t v8 = BOMExceptionHandlerMessage("Unable to allocate BOM buffer pool gBOMAsyncBufferSize=%lu gBOMAsyncBufferCount=%u!\n", v1, v2, v3, v4, v5, v6, v7, gBOMAsyncBufferSize);
    uLong v9 = __error();
    _BOMFatalException(v8, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMFile.c", 1744, *v9);
  }
  gBufferPool = (uint64_t)result;
  return result;
}

uint64_t _asyncWriteThread(uint64_t a1)
{
  if (gBOMAsyncDebug == 1) {
    fwrite("async write thread starting\n", 0x1CuLL, 1uLL, __stderrp);
  }
  int v2 = 0;
  do
  {
    uint64_t v3 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 88));
    unint64_t v4 = BOMFileWrite(*(void *)(a1 + 8), *(UInt8 **)(v3 + 24), *(void *)(v3 + 16));
    int v5 = *(_DWORD *)(v3 + 48);
    if ((v5 & 1) != 0 && gBOMAsyncDebug == 1) {
      fwrite("async write thread asked to finish\n", 0x23uLL, 1uLL, __stderrp);
    }
    if (v4 == -1)
    {
      if (gBOMAsyncDebug == 1)
      {
        uint64_t v7 = __stderrp;
        uint64_t v8 = __error();
        fprintf(v7, "async write thread finished file (errno=%d)\n", *v8);
      }
      int v2 = *__error();
      int v6 = 1;
    }
    else
    {
      int v6 = v5 & 1;
    }
    ++*(void *)(v3 + 40);
    BOMBufferPoolReturnBuffer(gBufferPool, v3);
  }
  while (!v6);
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
  {
    *(_DWORD *)(a1 + 224) = 2;
    *(_DWORD *)(a1 + 228) = v2;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 112))
      && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160))
      && gBOMAsyncDebug == 1)
    {
      fwrite("async write thread terminating\n", 0x1FuLL, 1uLL, __stderrp);
    }
  }
  return 0;
}

uint64_t _asyncReadThread(uint64_t a1)
{
  if (gBOMAsyncDebug == 1) {
    fwrite("async read thread starting\n", 0x1BuLL, 1uLL, __stderrp);
  }
  for (uint64_t i = BOMBufferPoolRequestBuffer(gBufferPool); ; uint64_t i = BOMBufferPoolRequestBuffer(gBufferPool))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 160))
      || (int v3 = *(_DWORD *)(a1 + 224), pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160))))
    {
      int v5 = 0;
      goto LABEL_20;
    }
    if (v3 == 1)
    {
      if (gBOMAsyncDebug == 1)
      {
        fwrite("async read thread asked to finish\n", 0x22uLL, 1uLL, __stderrp);
LABEL_13:
        if (gBOMAsyncDebug == 1) {
          fwrite("async read thread finished file\n", 0x20uLL, 1uLL, __stderrp);
        }
      }
      int v5 = 0;
      goto LABEL_19;
    }
    size_t v4 = BOMFileRead(*(void *)(a1 + 8), (UInt8 *)i[3], *i);
    if (v4 == -1) {
      break;
    }
    if (!v4) {
      goto LABEL_13;
    }
    i[1] = 0;
    i[2] = v4;
    ++i[5];
    BOMBufferFIFOEnqueue(*(void *)(a1 + 88), (uint64_t)i);
  }
  if (gBOMAsyncDebug == 1)
  {
    int v6 = __stderrp;
    uint64_t v7 = __error();
    fprintf(v6, "async read thread finished file (errno=%d)\n", *v7);
  }
  int v5 = *__error();
LABEL_19:
  i[1] = 0;
  i[2] = 0;
  ++i[5];
LABEL_20:
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 160)))
  {
    *(_DWORD *)(a1 + 224) = 2;
    *(_DWORD *)(a1 + 228) = v5;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 112)) && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 160)))
    {
      if (i) {
        BOMBufferFIFOEnqueue(*(void *)(a1 + 88), (uint64_t)i);
      }
      if (gBOMAsyncDebug == 1) {
        fwrite("async read thread terminating\n", 0x1EuLL, 1uLL, __stderrp);
      }
    }
  }
  return 0;
}

void **BOMStackNew()
{
  pthread_key_t v0 = (void **)BOM_calloc(1uLL, 0x18uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    v0[1] = (void *)1024;
    int v2 = BOM_malloczero(0x2000uLL);
    *uint64_t v1 = v2;
    if (!v2)
    {
      BOMStackFree(v1);
      uLong v11 = BOMExceptionHandlerMessage("Allocating BOMStack failed", v4, v5, v6, v7, v8, v9, v10, v13);
      size_t v12 = __error();
      _BOMFatalException(v11, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMStack.c", 38, *v12);
    }
  }
  return v1;
}

void BOMStackFree(void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

uint64_t *BOMStackPop(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = *result;
    if (*result && (uint64_t v2 = result[2]) != 0)
    {
      uint64_t v3 = v2 - 1;
      result[2] = v3;
      uint64_t result = *(uint64_t **)(v1 + 8 * v3);
      *(void *)(v1 + 8 * v3) = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *BOMStackPeek(void *result)
{
  if (result)
  {
    if (*result && (uint64_t v1 = result[2]) != 0) {
      return *(void **)(*result + 8 * v1 - 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

char *BOMStackPush(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    uint64_t result = *(char **)result;
    if (result)
    {
      unint64_t v11 = v8[1];
      uint64_t v10 = v8[2];
      uint64_t v12 = v10 + 1;
      if (v10 + 1 >= v11)
      {
        if (v11 == 0xFFFFFFF)
        {
          int v21 = BOMExceptionHandlerMessage("BOMStack is full can't grow anymore", a2, a3, a4, a5, a6, a7, a8, v25);
          BOOL v22 = __error();
          _BOMFatalException(v21, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMStack.c", 103, *v22);
        }
        uint64_t v13 = 2 * v11;
        if (2 * v11 >= 0xFFFFFFF) {
          uint64_t v13 = 0xFFFFFFFLL;
        }
        v8[1] = v13;
        uint64_t result = BOM_realloczero(result, 8 * v11, 8 * v13);
        *uint64_t v8 = result;
        if (!result)
        {
          uint64_t v23 = BOMExceptionHandlerMessage("BOMStack got blown", v14, v15, v16, v17, v18, v19, v20, v25);
          CFIndex v24 = __error();
          _BOMFatalException(v23, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMStack.c", 122, *v24);
        }
        uint64_t v10 = v8[2];
        uint64_t v12 = v10 + 1;
      }
      void v8[2] = v12;
      *(void *)&result[8 * v10] = a2;
    }
  }
  return result;
}

BOOL BOMStackIsEmpty(uint64_t a1)
{
  return !a1 || !*(void *)a1 || *(_DWORD *)(a1 + 16) < 1;
}

uint64_t BomSys_init(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = BOM_malloc(0x80uLL);
  uint64_t result = 0;
  long long v6 = *(_OWORD *)&off_1EF487930;
  v4[4] = xmmword_1EF487920;
  v4[5] = v6;
  long long v7 = *(_OWORD *)&off_1EF487950;
  void v4[6] = xmmword_1EF487940;
  v4[7] = v7;
  long long v8 = *(_OWORD *)&off_1EF4878F0;
  *uint64_t v4 = gDefaultSys;
  v4[1] = v8;
  long long v9 = *(_OWORD *)&off_1EF487910;
  v4[2] = xmmword_1EF487900;
  v4[3] = v9;
  *((void *)v4 + 1) = a2;
  *a1 = v4;
  return result;
}

void BomSys_free(void *a1)
{
  if (a1 != &gDefaultNOMMAPSys && a1 != 0 && a1 != &gDefaultSys) {
    free(a1);
  }
}

void BomSys_set_close(long long *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = a1 == (long long *)&gDefaultNOMMAPSys || a1 == 0 || a1 == &gDefaultSys;
  if (v9 || *(void *)a1)
  {
    _CUILog(4, (uint64_t)"%s ignoring call to alter shared Sys", a3, a4, a5, a6, a7, a8, (uint64_t)"void BomSys_set_close(BomSys *, BomSys_close_call)");
  }
  else if (a2)
  {
    *((void *)a1 + 3) = a2;
  }
  else
  {
    *((void *)a1 + 3) = BomSys_close;
  }
}

uint64_t BomSys_fcntl(int a1, int a2, int a3, uint64_t a4)
{
  return fcntl(a2, a3, a4);
}

void BomSys_set_read(long long *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = a1 == (long long *)&gDefaultNOMMAPSys || a1 == 0 || a1 == &gDefaultSys;
  if (v9 || *(void *)a1)
  {
    _CUILog(4, (uint64_t)"%s ignoring call to alter shared Sys", a3, a4, a5, a6, a7, a8, (uint64_t)"void BomSys_set_read(BomSys *, BomSys_read_call)");
  }
  else if (a2)
  {
    *((void *)a1 + 5) = a2;
  }
  else
  {
    *((void *)a1 + 5) = BomSys_read;
  }
}

void BomSys_set_write(long long *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = a1 == (long long *)&gDefaultNOMMAPSys || a1 == 0 || a1 == &gDefaultSys;
  if (v9 || *(void *)a1)
  {
    _CUILog(4, (uint64_t)"%s ignoring call to alter shared Sys", a3, a4, a5, a6, a7, a8, (uint64_t)"void BomSys_set_write(BomSys *, BomSys_write_call)");
  }
  else if (a2)
  {
    *((void *)a1 + 6) = a2;
  }
  else
  {
    *((void *)a1 + 6) = BomSys_write;
  }
}

ssize_t BomSys_write(int a1, int __fd, void *__buf, size_t __nbyte)
{
  return write(__fd, __buf, __nbyte);
}

uint64_t BomSys_fsync(int a1, int a2)
{
  return fsync(a2);
}

uint64_t BomSys_fstatfs(int a1, int a2, statfs *a3)
{
  return fstatfs(a2, a3);
}

void BomSys_rename(int a1, std::__fs::filesystem::path *__from, std::__fs::filesystem::path *__to)
{
}

void *BomSys_defaultNoMMAP()
{
  return &gDefaultNOMMAPSys;
}

uint64_t BomSys_fchmod(int a1, int a2, mode_t a3)
{
  return fchmod(a2, a3);
}

uint64_t BomSys_fchown(int a1, int a2, uid_t a3, gid_t a4)
{
  return fchown(a2, a3, a4);
}

void *BOM_realloc(void *a1, size_t a2)
{
  char v2 = a2;
  uint64_t v3 = reallocf(a1, a2);
  if (v3)
  {
    __CFSetLastAllocationEventName();
  }
  else
  {
    uint64_t v4 = __error();
    strerror(*v4);
    uint64_t v12 = BOMExceptionHandlerMessage("BOM_realloc: (%zd bytes) %s\n", v5, v6, v7, v8, v9, v10, v11, v2);
    uint64_t v13 = __error();
    _BOMExceptionHandlerCall(v12, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 70, *v13);
  }
  return v3;
}

char *BOM_realloczero(void *a1, unint64_t a2, size_t __size)
{
  uint64_t v5 = (char *)reallocf(a1, __size);
  if (v5)
  {
    __CFSetLastAllocationEventName();
    if (__size > a2) {
      bzero(&v5[a2], __size - a2);
    }
  }
  else
  {
    uint64_t v6 = __error();
    strerror(*v6);
    uint64_t v14 = BOMExceptionHandlerMessage("BOM_realloczero: (%zd bytes) %s\n", v7, v8, v9, v10, v11, v12, v13, __size);
    uint64_t v15 = __error();
    _BOMExceptionHandlerCall(v14, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Common/BOMSystemCmds.c", 85, *v15);
  }
  return v5;
}

uint64_t _dense_initialize(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  if ((a3 & 7) == 0 && (int)(a3 >> 3) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = (a3 >> 3);
    uint64_t v7 = (unsigned int *)(a2 + 4);
    do
    {
      unsigned int v8 = *(v7 - 1);
      unsigned int v9 = bswap32(v8);
      unsigned int v10 = bswap32(*v7);
      if (a4) {
        uint64_t v11 = v9;
      }
      else {
        uint64_t v11 = v8;
      }
      if (a4) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = *v7;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 + 40))(v5, v11, v12);
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  return result;
}

_DWORD *_dense_serialize(uint64_t **a1, int a2, size_t *a3)
{
  uint64_t v4 = *a1;
  size_t v5 = 8 * *((int *)a1 + 2);
  *a3 = v5;
  uint64_t result = BOM_malloc(v5);
  if (result)
  {
    int v7 = *((_DWORD *)v4 + 4);
    if (v7 < 1)
    {
      int v9 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 0;
      uint64_t v10 = *v4;
      do
      {
        uint64_t v11 = *(uint64_t **)(v10 + 8 * v8);
        if (v11)
        {
          int v12 = 2 * v9;
          do
          {
            unsigned int v13 = *((_DWORD *)v11 + 2);
            unsigned int v14 = *((_DWORD *)v11 + 3);
            unsigned int v15 = bswap32(v13);
            unsigned int v16 = bswap32(v14);
            if (a2)
            {
              unsigned int v13 = v15;
              unsigned int v14 = v16;
            }
            result[v12] = v13;
            result[v12 + 1] = v14;
            uint64_t v11 = (uint64_t *)*v11;
            v12 += 2;
            ++v9;
          }
          while (v11);
          int v7 = *((_DWORD *)v4 + 4);
        }
        ++v8;
      }
      while (v8 < v7);
    }
    uint64_t v17 = (uint64_t *)v4[1];
    if (v17)
    {
      int v18 = 2 * v9;
      do
      {
        unsigned int v19 = *((_DWORD *)v17 + 2);
        unsigned int v20 = *((_DWORD *)v17 + 3);
        unsigned int v21 = bswap32(v19);
        unsigned int v22 = bswap32(v20);
        if (a2) {
          unsigned int v19 = v21;
        }
        result[v18] = v19;
        if (a2) {
          unsigned int v23 = v22;
        }
        else {
          unsigned int v23 = v20;
        }
        result[v18 + 1] = v23;
        uint64_t v17 = (uint64_t *)*v17;
        v18 += 2;
      }
      while (v17);
    }
  }
  return result;
}

_DWORD *_dense_addFreeRange(_DWORD *result, int a2, unint64_t a3)
{
  if (a3)
  {
    size_t v5 = result;
    uint64_t v6 = *(void *)result;
    if (a3 < 0x10000)
    {
      unint64_t v8 = *(int *)(v6 + 16);
      if (v8 <= a3)
      {
        int v9 = a3 + 1;
        uint64_t v10 = (char *)BOM_realloc(*(void **)v6, (8 * (a3 + 1)));
        *(void *)uint64_t v6 = v10;
        if ((int)v8 <= (int)a3) {
          bzero(&v10[8 * *(int *)(v6 + 16)], 8 * (v9 - (int)v8));
        }
        *(_DWORD *)(v6 + 16) = v9;
        uint64_t v6 = *(void *)v5;
      }
      uint64_t v11 = *(void *)(*(void *)v6 + 8 * a3);
      uint64_t result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(void *)uint64_t result = v11;
      *(void *)(*(void *)v6 + 8 * a3) = result;
    }
    else
    {
      uint64_t v7 = *(void *)(v6 + 8);
      uint64_t result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(void *)uint64_t result = v7;
      *(void *)(v6 + 8) = result;
    }
    ++v5[2];
  }
  return result;
}

uint64_t _dense_allocateRange(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = *(int *)(*(void *)a1 + 16);
  if (v5 > a2)
  {
    uint64_t v6 = *(unsigned int **)(*v4 + 8 * a2);
    if (v6)
    {
      uint64_t v7 = v6[2];
      uint64_t v8 = *(void *)v6;
      free(v6);
      *(void *)(*v4 + 8 * a2) = v8;
      --*(_DWORD *)(a1 + 8);
      return v7;
    }
  }
  LODWORD(v9) = 0;
  while (1)
  {
    uint64_t v10 = (a2 + 1 + v9);
    if (v10 >= v5) {
      break;
    }
    uint64_t v11 = *(unsigned int **)(*v4 + 8 * v10);
    uint64_t v9 = (v9 + 1);
    if (v11)
    {
      uint64_t v7 = v11[2];
      uint64_t v12 = *(void *)v11;
      free(v11);
      *(void *)(*v4 + 8 * v10) = v12;
      --*(_DWORD *)(a1 + 8);
      (*(void (**)(uint64_t, void, uint64_t))(a1 + 40))(a1, (v7 + a2), v9);
      return v7;
    }
  }
  unsigned int v15 = (void **)v4[1];
  unsigned int v14 = v4 + 1;
  unsigned int v13 = v15;
  if (!v15) {
    return 0;
  }
  unint64_t v16 = *((unsigned int *)v13 + 3);
  if (v16 < a2)
  {
    while (1)
    {
      uint64_t v17 = v13;
      unsigned int v13 = (void **)*v13;
      if (!v13) {
        return 0;
      }
      unint64_t v16 = *((unsigned int *)v13 + 3);
      if (v16 >= a2) {
        goto LABEL_15;
      }
    }
  }
  uint64_t v17 = 0;
LABEL_15:
  int v18 = (void **)*v13;
  uint64_t v7 = *((unsigned int *)v13 + 2);
  uint64_t v19 = (v7 + a2);
  uint64_t v20 = (v16 - a2);
  free(v13);
  if (v17) {
    unsigned int v21 = v17;
  }
  else {
    unsigned int v21 = v14;
  }
  *unsigned int v21 = v18;
  --*(_DWORD *)(a1 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v19, v20);
  return v7;
}

uint64_t _dense_print(uint64_t result, FILE *__stream, int a3)
{
  uint64_t v5 = *(void *)result;
  int v6 = *(_DWORD *)(*(void *)result + 16);
  if (v6 >= 1)
  {
    for (uint64_t i = 0; i < v6; ++i)
    {
      uint64_t v8 = *(void **)(*(void *)v5 + 8 * i);
      if (v8)
      {
        int v9 = 0;
        do
        {
          ++v9;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
        if (v9 == 1) {
          uint64_t v10 = "y";
        }
        else {
          uint64_t v10 = "ies";
        }
        uint64_t result = fprintf(__stream, "Size %d: %d entr%s\n", i, v9, v10);
        int v6 = *(_DWORD *)(v5 + 16);
      }
    }
  }
  uint64_t v11 = *(uint64_t **)(v5 + 8);
  if (v11)
  {
    if (a3) {
      fwrite("Large sizes:\n\t", 0xEuLL, 1uLL, __stream);
    }
    int v12 = 1;
    if (!a3) {
      goto LABEL_17;
    }
    while (1)
    {
      fprintf(__stream, "%d ", *((_DWORD *)v11 + 3));
      uint64_t v11 = (uint64_t *)*v11;
      if (!v11) {
        break;
      }
      while (1)
      {
        ++v12;
        if (a3) {
          break;
        }
LABEL_17:
        uint64_t v11 = (uint64_t *)*v11;
        if (!v11)
        {
          unsigned int v13 = "ies";
          if (v12 == 1) {
            unsigned int v13 = "y";
          }
          return fprintf(__stream, "Large sizes: %d entr%s\n", v12, v13);
        }
      }
    }
    return fputc(10, __stream);
  }
  return result;
}

uint64_t BOMStorageNewWithOptionsAndSys(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v3 = a3;
  if (!a3) {
    uint64_t v3 = BomSys_default();
  }
  uint64_t v5 = (*((uint64_t (**)(void, uint64_t, uint64_t, uint64_t))v3 + 2))(*((void *)v3 + 1), a1, 1538, 420);
  if (v5 == -1)
  {
    uint64_t v8 = __error();
    strerror(*v8);
    _CUILog(4, (uint64_t)"%s can't open: '%s' %s", v9, v10, v11, v12, v13, v14, (uint64_t)"BOMStorage BOMStorageNewWithOptionsAndSys(const char *, CFDictionaryRef, BomSys *)");
  }
  else
  {
    uint64_t v6 = v5;
    bzero(v15, 0x470uLL);
    int v16 = v6;
    uint64_t v17 = v3;
    if (!_WriteRootPage((uint64_t)v15))
    {
      (*((void (**)(void, uint64_t))v3 + 3))(*((void *)v3 + 1), v6);
      return BOMStorageOpenWithSys(a1, 1, v3);
    }
  }
  return 0;
}

uint64_t _WriteRootPage(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = *(void *)(a1 + 1120);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t v3 = 1;
  uint64_t v4 = BOMStreamWithFileAndSys(*(_DWORD *)(a1 + 1028), 0, 0x200uLL, 1, 0, (long long *)v2);
  if (v4)
  {
    uint64_t v11 = (uint64_t (*)(void *))v4;
    BOMStreamWriteUInt32((uint64_t (*)(void *))v4, 1112493395, v5, v6, v7, v8, v9, v10);
    BOMStreamWriteUInt32(v11, 1953460837, v12, v13, v14, v15, v16, v17);
    BOMStreamWriteUInt32(v11, 1, v18, v19, v20, v21, v22, v23);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1056), v24, v25, v26, v27, v28, v29);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1060), v30, v31, v32, v33, v34, v35);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1064), v36, v37, v38, v39, v40, v41);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1096), v42, v43, v44, v45, v46, v47);
    BOMStreamWriteUInt32(v11, *(unsigned int *)(a1 + 1100), v48, v49, v50, v51, v52, v53);
    uint64_t v3 = BOMStreamFree((uint64_t)v11, v54, v55, v56, v57, v58, v59, v60);
    if ((*(unsigned int (**)(void, void))(v2 + 64))(*(void *)(v2 + 8), *(unsigned int *)(a1 + 1028)))
    {
      uint64_t v61 = __error();
      strerror(*v61);
      _CUILog(4, (uint64_t)"%s fsync: '%s'", v62, v63, v64, v65, v66, v67, (uint64_t)"int _WriteRootPage(BOMStorage)");
      return 1;
    }
  }
  return v3;
}

void _CreateMapAddress(uint64_t a1, unsigned int a2)
{
  vm_size_t v3 = a2 % vm_page_size;
  if (v3) {
    int v4 = vm_page_size - v3;
  }
  else {
    int v4 = 0;
  }
  uint64_t v5 = v4 + a2;
  uint64_t v6 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 1120)
                                                                                             + 96))(*(void *)(*(void *)(a1 + 1120) + 8), 0, v5, 3, 4098, 0xFFFFFFFFLL, 0);
  *(void *)(a1 + 1040) = v6;
  if (v6 == -1)
  {
    uint64_t v7 = __error();
    strerror(*v7);
    _CUILog(4, (uint64_t)"%s can't mmap memory of size '%d' error: '%s'", v8, v9, v10, v11, v12, v13, (uint64_t)"int _CreateMapAddress(BOMStorage, unsigned int)");
    *(void *)(a1 + 1040) = 0;
  }
  *(_DWORD *)(a1 + 1048) = v5;
}

void *BOMStorageOpenInRAM(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= 0x1FF)
  {
    uint64_t v8 = BOMExceptionHandlerMessage("stream invalid; root page is outside of address range",
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           v161);
    int v9 = *__error();
    uint64_t v10 = v8;
    int v11 = 486;
    goto LABEL_14;
  }
  char v12 = a3;
  int v13 = a2;
  uint64_t v15 = BOMStreamWithAddress(a1, 512, 0);
  if (!v15)
  {
    double v105 = BOMExceptionHandlerMessage("can't read from memory %p", v16, v17, v18, v19, v20, v21, v22, a1);
    int v9 = *__error();
    uint64_t v10 = v105;
    int v11 = 494;
    goto LABEL_14;
  }
  uint64_t v23 = v15;
  if (BOMStreamReadUInt32(v15, v16, v17, v18, v19, v20, v21, v22) == 1112493395
    && BOMStreamReadUInt32(v23, v24, v25, v26, v27, v28, v29, v30) == 1953460837)
  {
    int UInt32 = BOMStreamReadUInt32(v23, v24, v25, v26, v27, v28, v29, v30);
    if (UInt32 == 1)
    {
      uint64_t v39 = BOM_malloczero(0x470uLL);
      if (!v39)
      {
        unsigned int v108 = __error();
        strerror(*v108);
        _CUILog(4, (uint64_t)"%s: malloc: %s", v109, v110, v111, v112, v113, v114, (uint64_t)"BOMStorage BOMStorageOpenInRAM(void *, size_t, Boolean)");
        BOMStreamFree(v23, v115, v116, v117, v118, v119, v120, v121);
        return v39;
      }
      v39[140] = BomSys_default();
      *((_DWORD *)v39 + 257) = -1;
      *((_DWORD *)v39 + 258) = v13;
      *((_DWORD *)v39 + 259) = v13;
      *((_DWORD *)v39 + 263) = *((_DWORD *)v39 + 263) & 0xFFFFFFF6 | v12 & 1;
      *((_DWORD *)v39 + 264) = BOMStreamReadUInt32(v23, v40, v41, v42, v43, v44, v45, v46);
      *((_DWORD *)v39 + 265) = BOMStreamReadUInt32(v23, v47, v48, v49, v50, v51, v52, v53);
      *((_DWORD *)v39 + 266) = BOMStreamReadUInt32(v23, v54, v55, v56, v57, v58, v59, v60);
      *((_DWORD *)v39 + 274) = BOMStreamReadUInt32(v23, v61, v62, v63, v64, v65, v66, v67);
      *((_DWORD *)v39 + 275) = BOMStreamReadUInt32(v23, v68, v69, v70, v71, v72, v73, v74);
      *((_DWORD *)v39 + 263) |= 6u;
      BOMStreamFree(v23, v75, v76, v77, v78, v79, v80, v81);
      int v89 = *((_DWORD *)v39 + 265);
      int v90 = *((_DWORD *)v39 + 266);
      BOOL v91 = __CFADD__(v90, v89);
      unsigned int v92 = v90 + v89;
      if (v91)
      {
        double v93 = BOMExceptionHandlerMessage(" <memory>: stream invalid; overflow of admin offset+size",
                v82,
                v83,
                v84,
                v85,
                v86,
                v87,
                v88,
                v161);
        int v9 = *__error();
        uint64_t v10 = v93;
        int v11 = 549;
      }
      else
      {
        unsigned int v122 = *((_DWORD *)v39 + 258);
        if (v92 <= v122)
        {
          int v124 = *((_DWORD *)v39 + 274);
          int v125 = *((_DWORD *)v39 + 275);
          BOOL v91 = __CFADD__(v125, v124);
          unsigned int v126 = v125 + v124;
          if (v91)
          {
            uint64_t v127 = BOMExceptionHandlerMessage("<memory>: stream invalid; overflow of toc offset+size",
                     v82,
                     v83,
                     v84,
                     v85,
                     v86,
                     v87,
                     v88,
                     v161);
            int v9 = *__error();
            uint64_t v10 = v127;
            int v11 = 561;
          }
          else
          {
            if (v126 <= v122)
            {
              *((_DWORD *)v39 + 262) = v122;
              v39[130] = a1;
              _CreateBlockTable(v39);
              uint64_t v129 = *((unsigned int *)v39 + 265);
              if (v129)
              {
                uint64_t v130 = BOMStreamWithAddress(v39[130] + v129, *((unsigned int *)v39 + 266), 0);
                if (!v130)
                {
                  uint64_t v151 = __error();
                  char v152 = strerror(*v151);
                  CGFloat v160 = BOMExceptionHandlerMessage("can't read from <memory>: %s", v153, v154, v155, v156, v157, v158, v159, v152);
                  int v9 = *__error();
                  uint64_t v10 = v160;
                  int v11 = 585;
                  goto LABEL_14;
                }
                uint64_t v137 = v130;
                if (_ReadBlockTable((uint64_t)v39, v130, v131, v132, v133, v134, v135, v136)
                  || _ReadFreeList((uint64_t)v39, v137, v138, v139, v140, v141, v142, v143))
                {
                  return 0;
                }
                BOMStreamFree(v137, v144, v145, v146, v147, v148, v149, v150);
              }
              else
              {
                v39[136] = _BOMFreeListAllocate();
              }
              __strlcpy_chk();
              return v39;
            }
            double v128 = BOMExceptionHandlerMessage("<memory>: stream invalid; toc range is outside file",
                     v82,
                     v83,
                     v84,
                     v85,
                     v86,
                     v87,
                     v88,
                     v161);
            int v9 = *__error();
            uint64_t v10 = v128;
            int v11 = 567;
          }
        }
        else
        {
          CGFloat v123 = BOMExceptionHandlerMessage("<memory>: stream invalid; admin range is outside of file",
                   v82,
                   v83,
                   v84,
                   v85,
                   v86,
                   v87,
                   v88,
                   v161);
          int v9 = *__error();
          uint64_t v10 = v123;
          int v11 = 555;
        }
      }
LABEL_14:
      _BOMExceptionHandlerCall(v10, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v11, v9);
      return 0;
    }
    uint64_t v107 = BOMExceptionHandlerMessage("<memory> has an unknown version: 0x%X", v32, v33, v34, v35, v36, v37, v38, UInt32);
    int v95 = *__error();
    uint64_t v96 = v107;
    int v97 = 514;
  }
  else
  {
    CGFloat v94 = BOMExceptionHandlerMessage("%s is not a BOMStorage file", v24, v25, v26, v27, v28, v29, v30, (char)"<memory>");
    int v95 = *__error();
    uint64_t v96 = v94;
    int v97 = 501;
  }
  _BOMExceptionHandlerCall(v96, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v97, v95);
  BOMStreamFree(v23, v98, v99, v100, v101, v102, v103, v104);
  return 0;
}

uint64_t BOMStorageCommit(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  int v2 = *(_DWORD *)(a1 + 1052);
  if ((v2 & 0x10) == 0) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    BOOL v3 = 0;
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    goto LABEL_8;
  }
  _FlushWriteCache(a1);
  if (_AdjustFileSize(a1, 0, 0)) {
    return 1;
  }
  uint64_t v5 = *(void *)(a1 + 1088);
  int v6 = 8 * (*(_DWORD *)(a1 + 1068) + *(_DWORD *)(v5 + 8));
  size_t v7 = (v6 + 24);
  if (v6 == -24)
  {
    unsigned int v8 = 0;
  }
  else
  {
    unsigned int v8 = (*(uint64_t (**)(uint64_t, void))(v5 + 48))(v5, (v6 + 39) & 0xFFFFFFF0);
    if (!v8) {
      unsigned int v8 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
    }
  }
  int v9 = *(_DWORD *)(a1 + 1060);
  int v10 = *(_DWORD *)(a1 + 1064);
  *(_DWORD *)(a1 + 1060) = v8;
  *(_DWORD *)(a1 + 1064) = v7;
  if (v9 && v10) {
    (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
  }
  uint64_t v11 = v8;
  BOOL v3 = 1;
  char v12 = BOMStreamWithFile(*(_DWORD *)(a1 + 1028), v11, v7, 1, 0);
  if (v12)
  {
    uint64_t v19 = (uint64_t (*)(void *))v12;
    uint64_t v20 = *(unsigned int *)(a1 + 1068);
    BOMStreamWriteUInt32((uint64_t (*)(void *))v12, v20, v13, v14, v15, v16, v17, v18);
    if (v20)
    {
      uint64_t v27 = 0;
      unint64_t v28 = 0;
      do
      {
        if (v28 >= *(unsigned int *)(a1 + 1068))
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v21, v22, v23, v24, v25, v26, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
          uint64_t v31 = 0xFFFFFFFFLL;
        }
        else
        {
          unsigned int v29 = *(_DWORD *)(*(void *)(a1 + 1072) + v27);
          unsigned int v30 = bswap32(v29);
          if (*(unsigned char *)(a1 + 1052)) {
            uint64_t v31 = v29;
          }
          else {
            uint64_t v31 = v30;
          }
        }
        BOMStreamWriteUInt32(v19, v31, v21, v22, v23, v24, v25, v26);
        if (v28 >= *(unsigned int *)(a1 + 1068))
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v32, v33, v34, v35, v36, v37, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
          uint64_t v40 = 0;
        }
        else
        {
          unsigned int v38 = *(_DWORD *)(*(void *)(a1 + 1072) + v27 + 4);
          unsigned int v39 = bswap32(v38);
          if (*(unsigned char *)(a1 + 1052)) {
            uint64_t v40 = v38;
          }
          else {
            uint64_t v40 = v39;
          }
        }
        BOMStreamWriteUInt32(v19, v40, v32, v33, v34, v35, v36, v37);
        ++v28;
        v27 += 8;
      }
      while (8 * v20 != v27);
    }
    BOMStreamWriteUInt32(v19, *(unsigned int *)(*(void *)(a1 + 1088) + 8), v21, v22, v23, v24, v25, v26);
    size_t __len = 0;
    uint64_t v41 = *(void *)(a1 + 1088);
    uint64_t v42 = *(uint64_t (**)(uint64_t, BOOL, size_t *))(v41 + 24);
    BOOL v43 = BOMStreamGetByteOrder((uint64_t)v19) == 1;
    uint64_t v44 = (void *)v42(v41, v43, &__len);
    BOMStreamWriteBuffer((uint64_t)v19, v44, __len, v45, v46, v47, v48, v49);
    free(v44);
    int v57 = BOMStreamFree((uint64_t)v19, v50, v51, v52, v53, v54, v55, v56);
    if (_AdjustFileSize(a1, 0, 0)) {
      return 1;
    }
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    BOOL v3 = (_WriteRootPage(a1) | v57) != 0;
    int v2 = *(_DWORD *)(a1 + 1052);
LABEL_8:
    *(_DWORD *)(a1 + 1052) = v2 & 0xFFFFFFEF;
  }
  return v3;
}

uint64_t BOMStorageGetSys(uint64_t result)
{
  if (result) {
    return *(void *)(result + 1120);
  }
  return result;
}

uint64_t BOMStorageNewBlock(uint64_t a1)
{
  if (!a1 || (*(unsigned char *)(a1 + 1052) & 1) == 0) {
    return 0;
  }
  uint64_t v1 = (*(_DWORD *)(a1 + 1056) + 1);
  *(_DWORD *)(a1 + 1056) = v1;
  unsigned int v3 = *(_DWORD *)(a1 + 1068);
  if (v1 >= v3) {
    _ExpandBlockTable((char *)a1, v3 + 8);
  }
  return v1;
}

char *_ExpandBlockTable(char *result, unsigned int a2)
{
  int v2 = result;
  uint64_t v3 = *((unsigned int *)result + 267);
  if (v3 < a2)
  {
    *((void *)result + 134) = BOM_realloczero(*((void **)result + 134), 8 * v3, 8 * a2);
    uint64_t result = BOM_realloczero(*((void **)v2 + 135), 4 * *((unsigned int *)v2 + 267), 4 * a2);
    *((void *)v2 + 135) = result;
    *((_DWORD *)v2 + 267) = a2;
  }
  if (!*((void *)v2 + 134) || !*((void *)v2 + 135))
  {
    int v5 = *__error();
    return (char *)_BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1672, v5);
  }
  return result;
}

uint64_t BOMStorageNewNamedBlock(uint64_t a1, const char *a2)
{
  if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
    return 0;
  }
  if (_tocGet(a1, a2))
  {
    _CUILog(4, (uint64_t)"%s: block named '%s' already exists", v4, v5, v6, v7, v8, v9, (uint64_t)"BOMBlockID BOMStorageNewNamedBlock(BOMStorage, const char *)");
    return 0;
  }
  uint64_t v10 = BOMStorageNewBlock(a1);
  unsigned int v12 = strnlen(a2, 0xFFuLL);
  unsigned int v19 = v12;
  if (v12 < 0xFF)
  {
    if (*(_DWORD *)(a1 + 1096)) {
      int v20 = *(_DWORD *)(a1 + 1100);
    }
    else {
      int v20 = 4;
    }
    unsigned int v21 = v12 + v20;
    unsigned int v22 = v21 + 5;
    if (v21 == -5)
    {
      unsigned int v23 = 0;
    }
    else
    {
      unsigned int v23 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48))();
      if (!v23) {
        unsigned int v23 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
      }
    }
    _ExpandMapAddress(a1, v23 + v22);
    uint64_t v24 = *(unsigned int *)(a1 + 1096);
    if (v24)
    {
      uint64_t v25 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v24, *(unsigned int *)(a1 + 1100), 0);
      if (!v25) {
        return v10;
      }
      uint64_t v33 = v25;
      int UInt32 = BOMStreamReadUInt32(v25, v26, v27, v28, v29, v30, v31, v32);
    }
    else
    {
      int UInt32 = 0;
      uint64_t v33 = 0;
    }
    uint64_t v35 = (uint64_t (*)(void *))BOMStreamWithAddress(*(void *)(a1 + 1040) + v23, v22, 1);
    if (v35)
    {
      uint64_t v42 = v35;
      size_t v43 = v19;
      BOMStreamWriteUInt32(v35, (UInt32 + 1), v36, v37, v38, v39, v40, v41);
      if (v33)
      {
        for (unsigned int i = v23; UInt32; --UInt32)
        {
          uint64_t v51 = BOMStreamReadUInt32(v33, v44, v45, v46, v47, v48, v49, v50);
          uint64_t UInt8 = BOMStreamReadUInt8(v33, v52, v53, v54, v55, v56, v57, v58);
          BOMStreamReadBuffer(v33, __dst, UInt8, v60, v61, v62, v63, v64);
          BOMStreamWriteUInt32(v42, v51, v65, v66, v67, v68, v69, v70);
          BOMStreamWriteUInt8(v42, UInt8, v71, v72, v73, v74, v75, v76);
          BOMStreamWriteBuffer((uint64_t)v42, __dst, UInt8, v77, v78, v79, v80, v81);
        }
        BOMStreamFree(v33, v44, v45, v46, v47, v48, v49, v50);
        if (*(_DWORD *)(a1 + 1096))
        {
          uint64_t v45 = *(unsigned int *)(a1 + 1100);
          if (v45) {
            (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
          }
        }
        unsigned int v23 = i;
        size_t v43 = v19;
      }
      BOMStreamWriteUInt32(v42, v10, v45, v46, v47, v48, v49, v50);
      BOMStreamWriteUInt8(v42, v19, v82, v83, v84, v85, v86, v87);
      BOMStreamWriteBuffer((uint64_t)v42, a2, v43, v88, v89, v90, v91, v92);
      BOMStreamFree((uint64_t)v42, v93, v94, v95, v96, v97, v98, v99);
      *(_DWORD *)(a1 + 1096) = v23;
      *(_DWORD *)(a1 + 1100) = v22;
      _AdjustFileSize(a1, v23, v22);
      if (*(_DWORD *)(a1 + 1028) != -1) {
        _AddToWriteCache(a1, v23, v22);
      }
      *(_DWORD *)(a1 + 1052) |= 0x10u;
    }
  }
  else
  {
    _CUILog(4, (uint64_t)"%s: name length '%s' is > %d", v13, v14, v15, v16, v17, v18, (uint64_t)"void _tocSet(BOMStorage, BOMBlockID, const char *)");
  }
  return v10;
}

double BOMStorageFreeBlock(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2 && *(_DWORD *)(a1 + 1056) >= a2)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 1068);
    if (v10 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
      unsigned int v10 = *(_DWORD *)(a1 + 1068);
      int v12 = -1;
    }
    else
    {
      unsigned int v11 = bswap32(*(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2));
      if (*(unsigned char *)(a1 + 1052)) {
        int v12 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2);
      }
      else {
        int v12 = v11;
      }
    }
    if (v10 <= a2)
    {
      _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
LABEL_19:
      double result = NAN;
      *(void *)(*(void *)(a1 + 1072) + 8 * a2) = -1;
      return result;
    }
    unsigned int v14 = bswap32(*(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4));
    if (*(unsigned char *)(a1 + 1052)) {
      unsigned int v15 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
    }
    else {
      unsigned int v15 = v14;
    }
    if (v12 != -1 || v15 != -1)
    {
      if (v12)
      {
        if (v15) {
          (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
        }
      }
      goto LABEL_19;
    }
  }
  return result;
}

void BOMStorageFreeNamedBlock(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (a2)
    {
      unsigned int v4 = _tocGet(a1, a2);
      if (v4)
      {
        BOMStorageFreeBlock(a1, v4, v5, v6, v7, v8, v9, v10);
        if (*(_DWORD *)(a1 + 1096))
        {
          int v11 = strlen(a2);
          int v12 = *(_DWORD *)(a1 + 1100);
          if (v12)
          {
            unsigned int v13 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48))();
            if (!v13) {
              unsigned int v13 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
            }
          }
          else
          {
            unsigned int v13 = 0;
          }
          uint64_t v14 = (v12 - v11 - 5);
          _ExpandMapAddress(a1, v13 + v14);
          uint64_t v15 = BOMStreamWithAddress(*(void *)(a1 + 1040) + *(unsigned int *)(a1 + 1096), *(unsigned int *)(a1 + 1100), 0);
          if (v15)
          {
            uint64_t v16 = v15;
            uint64_t v17 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v13, v14, 1);
            if (v17)
            {
              uint64_t v25 = (uint64_t (*)(void *))v17;
              int UInt32 = BOMStreamReadUInt32(v16, v18, v19, v20, v21, v22, v23, v24);
              BOMStreamWriteUInt32(v25, (UInt32 - 1), v27, v28, v29, v30, v31, v32);
              for (; UInt32; --UInt32)
              {
                uint64_t v40 = BOMStreamReadUInt32(v16, v33, v34, v35, v36, v37, v38, v39);
                size_t UInt8 = BOMStreamReadUInt8(v16, v41, v42, v43, v44, v45, v46, v47);
                BOMStreamReadBuffer(v16, __s1, UInt8, v49, v50, v51, v52, v53);
                __s1[UInt8] = 0;
                if (strcmp(__s1, a2))
                {
                  BOMStreamWriteUInt32(v25, v40, v34, v35, v36, v37, v38, v39);
                  BOMStreamWriteUInt8(v25, UInt8, v54, v55, v56, v57, v58, v59);
                  BOMStreamWriteBuffer((uint64_t)v25, __s1, UInt8, v60, v61, v62, v63, v64);
                }
              }
              BOMStreamFree(v16, v33, v34, v35, v36, v37, v38, v39);
              BOMStreamFree((uint64_t)v25, v65, v66, v67, v68, v69, v70, v71);
              if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100)) {
                (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
              }
              *(_DWORD *)(a1 + 1096) = v13;
              *(_DWORD *)(a1 + 1100) = v14;
              _AdjustFileSize(a1, v13, v14);
              if (*(_DWORD *)(a1 + 1028) != -1) {
                _AddToWriteCache(a1, v13, v14);
              }
              *(_DWORD *)(a1 + 1052) |= 0x10u;
            }
          }
        }
      }
    }
  }
}

uint64_t BOMStorageCopyToBlock(uint64_t a1, uint64_t a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || *(_DWORD *)(a1 + 1056) < a2 || (*(unsigned char *)(a1 + 1052) & 1) == 0) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 1068) <= a2)
  {
    _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
    unint64_t v13 = 0;
  }
  else
  {
    unint64_t v13 = *(unsigned int *)(*(void *)(a1 + 1072) + 8 * a2 + 4);
  }
  return BOMStorageCopyToBlockRange(a1, a2, a3, a4, 0, v13, a7, a8);
}

uint64_t BOMStorageCopyToBlockRange(uint64_t a1, uint64_t a2, const void *a3, size_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1)
  {
    unsigned int v10 = a2;
    if (a2)
    {
      if (*(_DWORD *)(a1 + 1056) >= a2 && (*(unsigned char *)(a1 + 1052) & 1) != 0)
      {
        unsigned int v15 = *(_DWORD *)(a1 + 1068);
        if (v15 <= a2)
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
          unsigned int v15 = *(_DWORD *)(a1 + 1068);
          unsigned int v16 = -1;
        }
        else
        {
          unsigned int v16 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * a2);
        }
        if (v15 <= v10)
        {
          _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
          unsigned int v17 = 0;
        }
        else
        {
          unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * v10 + 4);
          unsigned int v18 = bswap32(v17);
          if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
            unsigned int v17 = v18;
          }
        }
        unint64_t v19 = a6 + a5;
        unint64_t v20 = v17;
        size_t v21 = v17 - (a6 + a5);
        if (v17 < a6 + a5)
        {
          int v22 = *__error();
          uint64_t v23 = "BOMStorageCopyToBlockRange: length extends beyond block size";
          int v24 = 826;
          goto LABEL_31;
        }
        if (v17 <= a5) {
          unint64_t v25 = a5;
        }
        else {
          unint64_t v25 = v17;
        }
        unint64_t v26 = v25 + a4;
        if (((v25 + a4) | v25 | a4) >> 32)
        {
          uint64_t v27 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"BOMStorageCopyToBlockRange");
          int v22 = *__error();
          uint64_t v23 = v27;
          int v24 = 843;
          goto LABEL_31;
        }
        unint64_t v28 = v26 - a6;
        if ((v26 - a6) >> 32 || HIDWORD(a6))
        {
          uint64_t v33 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"BOMStorageCopyToBlockRange");
          int v22 = *__error();
          uint64_t v23 = v33;
          int v24 = 845;
          goto LABEL_31;
        }
        if (v20 != v28 || (unsigned int v29 = v16, v16 < *(_DWORD *)(a1 + 1036)))
        {
          if (v16 && v20)
          {
            unint64_t v30 = v28;
            (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
            unint64_t v28 = v30;
          }
          if (v28)
          {
            unint64_t v31 = v28;
            unsigned int v32 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48))();
            unint64_t v28 = v31;
            unsigned int v29 = v32;
            if (!v32) {
              unsigned int v29 = (*(_DWORD *)(a1 + 1032) + 15) & 0xFFFFFFF0;
            }
          }
          else
          {
            unsigned int v29 = 0;
          }
          uint64_t v34 = (unsigned int *)(*(void *)(a1 + 1072) + 8 * v10);
          *uint64_t v34 = v29;
          v34[1] = v28;
        }
        uint64_t result = 0;
        if (v29 && v28)
        {
          unint64_t v69 = v28;
          unint64_t v35 = v28 + v29;
          if (HIDWORD(v35))
          {
            uint64_t v65 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", v35, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"BOMStorageCopyToBlockRange");
            int v22 = *__error();
            uint64_t v23 = v65;
            int v24 = 882;
          }
          else
          {
            if (_ExpandMapAddress(a1, v35)) {
              return 1;
            }
            uint64_t v43 = v29;
            uint64_t v44 = v16;
            if (a5 && (v45 = *(void *)(a1 + 1040), (uint64_t v36 = (const void *)(v45 + v16)) != 0) && v45 + v29)
            {
              memmove((void *)(v45 + v29), v36, a5);
              uint64_t v44 = v16;
              uint64_t v43 = v29;
              unsigned int v46 = a5;
            }
            else
            {
              unsigned int v46 = 0;
            }
            uint64_t v47 = v19 + v44;
            if ((v19 | (v19 + v44)) >> 32)
            {
              uint64_t v48 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
              int v22 = *__error();
              uint64_t v23 = v48;
              int v24 = 905;
            }
            else
            {
              uint64_t v49 = a5 + a4 + v43;
              if (!(((a5 + a4) | v49) >> 32))
              {
                if (v20 <= a5 || v29 < v16 || v29 >= v20 + v16)
                {
                  if (a4)
                  {
                    uint64_t v54 = a3;
                    unsigned int v55 = v46;
                    uint64_t v56 = v43;
                    uint64_t v57 = v47;
                    memmove((void *)(*(void *)(a1 + 1040) + v43 + v46), v54, a4);
                    uint64_t v47 = v57;
                    uint64_t v43 = v56;
                    unsigned int v46 = v55 + a4;
                  }
                  if (v46 < v69)
                  {
                    size_t v58 = v69 - v46;
                    if (HIDWORD(v58))
                    {
                      uint64_t v67 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
                      int v22 = *__error();
                      uint64_t v23 = v67;
                      int v24 = 945;
                      goto LABEL_31;
                    }
                    unsigned int v59 = v46;
                    memmove((void *)(*(void *)(a1 + 1040) + v43 + v46), (const void *)(*(void *)(a1 + 1040) + v47), v58);
                    unsigned int v46 = v59 + v58;
                  }
                }
                else
                {
                  if (HIDWORD(v21))
                  {
                    uint64_t v66 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
                    int v22 = *__error();
                    uint64_t v23 = v66;
                    int v24 = 917;
                    goto LABEL_31;
                  }
                  if (v21)
                  {
                    unsigned int v51 = v46;
                    uint64_t v52 = v43;
                    memmove((void *)(*(void *)(a1 + 1040) + v49), (const void *)(*(void *)(a1 + 1040) + v47), v21);
                    uint64_t v43 = v52;
                    unsigned int v46 = v51;
                  }
                  if (a4)
                  {
                    unsigned int v53 = v46;
                    memmove((void *)(*(void *)(a1 + 1040) + v43 + v46), a3, a4);
                    unsigned int v46 = v53 + a4;
                  }
                  v46 += v21;
                }
                uint64_t v60 = *(void *)(a1 + 1080);
                if (v60)
                {
                  *(unsigned char *)(v60 + 4 * v10) |= 1u;
                }
                else
                {
                  unsigned int v61 = v46;
                  uint64_t v62 = BOMExceptionHandlerMessage("BOM blockShadowTable is null", (uint64_t)v36, v37, v38, v39, v40, v41, v42, v68);
                  uint64_t v63 = __error();
                  _BOMExceptionHandlerCall(v62, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 957, *v63);
                  unsigned int v46 = v61;
                }
                int v64 = v69;
                if (v46 == v69)
                {
                  if (*(_DWORD *)(a1 + 1028) == -1)
                  {
                    if (v29 + v69 > *(_DWORD *)(a1 + 1032)) {
                      *(_DWORD *)(a1 + 1032) = v29 + v69;
                    }
                  }
                  else
                  {
                    _AddToWriteCache(a1, v29, v69);
                    int v64 = v69;
                  }
                  uint64_t result = _AdjustFileSize(a1, v29, v64);
                  if (!result)
                  {
                    *(_DWORD *)(a1 + 1052) |= 0x10u;
                    return result;
                  }
                  return 1;
                }
                int v22 = *__error();
                uint64_t v23 = "BOMStorageCopyToBlockRange: internal consistency error";
                int v24 = 962;
                goto LABEL_31;
              }
              uint64_t v50 = BOMExceptionHandlerMessage("ERROR in %s: %s [%s:%d]", (uint64_t)v36, v37, v38, v39, v40, v41, v42, (char)"BOMStorageCopyToBlockRange");
              int v22 = *__error();
              uint64_t v23 = v50;
              int v24 = 906;
            }
          }
LABEL_31:
          _BOMExceptionHandlerCall(v23, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v24, v22);
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t _ExpandMapAddress(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 1048);
  if (v3 < a2)
  {
    if (v3 >= 0x100000) {
      LODWORD(v4) = v3 + 0x100000;
    }
    else {
      LODWORD(v4) = 2 * v3;
    }
    if (v4 <= a2) {
      unint64_t v4 = a2;
    }
    else {
      unint64_t v4 = v4;
    }
    int v5 = vm_page_size - v4 % vm_page_size;
    if (!(v4 % vm_page_size)) {
      int v5 = 0;
    }
    uint64_t v6 = (v5 + v4);
    vm_address_t v7 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 1120)
                                                                                               + 96))(*(void *)(*(void *)(a1 + 1120) + 8), 0, v6, 3, 4098, 0xFFFFFFFFLL, 0);
    if (v7 == -1)
    {
      int v12 = *__error();
      unint64_t v13 = "mmap failed";
      uint64_t v11 = 1;
      int v14 = 1531;
    }
    else
    {
      vm_address_t v8 = v7;
      if (vm_copy(mach_task_self_, *(void *)(a1 + 1040), *(unsigned int *)(a1 + 1048), v7))
      {
        uint64_t v9 = __error();
        _BOMExceptionHandlerCall("vm_copy failed", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1535, *v9);
      }
      if ((*(unsigned int (**)(void, void, void))(*(void *)(a1 + 1120) + 104))(*(void *)(*(void *)(a1 + 1120) + 8), *(void *)(a1 + 1040), *(unsigned int *)(a1 + 1048)) != -1)
      {
        *(void *)(a1 + 1040) = v8;
        *(_DWORD *)(a1 + 1048) = v6;
        if (!v8) {
          goto LABEL_17;
        }
        return 0;
      }
      int v12 = *__error();
      unint64_t v13 = "munmap failed";
      uint64_t v11 = 1;
      int v14 = 1538;
    }
    _BOMExceptionHandlerCall(v13, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", v14, v12);
    return v11;
  }
  if (!*(void *)(a1 + 1040))
  {
LABEL_17:
    unsigned int v10 = __error();
    _BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1551, *v10);
  }
  return 0;
}

void _AddToWriteCache(uint64_t a1, unsigned int a2, int a3)
{
  if (!a2 || !a3) {
    return;
  }
  int v5 = *(_DWORD **)(a1 + 1104);
  if (!v5)
  {
    *(void *)(a1 + 1104) = _newFreeListEntry(a2, a3);
    int v11 = 1;
LABEL_23:
    *(_DWORD *)(a1 + 1112) = v11;
LABEL_24:
    if (*(_DWORD *)(a1 + 1112) < 0x10u)
    {
      int v14 = *(_DWORD **)(a1 + 1104);
      if (v14)
      {
        unsigned int v15 = 0;
        do
        {
          unsigned int v16 = v14[3];
          if (v16 < 0xFFFF)
          {
            unsigned int v17 = *(_DWORD **)v14;
            unsigned int v15 = v14;
          }
          else
          {
            unsigned int v17 = *(_DWORD **)v14;
            if (v15)
            {
              *unsigned int v15 = v17;
              unsigned int v17 = *(_DWORD **)v14;
            }
            else
            {
              *(void *)(a1 + 1104) = v17;
            }
            _WriteAddress(a1, v14[2], v16);
            free(v14);
            --*(_DWORD *)(a1 + 1112);
          }
          int v14 = v17;
        }
        while (v17);
      }
    }
    else
    {
      _FlushWriteCache(a1);
    }
    return;
  }
  unsigned int v6 = v5[2];
  if (v6 <= a2)
  {
    while (1)
    {
      vm_address_t v7 = v5;
      int v5 = *(_DWORD **)v5;
      if (!v5) {
        break;
      }
      unsigned int v8 = v5[2];
      if (v8 >= a2)
      {
        int v10 = v7[3];
        if (v10 + v7[2] != a2) {
          goto LABEL_6;
        }
        v7[3] = v10 + a3;
        if (a3 + a2 == v5[2])
        {
          v7[3] = v5[3] + v10 + a3;
          *(void *)vm_address_t v7 = *(void *)v5;
          free(v5);
          int v11 = *(_DWORD *)(a1 + 1112) - 1;
          goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
    int v13 = v7[3];
    if (v13 + v7[2] == a2)
    {
      v7[3] = v13 + a3;
      goto LABEL_24;
    }
    int v12 = _newFreeListEntry(a2, a3);
    if (v12)
    {
      *(void *)int v12 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    vm_address_t v7 = 0;
    unsigned int v8 = v5[2];
LABEL_6:
    if (a3 + a2 == v8)
    {
      int v9 = v5[3] + a3;
      v5[2] = a2;
      v5[3] = v9;
      goto LABEL_24;
    }
    int v12 = _newFreeListEntry(a2, a3);
    if (v12)
    {
      *(void *)int v12 = v5;
      if (v6 <= a2) {
LABEL_21:
      }
        *(void *)vm_address_t v7 = v12;
      else {
        *(void *)(a1 + 1104) = v12;
      }
      int v11 = *(_DWORD *)(a1 + 1112) + 1;
      goto LABEL_23;
    }
  }
  int v18 = *__error();
  _BOMExceptionHandlerCall("Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 2104, v18);
}

uint64_t _AdjustFileSize(uint64_t a1, int a2, int a3)
{
  if (a2)
  {
    if ((a3 + a2) <= *(_DWORD *)(a1 + 1032))
    {
      return 0;
    }
    else
    {
      uint64_t result = 0;
      *(_DWORD *)(a1 + 1032) = a3 + a2;
    }
  }
  else
  {
    uint64_t v5 = (*(uint64_t (**)(void, void, void, uint64_t))(*(void *)(a1 + 1120) + 56))(*(void *)(*(void *)(a1 + 1120) + 8), *(unsigned int *)(a1 + 1028), 0, 2);
    if (v5 == -1)
    {
      vm_address_t v7 = __error();
      strerror(*v7);
      _CUILog(4, (uint64_t)"%s: lseek: %s", v8, v9, v10, v11, v12, v13, (uint64_t)"int _AdjustFileSize(BOMStorage, unsigned int, unsigned int)");
      return 1;
    }
    else
    {
      int v6 = v5;
      uint64_t result = 0;
      *(_DWORD *)(a1 + 1032) = v6;
    }
  }
  return result;
}

void _FlushWriteCache(uint64_t a1)
{
  for (unsigned int i = *(_DWORD **)(a1 + 1104); i; unsigned int i = *(_DWORD **)(a1 + 1104))
  {
    *(void *)(a1 + 1104) = *(void *)i;
    _WriteAddress(a1, i[2], i[3]);
    free(i);
  }
  *(_DWORD *)(a1 + 1112) = 0;
}

uint64_t BOMStorageCompact(uint64_t a1)
{
  if (!a1 || (*(unsigned char *)(a1 + 1052) & 1) == 0 || *(_DWORD *)(a1 + 1028) == -1) {
    return 1;
  }
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v75 = 0u;
  uint64_t v2 = *(void *)(a1 + 1120);
  BOMStorageCommit(a1);
  __strlcpy_chk();
  int v3 = (*(uint64_t (**)(void, void, long long *))(v2 + 72))(*(void *)(v2 + 8), *(unsigned int *)(a1 + 1028), &v75);
  if (v3 == -1)
  {
    unint64_t v4 = __error();
    char v5 = strerror(*v4);
    uint64_t v13 = BOMExceptionHandlerMessage("fstat: %s", v6, v7, v8, v9, v10, v11, v12, v5);
    int v14 = __error();
    _BOMExceptionHandlerCall(v13, 0, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 1303, *v14);
  }
  __strlcpy_chk();
  unsigned int v15 = strrchr(__s, 47);
  if (v15) {
    *unsigned int v15 = 0;
  }
  else {
    __strlcpy_chk();
  }
  __strlcat_chk();
  if (!mktemp(__s))
  {
    _CUILog(4, (uint64_t)"%s: mktemp can't get temp file %s", v17, v18, v19, v20, v21, v22, (uint64_t)"int BOMStorageCompact(BOMStorage)");
    return 1;
  }
  uint64_t v23 = BOMStorageNewWithOptionsAndSys((uint64_t)__s, v16, (long long *)v2);
  if (!v23) {
    goto LABEL_56;
  }
  uint64_t v24 = v23;
  if (*(_DWORD *)(a1 + 1056))
  {
    uint64_t v25 = 1;
    do
    {
      if (v25 != BOMStorageNewBlock(v24))
      {
        _CUILog(4, (uint64_t)"%s: unable to reserve block %d", v26, v27, v28, v29, v30, v31, (uint64_t)"int BOMStorageCompact(BOMStorage)");
        goto LABEL_56;
      }
      unsigned int v32 = *(_DWORD *)(a1 + 1068);
      if (v32 <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v26, v27, v28, v29, v30, v31, (uint64_t)"unsigned int _getBlockTableAddr(BOMStorage, BOMBlockID)");
        unsigned int v32 = *(_DWORD *)(a1 + 1068);
      }
      else
      {
        unsigned int v33 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * v25);
        unsigned int v34 = bswap32(v33);
        if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
          unsigned int v33 = v34;
        }
        if (v33 != -1) {
          goto LABEL_26;
        }
      }
      if (v32 <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v26, v27, v28, v29, v30, v31, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        unsigned int v32 = *(_DWORD *)(a1 + 1068);
      }
      else
      {
        unsigned int v35 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * v25 + 4);
        unsigned int v36 = bswap32(v35);
        if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
          unsigned int v35 = v36;
        }
        if (v35 == -1)
        {
          BOMStorageFreeBlock(v24, v25, v26, v27, v28, v29, v30, v31);
          goto LABEL_39;
        }
      }
LABEL_26:
      if (v32 <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v26, v27, v28, v29, v30, v31, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        unsigned int v37 = 0;
      }
      else
      {
        unsigned int v37 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * v25 + 4);
        unsigned int v38 = bswap32(v37);
        if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
          unsigned int v37 = v38;
        }
      }
      uint64_t v39 = BOM_malloc(v37);
      if (BOMStorageCopyFromBlock(a1, v25, v39, v40, v41, v42, v43, v44)) {
        goto LABEL_45;
      }
      if (*(_DWORD *)(a1 + 1068) <= v25)
      {
        _CUILog(4, (uint64_t)"CoreUI: bid %d >= blockTableCount %d", v45, v46, v47, v48, v49, v50, (uint64_t)"unsigned int _getBlockTableSize(BOMStorage, BOMBlockID)");
        unsigned int v51 = 0;
      }
      else
      {
        unsigned int v51 = *(_DWORD *)(*(void *)(a1 + 1072) + 8 * v25 + 4);
        unsigned int v52 = bswap32(v51);
        if ((*(unsigned char *)(a1 + 1052) & 1) == 0) {
          unsigned int v51 = v52;
        }
      }
      if (BOMStorageCopyToBlock(v24, v25, v39, v51, v47, v48, v49, v50))
      {
LABEL_45:
        _CUILog(4, (uint64_t)"%s: unable to copy block %d", v45, v46, v47, v48, v49, v50, (uint64_t)"int BOMStorageCompact(BOMStorage)");
        free(v39);
        goto LABEL_56;
      }
      free(v39);
LABEL_39:
      uint64_t v25 = (v25 + 1);
    }
    while (v25 <= *(_DWORD *)(a1 + 1056));
  }
  if (*(_DWORD *)(a1 + 1096))
  {
    size_t v53 = *(unsigned int *)(a1 + 1100);
    *(_DWORD *)(v24 + 1100) = v53;
    if (v53)
    {
      unsigned int v54 = (*(uint64_t (**)(void))(*(void *)(v24 + 1088) + 48))();
      if (!v54) {
        unsigned int v54 = (*(_DWORD *)(v24 + 1032) + 15) & 0xFFFFFFF0;
      }
    }
    else
    {
      unsigned int v54 = 0;
    }
    *(_DWORD *)(v24 + 1096) = v54;
    _ExpandMapAddress(v24, v54 + v53);
    memmove((void *)(*(void *)(v24 + 1040) + *(unsigned int *)(v24 + 1096)), (const void *)(*(void *)(a1 + 1040) + *(unsigned int *)(a1 + 1096)), v53);
    _AdjustFileSize(v24, v54, v53);
    if (*(_DWORD *)(v24 + 1028) != -1) {
      _AddToWriteCache(v24, v54, v53);
    }
    *(_DWORD *)(v24 + 1052) |= 0x10u;
  }
  BOMStorageCommit(v24);
  unsigned int v55 = BOM_malloc(0x470uLL);
  if (!v55)
  {
    BOMStorageFree((unsigned char *)v24);
    uint64_t v67 = __error();
    strerror(*v67);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v68, v69, v70, v71, v72, v73, (uint64_t)"int BOMStorageCompact(BOMStorage)");
LABEL_56:
    unlink(__s);
    return 1;
  }
  uint64_t v56 = v55;
  memcpy(v55, (const void *)a1, 0x470uLL);
  BOMStorageFree(v56);
  if ((*(unsigned int (**)(void, char *, unsigned char *))(v2 + 88))(*(void *)(v2 + 8), __s, v85))
  {
    uint64_t v57 = __error();
    strerror(*v57);
    _CUILog(4, (uint64_t)"%s: rename: '%s' '%s' failed %s", v58, v59, v60, v61, v62, v63, (uint64_t)"int BOMStorageCompact(BOMStorage)");
    BOMStorageFree((unsigned char *)v24);
    uint64_t v64 = 1;
    uint64_t v65 = (void *)BOMStorageOpenWithSys((uint64_t)v85, 1, (long long *)v2);
    if (v65)
    {
      uint64_t v66 = v65;
      memcpy((void *)a1, v65, 0x470uLL);
      free(v66);
    }
  }
  else
  {
    if (v3 != -1)
    {
      (*(void (**)(void, void, void))(v2 + 112))(*(void *)(v2 + 8), *(unsigned int *)(v24 + 1028), WORD2(v75));
      (*(void (**)(void, void, void, void))(v2 + 120))(*(void *)(v2 + 8), *(unsigned int *)(v24 + 1028), v76, DWORD1(v76));
    }
    memcpy((void *)a1, (const void *)v24, 0x470uLL);
    __strlcpy_chk();
    free((void *)v24);
    return 0;
  }
  return v64;
}

_DWORD *_newFreeListEntry(int a1, int a2)
{
  unint64_t v4 = BOM_malloc(0x10uLL);
  char v5 = v4;
  if (v4)
  {
    *(void *)unint64_t v4 = 0;
    v4[2] = a1;
    v4[3] = a2;
  }
  else
  {
    uint64_t v6 = __error();
    strerror(*v6);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v7, v8, v9, v10, v11, v12, (uint64_t)"FreeListEntry _newFreeListEntry(unsigned int, unsigned int)");
  }
  return v5;
}

uint64_t (*_WriteAddress(uint64_t a1, unsigned int a2, unsigned int a3))(void *)
{
  int v3 = BOMStreamWithFile(*(_DWORD *)(a1 + 1028), a2, a3, 1, (char *)(*(void *)(a1 + 1040) + a2));
  if (v3)
  {
    unint64_t v4 = v3;
    BOMStreamFlush();
    return (uint64_t (*)(void *))BOMStreamFree(v4);
  }
  else
  {
    int v6 = *__error();
    return _BOMExceptionHandlerCall("Unable to create write stream.", 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStorage.c", 2177, v6);
  }
}

uint64_t BOMStreamWithBlockID(uint64_t a1, unsigned int a2, size_t a3, int a4)
{
  uint64_t v8 = BOM_malloczero(0x58uLL);
  uint64_t v15 = (uint64_t)v8;
  if (!v8)
  {
    uint64_t v28 = __error();
    strerror(*v28);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v29, v30, v31, v32, v33, v34, (uint64_t)"BOMStreamWithBlockID");
    return v15;
  }
  v8[1] = 1;
  unint64_t v16 = BOMStorageSizeOfBlock(a1, a2, v9, v10, v11, v12, v13, v14);
  *(void *)(v15 + 72) = BOMStorageGetSys(a1);
  *(_DWORD *)uint64_t v15 = 0;
  *(void *)(v15 + 8) = a1;
  *(_DWORD *)(v15 + 16) = a2;
  if (a3) {
    unint64_t v17 = a3;
  }
  else {
    unint64_t v17 = v16;
  }
  *(void *)(v15 + 32) = v17;
  *(_DWORD *)(v15 + 40) = a4;
  if (v16 <= a3) {
    size_t v18 = a3;
  }
  else {
    size_t v18 = v16;
  }
  uint64_t v19 = (char *)BOM_malloczero(v18);
  *(void *)(v15 + 48) = v19;
  if (!v19)
  {
    unsigned int v35 = __error();
    strerror(*v35);
    _CUILog(4, (uint64_t)"%s: malloc: %s", v36, v37, v38, v39, v40, v41, (uint64_t)"BOMStreamWithBlockID");
    goto LABEL_16;
  }
  uint64_t v26 = (uint64_t)v19;
  *(unsigned char *)(v15 + 80) |= 1u;
  uint64_t v27 = *(void *)(v15 + 32);
  *(void *)(v15 + 56) = v19;
  *(void *)(v15 + 64) = &v19[v27];
  if ((*(_DWORD *)(v15 + 40) | 2) != 2) {
    goto LABEL_12;
  }
  if (BOMStorageCopyFromBlock(a1, a2, v19, v21, v22, v23, v24, v25))
  {
LABEL_16:
    BOMStreamFree(v15, v20, v26, v21, v22, v23, v24, v25);
    return 0;
  }
  uint64_t v27 = *(void *)(v15 + 32);
LABEL_12:
  if (!v27) {
    goto LABEL_16;
  }
  return v15;
}

void *BOMStreamWithFile(int a1, uint64_t a2, size_t a3, int a4, char *a5)
{
  return BOMStreamWithFileAndSys(a1, a2, a3, a4, a5, 0);
}

uint64_t BOMStreamFlush(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _CUILog(4, (uint64_t)"%s: bad stream!", a3, a4, a5, a6, a7, a8, (uint64_t)"BOMStreamFlush");
    return 1;
  }
  if (!a1[10]) {
    goto LABEL_13;
  }
  int v9 = *a1;
  if (*a1 == 2) {
    goto LABEL_13;
  }
  if (v9 == 1)
  {
    if ((*(uint64_t (**)(void, void, void, void))(*((void *)a1 + 9) + 56))(*(void *)(*((void *)a1 + 9) + 8), a1[5], *((void *)a1 + 3), 0) == -1)
    {
      size_t v18 = __error();
      strerror(*v18);
      _CUILog(4, (uint64_t)"%s: lseek: %s", v19, v20, v21, v22, v23, v24, (uint64_t)"BOMStreamFlush");
    }
    else
    {
      if ((*(uint64_t (**)(void, void, void, void))(*((void *)a1 + 9) + 48))(*(void *)(*((void *)a1 + 9) + 8), a1[5], *((void *)a1 + 6), *((void *)a1 + 4)) == *((void *)a1 + 4))
      {
LABEL_13:
        uint64_t result = 0;
        goto LABEL_14;
      }
      uint64_t v11 = __error();
      strerror(*v11);
      _CUILog(4, (uint64_t)"%s: write: %s", v12, v13, v14, v15, v16, v17, (uint64_t)"BOMStreamFlush");
    }
    return 1;
  }
  if (v9)
  {
    _CUILog(4, (uint64_t)"%s: unknown stream type: %d", a3, a4, a5, a6, a7, a8, (uint64_t)"BOMStreamFlush");
    goto LABEL_13;
  }
  uint64_t result = BOMStorageCopyToBlock(*((void *)a1 + 1), a1[4], *((const void **)a1 + 6), *((void *)a1 + 4), a5, a6, a7, a8);
LABEL_14:
  *((unsigned char *)a1 + 80) &= ~2u;
  return result;
}

uint64_t BOMStreamGetByteOrder(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

uint64_t (*BOMStreamWriteUInt32(uint64_t (*result)(void *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(void *)
{
  unsigned int v8 = bswap32(a2);
  if (*((_DWORD *)result + 1) == 2) {
    int v9 = a2;
  }
  else {
    int v9 = v8;
  }
  if (*((_DWORD *)result + 10))
  {
    uint64_t v10 = (_DWORD *)*((void *)result + 7);
    if ((unint64_t)(v10 + 1) <= *((void *)result + 8))
    {
      *uint64_t v10 = v9;
      *((void *)result + 7) += 4;
      *((unsigned char *)result + 80) |= 2u;
      return result;
    }
    uint64_t v11 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt32");
    int v12 = *__error();
    uint64_t v13 = v11;
    unsigned __int8 v14 = 1;
    int v15 = 373;
  }
  else
  {
    uint64_t v16 = BOMExceptionHandlerMessage("%s write called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt32");
    int v12 = *__error();
    uint64_t v13 = v16;
    unsigned __int8 v14 = 0;
    int v15 = 371;
  }
  return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
}

uint64_t (*BOMStreamWriteUInt16(uint64_t (*result)(void *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(void *)
{
  __int16 v8 = __rev16(a2);
  if (*((_DWORD *)result + 1) == 2) {
    __int16 v9 = a2;
  }
  else {
    __int16 v9 = v8;
  }
  if (*((_DWORD *)result + 10))
  {
    uint64_t v10 = (_WORD *)*((void *)result + 7);
    if ((unint64_t)(v10 + 1) <= *((void *)result + 8))
    {
      *uint64_t v10 = v9;
      *((void *)result + 7) += 2;
      *((unsigned char *)result + 80) |= 2u;
      return result;
    }
    uint64_t v11 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt16");
    int v12 = *__error();
    uint64_t v13 = v11;
    unsigned __int8 v14 = 1;
    int v15 = 392;
  }
  else
  {
    uint64_t v16 = BOMExceptionHandlerMessage("%s write called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt16");
    int v12 = *__error();
    uint64_t v13 = v16;
    unsigned __int8 v14 = 0;
    int v15 = 390;
  }
  return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
}

uint64_t (*BOMStreamWriteUInt8(uint64_t (*result)(void *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(void *)
{
  if (*((_DWORD *)result + 10))
  {
    __int16 v8 = (unsigned char *)*((void *)result + 7);
    if ((unint64_t)(v8 + 1) <= *((void *)result + 8))
    {
      *__int16 v8 = a2;
      ++*((void *)result + 7);
      *((unsigned char *)result + 80) |= 2u;
      return result;
    }
    __int16 v9 = BOMExceptionHandlerMessage("%s buffer overflow", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt8");
    int v10 = *__error();
    uint64_t v11 = v9;
    unsigned __int8 v12 = 1;
    int v13 = 405;
  }
  else
  {
    unsigned __int8 v14 = BOMExceptionHandlerMessage("%s write called on read-only buffer", a2, a3, a4, a5, a6, a7, a8, (char)"BOMStreamWriteUInt8");
    int v10 = *__error();
    uint64_t v11 = v14;
    unsigned __int8 v12 = 0;
    int v13 = 403;
  }
  return _BOMExceptionHandlerCall(v11, v12, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v13, v10);
}

uint64_t (*BOMStreamWriteBuffer(uint64_t a1, const void *a2, size_t __len, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(void *)
{
  if (*(_DWORD *)(a1 + 40))
  {
    int v10 = *(void **)(a1 + 56);
    if ((unint64_t)v10 + __len <= *(void *)(a1 + 64))
    {
      uint64_t result = (uint64_t (*)(void *))memmove(v10, a2, __len);
      *(void *)(a1 + 56) += __len;
      *(unsigned char *)(a1 + 80) |= 2u;
      return result;
    }
    uint64_t v11 = BOMExceptionHandlerMessage("%s buffer overflow", (uint64_t)a2, __len, a4, a5, a6, a7, a8, (char)"BOMStreamWriteBuffer");
    int v12 = *__error();
    int v13 = v11;
    unsigned __int8 v14 = 1;
    int v15 = 418;
  }
  else
  {
    uint64_t v16 = BOMExceptionHandlerMessage("%s write called on read-only buffer", (uint64_t)a2, __len, a4, a5, a6, a7, a8, (char)"BOMStreamWriteBuffer");
    int v12 = *__error();
    int v13 = v16;
    unsigned __int8 v14 = 0;
    int v15 = 416;
  }
  return _BOMExceptionHandlerCall(v13, v14, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMStream.c", v15, v12);
}

_DWORD *BOMTreeNewWithName(uint64_t a1, const char *a2)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  unsigned int v4 = BOMStorageNewNamedBlock(a1, a2);
  if (!v4) {
    return 0;
  }
  return _BOMTreeNew(a1, a2, v4, 0, 0);
}

_DWORD *_BOMTreeNew(uint64_t a1, const char *a2, unsigned int a3, int a4, char a5)
{
  uint64_t result = _newBOMTree(a1, a2);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    result[4] = a3;
    if ((a4 - 1) >= 0x2F) {
      int v12 = a4;
    }
    else {
      int v12 = 48;
    }
    if (!v12) {
      int v12 = 4096;
    }
    result[76] = v12;
    unsigned int v13 = v12 - 16;
    result[77] = v13 >> 3;
    result[78] = (v13 >> 3) + 1;
    result[79] = v13 >> 4;
    result[89] = result[89] & 0xFFFFFFFB | (4 * (a5 & 1));
    unsigned __int8 v14 = _NewPage((uint64_t)result, 0);
    *(void *)(v11 + 24) = v14;
    *((_WORD *)v14 + 2) |= 1u;
    *(_DWORD *)(v11 + 356) |= 1u;
    BOMTreeFree(v11);
    return (_DWORD *)_BOMTreeOpen(a1, a2, a3, 1);
  }
  return result;
}

_DWORD *BOMTreeNewWithOptions(uint64_t a1, unsigned int a2, const char *a3, int a4, char a5)
{
  if (!a1) {
    return 0;
  }
  unsigned int v8 = a2;
  if (!a2 && !a3) {
    return 0;
  }
  if (!a2)
  {
    unsigned int v8 = BOMStorageNewNamedBlock(a1, a3);
    if (!v8) {
      return 0;
    }
  }
  return _BOMTreeNew(a1, a3, v8, a4, a5);
}

uint64_t BOMTreeCommit(uint64_t a1)
{
  if (!a1 || (*(unsigned char *)(a1 + 356) & 1) == 0) {
    return 0;
  }
  for (uint64_t i = 32; i != 288; i += 8)
  {
    uint64_t v5 = *(void *)(a1 + i);
    if (v5 && (*(_WORD *)(v5 + 4) & 2) != 0) {
      _WritePage(a1, v5);
    }
  }
  _WritePage(a1, *(void *)(a1 + 24));
  uint64_t v2 = 1;
  int v6 = (uint64_t (*)(void *))BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)(a1 + 16), 0x1DuLL, 1);
  if (v6)
  {
    unsigned int v13 = v6;
    BOMStreamWriteUInt32(v6, 1953654117, v7, v8, v9, v10, v11, v12);
    BOMStreamWriteUInt32(v13, 1, v14, v15, v16, v17, v18, v19);
    BOMStreamWriteUInt32(v13, **(unsigned int **)(a1 + 24), v20, v21, v22, v23, v24, v25);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a1 + 304), v26, v27, v28, v29, v30, v31);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a1 + 20), v32, v33, v34, v35, v36, v37);
    BOMStreamWriteUInt8(v13, (*(unsigned __int8 *)(a1 + 356) >> 2) & 1, v38, v39, v40, v41, v42, v43);
    if ((*(unsigned char *)(a1 + 356) & 4) != 0) {
      uint64_t v50 = 0;
    }
    else {
      uint64_t v50 = *(unsigned int *)(a1 + 348);
    }
    BOMStreamWriteUInt32(v13, v50, v44, v45, v46, v47, v48, v49);
    BOMStreamWriteUInt32(v13, 0, v51, v52, v53, v54, v55, v56);
    if (!BOMStreamFree((uint64_t)v13, v57, v58, v59, v60, v61, v62, v63))
    {
      uint64_t v2 = 0;
      *(_DWORD *)(a1 + 356) &= ~1u;
    }
  }
  return v2;
}

uint64_t BOMTreeRemoveAndFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)result;
    int v3 = BOMTreeIteratorNew(result, 0, 0, 0);
    if (v3)
    {
      for (uint64_t i = v3;
            !BOMTreeIteratorIsAtEnd((uint64_t)i, v4, v5, v6, v7, v8, v9, v10);
            BOMTreeIteratorNext((uint64_t)i, v31, v32, v33, v34, v35, v36, v37))
      {
        uint64_t v19 = (void *)BOMTreeIteratorKey((uint64_t)i, v12, v13, v14, v15, v16, v17, v18);
        unint64_t v27 = BOMTreeIteratorKeySize((uint64_t)i, v20, v21, v22, v23, v24, v25, v26);
        BOMTreeRemoveValue(v1, v19, v27, v28, v29, v30);
      }
      BOMTreeIteratorFree(i);
      BOMStorageFreeBlock(v2, **(_DWORD **)(v1 + 24), v38, v39, v40, v41, v42, v43);
      _FreePage(v1, *(void **)(v1 + 24));
      *(void *)(v1 + 24) = 0;
      uint64_t v50 = *(const char **)(v1 + 8);
      if (v50) {
        BOMStorageFreeNamedBlock(v2, v50);
      }
      else {
        BOMStorageFreeBlock(v2, *(_DWORD *)(v1 + 16), v44, v45, v46, v47, v48, v49);
      }
      uint64_t v51 = *(void **)(v1 + 8);
      if (v51 && (*(unsigned char *)(v1 + 356) & 0x20) != 0)
      {
        free(v51);
        *(void *)(v1 + 8) = 0;
      }
      uint64_t v52 = *(const void **)(v1 + 296);
      if (v52) {
        CFRelease(v52);
      }
      free((void *)v1);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMTreeRemoveValue(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = 1;
  if (a1)
  {
    if (a2)
    {
      int v8 = *(_DWORD *)(a1 + 356);
      if (a3 || (v8 & 4) != 0)
      {
        if ((v8 & 2) != 0)
        {
          uint64_t v9 = *(void *)(a1 + 24);
          uint64_t result = _findRemove(a1, &v9, 0, 0, 0, 0, a2, a3, 0);
          if (!result)
          {
            --*(_DWORD *)(a1 + 20);
            *(_DWORD *)(a1 + 356) |= 1u;
          }
        }
        else
        {
          _CUILog(4, (uint64_t)"%s BOMTree '%s' is read-only can't remove value", a3, a4, a5, a6, (uint64_t)a2, a3, (uint64_t)"int BOMTreeRemoveValue(BOMTree, void *, size_t)");
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t (*_WritePage(uint64_t a1, uint64_t a2))(void *)
{
  size_t v4 = *(unsigned int *)(a1 + 304);
  if ((*(unsigned char *)(a1 + 356) & 4) == 0)
  {
    int v5 = *(_DWORD *)(a1 + 348);
    if (v5 >= 1) {
      v4 += v5 * (unint64_t)*(unsigned __int16 *)(a2 + 16);
    }
  }
  uint64_t result = (uint64_t (*)(void *))BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)a2, v4, 1);
  if (result)
  {
    uint64_t v13 = result;
    BOMStreamWriteUInt16(result, *(_WORD *)(a2 + 4) & 1, v7, v8, v9, v10, v11, v12);
    BOMStreamWriteUInt16(v13, *(unsigned __int16 *)(a2 + 16), v14, v15, v16, v17, v18, v19);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a2 + 8), v20, v21, v22, v23, v24, v25);
    BOMStreamWriteUInt32(v13, *(unsigned int *)(a2 + 12), v26, v27, v28, v29, v30, v31);
    if (*(_WORD *)(a2 + 16))
    {
      uint64_t v38 = 0;
      unint64_t v39 = 0;
      do
      {
        BOMStreamWriteUInt32(v13, *(unsigned int *)(*(void *)(a2 + 24) + v38), v32, v33, v34, v35, v36, v37);
        BOMStreamWriteUInt32(v13, *(unsigned int *)(*(void *)(a2 + 24) + v38 + 4), v40, v41, v42, v43, v44, v45);
        ++v39;
        unint64_t v46 = *(unsigned __int16 *)(a2 + 16);
        v38 += 8;
      }
      while (v39 < v46);
    }
    else
    {
      unint64_t v46 = 0;
    }
    BOMStreamWriteUInt32(v13, *(unsigned int *)(*(void *)(a2 + 24) + 8 * v46), v32, v33, v34, v35, v36, v37);
    if ((*(unsigned char *)(a1 + 356) & 4) == 0)
    {
      size_t v54 = *(unsigned int *)(a1 + 348);
      if ((int)v54 >= 1)
      {
        uint64_t v61 = BOM_malloc(v54);
        if (*(_WORD *)(a2 + 16))
        {
          unint64_t v62 = 0;
          uint64_t v63 = 4;
          do
          {
            if (BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(a2 + 24) + v63), v55, v56, v57, v58, v59, v60) != *(_DWORD *)(a1 + 348))
            {
              long long v76 = BOMExceptionHandlerMessage("%s blockSize %d != tree->keySize %d", v64, v65, v66, v67, v68, v69, v70, (char)"_WritePage");
              long long v77 = __error();
              _BOMFatalException(v76, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 1408, *v77);
            }
            BOMStorageCopyFromBlock(*(void *)a1, *(_DWORD *)(*(void *)(a2 + 24) + v63), v61, v66, v67, v68, v69, v70);
            BOMStreamWriteBuffer((uint64_t)v13, v61, *(int *)(a1 + 348), v71, v72, v73, v74, v75);
            ++v62;
            v63 += 8;
          }
          while (v62 < *(unsigned __int16 *)(a2 + 16));
        }
        free(v61);
      }
    }
    uint64_t result = (uint64_t (*)(void *))BOMStreamFree((uint64_t)v13, v47, v48, v49, v50, v51, v52, v53);
    *(_WORD *)(a2 + 4) &= ~2u;
  }
  return result;
}

uint64_t BOMTreeSetValue(uint64_t a1, void *a2, unint64_t a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v42 = 0;
  uint64_t v8 = 1;
  if (a1)
  {
    if (a2)
    {
      int v14 = *(_DWORD *)(a1 + 356);
      if (a3 || (v14 & 4) != 0)
      {
        if ((v14 & 2) == 0)
        {
          _CUILog(4, (uint64_t)"%s: BOMTree '%s' is read-only tree can't update values", a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"int BOMTreeSetValue(BOMTree, void *, size_t, void *, size_t)");
          return v8;
        }
        uint64_t v15 = BOMStackNew();
        if (!_findPagesForKey(a1, (char *)v15, a2, a3, v16, v17, v18, v19))
        {
          BOMStackFree(v15);
          return v8;
        }
        if (v15)
        {
          if ((*(unsigned char *)(a1 + 356) & 4) != 0)
          {
            int v31 = (int)a2;
          }
          else
          {
            uint64_t v20 = BOMStackPeek(v15);
            if (!v20)
            {
              int v33 = 0;
              goto LABEL_27;
            }
            uint64_t v24 = v20;
            unsigned int IndexForKey = _findIndexForKey(a1, (uint64_t)v20, a2, a3, &v42, v21, v22, v23);
            if (v42)
            {
              uint64_t v30 = (unsigned int *)(v24[3] + 8 * IndexForKey);
              uint64_t v32 = *v30;
              int v31 = v30[1];
              if (v32)
              {
LABEL_17:
                if (!BOMStorageCopyToBlock(*(void *)a1, v32, a4, a5, v26, v27, v28, v29)
                  && !_PageSetValue(a1, (uint64_t *)v15, a2, a3, v31, v32))
                {
                  if (!v42) {
                    ++*(_DWORD *)(a1 + 20);
                  }
                  uint64_t v8 = 0;
                  *(_DWORD *)(a1 + 356) |= 1u;
                  int v33 = 1;
LABEL_27:
                  while (!BOMStackIsEmpty((uint64_t)v15))
                  {
                    unint64_t v39 = BOMStackPop((uint64_t *)v15);
                    *((_WORD *)v39 + 2) &= ~8u;
                  }
                  BOMStackFree(v15);
                  if (v33)
                  {
                    if ((*(unsigned char *)(a1 + 356) & 4) == 0)
                    {
                      int v40 = *(_DWORD *)(a1 + 348);
                      if (v40 != -1)
                      {
                        if (!v40)
                        {
                          uint64_t v8 = 0;
                          *(_DWORD *)(a1 + 348) = a3;
                          return v8;
                        }
                        if (v40 != a3)
                        {
                          uint64_t v8 = 0;
                          *(_DWORD *)(a1 + 348) = -1;
                          return v8;
                        }
                      }
                    }
                    return 0;
                  }
                  return v8;
                }
LABEL_25:
                int v33 = 0;
                uint64_t v8 = 1;
                goto LABEL_27;
              }
            }
            else
            {
              uint64_t v34 = BOMStorageNewBlock(*(void *)a1);
              if (!v34) {
                goto LABEL_25;
              }
              int v31 = v34;
              if (BOMStorageCopyToBlock(*(void *)a1, v34, a2, a3, v35, v36, v37, v38)) {
                goto LABEL_25;
              }
            }
          }
          uint64_t v32 = BOMStorageNewBlock(*(void *)a1);
          if (!v32) {
            goto LABEL_25;
          }
          goto LABEL_17;
        }
      }
    }
  }
  return v8;
}

uint64_t _PageSetValue(uint64_t a1, uint64_t *a2, void *a3, unint64_t a4, int a5, int a6)
{
  BOOL v62 = 0;
  uint64_t v6 = 1;
  if (a5)
  {
    if (a6)
    {
      uint64_t v13 = BOMStackPop(a2);
      if (v13)
      {
        uint64_t v14 = (uint64_t)v13;
        BOOL v15 = (*((_WORD *)v13 + 2) & 1) == 0;
        _invalidateIteratorsForPageID(a1, *(_DWORD *)v13);
        unsigned int IndexForKey = _findIndexForKey(a1, v14, a3, a4, &v62, v16, v17, v18);
        uint64_t v20 = *(void *)(v14 + 24);
        if (v62)
        {
          unsigned __int16 v21 = *(_WORD *)(v14 + 16);
        }
        else
        {
          if (*(_DWORD *)(v20 + 8 * IndexForKey + 4))
          {
            int v22 = *(_DWORD *)(a1 + 356);
            if ((v22 & 8) != 0)
            {
              *(_DWORD *)(a1 + 356) = v22 & 0xFFFFFFF7;
              uint64_t v20 = *(void *)(v14 + 24);
            }
            int v23 = *(unsigned __int16 *)(v14 + 16);
            LODWORD(v24) = v23 - IndexForKey;
            if (v23 != IndexForKey)
            {
              if (v24 <= 1) {
                uint64_t v24 = 1;
              }
              else {
                uint64_t v24 = v24;
              }
              unsigned int v25 = v15 + v23;
              unsigned int v26 = *(unsigned __int16 *)(v14 + 16);
              do
              {
                uint64_t v27 = v20 + 8 * v26--;
                uint64_t v28 = 8 * v25--;
                int v29 = *(_DWORD *)(v20 + 8 * v25);
                *(_DWORD *)(v27 + 4) = *(_DWORD *)(v20 + 8 * v26 + 4);
                *(_DWORD *)(v20 + v28) = v29;
                --v24;
              }
              while (v24);
            }
          }
          else
          {
            LOWORD(v23) = *(_WORD *)(v14 + 16);
          }
          *(_DWORD *)(v20 + 8 * IndexForKey + 4) = a5;
          unsigned __int16 v21 = v23 + 1;
          *(_WORD *)(v14 + 16) = v23 + 1;
        }
        *(_DWORD *)(v20 + 8 * (IndexForKey + v15)) = a6;
        *(_WORD *)(v14 + 4) |= 2u;
        if (*(_DWORD *)(a1 + 308) >= v21)
        {
          uint64_t v6 = 0;
        }
        else
        {
          uint64_t v30 = _NewPage(a1, 0);
          if (v30)
          {
            uint64_t v37 = (unsigned int *)v30;
            *((_WORD *)v30 + 2) = *((_WORD *)v30 + 2) & 0xFFFC | *(_WORD *)(v14 + 4) & 1 | 2;
            if ((*(_WORD *)(v14 + 4) & 1) == 0
              || (int v38 = *(_DWORD *)v30,
                  int v39 = *(_DWORD *)v14,
                  *((_DWORD *)v30 + 2) = *(_DWORD *)(v14 + 8),
                  *(_DWORD *)(v14 + 8) = v38,
                  *((_DWORD *)v30 + 3) = v39,
                  (int v40 = *((_DWORD *)v30 + 2)) == 0))
            {
LABEL_25:
              if ((*(unsigned char *)(a1 + 356) & 8) != 0)
              {
                LODWORD(v43) = *(_DWORD *)(a1 + 308) - 1;
                unsigned int v42 = *(unsigned __int16 *)(v14 + 16);
              }
              else
              {
                unsigned int v42 = *(unsigned __int16 *)(v14 + 16);
                LODWORD(v43) = v42 >> 1;
              }
              uint64_t v44 = *(void *)(v14 + 24);
              uint64_t v45 = *((void *)v37 + 3);
              if ((int)v43 + 1 >= (int)v42)
              {
                unsigned __int16 v47 = *((_WORD *)v37 + 8);
                uint64_t v43 = (int)v43;
                uint64_t v49 = v42;
              }
              else
              {
                uint64_t v43 = (int)v43;
                uint64_t v46 = (int)v43 + 1;
                unsigned __int16 v47 = *((_WORD *)v37 + 8);
                do
                {
                  uint64_t v48 = (void *)(v44 + 8 * v46);
                  *(void *)(v45 + 8 * v47++) = *v48;
                  *((_WORD *)v37 + 8) = v47;
                  *uint64_t v48 = 0;
                  ++v46;
                  uint64_t v49 = *(unsigned __int16 *)(v14 + 16);
                }
                while (v46 < v49);
                LOWORD(v42) = *(_WORD *)(v14 + 16);
              }
              uint64_t v50 = 8 * v49;
              *(_DWORD *)(v45 + 8 * v47) = *(_DWORD *)(v44 + v50);
              *(_DWORD *)(v44 + v50) = 0;
              *(_WORD *)(v14 + 16) = v42 - v47;
              uint64_t v51 = v44 + 8 * v43;
              unsigned int v54 = *(_DWORD *)(v51 + 4);
              uint64_t v52 = (_DWORD *)(v51 + 4);
              uint64_t v53 = v54;
              if ((*(unsigned char *)(v14 + 4) & 1) == 0)
              {
                *uint64_t v52 = 0;
                *(_WORD *)(v14 + 16) = v42 - v47 - 1;
              }
              _addPageToCache(a1, (uint64_t)v37);
              if (BOMStackIsEmpty((uint64_t)a2))
              {
                uint64_t v55 = _NewPage(a1, 0);
                uint64_t v6 = 1;
                if (v55)
                {
                  uint64_t v56 = v55;
                  uint64_t v57 = (_DWORD *)v55[3];
                  *uint64_t v57 = *(_DWORD *)v14;
                  v57[1] = v53;
                  v57[2] = *v37;
                  *((_WORD *)v55 + 8) = 1;
                  *((_WORD *)v55 + 2) |= 2u;
                  _addPageToCache(a1, v14);
                  uint64_t v6 = 0;
                  *(void *)(a1 + 24) = v56;
                }
              }
              else
              {
                uint64_t v6 = _PageSetValue(a1, a2, a3, a4, v53, *v37);
              }
              goto LABEL_44;
            }
            Page = _findPage(a1, v40, v31, v32, v33, v34, v35, v36);
            if (Page)
            {
              if (*((_DWORD *)Page + 3) == *(_DWORD *)v14)
              {
                *((_DWORD *)Page + 3) = *v37;
                *((_WORD *)Page + 2) |= 2u;
                goto LABEL_25;
              }
              int v58 = *__error();
              uint64_t v59 = "internal btree error";
              uint64_t v6 = 1;
              int v60 = 2201;
            }
            else
            {
              int v58 = *__error();
              uint64_t v59 = "missing tree page";
              uint64_t v6 = 1;
              int v60 = 2197;
            }
            _BOMExceptionHandlerCall(v59, 1u, "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", v60, v58);
          }
          else
          {
            uint64_t v6 = 1;
          }
        }
LABEL_44:
        *(_WORD *)(v14 + 4) &= ~8u;
      }
    }
  }
  return v6;
}

uint64_t _findRemove(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, unint64_t a8, char *a9)
{
  uint64_t v11 = a6;
  uint64_t v14 = a2;
  uint64_t v15 = a1;
  uint64_t v16 = a9;
  BOOL v97 = 0;
  uint64_t v17 = *a2;
  uint64_t v96 = 0;
  char v95 = 0;
  if (!a9) {
    uint64_t v16 = &v95;
  }
  uint64_t v94 = v16;
  unsigned int IndexForKey = _findIndexForKey(a1, v17, a7, a8, &v97, a6, (uint64_t)a7, a8);
  unsigned int v25 = IndexForKey;
  *(_DWORD *)(v17 + 20) = IndexForKey;
  if (*(unsigned char *)(v17 + 4))
  {
    BOOL v29 = v97;
    uint64_t result = 1;
    if (!v97) {
      return result;
    }
LABEL_42:
    if (v29)
    {
      _invalidateIteratorsForPageID(v15, *(_DWORD *)v17);
LABEL_45:
      unsigned int v39 = *(unsigned __int16 *)(v17 + 16);
      uint64_t v40 = *(void *)(v17 + 24);
      LODWORD(v41) = v39 - v25;
      if (v39 == v25)
      {
        unsigned int v42 = 0;
        unsigned int v43 = 0;
        *(_DWORD *)(v40 + 8 * (v25 - 1) + 4) = 0;
      }
      else
      {
        uint64_t v44 = (unsigned int *)(v40 + 8 * v25);
        unsigned int v43 = *v44;
        unsigned int v42 = v44[1];
        if (v41 <= 1) {
          uint64_t v41 = 1;
        }
        else {
          uint64_t v41 = v41;
        }
        unsigned int v45 = v25;
        do
        {
          *(void *)(v40 + 8 * v45) = *(void *)(v40 + 8 * (v45 + 1));
          ++v45;
          --v41;
        }
        while (v41);
      }
      *(_DWORD *)(v40 + 8 * v39) = 0;
      *(_WORD *)(v17 + 16) = v39 - 1;
      if (*(_WORD *)(v17 + 4))
      {
        if ((*(unsigned char *)(v15 + 356) & 4) == 0 && v42) {
          BOMStorageFreeBlock(*(void *)v15, v42, v19, v20, v21, v22, v23, v24);
        }
        if (v43) {
          BOMStorageFreeBlock(*(void *)v15, v43, v19, v20, v21, v22, v23, v24);
        }
      }
      __int16 v46 = *(_WORD *)(v17 + 4);
      *(_WORD *)(v17 + 4) = v46 | 2;
      unsigned int v47 = *(unsigned __int16 *)(v17 + 16);
      if ((v46 & 1) != 0 && v11 && v25 == v47)
      {
        *(_DWORD *)(*(void *)(v11 + 24) + 8 * *(unsigned int *)(v11 + 20) + 4) = *(_DWORD *)(*(void *)(v17 + 24)
                                                                                               + 8 * (v25 - 1)
                                                                                               + 4);
        *(_WORD *)(v11 + 4) |= 2u;
        unsigned int v47 = *(unsigned __int16 *)(v17 + 16);
      }
      unsigned int v48 = *(_DWORD *)(v15 + 316);
      if (v48 <= v47)
      {
        uint64_t result = 0;
        *uint64_t v94 = 0;
        return result;
      }
      if (v17 != *(void *)(v15 + 24))
      {
        uint64_t v49 = (_WORD *)*v14;
        if (!(a3 | a4))
        {
LABEL_111:
          uint64_t result = 0;
          *uint64_t v14 = (uint64_t)v49;
          return result;
        }
        uint64_t v89 = a3;
        uint64_t v91 = v14;
        if (a3) {
          uint64_t v50 = a3;
        }
        else {
          uint64_t v50 = a4;
        }
        uint64_t v51 = a5;
        if (!a3) {
          uint64_t v51 = v11;
        }
        if (a4) {
          BOOL v52 = a3 != 0;
        }
        else {
          BOOL v52 = 0;
        }
        BOOL v88 = v52;
        if (v52)
        {
          unsigned int v53 = *(unsigned __int16 *)(a3 + 16);
          unsigned int v54 = *(unsigned __int16 *)(a4 + 16);
          if (v53 >= v54)
          {
            if (v53 <= v54)
            {
              int v63 = *(_DWORD *)(*(void *)(v11 + 24) + 8 * *(unsigned int *)(v11 + 20));
              if (*(_DWORD *)v49 == v63) {
                uint64_t v50 = a4;
              }
              else {
                uint64_t v50 = a3;
              }
              if (*(_DWORD *)v49 != v63) {
                uint64_t v11 = a5;
              }
            }
            else
            {
              uint64_t v50 = a3;
              uint64_t v11 = a5;
            }
          }
          else
          {
            uint64_t v50 = a4;
          }
        }
        else
        {
          uint64_t v11 = v51;
        }
        unsigned int v64 = *(unsigned __int16 *)(v50 + 16);
        uint64_t v65 = a4;
        BOOL v66 = v50 == a4;
        BOOL v67 = v50 == a4;
        if (v66) {
          uint64_t v68 = (_WORD *)*v14;
        }
        else {
          uint64_t v68 = (_WORD *)v50;
        }
        if (v49[2]) {
          _invalidateIteratorsForPageID(v15, *(_DWORD *)v50);
        }
        uint64_t v69 = v11;
        int v70 = *(_DWORD *)(v11 + 20) - (v50 != v65);
        if ((v68[2] & 1) == 0)
        {
          uint64_t v71 = (unsigned __int16)v68[8];
          *(_DWORD *)(*((void *)v68 + 3) + 8 * v71 + 4) = *(_DWORD *)(*(void *)(v69 + 24) + 8 * v70 + 4);
          v68[8] = v71 + 1;
          v68[2] |= 2u;
        }
        if (v48 < v64)
        {
          _shiftKeysAndValues(v15, (uint64_t)v49, v50, v67);
          int v72 = *(_DWORD *)(*((void *)v68 + 3) + 8 * (unsigned __int16)v68[8] - 4);
          uint64_t v73 = *(void *)(v69 + 24) + 8 * v70;
          int v75 = *(_DWORD *)(v73 + 4);
          uint64_t v74 = (_DWORD *)(v73 + 4);
          if (v75 != v72)
          {
            *uint64_t v74 = v72;
            *(_WORD *)(v69 + 4) |= 2u;
          }
          uint64_t v14 = v91;
          char v76 = 0;
          if ((v68[2] & 1) == 0)
          {
            unsigned __int16 v77 = v68[8] - 1;
            v68[8] = v77;
            *(_DWORD *)(*((void *)v68 + 3) + 8 * v77 + 4) = 0;
            v68[2] |= 2u;
          }
          goto LABEL_110;
        }
        _shiftKeysAndValues(v15, v50, (uint64_t)v49, v50 != v65);
        if (v88)
        {
          uint64_t v14 = v91;
          *(_DWORD *)(v89 + 8) = *(_DWORD *)v65;
          *(_DWORD *)(v65 + 12) = *(_DWORD *)v89;
          *(_WORD *)(v89 + 4) |= 2u;
        }
        else if (v89)
        {
          *(_DWORD *)(v89 + 8) = 0;
          uint64_t v65 = v89;
          uint64_t v14 = v91;
        }
        else
        {
          uint64_t v14 = v91;
          if (!v65)
          {
LABEL_109:
            v49[2] &= ~8u;
            _removePageFromCache(v15, v49);
            BOMStorageFreeBlock(*(void *)v15, *(_DWORD *)v49, v78, v79, v80, v81, v82, v83);
            _FreePage(v15, v49);
            uint64_t v49 = 0;
            char v76 = 1;
LABEL_110:
            *uint64_t v94 = v76;
            goto LABEL_111;
          }
          *(_DWORD *)(v65 + 12) = 0;
        }
        *(_WORD *)(v65 + 4) |= 2u;
        goto LABEL_109;
      }
      if (!(*(_WORD *)(v17 + 4) & 1 | v47))
      {
        int v55 = **(_DWORD **)(v17 + 24);
        if (v55)
        {
          Page = _findPage(v15, v55, v19, v20, v21, v22, v23, v24);
          Page[2] &= ~8u;
          _removePageFromCache(v15, Page);
          *(void *)(v15 + 24) = Page;
          BOMStorageFreeBlock(*(void *)v15, *(_DWORD *)v17, v57, v58, v59, v60, v61, v62);
          _FreePage(v15, (void *)v17);
        }
      }
      return 0;
    }
LABEL_44:
    if (!*v94) {
      return 0;
    }
    goto LABEL_45;
  }
  uint64_t v92 = v11;
  if (IndexForKey)
  {
    uint64_t v26 = v15;
    uint64_t v27 = _findPage(v15, *(_DWORD *)(*(void *)(v17 + 24) + 8 * (IndexForKey - 1)), v19, v20, v21, v22, v23, v24);
    __int16 v28 = *((_WORD *)v27 + 2);
    if ((v28 & 8) == 0)
    {
      uint64_t v85 = v17;
LABEL_12:
      char v31 = 0;
      *((_WORD *)v27 + 2) = v28 | 8;
      goto LABEL_16;
    }
    char v31 = 1;
    uint64_t v85 = v17;
  }
  else if (a3)
  {
    uint64_t v26 = v15;
    uint64_t v27 = _findPage(v15, *(_DWORD *)(*(void *)(a3 + 24) + 8 * *(unsigned __int16 *)(a3 + 16)), v19, v20, v21, v22, v23, v24);
    __int16 v28 = *((_WORD *)v27 + 2);
    if ((v28 & 8) == 0)
    {
      uint64_t v85 = a5;
      goto LABEL_12;
    }
    char v31 = 1;
    uint64_t v85 = a5;
  }
  else
  {
    uint64_t v26 = v15;
    uint64_t v85 = 0;
    uint64_t v27 = 0;
    char v31 = 1;
  }
LABEL_16:
  uint64_t v90 = v14;
  unint64_t v87 = a8;
  uint64_t v86 = a7;
  if (v25 == *(unsigned __int16 *)(v17 + 16))
  {
    if (a4)
    {
      uint64_t v32 = _findPage(v26, **(_DWORD **)(a4 + 24), v19, v20, v21, v22, v23, v24);
      __int16 v33 = *((_WORD *)v32 + 2);
      if ((v33 & 8) == 0)
      {
        uint64_t v34 = v92;
LABEL_22:
        char v35 = 0;
        *((_WORD *)v32 + 2) = v33 | 8;
        goto LABEL_26;
      }
      char v35 = 1;
      uint64_t v34 = v92;
    }
    else
    {
      uint64_t v34 = 0;
      uint64_t v32 = 0;
      char v35 = 1;
    }
  }
  else
  {
    uint64_t v32 = _findPage(v26, *(_DWORD *)(*(void *)(v17 + 24) + 8 * (v25 + 1)), v19, v20, v21, v22, v23, v24);
    __int16 v33 = *((_WORD *)v32 + 2);
    if ((v33 & 8) == 0)
    {
      uint64_t v34 = v17;
      goto LABEL_22;
    }
    char v35 = 1;
    uint64_t v34 = v17;
  }
LABEL_26:
  uint64_t v36 = _findPage(v26, *(_DWORD *)(*(void *)(v17 + 24) + 8 * v25), v19, v20, v21, v22, v23, v24);
  uint64_t v96 = v36;
  if (!v36)
  {
    uint64_t v84 = __error();
    _BOMFatalException("BOMTree in invalid state - nextNode is NULL!", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 1810, *v84);
  }
  uint64_t v37 = v34;
  __int16 v38 = *((_WORD *)v36 + 2);
  if ((v38 & 8) == 0) {
    *((_WORD *)v36 + 2) = v38 | 8;
  }
  if (a3) {
    *(_WORD *)(a3 + 4) &= ~4u;
  }
  if (a4) {
    *(_WORD *)(a4 + 4) &= ~4u;
  }
  *((_WORD *)v36 + 2) &= ~4u;
  uint64_t result = _findRemove(v26, &v96, v27, v32, v85, v37, v86, v87, v94);
  if ((v31 & 1) == 0) {
    *((_WORD *)v27 + 2) &= ~8u;
  }
  if ((v35 & 1) == 0) {
    *((_WORD *)v32 + 2) &= ~8u;
  }
  uint64_t v15 = v26;
  if ((v38 & 8) == 0 && v96) {
    *((_WORD *)v96 + 2) &= ~8u;
  }
  uint64_t v14 = v90;
  uint64_t v11 = v92;
  if (!result)
  {
    BOOL v29 = v97;
    if ((*(_WORD *)(v17 + 4) & 1) == 0) {
      goto LABEL_44;
    }
    goto LABEL_42;
  }
  return result;
}

uint64_t BOMTreeIteratorValueSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (*(unsigned char *)(a1 + 57) & 8) != 0) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 57) & 1) != 0 || (uint64_t v9 = *(void *)(a1 + 8)) == 0 || *(_DWORD *)v9 != *(_DWORD *)(a1 + 16))
  {
    if (_revalidateIterator(a1, a2, a3, a4, a5, a6, a7, a8))
    {
      uint64_t v9 = *(void *)(a1 + 8);
      goto LABEL_8;
    }
    *(unsigned char *)(a1 + 57) |= 8u;
    return 0;
  }
LABEL_8:
  uint64_t v10 = **(void **)a1;
  unsigned int v11 = *(_DWORD *)(*(void *)(v9 + 24) + 8 * *(int *)(a1 + 20));
  unsigned int v12 = bswap32(v11);
  if ((*(_DWORD *)(*(void *)a1 + 356) & 0x40) != 0) {
    unsigned int v13 = v12;
  }
  else {
    unsigned int v13 = v11;
  }
  return BOMStorageSizeOfBlock(v10, v13, a3, a4, a5, a6, a7, a8);
}

uint64_t BOMTreeUsesNumericKeys(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 356) >> 2) & 1;
}

uint64_t BOMTreePageSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 304);
}

void _invalidateIteratorsForPageID(uint64_t a1, unsigned int a2)
{
  CFArrayRef v3 = *(const __CFArray **)(a1 + 296);
  if (v3)
  {
    CFIndex v5 = BOMCFArrayMaxRange(v3);
    CFIndex v7 = v6;
    CFArrayRef v8 = *(const __CFArray **)(a1 + 296);
    v9.location = v5;
    v9.CFIndex length = v7;
    CFArrayApplyFunction(v8, v9, (CFArrayApplierFunction)_invalidateIterator, (void *)a2);
  }
}

void _addPageToCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 8 * *(int *)(a1 + 288);
  CFIndex v6 = *(_WORD **)(v3 + 32);
  size_t v4 = (void *)(v3 + 32);
  CFIndex v5 = v6;
  if (v6)
  {
    while (1)
    {
      __int16 v8 = v5[2];
      if ((v8 & 0xC) == 4) {
        break;
      }
      v5[2] = v8 | 4;
      int v9 = *(_DWORD *)(a1 + 288) + 1;
      BOOL v10 = -v9 < 0;
      int v11 = -v9 & 0x1F;
      int v12 = v9 & 0x1F;
      if (!v10) {
        int v12 = -v11;
      }
      *(_DWORD *)(a1 + 288) = v12;
      uint64_t v13 = a1 + 8 * v12;
      uint64_t v14 = *(_WORD **)(v13 + 32);
      size_t v4 = (void *)(v13 + 32);
      CFIndex v5 = v14;
      if (!v14) {
        goto LABEL_10;
      }
    }
    if ((v8 & 2) != 0) {
      _WritePage(a1, (uint64_t)v5);
    }
    _FreePage(a1, v5);
    size_t v4 = (void *)(a1 + 8 * *(int *)(a1 + 288) + 32);
  }
LABEL_10:
  *size_t v4 = a2;
}

uint64_t _invalidateIterator(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if (*(_DWORD *)(result + 16) == a2 && (*(unsigned char *)(result + 57) & 9) == 0)
    {
      uint64_t result = *(void *)(result + 8);
      if (!result || *(_DWORD *)result != a2)
      {
        uint64_t result = (uint64_t)_findPage(*(void *)v8, a2, a3, a4, a5, a6, a7, a8);
        *(void *)(v8 + 8) = result;
        if (!result) {
          goto LABEL_27;
        }
      }
      uint64_t v9 = *(void *)v8;
      int v10 = *(_DWORD *)(*(void *)v8 + 356);
      if ((v10 & 4) != 0)
      {
        unsigned int v12 = *(_DWORD *)(*(void *)(result + 24) + 8 * *(int *)(v8 + 20) + 4);
        unsigned int v13 = bswap32(v12);
        if ((v10 & 0x40) != 0) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = v12;
        }
        *(void *)(v8 + 24) = v14;
        *(void *)(v8 + 32) = 0;
        goto LABEL_27;
      }
      if ((v10 & 0x40) != 0)
      {
        size_t v15 = *(unsigned int *)(v9 + 348);
        if ((int)v15 >= 1)
        {
LABEL_17:
          *(void *)(v8 + 32) = v15;
          uint64_t v16 = *(void **)(v8 + 24);
          if (v16)
          {
            free(v16);
            *(void *)(v8 + 24) = 0;
            size_t v15 = *(void *)(v8 + 32);
          }
          uint64_t v17 = BOM_malloc(v15);
          *(void *)(v8 + 24) = v17;
          if (!v17)
          {
            __int16 v28 = __error();
            _BOMFatalException("BOMTree iterator cannot cache keys. This is a fatal error (!it->key).", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2773, *v28);
          }
          uint64_t v23 = *(void *)v8;
          if ((*(unsigned char *)(*(void *)v8 + 356) & 0x40) != 0)
          {
            size_t v25 = *(unsigned int *)(v23 + 348);
            uint64_t v26 = *(void *)(v8 + 8);
            if ((int)v25 >= 1)
            {
              uint64_t v27 = *(void *)(v26 + 32);
              if (!v27)
              {
                uint64_t v30 = __error();
                _BOMFatalException("BOMTree iterator cannot cache keys. This is a fatal error (__getKeyIDValuePTR return 0).", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2781, *v30);
              }
              uint64_t result = (uint64_t)memcpy(v17, (const void *)(v27 + *(int *)(v8 + 20) * v25), v25);
              goto LABEL_27;
            }
            unsigned int v24 = bswap32(*(_DWORD *)(*(void *)(v26 + 24) + 8 * *(int *)(v8 + 20) + 4));
          }
          else
          {
            unsigned int v24 = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 24) + 8 * *(int *)(v8 + 20) + 4);
          }
          uint64_t result = BOMStorageCopyFromBlock(*(void *)v23, v24, v17, v18, v19, v20, v21, v22);
          if (result)
          {
            BOOL v29 = __error();
            _BOMFatalException("BOMTree iterator cannot cache keys. This is a fatal error (BOMStorageCopyFromBlock returned an error).", "/Library/Caches/com.apple.xbs/Sources/CoreUI/Bom/Storage/BOMTree.c", 2786, *v29);
          }
LABEL_27:
          *(unsigned char *)(v8 + 57) |= 1u;
          return result;
        }
        unsigned int v11 = bswap32(*(_DWORD *)(*(void *)(result + 24) + 8 * *(int *)(v8 + 20) + 4));
      }
      else
      {
        unsigned int v11 = *(_DWORD *)(*(void *)(result + 24) + 8 * *(int *)(v8 + 20) + 4);
      }
      size_t v15 = BOMStorageSizeOfBlock(*(void *)v9, v11, a3, a4, a5, a6, a7, a8);
      goto LABEL_17;
    }
  }
  return result;
}

void _removePageFromCache(uint64_t a1, _WORD *a2)
{
  if ((a2[2] & 8) == 0)
  {
    for (uint64_t i = 32; i != 288; i += 8)
    {
      if (*(_WORD **)(a1 + i) == a2)
      {
        CFArrayRef v5 = *(const __CFArray **)(a1 + 296);
        if (v5)
        {
          CFIndex v6 = BOMCFArrayMaxRange(v5);
          CFIndex v8 = v7;
          v10.location = v6;
          v10.CFIndex length = v8;
          CFArrayApplyFunction(*(CFArrayRef *)(a1 + 296), v10, (CFArrayApplierFunction)_pageRemovedCallback, a2);
        }
        *(void *)(a1 + i) = 0;
      }
    }
    if ((a2[2] & 2) != 0)
    {
      _WritePage(a1, (uint64_t)a2);
    }
  }
}

uint64_t _pageRemovedCallback(uint64_t result, uint64_t a2)
{
  if (result && a2 && *(void *)(result + 8) == a2) {
    *(void *)(result + 8) = 0;
  }
  return result;
}

uint64_t _shiftKeysAndValues(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(unsigned __int16 *)(a3 + 16);
  unsigned int v5 = *(_DWORD *)(result + 316);
  BOOL v6 = v4 >= v5;
  int v8 = v4 - v5;
  BOOL v7 = v8 != 0 && v6;
  unsigned int v9 = (v8 + 1) >> 1;
  if (v7) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = *(unsigned __int16 *)(a3 + 16);
  }
  uint64_t v11 = *(unsigned __int16 *)(a2 + 16);
  __int16 v12 = v10 + v11;
  unint64_t v13 = v4 - v10;
  if (a4)
  {
    unsigned int v14 = 0;
    if (!v10) {
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  uint64_t v15 = *(void *)(a2 + 24);
  *(_DWORD *)(v15 + 8 * (v10 + v11)) = *(_DWORD *)(v15 + 8 * v11);
  if (v11)
  {
    do
    {
      unsigned int v16 = v10 - 1 + v11--;
      *(void *)(v15 + 8 * v16) = *(void *)(v15 + 8 * v11);
    }
    while (v11);
  }
  unsigned int v14 = v4 - v10;
  if (v10)
  {
LABEL_10:
    uint64_t v17 = *(void *)(a3 + 24);
    uint64_t v18 = *(void *)(a2 + 24);
    uint64_t v11 = v11;
    unsigned int v19 = v10;
    do
    {
      *(void *)(v18 + 8 * v11) = *(void *)(v17 + 8 * v14);
      if (!a4) {
        *(void *)(v17 + 8 * v14) = 0;
      }
      ++v11;
      ++v14;
      --v19;
    }
    while (v19);
  }
LABEL_14:
  if (a4)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0 && v4 == v10)
    {
      uint64_t v20 = *(void *)(a3 + 24);
      uint64_t v21 = 8 * v14;
      *(_DWORD *)(*(void *)(a2 + 24) + 8 * v11) = *(_DWORD *)(v20 + v21);
      *(_DWORD *)(v20 + v21) = 0;
    }
    if (v4 != v10)
    {
      if (v4)
      {
        unint64_t v22 = 0;
        unint64_t v23 = v13 + v10;
        uint64_t v24 = 8 * v10;
        uint64_t v25 = 8 * v23;
        do
        {
          if (v22 >= v13)
          {
            uint64_t v26 = *(void *)(a3 + 24);
            if (v13 == v22) {
              *(void *)(v26 + 8 * v13) = *(unsigned int *)(v26 + v25);
            }
            else {
              *(void *)(v26 + 8 * v22) = 0;
            }
          }
          else
          {
            uint64_t v26 = *(void *)(a3 + 24);
            *(void *)(v26 + 8 * v22) = *(void *)(v26 + 8 * v22 + v24);
          }
          ++v22;
        }
        while (v4 != v22);
      }
      else
      {
        uint64_t v26 = *(void *)(a3 + 24);
      }
      *(_DWORD *)(v26 + 8 * v4) = 0;
    }
  }
  *(_WORD *)(a2 + 16) = v12;
  *(_WORD *)(a2 + 4) |= 2u;
  *(_WORD *)(a3 + 16) = v13;
  *(_WORD *)(a3 + 4) |= 2u;
  return result;
}

void CUIBitVectorToString_cold_1()
{
}

void _segmentForValue_cold_1()
{
}

void CUIFillRenditionKeyForCARKeyArray_cold_1()
{
}

void CUIRenditionKeySetValueForAttribute_cold_1()
{
}

void CUIRenditionKeySetValueForAttribute_cold_2()
{
}

void CUIRenditionKeySetValueForAttribute_cold_3()
{
}

void CUIFillCARKeyArrayForRenditionKey2_cold_1()
{
}

void CUIRenditionKeyCopy_cold_1()
{
}

void CUIRenditionKeyCopy_cold_2()
{
}

void CUICopyKeySignatureWithPrefix_cold_1()
{
}

void File::CopyToBuffer()
{
  __assert_rtn("CopyToBuffer", "WinFile.cpp", 130, "(_ioBufferPosition + size) <= kIOBufferSize");
}

void __CUIUncompressDeepmap2ImageData_block_invoke_cold_1()
{
  __assert_rtn("CUIUncompressDeepmap2ImageData_block_invoke", "CUIDeepmap2Compression.m", 481, "status == kDeepmap2StreamStatusEND");
}

void initMDLMaterial_cold_1()
{
}

void initMDLTexture_cold_1()
{
}

void initMDLTextureSampler_cold_1()
{
}

void initMDLMaterialProperty_cold_1()
{
}

void initMDLSubmesh_cold_1()
{
}

void CUIATECompressedDataFromBuffer_cold_1()
{
}

void __CUISubtypeFromIndex_cold_1(uint64_t a1)
{
  CUIPlatformNameForPlatform(a1);
  _CUILog(4, (uint64_t)"CoreUI: %s got a index %d that doesn't map to a known device subtype in platform %d:'%@'", v1, v2, v3, v4, v5, v6, (uint64_t)"int32_t __CUISubtypeFromIndex(CUIThemeSchemaPlatform, u_int32_t)");
  abort();
}

void CPSDLayerChannelGroup::Init()
{
  __assert_rtn("Init", "PSDLoader.cpp", 3638, "mChannelCount == kDefaultChannelCount");
}

void CPSDLayerChannelGroup::ComputeSizeForChannel()
{
}

void CPSDFile::LoadImageData()
{
}

void CPSDChannelData::LoadChannelData()
{
  __assert_rtn("LoadChannelData", "PSDLoader.cpp", 3616, "dwBytesRead == mpDataSize");
}

void CPSDImageLoad::UncompressChannelImageData()
{
}

{
  __assert_rtn("UncompressChannelImageData", "PSDLoader.cpp", 4894, "buffer");
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CPSDLayerRecord>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>,std::reverse_iterator<CPSDLayerRecord*>>(uint64_t (***a1)(void), uint64_t (***a2)(void))
{
  uint64_t v3 = a1;
  uint64_t v4 = a1;
  do
  {
    uint64_t result = (**v4)(v4);
    v4 += 61;
    v3 += 61;
  }
  while (v4 != a2);
  return result;
}

void CUIImageCompressedWithDeepmap_cold_1()
{
}

void __CUIUncompressDeepmapImageData_block_invoke_cold_1()
{
  __assert_rtn("CUIUncompressDeepmapImageData_block_invoke", "CUIDeepmapCompression.m", 438, "status == kDeepmapStreamStatusEND");
}

void initMDLMeshBufferMap_cold_1()
{
}

uint64_t CPSDAlphaChannelStream::CPSDAlphaChannelStream(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void initMDLVertexAttribute_cold_1()
{
}

void initMDLVertexBufferLayout_cold_1()
{
}

void initMDLVertexDescriptor_cold_1()
{
}

void initMDLMesh_cold_1()
{
}

void _CUIRenditionKeySetIntegerValueForAttribute_cold_1(unsigned __int16 a1)
{
  uint64_t v1 = CUIThemeAttributeNameToString(a1);
  _CUILog(4, (uint64_t)"CoreUI: Value passed for rendition key attribute out of bounds for u_int16_t identifier:'%s:%d' value:'%d'", v2, v3, v4, v5, v6, v7, (uint64_t)v1);
  __assert_rtn("_CUIRenditionKeySetIntegerValueForAttribute", "CUIRenditionKey.m", 28, "0");
}

void initMDLAsset_cold_1()
{
}

void CUICGBitmapContextCreate_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CUILog(4, (uint64_t)"CoreUI: CUICGBitmapContextCreate() called with a bogus bitmapInfo", a3, a4, a5, a6, a7, a8, vars0);
  abort();
}

void sub_1A13925E8()
{
  while (1)
    ;
}

void sub_1A13925F8()
{
  while (1)
    ;
}

void sub_1A1392608()
{
  while (1)
    ;
}

uint64_t CAColorMatrixConcat()
{
  return _CAColorMatrixConcat();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayContainsValue(theArray, range, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayGetFirstIndexOfValue(theArray, range, value);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return _CFAutorelease(arg);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return _CFCopyDescription(cf);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return _CFDataCreateMutable(allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return _CFDataCreateWithBytesNoCopy(allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return _CFDataGetMutableBytePtr(theData);
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return _CFDictionaryGetValueIfPresent(theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return _CFHash(cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return _CFReadStreamCreateWithBytesNoCopy(alloc, bytes, length, bytesDeallocator);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return _CFReadStreamOpen(stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return _CFReadStreamRead(stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return _CFStringCreateMutable(alloc, maxLength);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return _CFStringCreateWithBytes(alloc, bytes, numBytes, encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCharactersNoCopy(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return _CFStringCreateWithCharactersNoCopy(alloc, chars, numChars, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return _CFStringGetFileSystemRepresentation(string, buffer, maxBufLen);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return _CFStringGetMaximumSizeOfFileSystemRepresentation(string);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return _CFStringGetSystemEncoding();
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return _CFWriteStreamCopyProperty(stream, propertyName);
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return _CFWriteStreamCreateWithAllocatedBuffers(alloc, bufferAllocator);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return _CFWriteStreamOpen(stream);
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return _CFWriteStreamWrite(stream, buffer, bufferLength);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return _CGAffineTransformConcat(retstr, t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return _CGAffineTransformInvert(retstr, t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return _CGAffineTransformMakeScale(retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return _CGAffineTransformMakeTranslation(retstr, tx, ty);
}

uint64_t CGBitmapAllocateData()
{
  return _CGBitmapAllocateData();
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return _CGBitmapContextCreate(data, width, height, bitsPerComponent, bytesPerRow, space, bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return _CGBitmapContextCreateImage(context);
}

CGContextRef CGBitmapContextCreateWithData(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo, CGBitmapContextReleaseDataCallback releaseCallback, void *releaseInfo)
{
  return _CGBitmapContextCreateWithData(data, width, height, bitsPerComponent, bytesPerRow, space, bitmapInfo, releaseCallback, releaseInfo);
}

size_t CGBitmapContextGetBitsPerPixel(CGContextRef context)
{
  return _CGBitmapContextGetBitsPerPixel(context);
}

size_t CGBitmapContextGetBytesPerRow(CGContextRef context)
{
  return _CGBitmapContextGetBytesPerRow(context);
}

CGColorSpaceRef CGBitmapContextGetColorSpace(CGContextRef context)
{
  return _CGBitmapContextGetColorSpace(context);
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  return _CGBitmapContextGetData(context);
}

size_t CGBitmapContextGetHeight(CGContextRef context)
{
  return _CGBitmapContextGetHeight(context);
}

size_t CGBitmapContextGetWidth(CGContextRef context)
{
  return _CGBitmapContextGetWidth(context);
}

uint64_t CGBitmapFreeData()
{
  return _CGBitmapFreeData();
}

uint64_t CGBitmapGetAlignedBytesPerRow()
{
  return _CGBitmapGetAlignedBytesPerRow();
}

uint64_t CGBlt_copyBytes()
{
  return _CGBlt_copyBytes();
}

uint64_t CGBlt_fillBytes()
{
  return _CGBlt_fillBytes();
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return _CGColorCreate(space, components);
}

CGColorRef CGColorCreateCopy(CGColorRef color)
{
  return _CGColorCreateCopy(color);
}

CGColorRef CGColorCreateCopyByMatchingToColorSpace(CGColorSpaceRef a1, CGColorRenderingIntent intent, CGColorRef color, CFDictionaryRef options)
{
  return _CGColorCreateCopyByMatchingToColorSpace(a1, intent, color, options);
}

CGColorRef CGColorCreateCopyWithAlpha(CGColorRef color, CGFloat alpha)
{
  return _CGColorCreateCopyWithAlpha(color, alpha);
}

CGColorRef CGColorCreateSRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  return _CGColorCreateSRGB(red, green, blue, alpha);
}

CGColorRef CGColorCreateWithPattern(CGColorSpaceRef space, CGPatternRef pattern, const CGFloat *components)
{
  return _CGColorCreateWithPattern(space, pattern, components);
}

BOOL CGColorEqualToColor(CGColorRef color1, CGColorRef color2)
{
  return _CGColorEqualToColor(color1, color2);
}

CGFloat CGColorGetAlpha(CGColorRef color)
{
  return _CGColorGetAlpha(color);
}

CGColorSpaceRef CGColorGetColorSpace(CGColorRef color)
{
  return _CGColorGetColorSpace(color);
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  return _CGColorGetComponents(color);
}

CGColorRef CGColorGetConstantColor(CFStringRef colorName)
{
  return _CGColorGetConstantColor(colorName);
}

size_t CGColorGetNumberOfComponents(CGColorRef color)
{
  return _CGColorGetNumberOfComponents(color);
}

CFTypeID CGColorGetTypeID(void)
{
  return _CGColorGetTypeID();
}

void CGColorRelease(CGColorRef color)
{
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return _CGColorRetain(color);
}

CFDataRef CGColorSpaceCopyICCData(CGColorSpaceRef space)
{
  return _CGColorSpaceCopyICCData(space);
}

CGColorSpaceRef CGColorSpaceCreateDeviceGray(void)
{
  return _CGColorSpaceCreateDeviceGray();
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return _CGColorSpaceCreateDeviceRGB();
}

CGColorSpaceRef CGColorSpaceCreateICCBased(size_t nComponents, const CGFloat *range, CGDataProviderRef profile, CGColorSpaceRef alternate)
{
  return _CGColorSpaceCreateICCBased(nComponents, range, profile, alternate);
}

CGColorSpaceRef CGColorSpaceCreatePattern(CGColorSpaceRef baseSpace)
{
  return _CGColorSpaceCreatePattern(baseSpace);
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return _CGColorSpaceCreateWithName(name);
}

uint64_t CGColorSpaceEqualToColorSpace()
{
  return _CGColorSpaceEqualToColorSpace();
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return _CGColorSpaceGetModel(space);
}

CFStringRef CGColorSpaceGetName(CGColorSpaceRef space)
{
  return _CGColorSpaceGetName(space);
}

size_t CGColorSpaceGetNumberOfComponents(CGColorSpaceRef space)
{
  return _CGColorSpaceGetNumberOfComponents(space);
}

BOOL CGColorSpaceIsWideGamutRGB(CGColorSpaceRef a1)
{
  return _CGColorSpaceIsWideGamutRGB(a1);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
}

CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space)
{
  return _CGColorSpaceRetain(space);
}

uint64_t CGColorTransformConvertColor()
{
  return _CGColorTransformConvertColor();
}

uint64_t CGColorTransformCreate()
{
  return _CGColorTransformCreate();
}

uint64_t CGColorTransformRelease()
{
  return _CGColorTransformRelease();
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
}

void CGContextAddPath(CGContextRef c, CGPathRef path)
{
}

void CGContextAddRect(CGContextRef c, CGRect rect)
{
}

void CGContextBeginPath(CGContextRef c)
{
}

void CGContextBeginTransparencyLayer(CGContextRef c, CFDictionaryRef auxiliaryInfo)
{
}

void CGContextClearRect(CGContextRef c, CGRect rect)
{
}

void CGContextClip(CGContextRef c)
{
}

void CGContextClipToRect(CGContextRef c, CGRect rect)
{
}

void CGContextClipToRects(CGContextRef c, const CGRect *rects, size_t count)
{
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
}

CGRect CGContextConvertRectToDeviceSpace(CGContextRef c, CGRect rect)
{
  return _CGContextConvertRectToDeviceSpace(c, rect);
}

CGRect CGContextConvertRectToUserSpace(CGContextRef c, CGRect rect)
{
  return _CGContextConvertRectToUserSpace(c, rect);
}

CGPathRef CGContextCopyPath(CGContextRef c)
{
  return _CGContextCopyPath(c);
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
}

uint64_t CGContextDrawImages()
{
  return _CGContextDrawImages();
}

void CGContextDrawLinearGradient(CGContextRef c, CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)
{
}

void CGContextDrawPDFPage(CGContextRef c, CGPDFPageRef page)
{
}

void CGContextDrawRadialGradient(CGContextRef c, CGGradientRef gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options)
{
}

uint64_t CGContextDrawSVGDocument()
{
  return _CGContextDrawSVGDocument();
}

uint64_t CGContextDrawSVGNode()
{
  return _CGContextDrawSVGNode();
}

void CGContextDrawShading(CGContextRef c, CGShadingRef shading)
{
}

void CGContextEOFillPath(CGContextRef c)
{
}

void CGContextEndTransparencyLayer(CGContextRef c)
{
}

void CGContextFillPath(CGContextRef c)
{
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
}

uint64_t CGContextGetAllowsDithering()
{
  return _CGContextGetAllowsDithering();
}

uint64_t CGContextGetBaseCTM()
{
  return _CGContextGetBaseCTM();
}

CGAffineTransform *__cdecl CGContextGetCTM(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return _CGContextGetCTM(retstr, c);
}

uint64_t CGContextGetCharacterSpacing()
{
  return _CGContextGetCharacterSpacing();
}

CGRect CGContextGetClipBoundingBox(CGContextRef c)
{
  return _CGContextGetClipBoundingBox(c);
}

uint64_t CGContextGetFillColorAsColor()
{
  return _CGContextGetFillColorAsColor();
}

uint64_t CGContextGetFont()
{
  return _CGContextGetFont();
}

uint64_t CGContextGetFontRenderingStyle()
{
  return _CGContextGetFontRenderingStyle();
}

uint64_t CGContextGetFontSize()
{
  return _CGContextGetFontSize();
}

uint64_t CGContextGetFontSmoothingStyle()
{
  return _CGContextGetFontSmoothingStyle();
}

uint64_t CGContextGetShouldSmoothFonts()
{
  return _CGContextGetShouldSmoothFonts();
}

uint64_t CGContextGetStyle()
{
  return _CGContextGetStyle();
}

CGAffineTransform *__cdecl CGContextGetTextMatrix(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return _CGContextGetTextMatrix(retstr, c);
}

CGPoint CGContextGetTextPosition(CGContextRef c)
{
  CGPoint TextPosition = _CGContextGetTextPosition(c);
  double y = TextPosition.y;
  double x = TextPosition.x;
  result.double y = y;
  result.double x = x;
  return result;
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
}

void CGContextRelease(CGContextRef c)
{
}

void CGContextReplacePathWithStrokedPath(CGContextRef c)
{
}

void CGContextResetClip(CGContextRef c)
{
}

void CGContextRestoreGState(CGContextRef c)
{
}

void CGContextSaveGState(CGContextRef c)
{
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
}

uint64_t CGContextSetAllowsDithering()
{
  return _CGContextSetAllowsDithering();
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
}

void CGContextSetBlendMode(CGContextRef c, CGBlendMode mode)
{
}

uint64_t CGContextSetCTM()
{
  return _CGContextSetCTM();
}

void CGContextSetCharacterSpacing(CGContextRef c, CGFloat spacing)
{
}

uint64_t CGContextSetCompositeOperation()
{
  return _CGContextSetCompositeOperation();
}

void CGContextSetFillColor(CGContextRef c, const CGFloat *components)
{
}

void CGContextSetFillColorSpace(CGContextRef c, CGColorSpaceRef space)
{
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
}

void CGContextSetFillPattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
}

void CGContextSetFont(CGContextRef c, CGFontRef font)
{
}

uint64_t CGContextSetFontAntialiasingStyle()
{
  return _CGContextSetFontAntialiasingStyle();
}

uint64_t CGContextSetFontRenderingStyle()
{
  return _CGContextSetFontRenderingStyle();
}

void CGContextSetFontSize(CGContextRef c, CGFloat size)
{
}

uint64_t CGContextSetFontSmoothingBackgroundColor()
{
  return _CGContextSetFontSmoothingBackgroundColor();
}

void CGContextSetGrayFillColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
}

void CGContextSetLineCap(CGContextRef c, CGLineCap cap)
{
}

void CGContextSetLineJoin(CGContextRef c, CGLineJoin join)
{
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
}

void CGContextSetPatternPhase(CGContextRef c, CGSize phase)
{
}

void CGContextSetShouldAntialias(CGContextRef c, BOOL shouldAntialias)
{
}

void CGContextSetShouldSmoothFonts(CGContextRef c, BOOL shouldSmoothFonts)
{
}

void CGContextSetStrokeColor(CGContextRef c, const CGFloat *components)
{
}

void CGContextSetStrokeColorSpace(CGContextRef c, CGColorSpaceRef space)
{
}

void CGContextSetStrokeColorWithColor(CGContextRef c, CGColorRef color)
{
}

void CGContextSetStrokePattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
}

uint64_t CGContextSetStyle()
{
  return _CGContextSetStyle();
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
}

void CGContextStrokePath(CGContextRef c)
{
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
}

CFDataRef CGDataProviderCopyData(CGDataProviderRef provider)
{
  return _CGDataProviderCopyData(provider);
}

CGDataProviderRef CGDataProviderCreateDirect(void *info, off_t size, const CGDataProviderDirectCallbacks *callbacks)
{
  return _CGDataProviderCreateDirect(info, size, callbacks);
}

CGDataProviderRef CGDataProviderCreateSequential(void *info, const CGDataProviderSequentialCallbacks *callbacks)
{
  return _CGDataProviderCreateSequential(info, callbacks);
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return _CGDataProviderCreateWithCFData(data);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return _CGDataProviderCreateWithData(info, data, size, releaseData);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
}

CGFunctionRef CGFunctionCreate(void *info, size_t domainDimension, const CGFloat *domain, size_t rangeDimension, const CGFloat *range, const CGFunctionCallbacks *callbacks)
{
  return _CGFunctionCreate(info, domainDimension, domain, rangeDimension, range, callbacks);
}

void CGFunctionRelease(CGFunctionRef function)
{
}

CGGradientRef CGGradientCreateWithColorComponents(CGColorSpaceRef space, const CGFloat *components, const CGFloat *locations, size_t count)
{
  return _CGGradientCreateWithColorComponents(space, components, locations, count);
}

CGGradientRef CGGradientCreateWithColors(CGColorSpaceRef space, CFArrayRef colors, const CGFloat *locations)
{
  return _CGGradientCreateWithColors(space, colors, locations);
}

void CGGradientRelease(CGGradientRef gradient)
{
}

uint64_t CGImageBlockCreate()
{
  return _CGImageBlockCreate();
}

uint64_t CGImageBlockSetCreate()
{
  return _CGImageBlockSetCreate();
}

uint64_t CGImageBlockSetRelease()
{
  return _CGImageBlockSetRelease();
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return _CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, bitmapInfo, provider, decode, shouldInterpolate, intent);
}

CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space)
{
  return _CGImageCreateCopyWithColorSpace(image, space);
}

CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect)
{
  return _CGImageCreateWithImageInRect(image, rect);
}

uint64_t CGImageCreateWithImageProvider()
{
  return _CGImageCreateWithImageProvider();
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return _CGImageDestinationCreateWithData(data, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return _CGImageDestinationFinalize(idst);
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  return _CGImageGetAlphaInfo(image);
}

CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image)
{
  return _CGImageGetBitmapInfo(image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return _CGImageGetBitsPerComponent(image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return _CGImageGetBitsPerPixel(image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return _CGImageGetBytesPerRow(image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return _CGImageGetColorSpace(image);
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return _CGImageGetDataProvider(image);
}

const CGFloat *__cdecl CGImageGetDecode(CGImageRef image)
{
  return _CGImageGetDecode(image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return _CGImageGetHeight(image);
}

uint64_t CGImageGetImageProvider()
{
  return _CGImageGetImageProvider();
}

uint64_t CGImageGetProperty()
{
  return _CGImageGetProperty();
}

CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image)
{
  return _CGImageGetRenderingIntent(image);
}

BOOL CGImageGetShouldInterpolate(CGImageRef image)
{
  return _CGImageGetShouldInterpolate(image);
}

CFTypeID CGImageGetTypeID(void)
{
  return _CGImageGetTypeID();
}

size_t CGImageGetWidth(CGImageRef image)
{
  return _CGImageGetWidth(image);
}

CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate)
{
  return _CGImageMaskCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, provider, decode, shouldInterpolate);
}

uint64_t CGImageProviderCopyImageBlockSetWithOptions()
{
  return _CGImageProviderCopyImageBlockSetWithOptions();
}

uint64_t CGImageProviderCreate()
{
  return _CGImageProviderCreate();
}

uint64_t CGImageProviderGetColorSpace()
{
  return _CGImageProviderGetColorSpace();
}

uint64_t CGImageProviderGetInfo()
{
  return _CGImageProviderGetInfo();
}

uint64_t CGImageProviderRelease()
{
  return _CGImageProviderRelease();
}

void CGImageRelease(CGImageRef image)
{
}

CGImageRef CGImageRetain(CGImageRef image)
{
  return _CGImageRetain(image);
}

uint64_t CGImageSetProperty()
{
  return _CGImageSetProperty();
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return _CGImageSourceCreateImageAtIndex(isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return _CGImageSourceCreateWithData(data, options);
}

CGImageSourceRef CGImageSourceCreateWithDataProvider(CGDataProviderRef provider, CFDictionaryRef options)
{
  return _CGImageSourceCreateWithDataProvider(provider, options);
}

uint64_t CGImageTextureDataCreate()
{
  return _CGImageTextureDataCreate();
}

CGPDFDocumentRef CGPDFDocumentCreateWithProvider(CGDataProviderRef provider)
{
  return _CGPDFDocumentCreateWithProvider(provider);
}

uint64_t CGPDFDocumentGetDataProvider()
{
  return _CGPDFDocumentGetDataProvider();
}

CGPDFPageRef CGPDFDocumentGetPage(CGPDFDocumentRef document, size_t pageNumber)
{
  return _CGPDFDocumentGetPage(document, pageNumber);
}

void CGPDFDocumentRelease(CGPDFDocumentRef document)
{
}

uint64_t CGPDFPageContainsWideGamutContent()
{
  return _CGPDFPageContainsWideGamutContent();
}

CGRect CGPDFPageGetBoxRect(CGPDFPageRef page, CGPDFBox box)
{
  return _CGPDFPageGetBoxRect(page, box);
}

CGAffineTransform *__cdecl CGPDFPageGetDrawingTransform(CGAffineTransform *__return_ptr retstr, CGPDFPageRef page, CGPDFBox box, CGRect rect, int rotate, BOOL preserveAspectRatio)
{
  return _CGPDFPageGetDrawingTransform(retstr, page, box, rect, rotate, preserveAspectRatio);
}

void CGPDFPageRelease(CGPDFPageRef page)
{
}

CGPDFPageRef CGPDFPageRetain(CGPDFPageRef page)
{
  return _CGPDFPageRetain(page);
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

void CGPathAddPath(CGMutablePathRef path1, const CGAffineTransform *m, CGPathRef path2)
{
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
}

void CGPathApplyWithBlock(CGPathRef path, CGPathApplyBlock block)
{
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return _CGPathContainsPoint(path, m, point, eoFill);
}

CGPathRef CGPathCreateCopy(CGPathRef path)
{
  return _CGPathCreateCopy(path);
}

CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat lineWidth, CGLineCap lineCap, CGLineJoin lineJoin, CGFloat miterLimit)
{
  return _CGPathCreateCopyByStrokingPath(path, transform, lineWidth, lineCap, lineJoin, miterLimit);
}

CGPathRef CGPathCreateCopyBySubtractingPath(CGPathRef path, CGPathRef maskPath, BOOL evenOddFillRule)
{
  return _CGPathCreateCopyBySubtractingPath(path, maskPath, evenOddFillRule);
}

CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  return _CGPathCreateCopyByTransformingPath(path, transform);
}

CGPathRef CGPathCreateCopyByUnioningPath(CGPathRef path, CGPathRef maskPath, BOOL evenOddFillRule)
{
  return _CGPathCreateCopyByUnioningPath(path, maskPath, evenOddFillRule);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return _CGPathCreateMutable();
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  return _CGPathGetBoundingBox(path);
}

CGPoint CGPathGetCurrentPoint(CGPathRef path)
{
  CGPoint CurrentPoint = _CGPathGetCurrentPoint(path);
  double y = CurrentPoint.y;
  double x = CurrentPoint.x;
  result.double y = y;
  result.double x = x;
  return result;
}

BOOL CGPathIsEmpty(CGPathRef path)
{
  return _CGPathIsEmpty(path);
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

void CGPathRelease(CGPathRef path)
{
}

CGPathRef CGPathRetain(CGPathRef path)
{
  return _CGPathRetain(path);
}

CGPatternRef CGPatternCreate(void *info, CGRect bounds, CGAffineTransform *matrix, CGFloat xStep, CGFloat yStep, CGPatternTiling tiling, BOOL isColored, const CGPatternCallbacks *callbacks)
{
  return _CGPatternCreate(info, bounds, matrix, xStep, yStep, tiling, isColored, callbacks);
}

uint64_t CGPatternCreateWithImage2()
{
  return _CGPatternCreateWithImage2();
}

void CGPatternRelease(CGPatternRef pattern)
{
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  return _CGRectApplyAffineTransform(rect, t);
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return _CGRectContainsPoint(rect, point);
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  return _CGRectContainsRect(rect1, rect2);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return _CGRectCreateDictionaryRepresentation(a1);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return _CGRectEqualToRect(rect1, rect2);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  return _CGRectGetHeight(rect);
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  return _CGRectGetMaxX(rect);
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  return _CGRectGetMaxY(rect);
}

CGFloat CGRectGetMinX(CGRect rect)
{
  return _CGRectGetMinX(rect);
}

CGFloat CGRectGetMinY(CGRect rect)
{
  return _CGRectGetMinY(rect);
}

CGFloat CGRectGetWidth(CGRect rect)
{
  return _CGRectGetWidth(rect);
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  return _CGRectInset(rect, dx, dy);
}

CGRect CGRectIntegral(CGRect rect)
{
  return _CGRectIntegral(rect);
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  return _CGRectIntersection(r1, r2);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return _CGRectIsEmpty(rect);
}

BOOL CGRectIsNull(CGRect rect)
{
  return _CGRectIsNull(rect);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return _CGRectMakeWithDictionaryRepresentation(dict, rect);
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  return _CGRectOffset(rect, dx, dy);
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  return _CGRectUnion(r1, r2);
}

uint64_t CGSVGAtomCopyString()
{
  return _CGSVGAtomCopyString();
}

uint64_t CGSVGAtomFromString()
{
  return _CGSVGAtomFromString();
}

uint64_t CGSVGAttributeCopyString()
{
  return _CGSVGAttributeCopyString();
}

uint64_t CGSVGAttributeCreateWithColor()
{
  return _CGSVGAttributeCreateWithColor();
}

uint64_t CGSVGAttributeCreateWithString()
{
  return _CGSVGAttributeCreateWithString();
}

uint64_t CGSVGAttributeGetAtom()
{
  return _CGSVGAttributeGetAtom();
}

uint64_t CGSVGAttributeGetFloat()
{
  return _CGSVGAttributeGetFloat();
}

uint64_t CGSVGAttributeGetFloats()
{
  return _CGSVGAttributeGetFloats();
}

uint64_t CGSVGAttributeGetPaint()
{
  return _CGSVGAttributeGetPaint();
}

uint64_t CGSVGAttributeGetTransform()
{
  return _CGSVGAttributeGetTransform();
}

uint64_t CGSVGAttributeMapEnumerate()
{
  return _CGSVGAttributeMapEnumerate();
}

uint64_t CGSVGAttributeMapGetAttribute()
{
  return _CGSVGAttributeMapGetAttribute();
}

uint64_t CGSVGAttributeMapGetCount()
{
  return _CGSVGAttributeMapGetCount();
}

uint64_t CGSVGAttributeMapSetAttribute()
{
  return _CGSVGAttributeMapSetAttribute();
}

uint64_t CGSVGAttributeRelease()
{
  return _CGSVGAttributeRelease();
}

uint64_t CGSVGColorCreateCGColor()
{
  return _CGSVGColorCreateCGColor();
}

uint64_t CGSVGColorCreateRGBA()
{
  return _CGSVGColorCreateRGBA();
}

uint64_t CGSVGDocumentContainsWideGamutContent()
{
  return _CGSVGDocumentContainsWideGamutContent();
}

uint64_t CGSVGDocumentCreateFromData()
{
  return _CGSVGDocumentCreateFromData();
}

uint64_t CGSVGDocumentGetCanvasSize()
{
  return _CGSVGDocumentGetCanvasSize();
}

uint64_t CGSVGDocumentGetNamedStyle()
{
  return _CGSVGDocumentGetNamedStyle();
}

uint64_t CGSVGDocumentGetRootNode()
{
  return _CGSVGDocumentGetRootNode();
}

uint64_t CGSVGDocumentRelease()
{
  return _CGSVGDocumentRelease();
}

uint64_t CGSVGNodeCreateCompoundCGPath()
{
  return _CGSVGNodeCreateCompoundCGPath();
}

uint64_t CGSVGNodeEnumerate()
{
  return _CGSVGNodeEnumerate();
}

uint64_t CGSVGNodeFindAttribute()
{
  return _CGSVGNodeFindAttribute();
}

uint64_t CGSVGNodeFindChildWithStringIdentifier()
{
  return _CGSVGNodeFindChildWithStringIdentifier();
}

uint64_t CGSVGNodeGetAttributeMap()
{
  return _CGSVGNodeGetAttributeMap();
}

uint64_t CGSVGNodeGetChildAtIndex()
{
  return _CGSVGNodeGetChildAtIndex();
}

uint64_t CGSVGNodeGetChildCount()
{
  return _CGSVGNodeGetChildCount();
}

uint64_t CGSVGNodeGetParent()
{
  return _CGSVGNodeGetParent();
}

uint64_t CGSVGNodeGetType()
{
  return _CGSVGNodeGetType();
}

uint64_t CGSVGNodeSetAttribute()
{
  return _CGSVGNodeSetAttribute();
}

uint64_t CGSVGPaintGetColor()
{
  return _CGSVGPaintGetColor();
}

uint64_t CGSVGPaintGetType()
{
  return _CGSVGPaintGetType();
}

uint64_t CGSVGPathCreateCGPath()
{
  return _CGSVGPathCreateCGPath();
}

uint64_t CGSVGPathCreateWithCGPath()
{
  return _CGSVGPathCreateWithCGPath();
}

uint64_t CGSVGShapeNodeGetCircleGeometry()
{
  return _CGSVGShapeNodeGetCircleGeometry();
}

uint64_t CGSVGShapeNodeGetFloatCount()
{
  return _CGSVGShapeNodeGetFloatCount();
}

uint64_t CGSVGShapeNodeGetFloats()
{
  return _CGSVGShapeNodeGetFloats();
}

uint64_t CGSVGShapeNodeGetPath()
{
  return _CGSVGShapeNodeGetPath();
}

uint64_t CGSVGShapeNodeGetPrimitive()
{
  return _CGSVGShapeNodeGetPrimitive();
}

uint64_t CGSVGShapeNodeSetPath()
{
  return _CGSVGShapeNodeSetPath();
}

CGShadingRef CGShadingCreateAxial(CGColorSpaceRef space, CGPoint start, CGPoint end, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  return _CGShadingCreateAxial(space, start, end, function, extendStart, extendEnd);
}

void CGShadingRelease(CGShadingRef shading)
{
}

uint64_t CGStyleCreateShadow2()
{
  return _CGStyleCreateShadow2();
}

uint64_t CGStyleRelease()
{
  return _CGStyleRelease();
}

void CTFontDrawGlyphs(CTFontRef font, const CGGlyph *glyphs, const CGPoint *positions, size_t count, CGContextRef context)
{
}

uint64_t CTFontDrawGlyphsAtPositions()
{
  return _CTFontDrawGlyphsAtPositions();
}

uint64_t CTFontDrawGlyphsWithAdvances()
{
  return _CTFontDrawGlyphsWithAdvances();
}

CGRect CTFontGetBoundingRectsForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGRect *boundingRects, CFIndex count)
{
  return _CTFontGetBoundingRectsForGlyphs(font, orientation, glyphs, boundingRects, count);
}

CTFontSymbolicTraits CTFontGetSymbolicTraits(CTFontRef font)
{
  return _CTFontGetSymbolicTraits(font);
}

IOSurfaceRef IOSurfaceCreate(CFDictionaryRef properties)
{
  return _IOSurfaceCreate(properties);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return _IOSurfaceGetBaseAddress(buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return _IOSurfaceLock(buffer, options, seed);
}

void IOSurfaceSetValue(IOSurfaceRef buffer, CFStringRef key, CFTypeRef value)
{
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return _IOSurfaceUnlock(buffer, options, seed);
}

uint64_t MGCopyAnswer()
{
  return _MGCopyAnswer();
}

uint64_t MGGetBoolAnswer()
{
  return _MGGetBoolAnswer();
}

id MTLCreateSystemDefaultDevice(void)
{
  return _MTLCreateSystemDefaultDevice();
}

uint64_t MTLGPUFamilySupportsSamplingFromPixelFormat()
{
  return _MTLGPUFamilySupportsSamplingFromPixelFormat();
}

id NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone)
{
  return _NSAllocateObject(aClass, extraBytes, zone);
}

Class NSClassFromString(NSString *aClassName)
{
  return _NSClassFromString(aClassName);
}

NSMapTable *__cdecl NSCreateMapTable(NSMapTableKeyCallBacks *keyCallBacks, NSMapTableValueCallBacks *valueCallBacks, NSUInteger capacity)
{
  return _NSCreateMapTable(keyCallBacks, valueCallBacks, capacity);
}

BOOL NSEqualSizes(NSSize aSize, NSSize bSize)
{
  return _NSEqualSizes(aSize, bSize);
}

NSRect NSInsetRect(NSRect aRect, CGFloat dX, CGFloat dY)
{
  return _NSInsetRect(aRect, dX, dY);
}

NSRect NSIntegralRectWithOptions(NSRect aRect, NSAlignmentOptions opts)
{
  return _NSIntegralRectWithOptions(aRect, opts);
}

BOOL NSIsEmptyRect(NSRect aRect)
{
  return _NSIsEmptyRect(aRect);
}

uint64_t NSLocalizedFileSizeDescription()
{
  return _NSLocalizedFileSizeDescription();
}

void NSLog(NSString *format, ...)
{
}

void *__cdecl NSMapGet(NSMapTable *table, const void *key)
{
  return _NSMapGet(table, key);
}

void NSMapInsert(NSMapTable *table, const void *key, const void *value)
{
}

void NSMapInsertKnownAbsent(NSMapTable *table, const void *key, const void *value)
{
}

void NSMapRemove(NSMapTable *table, const void *key)
{
}

BOOL NSPointInRect(NSPoint aPoint, NSRect aRect)
{
  return _NSPointInRect(aPoint, aRect);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return _NSStringFromClass(aClass);
}

NSString *__cdecl NSStringFromPoint(NSPoint aPoint)
{
  return _NSStringFromPoint(aPoint);
}

NSString *__cdecl NSStringFromRect(NSRect aRect)
{
  return _NSStringFromRect(aRect);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return _NSStringFromSelector(aSelector);
}

NSString *__cdecl NSStringFromSize(NSSize aSize)
{
  return _NSStringFromSize(aSize);
}

NSRect NSUnionRect(NSRect aRect, NSRect bRect)
{
  return _NSUnionRect(aRect, bRect);
}

int32_t NSVersionOfLinkTimeLibrary(const char *libraryName)
{
  return _NSVersionOfLinkTimeLibrary(libraryName);
}

Boolean UTTypeConformsTo(CFStringRef inUTI, CFStringRef inConformsToUTI)
{
  return _UTTypeConformsTo(inUTI, inConformsToUTI);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFExecutableLinkedOnOrAfter()
{
  return __CFExecutableLinkedOnOrAfter();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return std::logic_error::logic_error(this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return std::bad_array_new_length::bad_array_new_length(this);
}

void std::terminate(void)
{
}

uint64_t operator delete[]()
{
  return operator delete[]();
}

void operator delete(void *__p)
{
}

uint64_t operator delete()
{
  return operator delete();
}

uint64_t operator new[]()
{
  return operator new[]();
}

void *__cdecl operator new(size_t __sz)
{
  return operator new(__sz);
}

uint64_t operator new()
{
  return operator new();
}

uint64_t __CFSetLastAllocationEventName()
{
  return ___CFSetLastAllocationEventName();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return ___cxa_allocate_exception(thrown_size);
}

void __cxa_bad_typeid(void)
{
}

void *__cxa_begin_catch(void *a1)
{
  return ___cxa_begin_catch(a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void *__cxa_get_exception_ptr(void *a1)
{
  return ___cxa_get_exception_ptr(a1);
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return ___error();
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

__float2 __sincosf_stret(float a1)
{
  __float2 v3 = ___sincosf_stret(a1);
  float cosval = v3.__cosval;
  float sinval = v3.__sinval;
  result.__float cosval = cosval;
  result.__float sinval = sinval;
  return result;
}

uint64_t __strlcat_chk()
{
  return ___strlcat_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

uint32_t at_block_format_to_MTLPixelFormat(at_block_format_t blockFormat)
{
  return _at_block_format_to_MTLPixelFormat(blockFormat);
}

float at_encoder_compress_texels(at_encoder_t encoder, const at_texel_region_t *src, const at_block_buffer_t *dest, float errorThreshold, at_flags_t flags)
{
  return _at_encoder_compress_texels(encoder, src, dest, errorThreshold, flags);
}

at_encoder_t at_encoder_create(at_texel_format_t texelType, at_alpha_t texelAlphaType, at_block_format_t blockType, at_alpha_t blockAlphaType, const float *backgroundColor)
{
  return _at_encoder_create(texelType, texelAlphaType, blockType, blockAlphaType, backgroundColor);
}

at_error_t at_encoder_decompress_texels(at_encoder_t encoder, const at_block_buffer_t *src, const at_texel_region_t *dest, at_flags_t flags)
{
  return _at_encoder_decompress_texels(encoder, src, dest, flags);
}

at_size_t at_encoder_get_block_counts(at_encoder_t encoder, at_size_t imageSize)
{
  return _at_encoder_get_block_counts(encoder, imageSize);
}

at_size_t at_encoder_get_block_dimensions(at_encoder_t encoder)
{
  return _at_encoder_get_block_dimensions(encoder);
}

size_t at_encoder_get_block_size(at_encoder_t encoder)
{
  return _at_encoder_get_block_size(encoder);
}

long double atan2(long double __y, long double __x)
{
  return _atan2(__y, __x);
}

int bcmp(const void *a1, const void *a2, size_t a3)
{
  return _bcmp(a1, a2, a3);
}

void bzero(void *a1, size_t a2)
{
}

int close(int a1)
{
  return _close(a1);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return _compression_decode_buffer(dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, algorithm);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return _compression_encode_buffer(dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, algorithm);
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  return _compression_stream_destroy(stream);
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  return _compression_stream_init(stream, operation, algorithm);
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  return _compression_stream_process(stream, flags);
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return _crc32(crc, buf, len);
}

int deflate(z_streamp strm, int flush)
{
  return _deflate(strm, flush);
}

int deflateEnd(z_streamp strm)
{
  return _deflateEnd(strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return _deflateInit2_(strm, level, method, windowBits, memLevel, strategy, version, stream_size);
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return _dlopen(__path, __mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

uint64_t dyld_program_sdk_at_least()
{
  return _dyld_program_sdk_at_least();
}

long double exp(long double __x)
{
  return _exp(__x);
}

int fchmod(int a1, mode_t a2)
{
  return _fchmod(a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return _fchown(a1, a2, a3);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

long double fmod(long double __x, long double __y)
{
  return _fmod(__x, __y);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return _fputc(a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return _fputs(a1, a2);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return _fstatfs(a1, a2);
}

int fsync(int a1)
{
  return _fsync(a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

int inflate(z_streamp strm, int flush)
{
  return _inflate(strm, flush);
}

int inflateEnd(z_streamp strm)
{
  return _inflateEnd(strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return _inflateInit2_(strm, windowBits, version, stream_size);
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

long double log(long double __x)
{
  return _log(__x);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return _lseek(a1, a2, a3);
}

kern_return_t mach_vm_protect(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return _mach_vm_protect(target_task, address, size, set_maximum, new_protection);
}

int madvise(void *a1, size_t a2, int a3)
{
  return _madvise(a1, a2, a3);
}

malloc_zone_t *malloc_default_zone(void)
{
  return _malloc_default_zone();
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_valloc(size, type_id);
}

void *__cdecl malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_zone_memalign(zone, alignment, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

char *__cdecl mktemp(char *a1)
{
  return _mktemp(a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return _notify_register_dispatch(name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

id objc_begin_catch(void *exc_buf)
{
  return _objc_begin_catch(exc_buf);
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return _objc_getClass(name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_loadWeak(id *location)
{
  return _objc_loadWeak(location);
}

id objc_loadWeakRetained(id *location)
{
  return _objc_loadWeakRetained(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return _objc_msgSendSuper2(a1, a2);
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

uint64_t objc_opt_respondsToSelector()
{
  return _objc_opt_respondsToSelector();
}

uint64_t self
{
  return _self;
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

void *__cdecl object_getIndexedIvars(id a1)
{
  return _object_getIndexedIvars(a1);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_is_darwinos()
{
  return _os_variant_is_darwinos();
}

long double pow(long double __x, long double __y)
{
  return _pow(__x, __y);
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return _pthread_cond_broadcast(a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return _pthread_cond_destroy(a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return _pthread_cond_init(a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return _pthread_cond_signal(a1);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return _pthread_cond_wait(a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return _pthread_getspecific(a1);
}

int pthread_join(pthread_t a1, void **a2)
{
  return _pthread_join(a1, a2);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return _pthread_key_create(a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return _pthread_setspecific(a1, a2);
}

int puts(const char *a1)
{
  return _puts(a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return _reallocf(__ptr, __size);
}

long double remainder(long double __x, long double __y)
{
  return _remainder(__x, __y);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

const char *__cdecl sel_getName(SEL sel)
{
  return _sel_getName(sel);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

char *__cdecl stpncpy(char *__dst, const char *__src, size_t __n)
{
  return _stpncpy(__dst, __src, __n);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return _strcpy(__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return _strnstr(__big, __little, __len);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

uint64_t swift_getForeignTypeMetadata()
{
  return _swift_getForeignTypeMetadata();
}

uint64_t swift_getWitnessTable()
{
  return _swift_getWitnessTable();
}

uint64_t swift_retain()
{
  return _swift_retain();
}

long double tan(long double __x)
{
  return _tan(__x);
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

void uuid_generate_random(uuid_t out)
{
}

void vDSP_vaddD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsaddD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vsmsmaD(const double *__A, vDSP_Stride __IA, const double *__B, const double *__C, vDSP_Stride __IC, const double *__D, double *__E, vDSP_Stride __IE, vDSP_Length __N)
{
}

void vDSP_vsmulD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsubD(const double *__B, vDSP_Stride __IB, const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

vImage_Error vImageBuffer_Init(vImage_Buffer *buf, vImagePixelCount height, vImagePixelCount width, uint32_t pixelBits, vImage_Flags flags)
{
  return _vImageBuffer_Init(buf, height, width, pixelBits, flags);
}

vImage_Error vImageBuffer_InitWithCGImage(vImage_Buffer *buf, vImage_CGImageFormat *format, const CGFloat *backgroundColor, CGImageRef image, vImage_Flags flags)
{
  return _vImageBuffer_InitWithCGImage(buf, format, backgroundColor, image, flags);
}

vImage_Error vImageClipToAlpha_RGBA8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return _vImageClipToAlpha_RGBA8888(src, dest, flags);
}

vImage_Error vImageConvert_ARGB16UtoARGB8888_dithered(const vImage_Buffer *src, const vImage_Buffer *dest, int dither, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return _vImageConvert_ARGB16UtoARGB8888_dithered(src, dest, dither, permuteMap, flags);
}

vImage_Error vImageConvert_ARGB8888toPlanar8(const vImage_Buffer *srcARGB, const vImage_Buffer *destA, const vImage_Buffer *destR, const vImage_Buffer *destG, const vImage_Buffer *destB, vImage_Flags flags)
{
  return _vImageConvert_ARGB8888toPlanar8(srcARGB, destA, destR, destG, destB, flags);
}

vImage_Error vImageConvert_AnyToAny(const vImageConverterRef converter, const vImage_Buffer *srcs, const vImage_Buffer *dests, void *tempBuffer, vImage_Flags flags)
{
  return _vImageConvert_AnyToAny(converter, srcs, dests, tempBuffer, flags);
}

vImage_Error vImageConvert_Planar16UtoPlanar8_dithered(const vImage_Buffer *src, const vImage_Buffer *dest, int dither, vImage_Flags flags)
{
  return _vImageConvert_Planar16UtoPlanar8_dithered(src, dest, dither, flags);
}

vImage_Error vImageConvert_Planar8toPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, Pixel_F maxFloat, Pixel_F minFloat, vImage_Flags flags)
{
  return _vImageConvert_Planar8toPlanarF(src, dest, maxFloat, minFloat, flags);
}

vImage_Error vImageConvert_RGB16UtoRGB888_dithered(const vImage_Buffer *src, const vImage_Buffer *dest, int dither, vImage_Flags flags)
{
  return _vImageConvert_RGB16UtoRGB888_dithered(src, dest, dither, flags);
}

vImageConverterRef vImageConverter_CreateWithCGImageFormat(const vImage_CGImageFormat *srcFormat, const vImage_CGImageFormat *destFormat, const CGFloat *backgroundColor, vImage_Flags flags, vImage_Error *error)
{
  return _vImageConverter_CreateWithCGImageFormat(srcFormat, destFormat, backgroundColor, flags, error);
}

void vImageConverter_Release(vImageConverterRef converter)
{
}

vImage_Error vImageConvolve_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, const int16_t *kernel, uint32_t kernel_height, uint32_t kernel_width, int32_t divisor, const Pixel_8888 backgroundColor, vImage_Flags flags)
{
  return _vImageConvolve_ARGB8888(src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel, kernel_height, kernel_width, divisor, backgroundColor, flags);
}

CGImageRef vImageCreateCGImageFromBuffer(const vImage_Buffer *buf, const vImage_CGImageFormat *format, void (__cdecl *callback)(void *, void *), void *userData, vImage_Flags flags, vImage_Error *error)
{
  return _vImageCreateCGImageFromBuffer(buf, format, callback, userData, flags, error);
}

uint64_t vImageDeepmap2Decode()
{
  return _vImageDeepmap2Decode();
}

uint64_t vImageDeepmap2DecodeStreamCreate()
{
  return _vImageDeepmap2DecodeStreamCreate();
}

uint64_t vImageDeepmap2DecodeStreamProcess()
{
  return _vImageDeepmap2DecodeStreamProcess();
}

uint64_t vImageDeepmap2DecodeStreamRelease()
{
  return _vImageDeepmap2DecodeStreamRelease();
}

uint64_t vImageDeepmap2EncodeCreateBuffer()
{
  return _vImageDeepmap2EncodeCreateBuffer();
}

uint64_t vImageDeepmapDecodeStreamCreate()
{
  return _vImageDeepmapDecodeStreamCreate();
}

uint64_t vImageDeepmapDecodeStreamProcess()
{
  return _vImageDeepmapDecodeStreamProcess();
}

uint64_t vImageDeepmapDecodeStreamRelease()
{
  return _vImageDeepmapDecodeStreamRelease();
}

uint64_t vImageDeepmapEncodeCreateBuffer()
{
  return _vImageDeepmapEncodeCreateBuffer();
}

vImage_Error vImageExtractChannel_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint64_t channelIndex, vImage_Flags flags)
{
  return _vImageExtractChannel_ARGB8888(src, dest, channelIndex, flags);
}

vImage_Error vImageHistogramCalculation_ARGB8888(const vImage_Buffer *src, vImagePixelCount *histogram[4], vImage_Flags flags)
{
  return _vImageHistogramCalculation_ARGB8888(src, histogram, flags);
}

vImage_Error vImageHistogramCalculation_ARGBFFFF(const vImage_Buffer *src, vImagePixelCount *histogram[4], unsigned int histogram_entries, Pixel_F minVal, Pixel_F maxVal, vImage_Flags flags)
{
  return _vImageHistogramCalculation_ARGBFFFF(src, histogram, histogram_entries, minVal, maxVal, flags);
}

vImage_Error vImageOverwriteChannels_ARGB8888(const vImage_Buffer *newSrc, const vImage_Buffer *origSrc, const vImage_Buffer *dest, uint8_t copyMask, vImage_Flags flags)
{
  return _vImageOverwriteChannels_ARGB8888(newSrc, origSrc, dest, copyMask, flags);
}

vImage_Error vImagePermuteChannels_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return _vImagePermuteChannels_ARGB8888(src, dest, permuteMap, flags);
}

vImage_Error vImageScale_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return _vImageScale_ARGB8888(src, dest, tempBuffer, flags);
}

vImage_Error vImageScale_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return _vImageScale_Planar8(src, dest, tempBuffer, flags);
}

vImage_Error vImageUnpremultiplyData_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return _vImageUnpremultiplyData_ARGB8888(src, dest, flags);
}

kern_return_t vm_copy(vm_map_t target_task, vm_address_t source_address, vm_size_t size, vm_address_t dest_address)
{
  return _vm_copy(target_task, source_address, size, dest_address);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return _vsnprintf(__str, __size, __format, a4);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

id objc_msgSend_key(void *a1, const char *a2, ...)
{
  return [a1 key];
}

id objc_msgSend_map(void *a1, const char *a2, ...)
{
  return [a1 map];
}

id objc_msgSend_psd(void *a1, const char *a2, ...)
{
  return [a1 psd];
}

id objc_msgSend_top(void *a1, const char *a2, ...)
{
  return [a1 top];
}

id objc_msgSend_writeToDiskAndCompact_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, sel_writeToDiskAndCompact_);
}