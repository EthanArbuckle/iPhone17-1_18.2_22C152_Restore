uint64_t sub_1B6492BF4(uint64_t result)
{
  *(_DWORD *)(result + 104) = 1065353216;
  *(_DWORD *)(result + 80) = 1065353216;
  *(_WORD *)(result + 84) |= 0x68u;
  return result;
}

uint64_t sub_1B6492C14(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 88))();
}

const void *sub_1B6492C1C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  CFArrayRef v10 = *(const __CFArray **)(a1 + 64);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = sub_1B660C900(a2, v10, 1);
  v19 = (const void *)v11;
  if (v11 && !sub_1B660F8C4(v11, v12, v13, v14, v15, v16, v17, v18))
  {
    CFRelease(v19);
    return 0;
  }
  return v19;
}

CFTypeRef sub_1B6492CA0(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 64);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 64) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 64) = result;
  }
  return result;
}

uint64_t sub_1B6492CF4(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

BOOL sub_1B6492CFC(const void *a1)
{
  CFTypeID v1 = CFGetTypeID(a1);
  return v1 == sub_1B6540E1C();
}

void sub_1B6492D2C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animation");
  }
  *(float *)(a1 + 72) = a2;
}

float sub_1B6492D84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(float *)(a1 + 72);
}

float sub_1B6492DD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  float v9 = *(float *)(a1 + 76);
  if (v9 == INFINITY || v9 == 3.4028e38) {
    return 3.4028e38;
  }
  float v12 = 1.0;
  if (v9 == 0.0) {
    float v9 = 1.0;
  }
  float v13 = v9 * *(float *)(a1 + 72);
  if (*(_WORD *)(a1 + 84)) {
    float v12 = 2.0;
  }
  return v13 * v12;
}

void sub_1B6492E68(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animation");
  }
  *(float *)(a1 + 76) = a2;
}

float sub_1B6492EC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(float *)(a1 + 76);
}

void sub_1B6492F0C(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFFE | a2;
}

uint64_t sub_1B6492F68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(_WORD *)(a1 + 84) & 1;
}

CFTypeRef sub_1B6492FB8(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 120);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 120) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 120) = result;
  }
  return result;
}

uint64_t sub_1B6493034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(void *)(a1 + 120);
}

void sub_1B6493080(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if (a2) {
    __int16 v10 = 2;
  }
  else {
    __int16 v10 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFFD | v10;
}

uint64_t sub_1B64930E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 2) & 1;
}

void sub_1B6493138(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if (a2) {
    __int16 v10 = 4;
  }
  else {
    __int16 v10 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFFB | v10;
}

uint64_t sub_1B64931A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 1) & 1;
}

uint64_t sub_1B64931F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 3) & 1;
}

void sub_1B6493240(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if (a2) {
    __int16 v10 = 8;
  }
  else {
    __int16 v10 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFFF7 | v10;
}

CFStringRef sub_1B64932A8(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }

  return sub_1B65834BC(a1, theString, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B649330C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }

  return sub_1B6583470(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B6493368(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animation");
  }
  *(double *)(a1 + 136) = a2;
}

double sub_1B64933C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(double *)(a1 + 136);
}

void sub_1B649340C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animation");
  }
  *(float *)(a1 + 80) = a2;
}

float sub_1B6493464(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(float *)(a1 + 80);
}

void sub_1B64934B0(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animation");
  }
  *(float *)(a1 + 108) = a2;
}

float sub_1B6493508(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(float *)(a1 + 108);
}

void sub_1B6493554(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animation");
  }
  *(float *)(a1 + 112) = a2;
}

float sub_1B64935AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(float *)(a1 + 112);
}

uint64_t sub_1B64935F8(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if (a2) {
    __int16 v10 = 16;
  }
  else {
    __int16 v10 = 0;
  }
  a1[42] = a1[42] & 0xFFEF | v10;
  CFTypeID v11 = CFGetTypeID(a1);
  uint64_t result = sub_1B6540E1C();
  if (v11 == result)
  {
    uint64_t result = sub_1B6541028((uint64_t)a1, v13, v14, v15, v16, v17, v18, v19);
    if (result >= 1)
    {
      uint64_t v26 = result;
      for (CFIndex i = 0; i != v26; ++i)
      {
        v28 = sub_1B6541084((uint64_t)a1, i, v20, v21, v22, v23, v24, v25);
        uint64_t result = sub_1B64935F8(v28, a2);
      }
    }
  }
  return result;
}

uint64_t sub_1B64936B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 4) & 1;
}

BOOL sub_1B6493708(unsigned char *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (qword_1E9DDAF38 != -1) {
    dispatch_once(&qword_1E9DDAF38, &unk_1F0FB7068);
  }
  if (v2 != qword_1E9DDAF30) {
    return 0;
  }
  if (a1[372]) {
    return 1;
  }
  return a1[373] != 0;
}

uint64_t sub_1B649378C()
{
  if (qword_1E9DDAF38 != -1) {
    dispatch_once(&qword_1E9DDAF38, &unk_1F0FB7068);
  }
  return qword_1E9DDAF30;
}

uint64_t sub_1B64937D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return a1 + 144;
}

uint64_t sub_1B649381C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(void *)(a1 + 96);
}

CFTypeRef sub_1B6493868(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 96);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 96) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 96) = result;
  }
  return result;
}

void sub_1B64938E4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if (a2) {
    __int16 v10 = 256;
  }
  else {
    __int16 v10 = 0;
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFEFF | v10;
}

uint64_t sub_1B649394C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return HIBYTE(*(unsigned __int16 *)(a1 + 84)) & 1;
}

uint64_t sub_1B649399C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return (*(unsigned __int16 *)(a1 + 84) >> 5) & 3;
}

void sub_1B64939EC(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  *(_WORD *)(a1 + 84) = *(_WORD *)(a1 + 84) & 0xFF9F | (32 * (a2 & 3));
}

uint64_t sub_1B6493A4C(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  CFTypeID v16 = CFGetTypeID(cf);
  if (qword_1E9DDAF38 != -1) {
    dispatch_once(&qword_1E9DDAF38, &unk_1F0FB7068);
  }
  if (v16 == qword_1E9DDAF30)
  {
    *((void *)cf + 11) = sub_1B6493B7C;
    return sub_1B6493CC4((uint64_t)cf, a2, v10, v11, v12, v13, v14, v15);
  }
  else if (v16 == sub_1B6437D6C())
  {
    *((void *)cf + 11) = sub_1B6437F58;
    return sub_1B643804C((uint64_t)cf, a2, v18, v19, v20, v21, v22, v23);
  }
  else
  {
    sub_1B63F2F54(16, @"Unreachable code: CFXAnimationSetup - unknown animation class", v18, v19, v20, v21, v22, v23, v24);
    return 0;
  }
}

BOOL sub_1B6493B7C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  double v11 = a9.n128_f64[0];
  if (a1)
  {
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"anim");
  if (!a3) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"outputAddress");
LABEL_4:
  uint64_t v13 = *(void *)(a1 + 376);
  if (v13)
  {
    if (*(unsigned char *)(a1 + 372)) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = a1 + 176;
    }
    if (*(unsigned char *)(a1 + 373))
    {
      uint64_t v15 = a3;
      if ((*(unsigned char *)(a1 + 374) & 4) != 0)
      {
        uint64_t v15 = a1 + 304;
        sub_1B63CAF80(*(__int16 *)(a1 + 368), v14, a1 + 240, a1 + 304, a5, a6, a7, a8, v20);
      }
    }
    else
    {
      uint64_t v15 = a1 + 304;
    }
    if (a2)
    {
      a9.n128_f64[0] = 1.0 - v11;
      uint64_t v16 = (*(unsigned __int16 *)(a1 + 84) >> 1) & 1;
      uint64_t v17 = v15;
      uint64_t v18 = v14;
    }
    else
    {
      uint64_t v16 = (*(unsigned __int16 *)(a1 + 84) >> 1) & 1;
      a9.n128_f64[0] = v11;
      uint64_t v17 = v14;
      uint64_t v18 = v15;
    }
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t, uint64_t, __n128))(a1 + 376))(v17, v18, 0, 0, 0, v16, a3, a9);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: CFXSimpleAnimationEvaluate - invalid evaluation function", a3, a4, a5, a6, a7, a8, v20);
  }
  return v13 != 0;
}

uint64_t sub_1B6493CC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2)
    {
LABEL_3:
      __int16 v10 = sub_1B660FA40(a2, a2, a3, a4, a5, a6, a7, a8);
      int v18 = sub_1B660F9A8(a2, v11, v12, v13, v14, v15, v16, v17);
      goto LABEL_6;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
    if (a2) {
      goto LABEL_3;
    }
  }
  int v18 = 0;
  __int16 v10 = *(_WORD *)(a1 + 368);
LABEL_6:
  int v19 = v10;
  uint64_t v20 = sub_1B643079C(v10, v18, 0, 0);
  *(void *)(a1 + 376) = v20;
  if (!v20) {
    return 0;
  }
  int v28 = *(unsigned __int8 *)(a1 + 374);
  if ((~v28 & 3) != 0)
  {
    if ((~v28 & 5) == 0)
    {
      sub_1B63CAF80(*(__int16 *)(a1 + 368), a1 + 176, a1 + 240, a1 + 304, v24, v25, v26, v27, v88);
      return 1;
    }
    if ((~v28 & 6) == 0)
    {
      sub_1B63CB308(*(__int16 *)(a1 + 368), a1 + 304, a1 + 240, a1 + 176, v24, v25, v26, v27, v88);
      return 1;
    }
    if (v28)
    {
      uint64_t v29 = 1;
      *(unsigned char *)(a1 + 373) = 1;
      return v29;
    }
    if ((v28 & 2) != 0)
    {
      uint64_t v29 = 1;
      *(unsigned char *)(a1 + 372) = 1;
      return v29;
    }
    if ((v28 & 4) != 0)
    {
      *(_WORD *)(a1 + 372) = 257;
      return 1;
    }
    uint64_t v30 = sub_1B660F8C4(a2, v21, v22, v23, v24, v25, v26, v27);
    if (v30)
    {
      v37 = (const void *)v30;
      uint64_t v29 = 1;
      v38 = (const void *)sub_1B65623D0(v19, 1, v31, v32, v33, v34, v35, v36);
      v46 = (const void *)sub_1B660F878(a2, v39, v40, v41, v42, v43, v44, v45);
      v54 = (void *)sub_1B6562568((uint64_t)v38, v47, v48, v49, v50, v51, v52, v53);
      size_t v62 = sub_1B6562484((uint64_t)v38, v55, v56, v57, v58, v59, v60, v61);
      uint64_t v70 = sub_1B660F9A8(a2, v63, v64, v65, v66, v67, v68, v69);
      uint64_t v78 = sub_1B660F9F4(a2, v71, v72, v73, v74, v75, v76, v77);
      sub_1B63F4434(v46, v37, v54, v62, v70, v78, v79, v80);
      sub_1B6494414(a1, (uint64_t)v38, v81, v82, v83, v84, v85, v86);
      *(unsigned char *)(a1 + 373) = 1;
      CFRelease(v38);
      return v29;
    }
    return 0;
  }
  return 1;
}

__n128 sub_1B6493EA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
LABEL_3:
  CFStringRef v10 = (const __CFString *)sub_1B649330C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1B64932A8(a2, v10, v11, v12, v13, v14, v15, v16);
  sub_1B6492CA0(a2, *(CFTypeRef *)(a1 + 64));
  int v23 = *(_DWORD *)(a1 + 72);
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v17, v18, v19, v20, v21, v22, (uint64_t)"animation");
  }
  int v24 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)(a2 + 72) = v23;
  *(_DWORD *)(a2 + 76) = v24;
  *(_WORD *)(a2 + 84) = *(_WORD *)(a2 + 84) & 0xFFFE | *(_WORD *)(a1 + 84) & 1;
  sub_1B6492FB8(a2, *(CFTypeRef *)(a1 + 120), v17, v18, v19, v20, v21, v22);
  int v25 = *(_WORD *)(a2 + 84) & 0xFFFD | (2 * ((*(unsigned __int16 *)(a1 + 84) >> 1) & 1));
  *(_WORD *)(a2 + 84) = v25;
  unsigned int v26 = v25 & 0xFFFFFFFB | (4 * ((*(unsigned __int16 *)(a1 + 84) >> 2) & 1));
  *(_WORD *)(a2 + 84) = v26;
  *(_WORD *)(a2 + 84) = v26 & 0xFFF7 | *(_WORD *)(a1 + 84) & 8;
  *(_OWORD *)(a2 + 128) = *(_OWORD *)(a1 + 128);
  *(_DWORD *)(a2 + 80) = *(_DWORD *)(a1 + 80);
  sub_1B64935F8((_WORD *)a2, (*(unsigned __int16 *)(a1 + 84) >> 4) & 1, v27, v28, v29, v30, v31, v32);
  *(_WORD *)(a2 + 84) = *(_WORD *)(a2 + 84) & 0xFF9F | *(_WORD *)(a1 + 84) & 0x60;
  *(void *)(a2 + 104) = *(void *)(a1 + 104);
  *(_DWORD *)(a2 + 112) = *(_DWORD *)(a1 + 112);
  sub_1B6493868(a2, *(CFTypeRef *)(a1 + 96), v33, v34, v35, v36, v37, v38);
  *(void *)(a2 + 160) = *(void *)(a1 + 160);
  *(_WORD *)(a2 + 84) = *(_WORD *)(a2 + 84) & 0xFF7F | *(_WORD *)(a1 + 84) & 0x80;
  __n128 result = *(__n128 *)(a1 + 144);
  *(__n128 *)(a2 + 144) = result;
  return result;
}

CFTypeRef *sub_1B6494038(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  }
  CFTypeID v9 = CFGetTypeID(cf);
  if (qword_1E9DDAF38 != -1) {
    dispatch_once(&qword_1E9DDAF38, &unk_1F0FB7068);
  }
  if (v9 == qword_1E9DDAF30)
  {
    CFStringRef v10 = (CFTypeRef *)sub_1B6494178();
    sub_1B64941E0((uint64_t)cf, (uint64_t)v10, v11, v12, v13, v14, v15, v16);
  }
  else if (v9 == sub_1B6437D6C())
  {
    CFStringRef v10 = (CFTypeRef *)sub_1B6437DF4();
    sub_1B64383C0((uint64_t)cf, (uint64_t)v10, v23, v24, v25, v26, v27, v28);
  }
  else if (v9 == sub_1B6540E1C())
  {
    CFStringRef v10 = (CFTypeRef *)sub_1B6540EA4();
    sub_1B6541190((uint64_t)cf, (uint64_t)v10, v29, v30, v31, v32, v33, v34);
  }
  else
  {
    if (v9 != sub_1B654DC68())
    {
      sub_1B6583A28((uint64_t)cf, 0, v35, v36, v37, v38, v39, v40);
      return 0;
    }
    CFStringRef v10 = (CFTypeRef *)sub_1B654DCF0();
    sub_1B654E844((uint64_t)cf, (uint64_t)v10, v41, v42, v43, v44, v45, v46);
  }
  sub_1B6583A28((uint64_t)cf, v10, v17, v18, v19, v20, v21, v22);
  if (v10) {
    sub_1B6493EA0((uint64_t)cf, (uint64_t)v10, v47, v48, v49, v50, v51, v52);
  }
  return v10;
}

uint64_t sub_1B6494178()
{
  if (qword_1E9DDAF38 != -1) {
    dispatch_once(&qword_1E9DDAF38, &unk_1F0FB7068);
  }
  uint64_t result = sub_1B63C8D44(qword_1E9DDAF30, 0x170uLL);
  *(_DWORD *)(result + 104) = 1065353216;
  *(_DWORD *)(result + 80) = 1065353216;
  *(_WORD *)(result + 84) |= 0x68u;
  return result;
}

void *sub_1B64941E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dest");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  *(void *)(a2 + 376) = *(void *)(a1 + 376);
  memcpy((void *)(a2 + 176), (const void *)(a1 + 176), *(__int16 *)(a1 + 370));
  memcpy((void *)(a2 + 304), (const void *)(a1 + 304), *(__int16 *)(a1 + 370));
  uint64_t result = memcpy((void *)(a2 + 240), (const void *)(a1 + 240), *(__int16 *)(a1 + 370));
  char v11 = *(unsigned char *)(a2 + 374) & 0xFE | *(unsigned char *)(a1 + 374) & 1;
  *(unsigned char *)(a2 + 374) = v11;
  char v12 = v11 & 0xFD | (2 * ((*(unsigned char *)(a1 + 374) & 2) != 0));
  *(unsigned char *)(a2 + 374) = v12;
  *(unsigned char *)(a2 + 374) = v12 & 0xFB | *(unsigned char *)(a1 + 374) & 4;
  *(_DWORD *)(a2 + 370) = *(_DWORD *)(a1 + 370);
  *(_WORD *)(a2 + 368) = *(_WORD *)(a1 + 368);
  return result;
}

void sub_1B64942E0()
{
  if (!qword_1E9DDAF30) {
    qword_1E9DDAF30 = sub_1B63C8D10(&qword_1E9DDAF30);
  }
}

size_t sub_1B6494324(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  *(_WORD *)(a1 + 368) = sub_1B65625B4(a2, a2, a3, a4, a5, a6, a7, a8);
  *(unsigned char *)(a1 + 374) |= 2u;

  return sub_1B6562704(a2, (void *)(a1 + 304), v10, v11, v12, v13, v14, v15);
}

uint64_t sub_1B64943A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if ((*(unsigned char *)(a1 + 374) & 2) == 0) {
    return 0;
  }
  uint64_t v9 = sub_1B65623D0(*(__int16 *)(a1 + 368), 1, a3, a4, a5, a6, a7, a8);
  sub_1B656264C(v9, (CFTypeRef)(a1 + 304), v10, v11, v12, v13, v14, v15);
  return v9;
}

size_t sub_1B6494414(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  *(_WORD *)(a1 + 368) = sub_1B65625B4(a2, a2, a3, a4, a5, a6, a7, a8);
  *(unsigned char *)(a1 + 374) |= 1u;

  return sub_1B6562704(a2, (void *)(a1 + 176), v10, v11, v12, v13, v14, v15);
}

uint64_t sub_1B6494490(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if ((*(unsigned char *)(a1 + 374) & 1) == 0) {
    return 0;
  }
  uint64_t v9 = sub_1B65623D0(*(__int16 *)(a1 + 368), 1, a3, a4, a5, a6, a7, a8);
  sub_1B656264C(v9, (CFTypeRef)(a1 + 176), v10, v11, v12, v13, v14, v15);
  return v9;
}

size_t sub_1B6494504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  *(_WORD *)(a1 + 368) = sub_1B65625B4(a2, a2, a3, a4, a5, a6, a7, a8);
  *(unsigned char *)(a1 + 374) |= 4u;

  return sub_1B6562704(a2, (void *)(a1 + 240), v10, v11, v12, v13, v14, v15);
}

uint64_t sub_1B6494580(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if ((*(unsigned char *)(a1 + 374) & 4) == 0) {
    return 0;
  }
  uint64_t v9 = sub_1B65623D0(*(__int16 *)(a1 + 368), 1, a3, a4, a5, a6, a7, a8);
  sub_1B656264C(v9, (CFTypeRef)(a1 + 240), v10, v11, v12, v13, v14, v15);
  return v9;
}

CFStringRef sub_1B64945FC(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXSimpleAnimation>");
}

CFStringRef sub_1B6494630(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXSimpleAnimation>");
}

void sub_1B6494664(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  uint64_t v10 = sub_1B63F4F54(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v18 = sub_1B64B28B0(v10, v11, v12, v13, v14, v15, v16, v17);
    if (v18)
    {
      uint64_t v19 = v18;
      sub_1B63C16D8(v18, a1, v12, v13, v14, v15, v16, v17);
      if (!a1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"light");
      }
      if (a1[18].i64[0]) {
        sub_1B63C04CC(v19, a1);
      }
    }
  }

  sub_1B65E4FB4(a1, v11, v12, v13, v14, v15, v16, v17, a9);
}

uint64_t sub_1B6494714(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(void *)(a1 + 288);
}

void sub_1B6494760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4)
  {
    ++*(_DWORD *)(a1 + 388);
    uint64_t v9 = (const void *)sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v9, 0, 1u);
  }
}

float sub_1B6494804(unsigned int a1)
{
  float result = 0.0;
  if (a1 <= 6) {
    return flt_1B6E511F0[a1];
  }
  return result;
}

uint64_t sub_1B6494820()
{
  if (qword_1EB995530 != -1) {
    dispatch_once(&qword_1EB995530, &unk_1F0FB58C8);
  }
  return qword_1EB995538;
}

double sub_1B6494864()
{
  if (!qword_1EB995538)
  {
    v0 = (void *)sub_1B63C8D10(&qword_1EB995538);
    qword_1EB995538 = (uint64_t)v0;
    CFAllocatorRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"attenuationDistance", 0x54u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"color", 0x40u, 12, 0, 0, 0, v4, v5);
    sub_1B660E400(@"intensity", 0x58u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"orthographicScale", 0x70u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"shadowBias", 0x108u, 6, 0, 0, 0, v10, v11);
    sub_1B660E400(@"shadowIntensity", 0x60u, 1, 0, 0, 0, v12, v13);
    sub_1B660E400(@"shadowRadius", 0x74u, 1, 0, 0, 0, v14, v15);
    sub_1B660E400(@"spotFalloffExponent", 0x138u, 1, 0, 0, 0, v16, v17);
    sub_1B660E400(@"spotInnerAngle", 0x134u, 1, 0, 0, 0, v18, v19);
    sub_1B660E400(@"spotOuterAngle", 0x130u, 1, 0, 0, 0, v20, v21);
    sub_1B660E400(@"temperature", 0x5Cu, 1, 0, 0, 0, v22, v23);
    sub_1B660E400(@"zFar", 0x100u, 1, 0, 0, 0, v24, v25);
    sub_1B660E400(@"zNear", 0xFCu, 1, 0, 0, 0, v26, v27);
    sub_1B660E400(@"shadowCascadeDebugFactor", 0x80u, 1, 0, 0, 0, v28, v29);
    sub_1B660E400(@"areaExtents", 0x150u, 8, 0, 0, 0, v30, v31);
    sub_1B660E3EC();
    qword_1EB984328 = (uint64_t)sub_1B6498CB4;
    double result = *(double *)&xmmword_1F0FB8908;
    xmmword_1EB984318 = xmmword_1F0FB8908;
    qword_1EB984368 = (uint64_t)sub_1B6499F58;
  }
  return result;
}

uint64_t sub_1B6494ADC()
{
  if (qword_1EB995530 != -1) {
    dispatch_once(&qword_1EB995530, &unk_1F0FB58C8);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995538, 0x180uLL);
  v21[0] = 0;
  v21[1] = 0;
  sub_1B6494BF4((float32x4_t *)v0, 1, v1, v2, v3, v4, v5, v6);
  sub_1B63C8F2C((float *)v21, 1.0, 1.0, 1.0, 1.0);
  sub_1B6494CAC((float32x4_t *)v0, (float *)v21, v7, v8, v9, v10, v11, v12, v20);
  if (!v0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v13, v14, v15, v16, v17, v18, (uint64_t)"light");
  }
  *(void *)(v0 + 264) = 0x3FF0000000000000;
  *(int32x2_t *)(v0 + 104) = vdup_n_s32(0x44800000u);
  *(void *)(v0 + 252) = 0x42C800003DCCCCCDLL;
  *(void *)(v0 + 240) = -1;
  *(_WORD *)(v0 + 132) = 272;
  *(_OWORD *)(v0 + 84) = xmmword_1B6E51070;
  *(unsigned char *)(v0 + 249) = *(unsigned char *)(v0 + 249) & 0xC7 | 8;
  *(_DWORD *)(v0 + 128) = 0;
  *(_OWORD *)(v0 + 112) = xmmword_1B6E51080;
  sub_1B6494DE8(v0);
  return v0;
}

void sub_1B6494BF4(float32x4_t *a1, __int32 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] != a2)
  {
    sub_1B6494F88((uint64_t)a1);
    a1[5].i32[0] = a2;
    sub_1B6494DE8((uint64_t)a1);
    sub_1B6494664(a1, v10, v11, v12, v13, v14, v15, v16, v25);
    uint64_t v24 = (const void *)sub_1B63F4F54(a1, v17, v18, v19, v20, v21, v22, v23);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v24, 0, 1u);
  }
}

void sub_1B6494CAC(float32x4_t *a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"color");
LABEL_3:
  if (!sub_1B63C8DC4(a2, a1[4].f32))
  {
    BOOL v11 = sub_1B63C8E84(a1[4].f32);
    BOOL v12 = sub_1B63C8E84(a2);
    float32x4_t v21 = *(float32x4_t *)a2;
    a1[4] = *(float32x4_t *)a2;
    if (v11 || v12) {
      sub_1B6494664(a1, v13, v14, v15, v16, v17, v18, v19, v22);
    }
    sub_1B64954F4(a1, v13, v14, v15, v16, v17, v18, v19, v21, v20, a9);
  }
}

void sub_1B6494D90(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"light");
  }
  *(float *)(a1 + 96) = a2;
}

double sub_1B6494DE8(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 80))
  {
    case 3:
      double result = 8.58993629e10;
      *(void *)(a1 + 304) = 0x4234000042700000;
      *(_DWORD *)(a1 + 312) = 0x40000000;
      break;
    case 4:
      *(void *)(a1 + 304) = 0;
      *(_DWORD *)(a1 + 392) = 1;
      *(void *)(a1 + 384) = 0x1FFFFFFFFLL;
      *(_WORD *)(a1 + 396) = 0;
      double result = 0.0;
      __asm { FMOV            V1.4S, #10.0 }
      *(_OWORD *)(a1 + 320) = _Q1;
      *(_OWORD *)(a1 + 336) = 0u;
      *(unsigned char *)(a1 + 398) = 0;
      __asm { FMOV            V1.4S, #1.0 }
      *(_OWORD *)(a1 + 352) = _Q1;
      *(_OWORD *)(a1 + 368) = 0u;
      break;
    case 5:
      *(void *)(a1 + 368) = 0;
      *(unsigned char *)(a1 + 304) = *(unsigned char *)(a1 + 304) & 0xFC | 2;
      *(_OWORD *)(a1 + 320) = xmmword_1B6E511C0;
      *(_OWORD *)(a1 + 336) = unk_1B6E511D0;
      double result = 0.0;
      *(_OWORD *)(a1 + 352) = xmmword_1B6E511E0;
      break;
    case 6:
      *(void *)(a1 + 304) = 0;
      double result = 2.19902369e13;
      *(void *)(a1 + 312) = 0x42B4000042C80000;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1B6494EB8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  uint64_t result = *(void *)(a1 + 272);
  if (a2)
  {
    if (!result)
    {
      uint64_t result = sub_1B647541C(a1, 21);
      *(void *)(a1 + 272) = result;
    }
  }
  return result;
}

uint64_t sub_1B6494F20(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  uint64_t result = *(void *)(a1 + 280);
  if (a2)
  {
    if (!result)
    {
      uint64_t result = sub_1B647541C(a1, 24);
      *(void *)(a1 + 280) = result;
    }
  }
  return result;
}

void sub_1B6494F88(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 80);
  if (v2 == 4)
  {
LABEL_4:
    uint64_t v3 = *(const void **)(a1 + 304);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 304) = 0;
    }
    return;
  }
  if (v2 != 5)
  {
    if (v2 != 6) {
      return;
    }
    goto LABEL_4;
  }
  uint64_t v4 = *(const void **)(a1 + 368);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 368) = 0;
  }
  if (*(unsigned char *)(a1 + 320) == 4)
  {
    uint64_t v5 = *(void **)(a1 + 360);
    free(v5);
  }
}

void sub_1B6495014(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 5)
  {
    int v10 = *(unsigned __int8 *)(a1 + 320);
    int v11 = *a2;
    if (v10 != 4 || v11 == 4)
    {
      if (v11 == 4)
      {
        unint64_t v13 = a2[32];
        if (v13 > 2)
        {
          uint64_t v24 = (void *)*((void *)a2 + 5);
          if (v10 == 4) {
            uint64_t v25 = *(void **)(a1 + 360);
          }
          else {
            uint64_t v25 = 0;
          }
          uint64_t v26 = malloc_type_realloc(v25, 8 * v13, 0x9B7D0981uLL);
          uint64_t v27 = 0;
          *((void *)a2 + 5) = v26;
          float v28 = 0.0;
          do
          {
            uint64_t v29 = v24[v27];
            uint64_t v30 = v27 + 1;
            if (v13 - 1 == v27) {
              int v31 = 0;
            }
            else {
              int v31 = v27 + 1;
            }
            float v28 = v28
                + vmlas_n_f32((float)-*((float *)&v29 + 1) * COERCE_FLOAT(v24[v31]), COERCE_FLOAT(HIDWORD(v24[v31])), *(float *)&v29);
            uint64_t v27 = v30;
          }
          while (v13 != v30);
          if (v28 >= 0.0)
          {
            memcpy(v26, v24, 8 * v13);
          }
          else
          {
            do
              *v26++ = v24[(int)--v13];
            while (v13);
          }
        }
        else
        {
          *a2 = 1;
          *(void *)&long long v14 = 0x3F0000003F000000;
          *((void *)&v14 + 1) = 0x3F0000003F000000;
          *((_OWORD *)a2 + 1) = v14;
        }
      }
    }
    else
    {
      free(*(void **)(a1 + 360));
    }
    long long v15 = *(_OWORD *)a2;
    long long v16 = *((_OWORD *)a2 + 2);
    *(_OWORD *)(a1 + 336) = *((_OWORD *)a2 + 1);
    *(_OWORD *)(a1 + 352) = v16;
    *(_OWORD *)(a1 + 320) = v15;
    sub_1B64968E0(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    sub_1B6496EB0((float32x4_t *)a1, v17, v18, v19, v20, v21, v22, v23);
  }
}

uint64_t sub_1B64951A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 80);
  if (v9 == 5) {
    int v10 = (*(unsigned char *)(a1 + 320) & 7) << 7;
  }
  else {
    int v10 = 0;
  }
  uint64_t v11 = *(void *)(a1 + 272);
  if (v11)
  {
    if (sub_1B6475F88(v11, a2, a3, a4, a5, a6, a7, a8)) {
      int v12 = 8;
    }
    else {
      int v12 = 0;
    }
    int v13 = *(_DWORD *)(a1 + 80);
  }
  else
  {
    int v12 = 0;
    int v13 = v9;
  }
  if ((v13 - 1) < 2) {
    goto LABEL_16;
  }
  if (v13 == 3)
  {
    float v14 = *(float *)(a1 + 304);
  }
  else
  {
    if (v13 != 6) {
      goto LABEL_17;
    }
    float v14 = *(float *)(a1 + 316);
  }
  if (v14 < 180.0)
  {
LABEL_16:
    BOOL v15 = *(unsigned char *)(a1 + 248) != 0;
    goto LABEL_18;
  }
LABEL_17:
  BOOL v15 = 0;
LABEL_18:
  if (v15) {
    int v16 = 16;
  }
  else {
    int v16 = 0;
  }
  uint64_t result = v10 | v12 | v9 & 7 | v16;
  if (v15)
  {
    if (*(unsigned __int8 *)(a1 + 132) >= 0x40u) {
      unsigned int v18 = 64;
    }
    else {
      unsigned int v18 = *(unsigned __int8 *)(a1 + 132);
    }
    if (*(unsigned char *)(a1 + 132)) {
      char v19 = v18;
    }
    else {
      char v19 = 1;
    }
    int v20 = (v19 & 0x1F) << 10;
    if (v18 >= 0x1F) {
      int v20 = 31744;
    }
    if (*(float *)(a1 + 116) == 0.0) {
      int v20 = 1024;
    }
    uint64_t result = v20 | (32 * (*(float *)(a1 + 96) < 1.0)) | result;
    if (v13 == 2)
    {
      unsigned int v21 = *(unsigned __int8 *)(a1 + 133);
      uint64_t result = result & 0xFFFC7FFF | ((v21 & 7) << 15);
      if (v21 >= 2) {
        return result | ((*(float *)(a1 + 128) != 0.0) << 19) | 0x40000;
      }
    }
  }
  return result;
}

uint64_t sub_1B64952FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(a1 + 272);
  if (result) {
    return sub_1B6475F88(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B649530C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  if ((v1 - 1) < 2) {
    return 1;
  }
  if (v1 == 6)
  {
    float v2 = *(float *)(a1 + 316);
    return v2 < 180.0;
  }
  if (v1 == 3)
  {
    float v2 = *(float *)(a1 + 304);
    return v2 < 180.0;
  }
  return 0;
}

uint64_t sub_1B649535C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(unsigned __int8 *)(a1 + 248);
}

uint64_t sub_1B64953A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(unsigned __int8 *)(a1 + 132) >= 0x40u) {
    unsigned int v9 = 64;
  }
  else {
    unsigned int v9 = *(unsigned __int8 *)(a1 + 132);
  }
  if (*(unsigned char *)(a1 + 132)) {
    return v9;
  }
  else {
    return 1;
  }
}

float sub_1B6495408(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 116);
}

BOOL sub_1B6495454(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(_DWORD *)(a1 + 80) == 2;
}

uint64_t sub_1B64954A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(unsigned __int8 *)(a1 + 133);
}

void sub_1B64954F4(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, uint64_t a11)
{
  if (a1[5].i32[0] == 5) {
    sub_1B6496C8C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }

  sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a11);
}

uint64_t sub_1B649553C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return a1 + 64;
}

float sub_1B6495588(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 96);
}

void sub_1B64955D4(float32x4_t *a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] == 6)
  {
    int v10 = (const void *)a1[19].i64[0];
    if (v10 != cf)
    {
      if (v10)
      {
        CFRelease(v10);
        a1[19].i64[0] = 0;
      }
      if (cf) {
        CFTypeRef v11 = CFRetain(cf);
      }
      else {
        CFTypeRef v11 = 0;
      }
      a1[19].i64[0] = (uint64_t)v11;
    }
    uint64_t v12 = j__objc_msgSend__infoHangle(cf, (const char *)cf, a3, a4);
    if (v12)
    {
      a1[19].i32[3] = *(_DWORD *)(v12 + 20);
      float v20 = *(float *)(v12 + 4);
    }
    else
    {
      a1[19].i32[3] = 1110704128;
      float v20 = 1.0;
    }
    a1[19].f32[2] = v20;
    sub_1B6494664(a1, v13, v14, v15, v16, v17, v18, v19, v29);
    float v28 = (const void *)sub_1B63F4F54(a1, v21, v22, v23, v24, v25, v26, v27);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v28, 0, 1u);
  }
}

uint64_t sub_1B64956D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) != 6) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Light should be a IES", a3, a4, a5, a6, a7, a8, (uint64_t)"light->_type == kCFXLightTypeIES");
  }
  return *(void *)(a1 + 304);
}

float sub_1B6495748(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) != 6) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Light should be a IES", a3, a4, a5, a6, a7, a8, (uint64_t)"light->_type == kCFXLightTypeIES");
  }
  return *(float *)(a1 + 316);
}

uint64_t sub_1B64957BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"projInfoOut");
LABEL_3:
  int v10 = *(_DWORD *)(a1 + 80);
  float v11 = 60.0;
  float v12 = 90.0;
  switch(v10)
  {
    case 1:
    case 4:
      break;
    case 3:
      float v11 = *(float *)(a1 + 304);
      goto LABEL_5;
    case 6:
      float v12 = *(float *)(a1 + 316);
      break;
    default:
LABEL_5:
      BOOL v13 = v11 < 180.0 && v11 > 0.0;
      float v12 = 60.0;
      if (v13) {
        float v12 = v11;
      }
      break;
  }
  char v14 = *(unsigned char *)a2 & 0xC2 | (v10 == 2);
  *(unsigned char *)a2 = v14;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  __asm { FMOV            V1.2S, #1.0 }
  *(void *)(a2 + 32) = _D1;
  float v20 = *(float *)(a1 + 252);
  float v21 = *(float *)(a1 + 256);
  if (v21 == 0.0) {
    float v21 = 100.0;
  }
  *(float *)(a2 + 4) = v20;
  *(float *)(a2 + 8) = v21;
  if (v20 == 0.0) {
    *(_DWORD *)(a2 + 4) = 1065353216;
  }
  *(unsigned char *)a2 = v14 & 0xC1;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 112);
  *(float *)(a2 + 44) = v12;
  return 1;
}

float sub_1B6495918(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 3) {
    return *(float *)(a1 + 304);
  }
  else {
    return 60.0;
  }
}

float sub_1B649597C(uint64_t a1, int a2, float a3)
{
  float v3 = *(float *)(a1 + 84) * a3;
  float v4 = fmaxf(v3, 0.0);
  if (!a2) {
    return v4;
  }
  if (v3 <= 0.0) {
    return 0.0;
  }
  return -1.0 / v3;
}

void sub_1B64959FC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  if (v1 == 3)
  {
    float v2 = fminf(*(float *)(a1 + 304), 180.0);
    float v4 = *(float *)(a1 + 308);
    if (v4 >= (float)(v2 + -0.1)) {
      float v4 = v2 + -0.1;
    }
    double v3 = (float)(v4 * 0.5);
  }
  else
  {
    float v2 = 0.0;
    double v3 = 0.0;
    if (v1 == 6) {
      float v2 = *(float *)(a1 + 316);
    }
  }
  float v5 = v3 / 180.0 * 3.14159265;
  cosf(v5);
  float v6 = (float)(v2 * 0.5) / 180.0 * 3.14159265;
  fmaxf(cosf(v6), 0.0);
}

float sub_1B6495B40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 84);
}

uint64_t sub_1B6495B8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(unsigned char *)(a1 + 249) & 1;
}

void sub_1B6495BDC(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  __int8 v10 = a1[15].i8[9];
  if (((((v10 & 1) == 0) ^ v8) & 1) == 0)
  {
    a1[15].i8[9] = v10 & 0xFE | v8;
    sub_1B6494664(a1, a2, a3, a4, a5, a6, a7, a8, v19);
    uint64_t v18 = (const void *)sub_1B63F4F54(a1, v11, v12, v13, v14, v15, v16, v17);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v18, 0, 1u);
  }
}

void sub_1B6495C94(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[15].u8[8] != v9)
  {
    a1[15].i8[8] = v9;
    uint64_t v11 = (const void *)sub_1B63F4F54(a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v11, 0, 1u);
    sub_1B6494664(a1, v12, v13, v14, v15, v16, v17, v18, a9);
  }
}

uint64_t sub_1B6495D3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(void *)(a1 + 240);
}

void sub_1B6495D88(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[15].i64[0] != a2)
  {
    a1[15].i64[0] = a2;
    sub_1B6494664(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

float sub_1B6495E08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 88);
}

void sub_1B6495E54(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, uint64_t a11)
{
  unsigned __int32 v11 = a9.i32[0];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  a1[5].i32[2] = v11;

  sub_1B64954F4(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

float sub_1B6495EC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  uint64_t v9 = *(int *)(a1 + 80);
  float v10 = 0.0;
  if (v9 <= 6) {
    float v10 = flt_1B6E511F0[v9];
  }
  return *(float *)(a1 + 88) / v10;
}

float sub_1B6495F2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 112);
}

void sub_1B6495F78(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  a1[7].f32[0] = a9;

  sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a10);
}

double sub_1B6495FE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(double *)(a1 + 264);
}

void sub_1B6496030(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  *(double *)(a1 + 264) = a9;

  sub_1B65E4FB4((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8, a10);
}

double sub_1B649609C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(double *)(a1 + 104);
}

void sub_1B64960E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x2_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  uint32x2_t v12 = (uint32x2_t)vcge_f32((float32x2_t)0x3400000034000000, vabd_f32(a9, *(float32x2_t *)(a1 + 104)));
  if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) == 0)
  {
    *(double *)(a1 + 104) = *(double *)&a9;
    uint64_t v13 = (const void *)sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v13, 0, 1u);
    sub_1B6494664((float32x4_t *)a1, v14, v15, v16, v17, v18, v19, v20, a10);
  }
}

void sub_1B64961AC(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  float v12 = a1[7].f32[1];
  if (v12 != a9)
  {
    a1[7].f32[1] = a9;
    if (a9 == 0.0 || v12 == 0.0)
    {
      uint64_t v13 = (const void *)sub_1B63F4F54(a1, a2, a3, a4, a5, a6, a7, a8);
      sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v13, 0, 1u);
      sub_1B6494664(a1, v14, v15, v16, v17, v18, v19, v20, a10);
    }
  }
}

uint64_t sub_1B6496270(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(unsigned __int8 *)(a1 + 132);
}

void sub_1B64962BC(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[8].u8[4] != v9)
  {
    a1[8].i8[4] = v9;
    unsigned __int32 v11 = (const void *)sub_1B63F4F54(a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v11, 0, 1u);
    sub_1B6494664(a1, v12, v13, v14, v15, v16, v17, v18, a9);
  }
}

float sub_1B6496364(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  float result = 2.0;
  if (*(_DWORD *)(a1 + 80) == 3) {
    return *(float *)(a1 + 312);
  }
  return result;
}

void sub_1B64963C0(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] == 3)
  {
    a1[19].f32[2] = a9;
    sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a10);
  }
}

float sub_1B649644C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 3) {
    return *(float *)(a1 + 308);
  }
  else {
    return 45.0;
  }
}

void sub_1B64964B0(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] == 3)
  {
    a1[19].f32[1] = a9;
    sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a10);
  }
}

void sub_1B649653C(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] == 3)
  {
    a1[19].f32[0] = a9;
    sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a10);
  }
}

float sub_1B64965C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 92);
}

void sub_1B6496614(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, uint64_t a11)
{
  unsigned __int32 v11 = a9.i32[0];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  a1[5].i32[3] = v11;

  sub_1B64954F4(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t sub_1B6496680(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(unsigned int *)(a1 + 80);
}

float sub_1B64966CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 256);
}

void sub_1B6496718(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  a1[16].f32[0] = a9;

  sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a10);
}

float sub_1B6496784(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 252);
}

void sub_1B64967D0(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  a1[15].f32[3] = a9;

  sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a10);
}

uint64_t sub_1B649683C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80) != 5 || (*(unsigned char *)(a1 + 304) & 2) == 0) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 368);
  if (!v2)
  {
    uint64_t v2 = -[VFXModel __createCFObject]_0();
    *(void *)(a1 + 368) = v2;
    float v4 = (void *)sub_1B64AED1C();
    uint64_t v12 = sub_1B64AF43C((uint64_t)v4, v5, v6, v7, v8, v9, v10, v11);
    sub_1B6475724(v12, 0, v13, v14, v15, v16, v17, v18);
    sub_1B64AF4E4((uint64_t)v4, 1, v19, v20, v21, v22, v23, v24);
    sub_1B63CE298(v2, v4, v25, v26, v27, v28, v29, v30);
    if (v4) {
      CFRelease(v4);
    }
    sub_1B64968E0(a1, v31, v32, v33, v34, v35, v36, v37);
    sub_1B6496C8C(a1, v38, v39, v40, v41, v42, v43, v44, v45, v46);
  }
  return v2;
}

void sub_1B64968E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 368);
  if (v8)
  {
    switch(*(unsigned char *)(a1 + 320))
    {
      case 0:
        float v10 = *(float *)(a1 + 336);
        *(float *)bytes = -v10;
        uint64_t v68 = 0;
        *(float *)uint64_t v69 = v10;
        *(void *)&v69[4] = 0;
        *(_WORD *)uint64_t v66 = 256;
        CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDataRef v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 24);
        values = (void *)sub_1B641CF98(v12, 0, 2, 3, 1, v13, v14, v15);
        CFRelease(v12);
        CFDataRef v16 = CFDataCreate(v11, v66, 2);
        uint64_t v64 = (void *)sub_1B63D0314();
        sub_1B63D05D4((uint64_t)v64, 2, 1, v16, 1, v17, v18, v19);
        CFRelease(v16);
        char v63 = 0;
        uint64_t v20 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        CFArrayRef v21 = CFArrayCreate(v11, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
        CFArrayRef v22 = CFArrayCreate(v11, (const void **)&v64, 1, v20);
        uint64_t v28 = (const void *)sub_1B63DC55C(v21, v22, (uint64_t)&v63, v23, v24, v25, v26, v27);
        sub_1B65834BC((uint64_t)v28, @"Area Light - Line", v29, v30, v31, v32, v33, v34);
        CFRelease(v22);
        CFRelease(v21);
        uint64_t v35 = v64;
        goto LABEL_18;
      case 1:
        uint64_t v37 = sub_1B6549D0C(0, 1, 1, 0, COERCE_FLOAT(*(_OWORD *)(a1 + 336)) + COERCE_FLOAT(*(_OWORD *)(a1 + 336)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 336))) + COERCE_FLOAT(HIDWORD(*(void *)(a1 + 336))), 0.0);
        uint64_t v28 = (const void *)v37;
        CFStringRef v44 = @"Area light - Rectangle";
        goto LABEL_10;
      case 2:
        uint64_t v37 = sub_1B6549D0C(0, 1, 1, 0, COERCE_FLOAT(*(_OWORD *)(a1 + 336)) + COERCE_FLOAT(*(_OWORD *)(a1 + 336)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 336))) + COERCE_FLOAT(HIDWORD(*(void *)(a1 + 336))), 0.0);
        uint64_t v28 = (const void *)v37;
        CFStringRef v44 = @"Area Light - Ellipse";
        goto LABEL_10;
      case 3:
        uint64_t v37 = sub_1B6523ED8(0, 1, 1, 1, 0, 0, *(float *)(a1 + 336) + *(float *)(a1 + 336), *(float *)(a1 + 340) + *(float *)(a1 + 340), *(float *)(a1 + 344) + *(float *)(a1 + 344), 0.0);
        uint64_t v28 = (const void *)v37;
        CFStringRef v44 = @"Area Light - Ellipsoid";
LABEL_10:
        sub_1B65834BC(v37, v44, v38, v39, v40, v41, v42, v43);
        goto LABEL_19;
      case 4:
        Mutable = CGPathCreateMutable();
        if (*(unsigned char *)(a1 + 352))
        {
          unint64_t v52 = 0;
          do
          {
            float32x2_t v53 = vmul_f32(*(float32x2_t *)(*(void *)(a1 + 360) + 8 * v52), (float32x2_t)0x3F800000BF800000);
            double v54 = v53.f32[0];
            double v55 = v53.f32[1];
            if (v52) {
              CGPathAddLineToPoint(Mutable, 0, v54, v55);
            }
            else {
              CGPathMoveToPoint(Mutable, 0, v54, v55);
            }
            ++v52;
          }
          while (v52 < *(unsigned __int8 *)(a1 + 352));
        }
        CGPathCloseSubpath(Mutable);
        *(float *)bytes = 0.0;
        uint64_t v68 = 1065353216;
        *(void *)uint64_t v69 = 0;
        *(_DWORD *)&v69[8] = 2139095039;
        uint64_t v70 = Mutable;
        uint64_t v71 = 0;
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        uint64_t v56 = (const void *)sub_1B6629578((uint64_t)bytes);
        *(float *)bytes = 0.0;
        uint64_t v68 = 1065353216;
        *(void *)uint64_t v69 = 0;
        *(_DWORD *)&v69[8] = 2139095039;
        uint64_t v70 = Mutable;
        uint64_t v71 = 0;
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        uint64_t v28 = (const void *)sub_1B65E143C((uint64_t)v56, (long long *)bytes);
        sub_1B65834BC((uint64_t)v28, @"Area light - Polygon", v57, v58, v59, v60, v61, v62);
        CFRelease(v56);
        uint64_t v35 = Mutable;
LABEL_18:
        CFRelease(v35);
LABEL_19:
        sub_1B63CDBD0(v8, (uint64_t)v28, v45, v46, v47, v48, v49, v50);
        if (v28) {
          CFRelease(v28);
        }
        break;
      default:
        uint64_t v36 = *(void *)(a1 + 368);
        sub_1B63CDBD0(v36, 0, a3, a4, a5, a6, a7, a8);
        break;
    }
  }
}

void sub_1B6496C8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10)
{
  uint64_t v10 = *(void *)(a1 + 368);
  if (v10)
  {
    *(__n128 *)bytes = sub_1B64972E4((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    CFArrayRef v18 = sub_1B63CCF34(v10, 0, v12, v13, v14, v15, v16, v17);
    sub_1B64AF354((uint64_t)v18, *(unsigned char *)(a1 + 304) & 1, v19, v20, v21, v22, v23, v24);
    switch(*(unsigned char *)(a1 + 320))
    {
      case 0:
      case 1:
      case 4:
        uint64_t v32 = sub_1B64AF43C((uint64_t)v18, v25, v26, v27, v28, v29, v30, v31);
        sub_1B64760E8(v32, 1, (float *)bytes, v33, v34, v35, v36, v37);
        break;
      case 2:
        uint64_t v38 = @"area_shape_ellipse_frag";
        goto LABEL_6;
      case 3:
        sub_1B64AF354((uint64_t)v18, 1, v26, v27, v28, v29, v30, v31);
        uint64_t v38 = @"area_shape_ellipsoid_frag";
LABEL_6:
        uint64_t v39 = sub_1B6450670(@"area_shape_vert", v38);
        sub_1B64AFD94((uint64_t)v18, v39, v40, v41, v42, v43, v44, v45);
        CFRelease(v39);
        CFAllocatorRef v46 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v47 = (__int16 *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 16);
        sub_1B6584BAC((uint64_t)v18, @"color", v47, v48, v49, v50, v51, v52);
        CFRelease(v47);
        long long v53 = *(_OWORD *)(a1 + 336);
        HIDWORD(v53) = 0;
        long long v60 = v53;
        double v54 = (__int16 *)CFDataCreate(v46, (const UInt8 *)&v60, 16);
        sub_1B6584BAC((uint64_t)v18, @"halfExtents", v54, v55, v56, v57, v58, v59);
        CFRelease(v54);
        break;
      default:
        return;
    }
  }
}

void sub_1B6496E04(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] == 5)
  {
    if (v8) {
      char v10 = 2;
    }
    else {
      char v10 = 0;
    }
    a1[19].i8[0] = a1[19].i8[0] & 0xFD | v10;
    if ((v8 & 1) == 0)
    {
      CFAllocatorRef v11 = (const void *)a1[23].i64[0];
      if (v11)
      {
        CFRelease(v11);
        a1[23].i64[0] = 0;
      }
    }
    sub_1B6496EB0(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B6496EB0(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B6494664(a1, a2, a3, a4, a5, a6, a7, a8, v21);
  uint64_t v16 = sub_1B63F4F54(a1, v9, v10, v11, v12, v13, v14, v15);

  sub_1B64B1F18(v16, 9, a1, 0, v17, v18, v19, v20);
}

uint64_t sub_1B6496EF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 5) {
    return (*(unsigned __int8 *)(a1 + 304) >> 1) & 1;
  }
  else {
    return 0;
  }
}

void sub_1B6496F5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (*(_DWORD *)(a1 + 80) == 5)
  {
    *(__n128 *)(a1 + 336) = a9;
    sub_1B64968E0(a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B6496EB0((float32x4_t *)a1, v10, v11, v12, v13, v14, v15, v16);
  }
}

__n128 sub_1B6496FB0(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  result.n128_u64[0] = 0;
  if (a1[5].n128_u32[0] == 5) {
    return a1[21];
  }
  return result;
}

void sub_1B649700C(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, uint64_t a11)
{
  char v11 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] == 5)
  {
    a1[19].i8[0] = a1[19].i8[0] & 0xFE | v11;
    sub_1B6496C8C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    sub_1B65E4FB4(a1, v13, v14, v15, v16, v17, v18, v19, a11);
  }
}

uint64_t sub_1B64970A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 5) {
    return *(unsigned char *)(a1 + 304) & 1;
  }
  else {
    return 0;
  }
}

__n128 sub_1B6497104@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a2, a3, a4, a5, a6, a7, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 5) {
    uint64_t v10 = (long long *)(a1 + 320);
  }
  else {
    uint64_t v10 = &xmmword_1B6E511C0;
  }
  long long v11 = v10[1];
  *(_OWORD *)a8 = *v10;
  *(_OWORD *)(a8 + 16) = v11;
  __n128 result = (__n128)v10[2];
  *(__n128 *)(a8 + 32) = result;
  return result;
}

BOOL sub_1B6497178(uint64_t a1)
{
  return *(_DWORD *)(a1 + 80) == 6 && *(void *)(a1 + 304) != 0;
}

BOOL sub_1B649719C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(float *)(a1 + 88) == 0.0) {
    return 1;
  }

  return sub_1B63C8E84((float *)(a1 + 64));
}

double sub_1B6497218(float32x4_t *a1, float32x4_t a2, float32x4_t a3)
{
  a2.i32[0] = a1[5].i32[3];
  if (a2.f32[0] == 0.0)
  {
    float32x4_t v3 = (float32x4_t)xmmword_1B6E4F300;
  }
  else
  {
    a3.i32[0] = 1170939904;
    int8x16_t v4 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a3, a2)), 0);
    float32x4_t v5 = vaddq_f32((float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B6E510A0, (int8x16_t)xmmword_1B6E51090), vdivq_f32((float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B6E510C0, (int8x16_t)xmmword_1B6E510B0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), (float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B6E510E0, (int8x16_t)xmmword_1B6E510D0))));
    v5.i32[3] = 0;
    float32x4_t v6 = vmaxnmq_f32(v5, (float32x4_t)0);
    v6.i32[3] = 0;
    float32x4_t v3 = vminnmq_f32(v6, (float32x4_t)xmmword_1B6E4F540);
  }
  *(void *)&double result = vmulq_f32(v3, a1[4]).u64[0];
  return result;
}

double sub_1B64972C4(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10)
{
  *(void *)&double result = sub_1B64972E4(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10).n128_u64[0];
  return result;
}

__n128 sub_1B64972E4(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10)
{
  a9.i32[0] = a1[5].i32[3];
  if (a9.f32[0] == 0.0)
  {
    float32x4_t v10 = (float32x4_t)xmmword_1B6E4F300;
  }
  else
  {
    a10.i32[0] = 1170939904;
    int8x16_t v11 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a10, a9)), 0);
    float32x4_t v12 = vaddq_f32((float32x4_t)vbslq_s8(v11, (int8x16_t)xmmword_1B6E510A0, (int8x16_t)xmmword_1B6E51090), vdivq_f32((float32x4_t)vbslq_s8(v11, (int8x16_t)xmmword_1B6E510C0, (int8x16_t)xmmword_1B6E510B0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 0), (float32x4_t)vbslq_s8(v11, (int8x16_t)xmmword_1B6E510E0, (int8x16_t)xmmword_1B6E510D0))));
    v12.i32[3] = 0;
    float32x4_t v13 = vmaxnmq_f32(v12, (float32x4_t)0);
    v13.i32[3] = 0;
    float32x4_t v10 = vminnmq_f32(v13, (float32x4_t)xmmword_1B6E4F540);
  }
  float32x4_t v14 = vmulq_f32(v10, a1[4]);
  float32x4_t v15 = v14;
  if (a1[5].i32[0] == 6)
  {
    float32x4_t v16 = vmulq_n_f32(v14, a1[19].f32[2] * 0.0014641);
    v16.i32[3] = HIDWORD(*(_OWORD *)&a1[4]);
    float32x4_t v18 = v16;
  }
  else
  {
    v15.i32[3] = HIDWORD(*(_OWORD *)&a1[4]);
    float32x4_t v18 = v15;
  }
  result.n128_u64[0] = vmulq_n_f32(v18, sub_1B6495EC0((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8)).u64[0];
  result.n128_u32[3] = v18.u32[3];
  return result;
}

void sub_1B64973E4(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  float v12 = a1[5].f32[1];
  a1[5].f32[1] = a9;
  if ((a9 == 0.0) == (v12 == 0.0))
  {
    sub_1B65E4FB4(a1, a2, a3, a4, a5, a6, a7, a8, a10);
  }
  else
  {
    sub_1B6494664(a1, a2, a3, a4, a5, a6, a7, a8, a10);
  }
}

void sub_1B6497490(float32x4_t *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  CFTypeRef v11 = (CFTypeRef)a1[18].i64[1];
  if (v11 != cf)
  {
    if (v11)
    {
      CFRelease(v11);
      a1[18].i64[1] = 0;
    }
    if (cf) {
      CFTypeRef v12 = CFRetain(cf);
    }
    else {
      CFTypeRef v12 = 0;
    }
    a1[18].i64[1] = (uint64_t)v12;
    sub_1B6494664(a1, (uint64_t)cf, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B6497530(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(void *)(a1 + 296);
}

void sub_1B649757C(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int8 v9 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].i32[0] == 4)
  {
    a1[24].i8[12] = v9;
    sub_1B6494664(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B64975FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    return *(unsigned __int8 *)(a1 + 396);
  }
  else {
    return 0;
  }
}

void sub_1B649765C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4 && *(unsigned char *)(a1 + 396) == 1 && *(unsigned __int8 *)(a1 + 397) != v8)
  {
    *(unsigned char *)(a1 + 397) = v8;
    sub_1B64976F4(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B64976F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4 && *(unsigned char *)(a1 + 396) == 1)
  {
    ++*(_DWORD *)(a1 + 392);
    __int8 v9 = (const void *)sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v9, 0, 1u);
  }
}

uint64_t sub_1B64977A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    return *(unsigned __int8 *)(a1 + 397);
  }
  else {
    return 0;
  }
}

void sub_1B6497804(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    *(unsigned char *)(a1 + 398) = a2;
  }
}

BOOL sub_1B6497860(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(_DWORD *)(a1 + 80) == 4 && *(unsigned char *)(a1 + 398) != 0;
}

void sub_1B64978C8(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"light");
    a2 = v10;
  }
  if (a1[5].n128_u32[0] == 4) {
    a1[23] = a2;
  }
}

__n128 sub_1B6497928(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  result.n128_u64[0] = 0;
  if (a1[5].n128_u32[0] == 4) {
    return a1[23];
  }
  return result;
}

void sub_1B6497984(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"light");
    a2 = v10;
  }
  if (a1[5].n128_u32[0] == 4) {
    a1[22] = a2;
  }
}

__n128 sub_1B64979E4(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].n128_u32[0] == 4) {
    return a1[22];
  }
  else {
    __asm { FMOV            V0.4S, #1.0 }
  }
  return result;
}

float32x4_t sub_1B6497A44(float32x4_t *a1, float32x4_t result, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    float32x4_t v10 = result;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"light");
    __n128 result = v10;
  }
  if (a1[5].i32[0] == 4)
  {
    result.i32[3] = 0;
    __n128 result = vminnmq_f32(result, (float32x4_t)xmmword_1B6E510F0);
    a1[20] = result;
  }
  return result;
}

__n128 sub_1B6497AB4(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a1[5].n128_u32[0] == 4) {
    return a1[20];
  }
  else {
    __asm { FMOV            V0.4S, #10.0 }
  }
  return result;
}

void sub_1B6497B14(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"light");
    a2 = v10;
  }
  if (a1[5].n128_u32[0] == 4) {
    a1[21] = a2;
  }
}

__n128 sub_1B6497B74(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  result.n128_u64[0] = 0;
  if (a1[5].n128_u32[0] == 4) {
    return a1[21];
  }
  return result;
}

void sub_1B6497BD0(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    *(_WORD *)(a1 + 384) = a2;
  }
}

uint64_t sub_1B6497C2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4) {
    return *(__int16 *)(a1 + 384);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_1B6497C8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (*(_DWORD *)(a1 + 80) == 4 && *(unsigned char *)(a1 + 396) == 1) {
    return *(unsigned int *)(a1 + 392);
  }
  else {
    return 1;
  }
}

float sub_1B6497CF8(unsigned int a1, float a2)
{
  float v2 = 0.0;
  if (a1 <= 6) {
    float v2 = flt_1B6E511F0[a1];
  }
  if (a1 == 6) {
    a2 = a2 * 0.683;
  }
  return (float)(a2 * v2) / 1000.0;
}

float sub_1B6497D38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9)
{
  __n128 v10 = (float32x4_t *)sub_1B64A01D4(a2, a2, a3, a4, a5, a6, a7, a8);
  int v11 = *(_DWORD *)(a1 + 80);
  if ((v11 | 2) != 3) {
    return 1.0;
  }
  float32x4_t v12 = vsubq_f32(v10[3], a9);
  float v13 = *(float *)(a1 + 84);
  float v14 = 1.0;
  if (v13 > 0.0)
  {
    *(float *)&unsigned int v15 = v13 * v13;
    float32x2_t v16 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v13 * v13));
    _D0 = vmul_f32(v16, vrecps_f32((float32x2_t)v15, v16));
    _D0.i32[0] = vmul_f32(_D0, vrecps_f32((float32x2_t)v15, _D0)).u32[0];
    _Q1 = vmulq_f32(v12, v12);
    _Q1.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q1, 2), vaddq_f32(_Q1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.f32, 1))).u32[0];
    __asm { FMLS            S4, S0, V1.S[0] }
    _D0.f32[0] = fminf(fmaxf(_S4, 0.0), 1.0);
    float v14 = (float)(1.0 / fmaxf(_Q1.f32[0], 0.0001)) * (float)(_D0.f32[0] * _D0.f32[0]);
  }
  if (v11 == 3)
  {
    float32x4_t v32 = v12;
    float32x4_t v34 = vnegq_f32(v10[2]);
    sub_1B64959FC(a1);
    int32x4_t v24 = (int32x4_t)vmulq_f32(v32, v32);
    v24.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v24, 2), vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v24.i8, 1))).u32[0];
    float32x2_t v25 = vrsqrte_f32((float32x2_t)v24.u32[0]);
    float32x2_t v26 = vmul_f32(v25, vrsqrts_f32((float32x2_t)v24.u32[0], vmul_f32(v25, v25)));
    float32x4_t v27 = vmulq_f32(vmulq_n_f32(v32, vmul_f32(v26, vrsqrts_f32((float32x2_t)v24.u32[0], vmul_f32(v26, v26))).f32[0]), v34);
    float v30 = fminf(fmaxf(vmlas_n_f32(v29, v28, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]), 0.0), 1.0);
    return v14 * (float)(v30 * v30);
  }
  return v14;
}

void sub_1B6497EA0(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a5;
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (a4) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, a4, a5, a6, a7, a8, (uint64_t)"light");
    if (a4) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"lightNode");
LABEL_3:
  uint64_t v13 = sub_1B64A01D4(a4, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  long long v69 = *(_OWORD *)(v13 + 32);
  float32x4_t v71 = *(float32x4_t *)(v13 + 48);
  v77.i32[2] = 0;
  v77.i64[0] = 0;
  __n128 v20 = sub_1B64A1EC8(a2, (__n128 *)&v77, v14, v15, v16, v17, v18, v19);
  __n128 v74 = sub_1B64972E4(a3, v21, v22, v23, v24, v25, v26, v27, (float32x4_t)v20, v28);
  float32x4_t v35 = vmulq_n_f32((float32x4_t)v74, sub_1B6497D38((uint64_t)a3, a4, v29, v30, v31, v32, v33, v34, v77));
  __int32 v36 = a3[5].i32[0];
  if (v36 == 1)
  {
    float32x4_t v38 = vsubq_f32(v71, v77);
    float32x4_t v39 = vmulq_f32(v38, v38);
    float32x4_t v40 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1);
    v40.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, v40)).f32[0]);
    long long v88 = xmmword_1B6E51100;
    uint64_t v89 = 0x3F88CF6B3F973FD9;
    float32x4_t v75 = v35;
    if (v40.f32[0] <= 0.1)
    {
      float v41 = 1.5708;
    }
    else
    {
      uint64_t v70 = v40.i64[0];
      float32x4_t v72 = v38;
      float v41 = asinf(0.1 / v40.f32[0]);
      v40.i64[0] = v70;
      float32x4_t v38 = v72;
    }
    float32x4_t v73 = vdivq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 0));
    __float2 v42 = __sincosf_stret(v41);
    v78[0] = 1.7725 - (float)(v42.__cosval * 1.7725);
    v78[1] = (float)((float)(v42.__sinval * v42.__sinval) * 3.07) * 0.5;
    if (v9 < 3)
    {
      float32x4_t v43 = v75;
      if (v9 != 2) {
        return;
      }
      int v79 = 1049652923;
      float v48 = v73.f32[2] * 0.488602512;
      float v80 = vmuls_lane_f32(-0.4886, *(float32x2_t *)v73.f32, 1);
      float v81 = v48;
      float v82 = -0.4886 * v73.f32[0];
    }
    else
    {
      v78[2] = (float)((float)(v42.__cosval * -3.9633) * (float)((float)(v42.__cosval * v42.__cosval) + -1.0)) * 0.5;
      float32x4_t v43 = v75;
      if (v9 == 3)
      {
        float32x2_t v44 = *(float32x2_t *)v73.f32;
        int v79 = 1049652923;
        float v45 = v73.f32[2] * 0.488602512;
        float v46 = vmuls_lane_f32(v73.f32[2], v73, 2) * 0.946174696 + -0.315391565;
        float v80 = vmuls_lane_f32(-0.4886, *(float32x2_t *)v73.f32, 1);
        float v81 = v45;
        float v47 = v73.f32[2] * -1.09254843;
        float v84 = vmuls_lane_f32(v47, *(float32x2_t *)v73.f32, 1);
        float v85 = v46;
        float v82 = -0.4886 * v73.f32[0];
        float v83 = vmlas_n_f32(vmuls_lane_f32(v44.f32[0], v44, 1), v73.f32[1], v73.f32[0]) * 0.54627;
        float v86 = v47 * v73.f32[0];
        float v87 = vmlas_n_f32(vmuls_lane_f32(-v73.f32[1], *(float32x2_t *)v73.f32, 1), v44.f32[0], v44.f32[0]) * 0.54627;
      }
      else
      {
        v78[3] = (float)((float)((float)(v42.__cosval * v42.__cosval) * 3.5171)
                       + (float)((float)((float)(v42.__cosval * v42.__cosval) * (float)(v42.__cosval * v42.__cosval))
                               * -2.9309))
               + -0.58618;
        if (v9 > 4) {
          return;
        }
        sub_1B6499F90((uint64_t)&v79, v73.f32[0], v73.f32[1], v73.f32[2]);
        float32x4_t v43 = v75;
      }
    }
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v52 = 1;
    do
    {
      uint64_t v53 = (2 * (v50 & 0x7FFFFFFF)) | 1;
      float32x4_t v54 = vmulq_n_f32(v43, v78[v50] * *((float *)&v88 + v50));
      uint64_t v55 = v49;
      do
      {
        uint64_t v56 = 4 * v55;
        float v57 = *(float *)((char *)&v79 + v56);
        *(float *)(a6 + v56) = *(float *)(a6 + v56) + (float)(v57 * v54.f32[0]);
        *(float *)(a6 + 4 * v9 * v9 + v56) = *(float *)(a6 + 4 * v9 * v9 + v56) + (float)(v57 * v54.f32[1]);
        uint64_t v51 = a6 + 8 * v9 * v9;
        *(float *)(v51 + v56) = *(float *)(v51 + v56) + (float)(v57 * v54.f32[2]);
        ++v55;
        --v53;
      }
      while (v53);
      ++v50;
      v49 += v52;
      v52 += 2;
    }
    while (v50 != v9);
  }
  else if (v36 == 2 && v9 - 7 >= 0xFFFFFFFB)
  {
    switch(v9)
    {
      case 4u:
        float32x4_t v76 = v35;
        sub_1B6499F90((uint64_t)&v79, *(float *)&v69, *((float *)&v69 + 1), *((float *)&v69 + 2));
        float32x4_t v35 = v76;
        break;
      case 3u:
        int v79 = 1049652923;
        float v58 = *((float *)&v69 + 2) * 0.488602512;
        float v59 = (float)(*((float *)&v69 + 2) * *((float *)&v69 + 2)) * 0.946174696 + -0.315391565;
        float v80 = *((float *)&v69 + 1) * -0.4886;
        float v81 = v58;
        float v60 = *((float *)&v69 + 2) * -1.09254843;
        float v84 = *((float *)&v69 + 1) * v60;
        float v85 = v59;
        float v82 = *(float *)&v69 * -0.4886;
        float v83 = (float)((float)(*(float *)&v69 * *((float *)&v69 + 1)) + (float)(*(float *)&v69 * *((float *)&v69 + 1)))
            * 0.54627;
        float v86 = *(float *)&v69 * v60;
        float v87 = (float)((float)(*(float *)&v69 * *(float *)&v69) - (float)(*((float *)&v69 + 1) * *((float *)&v69 + 1)))
            * 0.54627;
        break;
      case 2u:
        int v79 = 1049652923;
        float v37 = *((float *)&v69 + 2) * 0.488602512;
        float v80 = *((float *)&v69 + 1) * -0.4886;
        float v81 = v37;
        float v82 = *(float *)&v69 * -0.4886;
        break;
    }
    uint64_t v61 = 0;
    float v62 = 0.75;
    if (v9 > 2) {
      float v62 = 1.0625;
    }
    if (v9 > 4) {
      float v62 = v62 + -0.09375;
    }
    float v63 = 3.1416 / v62;
    float v65 = (float)(3.1416 / v62) * v35.f32[0];
    float v66 = vmuls_lane_f32(v63, *(float32x2_t *)v35.f32, 1);
    float v67 = vmuls_lane_f32(v63, v35, 2);
    do
    {
      float v68 = *(float *)((char *)&v79 + v61);
      *(float *)(a6 + v61) = *(float *)(a6 + v61) + (float)(v68 * v65);
      *(float *)(a6 + 4 * v9 * v9 + v61) = *(float *)(a6 + 4 * v9 * v9 + v61) + (float)(v68 * v66);
      uint64_t v64 = a6 + 8 * v9 * v9;
      *(float *)(v64 + v61) = *(float *)(v64 + v61) + (float)(v68 * v67);
      v61 += 4;
    }
    while (4 * v9 * v9 != v61);
  }
}

void sub_1B6498428(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  char v10 = *(unsigned char *)(a1 + 249);
  if (((((v10 & 8) == 0) ^ v8) & 1) == 0)
  {
    char v11 = v8 ? 8 : 0;
    *(unsigned char *)(a1 + 249) = v10 & 0xF7 | v11;
    if (*(unsigned __int8 *)(a1 + 133) >= 2u)
    {
      float32x4_t v12 = (const void *)sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
      sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v12, 0, 1u);
    }
  }
}

uint64_t sub_1B64984F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return (*(unsigned __int8 *)(a1 + 249) >> 3) & 1;
}

uint64_t sub_1B6498540(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"light");
  }
  int v15 = *(_DWORD *)(a1 + 80);
  BOOL v16 = v15 == 2 && *(unsigned __int8 *)(a1 + 133) > 1u;
  if (v15 == 2) {
    return v16 | ((*(unsigned char *)(a1 + 249) & 8) >> 3);
  }
  else {
    return 0;
  }
}

void sub_1B64985D8(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (v8 <= 1) {
    unsigned int v10 = 1;
  }
  else {
    unsigned int v10 = v8;
  }
  if (v10 >= 4) {
    unsigned int v10 = 4;
  }
  if (v10 != a1[8].u8[5])
  {
    a1[8].i8[5] = v10;
    sub_1B6494664(a1, a2, a3, a4, a5, a6, a7, a8, v19);
    uint64_t v18 = (const void *)sub_1B63F4F54(a1, v11, v12, v13, v14, v15, v16, v17);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v18, 0, 1u);
  }
}

void sub_1B6498694(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"light");
  }
  *(float *)(a1 + 120) = a2;
}

float sub_1B64986EC(uint64_t a1)
{
  return *(float *)(a1 + 120);
}

void sub_1B64986F4(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"light");
  }
  *(float *)(a1 + 124) = a2;
}

float sub_1B649874C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 124);
}

void sub_1B6498798(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  BOOL v11 = a1[8].f32[0] != 0.0;
  a1[8].f32[0] = a9;
  if ((a9 != 0.0) != v11)
  {
    sub_1B6494664(a1, a2, a3, a4, a5, a6, a7, a8, v20);
    uint64_t v19 = (const void *)sub_1B63F4F54(a1, v12, v13, v14, v15, v16, v17, v18);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v19, 0, 1u);
  }
}

float sub_1B649885C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(float *)(a1 + 128);
}

void sub_1B64988A8(float32x4_t *a1, unsigned __int32 a2, void *__src, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)__src, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  a1[8].i32[2] = a2;
  memcpy(&a1[9], __src, 16 * a2);

  sub_1B65E4FB4(a1, v12, v13, v14, v15, v16, v17, v18, a9);
}

uint64_t sub_1B6498928(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return a1 + 144;
}

uint64_t sub_1B6498974(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return *(unsigned int *)(a1 + 136);
}

void sub_1B64989C0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a2) {
    char v10 = 16;
  }
  else {
    char v10 = 0;
  }
  *(unsigned char *)(a1 + 249) = *(unsigned char *)(a1 + 249) & 0xEF | v10;
}

uint64_t sub_1B6498A28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  return (*(unsigned __int8 *)(a1 + 249) >> 4) & 1;
}

void sub_1B6498A78(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"light");
  }
  if (a2) {
    char v10 = 32;
  }
  else {
    char v10 = 0;
  }
  *(unsigned char *)(a1 + 249) = *(unsigned char *)(a1 + 249) & 0xDF | v10;
}

uint64_t sub_1B6498AE0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 249) >> 5) & 1;
}

id sub_1B6498AF0(void *a1)
{
  sub_1B6494F88((uint64_t)a1);
  uint64_t v9 = (const void *)a1[34];
  if (v9)
  {
    CFRelease(v9);
    a1[34] = 0;
  }
  char v10 = (const void *)a1[35];
  if (v10)
  {
    CFRelease(v10);
    a1[35] = 0;
  }
  BOOL v11 = (const void *)a1[37];
  if (v11)
  {
    CFRelease(v11);
    a1[37] = 0;
  }

  return sub_1B658325C((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
}

CFStringRef sub_1B6498B5C(unsigned __int8 *a1)
{
  int v2 = a1[248];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t v4 = sub_1B6498BD8((uint64_t)a1);
  if (v2) {
    return CFStringCreateWithFormat(v3, 0, @"<CFXLight %p> Type:%@ CastsShadow(Samples:%d Cascade:%d)", a1, v4, a1[132], a1[133]);
  }
  else {
    return CFStringCreateWithFormat(v3, 0, @"<CFXLight %p> Type:%@", a1, v4);
  }
}

__CFString *sub_1B6498BD8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  __n128 result = @"Ambient";
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      __n128 result = @"Omni";
      break;
    case 2:
      __n128 result = @"Directional";
      break;
    case 3:
      __n128 result = @"Spot";
      break;
    case 4:
      int v4 = *(unsigned __int8 *)(a1 + 396);
      uint64_t v5 = @"IES";
      if (v4 == 1) {
        uint64_t v5 = @"Radiance";
      }
      if (v4) {
        __n128 result = v5;
      }
      else {
        __n128 result = @"Irradiance";
      }
      break;
    case 5:
      unint64_t v6 = *(char *)(a1 + 320);
      if (v6 >= 5) {
        goto LABEL_12;
      }
      __n128 result = off_1E6142A80[v6];
      break;
    case 6:
      __n128 result = @"IES";
      break;
    default:
LABEL_12:
      __n128 result = @"Unknown";
      break;
  }
  return result;
}

__CFArray *sub_1B6498CB4(uint64_t a1)
{
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFAllocatorRef v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 12;
  uint64_t v87 = a1 + 64;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v4, @"name", @"Color");
  CFDictionarySetValue(v4, @"type", v5);
  CFDictionarySetValue(v4, @"address", v7);
  CFDictionarySetValue(v4, @"semantic", v6);
  CFArrayAppendValue(Mutable, v4);
  CFRelease(v6);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v5);
  uint64_t v8 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 88;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v8, @"name", @"intensity");
  CFDictionarySetValue(v8, @"type", v9);
  CFDictionarySetValue(v8, @"address", v11);
  CFDictionarySetValue(v8, @"semantic", v10);
  CFArrayAppendValue(Mutable, v8);
  CFRelease(v10);
  CFRelease(v8);
  CFRelease(v11);
  CFRelease(v9);
  uint64_t v12 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 2;
  uint64_t v87 = a1 + 80;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v13, @"name", @"type");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v18 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v12);
  int v88 = 0;
  int valuePtr = 3;
  uint64_t v87 = a1 + 248;
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v18, @"name", @"castShadow");
  CFDictionarySetValue(v18, @"type", v19);
  CFDictionarySetValue(v18, @"address", v21);
  CFDictionarySetValue(v18, @"semantic", v20);
  CFArrayAppendValue(Mutable, v18);
  CFRelease(v20);
  CFRelease(v18);
  CFRelease(v21);
  CFRelease(v19);
  uint64_t v22 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v23 = CFDictionaryCreateMutable(0, 4, v17, MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 96;
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v23, @"name", @"shadowIntensity");
  CFDictionarySetValue(v23, @"type", v24);
  CFDictionarySetValue(v23, @"address", v26);
  CFDictionarySetValue(v23, @"semantic", v25);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v25);
  CFRelease(v23);
  CFRelease(v26);
  CFRelease(v24);
  uint64_t v27 = CFDictionaryCreateMutable(0, 4, v17, v22);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 252;
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v27, @"name", @"zNear");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  uint64_t v31 = CFDictionaryCreateMutable(0, 4, v17, v22);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 256;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v31, @"name", @"zFar");
  CFDictionarySetValue(v31, @"type", v32);
  CFDictionarySetValue(v31, @"address", v34);
  CFDictionarySetValue(v31, @"semantic", v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  float32x4_t v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v22);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 116;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v35, @"name", @"shadowSoftenFactor");
  CFDictionarySetValue(v35, @"type", v36);
  CFDictionarySetValue(v35, @"address", v38);
  CFDictionarySetValue(v35, @"semantic", v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  float32x4_t v39 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  float32x4_t v40 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v22);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 84;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v40, @"name", @"attenuationDistance");
  CFDictionarySetValue(v40, @"type", v41);
  CFDictionarySetValue(v40, @"address", v43);
  CFDictionarySetValue(v40, @"semantic", v42);
  CFArrayAppendValue(Mutable, v40);
  CFRelease(v42);
  CFRelease(v40);
  CFRelease(v43);
  CFRelease(v41);
  float32x2_t v44 = CFDictionaryCreateMutable(0, 4, v39, v22);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 308;
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v44, @"name", @"spotInnerAngle");
  CFDictionarySetValue(v44, @"type", v45);
  CFDictionarySetValue(v44, @"address", v47);
  CFDictionarySetValue(v44, @"semantic", v46);
  CFArrayAppendValue(Mutable, v44);
  CFRelease(v46);
  CFRelease(v44);
  CFRelease(v47);
  CFRelease(v45);
  float v48 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 304;
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v48, @"name", @"spotOuterAngle");
  CFDictionarySetValue(v48, @"type", v49);
  CFDictionarySetValue(v48, @"address", v51);
  CFDictionarySetValue(v48, @"semantic", v50);
  uint64_t v52 = Mutable;
  CFArrayAppendValue(Mutable, v48);
  CFRelease(v50);
  CFRelease(v48);
  CFRelease(v51);
  CFRelease(v49);
  uint64_t v53 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  float32x4_t v54 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = a1 + 312;
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v56 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v57 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v54, @"name", @"spotFalloffExponent");
  CFDictionarySetValue(v54, @"type", v55);
  CFDictionarySetValue(v54, @"address", v57);
  CFDictionarySetValue(v54, @"semantic", v56);
  CFArrayAppendValue(v52, v54);
  CFRelease(v56);
  CFRelease(v54);
  CFRelease(v57);
  CFRelease(v55);
  float v58 = CFDictionaryCreateMutable(0, 4, v53, MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 6;
  uint64_t v87 = a1 + 264;
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v61 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v58, @"name", @"shadowBias");
  CFDictionarySetValue(v58, @"type", v59);
  CFDictionarySetValue(v58, @"address", v61);
  CFDictionarySetValue(v58, @"semantic", v60);
  CFArrayAppendValue(v52, v58);
  CFRelease(v60);
  CFRelease(v58);
  CFRelease(v61);
  CFRelease(v59);
  float v62 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  float v63 = CFDictionaryCreateMutable(0, 4, v53, MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 7;
  uint64_t v64 = a1;
  uint64_t v87 = a1 + 104;
  CFNumberRef v65 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v63, @"name", @"shadowMapSize");
  CFDictionarySetValue(v63, @"type", v65);
  CFDictionarySetValue(v63, @"address", v67);
  CFDictionarySetValue(v63, @"semantic", v66);
  float v68 = v52;
  CFArrayAppendValue(v52, v63);
  CFRelease(v66);
  CFRelease(v63);
  CFRelease(v67);
  CFRelease(v65);
  long long v69 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v70 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = v64 + 112;
  CFNumberRef v71 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v72 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v73 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v70, @"name", @"directionalExtent");
  CFDictionarySetValue(v70, @"type", v71);
  CFDictionarySetValue(v70, @"address", v73);
  CFDictionarySetValue(v70, @"semantic", v72);
  CFArrayAppendValue(v68, v70);
  CFRelease(v72);
  CFRelease(v70);
  CFRelease(v73);
  CFRelease(v71);
  __n128 v74 = CFDictionaryCreateMutable(0, 4, v69, MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 1;
  uint64_t v87 = v64 + 132;
  CFNumberRef v75 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v76 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v77 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v74, @"name", @"shadowMaxSampleCount");
  CFDictionarySetValue(v74, @"type", v75);
  CFDictionarySetValue(v74, @"address", v77);
  CFDictionarySetValue(v74, @"semantic", v76);
  CFArrayAppendValue(v68, v74);
  CFRelease(v76);
  CFRelease(v74);
  CFRelease(v77);
  CFRelease(v75);
  uint64_t v78 = CFDictionaryCreateMutable(0, 4, v69, MEMORY[0x1E4F1D540]);
  int v88 = 0;
  int valuePtr = 2;
  uint64_t v87 = v64 + 240;
  CFNumberRef v79 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v80 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v81 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v78, @"name", @"categoryBitMask");
  CFDictionarySetValue(v78, @"type", v79);
  CFDictionarySetValue(v78, @"address", v81);
  CFDictionarySetValue(v78, @"semantic", v80);
  CFArrayAppendValue(v68, v78);
  CFRelease(v80);
  CFRelease(v78);
  CFRelease(v81);
  CFRelease(v79);
  float v82 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v88 = 2;
  int valuePtr = 5;
  uint64_t v87 = v64 + 272;
  CFNumberRef v83 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v84 = CFNumberCreate(0, kCFNumberSInt32Type, &v88);
  CFNumberRef v85 = CFNumberCreate(0, kCFNumberLongType, &v87);
  CFDictionarySetValue(v82, @"name", @"gobo");
  CFDictionarySetValue(v82, @"type", v83);
  CFDictionarySetValue(v82, @"address", v85);
  CFDictionarySetValue(v82, @"semantic", v84);
  CFArrayAppendValue(v68, v82);
  CFRelease(v84);
  CFRelease(v82);
  CFRelease(v85);
  CFRelease(v83);
  return v68;
}

void sub_1B6499D74(float32x4_t *a1, float32x4_t *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (&a1[15].u32[2] == (unsigned __int32 *)__dst)
  {
    uint64_t v21 = *(unsigned __int8 *)__src;
    sub_1B6495C94(a1, v21, (uint64_t)__src, __n, a5, a6, a7, a8, a9);
  }
  else if (&a1[5].i32[1] == (__int32 *)__dst)
  {
    float32_t v22 = *__src;
    sub_1B64973E4(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, v22, a9);
  }
  else if (&a1[4] > __dst || (float32x4_t *)((char *)&a1[4].u64[1] + 4) < __dst)
  {
    if (&a1[21] > __dst || &a1[24] < __dst)
    {
      memcpy(__dst, __src, __n);
    }
    else
    {
      if (a1[5].i32[0] != 5 && (byte_1E9DDAF40 & 1) == 0)
      {
        byte_1E9DDAF40 = 1;
        sub_1B63F2F54(16, @"Error: animating areaExtents on a non area light", (uint64_t)__src, __n, a5, a6, a7, a8, v37);
      }
      memcpy(__dst, __src, __n);
      sub_1B64968E0((uint64_t)a1, v23, v24, v25, v26, v27, v28, v29);
      sub_1B6496EB0(a1, v30, v31, v32, v33, v34, v35, v36);
    }
  }
  else
  {
    BOOL v13 = sub_1B63C8E84(a1[4].f32);
    memcpy(__dst, __src, __n);
    if (v13 == sub_1B63C8E84(a1[4].f32))
    {
      sub_1B65E4FB4(a1, v14, v15, v16, v17, v18, v19, v20, a9);
    }
    else
    {
      sub_1B6494664(a1, v14, v15, v16, v17, v18, v19, v20, a9);
    }
  }
}

uint64_t sub_1B6499F58(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

float sub_1B6499F90(uint64_t a1, float a2, float a3, float a4)
{
  float v4 = a4 * a4;
  *(_DWORD *)a1 = 1049652923;
  double v5 = a4;
  float v6 = v5 * 0.488602512;
  double v7 = v4;
  float v8 = v7 * 0.946174696 + -0.315391565;
  float v9 = (v7 * 1.86588166 + -1.119529) * v5;
  *(float *)(a1 + 4) = a3 * -0.4886;
  *(float *)(a1 + 8) = v6;
  float v10 = v5 * -1.09254843;
  *(float *)(a1 + 20) = v10 * a3;
  *(float *)(a1 + 24) = v8;
  *(float *)&double v7 = v7 * -2.285229 + 0.457045799;
  *(float *)(a1 + 44) = *(float *)&v7 * a3;
  *(float *)(a1 + 48) = v9;
  float v11 = (float)(a2 * a3) + (float)(a2 * a3);
  *(float *)(a1 + 12) = a2 * -0.4886;
  *(float *)(a1 + 16) = v11 * 0.54627;
  float v12 = (float)(a2 * a2) - (float)(a3 * a3);
  *(float *)(a1 + 28) = v10 * a2;
  *(float *)(a1 + 32) = v12 * 0.54627;
  *(float *)&double v5 = v5 * 1.44530572;
  *(float *)(a1 + 52) = *(float *)&v7 * a2;
  *(float *)(a1 + 56) = v12 * *(float *)&v5;
  *(float *)(a1 + 36) = (float)((float)(v12 * a3) + (float)(a2 * v11)) * -0.59004;
  *(float *)(a1 + 40) = v11 * *(float *)&v5;
  float result = (float)((float)(a2 * v12) - (float)(v11 * a3)) * -0.59004;
  *(float *)(a1 + 60) = result;
  return result;
}

void sub_1B649A0B0(void *a1)
{
  values = a1;
  CFDictionaryRef v1 = CFDictionaryCreate(0, (const void **)off_1E61417E8, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  float v9 = (const void *)sub_1B63F4F54(values, v2, v3, v4, v5, v6, v7, v8);
  sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v9, v1, 1u);
  CFRelease(v1);
}

uint64_t sub_1B649A134()
{
  if (qword_1EB9953A0 != -1) {
    dispatch_once(&qword_1EB9953A0, &unk_1F0FB58E8);
  }
  return qword_1EB9953A8;
}

double sub_1B649A178()
{
  if (!qword_1EB9953A8)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB9953A8);
    qword_1EB9953A8 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"sensorHeight", 0xF8u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"filmOffset", 0x50u, 7, 0, 0, 0, v4, v5);
    sub_1B660E400(@"postProjectionTransformTranslation", 0x58u, 7, 0, 0, 0, v6, v7);
    sub_1B660E400(@"postProjectionTransformScale", 0x60u, 7, 0, 0, 0, v8, v9);
    sub_1B660E400(@"focusDistance", 0xF0u, 1, 0, 0, 0, v10, v11);
    sub_1B660E400(@"focalLength", 0xF4u, 1, 0, 0, 0, v12, v13);
    sub_1B660E400(@"fieldOfView", 0x6Cu, 1, 0, 0, 0, v14, v15);
    sub_1B660E400(@"orthographicScale", 0x68u, 1, 0, 0, 0, v16, v17);
    sub_1B660E400(@"projectionTransform", 0x70u, 10, 0, 0, 0, v18, v19);
    sub_1B660E400(@"zFar", 0x48u, 1, 0, 0, 0, v20, v21);
    sub_1B660E400(@"zNear", 0x44u, 1, 0, 0, 0, v22, v23);
    sub_1B660E400(@"depthOfField", 0x100u, 5, 1, 0, 0, v24, v25);
    sub_1B660E400(@"motionBlur", 0x108u, 5, 1, 0, 0, v26, v27);
    sub_1B660E400(@"grain", 0x110u, 5, 1, 0, 0, v28, v29);
    sub_1B660E400(@"exposure", 0x118u, 5, 1, 0, 0, v30, v31);
    sub_1B660E400(@"toneMapping", 0x120u, 5, 1, 0, 0, v32, v33);
    sub_1B660E400(@"bloom", 0x128u, 5, 1, 0, 0, v34, v35);
    sub_1B660E400(@"vignetting", 0x130u, 5, 1, 0, 0, v36, v37);
    sub_1B660E400(@"lensBlur", 0x138u, 5, 1, 0, 0, v38, v39);
    sub_1B660E400(@"colorFringe", 0x140u, 5, 1, 0, 0, v40, v41);
    sub_1B660E400(@"colorGrading", 0x148u, 5, 1, 0, 0, v42, v43);
    sub_1B660E400(@"chromaticTransform", 0x150u, 5, 1, 0, 0, v44, v45);
    sub_1B660E400(@"doughnutBokeh", 0x158u, 5, 1, 0, 0, v46, v47);
    sub_1B660E400(@"ssao", 0x160u, 5, 1, 0, 0, v48, v49);
    sub_1B660E3EC();
    xmmword_1EB9839D0 = xmmword_1F0FB8710;
    qword_1EB9839E0 = (uint64_t)sub_1B649D7C0;
    double result = *(double *)&xmmword_1F0FB8720;
    unk_1EB9839F8 = xmmword_1F0FB8720;
    unk_1EB983A08 = *(_OWORD *)algn_1F0FB8730;
    qword_1EB983A18 = qword_1F0FB8740;
    unk_1EB983A20 = sub_1B649EE98;
  }
  return result;
}

double sub_1B649A528()
{
  if (qword_1EB9953A0 != -1) {
    dispatch_once(&qword_1EB9953A0, &unk_1F0FB58E8);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB9953A8, 0x1B0uLL);
  *(void *)(v0 + 68) = 0x42C800003DCCCCCDLL;
  *(void *)(v0 + 88) = 0;
  __asm { FMOV            V1.2S, #1.0 }
  *(void *)(v0 + 96) = _D1;
  *(void *)(v0 + 104) = 0x427000003F800000;
  *(_DWORD *)(v0 + 248) = 1103101952;
  *(void *)(v0 + 240) = 0x4248000040200000;
  *(void *)(v0 + 432) = -1;
  char v6 = *(unsigned char *)(v0 + 360);
  *(_OWORD *)(v0 + 368) = xmmword_1B6E4F300;
  *(_OWORD *)(v0 + 384) = xmmword_1B6E4F320;
  double result = 0.0;
  *(_OWORD *)(v0 + 400) = xmmword_1B6E4F2E0;
  *(_OWORD *)(v0 + 416) = xmmword_1B6E4F370;
  *(unsigned char *)(v0 + 360) = v6 & 0xFC;
  return result;
}

void sub_1B649A5E4(unsigned char *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = a1[360];
  if (((((v10 & 2) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      char v11 = 2;
    }
    else {
      char v11 = 0;
    }
    a1[360] = v10 & 0xFD | v11;
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649A680(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 256);
}

void sub_1B649A6CC(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[32];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[32];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[32] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[32] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649A798(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 264);
}

void sub_1B649A7E4(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[33];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[33];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[33] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[33] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649A8B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 272);
}

void sub_1B649A8FC(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[34];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[34];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[34] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[34] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649A9C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 280);
}

void sub_1B649AA14(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[35];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[35];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[35] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[35] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649AAE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 288);
}

void sub_1B649AB2C(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[36];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[36];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[36] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[36] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649ABF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 296);
}

void sub_1B649AC44(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[37];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[37];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[37] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[37] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649AD10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 304);
}

void sub_1B649AD5C(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[38];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[38];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[38] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[38] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649AE28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 312);
}

void sub_1B649AE74(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[39];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[39];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[39] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[39] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649AF40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 328);
}

void sub_1B649AF8C(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[41];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[41];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[41] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[41] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649B058(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 320);
}

void sub_1B649B0A4(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[40];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[40];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[40] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[40] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649B170(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 336);
}

void sub_1B649B1BC(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[42];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[42];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[42] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[42] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649B288(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 344);
}

void sub_1B649B2D4(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[43];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[43];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[43] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[43] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649B3A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 352);
}

void sub_1B649B3EC(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  char v10 = (void *)a1[44];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B63F4AAC(v10, a1[6], a3, a4, a5, a6, a7, a8);
      char v11 = (const void *)a1[44];
      if (v11 != a2)
      {
        if (v11)
        {
          CFRelease(v11);
          a1[44] = 0;
        }
        if (!a2) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
LABEL_12:
      a2 = (void *)CFRetain(a2);
LABEL_13:
      a1[44] = (uint64_t)a2;
    }
    if (a2) {
      sub_1B63F4CCC((uint64_t *)a2, a1[6], a3, a4, a5, a6, a7, a8);
    }
    sub_1B649A0B0(a1);
  }
}

uint64_t sub_1B649B4B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t result = *(void *)(a1 + 256);
  if (result)
  {
    return sub_1B6529108(result);
  }
  return result;
}

uint64_t sub_1B649B548(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 264);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649B5D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 280);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) != 0.0;
  }
  return result;
}

uint64_t sub_1B649B668(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 296);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649B6F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 304);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649B788(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 312);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649B818(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 320);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529878(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649B8A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 272);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649B938(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t result = *(void *)(a1 + 288);
  if (result)
  {
    return sub_1B6529108(result);
  }
  return result;
}

uint64_t sub_1B649B9C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t result = *(void *)(a1 + 328);
  if (result)
  {
    return sub_1B6529108(result);
  }
  return result;
}

uint64_t sub_1B649BA58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 344);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649BAE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 352);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B6529330(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

uint64_t sub_1B649BB78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 336);
  if (!v15) {
    return 0;
  }
  uint64_t result = sub_1B6529108(v15);
  if (result) {
    return sub_1B65299B8(v15, v17, v18, v19, v20, v21, v22, v23) > 0.0;
  }
  return result;
}

BOOL sub_1B649BC08(void *a1, uint64_t a2)
{
  return a1[37] == a2
      || a1[32] == a2
      || a1[33] == a2
      || a1[34] == a2
      || a1[35] == a2
      || a1[36] == a2
      || a1[38] == a2
      || a1[39] == a2
      || a1[40] == a2
      || a1[41] == a2
      || a1[42] == a2
      || a1[43] != 0;
}

void sub_1B649BCA4(__n128 *a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (!a1)
  {
    __n128 v16 = a5;
    __n128 v14 = a3;
    __n128 v15 = a4;
    __n128 v13 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a7, a8, a9, a10, a11, a12, (uint64_t)"camera");
    a2 = v13;
    a3 = v14;
    a4 = v15;
    a5 = v16;
  }
  a1[11] = a2;
  a1[12] = a3;
  a1[13] = a4;
  a1[14] = a5;
  a1[4].n128_u8[0] |= 4u;
}

uint64_t sub_1B649BD18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return (*(unsigned __int8 *)(a1 + 64) >> 1) & 1;
}

void sub_1B649BD68(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  if (a2) {
    char v10 = 2;
  }
  else {
    char v10 = 0;
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xFD | v10;
}

uint64_t sub_1B649BDD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 432);
}

void sub_1B649BE1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  *(void *)(a1 + 432) = a2;
}

float sub_1B649BE6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(float *)(a1 + 104);
}

uint64_t sub_1B649BEB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(unsigned char *)(a1 + 64) & 1;
}

uint64_t sub_1B649BF08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t result = *(void *)(a1 + 280);
  if (result)
  {
    return sub_1B6529FDC(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B649BF98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return (*(unsigned __int8 *)(a1 + 360) >> 1) & 1;
}

float sub_1B649BFE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(float *)(a1 + 72);
}

float sub_1B649C034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(float *)(a1 + 68);
}

float sub_1B649C080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(float *)(a1 + 244);
}

float sub_1B649C0CC(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  a1[61] = a2;
  long double v11 = atan(a1[62] * 0.5 / a2);
  *(float *)&long double v11 = v11 + v11;
  float result = *(float *)&v11 / 3.14159265 * 180.0;
  a1[27] = result;
  return result;
}

float sub_1B649C16C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(float *)(a1 + 108);
}

float sub_1B649C1B8(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  a1[27] = a2;
  float v11 = a2 / 180.0 * 3.14159265;
  double v12 = a1[62] * 0.5;
  float result = v12 / tanf(v11 * 0.5);
  a1[61] = result;
  return result;
}

uint64_t sub_1B649C25C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return (*(unsigned __int8 *)(a1 + 64) >> 3) & 7;
}

void sub_1B649C2AC(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xC7 | (8 * (a2 & 7));
}

float sub_1B649C30C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(float *)(a1 + 240);
}

void sub_1B649C358(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  *(float *)(a1 + 240) = a2;
}

double sub_1B649C3B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(double *)(a1 + 80);
}

void sub_1B649C3FC(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  *(double *)(a1 + 80) = a2;
}

double sub_1B649C454(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(double *)(a1 + 88);
}

void sub_1B649C4A0(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  *(double *)(a1 + 88) = a2;
}

double sub_1B649C4F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(double *)(a1 + 96);
}

void sub_1B649C544(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  *(double *)(a1 + 96) = a2;
}

float sub_1B649C59C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"camera");
  }
  uint64_t v15 = *(void *)(a1 + 256);
  if (v15) {
    double v16 = sub_1B6529330(v15, a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    double v16 = 5.5999999;
  }
  return *(float *)(a1 + 244) / fmax(v16, 0.00001);
}

float sub_1B649C638(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(float *)(a1 + 248);
}

float sub_1B649C684(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  float v11 = 0.0001;
  if (a2 >= 0.0001) {
    float v11 = a2;
  }
  a1[62] = v11;
  float v12 = a1[27] / 180.0 * 3.14159265;
  float result = v11 * 0.5 / tanf(v12 * 0.5);
  a1[61] = result;
  return result;
}

void sub_1B649C738(uint64_t a1, float *a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  unsigned int v13 = *(unsigned __int8 *)(a1 + 64);
  if ((v13 & 0x38) != 0x20)
  {
    int v15 = (v13 >> 3) & 7;
    if (v15)
    {
      if (v15 == 3) {
        goto LABEL_14;
      }
      if (v15 == 1 && a9 >= 1.0) {
        goto LABEL_14;
      }
    }
    else if (a9 < 1.0)
    {
LABEL_14:
      float v18 = *(float *)(a1 + 108);
      *a2 = v18;
      float v14 = v18 / a9;
      goto LABEL_15;
    }
    float v17 = *(float *)(a1 + 108);
    *a3 = v17;
    *a2 = v17 * a9;
    return;
  }
  *a2 = *(float *)(a1 + 108);
  float v14 = *(float *)(a1 + 108);
LABEL_15:
  *a3 = v14;
}

uint64_t sub_1B649C80C(unsigned __int8 *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"infos");
  }
  int v11 = (*a1 >> 3) & 7;
  if (v11 == 3) {
    return 1;
  }
  BOOL v12 = a2 < 1.0;
  if (v11) {
    BOOL v12 = 0;
  }
  if (v11 == 1) {
    return a2 >= 1.0;
  }
  else {
    return v12;
  }
}

void sub_1B649C898(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  *(float *)(a1 + 104) = a2;
  *(unsigned char *)(a1 + 64) &= ~4u;
}

void sub_1B649C8FC(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xFA | a2;
}

void sub_1B649C95C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  *(float *)(a1 + 72) = a2;
  *(unsigned char *)(a1 + 64) &= ~4u;
}

void sub_1B649C9C0(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"infos");
  }
  *(float *)(a1 + 8) = a2;
  *(unsigned char *)a1 &= ~4u;
}

void sub_1B649CA24(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"camera");
  }
  if (a2 == 0.0 && (*(unsigned char *)(a1 + 64) & 1) == 0) {
    sub_1B63F2F54(0, @"Info: invalid zNear value (0) set to camera", a4, a5, a6, a7, a8, a9, v11);
  }
  *(float *)(a1 + 68) = a2;
  *(unsigned char *)(a1 + 64) &= ~4u;
}

void sub_1B649CAA8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"infos");
  }
  *(float *)(a1 + 4) = a2;
  *(unsigned char *)a1 &= ~4u;
}

double sub_1B649CB0C()
{
  return 0.0;
}

uint64_t sub_1B649CB18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return *(void *)(a1 + 440);
}

float sub_1B649CB64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"infos");
  }
  return *(float *)(a1 + 44);
}

double sub_1B649CBB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"infos");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"infos");
  }
  return *(float *)(a1 + 44);
}

float sub_1B649CC1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"infos");
  }
  return *(float *)(a1 + 4);
}

float sub_1B649CC68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"infos");
  }
  return *(float *)(a1 + 8);
}

float sub_1B649CCB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"infos");
  }
  return *(float *)(a1 + 40);
}

uint64_t sub_1B649CD00(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"infos");
  }
  return *a1 & 1;
}

unsigned __int8 *sub_1B649CD50(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"infos");
  }
  unsigned int v10 = *a1;
  if ((v10 & 4) != 0) {
    return a1 + 112;
  }
  if (v10)
  {
    double v38 = *((float *)a1 + 10);
    if (!a2) {
      goto LABEL_15;
    }
    LODWORD(v39) = HIDWORD(*(_OWORD *)a2);
    float v40 = 1.0;
    if (v39 != 0.0) {
      float v40 = COERCE_FLOAT(*(void *)(a2 + 8)) / v39;
    }
    if ((v10 & 0x38) != 0x20)
    {
      int v66 = sub_1B649C80C(a1, v40, a2, a3, a4, a5, a6, a7, a8);
      double v67 = v40;
      if (v66)
      {
        double v41 = v38 / v67;
      }
      else
      {
        double v41 = v38;
        double v38 = v38 * v67;
      }
    }
    else
    {
LABEL_15:
      double v41 = *((float *)a1 + 10);
    }
    float v42 = *((float *)a1 + 1);
    float v43 = *((float *)a1 + 2);
    double v44 = v42;
    double v45 = v42 + 1.0;
    if (v43 > v42) {
      double v45 = v43;
    }
    *(float *)&unsigned int v46 = 2.0 / (v38 + v38);
    v29.f64[0] = 0.0;
    long long v33 = v46;
    float v47 = 2.0 / (v41 + v41);
    LODWORD(v34) = 0;
    *((void *)&v34 + 1) = 0;
    *((float *)&v34 + 1) = v47;
    double v48 = v44 - v45;
    *(float *)&unsigned int v49 = 1.0 / v48;
    *(void *)&v29.f64[1] = v49;
    *(float *)&unsigned int v50 = -(v38 - v38) / (v38 + v38);
    *(float *)&unsigned int v51 = -(v41 - v41) / (v41 + v41);
    __asm { FMOV            V3.4S, #1.0 }
    *(void *)&_Q3 = __PAIR64__(v51, v50);
    float v52 = v44 / v48;
    *((float *)&_Q3 + 2) = v52;
    *((_OWORD *)a1 + 3) = v46;
    *((_OWORD *)a1 + 4) = (unint64_t)v34;
    *((float64x2_t *)a1 + 5) = v29;
    goto LABEL_41;
  }
  double v11 = *((float *)a1 + 11);
  if (a2
    && (float32x2_t v12 = *(float32x2_t *)(a1 + 16),
        uint32x2_t v13 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v12)),
        (vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0))
  {
    float v14 = v11 / 180.0 * 3.14159265 * 0.5;
    float v15 = *((float *)a1 + 1);
    float v16 = v15 * tanf(v14);
    float32x2_t v17 = vdiv_f32(vadd_f32(v12, v12), *(float32x2_t *)(a2 + 8));
    double v18 = v15;
    float v19 = *((float *)a1 + 2);
    __asm { FMOV            V7.2S, #1.0 }
    float64x2_t v29 = vcvtq_f64_f32(vmul_n_f32(vadd_f32(v17, _D7), -v16));
    float64x2_t v25 = vcvtq_f64_f32(vmul_n_f32(vsub_f32(_D7, v17), v16));
    float64x2_t v26 = vsubq_f64(v25, v29);
    float v27 = (v18 + v18) / v26.f64[0];
    float v28 = (v18 + v18) / v26.f64[1];
    *(float32x2_t *)&v29.f64[0] = vcvt_f32_f64(vdivq_f64(vaddq_f64(v25, v29), v26));
    double v30 = v15 + 1.0;
    if (v19 > v15) {
      double v30 = v19;
    }
    double v31 = v30 / (v18 - v30);
    float v32 = v31;
    LODWORD(v34) = 0;
    *((void *)&v34 + 1) = 0;
    long long v33 = LODWORD(v27);
    *((float *)&v34 + 1) = v28;
    double v35 = v31 * v18;
    float v36 = -1.0;
    *(float *)&v29.f64[1] = v32;
  }
  else
  {
    float v54 = *((float *)a1 + 1);
    float v55 = *((float *)a1 + 2);
    double v56 = v54;
    double v57 = __tanpi(v11 / 360.0);
    if (v57 == 0.0) {
      double v58 = 1.0;
    }
    else {
      double v58 = 1.0 / v57;
    }
    float v59 = v58;
    double v60 = v56 + 1.0;
    if (v55 > v54) {
      double v60 = v55;
    }
    double v61 = v60 / (v56 - v60);
    float v62 = v61;
    long long v33 = LODWORD(v59);
    LODWORD(v34) = 0;
    *((void *)&v34 + 1) = 0;
    *((float *)&v34 + 1) = v59;
    v29.f64[0] = 0.0;
    double v35 = v61 * v56;
    *(float *)&v29.f64[1] = v62;
    float v36 = -1.0;
  }
  *((float *)&v29.f64[1] + 1) = v36;
  *(float *)&unsigned int v63 = v35;
  *(void *)&_Q3 = 0;
  *((void *)&_Q3 + 1) = v63;
  *((_OWORD *)a1 + 3) = v33;
  *((_OWORD *)a1 + 4) = v34;
  *((float64x2_t *)a1 + 5) = v29;
  *((_OWORD *)a1 + 6) = _Q3;
  if ((v10 & 0x38) != 0x20)
  {
    if (a2)
    {
      LODWORD(v64) = HIDWORD(*(_OWORD *)a2);
      float v65 = COERCE_FLOAT(*(void *)(a2 + 8)) / v64;
      if (v64 == 0.0) {
        float v65 = 1.0;
      }
    }
    else
    {
      float v65 = 1.0;
    }
    int v68 = (v10 >> 3) & 7;
    if (v68)
    {
      if (v68 == 3 || v68 == 1 && v65 >= 1.0) {
        goto LABEL_37;
      }
    }
    else if (v65 < 1.0)
    {
LABEL_37:
      *((float *)a1 + 17) = v65 * *((float *)&v34 + 1);
      long long v34 = *((_OWORD *)a1 + 4);
      goto LABEL_41;
    }
    *((float *)a1 + 12) = *(float *)&v33 / v65;
    long long v33 = *((_OWORD *)a1 + 3);
  }
LABEL_41:
  uint64_t v69 = 0;
  float result = a1 + 48;
  long long v84 = v33;
  long long v85 = v34;
  float64x2_t v86 = v29;
  long long v87 = _Q3;
  long long v88 = 0u;
  long long v89 = 0u;
  float64x2_t v90 = 0u;
  long long v91 = 0u;
  do
  {
    *(long long *)((char *)&v88 + v69) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v84 + v69))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v84 + v69), 1), (float32x4_t)xmmword_1B6E4F340, *(float32x4_t *)((char *)&v84 + v69), 2), (float32x4_t)xmmword_1B6E4F360, *(float32x4_t *)((char *)&v84 + v69), 3);
    v69 += 16;
  }
  while (v69 != 64);
  long long v70 = v88;
  long long v71 = v89;
  float64x2_t v72 = v90;
  long long v73 = v91;
  *((_OWORD *)a1 + 3) = v88;
  *((_OWORD *)a1 + 4) = v71;
  *((float64x2_t *)a1 + 5) = v72;
  *((_OWORD *)a1 + 6) = v73;
  v74.i64[0] = *((void *)a1 + 3);
  float32x2_t v75 = *(float32x2_t *)(a1 + 32);
  uint32x2_t v76 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)v74.f32));
  if ((vpmax_u32(v76, v76).u32[0] & 0x80000000) != 0) {
    goto LABEL_45;
  }
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v78 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v75, _D1));
  if ((vpmax_u32(v78, v78).u32[0] & 0x80000000) != 0)
  {
LABEL_45:
    uint64_t v79 = 0;
    v80.i32[0] = 0;
    v80.i32[3] = 0;
    *(uint64_t *)((char *)v80.i64 + 4) = HIDWORD(*((void *)a1 + 4));
    v74.i32[2] = 0;
    v74.i32[3] = 1.0;
    long long v84 = v70;
    long long v85 = v71;
    float64x2_t v86 = v72;
    long long v87 = v73;
    long long v88 = 0u;
    long long v89 = 0u;
    float64x2_t v90 = 0u;
    long long v91 = 0u;
    do
    {
      *(long long *)((char *)&v88 + v79) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v75.u32[0], COERCE_FLOAT(*(long long *)((char *)&v84 + v79))), v80, *(float32x2_t *)((char *)&v84 + v79), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v84 + v79), 2), v74, *(float32x4_t *)((char *)&v84 + v79), 3);
      v79 += 16;
    }
    while (v79 != 64);
    long long v81 = v89;
    float64x2_t v82 = v90;
    long long v83 = v91;
    *((_OWORD *)a1 + 3) = v88;
    *((_OWORD *)a1 + 4) = v81;
    *((float64x2_t *)a1 + 5) = v82;
    *((_OWORD *)a1 + 6) = v83;
  }
  return result;
}

uint64_t sub_1B649D1E0(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  uint64_t v9 = (_OWORD *)a4;
  unsigned int v10 = a3;
  __n128 v49 = a9;
  unsigned int v13 = *(unsigned __int8 *)a1;
  if ((v13 & 5) == 0)
  {
    float v28 = a1[11] / 180.0 * 3.14159265;
    float32x4_t v48 = (float32x4_t)a9;
    float v29 = tanf(v28 * 0.5);
    float32x4_t v31 = vdivq_f32(v48, (float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3));
    int v32 = (v13 >> 3) & 7;
    if (v32)
    {
      if (v32 != 3 && (v32 != 1 || v31.f32[2] < 1.0))
      {
LABEL_12:
        v31.f32[0] = v31.f32[2] * v29;
        if (!v10) {
          return 1;
        }
        goto LABEL_17;
      }
    }
    else if (v31.f32[2] >= 1.0)
    {
      goto LABEL_12;
    }
    v31.f32[0] = v29;
    float v29 = v29 / v31.f32[2];
    if (!v10) {
      return 1;
    }
LABEL_17:
    v31.f32[1] = v29;
    float v35 = a1[1];
    float v34 = a1[2];
    float v36 = v35 * v34;
    float v37 = v35 - v34;
    uint64_t v38 = v10;
    float32x2_t v39 = (float32x2_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL).u64[0];
    float v40 = (float *)(a2 + 8);
    __asm { FMOV            V5.2S, #-1.0 }
    do
    {
      float v46 = v36 / (float)(v34 + (float)(*v40 * v37));
      *(float32x2_t *)&long long v30 = vsub_f32(*(float32x2_t *)(v40 - 2), *(float32x2_t *)v48.f32);
      *(float32x2_t *)&long long v30 = vmul_n_f32(vmul_f32(*(float32x2_t *)v31.f32, vadd_f32(vdiv_f32(vadd_f32(*(float32x2_t *)&v30, *(float32x2_t *)&v30), v39), _D5)), v46);
      *((float *)&v30 + 2) = -v46;
      *v9++ = v30;
      v40 += 4;
      --v38;
    }
    while (v38);
    return 1;
  }
  simd_float4x4 v50 = *(simd_float4x4 *)sub_1B649CD50((unsigned __int8 *)a1, (uint64_t)&v49, a3, a4, a5, a6, a7, a8);
  simd_float4x4 v51 = __invert_f4(v50);
  __n128 v20 = v49;
  float v21 = v49.n128_f32[2];
  if (v49.n128_f32[2] == 0.0 || v49.n128_f32[3] == 0.0)
  {
    sub_1B63F2F54(16, @"Error: CFXProjectionInfosUnproject : invalid viewport dimension", v14, v15, v16, v17, v18, v19, v47);
    return 0;
  }
  if (v10)
  {
    uint64_t v22 = v10;
    uint64_t v23 = (float *)(a2 + 8);
    do
    {
      float v24 = (float)((float)(*(v23 - 2) - v20.n128_f32[0]) + (float)(*(v23 - 2) - v20.n128_f32[0])) / v21;
      float v25 = (float)((float)((float)(*(v23 - 1) - v20.n128_f32[1]) + (float)(*(v23 - 1) - v20.n128_f32[1]))
                  / v20.n128_f32[3])
          + -1.0;
      float v26 = *v23;
      v23 += 4;
      *v9++ = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)v51.columns[3], (float32x4_t)v51.columns[2], 1.0 - v26), (float32x4_t)v51.columns[1], v25), (float32x4_t)v51.columns[0], v24 + -1.0);
      --v22;
    }
    while (v22);
  }
  return 1;
}

uint64_t sub_1B649D3DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"camera");
  }
  return a1 + 64;
}

void sub_1B649D42C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B658325C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v9 = (const void *)a1[55];
  if (v9)
  {
    CFRelease(v9);
    a1[55] = 0;
  }
  unsigned int v10 = (const void *)a1[41];
  if (v10)
  {
    CFRelease(v10);
    a1[41] = 0;
  }
  double v11 = (const void *)a1[33];
  if (v11)
  {
    CFRelease(v11);
    a1[33] = 0;
  }
  float32x2_t v12 = (const void *)a1[32];
  if (v12)
  {
    CFRelease(v12);
    a1[32] = 0;
  }
  unsigned int v13 = (const void *)a1[34];
  if (v13)
  {
    CFRelease(v13);
    a1[34] = 0;
  }
  uint64_t v14 = (const void *)a1[35];
  if (v14)
  {
    CFRelease(v14);
    a1[35] = 0;
  }
  uint64_t v15 = (const void *)a1[36];
  if (v15)
  {
    CFRelease(v15);
    a1[36] = 0;
  }
  uint64_t v16 = (const void *)a1[37];
  if (v16)
  {
    CFRelease(v16);
    a1[37] = 0;
  }
  uint64_t v17 = (const void *)a1[38];
  if (v17)
  {
    CFRelease(v17);
    a1[38] = 0;
  }
  uint64_t v18 = (const void *)a1[39];
  if (v18)
  {
    CFRelease(v18);
    a1[39] = 0;
  }
  uint64_t v19 = (const void *)a1[40];
  if (v19)
  {
    CFRelease(v19);
    a1[40] = 0;
  }
  __n128 v20 = (const void *)a1[41];
  if (v20)
  {
    CFRelease(v20);
    a1[41] = 0;
  }
  float v21 = (const void *)a1[42];
  if (v21)
  {
    CFRelease(v21);
    a1[42] = 0;
  }
  uint64_t v22 = (const void *)a1[43];
  if (v22)
  {
    CFRelease(v22);
    a1[43] = 0;
  }
  uint64_t v23 = (const void *)a1[44];
  if (v23)
  {
    CFRelease(v23);
    a1[44] = 0;
  }
}

CFStringRef sub_1B649D544(unsigned char *cf)
{
  char v2 = cf[64];
  if ((v2 & 4) != 0)
  {
    long long v30 = *((_OWORD *)cf + 13);
    long long v31 = *((_OWORD *)cf + 14);
    long long v28 = *((_OWORD *)cf + 11);
    long long v29 = *((_OWORD *)cf + 12);
    CFAllocatorRef v19 = CFGetAllocator(cf);
    uint64_t v27 = sub_1B6583470((uint64_t)cf, v20, v21, v22, v23, v24, v25, v26);
    return CFStringCreateWithFormat(v19, 0, @"<CFXCamera:%p \"%@\" custom, [%.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f ; %.3f %.3f %.3f %.3f]>",
             *(float *)&v28,
             *((float *)&v28 + 1),
             cf,
             v27,
             *(float *)&v28,
             *((float *)&v28 + 1),
             *((float *)&v28 + 2),
             *((float *)&v28 + 3),
             *(float *)&v29,
             *((float *)&v29 + 1),
             *((float *)&v29 + 2),
             *((float *)&v29 + 3),
             *(float *)&v30,
             *((float *)&v30 + 1),
             *((float *)&v30 + 2),
             *((float *)&v30 + 3),
             *(float *)&v31,
             *((float *)&v31 + 1),
             *((float *)&v31 + 2),
             *((float *)&v31 + 3));
  }
  else
  {
    float v3 = *((float *)cf + 26);
    float v4 = *((float *)cf + 27);
    float v6 = *((float *)cf + 17);
    float v5 = *((float *)cf + 18);
    CFAllocatorRef v7 = CFGetAllocator(cf);
    uint64_t v15 = sub_1B6583470((uint64_t)cf, v8, v9, v10, v11, v12, v13, v14);
    double v16 = v6;
    double v17 = v5;
    if (v2) {
      return CFStringCreateWithFormat(v7, 0, @"<CFXCamera:%p \"%@\" ortho, near:%.3f far:%.3f scale: %.3f>", v16, v17, cf, v15, v6, v5, v3);
    }
    else {
      return CFStringCreateWithFormat(v7, 0, @"<CFXCamera:%p \"%@\" persp, near:%.3f far:%.3f fov:%.3f>", v16, v17, cf, v15, v6, v5, v4);
    }
  }
}

float sub_1B649D6C8(uint64_t a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (float *)(a1 + 108);
  if ((float *)(a1 + 108) == __dst)
  {
    float v14 = *__src;
    return sub_1B649C1B8((float *)a1, v14, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else
  {
    memcpy(__dst, __src, __n);
    if (a1 + 112 <= (unint64_t)__dst && a1 + 128 > (unint64_t)__dst) {
      *(unsigned char *)(a1 + 64) |= 4u;
    }
    uint64_t v12 = (float *)(a1 + 244);
    if ((float *)(a1 + 248) == __dst || v12 == __dst)
    {
      long double v13 = atan(*(float *)(a1 + 248) * 0.5 / *v12);
      *(float *)&long double v13 = v13 + v13;
      float result = *(float *)&v13 / 3.14159265 * 180.0;
      *uint64_t v9 = result;
    }
  }
  return result;
}

__CFArray *sub_1B649D7C0(uint64_t a1)
{
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  float v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  float v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 1;
  uint64_t v114 = a1 + 108;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v4, @"name", @"fieldOfView");
  CFDictionarySetValue(v4, @"type", v5);
  CFDictionarySetValue(v4, @"address", v7);
  CFDictionarySetValue(v4, @"semantic", v6);
  CFArrayAppendValue(Mutable, v4);
  CFRelease(v6);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v5);
  uint64_t v8 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 1;
  uint64_t v114 = a1 + 248;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v8, @"name", @"sensorHeight");
  CFDictionarySetValue(v8, @"type", v9);
  CFDictionarySetValue(v8, @"address", v11);
  CFDictionarySetValue(v8, @"semantic", v10);
  CFArrayAppendValue(Mutable, v8);
  CFRelease(v10);
  CFRelease(v8);
  CFRelease(v11);
  CFRelease(v9);
  uint64_t v12 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  long double v13 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 1;
  uint64_t v114 = a1 + 244;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v13, @"name", @"focalLength");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  double v17 = CFDictionaryCreateMutable(0, 4, v3, v12);
  int v115 = 0;
  int valuePtr = 7;
  uint64_t v114 = a1 + 80;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v17, @"name", @"filmOffset");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  uint64_t v21 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 7;
  uint64_t v114 = a1 + 88;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v21, @"name", @"postProjectionTransformTranslation");
  CFDictionarySetValue(v21, @"type", v22);
  CFDictionarySetValue(v21, @"address", v24);
  CFDictionarySetValue(v21, @"semantic", v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  uint64_t v25 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 7;
  uint64_t v114 = a1 + 96;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v25, @"name", @"postProjectionTransformScale");
  CFDictionarySetValue(v25, @"type", v26);
  CFDictionarySetValue(v25, @"address", v28);
  CFDictionarySetValue(v25, @"semantic", v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  long long v29 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  long long v30 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 6;
  uint64_t v114 = a1 + 104;
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v30, @"name", @"orthoScale");
  CFDictionarySetValue(v30, @"type", v31);
  CFDictionarySetValue(v30, @"address", v33);
  CFDictionarySetValue(v30, @"semantic", v32);
  CFArrayAppendValue(Mutable, v30);
  CFRelease(v32);
  CFRelease(v30);
  CFRelease(v33);
  CFRelease(v31);
  float v34 = CFDictionaryCreateMutable(0, 4, v3, v29);
  int v115 = 0;
  int valuePtr = 1;
  uint64_t v114 = a1 + 72;
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v34, @"name", @"zfar");
  CFDictionarySetValue(v34, @"type", v35);
  CFDictionarySetValue(v34, @"address", v37);
  CFDictionarySetValue(v34, @"semantic", v36);
  CFArrayAppendValue(Mutable, v34);
  CFRelease(v36);
  CFRelease(v34);
  CFRelease(v37);
  CFRelease(v35);
  uint64_t v38 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v29);
  int v115 = 0;
  int valuePtr = 1;
  uint64_t v114 = a1 + 68;
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v40 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v38, @"name", @"znear");
  CFDictionarySetValue(v38, @"type", v39);
  CFDictionarySetValue(v38, @"address", v41);
  CFDictionarySetValue(v38, @"semantic", v40);
  CFArrayAppendValue(Mutable, v38);
  CFRelease(v40);
  CFRelease(v38);
  CFRelease(v41);
  CFRelease(v39);
  float v42 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  float v43 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 10;
  uint64_t v44 = a1;
  uint64_t v114 = a1 + 112;
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v43, @"name", @"matrix");
  CFDictionarySetValue(v43, @"type", v45);
  CFDictionarySetValue(v43, @"address", v47);
  CFDictionarySetValue(v43, @"semantic", v46);
  CFArrayAppendValue(Mutable, v43);
  CFRelease(v46);
  CFRelease(v43);
  CFRelease(v47);
  CFRelease(v45);
  float32x4_t v48 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  __n128 v49 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v42);
  int v115 = 0;
  int valuePtr = 1;
  uint64_t v114 = v44 + 240;
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v49, @"name", @"focusDistance");
  CFDictionarySetValue(v49, @"type", v50);
  CFDictionarySetValue(v49, @"address", v52);
  CFDictionarySetValue(v49, @"semantic", v51);
  CFArrayAppendValue(Mutable, v49);
  CFRelease(v51);
  CFRelease(v49);
  CFRelease(v52);
  CFRelease(v50);
  uint64_t v53 = CFDictionaryCreateMutable(0, 4, v48, MEMORY[0x1E4F1D540]);
  int v115 = 0;
  int valuePtr = 2;
  uint64_t v114 = v44 + 432;
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v56 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v53, @"name", @"categoryBitMask");
  CFDictionarySetValue(v53, @"type", v54);
  CFDictionarySetValue(v53, @"address", v56);
  CFDictionarySetValue(v53, @"semantic", v55);
  CFArrayAppendValue(Mutable, v53);
  CFRelease(v55);
  CFRelease(v53);
  CFRelease(v56);
  CFRelease(v54);
  double v57 = CFDictionaryCreateMutable(0, 4, v48, MEMORY[0x1E4F1D540]);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 256;
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v57, @"name", @"depthOfField");
  CFDictionarySetValue(v57, @"type", v58);
  CFDictionarySetValue(v57, @"address", v60);
  CFDictionarySetValue(v57, @"semantic", v59);
  CFArrayAppendValue(Mutable, v57);
  CFRelease(v59);
  CFRelease(v57);
  CFRelease(v60);
  CFRelease(v58);
  double v61 = v48;
  float v62 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  unsigned int v63 = CFDictionaryCreateMutable(0, 4, v61, MEMORY[0x1E4F1D540]);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 264;
  CFNumberRef v64 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v65 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v63, @"name", @"motionBlur");
  CFDictionarySetValue(v63, @"type", v64);
  CFDictionarySetValue(v63, @"address", v66);
  CFDictionarySetValue(v63, @"semantic", v65);
  CFArrayAppendValue(Mutable, v63);
  CFRelease(v65);
  CFRelease(v63);
  CFRelease(v66);
  CFRelease(v64);
  double v67 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 272;
  CFNumberRef v68 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v69 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v70 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v67, @"name", @"grain");
  CFDictionarySetValue(v67, @"type", v68);
  CFDictionarySetValue(v67, @"address", v70);
  CFDictionarySetValue(v67, @"semantic", v69);
  CFArrayAppendValue(Mutable, v67);
  CFRelease(v69);
  CFRelease(v67);
  CFRelease(v70);
  CFRelease(v68);
  long long v71 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 280;
  CFNumberRef v72 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v73 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v74 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v71, @"name", @"exposure");
  CFDictionarySetValue(v71, @"type", v72);
  CFDictionarySetValue(v71, @"address", v74);
  CFDictionarySetValue(v71, @"semantic", v73);
  CFArrayAppendValue(Mutable, v71);
  CFRelease(v73);
  CFRelease(v71);
  CFRelease(v74);
  CFRelease(v72);
  float32x2_t v75 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 288;
  CFNumberRef v76 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v77 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v78 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v75, @"name", @"toneMapping");
  CFDictionarySetValue(v75, @"type", v76);
  CFDictionarySetValue(v75, @"address", v78);
  CFDictionarySetValue(v75, @"semantic", v77);
  CFArrayAppendValue(Mutable, v75);
  CFRelease(v77);
  CFRelease(v75);
  CFRelease(v78);
  CFRelease(v76);
  uint64_t v79 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 296;
  CFNumberRef v80 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v81 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v82 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v79, @"name", @"bloom");
  CFDictionarySetValue(v79, @"type", v80);
  CFDictionarySetValue(v79, @"address", v82);
  CFDictionarySetValue(v79, @"semantic", v81);
  CFArrayAppendValue(Mutable, v79);
  CFRelease(v81);
  CFRelease(v79);
  CFRelease(v82);
  CFRelease(v80);
  long long v83 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 304;
  CFNumberRef v84 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v85 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v86 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v83, @"name", @"vignetting");
  CFDictionarySetValue(v83, @"type", v84);
  CFDictionarySetValue(v83, @"address", v86);
  CFDictionarySetValue(v83, @"semantic", v85);
  CFArrayAppendValue(Mutable, v83);
  CFRelease(v85);
  CFRelease(v83);
  CFRelease(v86);
  CFRelease(v84);
  long long v87 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 312;
  CFNumberRef v88 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v89 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v90 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v87, @"name", @"lensBlur");
  CFDictionarySetValue(v87, @"type", v88);
  CFDictionarySetValue(v87, @"address", v90);
  CFDictionarySetValue(v87, @"semantic", v89);
  CFArrayAppendValue(Mutable, v87);
  CFRelease(v89);
  CFRelease(v87);
  CFRelease(v90);
  CFRelease(v88);
  long long v91 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  v92 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v62);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 320;
  CFNumberRef v93 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v94 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v95 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v92, @"name", @"colorFringe");
  CFDictionarySetValue(v92, @"type", v93);
  CFDictionarySetValue(v92, @"address", v95);
  CFDictionarySetValue(v92, @"semantic", v94);
  CFArrayAppendValue(Mutable, v92);
  CFRelease(v94);
  CFRelease(v92);
  CFRelease(v95);
  CFRelease(v93);
  v96 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  v97 = CFDictionaryCreateMutable(0, 4, v91, MEMORY[0x1E4F1D540]);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 328;
  CFNumberRef v98 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v99 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v100 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v97, @"name", @"colorGrading");
  CFDictionarySetValue(v97, @"type", v98);
  CFDictionarySetValue(v97, @"address", v100);
  CFDictionarySetValue(v97, @"semantic", v99);
  CFArrayAppendValue(Mutable, v97);
  CFRelease(v99);
  CFRelease(v97);
  CFRelease(v100);
  CFRelease(v98);
  v101 = CFDictionaryCreateMutable(0, 4, v91, v96);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 336;
  CFNumberRef v102 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v103 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v104 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v101, @"name", @"chromaticTransform");
  CFDictionarySetValue(v101, @"type", v102);
  CFDictionarySetValue(v101, @"address", v104);
  CFDictionarySetValue(v101, @"semantic", v103);
  CFArrayAppendValue(Mutable, v101);
  CFRelease(v103);
  CFRelease(v101);
  CFRelease(v104);
  CFRelease(v102);
  v105 = CFDictionaryCreateMutable(0, 4, v91, v96);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 344;
  CFNumberRef v106 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v107 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v108 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v105, @"name", @"doughnutBokeh");
  CFDictionarySetValue(v105, @"type", v106);
  CFDictionarySetValue(v105, @"address", v108);
  CFDictionarySetValue(v105, @"semantic", v107);
  CFArrayAppendValue(Mutable, v105);
  CFRelease(v107);
  CFRelease(v105);
  CFRelease(v108);
  CFRelease(v106);
  v109 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v115 = 1;
  int valuePtr = 5;
  uint64_t v114 = v44 + 352;
  CFNumberRef v110 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v111 = CFNumberCreate(0, kCFNumberSInt32Type, &v115);
  CFNumberRef v112 = CFNumberCreate(0, kCFNumberLongType, &v114);
  CFDictionarySetValue(v109, @"name", @"ssao");
  CFDictionarySetValue(v109, @"type", v110);
  CFDictionarySetValue(v109, @"address", v112);
  CFDictionarySetValue(v109, @"semantic", v111);
  CFArrayAppendValue(Mutable, v109);
  CFRelease(v111);
  CFRelease(v109);
  CFRelease(v112);
  CFRelease(v110);
  return Mutable;
}

uint64_t sub_1B649EE98(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B649EED0(uint64_t result, uint64_t a2)
{
  float v3 = (void *)result;
  if (*(void *)(result + 256)) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[33]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[34]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[35]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[36]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[37]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[38]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[39]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[40]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[41]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[42]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[43]) {
    float result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  if (v3[44])
  {
    float v4 = *(uint64_t (**)(uint64_t))(a2 + 16);
    return v4(a2);
  }
  return result;
}

uint64_t sub_1B649F044(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 16) = a3;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  return a1;
}

void sub_1B649F094(_Unwind_Exception *exception_object)
{
  float v3 = v2;
  CFNumberRef v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

double sub_1B649F0B4(uint64_t a1)
{
  *(_DWORD *)(a1 + 56) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  return result;
}

uint64_t sub_1B649F0C8(uint64_t a1)
{
  char v2 = *(id **)(a1 + 32);
  if (v2 != *(id **)(a1 + 40))
  {
    do
    {

      v2 += 2;
    }
    while (v2 != *(id **)(a1 + 40));
    char v2 = *(id **)(a1 + 32);
  }
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1B649F12C(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)(v1 + 32);
  if (v3)
  {
    *(void *)(v1 + 40) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1B649F150@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unint64_t result = sub_1B653EFB8(*(void *)a1);
  unint64_t v10 = (a2 + 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v11 = *(void *)(a1 + 88);
  uint64_t v12 = v11 + v10;
  if (v11 + v10 > *(void *)(a1 + 80))
  {
    do
    {
      uint64_t v13 = *(void *)(a1 + 32);
      uint64_t v14 = *(unsigned int *)(a1 + 56);
      if (v14 >= ((unint64_t)(*(void *)(a1 + 40) - v13) >> 4))
      {
        double v17 = 0;
        do
          v17 += *(void *)(a1 + 8);
        while (v10 > (unint64_t)v17);
        uint64_t v18 = sub_1B653D684(*(void *)a1, v17, 16 * *(void *)(a1 + 24));
        uint64_t v19 = v18;
        *(void *)(a1 + 64) = v18;
        unint64_t v21 = *(void *)(a1 + 40);
        unint64_t v20 = *(void *)(a1 + 48);
        if (v21 >= v20)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          uint64_t v24 = (uint64_t)(v21 - v23) >> 4;
          unint64_t v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 60) {
            abort();
          }
          uint64_t v26 = v20 - v23;
          if (v26 >> 3 > v25) {
            unint64_t v25 = v26 >> 3;
          }
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v7 = v25;
          }
          if (v7) {
            CFNumberRef v27 = (char *)sub_1B6427C8C(a1 + 48, v7);
          }
          else {
            CFNumberRef v27 = 0;
          }
          CFNumberRef v28 = &v27[16 * v24];
          *(void *)CFNumberRef v28 = v19;
          *((_DWORD *)v28 + 2) = 1;
          long long v30 = *(char **)(a1 + 32);
          long long v29 = *(char **)(a1 + 40);
          CFNumberRef v31 = v28;
          if (v29 != v30)
          {
            do
            {
              *((_OWORD *)v31 - 1) = *((_OWORD *)v29 - 1);
              v31 -= 16;
              v29 -= 16;
            }
            while (v29 != v30);
            long long v29 = *(char **)(a1 + 32);
          }
          CFNumberRef v22 = v28 + 16;
          *(void *)(a1 + 32) = v31;
          *(void *)(a1 + 40) = v28 + 16;
          *(void *)(a1 + 48) = &v27[16 * v7];
          if (v29) {
            operator delete(v29);
          }
        }
        else
        {
          *(void *)unint64_t v21 = v18;
          *(_DWORD *)(v21 + 8) = 1;
          CFNumberRef v22 = (char *)(v21 + 16);
        }
        *(void *)(a1 + 40) = v22;
        LODWORD(v14) = *(_DWORD *)(a1 + 56);
        CFNumberRef v16 = *(void **)(a1 + 64);
      }
      else
      {
        uint64_t v15 = v13 + 16 * v14;
        CFNumberRef v16 = *(void **)v15;
        *(void *)(a1 + 64) = *(void *)v15;
        ++*(_DWORD *)(v15 + 8);
      }
      *(_DWORD *)(a1 + 56) = v14 + 1;
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 72) = objc_msgSend_contents(v16, (const char *)v7, v8, v9);
      unint64_t result = objc_msgSend_length(*(void **)(a1 + 64), v32, v33, v34);
      *(void *)(a1 + 80) = result;
      uint64_t v11 = *(void *)(a1 + 88);
      uint64_t v12 = v11 + v10;
    }
    while (v11 + v10 > result);
  }
  a3[2] = v11;
  uint64_t v35 = *(void *)(a1 + 64);
  *a3 = *(void *)(a1 + 72) + v11;
  a3[1] = v35;
  *(void *)(a1 + 88) = v12;
  return result;
}

void *sub_1B649F334@<X0>(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, void **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  sub_1B649F150(a1, a3, a4);
  unint64_t v7 = *a4;

  return memcpy(v7, a2, a3);
}

uint64_t sub_1B649F390(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(unsigned __int8 *)(a1 + 200);
}

void sub_1B649F3DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 48);
  if (v8) {
    sub_1B649F3EC(a1, v8, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B649F3EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = sub_1B649FF9C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (((v10 ^ (*(_DWORD *)(a1 + 216) == -1)) & 1) == 0)
  {
    int v18 = v10;
    uint64_t v19 = sub_1B64B2994(a2, v11, v12, v13, v14, v15, v16, v17);
    if (v18)
    {
      int v26 = sub_1B65C4D10(v19, a1, v20, v21, v22, v23, v24, v25);
    }
    else
    {
      sub_1B65C53B0(v19, *(_DWORD *)(a1 + 216), v20, v21, v22, v23, v24, v25);
      int v26 = -1;
    }
    *(_DWORD *)(a1 + 216) = v26;
    uint64_t v34 = sub_1B64B29E0(a2, v27, v28, v29, v30, v31, v32, v33);
    int v40 = *(_DWORD *)(a1 + 88);
    uint64_t v41 = *(unsigned int *)(a1 + 216);
    sub_1B650FF78(v34, v40, v41, v35, v36, v37, v38, v39);
  }
}

float32x4_t sub_1B649F48C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 223) & 1) == 0)
  {
    *(_OWORD *)(a1 + 272) = xmmword_1B6E4F370;
    *(_OWORD *)(a1 + 288) = xmmword_1B6E51230;
    uint64_t v9 = *(uint64_t **)(a1 + 248);
    if (!v9 || (sub_1B65E2120(v9, a1 + 272) & 1) == 0)
    {
      uint64_t v11 = *(const void **)(a1 + 240);
      if (v11)
      {
        float32x4_t v41 = 0uLL;
        float32x4_t v40 = 0uLL;
        if (sub_1B63F493C(v11, 0, (uint64_t)&v41, (uint64_t)&v40, a5, a6, a7, a8))
        {
          float32x4_t v13 = v40;
          float32x4_t v12 = v41;
          v12.i32[3] = 1.0;
          v13.i32[3] = 1.0;
          v14.i64[0] = 0x3F0000003F000000;
          v14.i64[1] = 0x3F0000003F000000;
          *(float32x4_t *)(a1 + 272) = vmulq_f32(vaddq_f32(v12, v13), v14);
          *(float32x4_t *)(a1 + 288) = vmulq_f32(vsubq_f32(v13, v12), v14);
        }
      }
      CFDictionaryRef v15 = sub_1B649F640(a1, a2, a3, a4, a5, a6, a7, a8);
      if (v15)
      {
        uint64_t v23 = (uint64_t)v15;
        if (sub_1B6496680((uint64_t)v15, v16, v17, v18, v19, v20, v21, v22) == 5)
        {
          if (sub_1B6496EF8(v23, v24, v25, v26, v27, v28, v29, v30))
          {
            uint64_t v31 = (const void *)sub_1B649683C(v23);
            if (v31)
            {
              float32x4_t v41 = 0uLL;
              float32x4_t v40 = 0uLL;
              if (sub_1B63F493C(v31, 0, (uint64_t)&v41, (uint64_t)&v40, v32, v33, v34, v35))
              {
                float32x4_t v37 = v40;
                float32x4_t v36 = v41;
                v36.i32[3] = 1.0;
                v37.i32[3] = 1.0;
                v38.i64[0] = 0x3F0000003F000000;
                v38.i64[1] = 0x3F0000003F000000;
                float32x4_t v39 = vmulq_f32(vaddq_f32(v36, v37), v38);
                float32x4_t result = vmulq_f32(vsubq_f32(v37, v36), v38);
                *(float32x4_t *)(a1 + 272) = v39;
                *(float32x4_t *)(a1 + 288) = result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1B649F5A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(void *)(a1 + 248);
}

uint64_t sub_1B649F5F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(void *)(a1 + 240);
}

CFDictionaryRef sub_1B649F640(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 221) & 2) == 0) {
    return 0;
  }

  return sub_1B6583734(a1, @"kLightKey", a3, a4, a5, a6, a7, a8);
}

void sub_1B649F6C4(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  sub_1B649F73C(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v13 = a1[3].i64[0];

  sub_1B64B1F18(v13, 2, a1, @"model", v9, v10, v11, v12);
}

void sub_1B649F73C(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((a1[13].i8[12] & 4) == 0) {
    sub_1B649F48C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  }
  if (a1[13].i32[2] != -1)
  {
    uint64_t v9 = a1[3].i64[0];
    if (v9)
    {
      uint64_t v10 = (void *)sub_1B64B2994(v9, a2, a3, a4, a5, a6, a7, a8);
      float32x4_t v16 = a1[18];
      v17[0] = a1[17];
      v17[1] = v16;
      if ((vminvq_u32((uint32x4_t)vcgezq_f32(a1[18])) & 0x80000000) != 0) {
        sub_1B65C4E20(v10, a1[13].u32[2], v17, v11, v12, v13, v14, v15);
      }
    }
  }
}

uint64_t sub_1B649F7D4(uint64_t a1, _OWORD *a2)
{
  long long v2 = *(_OWORD *)(a1 + 288);
  *a2 = *(_OWORD *)(a1 + 272);
  a2[1] = v2;
  return vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 288))) >> 31;
}

void sub_1B649F7F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v9 = *(void **)(a1 + 232);
  if (v9) {
    free(v9);
  }
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 220) &= ~0x4000u;
  uint64_t v10 = *(void *)(a1 + 240);
  if (v10)
  {
    CFArrayRef v11 = (const __CFArray *)sub_1B63CE0D8(v10, a2, a3, a4, a5, a6, a7, a8);
    if (v11)
    {
      CFArrayRef v12 = v11;
      if (CFArrayGetCount(v11) >= 1)
      {
        CFIndex Count = CFArrayGetCount(v12);
        uint64_t v14 = Count;
        uint64_t v15 = Count >= 0 ? Count : Count + 1;
        ValueAtIndex = CFArrayGetValueAtIndex(v12, v15 >> 1);
        char v24 = sub_1B647B2B0((uint64_t)ValueAtIndex, v17, v18, v19, v20, v21, v22, v23);
        uint64_t v25 = (char *)malloc_type_malloc(12 * v14 + 8, 0xB0A92020uLL);
        *(void *)(a1 + 232) = v25;
        *(_WORD *)uint64_t v25 = v14;
        v25[2] = v24;
        *(_DWORD *)(*(void *)(a1 + 232) + 4) = 0;
        *(_DWORD *)(a1 + 220) |= 0x4000u;
        if (v14 >= 1)
        {
          CFIndex v26 = 0;
          uint64_t v27 = (float *)(v25 + 16);
          do
          {
            uint64_t v28 = CFArrayGetValueAtIndex(v12, v26);
            *(v27 - 2) = sub_1B647B2FC((uint64_t)v28, v29, v30, v31, v32, v33, v34, v35);
            *(void *)(v27 - 1) = 0xFFFFFFFFLL;
            ++v26;
            v27 += 3;
          }
          while (v14 != v26);
        }
      }
    }
  }
  uint64_t v36 = *(void *)(a1 + 48);

  sub_1B64B1F18(v36, 2, (const void *)a1, @"model", a5, a6, a7, a8);
}

uint64_t sub_1B649F94C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 221) >> 6) & 1;
}

float32x4_t sub_1B649F958(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5)
{
  float32x4_t v5 = *a1;
  float32x4_t v6 = *a2;
  v5.i32[3] = 1.0;
  v6.i32[3] = 1.0;
  v7.i64[0] = 0x3F0000003F000000;
  v7.i64[1] = 0x3F0000003F000000;
  float32x4_t v8 = vmulq_f32(vaddq_f32(v5, v6), v7);
  int32x4_t v9 = (int32x4_t)vmulq_f32(vsubq_f32(v6, v5), v7);
  float32x4_t v10 = a5[1];
  float32x4_t v11 = a5[2];
  float32x4_t v12 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a5[3], v11, v8, 2), v10, *(float32x2_t *)v8.f32, 1), *a5, v8.f32[0]);
  v12.i32[3] = v8.i32[3];
  float32x4_t v13 = (float32x4_t)v9;
  v13.i32[1] = v9.i32[0];
  v13.i32[2] = v9.i32[0];
  float32x4_t v14 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v9.i8, 1), v9), vabsq_f32(v10)), v13, vabsq_f32(*a5)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v9, v9), v9), vabsq_f32(v11));
  *a3 = vsubq_f32(v12, v14);
  float32x4_t result = vaddq_f32(v14, v12);
  *a4 = result;
  return result;
}

uint64_t sub_1B649F9E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(a1 + 240);
  if (result)
  {
    uint64_t result = (uint64_t)sub_1B63CCF34(result, 0, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      uint64_t result = sub_1B64AF43C(result, v9, v10, v11, v12, v13, v14, v15);
      if (result) {
        return (sub_1B64757A4(result, v16, v17, v18, v19, v20, v21, v22) & 0xFFFFFFFD) != 0;
      }
    }
  }
  return result;
}

uint64_t sub_1B649FA1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 220);
  if ((v8 & 2) != 0)
  {
    if ((v8 & 4) != 0)
    {
      LODWORD(v10) = 0;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 240);
      if (v10)
      {
        LODWORD(v10) = sub_1B63CCFB8(v10, a2, a3, a4, a5, a6, a7, a8);
        int v8 = *(_DWORD *)(a1 + 220);
      }
    }
    int v8 = v8 & 0xFFFFFFFC | v10;
    *(_DWORD *)(a1 + 220) = v8;
  }
  return v8 & 1;
}

uint64_t sub_1B649FA70(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 220) >> 2) & 1;
}

void sub_1B649FA7C(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 220);
  if (a3 != 2 || (v10 & 4) == 0)
  {
    if (a2)
    {
      long long v11 = a2[1];
      *(_OWORD *)(a1 + 272) = *a2;
      *(_OWORD *)(a1 + 288) = v11;
    }
    else
    {
      sub_1B649F48C(a1, 0, a3, a4, a5, a6, a7, a8);
      unsigned int v10 = *(_DWORD *)(a1 + 220);
    }
    if (a3 != 2)
    {
      unsigned int v10 = v10 & 0xFFFFFFFB | (4 * (a3 == 1));
      *(_DWORD *)(a1 + 220) = v10;
    }
    if ((v10 & 4) != 0) {
      *(_DWORD *)(a1 + 220) = v10 & 0xFFFFFFFC;
    }
    sub_1B649F73C((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B649FB10(uint64_t result, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(result + 216) != -1)
  {
    uint64_t v8 = result;
    uint64_t result = *(void *)(result + 48);
    if (result)
    {
      uint64_t v10 = sub_1B64B2994(result, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      unsigned int v16 = *(_DWORD *)(v8 + 216);
      return sub_1B65C5058(v10, v16, a2, v11, v12, v13, v14, v15);
    }
  }
  return result;
}

uint64_t sub_1B649FB70(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (*(unsigned char *)(a1 + 200)) {
    return 0;
  }
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000;
  if ((*(unsigned char *)(a1 + 221) & 0x10) != 0 && *(void *)(a1 + 240))
  {
    uint64_t v11 = 0;
  }
  else
  {
    long long v12 = *(_OWORD *)(a1 + 288);
    *a2 = *(_OWORD *)(a1 + 272);
    a2[1] = v12;
    uint64_t v11 = vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 288))) >> 31;
  }
  char v24 = v11;
  uint64_t v13 = *(void *)(a1 + 72);
  if (v13)
  {
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 0x40000000;
    unsigned int v16 = sub_1B649FD5C;
    uint64_t v17 = &unk_1E6142AD0;
    uint64_t v18 = &v21;
    uint64_t v19 = a3;
    uint64_t v20 = a2;
    do
    {
      ((void (*)(void *, uint64_t))v16)(v15, v13);
      uint64_t v13 = *(void *)(v13 + 80);
    }
    while (v13);
    uint64_t v11 = *((unsigned char *)v22 + 24) != 0;
  }
  _Block_object_dispose(&v21, 8);
  return v11;
}

uint64_t sub_1B649FCB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 221) & 0x10) != 0) {
    return *(void *)(a1 + 240);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B649FD10(uint64_t result, uint64_t a2)
{
  for (uint64_t i = *(void *)(result + 72); i; uint64_t i = *(void *)(i + 80))
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, i);
  return result;
}

double sub_1B649FD5C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  v10.i64[0] = 0;
  float32x4_t v35 = 0u;
  int32x4_t v36 = 0u;
  if ((*(unsigned char *)(a2 + 221) & 0x10) != 0 && *(void *)(a2 + 240))
  {
    uint64_t v11 = (unsigned char *)a1[5];
    if (v11) {
      *uint64_t v11 = 1;
    }
  }
  else if (sub_1B649FB70(a2, &v35, a1[5]))
  {
    *(double *)v19.i64 = sub_1B649FE9C(a2, v12, v13, v14, v15, v16, v17, v18);
    float32x4_t v23 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v21, v20, v35, 2), v22, *(float32x2_t *)v35.f32, 1), v19, v35.f32[0]);
    v23.i32[3] = v35.i32[3];
    float32x4_t v24 = (float32x4_t)v36;
    v24.i32[1] = v36.i32[0];
    v24.i32[2] = v36.i32[0];
    float32x4_t v25 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v36.i8, 1), v36), vabsq_f32(v22)), v24, vabsq_f32(v19)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v36, v36), v36), vabsq_f32(v20));
    float32x4_t v35 = v23;
    int32x4_t v36 = (int32x4_t)v25;
    uint64_t v26 = *(void *)(a1[4] + 8);
    if (*(unsigned char *)(v26 + 24))
    {
      uint64_t v27 = (float32x4_t *)a1[6];
      float32x4_t v28 = v27[1];
      float32x4_t v29 = vminnmq_f32(vsubq_f32(*v27, v28), vsubq_f32(v23, v25));
      float32x4_t v30 = vmaxnmq_f32(vaddq_f32(*v27, v28), vaddq_f32(v23, v25));
      v28.i64[0] = 0x3F0000003F000000;
      v28.i64[1] = 0x3F0000003F000000;
      float32x4_t v31 = vmulq_f32(vaddq_f32(v29, v30), v28);
      float32x4_t v10 = vmulq_f32(vsubq_f32(v30, v29), v28);
      *uint64_t v27 = v31;
      v27[1] = v10;
    }
    else
    {
      *(unsigned char *)(v26 + 24) = 1;
      uint64_t v32 = a1[6];
      v10.i64[0] = v35.i64[0];
      int32x4_t v33 = v36;
      *(float32x4_t *)uint64_t v32 = v35;
      *(int32x4_t *)(v32 + 16) = v33;
    }
  }
  return *(double *)v10.i64;
}

double sub_1B649FE9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  __n128 v12 = sub_1B6454C84((unsigned char *)(a1 + 96), a2, a3, a4, a5, a6, a7, a8);
  float32x4_t v13 = (float32x4_t)v9;
  float32x4_t v14 = (float32x4_t)v10;
  float32x4_t v15 = (float32x4_t)v11;
  uint64_t v16 = *(void *)(a1 + 192);
  if (v16)
  {
    if (*(float *)(v16 + 124) == 0.0)
    {
      __n128 v24 = v9;
      __n128 v25 = v12;
      __n128 v22 = v11;
      __n128 v23 = v10;
      simd_float4x4 v28 = __invert_f4(*(simd_float4x4 *)v16);
      float32x4_t v15 = (float32x4_t)v22;
      float32x4_t v14 = (float32x4_t)v23;
      float32x4_t v13 = (float32x4_t)v24;
      __n128 v12 = v25;
      *(simd_float4x4 *)(v16 + 64) = v28;
      uint64_t v16 = *(void *)(a1 + 192);
    }
    uint64_t v17 = 0;
    long long v18 = *(_OWORD *)(v16 + 80);
    long long v19 = *(_OWORD *)(v16 + 96);
    long long v20 = *(_OWORD *)(v16 + 112);
    v26[0] = *(_OWORD *)(v16 + 64);
    v26[1] = v18;
    v26[2] = v19;
    v26[3] = v20;
    memset(v27, 0, sizeof(v27));
    do
    {
      v27[v17] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v12, COERCE_FLOAT(v26[v17])), v13, *(float32x2_t *)&v26[v17], 1), v14, (float32x4_t)v26[v17], 2), v15, (float32x4_t)v26[v17], 3);
      ++v17;
    }
    while (v17 != 4);
    v12.n128_u64[0] = *(void *)&v27[0];
  }
  return v12.n128_f64[0];
}

uint64_t sub_1B649FF9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 240)) {
    return 1;
  }
  unsigned int v9 = *(_DWORD *)(a1 + 220);
  if ((v9 & 0x2000) != 0) {
    return 1;
  }
  if ((v9 & 0x200) != 0)
  {
    CFDictionaryRef v10 = sub_1B649F640(a1, a2, a3, a4, a5, a6, a7, a8);
    if (sub_1B6496EF8((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17)) {
      return 1;
    }
    unsigned int v9 = *(_DWORD *)(a1 + 220);
  }
  return HIBYTE(v9) & 1;
}

uint64_t sub_1B649FFF0(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v2 = a1[18];
  *a2 = a1[17];
  a2[1] = v2;
  unsigned int v3 = vminvq_u32((uint32x4_t)vcgezq_f32(a1[18])) >> 31;
  for (uint64_t i = a1[4].i64[1]; i; uint64_t i = *(void *)(i + 80))
  {
    float32x4_t v24 = 0u;
    int32x4_t v25 = 0u;
    if (sub_1B649FFF0(i, &v24))
    {
      *(double *)v13.i64 = sub_1B649FE9C(i, v6, v7, v8, v9, v10, v11, v12);
      float32x4_t v17 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v15, v14, v24, 2), v16, *(float32x2_t *)v24.f32, 1), v13, v24.f32[0]);
      v17.i32[3] = v24.i32[3];
      float32x4_t v18 = (float32x4_t)v25;
      v18.i32[1] = v25.i32[0];
      v18.i32[2] = v25.i32[0];
      float32x4_t v19 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v25.i8, 1), v25), vabsq_f32(v16)), v18, vabsq_f32(v13)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v25, v25), v25), vabsq_f32(v14));
      float32x4_t v20 = a2[1];
      float32x4_t v21 = vminnmq_f32(vsubq_f32(v17, v19), vsubq_f32(*a2, v20));
      float32x4_t v22 = vmaxnmq_f32(vaddq_f32(v19, v17), vaddq_f32(*a2, v20));
      v20.i64[0] = 0x3F0000003F000000;
      v20.i64[1] = 0x3F0000003F000000;
      *a2 = vmulq_f32(vaddq_f32(v21, v22), v20);
      a2[1] = vmulq_f32(vsubq_f32(v22, v21), v20);
      LOBYTE(v3) = 1;
    }
  }
  return v3 & 1;
}

uint64_t sub_1B64A00F0(float32x4_t *a1, uint64_t a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1[13].i8[14] & 0xE0) == 0
    && (uint64_t v25 = a1[3].i64[0]) != 0
    && (uint64_t v26 = sub_1B64B2994(v25, a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0)
  {
    *(__n128 *)a3 = sub_1B65C6018(v26, (uint64_t)a1, a2, v27, v28, v29, v30, v31);
    a3[1] = v32;
    return vminvq_u32((uint32x4_t)vcgezq_f32(v32)) >> 31;
  }
  else
  {
    uint64_t result = sub_1B649FFF0(a1, a3);
    if (result)
    {
      if ((a2 & 1) == 0)
      {
        uint64_t v19 = sub_1B64A01D4((uint64_t)a1, v12, v13, v14, v15, v16, v17, v18);
        float32x4_t v20 = *(float32x4_t *)(v19 + 16);
        float32x4_t v21 = *(float32x4_t *)(v19 + 32);
        float32x4_t v22 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v19 + 48), v21, *a3, 2), v20, *(float32x2_t *)a3->f32, 1), *(float32x4_t *)v19, COERCE_FLOAT(*a3));
        v22.i32[3] = HIDWORD(*(unsigned long long *)a3);
        float32x4_t v23 = a3[1];
        v23.i32[1] = v23.i32[0];
        v23.i32[2] = (__int32)a3[1];
        float32x4_t v24 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)a3[1].f32, 1), (int32x4_t)a3[1]), vabsq_f32(v20)), v23, vabsq_f32(*(float32x4_t *)v19)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)a3[1], (int32x4_t)a3[1]), (int32x4_t)a3[1]), vabsq_f32(v21));
        *a3 = v22;
        a3[1] = v24;
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_1B64A01D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9)
  {
    uint64_t v10 = sub_1B64B29E0(v9, a2, a3, a4, a5, a6, a7, a8);
    if (v10)
    {
      uint64_t v17 = v10;
      int v18 = *(_DWORD *)(a1 + 88);
      if (v18 == -1)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Node should have a TT handle already", v11, v12, v13, v14, v15, v16, (uint64_t)"node->_transformHandle != kCFXTransformHandleInvalid");
        int v18 = *(_DWORD *)(a1 + 88);
      }
      return sub_1B651004C(v17, v18, v11, v12, v13, v14, v15, v16);
    }
    sub_1B63F2F54(0, @"Warning: CFXNodeGetWorldMatrix - no transform tree", v11, v12, v13, v14, v15, v16, v20);
  }

  return sub_1B6454F20(a1 + 96, a2, a3, a4, a5, a6, a7, a8);
}

double sub_1B64A02A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint32x4_t a9)
{
  int v10 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (!*(unsigned char *)(a1 + 200))
  {
    uint64_t v12 = *(void *)(a1 + 48);
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v13 = sub_1B64B2994(v12, a2, a3, a4, a5, a6, a7, a8);
    if (!v13) {
      goto LABEL_11;
    }
    if (v10)
    {
      __n128 v19 = sub_1B65C6018(v13, a1, 1, v14, v15, v16, v17, v18);
LABEL_10:
      *(__n128 *)a3 = v19;
      *(__n128 *)(a3 + 16) = v20;
LABEL_11:
      a9 = (uint32x4_t)vcgezq_f32(*(float32x4_t *)(a3 + 16));
      a9.i32[0] = vminvq_u32(a9);
      return *(double *)a9.i64;
    }
    int v21 = *(_DWORD *)(a1 + 216);
    if (v21 != -1)
    {
      v19.n128_f64[0] = sub_1B65C5F48(v13, v21, 1);
      goto LABEL_10;
    }
    a9.i64[0] = 0;
    *(_OWORD *)a3 = xmmword_1B6E4F370;
    *(_OWORD *)(a3 + 16) = xmmword_1B6E51230;
  }
  return *(double *)a9.i64;
}

uint64_t sub_1B64A0374(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B64A0448(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    int v16 = 4;
  }
  else
  {
    if (!a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"node");
    }
    if (*(void *)(a1 + 240)) {
      int v16 = 1;
    }
    else {
      int v16 = 16 * (sub_1B64A0544(a1, @"kParticleEmitter", v10, v11, v12, v13, v14, v15) != 0);
    }
  }
  CFDictionaryRef v17 = sub_1B649F640(a1, v9, v10, v11, v12, v13, v14, v15);
  if (v17 && sub_1B6496680((uint64_t)v17, v18, v19, v20, v21, v22, v23, v24) == 5) {
    v16 |= 8u;
  }
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v19, v20, v21, v22, v23, v24, (uint64_t)"node");
  }
  return (*(_DWORD *)(a1 + 220) >> 20) & 0x20 | v16;
}

uint64_t sub_1B64A0448(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 221) & 0x20) == 0) {
    return 0;
  }
  CFDictionaryRef v9 = sub_1B6583734(a1, @"kFilterKey", a3, a4, a5, a6, a7, a8);
  if (!v9) {
    return 0;
  }

  return sub_1B660F878((uint64_t)v9, v10, v11, v12, v13, v14, v15, v16);
}

CFDictionaryRef sub_1B64A04D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A0544(a1, @"kParticleEmitter", a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64A04E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return (*(unsigned __int8 *)(a1 + 223) >> 1) & 1;
}

CFDictionaryRef sub_1B64A0534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A0544(a1, @"kBehaviorGraph", a3, a4, a5, a6, a7, a8);
}

CFDictionaryRef sub_1B64A0544(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }

  return sub_1B6583734(a1, key, a3, a4, a5, a6, a7, a8);
}

void sub_1B64A05A8(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64A05B8(uint64_t a1, const __CFDictionary *a2, void *key, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v11 = *(void *)(a1 + 48);
  CFDictionaryRef v12 = sub_1B64A0544(a1, key, (uint64_t)key, a4, a5, a6, a7, a8);
  if (v11) {
    BOOL v20 = v12 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20) {
    sub_1B63F4AAC(v12, *(void *)(a1 + 48), v14, v15, v16, v17, v18, v19);
  }
  BOOL v21 = sub_1B63F4F08(a1, v13, v14, v15, v16, v17, v18, v19) != 0;
  sub_1B65837D4((CFTypeRef *)a1, key, a2, v21, v22, v23, v24, v25);
  int v26 = *(_DWORD *)(a1 + 220);
  int v40 = sub_1B64A4A84(a1, v27, v28, v29, v30, v31, v32, v33) != 0;
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFEFFFFFF | ((v40 & 1) << 24);
  if (v11 && (v26 & 0x1000000) != v40 << 24)
  {
    if ((v26 & 0x1000000) != 0)
    {
      sub_1B64B10F0(v11, (const void *)a1);
      if (!a2) {
        return;
      }
      goto LABEL_13;
    }
    sub_1B64B0F8C(v11, (void *)a1, v34, v35, v36, v37, v38, v39);
  }
  if (!a2) {
    return;
  }
LABEL_13:
  uint64_t v41 = *(void *)(a1 + 48);
  if (v41)
  {
    sub_1B63F4CCC((uint64_t *)a2, v41, v34, v35, v36, v37, v38, v39);
  }
}

uint64_t sub_1B64A06D4()
{
  if (qword_1EB9955A0 != -1) {
    dispatch_once(&qword_1EB9955A0, &unk_1F0FB5908);
  }
  return qword_1EB9955A8;
}

double sub_1B64A0718()
{
  if (!qword_1EB9955A8)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB9955A8);
    qword_1EB9955A8 = (uint64_t)v0;
    uint64_t v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"hidden", 0xC8u, 3, 0, 0, 0, v2, v3);
    sub_1B660E400(@"opacity", 0xCCu, 1, 0, 0, 0, v4, v5);
    sub_1B660E3EC();
    unk_1EB984918 = xmmword_1F0FB89E0;
    xmmword_1EB984900 = xmmword_1F0FB89C0;
    unk_1EB984928 = xmmword_1F0FB89F0;
    qword_1EB984910 = (uint64_t)sub_1B64A50D4;
    unk_1EB984938 = *(_OWORD *)&off_1F0FB8A00;
    qword_1EB984948 = qword_1F0FB8A10;
    unk_1EB984950 = sub_1B64A6420;
    double result = *(double *)&xmmword_1F0FB89D0;
    unk_1EB984968 = xmmword_1F0FB89D0;
  }
  return result;
}

uint64_t sub_1B64A0828()
{
  if (qword_1EB9955A0 != -1) {
    dispatch_once(&qword_1EB9955A0, &unk_1F0FB5908);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB9955A8, 0x120uLL);
  sub_1B64559FC(v0 + 96);
  *(_DWORD *)(v0 + 204) = 1065353216;
  *(unsigned char *)(v0 + 200) = 0;
  unsigned int v1 = *(_DWORD *)(v0 + 220) & 0xFFEFFFD1 | 0x10002A;
  *(void *)(v0 + 208) = 1;
  *(_DWORD *)(v0 + 216) = -1;
  *(_DWORD *)(v0 + 220) = v1;
  *(_DWORD *)(v0 + 88) = -1;
  *(_OWORD *)(v0 + 272) = xmmword_1B6E4F370;
  *(_OWORD *)(v0 + 288) = xmmword_1B6E51230;
  return v0;
}

uint64_t sub_1B64A08D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  long long v10 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(a2 + 112) = v10;
  long long v11 = *(_OWORD *)(a1 + 128);
  long long v12 = *(_OWORD *)(a1 + 144);
  long long v13 = *(_OWORD *)(a1 + 176);
  *(_OWORD *)(a2 + 160) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(a2 + 176) = v13;
  *(_OWORD *)(a2 + 128) = v11;
  *(_OWORD *)(a2 + 144) = v12;
  uint64_t v14 = *(long long **)(a1 + 192);
  if (v14) {
    sub_1B64A0A70(a2, v14, a3, a4, a5, a6, a7, a8);
  }
  sub_1B64A0B4C(a2, *(float *)(a1 + 204), (uint64_t)v14, a3, a4, a5, a6, a7, a8);
  sub_1B64A0CE8(a2, *(unsigned __int8 *)(a1 + 200), v15, v16, v17, v18, v19, v20);
  uint64_t v27 = *(void **)(a1 + 240);
  if (v27) {
    sub_1B64A0D6C((float32x4_t *)a2, v27, v21, v22, v23, v24, v25, v26);
  }
  sub_1B6583A28(a1, (CFTypeRef *)a2, v21, v22, v23, v24, v25, v26);
  unsigned int v28 = *(_DWORD *)(a2 + 220) & 0xFFFFFBFF | (((*(_DWORD *)(a1 + 220) >> 10) & 1) << 10);
  *(_DWORD *)(a2 + 220) = v28;
  unsigned int v29 = v28 & 0xFFFF7FFF | (((*(_DWORD *)(a1 + 220) >> 15) & 1) << 15);
  *(_DWORD *)(a2 + 220) = v29;
  unsigned int v30 = v29 & 0xFFFFDFFF | (((*(_DWORD *)(a1 + 220) >> 13) & 1) << 13);
  *(_DWORD *)(a2 + 220) = v30;
  unsigned int v31 = v30 & 0xFFFFEFFF | (((*(_DWORD *)(a1 + 220) >> 12) & 1) << 12);
  *(_DWORD *)(a2 + 220) = v31;
  unsigned int v32 = v31 & 0xFFFFFDFF | (((*(_DWORD *)(a1 + 220) >> 9) & 1) << 9);
  *(_DWORD *)(a2 + 220) = v32;
  uint64_t v33 = *(void **)(a1 + 248);
  if (v33)
  {
    uint64_t v33 = (void *)sub_1B65E199C(v33, a2);
    unsigned int v32 = *(_DWORD *)(a2 + 220);
  }
  *(void *)(a2 + 248) = v33;
  unsigned int v34 = v32 & 0xFFFFF7FF | (((*(_DWORD *)(a1 + 220) >> 11) & 1) << 11);
  *(_DWORD *)(a2 + 220) = v34;
  long long v35 = *(_OWORD *)(a1 + 288);
  *(_OWORD *)(a2 + 272) = *(_OWORD *)(a1 + 272);
  *(_OWORD *)(a2 + 288) = v35;
  *(_DWORD *)(a2 + 220) = v34 & 0xFFFFFFFB | (4 * ((*(_DWORD *)(a1 + 220) >> 2) & 1));
  *(void *)(a2 + 208) = *(void *)(a1 + 208);
  return a2;
}

BOOL sub_1B64A0A1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(void *)(a1 + 192) != 0;
}

uint64_t sub_1B64A0A70(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  long long v10 = *(_OWORD **)(a1 + 192);
  if (!v10)
  {
    long long v10 = sub_1B63CA51C(0x80uLL);
    *(void *)(a1 + 192) = v10;
  }
  long long v11 = *a2;
  long long v12 = a2[1];
  long long v13 = a2[3];
  v10[2] = a2[2];
  v10[3] = v13;
  *long long v10 = v11;
  v10[1] = v12;
  uint64_t v14 = *(void *)(a1 + 192);
  if (v14) {
    *(_DWORD *)(v14 + 124) = 0;
  }

  return sub_1B64A2394(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64A0B00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(void *)(a1 + 192);
}

void sub_1B64A0B4C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"node");
  }
  float v11 = *(float *)(a1 + 204);
  if (v11 != a2)
  {
    if (a2 >= 1.0 && v11 < 1.0)
    {
      *(float *)(a1 + 204) = a2;
      sub_1B64A2FEC(a1, 1, a4, a5, a6, a7, a8, a9);
    }
    else
    {
      if (a2 >= 1.0)
      {
        *(float *)(a1 + 204) = a2;
        sub_1B64A2FEC(a1, 0, a4, a5, a6, a7, a8, a9);
        goto LABEL_14;
      }
      *(float *)(a1 + 204) = a2;
      sub_1B64A2FEC(a1, v11 >= 1.0, a4, a5, a6, a7, a8, a9);
      if (v11 < 1.0) {
        goto LABEL_14;
      }
    }
    uint64_t v19 = *(void *)(a1 + 48);
    sub_1B64B1F18(v19, 4, (const void *)a1, 0, v15, v16, v17, v18);
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 0x40000000;
    v20[2] = sub_1B64A6710;
    v20[3] = &unk_1E6142C70;
    v20[4] = v19;
    sub_1B64A18A4(a1, (uint64_t)v20);
LABEL_14:
    if (a2 == 0.0 || v11 == 0.0) {
      sub_1B64A30B4(a1, 1, v13, v14, v15, v16, v17, v18);
    }
  }
}

float sub_1B64A0C9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(float *)(a1 + 204);
}

void sub_1B64A0CE8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (*(unsigned __int8 *)(a1 + 200) != a2)
  {
    *(unsigned char *)(a1 + 200) = a2;
    sub_1B64A32D4(a1, a2 ^ 1u, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B64A0D6C(float32x4_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"node");
  }
  uint64_t v16 = (void *)a1[15].i64[0];
  if (!v16)
  {
    if (!a2) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  sub_1B63CE7AC(a1[15].i64[0], a1, a3, a4, a5, a6, a7, a8);
  sub_1B63F4AAC(v16, a1[3].i64[0], v17, v18, v19, v20, v21, v22);
  uint64_t v23 = (const void *)a1[15].i64[0];
  if (v23 == a2) {
    goto LABEL_12;
  }
  if (v23)
  {
    CFRelease(v23);
    a1[15].i64[0] = 0;
  }
  if (a2)
  {
LABEL_10:
    CFTypeRef v24 = CFRetain(a2);
    goto LABEL_11;
  }
  CFTypeRef v24 = 0;
LABEL_11:
  a1[15].i64[0] = (uint64_t)v24;
LABEL_12:
  if (a2) {
    sub_1B63CE674((uint64_t)a2, a1, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v25 = a1[3].i64[0];
  if (v25) {
    sub_1B6595A0C(@"kCFXNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"model", 1u);
  }
  if (!a2) {
    goto LABEL_21;
  }
  uint64_t v26 = a1[3].i64[0];
  if (v26) {
    sub_1B63F4CCC((uint64_t *)a2, v26, a3, a4, a5, a6, a7, a8);
  }
  CFTypeID v27 = CFGetTypeID(a2);
  if (v27 == sub_1B651930C())
  {
    int v28 = 4096;
  }
  else
  {
LABEL_21:
    int v28 = 0;
    int v29 = 0;
    __int32 v30 = a1[13].i32[3];
    if ((v30 & 0x1000) == 0) {
      goto LABEL_23;
    }
  }
  sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", (const void *)a1[3].i64[0], 0, 1u);
  __int32 v30 = a1[13].i32[3];
  int v29 = v28;
LABEL_23:
  a1[13].i32[3] = v30 & 0xFFFFEFFF | v29;
  unsigned int v31 = (void *)a1[15].i64[1];
  if (v31) {
    sub_1B65E1C08(v31, a2, a3, a4, a5, a6, a7, a8);
  }
  sub_1B649F7F4((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  sub_1B649F73C(a1, v32, v33, v34, v35, v36, v37, v38);
  sub_1B64A30B4((uint64_t)a1, 0, v39, v40, v41, v42, v43, v44);
  CFNumberRef v51 = a1;
  do
  {
    v51[13].i32[3] |= 2u;
    CFNumberRef v51 = (float32x4_t *)v51[4].i64[0];
  }
  while (v51);
  if (v25)
  {
    sub_1B649F3EC((uint64_t)a1, v25, v45, v46, v47, v48, v49, v50);
  }
}

uint64_t sub_1B64A0F4C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v10 = sub_1B64A0828();
  sub_1B64A08D4(a1, v10, v11, v12, v13, v14, v15, v16);
  if (a2)
  {
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 0x40000000;
    uint64_t v20 = sub_1B64A1028;
    uint64_t v21 = &unk_1E6142B10;
    char v23 = a2;
    uint64_t v22 = v10;
    for (uint64_t i = *(void *)(a1 + 72); i; uint64_t i = *(void *)(i + 80))
      v20((uint64_t)v19, i);
  }
  return v10;
}

void sub_1B64A1028(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const void *)sub_1B64A0F4C(a2, *(unsigned __int8 *)(a1 + 40));
  sub_1B64A107C(*(void *)(a1 + 32), v3, v4, v5, v6, v7, v8, v9);

  CFRelease(v3);
}

uint64_t sub_1B64A107C(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (cf)
  {
    uint64_t v10 = *(void *)(a1 + 72);
    if (!v10)
    {
      *(void *)(a1 + 72) = CFRetain(cf);
      goto LABEL_8;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"child");
    uint64_t v10 = *(void *)(a1 + 72);
    if (!v10) {
      goto LABEL_8;
    }
  }
  do
  {
    uint64_t v11 = v10;
    uint64_t v10 = *(void *)(v10 + 80);
  }
  while (v10);
  if (cf) {
    *(void *)(v11 + 80) = CFRetain(cf);
  }
LABEL_8:

  return sub_1B64A1A6C(a1, (uint64_t)cf, a3, a4, a5, a6, a7, a8);
}

__n128 *sub_1B64A1124(const void *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v8 = a3;
  uint64_t v10 = sub_1B63CDB74(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = (__n128 *)v10;
  if (a2)
  {
    uint64_t v19 = sub_1B63CCE68(v10, v11, v12, v13, v14, v15, v16, v17);
    sub_1B64AD458(v19, a2, v20, v21, v22, v23, v24, v25);
  }
  int v26 = sub_1B647F580((uint64_t)v18);
  sub_1B647F588((uint64_t)v18, v26 & 0xFFFFFF00);
  sub_1B647F3D0(v18, v8, v27, v28, v29, v30, v31, v32);
  CFTypeRef v33 = sub_1B653976C((uint64_t)v18);
  CFRetain(v33);
  sub_1B647F3D0(v18, 0, v34, v35, v36, v37, v38, v39);
  sub_1B63CDBD0((uint64_t)v18, (uint64_t)v33, v40, v41, v42, v43, v44, v45);
  CFRelease(v33);
  return v18;
}

float32x4_t *sub_1B64A11C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. need subdivision level", a3, a4, a5, a6, a7, a8, (uint64_t)"subdivisionLevel > 0");
  }
  uint64_t v17 = (float32x4_t *)sub_1B64A0F4C(a1, 0, a3, a4, a5, a6, a7, a8);
  if (!v17) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v11, v12, v13, v14, v15, v16, (uint64_t)"node");
  }
  uint64_t v18 = (const void *)v17[15].i64[0];
  if (v18)
  {
    uint64_t v19 = sub_1B64A14EC(a1, v10, v11, v12, v13, v14, v15, v16);
    uint64_t v24 = sub_1B64A1124(v18, 0, a2, 0, v20, v21, v22, v23);
    sub_1B64A0D6C(v17, v24, v25, v26, v27, v28, v29, v30);
    CFRelease(v24);
    uint64_t v38 = sub_1B63CCE68((uint64_t)v18, v31, v32, v33, v34, v35, v36, v37);
    uint64_t v45 = sub_1B64AD3C4(v38, 0, v39, v40, v41, v42, v43, v44);
    if (v19)
    {
      uint64_t v53 = (const void *)v45;
      uint64_t v149 = v19;
      CFNumberRef v54 = sub_1B6588C30(v19, v46, v47, v48, v49, v50, v51, v52);
      sub_1B6588E6C((uint64_t)v54, v24, v55, v56, v57, v58, v59, v60);
      v147 = (uint64_t *)v54;
      uint64_t v61 = sub_1B63CD09C((uint64_t)v54);
      if (sub_1B65880A4(v61, v62, v63, v64, v65, v66, v67, v68)) {
        sub_1B6587ACC(v61, v38, 0, 0, v69, v70, v71, v72);
      }
      if (sub_1B65873F4(v61)) {
        sub_1B6587E98(v61, v38, 0, 0, v73, v74, v75, v76, v146);
      }
      uint64_t v148 = v38;
      CFArrayRef v77 = (const __CFArray *)sub_1B63CD09C(v61);
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      CFIndex Count = CFArrayGetCount(v77);
      if (Count >= 1)
      {
        CFIndex v85 = Count;
        for (CFIndex i = 0; i != v85; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v77, i);
          v92 = sub_1B64A1124(ValueAtIndex, v53, a2, 0, v88, v89, v90, v91);
          CFArrayAppendValue(Mutable, v92);
          CFRelease(v92);
        }
      }
      sub_1B65870C8(v61, Mutable, 0, v80, v81, v82, v83, v84);
      sub_1B64A155C(v17, v147, v93, v94, v95, v96, v97, v98);
      CFRelease(v147);
      uint64_t v38 = v148;
      uint64_t v19 = v149;
    }
    uint64_t v99 = *(void *)(a1 + 248);
    if (v99)
    {
      uint64_t v100 = sub_1B65E1E14(v99, v46, v47, v48, v49, v50, v51, v52);
      if (v100)
      {
        uint64_t v101 = v100;
        uint64_t v102 = sub_1B63CD09C(v100);
        uint64_t v110 = sub_1B64AB2A8(v38, v103, v104, v105, v106, v107, v108, v109);
        CFNumberRef v111 = (__n128 *)-[VFXModel __createCFObject]_0();
        sub_1B63CDBD0((uint64_t)v111, v110, v112, v113, v114, v115, v116, v117);
        if (v19)
        {
          int v124 = sub_1B647F580((uint64_t)v111);
          sub_1B647F588((uint64_t)v111, v124 & 0xFFFFFF00);
        }
        sub_1B647F3D0(v111, a2, v118, v119, v120, v121, v122, v123);
        CFTypeRef v125 = sub_1B653976C((uint64_t)v111);
        CFArrayRef v126 = (const __CFArray *)sub_1B6451F14(v101);
        CFArrayRef v127 = v126;
        if (v126) {
          LOWORD(v126) = CFArrayGetCount(v126);
        }
        v128 = (void *)sub_1B6530ED0((uint64_t)v125, (__int16)v126);
        CFRelease(v111);
        if (v128)
        {
          v129 = (__n128 *)sub_1B653166C(v102);
          sub_1B6531660((uint64_t)v128, *v129, v129[1], v129[2], v129[3]);
          v130 = (void *)sub_1B6451F14(v102);
          sub_1B65312C0((uint64_t)v128, v130, v131, v132, v133, v134, v135, v136);
          v137 = (uint64_t *)sub_1B6524738(v128);
          CFRelease(v128);
          if (v127)
          {
            CFArrayRef Copy = CFArrayCreateCopy(0, v127);
            sub_1B65248F4((uint64_t)v137, Copy);
            CFRelease(Copy);
          }
          sub_1B64A16B0(v17, v137, v138, v139, v140, v141, v142, v143);
          CFRelease(v137);
        }
      }
    }
  }
  return v17;
}

uint64_t sub_1B64A14EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t result = *(void *)(a1 + 248);
  if (result)
  {
    return sub_1B65E1CD8(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

void sub_1B64A155C(float32x4_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v10 = sub_1B64A14EC((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t *)v10 != a2)
  {
    uint64_t v18 = (void *)v10;
    if (v10)
    {
      uint64_t v19 = sub_1B63F4F08((uint64_t)a1, v11, v12, v13, v14, v15, v16, v17);
      sub_1B63F4AAC(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    if (a2)
    {
      uint64_t v26 = a1[3].i64[0];
      if (v26) {
        sub_1B63F4CCC(a2, v26, v12, v13, v14, v15, v16, v17);
      }
      uint64_t v28 = (CFTypeRef *)&a1[15].i64[1];
      uint64_t v27 = (void *)a1[15].i64[1];
      if (!v27)
      {
        uint64_t v27 = (void *)sub_1B65E18F8((uint64_t)a1);
        a1[15].i64[1] = (uint64_t)v27;
        if (!v27) {
          goto LABEL_17;
        }
      }
    }
    else
    {
      uint64_t v28 = (CFTypeRef *)&a1[15].i64[1];
      uint64_t v27 = (void *)a1[15].i64[1];
      if (!v27)
      {
LABEL_17:
        if (sub_1B63F4F08((uint64_t)a1, v11, v12, v13, v14, v15, v16, v17)) {
          sub_1B6595A0C(@"kCFXNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"kDeformerStackKey", 1u);
        }
        sub_1B649F6C4(a1, v36, v37, v38, v39, v40, v41, v42);
        return;
      }
    }
    sub_1B65E1D24((uint64_t)v27, a2, v12, v13, v14, v15, v16, v17);
    if (sub_1B65E1ACC(v27, v29, v30, v31, v32, v33, v34, v35) && *v28)
    {
      CFRelease(*v28);
      CFTypeRef *v28 = 0;
    }
    goto LABEL_17;
  }
}

uint64_t sub_1B64A16A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(a1 + 248);
  if (result) {
    return sub_1B65E1E14(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

void sub_1B64A16B0(float32x4_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v10 = a1[15].i64[1];
  if (!v10)
  {
    if (!a2) {
      return;
    }
LABEL_11:
    uint64_t v28 = a1[3].i64[0];
    if (v28) {
      sub_1B63F4CCC(a2, v28, a3, a4, a5, a6, a7, a8);
    }
    sub_1B6524A8C((uint64_t)a2, (uint64_t)a1, a3, a4, a5, a6, a7, a8);
    uint64_t v27 = (void *)a1[15].i64[1];
    if (!v27)
    {
      uint64_t v27 = (void *)sub_1B65E18F8((uint64_t)a1);
      a1[15].i64[1] = (uint64_t)v27;
      if (!v27) {
        goto LABEL_18;
      }
    }
    goto LABEL_15;
  }
  uint64_t v11 = sub_1B65E1E14(v10, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t *)v11 == a2) {
    return;
  }
  uint64_t v13 = (void *)v11;
  if (v11)
  {
    uint64_t v14 = sub_1B63F4F08((uint64_t)a1, v12, a3, a4, a5, a6, a7, a8);
    sub_1B63F4AAC(v13, v14, v15, v16, v17, v18, v19, v20);
    sub_1B6524A8C((uint64_t)v13, 0, v21, v22, v23, v24, v25, v26);
  }
  if (a2) {
    goto LABEL_11;
  }
  uint64_t v27 = (void *)a1[15].i64[1];
  if (v27)
  {
LABEL_15:
    sub_1B65E1E60(v27, a2, a3, a4, a5, a6, a7, a8);
    if (sub_1B65E1ACC(v27, v29, v30, v31, v32, v33, v34, v35))
    {
      uint64_t v36 = (const void *)a1[15].i64[1];
      if (v36)
      {
        CFRelease(v36);
        a1[15].i64[1] = 0;
      }
    }
  }
LABEL_18:
  if (sub_1B63F4F08((uint64_t)a1, v12, a3, a4, a5, a6, a7, a8)) {
    sub_1B6595A0C(@"kCFXNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"kDeformerStackKey", 1u);
  }

  sub_1B649F6C4(a1, v37, v38, v39, v40, v41, v42, v43);
}

uint64_t sub_1B64A180C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (!v1) {
    return 0;
  }
  LODWORD(result) = 0;
  do
  {
    uint64_t result = (result + 1);
    uint64_t v1 = *(void *)(v1 + 80);
  }
  while (v1);
  return result;
}

BOOL sub_1B64A1830(uint64_t a1, uint64_t a2)
{
  char v6 = 0;
  uint64_t v2 = *(void *)(a1 + 72);
  if (!v2) {
    return 0;
  }
  do
  {
    (*(void (**)(uint64_t, uint64_t, char *))(a2 + 16))(a2, v2, &v6);
    uint64_t v2 = *(void *)(v2 + 80);
    BOOL result = v6 != 0;
    if (v6) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v2 == 0;
    }
  }
  while (!v5);
  return result;
}

uint64_t sub_1B64A18A4(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, result);
    if (v4 == 2) {
      return 1;
    }
    BOOL v5 = v3;
    while (1)
    {
      if (v4 == 1 || (char v6 = (void *)v5[9]) == 0)
      {
        if (v5 == v3) {
          return 0;
        }
        while (1)
        {
          char v6 = (void *)v5[10];
          if (v6) {
            break;
          }
          BOOL v5 = (void *)v5[8];
          if (v5) {
            BOOL v7 = v5 == v3;
          }
          else {
            BOOL v7 = 1;
          }
          if (v7) {
            return 0;
          }
        }
      }
      uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, v6);
      BOOL v5 = v6;
      if (v4 == 2) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_1B64A1954(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }

  return sub_1B6583470(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64A19B0(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    uint64_t v4 = result;
    do
    {
LABEL_3:
      BOOL v5 = (void *)v4;
      if (*(unsigned char *)(v4 + 200)) {
        break;
      }
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v4);
      if (v6 == 2) {
        return 1;
      }
      uint64_t v4 = v5[9];
    }
    while (v6 != 1 && v4 != 0);
    while (v5 != v3)
    {
      uint64_t v4 = v5[10];
      if (v4) {
        goto LABEL_3;
      }
      BOOL v5 = (void *)v5[8];
    }
    return 0;
  }
  return result;
}

uint64_t sub_1B64A1A44(uint64_t a1, unsigned int a2)
{
  uint64_t result = *(void *)(a1 + 72);
  if (a2 && result)
  {
    unsigned int v3 = 1;
    do
    {
      uint64_t result = *(void *)(result + 80);
      if (v3 >= a2) {
        break;
      }
      ++v3;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1B64A1A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a2 + 64) = a1;
  sub_1B64A2394(a2, a2, a3, a4, a5, a6, a7, a8);
  if (a1)
  {
    if ((*(_DWORD *)(a2 + 220) & 3) != 0)
    {
      uint64_t v16 = a1;
      do
      {
        *(_DWORD *)(v16 + 220) |= 2u;
        uint64_t v16 = *(void *)(v16 + 64);
      }
      while (v16);
      if (!a2) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"node");
      }
    }
  }
  uint64_t v17 = *(void *)(a2 + 64);
  if (v17)
  {
    unsigned int v18 = *(_DWORD *)(a2 + 220) & 0xFFFFFF7F | (((*(_DWORD *)(v17 + 220) >> 7) & 1) << 7);
    *(_DWORD *)(a2 + 220) = v18;
    unsigned int v19 = v18 & 0xFF1FFFFF | (((*(_DWORD *)(v17 + 220) >> 21) & 7) << 21);
    *(_DWORD *)(a2 + 220) = v19;
  }
  else
  {
    unsigned int v19 = *(_DWORD *)(a2 + 220);
  }
  sub_1B64A4C20(a2, (v19 >> 7) & 1, (v19 >> 21) & 7, v11, v12, v13, v14, v15);
  sub_1B64A2FEC(a2, 0, v20, v21, v22, v23, v24, v25);
  uint64_t v32 = *(void *)(a1 + 48);
  uint64_t v33 = *(void *)(a2 + 48);
  if (v32)
  {
    if (v33 != v32)
    {
      sub_1B63F4AAC((void *)a2, v33, v26, v27, v28, v29, v30, v31);
      sub_1B63F4CCC((uint64_t *)a2, *(void *)(a1 + 48), v34, v35, v36, v37, v38, v39);
    }
  }
  else
  {
    sub_1B63F4AAC((void *)a2, v33, v26, v27, v28, v29, v30, v31);
  }

  return sub_1B64A32D4(a2, 1, v26, v27, v28, v29, v30, v31);
}

uint64_t sub_1B64A1B88(uint64_t a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (cf[10]) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. child is already inserted in a tree", a3, a4, a5, a6, a7, a8, (uint64_t)"child->_nextSibling == NULL");
  }
  if (cf[8]) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. child is already inserted in a tree", a3, a4, a5, a6, a7, a8, (uint64_t)"child->_parent == NULL");
  }
  if (v8)
  {
    uint64_t v11 = *(void *)(a1 + 72);
    uint64_t v12 = (v8 - 1);
    if (v8 != 1)
    {
      do
      {
        uint64_t v11 = *(void *)(v11 + 80);
        --v12;
      }
      while (v12);
    }
    uint64_t v13 = *(void *)(v11 + 80);
    *(void *)(v11 + 80) = cf;
    CFRetain(cf);
    cf[10] = v13;
  }
  else
  {
    cf[10] = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = cf;
    CFRetain(cf);
  }

  return sub_1B64A1A6C(a1, (uint64_t)cf, v14, v15, v16, v17, v18, v19);
}

uint64_t sub_1B64A1C68(uint64_t a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (cf[8]) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. child is already inserted in a tree", a3, a4, a5, a6, a7, a8, (uint64_t)"child->_parent == NULL");
  }
  if (cf[10]) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. child is already inserted in a tree", a3, a4, a5, a6, a7, a8, (uint64_t)"child->_nextSibling == NULL");
  }
  if (a3)
  {
    if (*(void *)(a3 + 64) != a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. prevChild is not parented to the right node", a3, a4, a5, a6, a7, a8, (uint64_t)"prevSibling->_parent == node");
    }
    uint64_t v11 = *(void *)(a3 + 80);
    *(void *)(a3 + 80) = cf;
    CFRetain(cf);
    cf[10] = v11;
  }
  else
  {
    cf[10] = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = cf;
    CFRetain(cf);
  }

  return sub_1B64A1A6C(a1, (uint64_t)cf, v12, v13, v14, v15, v16, v17);
}

void sub_1B64A1D58(void *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = cf[8];
  if (v8)
  {
    uint64_t v10 = *(void **)(v8 + 72);
    if (v10 == cf)
    {
      *(void *)(v8 + 72) = cf[10];
    }
    else
    {
      if (!v10) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"prevChild");
      }
      for (CFIndex i = (void *)v10[10]; i != cf; CFIndex i = (void *)v10[10])
      {
        uint64_t v10 = i;
        if (!i) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"prevChild");
        }
      }
      v10[10] = cf[10];
    }
    cf[10] = 0;
    cf[8] = 0;
    sub_1B63F4AAC(cf, cf[6], a3, a4, a5, a6, a7, a8);
    CFRelease(cf);
  }
}

uint64_t sub_1B64A1E44(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 72);
  BOOL v3 = v2 == 0;
  BOOL v4 = v2 == 0;
  unsigned int v5 = 0;
  while (!v3 && v2 != a2)
  {
    ++v5;
    uint64_t v2 = *(void *)(v2 + 80);
    BOOL v3 = v2 == 0;
    BOOL v4 = v2 == 0;
  }
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t sub_1B64A1E7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(void *)(a1 + 64);
}

__n128 sub_1B64A1EC8(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"position");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  __n128 result = *(__n128 *)(sub_1B64A01D4(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) + 48);
  *a2 = result;
  return result;
}

float32x4_t sub_1B64A1F4C(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"orientation");
LABEL_3:
  uint64_t v10 = sub_1B64A01D4(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  float32x4_t v11 = *(float32x4_t *)(v10 + 16);
  float32x4_t v12 = *(float32x4_t *)(v10 + 32);
  int32x4_t v13 = (int32x4_t)vmulq_f32(*(float32x4_t *)v10, *(float32x4_t *)v10);
  int32x4_t v14 = (int32x4_t)vmulq_f32(v11, v11);
  int32x4_t v15 = (int32x4_t)vmulq_f32(v12, v12);
  int32x4_t v16 = vzip2q_s32(v13, v15);
  float32x4_t v17 = (float32x4_t)vzip1q_s32(vzip1q_s32(v13, v15), v14);
  float32x4_t v18 = (float32x4_t)vtrn2q_s32(v13, v14);
  v18.i32[2] = v15.i32[1];
  float32x4_t v19 = vaddq_f32((float32x4_t)vzip1q_s32(v16, vdupq_laneq_s32(v14, 2)), vaddq_f32(v17, v18));
  v18.i64[0] = 0x80000000800000;
  v18.i64[1] = 0x80000000800000;
  int8x16_t v20 = (int8x16_t)vcgeq_f32(v18, v19);
  v19.i32[3] = 0;
  float32x4_t v21 = vrsqrteq_f32(v19);
  float32x4_t v22 = vmulq_f32(v21, vrsqrtsq_f32(v19, vmulq_f32(v21, v21)));
  int32x4_t v23 = (int32x4_t)v20;
  v23.i32[3] = 0;
  float32x4_t v24 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v23), (int8x16_t)v19, (int8x16_t)vmulq_f32(v22, vrsqrtsq_f32(v19, vmulq_f32(v22, v22))));
  float32x4_t v25 = vmulq_n_f32(*(float32x4_t *)v10, v24.f32[0]);
  float32x4_t v26 = vmulq_lane_f32(v11, *(float32x2_t *)v24.f32, 1);
  float32x4_t v27 = vmulq_laneq_f32(v12, v24, 2);
  int8x16_t v28 = (int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27);
  int8x16_t v29 = (int8x16_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v26);
  int32x4_t v30 = (int32x4_t)v25;
  if (v20.i32[0])
  {
    int8x16_t v31 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v28, (int8x16_t)v27, 0xCuLL), vnegq_f32(v26)), v27, (float32x4_t)vextq_s8(v29, (int8x16_t)v26, 0xCuLL));
    int32x4_t v30 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), v31, 0xCuLL);
  }
  int8x16_t v32 = (int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25);
  float32x4_t v33 = v26;
  if (v20.i32[1])
  {
    int8x16_t v34 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v32, (int8x16_t)v25, 0xCuLL), vnegq_f32(v27)), v25, (float32x4_t)vextq_s8(v28, (int8x16_t)v27, 0xCuLL));
    float32x4_t v33 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), v34, 0xCuLL);
  }
  if (v20.i32[2])
  {
    int8x16_t v20 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v29, (int8x16_t)v26, 0xCuLL), vnegq_f32(v25)), v26, (float32x4_t)vextq_s8(v32, (int8x16_t)v25, 0xCuLL));
    float32x4_t v27 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), v20, 0xCuLL);
  }
  float v35 = (float)(*(float *)v30.i32 + v33.f32[1]) + v27.f32[2];
  if (v35 > 0.0)
  {
    float32x4_t v36 = (float32x4_t)vzip2q_s32((int32x4_t)v33, vuzp1q_s32((int32x4_t)v33, (int32x4_t)v27));
    v36.i32[2] = v30.i32[1];
    float v37 = sqrtf(v35 + 1.0);
    float32x4_t v38 = (float32x4_t)vtrn2q_s32((int32x4_t)v27, vzip2q_s32((int32x4_t)v27, v30));
    v38.i32[2] = v33.i32[0];
    float32x4_t v40 = vsubq_f32(v36, v38);
    v36.f32[3] = v37;
    v38.f32[3] = v37;
    float32x4_t v39 = vmulq_f32(v36, v38);
    v40.i32[3] = v39.i32[3];
LABEL_22:
    v39.f32[0] = 0.5 / v37;
    float32x4_t v50 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0);
    goto LABEL_23;
  }
  if (*(float *)v30.i32 < v33.f32[1] || *(float *)v30.i32 < v27.f32[2])
  {
    if (v33.f32[1] <= v27.f32[2])
    {
      float v37 = sqrtf((float)((float)(v27.f32[2] + 1.0) - *(float *)v30.i32) - v33.f32[1]);
      *(float32x2_t *)v40.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v30, (int32x4_t)v33), *(float32x2_t *)v27.f32);
      float32x2_t v51 = (float32x2_t)__PAIR64__(v30.u32[1], LODWORD(v37));
      float32x2_t v52 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.f32, 0);
      *(float32x2_t *)v39.f32 = vsub_f32(*(float32x2_t *)v30.i8, v52);
      v52.f32[0] = v37;
      v52.i32[0] = vmul_f32(v51, v52).u32[0];
      v52.i32[1] = v39.i32[1];
      *(float32x2_t *)&v40.u32[2] = v52;
      goto LABEL_22;
    }
    float v44 = sqrtf((float)((float)(v33.f32[1] + 1.0) - *(float *)v30.i32) - v27.f32[2]);
    *(int32x2_t *)v20.i8 = vdup_laneq_s32((int32x4_t)v33, 2);
    int8x16_t v42 = v20;
    *(float *)v42.i32 = v44;
    v42.i32[0] = vmul_f32(*(float32x2_t *)v42.i8, (float32x2_t)__PAIR64__(v27.u32[1], LODWORD(v44))).u32[0];
    v42.i32[1] = vadd_f32(*(float32x2_t *)&v20, *(float32x2_t *)&v27).i32[1];
    int8x16_t v43 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.i8, 1), v33);
    int32x2_t v49 = (int32x2_t)vsubq_f32(v27, (float32x4_t)vdupq_laneq_s32(v30, 2)).u64[0];
    float32x4_t v50 = (float32x4_t)vextq_s8(vextq_s8(v43, v43, 4uLL), v42, 0xCuLL);
    v50.i32[3] = v49.i32[0];
  }
  else
  {
    float v44 = sqrtf((float)((float)(*(float *)v30.i32 + 1.0) - v33.f32[1]) - v27.f32[2]);
    float32x2_t v45 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.f32, 0);
    float32x2_t v46 = vadd_f32(*(float32x2_t *)v30.i8, v45);
    v45.f32[0] = v44;
    v50.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v30.u32[1], LODWORD(v44)), v45).u32[0];
    v50.i32[1] = v46.i32[1];
    float32x2_t v47 = (float32x2_t)vzip2q_s32(v30, (int32x4_t)v33).u64[0];
    LODWORD(v48) = vadd_f32(v47, *(float32x2_t *)v27.f32).u32[0];
    int32x2_t v49 = (int32x2_t)vsub_f32(v47, *(float32x2_t *)v27.f32);
    HIDWORD(v48) = v49.i32[1];
    v50.i64[1] = v48;
  }
  *(float *)v49.i32 = 0.5 / v44;
  float32x4_t v40 = (float32x4_t)vdupq_lane_s32(v49, 0);
LABEL_23:
  float32x4_t result = vmulq_f32(v40, v50);
  *a2 = result;
  return result;
}

double sub_1B64A2220(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  simd_float4x4 v8 = *(simd_float4x4 *)sub_1B64A01D4(a1, a2, a3, a4, a5, a6, a7, a8);

  *(void *)&double result = (unint64_t)__invert_f4(v8);
  return result;
}

uint64_t sub_1B64A2250(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9)
  {
    uint64_t v16 = sub_1B64B29E0(v9, a2, a3, a4, a5, a6, a7, a8);
    int v17 = *(_DWORD *)(a1 + 88);
    if (v17 == -1)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Node should have a TT handle already", v10, v11, v12, v13, v14, v15, (uint64_t)"node->_transformHandle != kCFXTransformHandleInvalid");
      int v17 = *(_DWORD *)(a1 + 88);
    }
    return sub_1B6510114(v16, v17, v10, v11, v12, v13, v14, v15);
  }
  else
  {
    return sub_1B6454F20(a1 + 96, a2, a3, a4, a5, a6, a7, a8);
  }
}

double sub_1B64A230C(__n128 *a1)
{
  *(void *)&double result = sub_1B64556B4(a1 + 6).n128_u64[0];
  return result;
}

void sub_1B64A2314(__n128 *a1, float32x4_t a2)
{
  BOOL v3 = a1 + 6;
  uint32x4_t v4 = (uint32x4_t)vceqq_f32((float32x4_t)sub_1B64556B4(a1 + 6), a2);
  v4.i32[3] = v4.i32[2];
  if ((vminvq_u32(v4) & 0x80000000) == 0)
  {
    sub_1B64556BC(v3, (__n128)a2);
    sub_1B64A2394((uint64_t)a1, v5, v6, v7, v8, v9, v10, v11);
  }
}

uint64_t sub_1B64A2394(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(result + 48);
  if (v8)
  {
    uint64_t v9 = result;
    uint64_t v10 = sub_1B64B29E0(*(void *)(result + 48), a2, a3, a4, a5, a6, a7, a8);
    if (v10 && *(_DWORD *)(v9 + 88) != -1)
    {
      uint64_t v18 = v10;
      *(double *)&long long v19 = sub_1B649FE9C(v9, v11, v12, v13, v14, v15, v16, v17);
      v38[0] = v19;
      v38[1] = v20;
      v38[2] = v21;
      v38[3] = v22;
      sub_1B650FDCC(v18, *(_DWORD *)(v9 + 88), v38, v23, v24, v25, v26, v27);
    }
    uint64_t v28 = sub_1B64B28FC(v8, v11, v12, v13, v14, v15, v16, v17);
    if (v28) {
      sub_1B66267CC(v28, v9, v30, v31, v32, v33, v34, v35);
    }
    uint64_t v36 = sub_1B64B2864(v8, v29, v30, v31, v32, v33, v34, v35);
    v37[0] = MEMORY[0x1E4F143A8];
    v37[1] = 0x40000000;
    v37[2] = sub_1B64A6640;
    v37[3] = &unk_1E6142C08;
    v37[4] = v36;
    return sub_1B64A18A4(v9, (uint64_t)v37);
  }
  return result;
}

double sub_1B64A2478(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&double result = sub_1B64556CC(a1 + 96, a2, a3, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

void sub_1B64A2480(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9)
{
  uint64_t v10 = (float32x4_t *)(a1 + 96);
  uint32x4_t v18 = (uint32x4_t)vceqq_f32((float32x4_t)sub_1B64556CC(a1 + 96, a2, a3, a4, a5, a6, a7, a8), a9);
  v18.i32[3] = v18.i32[2];
  if ((vminvq_u32(v18) & 0x80000000) == 0)
  {
    sub_1B6455700(v10, (__n128)a9, v11, v12, v13, v14, v15, v16, v17);
    sub_1B64A2394(a1, v19, v20, v21, v22, v23, v24, v25);
  }
}

double sub_1B64A2500(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B6454F54(a1 + 6, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B64A2508(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B64A2510(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  sub_1B645565C(a1 + 96, a2, a3, a4, a5, a6, a7, a8, a9);

  return sub_1B64A2394(a1, v10, v11, v12, v13, v14, v15, v16);
}

double sub_1B64A254C(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&double result = sub_1B64554E4(a1 + 6, a2, a3, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

uint64_t sub_1B64A2554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  sub_1B6455570(a1 + 96, a2, a3, a4, a5, a6, a7, a8, a9);

  return sub_1B64A2394(a1, v10, v11, v12, v13, v14, v15, v16);
}

void sub_1B64A2590(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  uint64_t v10 = (uint64_t)&a1[6];
  *(double *)v18.i64 = sub_1B6454F54(a1 + 6, a2, a3, a4, a5, a6, a7, a8);
  if ((vminvq_u32((uint32x4_t)vceqq_f32(v18, (float32x4_t)a9)) & 0x80000000) == 0)
  {
    sub_1B64553BC(v10, v11, v12, v13, v14, v15, v16, v17, a9);
    sub_1B64A2394((uint64_t)a1, v19, v20, v21, v22, v23, v24, v25);
  }
}

uint64_t sub_1B64A260C(uint64_t a1)
{
  return a1 + 96;
}

uint64_t sub_1B64A2614(uint64_t a1, uint64_t a2)
{
  sub_1B6454C68(a1 + 96, a2);

  return sub_1B64A2394(a1, v3, v4, v5, v6, v7, v8, v9);
}

double sub_1B64A2650(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }

  *(void *)&double result = sub_1B6454C84((unsigned char *)(a1 + 96), a2, a3, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

double sub_1B64A26AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v9 = *(void *)(a1 + 192);
  if (v9) {
    long long v10 = *(_OWORD *)(v9 + 48);
  }
  else {
    *(void *)&long long v10 = 0;
  }
  return *(double *)&v10;
}

uint64_t sub_1B64A2708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (!a1)
  {
    __n128 v13 = a9;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    a9 = v13;
  }
  long long v10 = *(__n128 **)(a1 + 192);
  if (v10)
  {
    a9.n128_u32[3] = v10[3].n128_u32[3];
    v10[3] = a9;
  }
  else
  {
    a9.n128_u32[3] = 1.0;
    v14[0] = xmmword_1B6E4F300;
    v14[1] = xmmword_1B6E4F320;
    v14[2] = xmmword_1B6E4F2E0;
    v14[3] = (__int128)a9;
    sub_1B64A0A70(a1, v14, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v11 = *(void *)(a1 + 192);
  if (v11) {
    *(_DWORD *)(v11 + 124) = 0;
  }

  return sub_1B64A2394(a1, a2, a3, a4, a5, a6, a7, a8);
}

__n128 sub_1B64A27C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"m");
  }
  uint64_t v10 = sub_1B64A01D4(a1, a2, a3, a4, a5, a6, a7, a8);
  __n128 result = *(__n128 *)(v10 + 32);
  long long v12 = *(_OWORD *)(v10 + 48);
  long long v14 = *(_OWORD *)v10;
  long long v13 = *(_OWORD *)(v10 + 16);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v12;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v13;
  return result;
}

__n128 sub_1B64A2828(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"m");
  }
  if (*(_DWORD *)(a1 + 88) == -1)
  {
    uint64_t v20 = sub_1B64A01D4(a1, a2, a3, a4, a5, a6, a7, a8);
    __n128 result = *(__n128 *)(v20 + 32);
    long long v21 = *(_OWORD *)(v20 + 48);
    long long v23 = *(_OWORD *)v20;
    long long v22 = *(_OWORD *)(v20 + 16);
    *(__n128 *)(a2 + 32) = result;
    *(_OWORD *)(a2 + 48) = v21;
    *(_OWORD *)a2 = v23;
    *(_OWORD *)(a2 + 16) = v22;
  }
  else
  {
    result.n128_f64[0] = sub_1B649FE9C(a1, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v14 = *(void *)(a1 + 64);
    if (v14)
    {
      float32x4_t v30 = 0u;
      float32x4_t v31 = 0u;
      float32x4_t v28 = 0u;
      float32x4_t v29 = 0u;
      __n128 v24 = result;
      long long v25 = v11;
      long long v26 = v12;
      long long v27 = v13;
      sub_1B64A2828(v14, &v28);
      uint64_t v15 = 0;
      float32x4_t v16 = v28;
      float32x4_t v17 = v29;
      float32x4_t v18 = v30;
      float32x4_t v19 = v31;
      v32[0] = v24;
      v32[1] = v25;
      v32[2] = v26;
      v32[3] = v27;
      __n128 v33 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      do
      {
        *(float32x4_t *)((char *)&v33 + v15 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v16, COERCE_FLOAT(v32[v15])), v17, *(float32x2_t *)&v32[v15], 1), v18, (float32x4_t)v32[v15], 2), v19, (float32x4_t)v32[v15], 3);
        ++v15;
      }
      while (v15 != 4);
      __n128 result = v33;
      long long v11 = v34;
      long long v12 = v35;
      long long v13 = v36;
    }
    *(__n128 *)a2 = result;
    *(_OWORD *)(a2 + 16) = v11;
    *(_OWORD *)(a2 + 32) = v12;
    *(_OWORD *)(a2 + 48) = v13;
  }
  return result;
}

uint64_t sub_1B64A293C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"root");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"name");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  v12[2] = sub_1B64A2A34;
  v12[3] = &unk_1E6142B38;
  v12[4] = &v13;
  v12[5] = a2;
  sub_1B64A18A4(a1, (uint64_t)v12);
  uint64_t v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

uint64_t sub_1B64A2A34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B64A1954(a2, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if (CFEqual((CFTypeRef)result, *(CFTypeRef *)(a1 + 40)))
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
      return 2;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFMutableArrayRef sub_1B64A2A88(uint64_t a1, __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a3;
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"root");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"attributeName");
LABEL_3:
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v12 = Mutable;
  if (@"model" == a2)
  {
    uint64_t v13 = v19;
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 0x40000000;
    void v19[2] = sub_1B64A2C48;
    v19[3] = &unk_1E6142B58;
    v19[4] = Mutable;
LABEL_10:
    uint64_t v14 = v13 + 5;
    goto LABEL_11;
  }
  if (@"kDeformerStackKey" == a2)
  {
    uint64_t v13 = v18;
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    v18[2] = sub_1B64A2CBC;
    v18[3] = &unk_1E6142B78;
    v18[4] = Mutable;
    goto LABEL_10;
  }
  uint64_t v13 = v16;
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 0x40000000;
  v16[2] = sub_1B64A2D30;
  v16[3] = &unk_1E6142B98;
  v16[4] = a2;
  v16[5] = Mutable;
  uint64_t v14 = &v17;
LABEL_11:
  *(unsigned char *)uint64_t v14 = v8;
  sub_1B64A18A4(a1, (uint64_t)v13);
  return v12;
}

uint64_t sub_1B64A2C48(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!value) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (value[30] && (CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), value), *(unsigned char *)(a1 + 40))) {
    return 2;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B64A2CBC(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!value) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (value[31] && (CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), value), *(unsigned char *)(a1 + 40))) {
    return 2;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B64A2D30(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B658391C((uint64_t)a2, *(void **)(a1 + 32), a3, a4, a5, a6, a7, a8)
    && (CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), a2), *(unsigned char *)(a1 + 48)))
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

__CFArray *sub_1B64A2D84(void *a1, uint64_t a2, int a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  sub_1B64A2DEC(a1, a2, a3, Mutable);
  return Mutable;
}

BOOL sub_1B64A2DEC(void *a1, uint64_t a2, int a3, __CFArray *a4)
{
  unsigned __int8 v19 = 1;
  if ((*(unsigned int (**)(uint64_t, void *, unsigned __int8 *))(a2 + 16))(a2, a1, &v19)) {
    CFArrayAppendValue(a4, a1);
  }
  int v8 = v19;
  if (v19) {
    BOOL v9 = a3 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    uint64_t v14 = sub_1B64A6674;
    uint64_t v15 = &unk_1E6142C30;
    char v18 = a3;
    uint64_t v16 = a2;
    uint64_t v17 = a4;
    char v20 = 0;
    uint64_t v10 = a1[9];
    if (v10)
    {
      do
      {
        v14((uint64_t)v13, v10, &v20);
        uint64_t v10 = *(void *)(v10 + 80);
        if (v20) {
          BOOL v11 = 1;
        }
        else {
          BOOL v11 = v10 == 0;
        }
      }
      while (!v11);
      int v8 = v19;
    }
    else
    {
      int v8 = 1;
    }
  }
  return v8 != 0;
}

CFStringRef sub_1B64A2F04(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }

  return sub_1B65834BC(a1, theString, a3, a4, a5, a6, a7, a8);
}

void sub_1B64A2F68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  int v9 = *(_DWORD *)(a1 + 220);
  if ((v9 & 0x20) != 0)
  {
    *(_DWORD *)(a1 + 256) = *(_DWORD *)(a1 + 204);
    if (*(void *)(a1 + 64))
    {
      *(float *)(a1 + 256) = sub_1B64A2F68() * *(float *)(a1 + 256);
      int v9 = *(_DWORD *)(a1 + 220);
    }
    *(_DWORD *)(a1 + 220) = v9 & 0xFFFFFFDF;
  }
}

void sub_1B64A2FEC(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  int v10 = *(_DWORD *)(a1 + 220);
  if (*(void *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 220) = v10 & 0xFFFFFFDF;
    uint64_t v11 = *(void *)(a1 + 48);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    v12[2] = sub_1B64A66B4;
    v12[3] = &unk_1E6142C50;
    char v13 = a2;
    v12[4] = v11;
    sub_1B64A18A4(a1, (uint64_t)v12);
  }
  else
  {
    *(_DWORD *)(a1 + 220) = v10 | 0x20;
  }
}

uint64_t sub_1B64A30B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    int v10 = a2;
    uint64_t result = sub_1B64B2994(result, a2, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      if (v10)
      {
        v18[0] = MEMORY[0x1E4F143A8];
        v18[1] = 0x40000000;
        v18[2] = sub_1B64A6754;
        v18[3] = &unk_1E6142C90;
        v18[4] = result;
        return sub_1B64A18A4(a1, (uint64_t)v18);
      }
      else
      {
        unsigned int v17 = *(_DWORD *)(a1 + 216);
        if (v17 != -1)
        {
          return sub_1B65C5230(result, v17, v11, v12, v13, v14, v15, v16);
        }
      }
    }
  }
  return result;
}

BOOL sub_1B64A3178(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (*(unsigned char *)(v8 + 200)) {
    return 1;
  }
  do
  {
    uint64_t v8 = *(void *)(v8 + 64);
    BOOL result = v8 != 0;
  }
  while (v8 && !*(unsigned char *)(v8 + 200));
  return result;
}

BOOL sub_1B64A31E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (*(unsigned char *)(v8 + 200) || *(float *)(v8 + 204) <= 0.0) {
    return 1;
  }
  do
  {
    uint64_t v8 = *(void *)(v8 + 64);
    BOOL result = v8 != 0;
  }
  while (v8 && !*(unsigned char *)(v8 + 200) && *(float *)(v8 + 204) > 0.0);
  return result;
}

BOOL sub_1B64A3270(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(unsigned char *)(a1 + 200) || *(float *)(a1 + 204) <= 0.0;
}

uint64_t sub_1B64A32D4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(result + 48);
  if (v8)
  {
    char v9 = a2;
    uint64_t v10 = result;
    if (sub_1B649FF9C(result, a2, a3, a4, a5, a6, a7, a8))
    {
      if (*(_DWORD *)(v10 + 216) == -1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Node should already be in CullingSystem", v11, v12, v13, v14, v15, v16, (uint64_t)"!CFXNodeShouldBePutInCullingSystem(root) || (root->_cullingHandle != kCFXCullingHandleInvalid)");
      }
    }
    sub_1B64A30B4(v10, 1, v11, v12, v13, v14, v15, v16);
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 0x40000000;
    float32x4_t v17[2] = sub_1B64A6780;
    v17[3] = &unk_1E6142CB0;
    char v18 = v9;
    v17[4] = v10;
    v17[5] = v8;
    return sub_1B64A18A4(v10, (uint64_t)v17);
  }
  return result;
}

BOOL sub_1B64A33A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1;
  if (a1)
  {
    if (a2) {
      goto LABEL_6;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a2) {
      goto LABEL_6;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"ancestor");
  do
LABEL_6:
    uint64_t v9 = *(void *)(v9 + 64);
  while (v9 != a2 && v9 != 0);
  return v9 != 0;
}

void *sub_1B64A3430(CFArrayRef theArray, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theArray) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"arrayOfNodes");
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count) {
    return 0;
  }
  uint64_t v10 = Count;
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
  if (v10 >= 2)
  {
    for (CFIndex i = 1; i != v10; ++i)
    {
      uint64_t v13 = CFArrayGetValueAtIndex(theArray, i);
      if (!ValueAtIndex) {
        break;
      }
      while (!v13)
      {
LABEL_11:
        ValueAtIndex = (void *)ValueAtIndex[8];
        if (!ValueAtIndex) {
          return ValueAtIndex;
        }
      }
      uint64_t v14 = v13;
      while (v14 != ValueAtIndex)
      {
        uint64_t v14 = (void *)v14[8];
        if (!v14) {
          goto LABEL_11;
        }
      }
    }
  }
  return ValueAtIndex;
}

CFDictionaryRef sub_1B64A34FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  CFDictionaryRef result = sub_1B6583734(a1, @"kRenderingPriorityKey", a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(result, kCFNumberLongType, &valuePtr);
    return (const __CFDictionary *)valuePtr;
  }
  return result;
}

void sub_1B64A3570(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (sub_1B64A34FC(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) != a2)
  {
    if (a2)
    {
      CFDictionaryRef valuePtr = a2;
      CFDictionaryRef v15 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
      sub_1B6583914((CFTypeRef *)a1, @"kRenderingPriorityKey", v15, v16, v17, v18, v19, v20);
      CFRelease(v15);
    }
    else
    {
      sub_1B6583914((CFTypeRef *)a1, @"kRenderingPriorityKey", 0, v10, v11, v12, v13, v14);
    }
    sub_1B64B1F18(*(void *)(a1 + 48), 5, (const void *)a1, 0, v21, v22, v23, v24);
  }
}

uint64_t sub_1B64A3638(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return (*(unsigned __int8 *)(a1 + 222) >> 4) & 1;
}

void sub_1B64A3688(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  int v10 = *(_DWORD *)(a1 + 220);
  if (((((v10 & 0x100000) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      int v11 = 0x100000;
    }
    else {
      int v11 = 0;
    }
    *(_DWORD *)(a1 + 220) = v10 & 0xFFEFFFFF | v11;
    sub_1B64B1F18(*(void *)(a1 + 48), 5, (const void *)a1, 0, a5, a6, a7, a8);
    sub_1B64A30B4(a1, 0, v12, v13, v14, v15, v16, v17);
  }
}

void sub_1B64A373C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  int v10 = *(_DWORD *)(a1 + 220);
  if (((((v10 & 0x2000000) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      int v11 = 0x2000000;
    }
    else {
      int v11 = 0;
    }
    *(_DWORD *)(a1 + 220) = v10 & 0xFDFFFFFF | v11;
    uint64_t v12 = *(void *)(a1 + 48);
    sub_1B64B1F18(v12, 8, (const void *)a1, 0, a5, a6, a7, a8);
    sub_1B64B1F18(v12, 5, (const void *)a1, 0, v13, v14, v15, v16);
    sub_1B64A30B4(a1, 0, v17, v18, v19, v20, v21, v22);
  }
}

uint64_t sub_1B64A3808(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return *(void *)(a1 + 208);
}

uint64_t sub_1B64A3854(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  a1[26] = a2;
  sub_1B64B1F18(a1[6], 5, a1, 0, a5, a6, a7, a8);

  return sub_1B64A30B4((uint64_t)a1, 0, v10, v11, v12, v13, v14, v15);
}

uint64_t sub_1B64A38D0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 220) >> 3) & 1;
}

uint64_t sub_1B64A38DC(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 8;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFFFFFFF7 | v2;
  return result;
}

uint64_t sub_1B64A38FC(uint64_t a1)
{
  return *(unsigned char *)(a1 + 221) & 1;
}

uint64_t sub_1B64A3908(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 256;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFFFFFEFF | v2;
  return result;
}

uint64_t sub_1B64A3928(uint64_t a1)
{
  return *(unsigned char *)(a1 + 222) & 1;
}

uint64_t sub_1B64A3934(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 0x10000;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFFFEFFFF | v2;
  return result;
}

CFTypeRef sub_1B64A3954(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 240);
  if (result) {
    return sub_1B63CE23C((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B64A3964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return (*(unsigned __int8 *)(a1 + 221) >> 1) & 1;
}

void sub_1B64A39B4(float32x4_t *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v10 = (const void *)a1[3].i64[0];
  if (v10)
  {
    CFDictionaryRef v11 = sub_1B649F640((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    if (v11)
    {
      sub_1B63F4AAC(v11, a1[3].i64[0], a3, a4, a5, a6, a7, a8);
      uint64_t v19 = sub_1B64B28B0((uint64_t)v10, v12, v13, v14, v15, v16, v17, v18);
      sub_1B63C1468(v19, a1);
      sub_1B65E4DEC((uint64_t)v10, (uint64_t)a1, v20, v21, v22, v23, v24, v25, v78);
    }
  }
  BOOL v26 = sub_1B63F4F08((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) != 0;
  sub_1B65837D4((CFTypeRef *)a1, @"kLightKey", a2, v26, v27, v28, v29, v30);
  if (a2)
  {
    uint64_t v31 = a1[3].i64[0];
    if (v31) {
      sub_1B63F4CCC((uint64_t *)a2, v31, v32, v33, v34, v35, v36, v37);
    }
  }
  a1[13].i32[3] = a1[13].i32[3] & 0xFFFFFDFF | ((a2 != 0) << 9);
  if (a2 && v10)
  {
    uint64_t v38 = sub_1B64B28B0((uint64_t)v10, v31, v32, v33, v34, v35, v36, v37);
    sub_1B63C11C8(v38, a1, v39, v40, v41, v42, v43, v44, v78);
    sub_1B63C16D8(v38, a2, v45, v46, v47, v48, v49, v50);
    sub_1B65E46AC((uint64_t)v10, (uint64_t)a1, v51, v52, v53, v54, v55, v56, v79);
  }
  else if (!a2)
  {
    return;
  }
  if (sub_1B6496680((uint64_t)a2, v31, v32, v33, v34, v35, v36, v37) == 5
    && sub_1B6496EF8((uint64_t)a2, v57, v58, v59, v60, v61, v62, v63))
  {
    sub_1B649F73C(a1, v64, v65, v66, v67, v68, v69, v70);
  }
  if (sub_1B649530C((uint64_t)a2)
    && sub_1B649535C((uint64_t)a2, v71, v72, v73, v74, v75, v76, v77))
  {
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v10, 0, 1u);
  }
}

CFDictionaryRef sub_1B64A3B48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 221) & 4) == 0) {
    return 0;
  }

  return sub_1B6583734(a1, @"kCameraKey", a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64A3BCC(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 221) >> 2) & 1;
}

void sub_1B64A3BD8(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (sub_1B63F4F08(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
  {
    CFDictionaryRef v17 = sub_1B64A3B48(a1, v10, v11, v12, v13, v14, v15, v16);
    if (v17) {
      sub_1B63F4AAC(v17, *(void *)(a1 + 48), v11, v12, v13, v14, v15, v16);
    }
  }
  BOOL v18 = sub_1B63F4F08(a1, v10, v11, v12, v13, v14, v15, v16) != 0;
  sub_1B65837D4((CFTypeRef *)a1, @"kCameraKey", a2, v18, v19, v20, v21, v22);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFFBFF | ((a2 != 0) << 10);
  if (a2)
  {
    uint64_t v29 = *(void *)(a1 + 48);
    if (v29)
    {
      sub_1B63F4CCC((uint64_t *)a2, v29, v23, v24, v25, v26, v27, v28);
    }
  }
}

uint64_t sub_1B64A3CC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(a1 + 248);
  if (result) {
    return sub_1B65E1F44(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

void sub_1B64A3CD0(void *a1, const __CFArray *a2)
{
  uint64_t v4 = (void *)a1[31];
  if (a2 && !v4)
  {
    uint64_t v4 = (void *)sub_1B65E18F8((uint64_t)a1);
    a1[31] = v4;
  }
  if (v4)
  {
    sub_1B65E1F90(v4, a2);
    if (sub_1B65E1ACC(v4, v5, v6, v7, v8, v9, v10, v11))
    {
      uint64_t v12 = (const void *)a1[31];
      if (v12)
      {
        CFRelease(v12);
        a1[31] = 0;
      }
    }
    if (a1[6])
    {
      sub_1B6595A0C(@"kCFXNotificationEntityAttributeDidChange", a1, (const __CFDictionary *)@"kDeformerStackKey", 1u);
    }
  }
}

CFDictionaryRef sub_1B64A3D8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 221) & 8) == 0) {
    return 0;
  }

  return sub_1B6583734(a1, @"kLightmapInfoKey", a3, a4, a5, a6, a7, a8);
}

CFDictionaryRef sub_1B64A3E10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 222) & 4) == 0) {
    return 0;
  }

  return sub_1B6583734(a1, @"kAudioPlayer", a3, a4, a5, a6, a7, a8);
}

CFIndex sub_1B64A3E94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 222) & 4) == 0) {
    return 0;
  }
  CFArrayRef v10 = sub_1B6583734(a1, @"kAudioPlayer", a3, a4, a5, a6, a7, a8);

  return CFArrayGetCount(v10);
}

uint64_t sub_1B64A3F1C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"player");
LABEL_3:
  CFIndex v10 = sub_1B64A3E94(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  sub_1B64A3FD8(a1, a2, v10, v11, v12, v13, v14, v15);
  uint64_t result = sub_1B64A3178(a1, v16, v17, v18, v19, v20, v21, v22);
  if ((result & 1) == 0)
  {
    return sub_1B658F220(a2, v24, v25, v26);
  }
  return result;
}

uint64_t sub_1B64A3FD8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"player");
LABEL_3:
  CFDictionaryRef Mutable = sub_1B6583734(a1, @"kAudioPlayer", a3, a4, a5, a6, a7, a8);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    sub_1B6583914((CFTypeRef *)a1, @"kAudioPlayer", Mutable, v12, v13, v14, v15, v16);
    CFRelease(Mutable);
  }
  CFArrayInsertValueAtIndex(Mutable, a3, a2);
  *(_DWORD *)(a1 + 220) |= 0x40000u;
  uint64_t v24 = sub_1B64A01D4(a1, v17, v18, v19, v20, v21, v22, v23);
  sub_1B658F1AC(a2, v24, v25, v26);

  return sub_1B658F2AC(a2, v27, v28, v29);
}

void sub_1B64A40F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  CFArrayRef v9 = sub_1B6583734(a1, @"kAudioPlayer", a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    CFIndex Count = CFArrayGetCount(v9);
    if (Count >= 1)
    {
      CFIndex v16 = Count;
      do
      {
        sub_1B64A41A0(a1, 0, 1, v11, v12, v13, v14, v15);
        --v16;
      }
      while (v16);
    }
    sub_1B6583914((CFTypeRef *)a1, @"kAudioPlayer", 0, v11, v12, v13, v14, v15);
  }
  *(_DWORD *)(a1 + 220) &= ~0x40000u;
}

void sub_1B64A41A0(uint64_t a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  CFArrayRef v11 = sub_1B6583734(a1, @"kAudioPlayer", a3, a4, a5, a6, a7, a8);
  if (v11)
  {
    uint64_t v12 = v11;
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(v11, a2);
    uint64_t v14 = ValueAtIndex;
    if (ValueAtIndex) {
      CFRetain(ValueAtIndex);
    }
    CFArrayRemoveValueAtIndex(v12, a2);
    if (CFArrayGetCount(v12)) {
      *(_DWORD *)(a1 + 220) &= ~0x40000u;
    }
    if (v8) {
      sub_1B658F310(v14, v15, v16, v17);
    }
    sub_1B653F124((uint64_t)v14);
    if (v14)
    {
      CFRelease(v14);
    }
  }
}

void sub_1B64A429C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a2) {
      goto LABEL_3;
    }
LABEL_10:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"ps");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_10;
  }
LABEL_3:
  CFArrayRef v11 = sub_1B6583734(a1, @"kAudioPlayer", a3, a4, a5, a6, a7, a8);
  if (v11)
  {
    CFArrayRef v12 = v11;
    v20.length = CFArrayGetCount(v11);
    v20.location = 0;
    CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v12, v20, a2);
    if (FirstIndexOfValue != -1)
    {
      sub_1B64A41A0(a1, FirstIndexOfValue, a3, v14, v15, v16, v17, v18);
    }
  }
}

void sub_1B64A4388(uint64_t a1, void *cf, CFIndex a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (cf)
    {
LABEL_3:
      CFRetain(cf);
      sub_1B64A41A0(a1, a3, 1, v11, v12, v13, v14, v15);
      sub_1B64A3FD8(a1, cf, a3, v16, v17, v18, v19, v20);
      uint64_t v28 = sub_1B64A01D4(a1, v21, v22, v23, v24, v25, v26, v27);
      sub_1B658F1AC(cf, v28, v29, v30);
      CFRelease(cf);
      return;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (cf) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"ps");
  sub_1B64A41A0(a1, a3, 1, v31, v32, v33, v34, v35);
  sub_1B64A3FD8(a1, 0, a3, v36, v37, v38, v39, v40);
  uint64_t v48 = sub_1B64A01D4(a1, v41, v42, v43, v44, v45, v46, v47);

  sub_1B658F1AC(0, v48, v49, v50);
}

void sub_1B64A44A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 222) & 4) != 0)
  {
    CFArrayRef v16 = sub_1B6583734(a1, @"kAudioPlayer", a3, a4, a5, a6, a7, a8);
    if (!v16) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"array");
    }
    uint64_t v17 = sub_1B64A01D4(a1, v9, v10, v11, v12, v13, v14, v15);
    CFIndex Count = CFArrayGetCount(v16);
    if (Count >= 1)
    {
      CFIndex v19 = Count;
      for (CFIndex i = 0; i != v19; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v16, i);
        sub_1B658F1AC(ValueAtIndex, v17, v22, v23);
      }
    }
  }
}

CFDictionaryRef sub_1B64A457C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 221) & 0x80) == 0) {
    return 0;
  }

  return sub_1B6583734(a1, @"kConstraints", a3, a4, a5, a6, a7, a8);
}

void sub_1B64A4600(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (sub_1B63F4F08(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
  {
    CFArrayRef v17 = sub_1B64A457C(a1, v10, v11, v12, v13, v14, v15, v16);
    if (v17)
    {
      CFArrayRef v18 = v17;
      CFIndex Count = CFArrayGetCount(v17);
      if (Count >= 1)
      {
        CFIndex v20 = Count;
        for (CFIndex i = 0; i != v20; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(v18, i);
          uint64_t v30 = sub_1B63F4F08(a1, v23, v24, v25, v26, v27, v28, v29);
          sub_1B63F4AAC(ValueAtIndex, v30, v31, v32, v33, v34, v35, v36);
        }
      }
    }
  }
  BOOL v37 = sub_1B63F4F08(a1, v10, v11, v12, v13, v14, v15, v16) != 0;
  sub_1B65837D4((CFTypeRef *)a1, @"kConstraints", a2, v37, v38, v39, v40, v41);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFF7FFF | ((a2 != 0) << 15);
  uint64_t v48 = *(void *)(a1 + 48);
  if (v48)
  {
    sub_1B64B0E98(*(void *)(a1 + 48), (void *)a1, v42, v43, v44, v45, v46, v47);
    if (a2)
    {
      CFIndex v49 = CFArrayGetCount(a2);
      if (v49 >= 1)
      {
        CFIndex v50 = v49;
        for (CFIndex j = 0; j != v50; ++j)
        {
          uint64_t v52 = (uint64_t *)CFArrayGetValueAtIndex(a2, j);
          sub_1B63F4CCC(v52, v48, v53, v54, v55, v56, v57, v58);
        }
      }
    }
  }
}

void sub_1B64A474C(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFFFFFBF | ((a2 != 0) << 6);

  sub_1B6583914((CFTypeRef *)a1, @"kPhysicsBodyKey", a2, a4, a5, a6, a7, a8);
}

CFDictionaryRef sub_1B64A47D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }

  return sub_1B6583734(a1, @"kPhysicsBodyKey", a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64A4838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return (*(unsigned __int8 *)(a1 + 220) >> 6) & 1;
}

uint64_t sub_1B64A4888(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  return (*(unsigned __int8 *)(a1 + 222) >> 3) & 1;
}

void sub_1B64A48D8(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v17 = sub_1B63F4F08(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v17)
  {
    CFDictionaryRef v18 = sub_1B64A4A00(a1, v10, v11, v12, v13, v14, v15, v16);
    if (v18)
    {
      CFDictionaryRef v19 = v18;
      sub_1B64B1474(v17, (void *)a1, v11, v12, v13, v14, v15, v16);
      sub_1B65D363C((uint64_t)v19, 0, v20, v21, v22, v23, v24, v25);
      sub_1B63F4AAC(v19, *(void *)(a1 + 48), v26, v27, v28, v29, v30, v31);
    }
  }
  BOOL v32 = sub_1B63F4F08(a1, v10, v11, v12, v13, v14, v15, v16) != 0;
  sub_1B65837D4((CFTypeRef *)a1, @"kForceFieldKey", a2, v32, v33, v34, v35, v36);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFFF7FFFF | ((a2 != 0) << 19);
  if (a2)
  {
    sub_1B65D363C((uint64_t)a2, a1, v37, v38, v39, v40, v41, v42);
    uint64_t v49 = *(void *)(a1 + 48);
    if (v49) {
      sub_1B63F4CCC((uint64_t *)a2, v49, v43, v44, v45, v46, v47, v48);
    }
    if (v17)
    {
      sub_1B64B13E8(v17, (void *)a1, v43, v44, v45, v46, v47, v48);
    }
  }
}

CFDictionaryRef sub_1B64A4A00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 222) & 8) == 0) {
    return 0;
  }

  return sub_1B6583734(a1, @"kForceFieldKey", a3, a4, a5, a6, a7, a8);
}

CFDictionaryRef sub_1B64A4A84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef result = sub_1B64A0544(a1, @"kParticleEmitter", a3, a4, a5, a6, a7, a8);
  if (!result)
  {
    return sub_1B64A0544(a1, @"kParticleCollider", v10, v11, v12, v13, v14, v15);
  }
  return result;
}

void sub_1B64A4AE4(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

CFDictionaryRef sub_1B64A4AF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A0544(a1, @"kParticleCollider", a3, a4, a5, a6, a7, a8);
}

void sub_1B64A4B04(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

CFDictionaryRef sub_1B64A4B14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A0544(a1, @"kBehaviorGraph", a3, a4, a5, a6, a7, a8);
}

void sub_1B64A4B24(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64A4B34(uint64_t a1, CFArrayRef theArray, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (theArray)
    {
LABEL_3:
      int v10 = (CFArrayGetCount(theArray) > 0) << 13;
      goto LABEL_6;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (theArray) {
      goto LABEL_3;
    }
  }
  int v10 = 0;
LABEL_6:
  unsigned int v11 = *(_DWORD *)(a1 + 220);
  *(_DWORD *)(a1 + 220) = v11 & 0xFFFFDFFF | v10;
  sub_1B64A4C20(a1, v10 != 0, (v11 >> 21) & 7, a4, a5, a6, a7, a8);
  uint64_t v18 = *(void *)(a1 + 48);
  if (v18)
  {
    sub_1B64B12BC(*(CFTypeRef **)(a1 + 48), (const void *)a1, v12, v13, v14, v15, v16, v17);
    sub_1B649F3EC(a1, v18, v19, v20, v21, v22, v23, v24);
    uint64_t v32 = sub_1B64B2864(v18, v25, v26, v27, v28, v29, v30, v31);
    sub_1B64528B8(v32, a1, v33, v34, v35, v36, v37, v38);
    sub_1B64A32D4(a1, 1, v39, v40, v41, v42, v43, v44);
  }
}

void sub_1B64A4C20(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  unsigned int v11 = *(_DWORD *)(a1 + 220);
  int v12 = (v11 >> 6) & 0x80;
  if (a2) {
    int v12 = 128;
  }
  *(_DWORD *)(a1 + 220) = v12 & 0xFF1FFFFF | ((a3 & 7) << 21) | v11 & 0xFF1FFF7F;
  for (uint64_t i = *(void *)(a1 + 72); i; uint64_t i = *(void *)(i + 80))
    sub_1B64A4C20(i, (*(_DWORD *)(a1 + 220) >> 7) & 1, a3);
}

CFDictionaryRef sub_1B64A4CCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if ((*(unsigned char *)(a1 + 221) & 0x20) == 0) {
    return 0;
  }

  return sub_1B6583734(a1, @"kFilterKey", a3, a4, a5, a6, a7, a8);
}

void sub_1B64A4D50(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (a2 >= 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. layer index out of bound", a3, a4, a5, a6, a7, a8, (uint64_t)"layer < CFX_MAX_LAYERS");
  }
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a1 + 220) & 0xFF1FFFFF | ((v8 & 7) << 21);
}

uint64_t sub_1B64A4DAC(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 220) >> 21) & 7;
}

uint64_t sub_1B64A4DB8(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 0x4000000;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xFBFFFFFF | v2;
  return result;
}

uint64_t sub_1B64A4DD8(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 223) >> 2) & 1;
}

uint64_t sub_1B64A4DE4(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 223) >> 3) & 1;
}

uint64_t sub_1B64A4DF0(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  do
  {
    unsigned int v1 = *(_DWORD *)(a1 + 220);
    uint64_t v2 = (v1 >> 27) & 1;
    if ((v1 & 0x8000000) != 0) {
      break;
    }
    a1 = *(void *)(a1 + 64);
  }
  while (a1);
  return v2;
}

uint64_t sub_1B64A4E18(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 0x8000000;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 220) = *(_DWORD *)(result + 220) & 0xF7FFFFFF | v2;
  return result;
}

id sub_1B64A4E3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v9 = *(void *)(a1 + 240);
  if (v9) {
    sub_1B63CE7AC(v9, (const void *)a1, a3, a4, a5, a6, a7, a8);
  }
  sub_1B6595A0C(@"kCFXNotificationNodeWillDie", (const void *)a1, 0, 1u);
  uint64_t v17 = *(void **)(a1 + 192);
  if (v17) {
    free(v17);
  }
  int v18 = *(_DWORD *)(a1 + 220);
  if ((v18 & 0x40000) != 0)
  {
    sub_1B64A40F0(a1, v10, v11, v12, v13, v14, v15, v16);
    int v18 = *(_DWORD *)(a1 + 220);
  }
  if ((v18 & 0x80000) != 0) {
    sub_1B64A48D8(a1, 0, v11, v12, v13, v14, v15, v16);
  }
  uint64_t v19 = *(void **)(a1 + 72);
  if (v19)
  {
    do
    {
      uint64_t v20 = v19[8];
      if (v20 == a1)
      {
        v19[8] = 0;
      }
      else if (v20)
      {
        sub_1B63F2F54(16, @"Error: inconsistency in world graph found in CFXNode finalize", v11, v12, v13, v14, v15, v16, v27);
      }
      uint64_t v21 = (void *)v19[10];
      v19[10] = 0;
      CFRelease(v19);
      uint64_t v19 = v21;
    }
    while (v21);
  }
  uint64_t v22 = *(const void **)(a1 + 80);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v23 = *(const void **)(a1 + 240);
  if (v23)
  {
    CFRelease(v23);
    *(void *)(a1 + 240) = 0;
  }
  uint64_t v24 = *(const void **)(a1 + 248);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a1 + 248) = 0;
  }
  uint64_t v25 = *(void **)(a1 + 232);
  if (v25) {
    free(v25);
  }

  return sub_1B658325C(a1, v10, v11, v12, v13, v14, v15, v16);
}

__CFString *sub_1B64A4F88(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v10 = sub_1B64A1954(a1, v3, v4, v5, v6, v7, v8, v9);
  CFStringAppendFormat(Mutable, 0, @"<CFXNode:%p \"%@\"\n", a1, v10);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v11, v12, v13, v14, v15, v16, (uint64_t)"node");
  }
  CFStringAppendFormat(Mutable, 0, @"  geometry: %@\n", *(void *)(a1 + 240));
  int v24 = *(_DWORD *)(a1 + 220);
  if ((v24 & 0x200) != 0)
  {
    CFDictionaryRef v25 = sub_1B649F640(a1, v17, v18, v19, v20, v21, v22, v23);
    CFStringAppendFormat(Mutable, 0, @"  light: %@\n", v25);
    int v24 = *(_DWORD *)(a1 + 220);
  }
  if ((v24 & 0x400) != 0)
  {
    CFDictionaryRef v26 = sub_1B64A3B48(a1, v17, v18, v19, v20, v21, v22, v23);
    CFStringAppendFormat(Mutable, 0, @"  camera: %@\n", v26);
  }
  uint64_t v27 = *(void *)(a1 + 248);
  if (v27)
  {
    uint64_t v28 = sub_1B65E1E14(v27, v17, v18, v19, v20, v21, v22, v23);
    if (v28) {
      CFStringAppendFormat(Mutable, 0, @"  skinner: %@\n", v28);
    }
  }
  uint64_t v29 = sub_1B64A14EC(a1, v17, v18, v19, v20, v21, v22, v23);
  if (v29) {
    CFStringAppendFormat(Mutable, 0, @"  morpher: %@\n", v29);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

__CFArray *sub_1B64A50D4(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t valuePtr = 0x500000001;
  uint64_t v111 = sub_1B6583544(a1, v6, v7, v8, v9, v10, v11, v12);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v5, @"name", @"id");
  CFDictionarySetValue(v5, @"type", v13);
  CFDictionarySetValue(v5, @"address", v15);
  CFDictionarySetValue(v5, @"semantic", v14);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v14);
  CFRelease(v5);
  CFRelease(v15);
  CFRelease(v13);
  uint64_t v16 = CFDictionaryCreateMutable(0, 4, v3, v4);
  uint64_t valuePtr = 0x500000001;
  uint64_t v111 = sub_1B6583470(a1, v17, v18, v19, v20, v21, v22, v23);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v16, @"name", @"name");
  CFDictionarySetValue(v16, @"type", v24);
  CFDictionarySetValue(v16, @"address", v26);
  CFDictionarySetValue(v16, @"semantic", v25);
  CFArrayAppendValue(Mutable, v16);
  CFRelease(v25);
  CFRelease(v16);
  CFRelease(v26);
  CFRelease(v24);
  uint64_t v27 = CFDictionaryCreateMutable(0, 4, v3, v4);
  uint64_t valuePtr = 0x500000001;
  uint64_t v111 = sub_1B65836E8(a1, v28, v29, v30, v31, v32, v33, v34);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v27, @"name", @"attributes");
  CFDictionarySetValue(v27, @"type", v35);
  CFDictionarySetValue(v27, @"address", v37);
  CFDictionarySetValue(v27, @"semantic", v36);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v36);
  CFRelease(v27);
  CFRelease(v37);
  CFRelease(v35);
  uint64_t v38 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t valuePtr = 0xA00000000;
  uint64_t v111 = a1 + 96;
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v40 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v38, @"name", @"transforms");
  CFDictionarySetValue(v38, @"type", v39);
  CFDictionarySetValue(v38, @"address", v41);
  CFDictionarySetValue(v38, @"semantic", v40);
  CFArrayAppendValue(Mutable, v38);
  CFRelease(v40);
  CFRelease(v38);
  CFRelease(v41);
  CFRelease(v39);
  uint64_t v42 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v43 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t valuePtr = 0x500000002;
  uint64_t v111 = a1 + 72;
  CFNumberRef v44 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v43, @"name", @"firstChild");
  CFDictionarySetValue(v43, @"type", v44);
  CFDictionarySetValue(v43, @"address", v46);
  CFDictionarySetValue(v43, @"semantic", v45);
  CFArrayAppendValue(Mutable, v43);
  CFRelease(v45);
  CFRelease(v43);
  CFRelease(v46);
  CFRelease(v44);
  uint64_t v47 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v48 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v42);
  uint64_t valuePtr = 0x500000002;
  uint64_t v111 = a1 + 80;
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v48, @"name", @"nextSibling");
  CFDictionarySetValue(v48, @"type", v49);
  CFDictionarySetValue(v48, @"address", v51);
  CFDictionarySetValue(v48, @"semantic", v50);
  CFArrayAppendValue(Mutable, v48);
  CFRelease(v50);
  CFRelease(v48);
  CFRelease(v51);
  CFRelease(v49);
  uint64_t v52 = CFDictionaryCreateMutable(0, 4, v47, v42);
  uint64_t valuePtr = 0x100000000;
  uint64_t v111 = a1 + 204;
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v52, @"name", @"opacity");
  CFDictionarySetValue(v52, @"type", v53);
  CFDictionarySetValue(v52, @"address", v55);
  CFDictionarySetValue(v52, @"semantic", v54);
  CFArrayAppendValue(Mutable, v52);
  CFRelease(v54);
  CFRelease(v52);
  CFRelease(v55);
  CFRelease(v53);
  uint64_t v56 = CFDictionaryCreateMutable(0, 4, v47, v42);
  uint64_t valuePtr = 0x300000000;
  uint64_t v111 = a1 + 200;
  CFNumberRef v57 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v56, @"name", @"hidden");
  CFDictionarySetValue(v56, @"type", v57);
  CFDictionarySetValue(v56, @"address", v59);
  CFDictionarySetValue(v56, @"semantic", v58);
  CFArrayAppendValue(Mutable, v56);
  CFRelease(v58);
  CFRelease(v56);
  CFRelease(v59);
  CFRelease(v57);
  uint64_t v60 = CFDictionaryCreateMutable(0, 4, v47, MEMORY[0x1E4F1D540]);
  uint64_t v111 = a1 + 64;
  uint64_t valuePtr = 0;
  CFNumberRef v61 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v62 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v63 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v60, @"name", @"parent");
  CFDictionarySetValue(v60, @"type", v61);
  CFDictionarySetValue(v60, @"address", v63);
  CFDictionarySetValue(v60, @"semantic", v62);
  CFArrayAppendValue(Mutable, v60);
  CFRelease(v62);
  CFRelease(v60);
  CFRelease(v63);
  CFRelease(v61);
  uint64_t v64 = CFDictionaryCreateMutable(0, 4, v47, MEMORY[0x1E4F1D540]);
  uint64_t valuePtr = 0x500000002;
  uint64_t v111 = a1 + 240;
  CFNumberRef v65 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v64, @"name", @"geometry");
  CFDictionarySetValue(v64, @"type", v65);
  CFDictionarySetValue(v64, @"address", v67);
  CFDictionarySetValue(v64, @"semantic", v66);
  CFArrayAppendValue(Mutable, v64);
  CFRelease(v66);
  CFRelease(v64);
  CFRelease(v67);
  CFRelease(v65);
  uint64_t v68 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t valuePtr = 0x200000000;
  uint64_t v111 = a1 + 208;
  CFNumberRef v69 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberRef v70 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v71 = CFNumberCreate(0, kCFNumberLongType, &v111);
  CFDictionarySetValue(v68, @"name", @"categoryBitMask");
  CFDictionarySetValue(v68, @"type", v69);
  CFDictionarySetValue(v68, @"address", v71);
  CFDictionarySetValue(v68, @"semantic", v70);
  CFArrayAppendValue(Mutable, v68);
  CFRelease(v70);
  CFRelease(v68);
  CFRelease(v71);
  CFRelease(v69);
  if (sub_1B64A14EC(a1, v72, v73, v74, v75, v76, v77, v78))
  {
    CFNumberRef v86 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t valuePtr = 0x500000001;
    uint64_t v111 = sub_1B64A14EC(a1, v87, v88, v89, v90, v91, v92, v93);
    CFNumberRef v94 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    CFNumberRef v95 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v96 = CFNumberCreate(0, kCFNumberLongType, &v111);
    CFDictionarySetValue(v86, @"name", @"morpher");
    CFDictionarySetValue(v86, @"type", v94);
    CFDictionarySetValue(v86, @"address", v96);
    CFDictionarySetValue(v86, @"semantic", v95);
    CFArrayAppendValue(Mutable, v86);
    CFRelease(v95);
    CFRelease(v86);
    CFRelease(v96);
    CFRelease(v94);
  }
  uint64_t v97 = *(void *)(a1 + 248);
  if (v97 && sub_1B65E1E14(v97, v79, v80, v81, v82, v83, v84, v85))
  {
    uint64_t v105 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t valuePtr = 0x500000001;
    uint64_t v106 = *(void *)(a1 + 248);
    if (v106) {
      uint64_t v106 = sub_1B65E1E14(v106, v98, v99, v100, v101, v102, v103, v104);
    }
    uint64_t v111 = v106;
    CFNumberRef v107 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    CFNumberRef v108 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v109 = CFNumberCreate(0, kCFNumberLongType, &v111);
    CFDictionarySetValue(v105, @"name", @"skinner");
    CFDictionarySetValue(v105, @"type", v107);
    CFDictionarySetValue(v105, @"address", v109);
    CFDictionarySetValue(v105, @"semantic", v108);
    CFArrayAppendValue(Mutable, v105);
    CFRelease(v108);
    CFRelease(v105);
    CFRelease(v109);
    CFRelease(v107);
  }
  return Mutable;
}

uint64_t sub_1B64A5D2C(float32x4_t *a1, int a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v14 = 0u;
  float32x4_t v15 = 0u;
  if (a2)
  {
    if (sub_1B64A00F0(a1, 1, &v14, (uint64_t)a4, a5, a6, a7, a8))
    {
LABEL_3:
      float32x4_t v10 = v14;
      float32x4_t v11 = v15;
      *a3 = vsubq_f32(v14, v15);
      *a4 = vaddq_f32(v10, v11);
      return 1;
    }
  }
  else
  {
    float32x4_t v13 = a1[18];
    float32x4_t v14 = a1[17];
    float32x4_t v15 = v13;
    if ((vminvq_u32((uint32x4_t)vcgezq_f32(a1[18])) & 0x80000000) != 0) {
      goto LABEL_3;
    }
  }
  return 0;
}

uint64_t sub_1B64A5DB0(void *a1, uint64_t a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, a4, a5, a6, a7, a8, (uint64_t)"sphereOut");
  }
  float32x4_t v52 = 0uLL;
  float32x4_t v51 = 0uLL;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  float32x4_t v11 = (const void *)a1[30];
  if (v11)
  {
    uint64_t v12 = a1[31];
    if (!v12 || (uint64_t v13 = sub_1B65E1E14(v12, a2, (uint64_t)a3, a4, a5, a6, a7, a8)) == 0)
    {
      char v20 = sub_1B63F49F8(v11, a2, (uint64_t)&v52, a4, a5, a6, a7, a8);
      if (!a2) {
        goto LABEL_32;
      }
      goto LABEL_16;
    }
    float32x4_t v47 = 0u;
    float32x4_t v48 = 0u;
    sub_1B6525818(v13, (uint64_t)a1, (uint64_t)&v47, a4, a5, a6, a7, a8);
    goto LABEL_11;
  }
  if (sub_1B64A0544((uint64_t)a1, @"kParticleEmitter", (uint64_t)a3, a4, a5, a6, a7, a8))
  {
    float32x4_t v47 = 0u;
    float32x4_t v48 = 0u;
    sub_1B64A02A0((uint64_t)a1, a2, (uint64_t)&v47, v15, v16, v17, v18, v19, (uint32x4_t)0);
LABEL_11:
    char v20 = v14;
    float32x4_t v21 = v47;
    v21.i32[3] = vmaxvq_f32(v48);
    float32x4_t v52 = v21;
    if (!a2) {
      goto LABEL_32;
    }
    goto LABEL_16;
  }
  char v20 = 0;
  if (!a2) {
    goto LABEL_32;
  }
LABEL_16:
  uint64_t v22 = a1[9];
  if (v22)
  {
    LODWORD(v23) = 0;
    do
    {
      uint64_t v23 = (v23 + 1);
      uint64_t v22 = *(void *)(v22 + 80);
    }
    while (v22);
    if (v23)
    {
      for (uint64_t i = 0; i != v23; ++i)
      {
        CFNumberRef v25 = (void *)a1[9];
        if (i && v25)
        {
          unsigned int v26 = 1;
          do
          {
            CFNumberRef v25 = (void *)v25[10];
            if (v26 >= i) {
              break;
            }
            ++v26;
          }
          while (v25);
        }
        if (sub_1B63F49F8(v25, 1, (uint64_t)&v51, v15, v16, v17, v18, v19))
        {
          long long v49 = 0u;
          long long v50 = 0u;
          float32x4_t v47 = 0u;
          float32x4_t v48 = 0u;
          *(double *)v29.i64 = sub_1B649FE9C((uint64_t)v25, v27, v28, v15, v16, v17, v18, v19);
          float32x4_t v47 = v29;
          float32x4_t v48 = v30;
          long long v49 = v31;
          long long v50 = v32;
          __n128 v40 = sub_1B64556CC((uint64_t)(v25 + 12), v33, v34, v35, v36, v37, v38, v39);
          sub_1B63DAB1C(&v51, &v47, (uint64_t)&v51, v41, v42, v43, v44, v45, v40);
          if (v20) {
            sub_1B6403B98(&v52, &v51, &v52);
          }
          else {
            float32x4_t v52 = v51;
          }
          char v20 = 1;
        }
      }
    }
  }
LABEL_32:
  if ((v20 & 1) == 0) {
    return 0;
  }
  *a3 = v52;
  return 1;
}

void sub_1B64A5FAC(void **a1, __n128 *__dst, long long *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (a1 + 12 == (void **)__dst)
  {
    sub_1B6456160(__dst, __src, __n, a5, a6, a6, a7, a8, a9, v19);
    sub_1B64A2394((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
  }
  else if (a1[24] == __dst)
  {
    sub_1B64A0A70((uint64_t)a1, __src, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else if ((__n128 *)((char *)a1 + 204) == __dst)
  {
    float v17 = *(float *)__src;
    sub_1B64A0B4C((uint64_t)a1, v17, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else if (a1 + 25 == (void **)__dst)
  {
    int v18 = *(unsigned __int8 *)__src;
    sub_1B64A0CE8((uint64_t)a1, v18, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else
  {
    memcpy(__dst, __src, __n);
  }
}

void sub_1B64A60BC(uint64_t a1, const void *a2, void *__dst, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if ((const void *)(a1 + 96) == a2) {
    sub_1B6455A38((uint64_t)a2, __dst, __n, a5, a6, a6, a7, a8, a9);
  }
  else {
    memcpy(__dst, a2, __n);
  }
}

uint64_t sub_1B64A60EC(void *a1, void (**a2)(void), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10 = (const __CFDictionary *)sub_1B65836E8((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10) {
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)sub_1B64A63B4, a2);
  }
  uint64_t v17 = a1[30];
  if (v17) {
    a2[2](a2);
  }
  uint64_t v18 = sub_1B64A14EC((uint64_t)a1, v17, v11, v12, v13, v14, v15, v16);
  if (v18) {
    ((void (*)(void (**)(void), uint64_t))a2[2])(a2, v18);
  }
  uint64_t v26 = a1[31];
  if (v26)
  {
    uint64_t v27 = sub_1B65E1E14(v26, v19, v20, v21, v22, v23, v24, v25);
    if (v27) {
      ((void (*)(void (**)(void), uint64_t))a2[2])(a2, v27);
    }
  }
  uint64_t result = (uint64_t)sub_1B64A457C((uint64_t)a1, v19, v20, v21, v22, v23, v24, v25);
  if (result)
  {
    CFArrayRef v29 = (const __CFArray *)result;
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      uint64_t v30 = result;
      for (CFIndex i = 0; i != v30; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v29, i);
        uint64_t result = ((uint64_t (*)(void (**)(void), const void *))a2[2])(a2, ValueAtIndex);
      }
    }
  }
  v34[0] = MEMORY[0x1E4F143A8];
  v34[1] = 0x40000000;
  uint64_t v35 = sub_1B64A6410;
  uint64_t v36 = &unk_1E6142BC0;
  uint64_t v37 = a2;
  for (uint64_t j = a1[9]; j; uint64_t j = *(void *)(j + 80))
    uint64_t result = ((uint64_t (*)(void *, uint64_t))v35)(v34, j);
  return result;
}

void sub_1B64A625C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B64B29E0(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v16 = *(void *)(a1 + 64);
  if (v16) {
    uint64_t v17 = *(unsigned int *)(v16 + 88);
  }
  else {
    uint64_t v17 = 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 88) = sub_1B650F3B0(v10, a1, v17, v11, v12, v13, v14, v15);

  sub_1B649F3EC(a1, a2, v18, v19, v20, v21, v22, v23);
}

void sub_1B64A62C0(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B64B1788(a2, a1, a3, a4, a5, a6, a7, a8);
  if (a1[22] != -1)
  {
    uint64_t v17 = sub_1B64B29E0(a2, v10, v11, v12, v13, v14, v15, v16);
    if (v17) {
      sub_1B650F670(v17, a1[22], v11, v12, v13, v14, v15, v16);
    }
    a1[22] = -1;
  }
  if (a1[54] != -1)
  {
    uint64_t v18 = sub_1B64B2994(a2, v10, v11, v12, v13, v14, v15, v16);
    if (v18) {
      sub_1B65C53B0(v18, a1[54], v19, v20, v21, v22, v23, v24);
    }
    a1[54] = -1;
  }
}

void sub_1B64A6340(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1[4].i64[0]) {
    sub_1B64A32D4((uint64_t)a1, 1, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v10 = a1[15].i64[1];
  if (v10)
  {
    uint64_t v11 = sub_1B65E1E14(v10, a2, a3, a4, a5, a6, a7, a8);
    if (v11)
    {
      uint64_t v12 = v11;
      if (sub_1B63CD09C(v11))
      {
        sub_1B65256D0(v12, a1, v13, v14, v15, v16, v17, v18, a9);
      }
    }
  }
}

const void *sub_1B64A63B4(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t result = sub_1B6583B18(a2);
  if (result)
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, const void *))(a3 + 16);
    return (const void *)v6(a3, a2);
  }
  return result;
}

uint64_t sub_1B64A6410(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1B64A6420(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  uint64_t v18 = (const void *)sub_1B6583470(a1, v11, v12, v13, v14, v15, v16, v17);
  if (v18)
  {
    if (sub_1B63C47F8(v18, a2)) {
      return a1;
    }
  }
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v19, v20, v21, v22, v23, v24, (uint64_t)"node");
  }
  uint64_t v25 = sub_1B63F4FC8(*(const void **)(a1 + 240), (uint64_t)a2);
  if (!v25)
  {
    CFDictionaryRef v33 = sub_1B649F640(a1, v26, v27, v28, v29, v30, v31, v32);
    uint64_t v25 = sub_1B63F4FC8(v33, (uint64_t)a2);
    if (!v25)
    {
      uint64_t v41 = (const void *)sub_1B64A14EC(a1, v34, v35, v36, v37, v38, v39, v40);
      uint64_t v25 = sub_1B63F4FC8(v41, (uint64_t)a2);
      if (!v25)
      {
        long long v49 = *(const void **)(a1 + 248);
        if (v49) {
          long long v49 = (const void *)sub_1B65E1E14((uint64_t)v49, v42, v43, v44, v45, v46, v47, v48);
        }
        uint64_t v25 = sub_1B63F4FC8(v49, (uint64_t)a2);
        if (!v25)
        {
          CFNumberRef v57 = (const void *)sub_1B649FCB4(a1, v50, v51, v52, v53, v54, v55, v56);
          uint64_t v25 = sub_1B63F4FC8(v57, (uint64_t)a2);
          if (!v25)
          {
            CFDictionaryRef v65 = sub_1B64A3B48(a1, v58, v59, v60, v61, v62, v63, v64);
            uint64_t v25 = sub_1B63F4FC8(v65, (uint64_t)a2);
            if (!v25)
            {
              uint64_t v74 = 0;
              uint64_t v75 = &v74;
              uint64_t v76 = 0x2000000000;
              uint64_t v77 = 0;
              v69[0] = MEMORY[0x1E4F143A8];
              v69[1] = 0x40000000;
              CFNumberRef v70 = sub_1B64A65E8;
              CFNumberRef v71 = &unk_1E6142BE8;
              uint64_t v72 = &v74;
              uint64_t v73 = a2;
              char v78 = 0;
              uint64_t v66 = *(void *)(a1 + 72);
              if (v66)
              {
                do
                {
                  v70((uint64_t)v69, v66, &v78);
                  uint64_t v66 = *(void *)(v66 + 80);
                  if (v78) {
                    BOOL v67 = 1;
                  }
                  else {
                    BOOL v67 = v66 == 0;
                  }
                }
                while (!v67);
                uint64_t v25 = v75[3];
              }
              else
              {
                uint64_t v25 = 0;
              }
              _Block_object_dispose(&v74, 8);
            }
          }
        }
      }
    }
  }
  return v25;
}

uint64_t sub_1B64A65E8(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = sub_1B64A6420(a2, *(void *)(a1 + 40));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    *a3 = 1;
  }
  return result;
}

uint64_t sub_1B64A6640(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2[55] & 0xC0200) != 0) {
    sub_1B6454054(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  }
  return 0;
}

uint64_t sub_1B64A6674(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = sub_1B64A2DEC(a2, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 40));
  if ((result & 1) == 0) {
    *a3 = 1;
  }
  return result;
}

uint64_t sub_1B64A66B4(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 40)) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = (a2[55] & 0x20) == 0;
  }
  if (!v8) {
    return 1;
  }
  a2[55] |= 0x20u;
  if (*(unsigned char *)(a1 + 40)) {
    sub_1B64B1F18(*(void *)(a1 + 32), 4, a2, 0, a5, a6, a7, a8);
  }
  return 0;
}

uint64_t sub_1B64A6710(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2[51] < 1.0) {
    return 1;
  }
  sub_1B64B1F18(*(void *)(a1 + 32), 4, a2, 0, a5, a6, a7, a8);
  return 0;
}

uint64_t sub_1B64A6754(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a2 + 216);
  if (v8 != -1) {
    sub_1B65C5230(*(void *)(a1 + 32), v8, a3, a4, a5, a6, a7, a8);
  }
  return 0;
}

uint64_t sub_1B64A6780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (*(unsigned char *)(a2 + 200) && (*(unsigned char *)(a1 + 48) || *(void *)(a1 + 32) != a2)) {
    return 1;
  }
  if (sub_1B649FF9C(a2, a2, a3, a4, a5, a6, a7, a8) && *(_DWORD *)(a2 + 216) == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Node should already be in CullingSystem", v12, v13, v14, v15, v16, v17, (uint64_t)"!CFXNodeShouldBePutInCullingSystem(child) || (child->_cullingHandle != kCFXCullingHandleInvalid)");
  }
  if (*(unsigned char *)(a1 + 48))
  {
    sub_1B64B1F18(*(void *)(a2 + 48), 0, (const void *)a2, 0, v14, v15, v16, v17);
    uint64_t v18 = *(void *)(a1 + 40);
    if (v18) {
      sub_1B64B15A4(v18, a2, v12, v13, v14, v15, v16, v17);
    }
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 40);
    if (v19) {
      sub_1B64B1998(v19, (unsigned char *)a2, v12, v13, v14, v15, v16, v17);
    }
  }
  BOOL v20 = (*(unsigned char *)(a2 + 221) & 0x10) != 0 && *(void *)(a2 + 240) != 0;
  CFDictionaryRef v21 = sub_1B649F640(a2, v11, v12, v13, v14, v15, v16, v17);
  if (v21)
  {
    uint64_t v22 = (uint64_t)v21;
    CFTypeID v23 = CFGetTypeID(v21);
    if (v23 == sub_1B6494820())
    {
      if (sub_1B649530C(v22))
      {
        if (((sub_1B649535C(v22, v24, v25, v26, v27, v28, v29, v30) | v20) & 1) == 0) {
          return 0;
        }
        goto LABEL_24;
      }
    }
  }
  if (v20) {
LABEL_24:
  }
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", *(const void **)(a1 + 40), 0, 1u);
  return 0;
}

unsigned char *sub_1B64A68F0(void *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  v36.receiver = a1;
  v36.super_class = (Class)VFXMTLDeformerStack;
  uint64_t v9 = objc_msgSendSuper2(&v36, sel_init);
  uint64_t v17 = v9;
  if (v9)
  {
    *((void *)v9 + 1) = a5;
    *((void *)v9 + 2) = a2;
    *((void *)v9 + 3) = a3;
    v9[40] = a4;
    v9[41] = a4;
    uint64_t v18 = (void *)sub_1B65E1F44(a2, v10, v11, v12, v13, v14, v15, v16);
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    uint64_t v20 = objc_msgSend_countByEnumeratingWithState_objects_count_(v18, v19, (uint64_t)&v32, (uint64_t)v37, 16);
    if (v20)
    {
      uint64_t v24 = v20;
      uint64_t v25 = *(void *)v33;
      do
      {
        for (uint64_t i = 0; i != v24; ++i)
        {
          if (*(void *)v33 != v25) {
            objc_enumerationMutation(v18);
          }
          uint64_t v27 = *(void **)(*((void *)&v32 + 1) + 8 * i);
          v17[41] = 0;
          v17[43] |= objc_msgSend_deformedMeshReliesOnTransforms(v27, v21, v22, v23);
          v17[44] |= objc_msgSend_deformedMeshReliesOnFrustum(v27, v28, v29, v30);
        }
        uint64_t v24 = objc_msgSend_countByEnumeratingWithState_objects_count_(v18, v21, (uint64_t)&v32, (uint64_t)v37, 16);
      }
      while (v24);
    }
  }
  return v17;
}

uint64_t sub_1B64A6B40(uint64_t result)
{
  if (result) {
    return *(void *)(result + 104);
  }
  return result;
}

void sub_1B64A7628(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1B64A76BC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a3 != 7 && (a3 == 3 || a4 <= 0) && (a3 != 3 || a4 <= 7))
  {
    if (sub_1B647BC9C(a2))
    {
      sub_1B63F2F54(16, @"Unreachable code: Volatile meshes are not supported by the deformer stack", v12, v13, v14, v15, v16, v17, a9);
    }
    else if (a3 != 4 && a3 != 1)
    {
      if (a3)
      {
        if (!*(unsigned char *)(a1 + 72))
        {
          uint64_t v37 = sub_1B653BEF8(*(void *)(*(void *)(a1 + 32) + 8), a2);
          if (v37)
          {
            uint64_t v40 = (uint64_t)v37;
            if (objc_msgSend_indexOfObject_(*(void **)(a1 + 40), v38, (uint64_t)v37, v39) == 0x7FFFFFFFFFFFFFFFLL)
            {
              objc_msgSend_count(*(void **)(a1 + 40), v41, v42, v43);
              objc_msgSend_addObject_(*(void **)(a1 + 40), v44, v40, v45);
            }
            uint64_t v46 = *(void *)(a1 + 48);
            MEMORY[0x1F4181798](VFXMTLResourceManager, sel__fillVertexDescriptor_withMeshSource_semantic_inputSet_bufferIndex_, v46, a2);
          }
        }
      }
      else
      {
        uint64_t v18 = sub_1B64D80E0(30);
        uint64_t v26 = sub_1B641D8A0(a2, v19, v20, v21, v22, v23, v24, v25);
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v26;
        *(void *)(*(void *)(a1 + 32) + 112) = sub_1B653D7E8(*(void *)(*(void *)(a1 + 32) + 8), (const char *)(v26 * v18), 32);
        uint64_t v31 = *(void *)(a1 + 32);
        uint64_t v32 = *(unsigned __int8 *)(v31 + 41);
        if (v32 == *(unsigned __int8 *)(v31 + 40))
        {
          id v33 = *(id *)(v31 + 112);
        }
        else
        {
          uint64_t v47 = sub_1B64AC5F8(*(void *)(a1 + 64), 0, 0, v32, v27, v28, v29, v30);
          uint64_t v55 = sub_1B641D8A0((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54);
          id v33 = (id)sub_1B653D7E8(*(void *)(*(void *)(a1 + 32) + 8), (const char *)(v55 * v18), 32);
        }
        *(void *)(*(void *)(a1 + 32) + 80) = v33;
        uint64_t v56 = objc_msgSend_count(*(void **)(a1 + 40), v34, v35, v36);
        objc_msgSend_addObject_(*(void **)(a1 + 40), v57, *(void *)(*(void *)(a1 + 32) + 112), v58);
        uint64_t v62 = objc_msgSend_attributes(*(void **)(a1 + 48), v59, v60, v61);
        CFDictionaryRef v65 = objc_msgSend_objectAtIndexedSubscript_(v62, v63, 0, v64);
        objc_msgSend_setFormat_(v65, v66, 30, v67);
        objc_msgSend_setOffset_(v65, v68, 0, v69);
        objc_msgSend_setBufferIndex_(v65, v70, v56 + 18, v71);
        uint64_t v75 = objc_msgSend_layouts(*(void **)(a1 + 48), v72, v73, v74);
        uint64_t v79 = objc_msgSend_bufferIndex(v65, v76, v77, v78);
        uint64_t v82 = objc_msgSend_objectAtIndexedSubscript_(v75, v80, v79, v81);
        objc_msgSend_setStride_(v82, v83, v18, v84);
        objc_msgSend_setStepFunction_(v82, v85, 1, v86);
        uint64_t v90 = objc_msgSend_offset(v65, v87, v88, v89);
        uint64_t v94 = objc_msgSend_stride(v82, v91, v92, v93);
        uint64_t v95 = *(void *)(a1 + 32);
        *(unsigned char *)(v95 + 232) = 1;
        *(void *)(v95 + 240) = 30;
        *(void *)(v95 + 248) = v90;
        *(void *)(v95 + 256) = v94;
      }
    }
  }
}

uint64_t sub_1B64A8274(uint64_t result)
{
  if (result) {
    *(unsigned char *)(result + 42) = 0;
  }
  return result;
}

void *sub_1B64A8CE8(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7)
{
  if (!a1) {
    return 0;
  }
  v17.receiver = a1;
  v17.super_class = (Class)VFXModelDeformerInstanceWrapper;
  uint64_t v13 = objc_msgSendSuper2(&v17, sel_init);
  uint64_t v14 = v13;
  if (v13)
  {
    v13[1] = a2;
    void v13[2] = a3;
    memcpy(v13 + 4, a7, 0x180uLL);
    v14[3] = objc_msgSend_newDeformerInstanceForNode_outputs_computeVertexCount_context_(a3, v15, a4, a5, a6, v14);
  }
  return v14;
}

uint64_t sub_1B64A8F60(uint64_t result)
{
  if (result) {
    return sub_1B6592134(*(void *)(result + 736));
  }
  return result;
}

BOOL sub_1B64A8F70(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 43) != 0;
  }
  return result;
}

BOOL sub_1B64A8F84(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 44) != 0;
  }
  return result;
}

uint64_t sub_1B64A8F98(uint64_t a1, uint64_t a2, unsigned __int8 a3, long long *a4, long long *a5, BOOL *a6)
{
  if (!a1) {
    return 0;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  v87[0] = MEMORY[0x1E4F143A8];
  v87[1] = 3221225472;
  v87[2] = sub_1B64A93AC;
  v87[3] = &unk_1E6142D00;
  v87[4] = a1;
  v87[5] = a2;
  unsigned __int8 v88 = a3;
  sub_1B65E2034(v12, (uint64_t)v87);
  long long v13 = *a4;
  long long v14 = a4[1];
  long long v15 = a4[3];
  *(_OWORD *)(a1 + 448) = a4[2];
  *(_OWORD *)(a1 + 464) = v15;
  *(_OWORD *)(a1 + 416) = v13;
  *(_OWORD *)(a1 + 432) = v14;
  long long v16 = a4[4];
  long long v17 = a4[5];
  long long v18 = a4[7];
  *(_OWORD *)(a1 + 512) = a4[6];
  *(_OWORD *)(a1 + 528) = v18;
  *(_OWORD *)(a1 + 480) = v16;
  *(_OWORD *)(a1 + 496) = v17;
  long long v19 = a4[8];
  long long v20 = a4[9];
  long long v21 = a4[11];
  *(_OWORD *)(a1 + 576) = a4[10];
  *(_OWORD *)(a1 + 592) = v21;
  *(_OWORD *)(a1 + 544) = v19;
  *(_OWORD *)(a1 + 560) = v20;
  long long v22 = *a5;
  long long v23 = a5[2];
  *(_OWORD *)(a1 + 624) = a5[1];
  *(_OWORD *)(a1 + 640) = v23;
  *(_OWORD *)(a1 + 608) = v22;
  long long v24 = a5[3];
  long long v25 = a5[4];
  long long v26 = a5[6];
  *(_OWORD *)(a1 + 688) = a5[5];
  *(_OWORD *)(a1 + 704) = v26;
  *(_OWORD *)(a1 + 656) = v24;
  *(_OWORD *)(a1 + 672) = v25;
  *(void *)(a1 + 720) = a2;
  objc_msgSend_reconfigureIfNeededWithContext_programHashCodeRequirements_((void *)a1, v27, a2, a3);
  v86[0] = MEMORY[0x1E4F143A8];
  v86[1] = 3221225472;
  v86[2] = sub_1B64A94A0;
  v86[3] = &unk_1E6142D28;
  v86[4] = a1;
  uint64_t v35 = *(void *)(a1 + 56);
  uint64_t v36 = *(void *)(a1 + 80);
  uint64_t v37 = *(void *)(a1 + 88);
  if (*(void *)(a1 + 48)) {
    uint64_t v38 = *(void *)(a1 + 48);
  }
  else {
    uint64_t v38 = *(void *)(a1 + 80);
  }
  uint64_t v77 = v38;
  uint64_t v78 = v36;
  if (v35) {
    uint64_t v39 = v35;
  }
  else {
    uint64_t v39 = v37;
  }
  uint64_t v79 = v39;
  uint64_t v80 = v37;
  uint64_t v41 = *(void *)(a1 + 96);
  uint64_t v40 = *(void *)(a1 + 104);
  if (*(void *)(a1 + 64)) {
    uint64_t v42 = *(void *)(a1 + 64);
  }
  else {
    uint64_t v42 = *(void *)(a1 + 96);
  }
  uint64_t v81 = v42;
  uint64_t v82 = v41;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  uint64_t v43 = *(void **)(a1 + 736);
  if (v43)
  {
    BOOL v44 = objc_msgSend_updateWithComputeContext_positions_normals_tangents_(v43, v28, a1, v38, v39, v42) == 1;
    uint64_t v36 = *(void *)(a1 + 80);
    uint64_t v37 = *(void *)(a1 + 88);
    uint64_t v77 = v38;
    uint64_t v78 = v36;
    uint64_t v79 = v39;
    uint64_t v80 = v37;
    uint64_t v41 = *(void *)(a1 + 96);
    uint64_t v81 = v42;
    uint64_t v82 = v41;
  }
  else
  {
    BOOL v44 = 0;
  }
  uint64_t v45 = *(void **)(a1 + 744);
  if (v45)
  {
    if (objc_msgSend_updateWithComputeContext_positions_normals_tangents_(v45, v28, a1, v36, v37, v41) == 1) {
      BOOL v44 = 1;
    }
    uint64_t v77 = v36;
    uint64_t v79 = v37;
    uint64_t v81 = v41;
  }
  if (*(void *)(a1 + 760))
  {
    uint64_t v46 = (void *)sub_1B65E1F44(*(void *)(a1 + 16), (uint64_t)v28, v29, v30, v31, v32, v33, v34);
    uint64_t v50 = objc_msgSend_count(*(void **)(a1 + 760), v47, v48, v49);
    if (v50)
    {
      int v51 = 0;
      for (uint64_t i = 0; i != v50; ++i)
      {
        uint64_t v53 = objc_msgSend_objectAtIndexedSubscript_(*(void **)(a1 + 760), v28, i, v30);
        double v57 = sub_1B64A94D0(v53, (const char *)v86, (uint64_t)&v77, v54);
        if (v58 == 1)
        {
          BOOL v44 = 1;
          int v51 = 1;
        }
        uint64_t v59 = objc_msgSend_objectAtIndexedSubscript_(v46, v55, i, v56, v57);
        if ((objc_msgSend_requiredOutputs(v59, v60, v61, v62) & 8) != 0)
        {
          if (v53) {
            uint64_t v63 = objc_msgSend_meshForDeformedTopology(*(void **)(v53 + 24), v28, v29, v30);
          }
          else {
            uint64_t v63 = objc_msgSend_meshForDeformedTopology(0, v28, v29, v30);
          }
          uint64_t v40 = v63;
        }
      }
      LODWORD(v50) = v51;
    }
  }
  else
  {
    LODWORD(v50) = 0;
  }
  if (*(unsigned __int8 *)(a1 + 40) != *(unsigned __int8 *)(a1 + 41))
  {
    uint64_t v64 = (void **)objc_msgSend_currentComputeEncoder((void *)a1, v28, v29, v30);
    objc_msgSend_setBuffer_offset_atIndex_(*v64, v65, *(void *)(a1 + 80), 0, 0);
    objc_msgSend_setBuffer_offset_atIndex_(*v64, v66, *(void *)(a1 + 112), 0, 1);
    uint64_t v68 = *(void *)(a1 + 88);
    if (v68)
    {
      objc_msgSend_setBuffer_offset_atIndex_(*v64, v67, v68, 0, 2);
      objc_msgSend_setBuffer_offset_atIndex_(*v64, v69, *(void *)(a1 + 120), 0, 3);
    }
    uint64_t v70 = *(void *)(a1 + 96);
    if (v70)
    {
      objc_msgSend_setBuffer_offset_atIndex_(*v64, v67, v70, 0, 4);
      objc_msgSend_setBuffer_offset_atIndex_(*v64, v71, *(void *)(a1 + 128), 0, 5);
    }
    objc_msgSend_setBuffer_offset_atIndex_(*v64, v67, *(void *)(a1 + 344), 0, 6);
    objc_msgSend_setBytes_length_atIndex_(*v64, v72, a1 + 328, 4, 7);
    uint64_t v73 = sub_1B653EFB8(*(void *)(a1 + 336));
    objc_msgSend_dispatchOnVertices_vertexCount_(*v64, v74, v73, *(unsigned int *)(a1 + 328));
  }
  if (v44) {
    objc_msgSend_updateWithComputeContext_positions_normals_tangents_(*(void **)(a1 + 752), v28, a1, *(void *)(a1 + 112), *(void *)(a1 + 120), *(void *)(a1 + 128));
  }
  uint64_t v75 = *(void ***)(a1 + 728);
  if (v75) {
    objc_msgSend_resetCache(*v75, v28, v29, v30);
  }
  *a6 = v44;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(void *)(a1 + 720) = 0;
  *(void *)(a1 + 728) = 0;
  if (v50) {
    sub_1B649F73C(*(float32x4_t **)(a1 + 24), (uint64_t)v28, v29, v30, v31, v32, v33, v34);
  }
  return v40;
}

uint64_t sub_1B64A93AC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B65E1B38(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v14 = objc_msgSend_renderResourceForDeformerStack_node_dataKind_(*(void **)(*(void *)(a1 + 32) + 8), v13, (uint64_t)a2, a3, a4);
    uint64_t v21 = v14;
    if (v14)
    {
      if (*(unsigned char *)(v14 + 43)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Transform of dependency node is not available", v15, v16, v17, v18, v19, v20, (uint64_t)"[dependencyDeformerStack computeDeformedMeshReliesOnTransforms] == NO");
      }
      if (*(unsigned char *)(v21 + 44)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Frustum info for dependency node is not available", v15, v16, v17, v18, v19, v20, (uint64_t)"[dependencyDeformerStack computeDeformedMeshReliesOnFrustum] == NO");
      }
    }
    uint64_t v22 = *(void *)(a1 + 40);
    uint64_t v23 = *(unsigned __int8 *)(a1 + 48);
    v24[4] = v31;
    v24[5] = v32;
    v24[6] = v33;
    v24[0] = v27;
    v24[1] = v28;
    v24[2] = v29;
    v24[3] = v30;
    return sub_1B64A8F98(v21, v22, v23, v25, v24, v26);
  }
  return result;
}

uint64_t sub_1B64A94A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)objc_msgSend_currentComputeEncoder(*(void **)(a1 + 32), a2, a3, a4);

  return objc_msgSend_getEncoderAndResetCache(v4, v5, v6, v7);
}

double sub_1B64A94D0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    *(void *)(a1 + 416) = a2;
    long long v6 = *(_OWORD *)(a3 + 16);
    long long v7 = *(_OWORD *)(a3 + 32);
    *(_OWORD *)(a1 + 432) = *(_OWORD *)a3;
    *(_OWORD *)(a1 + 448) = v6;
    *(_OWORD *)(a1 + 464) = v7;
    *(_OWORD *)(a1 + 480) = 0u;
    *(_OWORD *)(a1 + 496) = 0u;
    *(_OWORD *)(a1 + 512) = 0u;
    unsigned int v8 = *(void **)(a1 + 16);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = sub_1B64A9698;
    v12[3] = &unk_1E6142D50;
    v12[4] = a1;
    objc_msgSend__enumerateDependencyNodesUsingBlock_(v8, a2, (uint64_t)v12, a4);
    objc_msgSend_updateWithContext_(*(void **)(a1 + 24), v9, a1, v10);
    *(void *)a3 = *(void *)(a3 + 8);
    *(void *)(a3 + 16) = *(void *)(a3 + 24);
    *(void *)(a3 + 32) = *(void *)(a3 + 40);
    double result = 0.0;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(void *)(a1 + 416) = 0;
    *(void *)(a1 + 424) = 0;
  }
  return result;
}

void sub_1B64A9698(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  __int16 v4 = a4;
  uint64_t v7 = objc_msgSend_nodeRef(a3, a2, (uint64_t)a3, a4);
  uint64_t v15 = sub_1B649F5A8(v7, v8, v9, v10, v11, v12, v13, v14);
  if (v15)
  {
    uint64_t v24 = objc_msgSend_renderResourceForDeformerStack_node_dataKind_(*(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 8), v16, v15, v7, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 41));
    if (a2 != (const char *)1)
    {
      if (!a2)
      {
        if ((v4 & 0x100) != 0)
        {
          *(void *)(*(void *)(a1 + 32) + 480) = objc_msgSend_dependencyBufferForInput_dependencyStack_(*(void **)(a1 + 32), v23, 256, v24);
          if (!*(void *)(*(void *)(a1 + 32) + 480)) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v25, v26, v27, v28, v29, v30, (uint64_t)"_currentUpdateBuffers.dependency0Positions");
          }
        }
        if ((v4 & 0x200) != 0)
        {
          *(void *)(*(void *)(a1 + 32) + 488) = objc_msgSend_dependencyBufferForInput_dependencyStack_(*(void **)(a1 + 32), v23, 512, v24);
          if (!*(void *)(*(void *)(a1 + 32) + 488)) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v31, v32, v33, v34, v35, v36, (uint64_t)"_currentUpdateBuffers.dependency0Normals");
          }
        }
        if ((v4 & 0x400) != 0)
        {
          uint64_t v37 = objc_msgSend_dependencyBufferForInput_dependencyStack_(*(void **)(a1 + 32), v23, 1024, v24);
LABEL_22:
          *(void *)(*(void *)(a1 + 32) + 496) = v37;
          if (*(void *)(*(void *)(a1 + 32) + 496)) {
            return;
          }
          uint64_t v67 = "_currentUpdateBuffers.dependency0Tangents";
LABEL_42:
          sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v38, v39, v40, v41, v42, v43, (uint64_t)v67);
          return;
        }
      }
      return;
    }
    if ((v4 & 0x800) != 0)
    {
      *(void *)(*(void *)(a1 + 32) + 504) = objc_msgSend_dependencyBufferForInput_dependencyStack_(*(void **)(a1 + 32), v23, 2048, v24);
      if (!*(void *)(*(void *)(a1 + 32) + 504)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v68, v69, v70, v71, v72, v73, (uint64_t)"_currentUpdateBuffers.dependency1Positions");
      }
    }
    if ((v4 & 0x1000) != 0)
    {
      *(void *)(*(void *)(a1 + 32) + 512) = objc_msgSend_dependencyBufferForInput_dependencyStack_(*(void **)(a1 + 32), v23, 4096, v24);
      if (!*(void *)(*(void *)(a1 + 32) + 512)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v74, v75, v76, v77, v78, v79, (uint64_t)"_currentUpdateBuffers.dependency1Normals");
      }
    }
    if ((v4 & 0x2000) == 0) {
      return;
    }
    uint64_t v80 = objc_msgSend_dependencyBufferForInput_dependencyStack_(*(void **)(a1 + 32), v23, 0x2000, v24);
LABEL_40:
    *(void *)(*(void *)(a1 + 32) + 520) = v80;
    if (*(void *)(*(void *)(a1 + 32) + 520)) {
      return;
    }
    uint64_t v67 = "_currentUpdateBuffers.dependency1Tangents";
    goto LABEL_42;
  }
  uint64_t v44 = sub_1B649F5F4(v7, (uint64_t)v16, v17, v18, v19, v20, v21, v22);
  uint64_t v52 = sub_1B63CCE68(v44, v45, v46, v47, v48, v49, v50, v51);
  uint64_t v54 = sub_1B653C844(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 8), v52, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 41));
  if (a2 == (const char *)1)
  {
    if ((v4 & 0x800) != 0)
    {
      *(void *)(*(void *)(a1 + 32) + 504) = objc_msgSend_dependencyBufferForInput_dependencyMesh_(*(void **)(a1 + 32), v53, 2048, (uint64_t)v54);
      if (!*(void *)(*(void *)(a1 + 32) + 504)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v81, v82, v83, v84, v85, v86, (uint64_t)"_currentUpdateBuffers.dependency1Positions");
      }
    }
    if ((v4 & 0x1000) != 0)
    {
      *(void *)(*(void *)(a1 + 32) + 512) = objc_msgSend_dependencyBufferForInput_dependencyMesh_(*(void **)(a1 + 32), v53, 4096, (uint64_t)v54);
      if (!*(void *)(*(void *)(a1 + 32) + 512)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v87, v88, v89, v90, v91, v92, (uint64_t)"_currentUpdateBuffers.dependency1Normals");
      }
    }
    if ((v4 & 0x2000) == 0) {
      return;
    }
    uint64_t v80 = objc_msgSend_dependencyBufferForInput_dependencyMesh_(*(void **)(a1 + 32), v53, 0x2000, (uint64_t)v54);
    goto LABEL_40;
  }
  if (!a2)
  {
    if ((v4 & 0x100) != 0)
    {
      *(void *)(*(void *)(a1 + 32) + 480) = objc_msgSend_dependencyBufferForInput_dependencyMesh_(*(void **)(a1 + 32), v53, 256, (uint64_t)v54);
      if (!*(void *)(*(void *)(a1 + 32) + 480)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v55, v56, v57, v58, v59, v60, (uint64_t)"_currentUpdateBuffers.dependency0Positions");
      }
    }
    if ((v4 & 0x200) != 0)
    {
      *(void *)(*(void *)(a1 + 32) + 488) = objc_msgSend_dependencyBufferForInput_dependencyMesh_(*(void **)(a1 + 32), v53, 512, (uint64_t)v54);
      if (!*(void *)(*(void *)(a1 + 32) + 488)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v61, v62, v63, v64, v65, v66, (uint64_t)"_currentUpdateBuffers.dependency0Normals");
      }
    }
    if ((v4 & 0x400) != 0)
    {
      uint64_t v37 = objc_msgSend_dependencyBufferForInput_dependencyMesh_(*(void **)(a1 + 32), v53, 1024, (uint64_t)v54);
      goto LABEL_22;
    }
  }
}

uint64_t sub_1B64A9C38(void *a1, const char *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = objc_msgSend_attributes(a1, a2, (uint64_t)a3, a4);
  uint64_t v10 = objc_msgSend_objectAtIndexedSubscript_(v7, v8, (uint64_t)a2, v9);
  objc_msgSend_setFormat_(v10, v11, a3[1], v12);
  objc_msgSend_setOffset_(v10, v13, a3[2], v14);
  objc_msgSend_setBufferIndex_(v10, v15, (uint64_t)(a2 + 10), v16);
  uint64_t v20 = objc_msgSend_layouts(a1, v17, v18, v19);
  uint64_t v24 = objc_msgSend_bufferIndex(v10, v21, v22, v23);
  uint64_t v27 = objc_msgSend_objectAtIndexedSubscript_(v20, v25, v24, v26);
  objc_msgSend_setStepFunction_(v27, v28, 5, v29);
  uint64_t v32 = a3[3];

  return objc_msgSend_setStride_(v27, v30, v32, v31);
}

_DWORD *sub_1B64AA09C(void *a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  if (!a1) {
    return 0;
  }
  v183.receiver = a1;
  v183.super_class = (Class)VFXMTLSmoothNormalsDeformer;
  uint64_t v8 = objc_msgSendSuper2(&v183, sel_init);
  if (!v8) {
    return 0;
  }
  uint64_t v13 = v8;
  v161 = a5;
  uint64_t v14 = sub_1B64AC5F8(a2, 0, 0, a3, v9, v10, v11, v12);
  v162 = v13;
  v13[4] = sub_1B641D8A0((uint64_t)v14, v15, v16, v17, v18, v19, v20, v21);
  CFArrayRef v29 = sub_1B64ABD08(a2, v22, v23, v24, v25, v26, v27, v28);
  unsigned __int8 v165 = sub_1B64ACE9C(a2, 0, 0, v30, v31, v32, v33, v34);
  uint64_t v41 = sub_1B64ACF7C(a2, 0, v35, v36, v37, v38, v39, v40);
  uint64_t v49 = sub_1B641D8A0((uint64_t)v41, v42, v43, v44, v45, v46, v47, v48);
  unsigned int v182 = 0;
  uint64_t v160 = sub_1B64AD1D4(a2, &v182);
  uint64_t v57 = sub_1B644805C(a2);
  uint64_t v58 = 0;
  if (!v57) {
    uint64_t v58 = sub_1B65E2DE0((uint64_t)v14, v50, v51, v52, v53, v54, v55, v56);
  }
  v168 = malloc_type_calloc(4uLL, v49, 0xF3BC1C75uLL);
  if ((uint64_t)v29 >= 1)
  {
    for (CFIndex i = 0; (const __CFArray *)i != v29; ++i)
    {
      uint64_t v65 = sub_1B64ABD78(a2, i, 0, v59, v60, v61, v62, v63);
      uint64_t v181 = 0;
      long long v179 = 0u;
      long long v180 = 0u;
      long long v178 = 0u;
      sub_1B63D11F0((uint64_t)v65, v165, v66, v67, v68, v69, v70, v71, (uint64_t)&v178);
      if ((BYTE10(v179) & 0xFA) != 0)
      {
        sub_1B63F2F54(0, @"Warning: VFXMTLSmoothNormalsDeformer can only process triangles and polygons", v72, v73, v74, v75, v76, v77, v157);
      }
      else
      {
        v176[0] = v178;
        v176[1] = v179;
        v176[2] = v180;
        uint64_t v177 = v181;
        v174[0] = MEMORY[0x1E4F143A8];
        v174[1] = 3221225472;
        v174[2] = sub_1B64AA7F0;
        v174[3] = &unk_1E6142D70;
        int v175 = v49;
        v174[4] = v58;
        v174[5] = v168;
        sub_1B63D1BEC((uint64_t *)v176, (uint64_t)v174, v72, v73, v74, v75, v76, v77);
      }
    }
  }
  if (v58 && v49)
  {
    uint64_t v78 = 0;
    do
    {
      uint64_t v79 = v58[v78];
      if (v78 != v79) {
        v168[v78] = v168[v79];
      }
      ++v78;
    }
    while (v49 != v78);
  }
  uint64_t v80 = (char *)malloc_type_malloc((4 * v49 + 4) & 0x3FFFFFFFCLL, 0x1A989224uLL);
  uint64_t v81 = v168;
  *(_DWORD *)uint64_t v80 = 0;
  uint64_t v82 = v162;
  if (v49)
  {
    int v83 = 0;
    uint64_t v84 = v80 + 4;
    uint64_t v85 = v49;
    uint64_t v86 = v168;
    do
    {
      int v87 = *v86++;
      v83 += v87;
      *v84++ = v83;
      --v85;
    }
    while (v85);
  }
  unsigned int v88 = v182;
  if (!v57) {
    unsigned int v88 = v49;
  }
  unsigned int v163 = v88;
  BOOL v167 = v88 < 0x10000;
  int v89 = *(_DWORD *)&v80[4 * v49];
  if (v88 < 0x10000) {
    char v90 = 1;
  }
  else {
    char v90 = 2;
  }
  if (v89)
  {
    char v159 = v90;
    int v166 = *(_DWORD *)&v80[4 * v49];
    unint64_t v158 = (unint64_t)(3 * v89) << v90;
    uint64_t v98 = (char *)malloc_type_calloc(v158, 1uLL, 0x368D7902uLL);
    if ((uint64_t)v29 >= 1)
    {
      for (CFIndex j = 0; (const __CFArray *)j != v29; ++j)
      {
        uint64_t v100 = sub_1B64ABD78(a2, j, 0, v93, v94, v95, v96, v97);
        uint64_t v181 = 0;
        long long v179 = 0u;
        long long v180 = 0u;
        long long v178 = 0u;
        sub_1B63D11F0((uint64_t)v100, v165, v101, v102, v103, v104, v105, v106, (uint64_t)&v178);
        if ((BYTE10(v179) & 0xFA) != 0)
        {
          sub_1B63F2F54(0, @"Warning: VFXMTLSmoothNormalsDeformer can only process triangles and polygons", v107, v108, v109, v110, v111, v112, v157);
        }
        else
        {
          v172[0] = v178;
          v172[1] = v179;
          v172[2] = v180;
          uint64_t v173 = v181;
          v169[0] = MEMORY[0x1E4F143A8];
          v169[1] = 3221225472;
          v169[2] = sub_1B64AA8BC;
          v169[3] = &unk_1E6142D90;
          v169[4] = v58;
          v169[5] = v168;
          int v170 = v166;
          BOOL v171 = v167;
          v169[6] = v80;
          v169[7] = v98;
          v169[8] = v98;
          sub_1B63D1BEC((uint64_t *)v172, (uint64_t)v169, v107, v108, v109, v110, v111, v112);
        }
      }
    }
    if (v58)
    {
      uint64_t v113 = v168;
      if (v49)
      {
        uint64_t v114 = 0;
        do
        {
          uint64_t v115 = v58[v114];
          if (v114 != v115)
          {
            if (!v113[v114])
            {
              sub_1B63F2F54(17, @"Assertion '%s' failed. splitted vertices should not have been decremented yet", v92, v93, v94, v95, v96, v97, (uint64_t)"perVertexTriangleCount[vertexIndex] > 0");
              uint64_t v113 = v168;
            }
            if (v113[v115])
            {
              sub_1B63F2F54(17, @"Assertion '%s' failed. welded vertices should have been entirely decremented", v92, v93, v94, v95, v96, v97, (uint64_t)"perVertexTriangleCount[weldedVertexIndex] == 0");
              uint64_t v113 = v168;
            }
            uint64_t v116 = (3 * *(_DWORD *)&v80[4 * v115]);
            uint64_t v117 = (3 * *(_DWORD *)&v80[4 * v114]);
            uint64_t v118 = (3 * v113[v114]);
            if (HIWORD(v163))
            {
              uint64_t v119 = &v98[4 * v117];
              size_t v120 = 4 * v118;
              uint64_t v121 = &v98[4 * v116];
            }
            else
            {
              uint64_t v119 = &v98[2 * v117];
              size_t v120 = 2 * v118;
              uint64_t v121 = &v98[2 * v116];
            }
            memcpy(v119, v121, v120);
            uint64_t v113 = v168;
          }
          ++v114;
        }
        while (v49 != v114);
      }
      free(v58);
    }
    if (v160)
    {
      uint64_t v122 = 4 * (v182 + 1);
      uint64_t v123 = (char *)malloc_type_malloc(v122, 0xEC9EA934uLL);
      int v124 = v123;
      *(_DWORD *)uint64_t v123 = 0;
      uint64_t v82 = v162;
      if (v182)
      {
        int v125 = 0;
        unint64_t v126 = 0;
        unsigned int v127 = v163;
        char v128 = v159;
        do
        {
          v125 += *(_DWORD *)&v80[4 * (*(_DWORD *)(v160 + 4 * v126) + 1)]
                - *(_DWORD *)&v80[4 * *(unsigned int *)(v160 + 4 * v126)];
          *(_DWORD *)&v123[4 * v126++ + 4] = v125;
        }
        while (v126 < v182);
        uint64_t v129 = (3 * *(_DWORD *)&v123[4 * v182]);
      }
      else
      {
        uint64_t v129 = 0;
        unsigned int v127 = v163;
        char v128 = v159;
      }
      uint64_t v135 = v129 << v128;
      uint64_t v136 = (char *)malloc_type_calloc(v129 << v128, 1uLL, 0x1F702E45uLL);
      uint64_t v140 = v136;
      if (v182)
      {
        for (unint64_t k = 0; k < v182; ++k)
        {
          uint64_t v142 = *(unsigned int *)(v160 + 4 * k);
          int v143 = *(_DWORD *)&v80[4 * (v142 + 1)];
          int v144 = *(_DWORD *)&v80[4 * v142];
          uint64_t v145 = (v143 - v144);
          unsigned int v146 = 3 * v144;
          unsigned int v147 = 3 * *(_DWORD *)&v124[4 * k];
          if (v127 >= 0x10000)
          {
            if (v143 != v144)
            {
              do
              {
                *(_DWORD *)&v136[4 * v147] = *(_DWORD *)(v57 + 4 * *(unsigned int *)&v98[4 * v146]);
                *(_DWORD *)&v136[4 * v147 + 4] = *(_DWORD *)(v57 + 4 * *(unsigned int *)&v98[4 * v146 + 4]);
                *(_DWORD *)&v136[4 * v147 + 8] = *(_DWORD *)(v57 + 4 * *(unsigned int *)&v98[4 * v146 + 8]);
                v147 += 3;
                v146 += 3;
                --v145;
              }
              while (v145);
            }
          }
          else if (v143 != v144)
          {
            do
            {
              *(_WORD *)&v136[2 * v147] = *(_DWORD *)(v57 + 4 * *(unsigned __int16 *)&v98[2 * v146]);
              *(_WORD *)&v136[2 * v147 + 2] = *(_DWORD *)(v57 + 4 * *(unsigned __int16 *)&v98[2 * v146 + 2]);
              *(_WORD *)&v136[2 * v147 + 4] = *(_DWORD *)(v57 + 4 * *(unsigned __int16 *)&v98[2 * v146 + 4]);
              v147 += 3;
              v146 += 3;
              --v145;
            }
            while (v145);
          }
        }
      }
      uint64_t v148 = objc_msgSend_currentBlitEncoder(v161, v137, v138, v139);
      *((void *)v162 + 3) = sub_1B653D738((uint64_t)a4, v124, v122, v148);
      v152 = objc_msgSend_currentBlitEncoder(v161, v149, v150, v151);
      *((void *)v162 + 4) = sub_1B653D738((uint64_t)a4, v140, v135, v152);
      free(v124);
      free(v140);
    }
    else
    {
      v130 = objc_msgSend_currentBlitEncoder(v161, v91, v92, v93);
      uint64_t v82 = v162;
      *((void *)v162 + 3) = sub_1B653D738((uint64_t)a4, v80, (4 * v49 + 4) & 0x3FFFFFFFCLL, v130);
      uint64_t v134 = objc_msgSend_currentBlitEncoder(v161, v131, v132, v133);
      *((void *)v162 + 4) = sub_1B653D738((uint64_t)a4, v98, v158, v134);
    }
    free(v98);
    uint64_t v81 = v168;
  }
  free(v81);
  free(v80);
  if (v163 >= 0x10000) {
    v155 = objc_msgSend_computePipelineStateForKernel_(a4, v153, @"unify_u32", v154);
  }
  else {
    v155 = objc_msgSend_computePipelineStateForKernel_(a4, v153, @"unify_u16", v154);
  }
  *((void *)v82 + 5) = v155;
  return v82;
}

void sub_1B64AA7F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  uint64_t v9 = (unsigned int *)a3;
  if (a4 > 2
    || (sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected vertex count", a3, a4, a5, a6, a7, a8, (uint64_t)"indicesCount >= 3"), v8))
  {
    uint64_t v11 = v8;
    do
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = v9;
      if (v12) {
        uint64_t v13 = (unsigned int *)(v12 + 4 * *v9);
      }
      uint64_t v14 = *v13;
      if (v14 >= *(_DWORD *)(a1 + 48)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. indexed index overflow", a3, a4, a5, a6, a7, a8, (uint64_t)"vertexIndex < originalVertexCount");
      }
      ++*(_DWORD *)(*(void *)(a1 + 40) + 4 * v14);
      ++v9;
      --v11;
    }
    while (v11);
  }
}

void sub_1B64AA8BC(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  if (a4 > 2
    || (sub_1B63F2F54(17, @"Assertion '%s' failed. expecting at least triangles here", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"indicesCount >= 3"), v8))
  {
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(a1 + 40);
    uint64_t v13 = v8;
    uint64_t v14 = a3;
    do
    {
      uint64_t v15 = v14;
      if (v11) {
        uint64_t v15 = (unsigned int *)(v11 + 4 * *v14);
      }
      uint64_t v16 = *v15;
      int v17 = *(_DWORD *)(v12 + 4 * v16);
      if (!v17) {
        break;
      }
      int v18 = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v16);
      int v19 = v17 - 1;
      *(_DWORD *)(v12 + 4 * v16) = v19;
      int v20 = v18 + v19;
      if ((v18 + v19) >= *(_DWORD *)(a1 + 72)) {
        break;
      }
      unsigned int v21 = *a3;
      if (*(unsigned char *)(a1 + 76))
      {
        uint64_t v22 = *(void *)(a1 + 56);
        unsigned int v23 = 3 * v20;
        *(_WORD *)(v22 + 2 * v23) = v21;
        unsigned int v24 = a3[2];
        *(_WORD *)(v22 + 2 * (v23 + 1)) = a3[1];
        *(_WORD *)(v22 + 2 * (v23 + 2)) = v24;
      }
      else
      {
        uint64_t v25 = *(void *)(a1 + 64);
        unsigned int v26 = 3 * v20;
        *(_DWORD *)(v25 + 4 * v26) = v21;
        *(_DWORD *)(v25 + 4 * (v26 + 1)) = a3[1];
        *(_DWORD *)(v25 + 4 * (v26 + 2)) = a3[2];
      }
      ++v14;
      --v13;
    }
    while (v13);
  }
}

void sub_1B64AAB0C(uint64_t a1)
{
  uint64_t valuePtr = a1;
  CFNumberRef v1 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kCFXNotificationMeshWillDie", v1, 0, 1u);
  CFRelease(v1);
}

void sub_1B64AAB70(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 144);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 112);
  if (v3)
  {
    for (uint64_t i = 0; i != 18; i += 2)
      *(_WORD *)(a1 + i + 120) = 255;
    CFRelease(v3);
    *(void *)(a1 + 112) = 0;
  }
}

void sub_1B64AABCC(uint64_t a1)
{
  uint64_t v2 = a1 + 112;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 112));
  free(*(void **)(a1 + 152));
  *(void *)(a1 + 152) = malloc_type_calloc(Count, 1uLL, 0x100004077774924uLL);

  sub_1B64AAC44(a1, v2);
}

void sub_1B64AAC44(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 18; i += 2)
    *(_WORD *)(a2 + i + 8) = 255;
  *(unsigned char *)(a1 + 200) &= ~0x80u;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)a2);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    char v8 = -1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a2, v7);
      int v17 = sub_1B641D56C((uint64_t)ValueAtIndex, v10, v11, v12, v13, v14, v15, v16);
      int v25 = v17;
      if (v17 == v8)
      {
        if (!v8 && *(unsigned char *)(a2 + 9)) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. No double position sources allowed", v19, v20, v21, v22, v23, v24, (uint64_t)"semantic != kCFXMeshSourceSemanticPosition || data->sourcesSemanticInfos[semantic].count == 0");
        }
        uint64_t v26 = a2 + 2 * v8;
        unsigned __int8 v27 = *(unsigned char *)(v26 + 9) + 1;
        *(unsigned char *)(v26 + 9) = v27;
        if (v8 != 3 && v27 >= 2u)
        {
          uint64_t v28 = sub_1B6583470(a1, v18, v19, v20, v21, v22, v23, v24);
          sub_1B641CDD4(v8);
          sub_1B63F2F54(0, @"Warning: Mesh '%@' : sources of redundant semantic '%@' will be ignored in rendering", v29, v30, v31, v32, v33, v34, v28);
        }
      }
      else
      {
        if (v17 <= v8) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh sources are not sorted correctly", v19, v20, v21, v22, v23, v24, (uint64_t)"semantic > currentSemantic");
        }
        uint64_t v35 = a2 + 2 * v25;
        int v37 = *(unsigned __int8 *)(v35 + 8);
        uint64_t v36 = (unsigned char *)(v35 + 8);
        if (v37 != 255) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh sources with same semantic non contiguous", v19, v20, v21, v22, v23, v24, (uint64_t)"data->sourcesSemanticInfos[semantic].index == -1");
        }
        *uint64_t v36 = v7;
        *(unsigned char *)(a2 + 2 * v25 + 9) = 1;
        char v8 = v25;
      }
      if (v25 == 2)
      {
        int v38 = sub_1B641DCB4((uint64_t)ValueAtIndex, v18, v19, v20, v21, v22, v23, v24);
        char v39 = *(unsigned char *)(a1 + 200);
        char v40 = v39 & 0x80;
        if (v38) {
          char v40 = 0x80;
        }
        *(unsigned char *)(a1 + 200) = v40 & 0x80 | v39 & 0x7F;
      }
      ++v7;
    }
    while (v6 != v7);
  }
}

void *sub_1B64AAE18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(a1 + 112)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh->_renderableData.sources");
  }
  if (!*(void *)(a1 + 144)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh->_renderableData.elements");
  }
  CFTypeRef v9 = *(CFTypeRef *)(a1 + 64);
  CFTypeRef v10 = *(CFTypeRef *)(a1 + 112);
  if (v9 != v10)
  {
    if (v9)
    {
      CFRelease(*(CFTypeRef *)(a1 + 64));
      *(void *)(a1 + 64) = 0;
      CFTypeRef v10 = *(CFTypeRef *)(a1 + 112);
    }
    if (v10) {
      CFTypeRef v10 = CFRetain(v10);
    }
    *(void *)(a1 + 64) = v10;
  }
  CFTypeRef v11 = *(CFTypeRef *)(a1 + 96);
  CFTypeRef v12 = *(CFTypeRef *)(a1 + 144);
  if (v11 != v12)
  {
    if (v11)
    {
      CFRelease(*(CFTypeRef *)(a1 + 96));
      *(void *)(a1 + 96) = 0;
      CFTypeRef v12 = *(CFTypeRef *)(a1 + 144);
    }
    if (v12) {
      CFTypeRef v12 = CFRetain(v12);
    }
    *(void *)(a1 + 96) = v12;
  }
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a1 + 120);
  *(_WORD *)(a1 + 88) = *(_WORD *)(a1 + 136);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 112));
  free(*(void **)(a1 + 104));
  uint64_t v14 = malloc_type_malloc(Count, 0x8524CE99uLL);
  *(void *)(a1 + 104) = v14;
  uint64_t v15 = *(const void **)(a1 + 152);

  return memcpy(v14, v15, Count);
}

void sub_1B64AAF38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 200) &= ~4u;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = sub_1B64AB0A8;
  v8[3] = &unk_1E6142DB0;
  v8[4] = a1;
  sub_1B64AAFB4(a1, 0, (uint64_t)v8, a4, a5, a6, a7, a8);
}

void sub_1B64AAFB4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v10 = a1 + 112;
  }
  else if (a2)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"__meshDataForDataKind");
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = a1 + 64;
  }
  for (uint64_t i = 0; i != 9; ++i)
  {
    uint64_t v12 = v10 + 2 * i;
    uint64_t v15 = *(char *)(v12 + 8);
    uint64_t v13 = v12 + 8;
    uint64_t v14 = v15;
    if (v15 != -1)
    {
      uint64_t v16 = *(unsigned __int8 *)(v13 + 1);
      if (*(unsigned char *)(v13 + 1))
      {
        uint64_t v17 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)v10, v14 + v17);
          (*(void (**)(uint64_t, const void *, void, uint64_t, void))(a3 + 16))(a3, ValueAtIndex, (char)i, v17, *(unsigned __int8 *)(v14 + v17 + *(void *)(v10 + 40)));
          ++v17;
        }
        while (v16 != v17);
      }
    }
  }
}

uint64_t sub_1B64AB0A8(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1B641CF90(a2);
  uint64_t v4 = *(void *)(a1 + 32);
  char v5 = *(unsigned char *)(v4 + 200);
  if (result | ((v5 & 4) >> 2)) {
    char v6 = 4;
  }
  else {
    char v6 = 0;
  }
  *(unsigned char *)(v4 + 200) = v6 | v5 & 0xFB;
  return result;
}

uint64_t sub_1B64AB0F8()
{
  if (qword_1EB995560 != -1) {
    dispatch_once(&qword_1EB995560, &unk_1F0FB5928);
  }
  return qword_1EB995568;
}

double sub_1B64AB13C()
{
  if (!qword_1EB995568)
  {
    qword_1EB995568 = sub_1B63C8D10(&qword_1EB995568);
    qword_1EB9844D8 = (uint64_t)sub_1B64AE2AC;
    double result = *(double *)&xmmword_1F0FB8948;
    unk_1EB9844F0 = xmmword_1F0FB8948;
    unk_1EB984500 = unk_1F0FB8958;
    qword_1EB984510 = qword_1F0FB8968;
    unk_1EB984518 = sub_1B64AE6B8;
  }
  return result;
}

uint64_t sub_1B64AB284()
{
  uint64_t result = -[VFXMesh __createCFObject]_0();
  *(unsigned char *)(result + 200) |= 1u;
  return result;
}

uint64_t sub_1B64AB2A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"input");
  }
  uint64_t v9 = -[VFXMesh __createCFObject]_0();
  sub_1B64AB30C(a1, v9, 0, v10, v11, v12, v13, v14);
  return v9;
}

void sub_1B64AB30C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"src");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dst");
LABEL_3:
  sub_1B64ACAA8(a1, a2, a3, a4, a5, a6, a7, a8);
  if (a3)
  {
    CFIndex v18 = (CFIndex)sub_1B64ABD08(a1, v11, v12, v13, v14, v15, v16, v17);
    CFDictionaryRef Mutable = CFArrayCreateMutable(0, v18, MEMORY[0x1E4F1D510]);
    if (v18 >= 1)
    {
      for (CFIndex i = 0; i != v18; ++i)
      {
        unsigned __int8 v27 = sub_1B64ABD78(a1, i, 0, v20, v21, v22, v23, v24);
        uint64_t v35 = (const void *)sub_1B63D0804((uint64_t)v27, v28, v29, v30, v31, v32, v33, v34);
        CFArrayAppendValue(Mutable, v35);
        CFRelease(v35);
      }
    }
    sub_1B64AD458(a2, Mutable, v19, v20, v21, v22, v23, v24);
    CFRelease(Mutable);
  }
  else
  {
    uint64_t v42 = *(const void **)(a2 + 96);
    if (v42)
    {
      CFRelease(v42);
      *(void *)(a2 + 96) = 0;
    }
    uint64_t v43 = *(const void **)(a2 + 144);
    if (v43)
    {
      CFRelease(v43);
      *(void *)(a2 + 144) = 0;
    }
    CFAllocatorRef v44 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)(a2 + 96) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFArrayRef *)(a1 + 96));
    CFArrayRef v45 = *(const __CFArray **)(a1 + 144);
    if (v45) {
      MutableCFArrayRef Copy = CFArrayCreateMutableCopy(v44, 0, v45);
    }
    else {
      MutableCFArrayRef Copy = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CFA0], 0, MEMORY[0x1E4F1D510]);
    }
    *(void *)(a2 + 144) = MutableCopy;
  }
  *(unsigned char *)(a2 + 200) = *(unsigned char *)(a2 + 200) & 0x87 | *(unsigned char *)(a1 + 200) & 0x78;

  sub_1B6583A28(a1, (CFTypeRef *)a2, v36, v37, v38, v39, v40, v41);
}

uint64_t sub_1B64AB4D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"input");
  }
  uint64_t v9 = -[VFXMesh __createCFObject]_0();
  sub_1B64AB30C(a1, v9, 1, v10, v11, v12, v13, v14);
  return v9;
}

uint64_t sub_1B64AB534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"input");
  }
  uint64_t v9 = -[VFXMesh __createCFObject]_0();
  sub_1B64AB30C(a1, v9, 1, v10, v11, v12, v13, v14);
  sub_1B64F72FC(v9, 1, v15, v16, v17, v18, v19, v20);
  sub_1B64AAE18(v9, v21, v22, v23, v24, v25, v26, v27);
  return v9;
}

void sub_1B64AB5AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v9 = *(void **)(a1 + 184);
  if (v9) {
    free(v9);
  }
  uint64_t v10 = *(void **)(a1 + 192);
  if (v10) {
    free(v10);
  }
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 200) &= ~2u;
}

uint64_t sub_1B64AB620(uint64_t a1, _OWORD *a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v11 = *(_OWORD **)(a1 + 192);
  if (!v11)
  {
    uint64_t v12 = sub_1B64AC5F8(a1, 0, 0, 0, a5, a6, a7, a8);
    float32x4_t v43 = 0u;
    if (v12
      && (uint64_t v20 = sub_1B641D478((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19), v29 = v21, v21))
    {
      uint64_t v30 = v20;
      float32x4_t v31 = 0uLL;
      if (v20)
      {
        if ((v21 & 0xFF000000000000) == 0x1000000000000)
        {
          uint64_t v32 = 0;
          float32x4_t v33 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
          v31.i64[0] = 0x80000000800000;
          v31.i64[1] = 0x80000000800000;
          do
          {
            uint64_t v34 = v20 + v32;
            v35.i64[0] = *(void *)v34;
            v35.i64[1] = *(unsigned int *)(v34 + 8);
            float32x4_t v33 = vminnmq_f32(v33, v35);
            float32x4_t v31 = vmaxnmq_f32(v31, v35);
            v32 += BYTE5(v21);
            --v29;
          }
          while (v29);
        }
        else
        {
          unsigned int v36 = 0;
          int v37 = BYTE4(v21);
          float32x4_t v33 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
          int v38 = BYTE5(v21);
          v31.i64[0] = 0x80000000800000;
          v31.i64[1] = 0x80000000800000;
          do
          {
            float32x4_t v41 = v31;
            float32x4_t v44 = v33;
            *(double *)v28.i64 = sub_1B65D6198(v37, (const float *)(v30 + v36), v22, v23, v24, v25, v26, v27, v28, v33.f32[0], v31.f32[0]);
            float32x4_t v33 = vminnmq_f32(v44, v28);
            float32x4_t v31 = vmaxnmq_f32(v41, v28);
            v36 += v38;
            --v29;
          }
          while (v29);
        }
        float32x4_t v43 = v33;
      }
    }
    else
    {
      float32x4_t v31 = 0uLL;
    }
    float32x4_t v42 = v31;
    uint64_t v39 = sub_1B63CA51C(0x20uLL);
    *(void *)(a1 + 192) = v39;
    *uint64_t v39 = v43;
    *(float32x4_t *)(*(void *)(a1 + 192) + 16) = v42;
    uint64_t v11 = *(_OWORD **)(a1 + 192);
  }
  *a2 = *v11;
  *a3 = *(_OWORD *)(*(void *)(a1 + 192) + 16);
  return 1;
}

uint64_t sub_1B64AB7A0(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v10 = *(_OWORD **)(a1 + 184);
  if (v10) {
    goto LABEL_23;
  }
  long long v45 = 0uLL;
  v48.i32[2] = 0;
  v48.i64[0] = 0;
  v47.i32[2] = 0;
  v47.i64[0] = 0;
  sub_1B64AB620(a1, &v48, &v47, a4, a5, a6, a7, a8);
  v11.i64[0] = 0x3F0000003F000000;
  v11.i64[1] = 0x3F0000003F000000;
  float32x4_t v44 = vmulq_f32(vaddq_f32(v47, v48), v11);
  float32x4_t v46 = v44;
  uint64_t v16 = sub_1B64AC5F8(a1, 0, 0, 0, v12, v13, v14, v15);
  if (v16)
  {
    uint64_t result = sub_1B641D478((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23);
    if (!result) {
      return result;
    }
    uint64_t v29 = result;
    uint64_t v30 = v25;
    if ((v25 & 0xFF000000000000) == 0x1000000000000)
    {
      if (v25)
      {
        unsigned int v31 = 0;
        float v32 = 0.0;
        do
        {
          uint64_t v33 = result + v31;
          v26.i64[0] = *(void *)v33;
          v26.i32[2] = *(_DWORD *)(v33 + 8);
          float32x4_t v34 = vsubq_f32(v26, v44);
          float32x4_t v35 = vmulq_f32(v34, v34);
          float32x4_t v26 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1)));
          if (v26.f32[0] > v32) {
            float v32 = v26.f32[0];
          }
          v31 += BYTE5(v25);
          --v30;
        }
        while (v30);
        goto LABEL_21;
      }
    }
    else if (v25)
    {
      unsigned int v37 = 0;
      int v38 = BYTE4(v25);
      int v39 = BYTE5(v25);
      float v32 = 0.0;
      do
      {
        *(double *)v40.i64 = sub_1B65D6198(v38, (const float *)(v29 + v37), v18, v19, v20, v21, v22, v23, v26, v27.f32[0], v28.f32[0]);
        float32x4_t v41 = vsubq_f32(v40, v44);
        float32x4_t v42 = vmulq_f32(v41, v41);
        float32x4_t v27 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1);
        float32x4_t v28 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2);
        float32x4_t v26 = vaddq_f32(v28, vaddq_f32(v42, v27));
        if (v26.f32[0] > v32) {
          float v32 = v26.f32[0];
        }
        v37 += v39;
        --v30;
      }
      while (v30);
      goto LABEL_21;
    }
    float v32 = 0.0;
LABEL_21:
    float v36 = sqrtf(v32);
    goto LABEL_22;
  }
  float v36 = 0.0;
LABEL_22:
  sub_1B6403B08(&v45, (long long *)&v46, v18, v19, v20, v21, v22, v23, v36);
  float32x4_t v43 = sub_1B63CA51C(0x10uLL);
  *(void *)(a1 + 184) = v43;
  *float32x4_t v43 = v45;
  uint64_t v10 = *(_OWORD **)(a1 + 184);
LABEL_23:
  *a2 = *v10;
  return 1;
}

uint64_t sub_1B64AB970(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(result + 200) & 2) == 0)
  {
    uint64_t v8 = result;
    uint64_t result = (uint64_t)sub_1B64ABD08(result, a2, a3, a4, a5, a6, a7, a8);
    if (result >= 1)
    {
      uint64_t v14 = result;
      CFIndex v15 = 0;
      int32x4_t v59 = vdupq_n_s32(0x7F7FFFFFu);
      do
      {
        uint64_t v16 = (float32x4_t *)sub_1B64ABD78(v8, v15, 0, v9, v10, v11, v12, v13);
        uint64_t v71 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v68 = 0u;
        sub_1B63D11F0((uint64_t)v16, 0, v17, v18, v19, v20, v21, v22, (uint64_t)&v68);
        if ((void)v68 && (float32x4_t *)sub_1B63D19E8((uint64_t)v16) == v16)
        {
          uint64_t result = (uint64_t)sub_1B64AC5F8(v8, 0, 0, 0, v23, v24, v25, v26);
          if (result)
          {
            uint64_t result = sub_1B641D478(result, v27, v28, v9, v10, v11, v12, v13);
            if (result)
            {
              uint64_t v31 = result;
              uint64_t v32 = v29;
              uint64_t v33 = sub_1B63D0CA8((uint64_t)v16, v29, v30, v9, v10, v11, v12, v13);
              uint64_t v41 = v33;
              v42.i64[0] = 0x80000000800000;
              v42.i64[1] = 0x80000000800000;
              if ((v32 & 0xFF000000000000) == 0x1000000000000)
              {
                switch(BYTE11(v69))
                {
                  case 4u:
                    float32x4_t v43 = (float32x4_t)v59;
                    if (v33 >= 1)
                    {
                      uint64_t v49 = (_DWORD *)(v68 + 4 * *((void *)&v70 + 1));
                      float32x4_t v43 = (float32x4_t)v59;
                      do
                      {
                        uint64_t v50 = v31 + *v49 * BYTE5(v32);
                        v51.i64[0] = *(void *)v50;
                        v51.i64[1] = *(unsigned int *)(v50 + 8);
                        float32x4_t v43 = vminnmq_f32(v43, v51);
                        float32x4_t v42 = vmaxnmq_f32(v42, v51);
                        v49 += v71;
                        --v41;
                      }
                      while (v41);
                    }
                    goto LABEL_43;
                  case 2u:
                    float32x4_t v43 = (float32x4_t)v59;
                    if (v33 >= 1)
                    {
                      uint64_t v52 = (unsigned __int16 *)(v68 + 2 * *((void *)&v70 + 1));
                      float32x4_t v43 = (float32x4_t)v59;
                      do
                      {
                        unint64_t v53 = v31 + BYTE5(v32) * (unint64_t)*v52;
                        v54.i64[0] = *(void *)v53;
                        v54.i64[1] = *(unsigned int *)(v53 + 8);
                        float32x4_t v43 = vminnmq_f32(v43, v54);
                        float32x4_t v42 = vmaxnmq_f32(v42, v54);
                        v52 += v71;
                        --v41;
                      }
                      while (v41);
                    }
                    goto LABEL_43;
                  case 1u:
                    float32x4_t v43 = (float32x4_t)v59;
                    if (v33 >= 1)
                    {
                      float32x4_t v44 = (unsigned __int8 *)(v68 + *((void *)&v70 + 1));
                      float32x4_t v43 = (float32x4_t)v59;
                      do
                      {
                        unint64_t v45 = v31 + BYTE5(v32) * (unint64_t)*v44;
                        v46.i64[0] = *(void *)v45;
                        v46.i64[1] = *(unsigned int *)(v45 + 8);
                        float32x4_t v43 = vminnmq_f32(v43, v46);
                        float32x4_t v42 = vmaxnmq_f32(v42, v46);
                        v44 += v71;
                        --v41;
                      }
                      while (v41);
                    }
                    goto LABEL_43;
                }
              }
              else
              {
                switch(BYTE11(v69))
                {
                  case 4u:
                    float32x4_t v43 = (float32x4_t)v59;
                    if (v33 >= 1)
                    {
                      uint64_t v55 = 0;
                      uint64_t v56 = v68;
                      float32x4_t v43 = (float32x4_t)v59;
                      do
                      {
                        float32x4_t v61 = v43;
                        float32x4_t v65 = v42;
                        *(double *)v40.i64 = sub_1B65D6198(BYTE4(v32), (const float *)(v31+ *(_DWORD *)(v56 + 4 * (*((void *)&v70 + 1) + v71 * v55))* BYTE5(v32)), v34, v35, v36, v37, v38, v39, v40, v42.f32[0], v43.f32[0]);
                        float32x4_t v43 = vminnmq_f32(v61, v40);
                        float32x4_t v42 = vmaxnmq_f32(v65, v40);
                        ++v55;
                      }
                      while (v41 != v55);
                    }
                    goto LABEL_43;
                  case 2u:
                    float32x4_t v43 = (float32x4_t)v59;
                    if (v33 >= 1)
                    {
                      uint64_t v57 = 0;
                      uint64_t v58 = v68;
                      float32x4_t v43 = (float32x4_t)v59;
                      do
                      {
                        float32x4_t v62 = v43;
                        float32x4_t v66 = v42;
                        *(double *)v40.i64 = sub_1B65D6198(BYTE4(v32), (const float *)(v31+ BYTE5(v32)* (unint64_t)*(unsigned __int16 *)(v58 + 2 * (*((void *)&v70 + 1) + v71 * v57))), v34, v35, v36, v37, v38, v39, v40, v42.f32[0], v43.f32[0]);
                        float32x4_t v43 = vminnmq_f32(v62, v40);
                        float32x4_t v42 = vmaxnmq_f32(v66, v40);
                        ++v57;
                      }
                      while (v41 != v57);
                    }
                    goto LABEL_43;
                  case 1u:
                    float32x4_t v43 = (float32x4_t)v59;
                    if (v33 >= 1)
                    {
                      uint64_t v47 = 0;
                      uint64_t v48 = v68;
                      float32x4_t v43 = (float32x4_t)v59;
                      do
                      {
                        float32x4_t v60 = v43;
                        float32x4_t v64 = v42;
                        *(double *)v40.i64 = sub_1B65D6198(BYTE4(v32), (const float *)(v31+ BYTE5(v32)* (unint64_t)*(unsigned __int8 *)(v48 + *((void *)&v70 + 1) + v71 * v47)), v34, v35, v36, v37, v38, v39, v40, v42.f32[0], v43.f32[0]);
                        float32x4_t v43 = vminnmq_f32(v60, v40);
                        float32x4_t v42 = vmaxnmq_f32(v64, v40);
                        ++v47;
                      }
                      while (v41 != v47);
                    }
                    goto LABEL_43;
                }
              }
              float32x4_t v43 = (float32x4_t)v59;
LABEL_43:
              float32x4_t v63 = v43;
              float32x4_t v67 = v42;
              v16[11] = v43;
              v16[12] = v42;
              uint64_t result = (uint64_t)sub_1B64AD364(v8, v15);
              if (result)
              {
                *(float32x4_t *)(result + 176) = v63;
                *(float32x4_t *)(result + 192) = v67;
              }
            }
          }
        }
        else
        {
          v16[11] = 0u;
          v16[12] = 0u;
          uint64_t result = (uint64_t)sub_1B64AD364(v8, v15);
          if (result)
          {
            *(_OWORD *)(result + 176) = 0u;
            *(_OWORD *)(result + 192) = 0u;
          }
        }
        ++v15;
      }
      while (v15 != v14);
    }
    *(unsigned char *)(v8 + 200) |= 2u;
  }
  return result;
}

CFArrayRef sub_1B64ABD08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 96);
  if (result)
  {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

const void *sub_1B64ABD78(uint64_t a1, CFIndex idx, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  if (!*(void *)(a1 + 96)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh->_originalData.elements");
  }
  if (v8 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    CFArrayRef v11 = *(const __CFArray **)(a1 + 144);
  }
  else
  {
    if (v8)
    {
      sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"CFXMeshGetElementAtIndex");
      return 0;
    }
    CFArrayRef v11 = *(const __CFArray **)(a1 + 96);
  }

  return CFArrayGetValueAtIndex(v11, idx);
}

void sub_1B64ABE60(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  if (v8 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v12 = (CFArrayRef *)(a1 + 112);
  }
  else if (v8)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"__meshDataForDataKind");
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = (CFArrayRef *)(a1 + 64);
  }
  uint64_t v13 = (char *)v12 + 2 * a2;
  uint64_t v16 = v13[8];
  CFIndex v15 = v13 + 8;
  uint64_t v14 = v16;
  if (v16 != -1 && v15[1] > a3)
  {
    CFIndex v17 = v14 + a3;
    CFIndex Count = CFArrayGetCount(*v12);
    if (v17 >= Count) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh sources are malformed", v18, v19, v20, v21, v22, v23, (uint64_t)"sourceIndex < oldSourceCount");
    }
    CFArrayRemoveValueAtIndex(*v12, v17);
    uint64_t v25 = *(void **)(a1 + 152);
    if (v25)
    {
      free(v25);
      *(void *)(a1 + 152) = 0;
    }
    if (v8)
    {
      sub_1B64AAC44(a1, (uint64_t)v12);
    }
    else
    {
      if (Count - 1 > v17)
      {
        do
        {
          *(unsigned char *)(*(void *)(a1 + 104) + v17) = *(unsigned char *)(*(void *)(a1 + 104) + v17 + 1);
          ++v17;
        }
        while (Count - 1 != v17);
      }
      sub_1B64AAC44(a1, (uint64_t)v12);
      sub_1B64AAF38(a1, v26, v27, v28, v29, v30, v31, v32);
      sub_1B64AAB70(a1);
    }
    sub_1B64AAB0C(a1);
  }
}

uint64_t sub_1B64AC000(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64AC008(a1, a2, a3, a4, 0, a6, a7, a8);
}

uint64_t sub_1B64AC008(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a4;
  char v10 = a3;
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  if (!a2) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
LABEL_4:
  if (a5 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v13 = (CFArrayRef *)(a1 + 112);
  }
  else if (a5)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"__meshDataForDataKind");
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v13 = (CFArrayRef *)(a1 + 64);
  }
  int v14 = sub_1B641D56C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  int v19 = v14;
  if (v14)
  {
    unsigned __int8 v20 = v14;
    if ((v14 & 0x80000000) == 0) {
      goto LABEL_17;
    }
LABEL_19:
    CFIndex v34 = 0;
  }
  else
  {
    if (sub_1B64AC5F8(a1, 0, 0, a5, v15, v16, v17, v18))
    {
      sub_1B63F2F54(0, @"Warning: Can't add two position sources", v22, v23, v24, v25, v26, v27, v45);
      return -1;
    }
    sub_1B64AB5AC(a1, v21, v22, v23, v24, v25, v26, v27);
    unsigned __int8 v20 = v19;
LABEL_17:
    while (1)
    {
      uint64_t v29 = (char *)v13 + 2 * v20;
      uint64_t v32 = v29[8];
      uint64_t v30 = v29 + 8;
      uint64_t v31 = v32;
      if (v32 != -1) {
        break;
      }
      int v33 = (char)v20--;
      if (v33 < 1) {
        goto LABEL_19;
      }
    }
    CFIndex v34 = v30[1] + v31;
  }
  CFIndex Count = CFArrayGetCount(*v13);
  CFArrayInsertValueAtIndex(*v13, v34, a2);
  if (!a5)
  {
    uint64_t v36 = *(void **)(a1 + 152);
    if (v36)
    {
      free(v36);
      *(void *)(a1 + 152) = 0;
    }
    uint64_t v37 = malloc_type_realloc(*(void **)(a1 + 104), Count + 1, 0x7E1412FFuLL);
    *(void *)(a1 + 104) = v37;
    if (Count > v34)
    {
      do
      {
        *(unsigned char *)(*(void *)(a1 + 104) + Count) = *(unsigned char *)(*(void *)(a1 + 104) + Count - 1);
        --Count;
      }
      while (Count > v34);
      uint64_t v37 = *(unsigned char **)(a1 + 104);
    }
    v37[v34] = v10;
    sub_1B64AAC44(a1, (uint64_t)v13);
    sub_1B64AAF38(a1, v38, v39, v40, v41, v42, v43, v44);
    sub_1B64AAB70(a1);
    if (!v9) {
      return *((unsigned __int8 *)v13 + 2 * v19 + 9) - 1;
    }
    goto LABEL_23;
  }
  sub_1B64AABCC(a1);
  if (v9) {
LABEL_23:
  }
    sub_1B64AAB0C(a1);
  return *((unsigned __int8 *)v13 + 2 * v19 + 9) - 1;
}

uint64_t sub_1B64AC234(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v9 = a4;
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
    if (a2)
    {
LABEL_3:
      if (!v9) {
        goto LABEL_9;
      }
      goto LABEL_7;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  if (!v9) {
    goto LABEL_9;
  }
LABEL_7:
  if (v8 == 1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Renderable data kind must not give a channel", a3, a4, a5, a6, a7, a8, (uint64_t)"(dataKind != kCFXMeshDataKindRenderable) || (channel == kCFXSharedRenderableIndexChannel)");
LABEL_12:
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v13 = a1 + 112;
    goto LABEL_13;
  }
LABEL_9:
  if (v8 == 1) {
    goto LABEL_12;
  }
  if (v8)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"__meshDataForDataKind");
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v13 = a1 + 64;
  }
LABEL_13:
  int v14 = sub_1B641D56C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  int v21 = v14;
  uint64_t v22 = v13 + 2 * v14;
  uint64_t v25 = *(char *)(v22 + 8);
  uint64_t v24 = v22 + 8;
  uint64_t v23 = v25;
  if (v25 != -1 && *(unsigned __int8 *)(v24 + 1) > a3)
  {
    CFIndex v26 = v23 + a3;
    CFArraySetValueAtIndex(*(CFMutableArrayRef *)v13, v26, a2);
    if (v9 != 255) {
      *(unsigned char *)(*(void *)(v13 + 40) + v26) = v9;
    }
    if (v8) {
      goto LABEL_40;
    }
    goto LABEL_37;
  }
  if (v9 == 255)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. need to provide a valid channel index when adding a new source", v15, v16, v17, v18, v19, v20, (uint64_t)"channel != kAutomaticChannelIndex");
    if (v21 < 0)
    {
LABEL_26:
      CFIndex v40 = 0;
      goto LABEL_27;
    }
  }
  else if (v14 < 0)
  {
    goto LABEL_26;
  }
  unsigned __int8 v34 = v21;
  while (1)
  {
    uint64_t v35 = v13 + 2 * v34;
    uint64_t v38 = *(char *)(v35 + 8);
    uint64_t v37 = v35 + 8;
    uint64_t v36 = v38;
    if (v38 != -1) {
      break;
    }
    int v39 = (char)v34--;
    if (v39 < 1) {
      goto LABEL_26;
    }
  }
  uint64_t v42 = *(unsigned __int8 *)(v37 + 1);
  if (v42 < a3) {
    return 0;
  }
  CFIndex v40 = v42 + v36;
LABEL_27:
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)v13);
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)v13, v40, a2);
  if (!v8)
  {
    uint64_t v44 = *(void **)(a1 + 152);
    if (v44)
    {
      free(v44);
      *(void *)(a1 + 152) = 0;
    }
    uint64_t v45 = malloc_type_realloc(*(void **)(a1 + 104), Count + 1, 0x7E1412FFuLL);
    *(void *)(a1 + 104) = v45;
    if (Count > v40)
    {
      do
      {
        *(unsigned char *)(*(void *)(a1 + 104) + Count) = *(unsigned char *)(*(void *)(a1 + 104) + Count - 1);
        --Count;
      }
      while (Count > v40);
      uint64_t v45 = *(unsigned char **)(a1 + 104);
    }
    v45[v40] = v9;
    sub_1B64AAC44(a1, v13);
LABEL_37:
    sub_1B64AAF38(a1, v27, v28, v29, v30, v31, v32, v33);
    if (!v21) {
      sub_1B64AB5AC(a1, v46, v47, v48, v49, v50, v51, v52);
    }
    sub_1B64AAB70(a1);
    goto LABEL_40;
  }
  sub_1B64AABCC(a1);
LABEL_40:
  sub_1B64AAB0C(a1);
  return 1;
}

uint64_t sub_1B64AC4C8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64AC234(a1, a2, a3, a4, 0, a6, a7, a8);
}

uint64_t sub_1B64AC4D0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64AC234(a1, a2, a3, 0, 1, a6, a7, a8);
}

uint64_t sub_1B64AC4DC(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  if (!a2) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
LABEL_4:
  if (v8 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    CFArrayRef v11 = (CFArrayRef *)(a1 + 112);
  }
  else if (v8)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"__meshDataForDataKind");
    CFArrayRef v11 = 0;
  }
  else
  {
    CFArrayRef v11 = (CFArrayRef *)(a1 + 64);
  }
  uint64_t v12 = (char *)v11 + 2 * (int)sub_1B641D56C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = v12[8];
  uint64_t v13 = v12 + 8;
  uint64_t v14 = v15;
  if (v15 == -1) {
    return -1;
  }
  uint64_t v16 = v13[1];
  if (!v13[1]) {
    return -1;
  }
  uint64_t v17 = 0;
  while (CFArrayGetValueAtIndex(*v11, v14 + v17) != a2)
  {
    if (v16 == ++v17) {
      return -1;
    }
  }
  return v17;
}

const void *sub_1B64AC5F8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if (a4 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v12 = (const __CFArray **)(a1 + 112);
    if (!a1) {
      goto LABEL_8;
    }
  }
  else if (a4)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"__meshDataForDataKind");
    uint64_t v12 = 0;
    if (!a1) {
LABEL_8:
    }
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  else
  {
    uint64_t v12 = (const __CFArray **)(a1 + 64);
    if (!a1) {
      goto LABEL_8;
    }
  }
  if (v8 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v13 = (CFArrayRef *)(a1 + 112);
  }
  else if (v8)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"__meshDataForDataKind");
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v13 = (CFArrayRef *)(a1 + 64);
  }
  uint64_t v14 = (char *)v13 + 2 * a2;
  uint64_t v17 = v14[8];
  uint64_t v16 = v14 + 8;
  uint64_t v15 = v17;
  if (v17 == -1 || v16[1] <= a3) {
    return 0;
  }
  CFIndex v18 = v15 + a3;
  if (v18 >= CFArrayGetCount(*v13)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh sources are malformed", v19, v20, v21, v22, v23, v24, (uint64_t)"sourceIndex < CFArrayGetCount(meshData->sources)");
  }
  if (v18 == -1) {
    return 0;
  }
  CFArrayRef v25 = *v12;

  return CFArrayGetValueAtIndex(v25, v18);
}

BOOL sub_1B64AC77C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  int v9 = a2;
  if (a3 == 1)
  {
    if (a4) {
      sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    }
    CFArrayRef v11 = (void *)(a1 + 112);
  }
  else
  {
    if (a3) {
      sub_1B6E307D0(a1, a2, a3, a4, a5, a6, a7, a8);
    }
    CFArrayRef v11 = (void *)(a1 + 64);
  }
  if (!*v11) {
    return 0;
  }
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  if (v8 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v12 = (CFArrayRef *)(a1 + 112);
  }
  else
  {
    uint64_t v12 = (CFArrayRef *)(a1 + 64);
  }
  uint64_t v14 = (char *)v12 + 2 * v9;
  CFIndex v17 = v14[8];
  uint64_t v15 = v14 + 8;
  CFIndex v16 = v17;
  if (v17 != -1)
  {
    if (v15[1])
    {
      if (CFArrayGetCount(*v12) <= v16) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh sources are malformed", v18, v19, v20, v21, v22, v23, (uint64_t)"sourceIndex < CFArrayGetCount(meshData->sources)");
      }
    }
    else
    {
      CFIndex v16 = -1;
    }
  }
  return v16 != -1;
}

void sub_1B64AC8AC(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
LABEL_3:
  uint64_t v10 = sub_1B64AC4DC(a1, a2, 0, a4, a5, a6, a7, a8);
  if (v10 != -1)
  {
    uint64_t v18 = v10;
    int v19 = sub_1B641D56C((uint64_t)a2, v11, v12, v13, v14, v15, v16, v17);
    sub_1B64ABE60(a1, v19, v18, 0, v20, v21, v22, v23);
  }
}

const void *sub_1B64AC980(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  while (1)
  {
    CFArrayRef result = sub_1B64AC5F8(a1, a2, 0, 0, a5, a6, a7, a8);
    if (!result) {
      break;
    }
    sub_1B64ABE60(a1, a2, 0, 0, v11, v12, v13, v14);
  }
  return result;
}

void sub_1B64AC9FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  CFArrayRef v9 = *(const __CFArray **)(a1 + 64);
  if (v9)
  {
    CFIndex Count = CFArrayGetCount(v9);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0; i != v11; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
        uint64_t v14 = (const void *)ValueAtIndex[9];
        if (v14 && (ValueAtIndex[11] & 4) == 0 && !ValueAtIndex[10])
        {
          CFRelease(v14);
          ValueAtIndex[9] = 0;
        }
      }
    }
  }
}

void sub_1B64ACAA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"src");
  if (!a2) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dst");
LABEL_4:
  long long v11 = *(_OWORD *)(a1 + 72);
  *(_WORD *)(a2 + 88) = *(_WORD *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v11;
  long long v12 = *(_OWORD *)(a1 + 120);
  *(_WORD *)(a2 + 136) = *(_WORD *)(a1 + 136);
  *(_OWORD *)(a2 + 120) = v12;
  uint64_t v13 = *(const void **)(a2 + 64);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a2 + 64) = 0;
  }
  uint64_t v14 = *(const void **)(a2 + 112);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a2 + 112) = 0;
  }
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(void *)(a2 + 64) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFArrayRef *)(a1 + 64));
  CFArrayRef v16 = *(const __CFArray **)(a1 + 112);
  if (v16) {
    MutableCFArrayRef Copy = CFArrayCreateMutableCopy(v15, 0, v16);
  }
  else {
    MutableCFArrayRef Copy = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CFA0], 0, MEMORY[0x1E4F1D510]);
  }
  *(void *)(a2 + 112) = MutableCopy;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  CFArrayRef v19 = *(const __CFArray **)(a1 + 112);
  if (v19)
  {
    CFIndex v20 = CFArrayGetCount(v19);
    if (!v8) {
      goto LABEL_23;
    }
  }
  else
  {
    CFIndex v20 = 0;
    if (!v8) {
      goto LABEL_23;
    }
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
      uint64_t v23 = (const void *)sub_1B641E0A8((uint64_t)ValueAtIndex);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a2 + 64), i, v23);
      CFRelease(v23);
    }
  }
  if (v20 >= 1)
  {
    for (CFIndex j = 0; j != v20; ++j)
    {
      CFArrayRef v25 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 112), j);
      CFIndex v26 = (const void *)sub_1B641E0A8((uint64_t)v25);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a2 + 112), j, v26);
      CFRelease(v26);
    }
  }
LABEL_23:
  uint64_t v27 = *(const void **)(a1 + 104);
  free(*(void **)(a2 + 104));
  uint64_t v28 = malloc_type_calloc(Count, 1uLL, 0x100004077774924uLL);
  *(void *)(a2 + 104) = v28;
  if (v27) {
    memcpy(v28, v27, Count);
  }
  uint64_t v29 = *(const void **)(a1 + 152);
  free(*(void **)(a2 + 152));
  uint64_t v30 = malloc_type_calloc(v20, 1uLL, 0x100004077774924uLL);
  *(void *)(a2 + 152) = v30;
  if (v29) {
    memcpy(v30, v29, v20);
  }
  *(_DWORD *)(a2 + 160) = *(_DWORD *)(a1 + 160);
  uint64_t v31 = *(unsigned int *)(a1 + 160);
  if (v31)
  {
    size_t v32 = 4 * v31;
    uint64_t v33 = malloc_type_realloc(*(void **)(a2 + 168), 4 * v31, 0xF0AD4153uLL);
    *(void *)(a2 + 168) = v33;
    memcpy(v33, *(const void **)(a1 + 168), v32);
  }
  else
  {
    free(*(void **)(a2 + 168));
    *(void *)(a2 + 168) = 0;
  }
  if (*(void *)(a1 + 176))
  {
    uint64_t v38 = sub_1B64AC5F8(a1, 0, 0, 0, v34, v35, v36, v37);
    size_t v46 = 4 * sub_1B641D8A0((uint64_t)v38, v39, v40, v41, v42, v43, v44, v45);
    uint64_t v47 = malloc_type_realloc(*(void **)(a2 + 176), v46, 0xB0799675uLL);
    *(void *)(a2 + 176) = v47;
    memcpy(v47, *(const void **)(a1 + 176), v46);
    if (!v8) {
      return;
    }
  }
  else
  {
    free(*(void **)(a2 + 176));
    *(void *)(a2 + 176) = 0;
    if (!v8) {
      return;
    }
  }

  sub_1B64AD02C(a1, a2);
}

CFIndex sub_1B64ACDD4(uint64_t a1, void *a2)
{
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (result)
  {
    char v5 = *(unsigned __int8 **)(a1 + 104);
    uint64_t v6 = *v5;
    if (result < 2)
    {
LABEL_6:
      if (a2) {
        *a2 = v6;
      }
      return 1;
    }
    else
    {
      CFIndex v7 = result - 1;
      int v8 = v5 + 1;
      while (1)
      {
        int v9 = *v8++;
        if (v9 != v6) {
          return 0;
        }
        if (!--v7) {
          goto LABEL_6;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1B64ACE44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 104);
  if (!v9)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh->_originalData.sourceChannels");
    uint64_t v9 = *(void *)(a1 + 104);
  }
  return *(unsigned __int8 *)(v9 + a2);
}

uint64_t sub_1B64ACE9C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v11 = a1 + 2 * a2;
  uint64_t v14 = *(char *)(v11 + 72);
  uint64_t v13 = v11 + 72;
  uint64_t v12 = v14;
  if (v14 == -1 || *(unsigned __int8 *)(v13 + 1) <= a3) {
    goto LABEL_8;
  }
  uint64_t v15 = v12 + a3;
  if (v12 + a3 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 64))) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh sources are malformed", v16, v17, v18, v19, v20, v21, (uint64_t)"sourceIndex < CFArrayGetCount(meshData->sources)");
  }
  if (v15 == -1)
  {
LABEL_8:
    sub_1B641CDD4(a2);
    sub_1B63F2F54(17, @"Assertion '%s' failed. Could not find source with semantic %@ at index %d", v22, v23, v24, v25, v26, v27, (uint64_t)"sourceIndex != kCFNotFound");
    uint64_t v15 = -1;
  }
  return *(unsigned __int8 *)(*(void *)(a1 + 104) + v15);
}

const void *sub_1B64ACF7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64AC5F8(a1, 0, 0, a2, a5, a6, a7, a8);
}

CFArrayRef sub_1B64ACF8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  if (v8 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    uint64_t v10 = (const __CFArray **)(a1 + 112);
  }
  else
  {
    if (v8) {
      sub_1B6E307D0(a1, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v10 = (const __CFArray **)(a1 + 64);
  }
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  CFArrayRef v12 = *v10;

  return CFArrayCreateCopy(v11, v12);
}

uint64_t sub_1B64AD020(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(a1 + 2 * a2 + 73);
}

void sub_1B64AD02C(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v6);
      uint64_t v15 = sub_1B6536C44((uint64_t)ValueAtIndex, v8, v9, v10, v11, v12, v13, v14);
      if (!v15) {
        goto LABEL_17;
      }
      uint64_t v16 = *(const void **)(v15 + 16);
      if (v16 == ValueAtIndex) {
        goto LABEL_17;
      }
      CFIndex v17 = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
      if (v17 < 1) {
        break;
      }
      CFIndex v24 = v17;
      if (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 0) == v16)
      {
        CFIndex v28 = 0;
      }
      else
      {
        CFIndex v25 = 1;
        while (1)
        {
          CFIndex v26 = v25;
          if (v24 == v25) {
            break;
          }
          uint64_t v27 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), v25);
          CFIndex v25 = v26 + 1;
          if (v27 == v16)
          {
            CFIndex v28 = v26;
            goto LABEL_13;
          }
        }
        CFIndex v28 = 0;
LABEL_13:
        if (v26 >= v24) {
          break;
        }
      }
      uint64_t v29 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 64), v6);
      uint64_t v37 = sub_1B6536C44((uint64_t)v29, v30, v31, v32, v33, v34, v35, v36);
      uint64_t v38 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 64), v28);
      sub_1B6534974(v37, (uint64_t)v38);
LABEL_17:
      if (++v6 == v5) {
        return;
      }
    }
    if ((byte_1E9DDAF48 & 1) == 0)
    {
      byte_1E9DDAF48 = 1;
      sub_1B63F2F54(16, @"Error: __CFXMeshCopy - unable to resolve interleaved mesh", v18, v19, v20, v21, v22, v23, v39);
    }
    goto LABEL_17;
  }
}

uint64_t sub_1B64AD17C(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t result = 0;
  uint64_t v4 = a1 + 73;
  do
  {
    result += *(unsigned __int8 *)(v4 + v2);
    v2 += 2;
  }
  while (v2 != 18);
  return result;
}

uint64_t sub_1B64AD1A4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200) >> 7;
}

BOOL sub_1B64AD1B0(uint64_t a1, int a2)
{
  return *(unsigned char *)(a1 + 2 * a2 + 73) != 0;
}

const void *sub_1B64AD1C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64AC5F8(a1, 1, 0, a2, a5, a6, a7, a8);
}

uint64_t sub_1B64AD1D4(uint64_t a1, _DWORD *a2)
{
  if (a2) {
    *a2 = *(_DWORD *)(a1 + 160);
  }
  return *(void *)(a1 + 168);
}

void sub_1B64AD1E8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  *(unsigned char *)(a1 + 200) &= ~2u;
  sub_1B64AAB70(a1);
  uint64_t v10 = *(__CFArray **)(a1 + 96);

  CFArrayAppendValue(v10, a2);
}

CFIndex sub_1B64AD260(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  if (!*(void *)(a1 + 96)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh->_originalData.elements");
  }
  if (v8 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    v11.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 144));
    CFArrayRef v12 = *(const __CFArray **)(a1 + 144);
  }
  else
  {
    if (v8)
    {
      sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"CFXMeshGetIndexOfElement");
      return -1;
    }
    v11.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
    CFArrayRef v12 = *(const __CFArray **)(a1 + 96);
  }
  v11.location = 0;

  return CFArrayGetFirstIndexOfValue(v12, v11, a2);
}

const void *sub_1B64AD364(uint64_t a1, CFIndex idx)
{
  CFArrayRef Count = *(const __CFArray **)(a1 + 144);
  if (Count) {
    CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  if ((uint64_t)Count <= idx) {
    return 0;
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 144);

  return CFArrayGetValueAtIndex(v5, idx);
}

uint64_t sub_1B64AD3C4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  if (a2 == 1)
  {
    sub_1B64F72FC(a1, 1, a3, a4, a5, a6, a7, a8);
    return *(void *)(a1 + 144);
  }
  else if (a2)
  {
    sub_1B63F2F54(16, @"Unreachable code: Internal consistency error in %s", a3, a4, a5, a6, a7, a8, (uint64_t)"CFXMeshGetMeshElements");
    return 0;
  }
  else
  {
    return *(void *)(a1 + 96);
  }
}

void sub_1B64AD458(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  CFTypeRef v10 = *(CFTypeRef *)(a1 + 96);
  if (v10 != cf)
  {
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 96) = 0;
    }
    if (cf)
    {
      CFAllocatorRef v11 = CFGetAllocator(cf);
      *(void *)(a1 + 96) = CFArrayCreateMutableCopy(v11, 0, (CFArrayRef)cf);
    }
    *(unsigned char *)(a1 + 200) &= ~2u;
    sub_1B64AAB70(a1);
  }
}

void sub_1B64AD508(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  *(unsigned char *)(a1 + 200) &= ~2u;
  sub_1B64AAB70(a1);
  uint64_t v9 = *(__CFArray **)(a1 + 96);

  CFArrayRemoveAllValues(v9);
}

void sub_1B64AD578(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v10 = sub_1B64ABD08(a1, a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t)v10 >= 1)
  {
    CFArrayRef v16 = v10;
    CFIndex v17 = 0;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      uint64_t v18 = sub_1B64ABD78(a1, v17, 1, v11, v12, v13, v14, v15);
      if ((int)sub_1B63D0C08((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25) != a2)
      {
        if ((unint64_t)(a2 - 4) < 0xFFFFFFFFFFFFFFFELL)
        {
          sub_1B63F2F54(0, @"Warning: Can only convert to lines or points element type", v27, v11, v12, v13, v14, v15, v53);
          return;
        }
        if (!sub_1B63D0C08((uint64_t)v18, v26, v27, v11, v12, v13, v14, v15))
        {
          LODWORD(size) = 0;
          CFDataRef v34 = (const __CFData *)sub_1B63D0F38((uint64_t)v18, &size);
          uint64_t v35 = sub_1B63D11E8((uint64_t)v18);
          if (size == 2)
          {
            BytePtr = CFDataGetBytePtr(v34);
            if (a2 == 3) {
              goto LABEL_24;
            }
            if (a2 != 2) {
              goto LABEL_25;
            }
            uint64_t v54 = 3 * v35;
            uint64_t v37 = 6 * v35;
            uint64_t v38 = (UInt8 *)malloc_type_calloc(6 * v35, size, 0x9CD0CE31uLL);
            uint64_t v41 = v38;
            if (v35 >= 1)
            {
              do
              {
                *(_WORD *)uint64_t v41 = *(_WORD *)BytePtr;
                *((_WORD *)v41 + 1) = *((_WORD *)BytePtr + 1);
                *((_WORD *)v41 + 2) = *((_WORD *)BytePtr + 1);
                *((_WORD *)v41 + 3) = *((_WORD *)BytePtr + 2);
                *((_WORD *)v41 + 4) = *((_WORD *)BytePtr + 2);
                __int16 v42 = *(_WORD *)BytePtr;
                BytePtr += 6;
                *((_WORD *)v41 + 5) = v42;
                v41 += 12;
                --v35;
              }
              while (v35);
            }
          }
          else
          {
            if (size == 1)
            {
              BytePtr = CFDataGetBytePtr(v34);
              if (a2 != 3)
              {
                if (a2 == 2)
                {
                  uint64_t v54 = 3 * v35;
                  uint64_t v37 = 6 * v35;
                  uint64_t v38 = (UInt8 *)malloc_type_calloc(6 * v35, size, 0x5BF38C37uLL);
                  uint64_t v39 = v38;
                  if (v35 >= 1)
                  {
                    do
                    {
                      *uint64_t v39 = *BytePtr;
                      v39[1] = BytePtr[1];
                      v39[2] = BytePtr[1];
                      v39[3] = BytePtr[2];
                      v39[4] = BytePtr[2];
                      UInt8 v40 = *BytePtr;
                      BytePtr += 3;
                      v39[5] = v40;
                      v39 += 6;
                      --v35;
                    }
                    while (v35);
                  }
                  goto LABEL_23;
                }
LABEL_25:
                sub_1B64AAB70(a1);
                goto LABEL_26;
              }
LABEL_24:
              CFDataRef v49 = CFDataCreate(allocator, BytePtr, 3 * v35 * size);
              sub_1B63D05D4((uint64_t)v18, 3, 3 * v35, v49, size, v50, v51, v52);
              CFRelease(v49);
              goto LABEL_25;
            }
            BytePtr = CFDataGetBytePtr(v34);
            if (a2 == 3) {
              goto LABEL_24;
            }
            if (a2 != 2) {
              goto LABEL_25;
            }
            uint64_t v54 = 3 * v35;
            uint64_t v37 = 6 * v35;
            uint64_t v38 = (UInt8 *)malloc_type_calloc(6 * v35, size, 0xB6420FDBuLL);
            uint64_t v43 = v38;
            if (v35 >= 1)
            {
              do
              {
                *(_DWORD *)uint64_t v43 = *(_DWORD *)BytePtr;
                *((_DWORD *)v43 + 1) = *((_DWORD *)BytePtr + 1);
                *((_DWORD *)v43 + 2) = *((_DWORD *)BytePtr + 1);
                *((_DWORD *)v43 + 3) = *((_DWORD *)BytePtr + 2);
                *((_DWORD *)v43 + 4) = *((_DWORD *)BytePtr + 2);
                int v44 = *(_DWORD *)BytePtr;
                BytePtr += 12;
                *((_DWORD *)v43 + 5) = v44;
                v43 += 24;
                --v35;
              }
              while (v35);
            }
          }
LABEL_23:
          CFDataRef v45 = CFDataCreate(allocator, v38, v37 * size);
          sub_1B63D05D4((uint64_t)v18, 2, v54, v45, size, v46, v47, v48);
          CFRelease(v45);
          free(v38);
          goto LABEL_25;
        }
        sub_1B63F2F54(0, @"Warning: Can only convert from triangle array to another element type", v28, v29, v30, v31, v32, v33, v53);
      }
LABEL_26:
      ++v17;
    }
    while ((const __CFArray *)v17 != v16);
  }
}

uint64_t sub_1B64AD8C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  return (*(unsigned __int8 *)(a1 + 200) >> 2) & 1;
}

uint64_t sub_1B64AD910(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }

  return sub_1B6583470(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64AD96C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  return *(void *)(a1 + 208);
}

uint64_t sub_1B64AD9B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  return *(unsigned char *)(a1 + 200) & 1;
}

BOOL sub_1B64ADA08(float32x4_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float a10, float32x4_t a11, double a12, double a13, __n128 a14, __n128 a15)
{
  int v15 = a3 - a2;
  if (a3 <= a2)
  {
    return 0;
  }
  else
  {
    uint64_t v17 = a1[3].i64[1];
    int v18 = a1[4].u8[5];
    uint64_t v19 = a2;
    int v76 = a1[4].u8[6];
    int v20 = a1[4].u8[4];
    unint64_t v75 = a3;
    BOOL v21 = 1;
    do
    {
      int v22 = a1[1].u8[10];
      if (a1[1].i8[10])
      {
        if (v19) {
          uint64_t v23 = 1;
        }
        else {
          uint64_t v23 = 2;
        }
        if (v19) {
          uint64_t v24 = 2;
        }
        else {
          uint64_t v24 = 1;
        }
        uint64_t v25 = v22 != 5;
        BOOL v26 = v22 == 1;
        if (v22 == 1) {
          uint64_t v25 = 1;
        }
        uint64_t v27 = 1;
        if (v22 == 1) {
          uint64_t v28 = v23;
        }
        else {
          uint64_t v28 = 2;
        }
        if (v26) {
          uint64_t v29 = v24;
        }
        else {
          uint64_t v29 = 1;
        }
      }
      else
      {
        uint64_t v25 = 3;
        uint64_t v27 = 3;
        uint64_t v28 = 2;
        uint64_t v29 = 1;
      }
      uint64_t v30 = a1->i64[0];
      if (a1->i64[0])
      {
        int v31 = a1[1].u8[11];
        uint64_t v32 = a1[2].i64[1];
        uint64_t v33 = a1[3].i64[0];
        switch(v31)
        {
          case 4:
            int v34 = *(_DWORD *)(v30 + 4 * (v32 + v33 * v19 * v25));
            uint64_t v39 = v27 * v19;
            int v36 = *(_DWORD *)(v30 + 4 * (v32 + (v29 + v39) * v33));
            int v37 = *(_DWORD *)(v30 + 4 * (v32 + (v39 + v28) * v33));
            break;
          case 2:
            int v34 = *(unsigned __int16 *)(v30 + 2 * (v32 + v33 * v19 * v25));
            uint64_t v40 = v27 * v19;
            int v36 = *(unsigned __int16 *)(v30 + 2 * (v32 + (v29 + v40) * v33));
            int v37 = *(unsigned __int16 *)(v30 + 2 * (v32 + (v40 + v28) * v33));
            break;
          case 1:
            int v34 = *(unsigned __int8 *)(v30 + v32 + v33 * v19 * v25);
            uint64_t v35 = v27 * v19;
            int v36 = *(unsigned __int8 *)(v30 + v32 + (v29 + v35) * v33);
            int v37 = *(unsigned __int8 *)(v30 + v32 + (v35 + v28) * v33);
            break;
          default:
            sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", a3, a4, a5, a6, a7, a8, a1[1].u8[11]);
            int v37 = 0;
            int v36 = 0;
            int v34 = 0;
            break;
        }
      }
      else
      {
        int v34 = v19 * v25;
        int v38 = v27 * v19;
        int v36 = v29 + v38;
        int v37 = v38 + v28;
      }
      uint64_t v41 = v17 + (v34 * v18);
      if (v76 == 1)
      {
        a14.n128_u64[0] = *(void *)v41;
        a14.n128_u32[2] = *(_DWORD *)(v41 + 8);
        uint64_t v42 = v17 + (v36 * v18);
        a15.n128_u64[0] = *(void *)v42;
        a15.n128_u32[2] = *(_DWORD *)(v42 + 8);
        uint64_t v43 = v17 + (v37 * v18);
        a9.i64[0] = *(void *)v43;
        a9.i32[2] = *(_DWORD *)(v43 + 8);
      }
      else
      {
        *(double *)v44.i64 = sub_1B65D6198(v20, (const float *)v41, a3, a4, a5, a6, a7, a8, a9, a10, a11.f32[0]);
        __n128 v74 = (__n128)v44;
        *(double *)v53.i64 = sub_1B65D6198(v20, (const float *)(v17 + (v36 * v18)), v45, v46, v47, v48, v49, v50, v44, v51, v52);
        __n128 v73 = (__n128)v53;
        *(double *)a9.i64 = sub_1B65D6198(v20, (const float *)(v17 + (v37 * v18)), v54, v55, v56, v57, v58, v59, v53, v60, v61);
        a15 = v73;
        a14 = v74;
      }
      float32x4_t v62 = (float32x4_t)a15;
      v62.i32[3] = 0;
      float32x4_t v63 = a9;
      v63.i32[3] = 0;
      float32x4_t v64 = vminnmq_f32(v62, v63);
      float32x4_t v65 = (float32x4_t)a14;
      v65.i32[3] = 0;
      v64.i32[3] = 0;
      float32x4_t v66 = vminnmq_f32(v65, v64);
      float32x4_t v67 = vmaxnmq_f32(v62, v63);
      v67.i32[3] = 0;
      float32x4_t v68 = vmaxnmq_f32(v65, v67);
      v66.i32[3] = 1.0;
      v68.i32[3] = 1.0;
      v65.i64[0] = 0x3F0000003F000000;
      v65.i64[1] = 0x3F0000003F000000;
      a11 = vabdq_f32(a1[5], vmulq_f32(vaddq_f32(v66, v68), v65));
      uint32x4_t v69 = (uint32x4_t)vcgeq_f32(vaddq_f32(a1[6], vmulq_f32(vsubq_f32(v68, v66), v65)), a11);
      v69.i32[3] = v69.i32[2];
      a10 = COERCE_FLOAT(vminvq_u32(v69));
      if ((LODWORD(a10) & 0x80000000) != 0)
      {
        unsigned __int32 v70 = a1[200].u32[0];
        a1[200].i32[0] = v70 + 1;
        uint64_t v71 = (__n128 *)&a1[3 * v70];
        v71[8] = a14;
        v71[9] = a15;
        v71[10] = (__n128)a9;
        if (a1[200].i32[0] == 64)
        {
          a1[200].i32[0] = 0;
          if ((*(uint64_t (**)(void))(a1[7].i64[0] + 16))()) {
            break;
          }
        }
      }
      BOOL v21 = ++v19 < v75;
      --v15;
    }
    while (v15);
  }
  return v21;
}

uint64_t sub_1B64ADD0C(uint64_t a1, uint64_t a2, float32x4_t a3, float32x4_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12 = sub_1B64AC5F8(a1, 0, 0, 0, a7, a8, a9, a10);
  uint64_t result = sub_1B641D8A0((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19);
  if (result)
  {
    uint64_t result = (uint64_t)sub_1B64ABD08(a1, v21, v22, v23, v24, v25, v26, v27);
    if (result)
    {
      uint64_t v35 = result;
      memset(v89, 0, 384);
      long long v88 = 0u;
      long long v85 = 0u;
      float32x4_t v82 = 0u;
      uint64_t v83 = 0;
      long long v80 = 0u;
      long long v81 = 0u;
      uint64_t result = sub_1B641D478((uint64_t)v12, v28, v29, v30, v31, v32, v33, v34);
      uint64_t v84 = result;
      *(void *)&long long v85 = v41;
      float32x4_t v86 = a3;
      float32x4_t v87 = a4;
      int v90 = 0;
      *(void *)&long long v88 = a2;
      if (v35 >= 1)
      {
        for (CFIndex i = 0; i != v35; ++i)
        {
          uint64_t v43 = sub_1B64ABD78(a1, i, 0, v36, v37, v38, v39, v40);
          sub_1B63D11F0((uint64_t)v43, 0, v44, v45, v46, v47, v48, v49, (uint64_t)&v76);
          long long v80 = v76;
          long long v81 = v77;
          float32x4_t v82 = v78;
          uint64_t v83 = v79;
          if (DWORD2(v76) < 0x101)
          {
            uint64_t result = sub_1B64ADA08((float32x4_t *)&v80, 0, DWORD2(v76), v50, v51, v52, v53, v54, v78, *(float *)&v77, v55, v56, v57, v58, v59);
            if (result) {
              return result;
            }
          }
          else
          {
            unsigned int v75 = 0;
            long long v76 = v80;
            long long v77 = v81;
            float32x4_t v78 = v82;
            uint64_t v79 = v83;
            uint64_t result = sub_1B63D5C0C((uint64_t)v43, &v76, v84, v85, (uint64_t)&v75, v52, v53, v54);
            unint64_t v63 = v75;
            if (v75)
            {
              uint64_t v64 = result;
              uint64_t v65 = 0;
              for (unint64_t j = 0; j < v63; ++j)
              {
                float32x4_t v67 = *(float32x4_t *)(v64 + v65);
                float32x4_t v68 = *(float32x4_t *)(v64 + v65 + 16);
                float32x4_t v69 = vaddq_f32(v87, v68);
                float32x4_t v70 = (float32x4_t)vcgeq_f32(v69, vabdq_f32(v86, v67));
                v70.i32[3] = v70.i32[2];
                v70.i32[0] = vminvq_u32((uint32x4_t)v70);
                uint64_t v71 = v65 + 32;
                if (v70.i32[0] < 0)
                {
                  if (v71 >= DWORD2(v80)) {
                    uint64_t v72 = DWORD2(v80);
                  }
                  else {
                    uint64_t v72 = v71;
                  }
                  uint64_t result = sub_1B64ADA08((float32x4_t *)&v80, v65, v72, v36, v37, v38, v39, v40, v70, v69.f32[0], v67, *(double *)v68.i64, v60, v61, v62);
                  if (result) {
                    return result;
                  }
                  unint64_t v63 = v75;
                }
                uint64_t v65 = v71;
              }
            }
          }
        }
        if (v90) {
          return (*(uint64_t (**)(uint64_t, unsigned char *))(a2 + 16))(a2, v89);
        }
      }
    }
  }
  return result;
}

id sub_1B64ADF24(uint64_t a1)
{
  sub_1B64AAB0C(a1);
  uint64_t v2 = *(const void **)(a1 + 96);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 144);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 144) = 0;
  }
  CFArrayRef v5 = *(const void **)(a1 + 112);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 112) = 0;
  }
  free(*(void **)(a1 + 104));
  free(*(void **)(a1 + 152));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 176));
  uint64_t v13 = *(void **)(a1 + 192);
  if (v13) {
    free(v13);
  }
  uint64_t v14 = *(void **)(a1 + 184);
  if (v14) {
    free(v14);
  }

  return sub_1B658325C(a1, v6, v7, v8, v9, v10, v11, v12);
}

__CFString *sub_1B64ADFD8(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v10 = sub_1B6583470(a1, v3, v4, v5, v6, v7, v8, v9);
  CFStringAppendFormat(Mutable, 0, @"<CFXMesh %p \"%@\"\n", a1, v10);
  if ((uint64_t)sub_1B64ABD08(a1, v11, v12, v13, v14, v15, v16, v17) >= 1)
  {
    CFIndex v23 = 0;
    do
    {
      uint64_t v24 = sub_1B64ABD78(a1, v23, 0, v18, v19, v20, v21, v22);
      CFStringAppendFormat(Mutable, 0, @"  element%d: %@\n", v23++, v24);
    }
    while (v23 < (uint64_t)sub_1B64ABD08(a1, v25, v26, v27, v28, v29, v30, v31));
  }
  v55[0] = MEMORY[0x1E4F143A8];
  v55[1] = 0x40000000;
  v55[2] = sub_1B64AE1B4;
  v55[3] = &unk_1E6142DF0;
  v55[4] = Mutable;
  sub_1B64AAFB4(a1, 0, (uint64_t)v55, v18, v19, v20, v21, v22);
  if (*(void *)(a1 + 112))
  {
    if ((uint64_t)sub_1B64ABD08(a1, v32, v33, v34, v35, v36, v37, v38) >= 1)
    {
      CFIndex v44 = 0;
      do
      {
        uint64_t v45 = sub_1B64ABD78(a1, v44, 1, v39, v40, v41, v42, v43);
        CFStringAppendFormat(Mutable, 0, @"  renderable element%d: %@\n", v44++, v45);
      }
      while (v44 < (uint64_t)sub_1B64ABD08(a1, v46, v47, v48, v49, v50, v51, v52));
    }
    v54[0] = MEMORY[0x1E4F143A8];
    v54[1] = 0x40000000;
    v54[2] = sub_1B64AE238;
    v54[3] = &unk_1E6142E10;
    v54[4] = Mutable;
    sub_1B64AAFB4(a1, 1, (uint64_t)v54, v39, v40, v41, v42, v43);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

void sub_1B64AE1B4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5)
{
  uint64_t v8 = *(__CFString **)(a1 + 32);
  uint64_t v9 = sub_1B641CDD4(a3);
  if (a4 < 1) {
    CFStringAppendFormat(v8, 0, @"  source %@ (channel:%d) : %@\n", v9, a5, a2);
  }
  else {
    CFStringAppendFormat(v8, 0, @"  source %@%d (channel:%d) : %@\n", v9, a4, a5, a2);
  }
}

void sub_1B64AE238(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6 = *(__CFString **)(a1 + 32);
  uint64_t v7 = sub_1B641CDD4(a3);
  if (a4 < 1) {
    CFStringAppendFormat(v6, 0, @"  renderable source %@: %@\n", v7, a2);
  }
  else {
    CFStringAppendFormat(v6, 0, @"  renderable source %@%d: %@\n", v7, a4, a2);
  }
}

__CFArray *sub_1B64AE2AC(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v23 = 2;
  int valuePtr = 5;
  uint64_t v22 = a1 + 64;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v5, @"name", @"sources");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v23 = 0;
  int valuePtr = 5;
  uint64_t v22 = a1 + 184;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v9, @"name", @"boundingSphere");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v23 = 0;
  int valuePtr = 5;
  uint64_t v22 = a1 + 192;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v13, @"name", @"boundingBox");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v23 = 2;
  int valuePtr = 5;
  uint64_t v22 = a1 + 96;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v17, @"name", @"meshElements");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  return Mutable;
}

uint64_t sub_1B64AE6B8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B64AE6F4(uint64_t a1)
{
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }

  return MEMORY[0x1F4181798](a1, sel_documentEnclosingURL, v2, v3);
}

uint64_t sub_1B64AEBD0()
{
  if (qword_1EB995540 != -1) {
    dispatch_once(&qword_1EB995540, &unk_1F0FB5948);
  }
  return qword_1EB995548;
}

double sub_1B64AEC14()
{
  if (!qword_1EB995548)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995548);
    qword_1EB995548 = (uint64_t)v0;
    CFNumberRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"doubleSided", 0x68u, 3, 0, 0, 0, v2, v3);
    sub_1B660E400(@"cullMode", 0x5Eu, 4, 0, 0, 0, v4, v5);
    sub_1B660E400(@"alphaCutoff", 0x58u, 1, 0, 0, 0, v6, v7);
    sub_1B660E3EC();
    qword_1EB984400 = (uint64_t)sub_1B64B0140;
    qword_1EB984440 = (uint64_t)sub_1B64B09D8;
    xmmword_1EB9843F0 = xmmword_1F0FB8918;
    double result = *(double *)&xmmword_1F0FB8928;
    unk_1EB984458 = xmmword_1F0FB8928;
  }
  return result;
}

uint64_t sub_1B64AED1C()
{
  if (qword_1EB995540 != -1) {
    dispatch_once(&qword_1EB995540, &unk_1F0FB5948);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995548, 0x60uLL);
  *(void *)(v0 + 64) = sub_1B6475CE8(v0);
  *(unsigned char *)(v0 + 104) = 0;
  *(_WORD *)(v0 + 96) = 3840;
  *(_DWORD *)(v0 + 92) = 257;
  *(_DWORD *)(v0 + 88) = -1082130432;
  sub_1B64AEDA8(v0);
  return v0;
}

uint64_t sub_1B64AEDA8(uint64_t a1)
{
  sub_1B64516BC(*(CFTypeRef *)(a1 + 80));
  memset(v5, 0, 28);
  sub_1B64513F4(v5);
  if (*(unsigned char *)(a1 + 104)) {
    int v2 = 2;
  }
  else {
    int v2 = *(unsigned __int8 *)(a1 + 94);
  }
  *(void *)&v5[0] = __PAIR64__(*(unsigned __int8 *)(a1 + 95), v2);
  BYTE8(v5[0]) = *(unsigned char *)(a1 + 93) != 0;
  BYTE9(v5[0]) = *(unsigned char *)(a1 + 92) != 0;
  v4[0] = v5[0];
  *(_OWORD *)((char *)v4 + 12) = *(_OWORD *)((char *)v5 + 12);
  uint64_t result = sub_1B6451514((uint64_t)v4);
  *(void *)(a1 + 80) = result;
  return result;
}

uint64_t sub_1B64AEE44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"src");
  }
  uint64_t v9 = sub_1B64AED1C();
  sub_1B64AEEA4(a1, v9, v10, v11, v12, v13, v14, v15);
  return v9;
}

uint64_t sub_1B64AEEA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"src");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dst");
LABEL_3:
  *(unsigned char *)(a2 + 104) = *(unsigned char *)(a1 + 104);
  *(_DWORD *)(a2 + 92) = *(_DWORD *)(a1 + 92);
  *(unsigned char *)(a2 + 97) = *(unsigned char *)(a1 + 97);
  *(_DWORD *)(a2 + 88) = *(_DWORD *)(a1 + 88);
  uint64_t v10 = *(void *)(a1 + 64);
  uint64_t v11 = *(void *)(a2 + 64);
  if (v10)
  {
    sub_1B64755C0(v10, v11, a3, a4, a5, a6, a7, a8);
  }
  else if (v11)
  {
    CFRelease(*(CFTypeRef *)(a2 + 64));
    *(void *)(a2 + 64) = 0;
  }
  sub_1B6583A28(a1, (CFTypeRef *)a2, a3, a4, a5, a6, a7, a8);
  CFStringRef v19 = (const __CFString *)sub_1B64AEFF4(a1, v12, v13, v14, v15, v16, v17, v18);
  sub_1B64AEF90(a2, v19, v20, v21, v22, v23, v24, v25);

  return sub_1B64AEDA8(a2);
}

CFStringRef sub_1B64AEF90(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }

  return sub_1B65834BC(a1, theString, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64AEFF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }

  return sub_1B6583470(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64AF050(uint64_t a1)
{
  long long v69 = xmmword_1B6E4F380;
  long long v70 = xmmword_1B6E4F370;
  uint64_t v2 = sub_1B64AED1C();
  sub_1B64755C0(*(void *)(a1 + 64), *(void *)(v2 + 64), v3, v4, v5, v6, v7, v8);
  int v14 = 0;
  uint64_t v15 = *(void *)(v2 + 64);
  do
  {
    sub_1B647624C(v15, (char)v14, 0, v9, v10, v11, v12, v13, v67);
    sub_1B64760E8(*(void *)(v2 + 64), (char)v14++, (float *)&v70, v16, v17, v18, v19, v20);
    uint64_t v15 = *(void *)(v2 + 64);
  }
  while (v14 != 16);
  sub_1B6475724(v15, 0, v21, v9, v10, v11, v12, v13);
  sub_1B647624C(*(void *)(v2 + 64), 1, 0, v22, v23, v24, v25, v26, v67);
  sub_1B64760E8(*(void *)(v2 + 64), 1, (float *)&v69, v27, v28, v29, v30, v31);
  sub_1B647624C(*(void *)(v2 + 64), 5, 0, v32, v33, v34, v35, v36, v68);
  sub_1B64760E8(*(void *)(v2 + 64), 5, (float *)&v69, v37, v38, v39, v40, v41);
  sub_1B64AF180(v2, 1u, v42, v43, v44, v45, v46, v47);
  sub_1B64AF224(v2, 0, v48, v49, v50, v51, v52, v53);
  sub_1B64AF2BC(v2, 15, v54, v55, v56, v57, v58, v59);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v60, v61, v62, v63, v64, v65, (uint64_t)"material");
  }
  sub_1B64AF354(v2, *(unsigned __int8 *)(a1 + 104), v60, v61, v62, v63, v64, v65);
  return v2;
}

void sub_1B64AF180(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (a2 >= 2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. invalid fill mode", a3, a4, a5, a6, a7, a8, (uint64_t)"fillMode == kCFXFillModeFill || fillMode == kCFXFillModeLines");
  }
  if (*(unsigned __int8 *)(a1 + 95) != a2)
  {
    *(unsigned char *)(a1 + 95) = a2;
    sub_1B64AEDA8(a1);
  }
}

void sub_1B64AF224(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (*(unsigned __int8 *)(a1 + 96) != v8)
  {
    *(unsigned char *)(a1 + 96) = v8;
    uint64_t v10 = sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B64B1F18(v10, 3, (const void *)a1, 0, v11, v12, v13, v14);
    sub_1B64AEDA8(a1);
  }
}

void sub_1B64AF2BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (*(unsigned __int8 *)(a1 + 97) != v8)
  {
    *(unsigned char *)(a1 + 97) = v8;
    uint64_t v10 = sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B64B1F18(v10, 3, (const void *)a1, 0, v11, v12, v13, v14);
    sub_1B64AEDA8(a1);
  }
}

void sub_1B64AF354(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (*(unsigned __int8 *)(a1 + 104) != v8)
  {
    *(unsigned char *)(a1 + 104) = v8;
    uint64_t v10 = sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B64B1F18(v10, 3, (const void *)a1, 0, v11, v12, v13, v14);
    sub_1B64AEDA8(a1);
  }
}

uint64_t sub_1B64AF3EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned __int8 *)(a1 + 104);
}

uint64_t sub_1B64AF43C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(void *)(a1 + 64);
}

uint64_t sub_1B64AF488(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (*(void *)(a1 + 72)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 64);
  }
}

void sub_1B64AF4E4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (*(unsigned __int8 *)(a1 + 94) != a2)
  {
    *(unsigned char *)(a1 + 94) = a2;
    sub_1B64AEDA8(a1);
  }
}

uint64_t sub_1B64AF564(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned __int8 *)(a1 + 94);
}

uint64_t sub_1B64AF5B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned __int8 *)(a1 + 95);
}

uint64_t sub_1B64AF5FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned __int8 *)(a1 + 96);
}

float sub_1B64AF648(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(float *)(a1 + 88);
}

void sub_1B64AF694(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  float v11 = *(float *)(a1 + 88);
  if (v11 != a9)
  {
    *(float *)(a1 + 88) = a9;
    ++*(_DWORD *)(a1 + 100);
    if (a9 < 0.0 == v11 >= 0.0)
    {
      uint64_t v12 = sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
      sub_1B64B1F18(v12, 3, (const void *)a1, 0, v13, v14, v15, v16);
    }
  }
}

void sub_1B64AF754(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  ++*(_DWORD *)(a1 + 100);
}

void sub_1B64AF7A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (*(unsigned __int8 *)(a1 + 92) != v8)
  {
    *(unsigned char *)(a1 + 92) = v8;
    uint64_t v10 = sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B64B1F18(v10, 3, (const void *)a1, 0, v11, v12, v13, v14);
    sub_1B64AEDA8(a1);
  }
}

BOOL sub_1B64AF840(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned char *)(a1 + 92) != 0;
}

uint64_t sub_1B64AF894(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned __int8 *)(a1 + 97);
}

void sub_1B64AF8E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  if (*(unsigned __int8 *)(a1 + 93) != v8)
  {
    *(unsigned char *)(a1 + 93) = v8;
    uint64_t v10 = sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    sub_1B64B1F18(v10, 3, (const void *)a1, 0, v11, v12, v13, v14);
    sub_1B64AEDA8(a1);
  }
}

BOOL sub_1B64AF978(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned char *)(a1 + 93) != 0;
}

uint64_t sub_1B64AF9CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9)
  {
    return sub_1B6515FA4(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    uint64_t v11 = sub_1B6475290(*(void *)(a1 + 64), 4, 0, a4, a5, a6, a7, a8);
    int v12 = sub_1B6476FB8(v11);
    uint64_t result = 0;
    if (v12) {
      return *(unsigned char *)(a1 + 96) == 0;
    }
  }
  return result;
}

uint64_t sub_1B64AFA68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(void *)(a1 + 72);
}

uint64_t sub_1B64AFAB4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(unsigned char *)(a1 + 96))
  {
    case 0:
      if (!a2) {
        goto LABEL_13;
      }
      uint64_t v8 = sub_1B6475290(*(void *)(a1 + 64), 4, 0, a4, a5, a6, a7, a8);
      if ((sub_1B6476FB8(v8) & 1) == 0) {
        goto LABEL_13;
      }
      uint64_t result = sub_1B64E3664();
      break;
    case 1:
      if (!*(void *)(a1 + 64)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material->_commonProfile");
      }
      if (a5) {
        goto LABEL_13;
      }
      uint64_t v13 = "oBlendColor";
      uint64_t v10 = @"Assertion '%s' failed. Null argument";
      int v11 = 17;
      goto LABEL_12;
    case 2:
      uint64_t result = sub_1B64E3450();
      break;
    case 3:
      uint64_t result = sub_1B64E36E4();
      break;
    case 4:
      if (a4)
      {
        uint64_t result = sub_1B64E3558();
      }
      else
      {
        uint64_t result = sub_1B64E34D4();
      }
      break;
    case 5:
      uint64_t result = sub_1B64E37F0();
      break;
    case 6:
      uint64_t result = sub_1B64E3768();
      break;
    default:
      uint64_t v10 = @"Unreachable code: Blend mode not implemented.";
      int v11 = 16;
LABEL_12:
      sub_1B63F2F54(v11, (uint64_t)v10, a3, a4, a5, a6, a7, a8, (uint64_t)v13);
LABEL_13:
      uint64_t result = sub_1B64E35DC();
      break;
  }
  return result;
}

void sub_1B64AFC88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B63F4F54((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1B64B1F18(v9, 3, (const void *)a1, 0, v10, v11, v12, v13);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v14, v15, v16, v17, v18, v19, (uint64_t)"material");
  }
  ++*(_DWORD *)(a1 + 100);
  uint64_t v20 = *(const void **)(a1 + 64);

  sub_1B6595A0C(@"kCFXShadableDidChange", v20, 0, 1u);
}

CFTypeRef sub_1B64AFD18(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 72);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 72) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 72) = result;
  }
  return result;
}

CFTypeRef sub_1B64AFD94(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  uint64_t v10 = *(void **)(a1 + 72);
  if (!v10)
  {
    uint64_t v10 = (void *)sub_1B65151FC(1uLL);
    sub_1B64AFD18(a1, v10, v11, v12, v13, v14, v15, v16);
    CFRelease(v10);
  }
  if (sub_1B6515384((uint64_t)v10, (uint64_t)a2, a3, a4, a5, a6, a7, a8) < 1)
  {
    uint64_t v29 = (const void *)sub_1B65F6884();
    sub_1B65152BC(v10, v29, v30, v31, v32, v33, v34, v35, v43);
    CFRelease(v29);
  }
  else
  {
    uint64_t v29 = (const void *)sub_1B6515448((uint64_t)v10, 0, v17, v18, v19, v20, v21, v22);
  }
  sub_1B65F6C98((uint64_t)v29, 2, v23, v24, v25, v26, v27, v28);

  return sub_1B65F6B7C((uint64_t)v29, a2, v36, v37, v38, v39, v40, v41);
}

uint64_t sub_1B64AFE74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  return *(unsigned int *)(a1 + 100);
}

CFDictionaryRef sub_1B64AFEC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }

  return sub_1B6583734(a1, @"kBehaviorGraph", a3, a4, a5, a6, a7, a8);
}

void sub_1B64AFF28(CFTypeRef *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  uint64_t v10 = sub_1B63F4F54(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  CFDictionaryRef v18 = sub_1B64AFEC0((uint64_t)a1, v11, v12, v13, v14, v15, v16, v17);
  if (v10 && v18) {
    sub_1B63F4AAC(v18, v10, v19, v20, v21, v22, v23, v24);
  }
  sub_1B65837D4(a1, @"kBehaviorGraph", a2, v10 != 0, v21, v22, v23, v24);
  if (a2 && v10)
  {
    sub_1B63F4CCC((uint64_t *)a2, v10, v25, v26, v27, v28, v29, v30);
  }
}

id sub_1B64AFFF8(uint64_t a1)
{
  sub_1B6595A0C(@"kCFXNotificationMaterialWillDie", (const void *)a1, 0, 1u);
  uint64_t v2 = *(const void **)(a1 + 64);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 72);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 72) = 0;
  }
  sub_1B64516BC(*(CFTypeRef *)(a1 + 80));

  return sub_1B658325C(a1, v4, v5, v6, v7, v8, v9, v10);
}

__CFString *sub_1B64B0074(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v10 = sub_1B6583470(a1, v3, v4, v5, v6, v7, v8, v9);
  CFStringAppendFormat(Mutable, 0, @"<CFXMaterial %p : \"%@\", ", a1, v10);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v11, v12, v13, v14, v15, v16, (uint64_t)"material");
  }
  if (*(void *)(a1 + 72) || !*(void *)(a1 + 64)) {
    CFStringAppendFormat(Mutable, 0, @"custom %@", *(void *)(a1 + 72));
  }
  else {
    CFStringAppendFormat(Mutable, 0, @"common profile %@", *(void *)(a1 + 64));
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

__CFArray *sub_1B64B0140(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v57 = 1;
  int valuePtr = 5;
  uint64_t v56 = sub_1B64AEFF4(a1, v6, v7, v8, v9, v10, v11, v12);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v5, @"name", @"name");
  CFDictionarySetValue(v5, @"type", v13);
  CFDictionarySetValue(v5, @"address", v15);
  CFDictionarySetValue(v5, @"semantic", v14);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v14);
  CFRelease(v5);
  CFRelease(v15);
  CFRelease(v13);
  uint64_t v22 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v57 = 1;
  int valuePtr = 5;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v16, v17, v18, v19, v20, v21, (uint64_t)"material");
  }
  uint64_t v56 = *(void *)(a1 + 64);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v22, @"name", @"commonProfile");
  CFDictionarySetValue(v22, @"type", v23);
  CFDictionarySetValue(v22, @"address", v25);
  CFDictionarySetValue(v22, @"semantic", v24);
  CFArrayAppendValue(Mutable, v22);
  CFRelease(v24);
  CFRelease(v22);
  CFRelease(v25);
  CFRelease(v23);
  uint64_t v26 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v57 = 0;
  int valuePtr = 4;
  uint64_t v56 = a1 + 94;
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v26, @"name", @"cullMode");
  CFDictionarySetValue(v26, @"type", v27);
  CFDictionarySetValue(v26, @"address", v29);
  CFDictionarySetValue(v26, @"semantic", v28);
  CFArrayAppendValue(Mutable, v26);
  CFRelease(v28);
  CFRelease(v26);
  CFRelease(v29);
  CFRelease(v27);
  uint64_t v30 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v57 = 0;
  int valuePtr = 4;
  uint64_t v56 = a1 + 95;
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v30, @"name", @"fillMode");
  CFDictionarySetValue(v30, @"type", v31);
  CFDictionarySetValue(v30, @"address", v33);
  CFDictionarySetValue(v30, @"semantic", v32);
  CFArrayAppendValue(Mutable, v30);
  CFRelease(v32);
  CFRelease(v30);
  CFRelease(v33);
  CFRelease(v31);
  uint64_t v34 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v57 = 0;
  int valuePtr = 1;
  uint64_t v56 = a1 + 88;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v35, @"name", @"alphaCutoff");
  CFDictionarySetValue(v35, @"type", v36);
  CFDictionarySetValue(v35, @"address", v38);
  CFDictionarySetValue(v35, @"semantic", v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  uint64_t v39 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v34);
  int v57 = 0;
  int valuePtr = 3;
  uint64_t v56 = a1 + 93;
  CFNumberRef v40 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v39, @"name", @"enableReadsFromDepthBuffer");
  CFDictionarySetValue(v39, @"type", v40);
  CFDictionarySetValue(v39, @"address", v42);
  CFDictionarySetValue(v39, @"semantic", v41);
  CFArrayAppendValue(Mutable, v39);
  CFRelease(v41);
  CFRelease(v39);
  CFRelease(v42);
  CFRelease(v40);
  uint64_t v43 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v57 = 0;
  int valuePtr = 3;
  uint64_t v56 = a1 + 92;
  CFNumberRef v44 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v46 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v43, @"name", @"enableWriteInDepthBuffer");
  CFDictionarySetValue(v43, @"type", v44);
  CFDictionarySetValue(v43, @"address", v46);
  CFDictionarySetValue(v43, @"semantic", v45);
  CFArrayAppendValue(Mutable, v43);
  CFRelease(v45);
  CFRelease(v43);
  CFRelease(v46);
  CFRelease(v44);
  uint64_t v47 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v57 = 0;
  int valuePtr = 3;
  uint64_t v56 = a1 + 104;
  CFNumberRef v48 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v50 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v47, @"name", @"doubleSided");
  CFDictionarySetValue(v47, @"type", v48);
  CFDictionarySetValue(v47, @"address", v50);
  CFDictionarySetValue(v47, @"semantic", v49);
  CFArrayAppendValue(Mutable, v47);
  CFRelease(v49);
  CFRelease(v47);
  CFRelease(v50);
  CFRelease(v48);
  uint64_t v51 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v57 = 0;
  int valuePtr = 2;
  uint64_t v56 = a1 + 48;
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt32Type, &v57);
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberLongType, &v56);
  CFDictionarySetValue(v51, @"name", @"worldRef");
  CFDictionarySetValue(v51, @"type", v52);
  CFDictionarySetValue(v51, @"address", v54);
  CFDictionarySetValue(v51, @"semantic", v53);
  CFArrayAppendValue(Mutable, v51);
  CFRelease(v53);
  CFRelease(v51);
  CFRelease(v54);
  CFRelease(v52);
  return Mutable;
}

uint64_t sub_1B64B09D8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

void sub_1B64B0A10(uint64_t a1, void *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((void *)(a1 + 88) == __dst) {
    sub_1B64AF694(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, *__src);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFDictionaryRef sub_1B64B0A40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }

  return sub_1B6583734(a1, @"kBehaviorGraph", a3, a4, a5, a6, a7, a8);
}

void sub_1B64B0AAC(CFTypeRef *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  CFDictionaryRef v10 = sub_1B64B0A40((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10) {
    sub_1B63F4AAC(v10, (uint64_t)a1, v11, v12, v13, v14, v15, v16);
  }
  sub_1B65837D4(a1, @"kBehaviorGraph", a2, 1, v13, v14, v15, v16);
  if (a2)
  {
    sub_1B63F4CCC((uint64_t *)a2, (uint64_t)a1, v17, v18, v19, v20, v21, v22);
  }
}

uint64_t sub_1B64B0B54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B64B0C28(a1, a2, a3, a4, a5, a6, a7, a8);
  int v17 = *(unsigned __int16 *)(a1 + 224);
  if (v17 == 1)
  {
    uint64_t v18 = *(void *)(a1 + 216);
    uint64_t v19 = malloc_type_malloc(0x10uLL, 0x2004093837F09uLL);
    *(void *)(a1 + 216) = v19;
    void *v19 = v18;
    *(void *)(*(void *)(a1 + 216) + 8) = a2;
    *(_WORD *)(a1 + 224) = 2;
  }
  else if (*(_WORD *)(a1 + 224))
  {
    unsigned __int16 v20 = v17 + 1;
    *(_WORD *)(a1 + 224) = v20;
    uint64_t v21 = malloc_type_realloc(*(void **)(a1 + 216), 8 * v20, 0x2004093837F09uLL);
    *(void *)(a1 + 216) = v21;
    v21[*(unsigned __int16 *)(a1 + 224) - 1] = a2;
  }
  else
  {
    *(_WORD *)(a1 + 224) = 1;
    *(void *)(a1 + 216) = a2;
  }

  return sub_1B64B0CB4(a1, v10, v11, v12, v13, v14, v15, v16);
}

void sub_1B64B0C28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  prof_beginFlame((uint64_t)"CFXWorldLock", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/Core/CFXWorld.m", 1038);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 296));

  prof_endFlame();
}

void sub_1B64B0CA0(_Unwind_Exception *a1)
{
}

uint64_t sub_1B64B0CB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 296));
}

uint64_t sub_1B64B0D10(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(result + 224))
  {
    uint64_t v9 = result;
    sub_1B64B0C28(result, a2, a3, a4, a5, a6, a7, a8);
    int v17 = *(unsigned __int16 *)(v9 + 224);
    if (*(_WORD *)(v9 + 224))
    {
      if (v17 == 1)
      {
        if (*(void *)(v9 + 216) == a2)
        {
          *(_WORD *)(v9 + 224) = 0;
          *(void *)(v9 + 216) = 0;
        }
      }
      else
      {
        unint64_t v18 = 0;
        uint64_t v19 = 8;
        do
        {
          unsigned __int16 v20 = *(char **)(v9 + 216);
          if (*(void *)&v20[8 * v18] == a2)
          {
            if ((unsigned __int16)v17 == 2)
            {
              uint64_t v21 = *(void *)&v20[v19];
              free(v20);
              *(void *)(v9 + 216) = v21;
              LOWORD(v17) = 1;
              *(_WORD *)(v9 + 224) = 1;
            }
            else
            {
              LOWORD(v17) = v17 - 1;
              *(_WORD *)(v9 + 224) = v17;
              *(void *)&v20[8 * v18] = *(void *)&v20[8 * (unsigned __int16)v17];
            }
          }
          ++v18;
          v19 -= 8;
        }
        while (v18 < (unsigned __int16)v17);
      }
    }
    return sub_1B64B0CB4(v9, v10, v11, v12, v13, v14, v15, v16);
  }
  return result;
}

uint64_t sub_1B64B0E00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B64B0C28(a1, a2, a3, a4, a5, a6, a7, a8);
  if (*(_WORD *)(a1 + 224))
  {
    if (*(_WORD *)(a1 + 224) == 1)
    {
      (*(void (**)(uint64_t, void))(a2 + 16))(a2, *(void *)(a1 + 216));
    }
    else
    {
      unint64_t v17 = 0;
      do
        (*(void (**)(uint64_t, void))(a2 + 16))(a2, *(void *)(*(void *)(a1 + 216) + 8 * v17++));
      while (v17 < *(unsigned __int16 *)(a1 + 224));
    }
  }

  return sub_1B64B0CB4(a1, v10, v11, v12, v13, v14, v15, v16);
}

void sub_1B64B0E98(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v16 = sub_1B64A457C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"world");
  }
  uint64_t v17 = *(void *)(a1 + 96);
  CFStringRef v18 = CFStringCreateWithFormat(0, 0, @"nodeConstraints-%p", a2);
  sub_1B660BA40(v17, v16, a2, (uint64_t)v18, v19, v20, v21, v22);

  CFRelease(v18);
}

uint64_t sub_1B64B0F40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 96);
}

uint64_t sub_1B64B0F8C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(a1 + 192)) {
    *(void *)(a1 + 192) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
  }
  CFDictionaryRef v10 = sub_1B64A4A84((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 192), a2, v10);
  }
  else {
    sub_1B63F2F54(16, @"Unreachable code: unexpected call to CFXWorldRegisterNodeCoreEntityHandle", v11, v12, v13, v14, v15, v16, v31);
  }
  BOOL v24 = !sub_1B64A3178((uint64_t)a2, v17, v18, v19, v20, v21, v22, v23);

  return sub_1B64B1028(a1, a2, v24, v25, v26, v27, v28, v29);
}

uint64_t sub_1B64B1028(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
    if (key) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
LABEL_3:
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 192), key);
  if (!Value) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v11, v12, v13, v14, v15, v16, (uint64_t)"entityHandle");
  }

  return sub_1B6535D40(Value, a3, v11, v12, v13, v14, v15, v16);
}

void sub_1B64B10F0(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(__CFDictionary **)(a1 + 192);
  if (v2) {
    CFDictionaryRemoveValue(v2, a2);
  }
}

uint64_t sub_1B64B1100(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 192);
}

void sub_1B64B114C(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  if (!*(void *)(a1 + 200)) {
    *(void *)(a1 + 200) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
  }
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 200), a2, v5);
  if (v5) {
    CFRelease(v5);
  }
}

void sub_1B64B11E0(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(__CFDictionary **)(a1 + 200);
  if (v2) {
    CFDictionaryRemoveValue(v2, a2);
  }
}

CFDictionaryRef sub_1B64B11F0(uint64_t a1, const void *a2)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 200);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, a2);
    if (result)
    {
      uint64_t valuePtr = 0;
      CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
      return (const __CFDictionary *)valuePtr;
    }
  }
  return result;
}

uint64_t sub_1B64B1230(uint64_t a1)
{
  return *(void *)(a1 + 208);
}

void sub_1B64B1238(uint64_t a1)
{
  CFNumberRef v1 = *(__CFArray **)(a1 + 208);
  if (v1) {
    CFArrayRemoveAllValues(v1);
  }
}

uint64_t sub_1B64B1248(uint64_t result, void *value)
{
  if (value)
  {
    uint64_t v3 = result;
    CFDictionaryRef Mutable = *(__CFArray **)(result + 208);
    if (!Mutable)
    {
      CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      *(void *)(v3 + 208) = Mutable;
    }
    CFArrayAppendValue(Mutable, value);
    CFDictionaryRef result = *(void *)(v3 + 144);
    if (result)
    {
      return sub_1B6626AE4(result);
    }
  }
  return result;
}

void sub_1B64B12BC(CFTypeRef *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v10 = (const __CFArray *)sub_1B64A0448((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10 && CFArrayGetCount(v10) >= 1)
  {
    CFDictionaryRef Mutable = (__CFSet *)a1[14];
    if (!Mutable)
    {
      CFDictionaryRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
      a1[14] = Mutable;
    }
    CFSetAddValue(Mutable, a2);
  }
  else
  {
    uint64_t v12 = (__CFSet *)a1[14];
    if (v12)
    {
      CFSetRemoveValue(v12, a2);
      if (!CFSetGetCount((CFSetRef)a1[14]))
      {
        CFRelease(a1[14]);
        a1[14] = 0;
      }
    }
  }

  sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", a1, 0, 1u);
}

CFDictionaryRef sub_1B64B1370(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 120);
  if (result)
  {
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  }
  return result;
}

void sub_1B64B13E8(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"worldRef");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"nodeRef");
LABEL_3:
  uint64_t v10 = *(void *)(a1 + 128);

  sub_1B64541AC(v10, value, a3, a4, a5, a6, a7, a8);
}

void sub_1B64B1474(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"worldRef");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"nodeRef");
LABEL_3:
  uint64_t v10 = *(void *)(a1 + 128);

  sub_1B6454280(v10, value, a3, a4, a5, a6, a7, a8);
}

void sub_1B64B1500(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"worldRef");
  }
  *(_DWORD *)(a1 + 292) = a2;
}

BOOL sub_1B64B1550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"worldRef");
  }
  return *(_DWORD *)(a1 + 292) > 0;
}

uint64_t sub_1B64B15A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
    if (a2)
    {
LABEL_3:
      if (!a1) {
        goto LABEL_14;
      }
      goto LABEL_7;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  if (!a1) {
    goto LABEL_14;
  }
LABEL_7:
  int v10 = *(_DWORD *)(a2 + 220);
  if ((v10 & 0x8000) != 0)
  {
    sub_1B64B0E98(a1, (void *)a2, a3, a4, a5, a6, a7, a8);
    int v10 = *(_DWORD *)(a2 + 220);
    if ((v10 & 0x40) == 0)
    {
LABEL_9:
      if ((v10 & 0x80000) == 0) {
        goto LABEL_10;
      }
      goto LABEL_29;
    }
  }
  else if ((v10 & 0x40) == 0)
  {
    goto LABEL_9;
  }
  sub_1B64412DC((id *)a1, (id *)a2);
  int v10 = *(_DWORD *)(a2 + 220);
  if ((v10 & 0x80000) == 0)
  {
LABEL_10:
    if ((v10 & 0x2000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_30;
  }
LABEL_29:
  sub_1B64B13E8(a1, (void *)a2, a3, a4, a5, a6, a7, a8);
  int v10 = *(_DWORD *)(a2 + 220);
  if ((v10 & 0x2000) == 0)
  {
LABEL_11:
    if ((v10 & 0x200) == 0) {
      goto LABEL_12;
    }
LABEL_31:
    sub_1B63C11C8(*(void *)(a1 + 136), (const void *)a2, a3, a4, a5, a6, a7, a8, v38);
    sub_1B65E46AC(a1, a2, v32, v33, v34, v35, v36, v37, v39);
    if ((*(_DWORD *)(a2 + 220) & 0x1000000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_30:
  sub_1B64B12BC((CFTypeRef *)a1, (const void *)a2, a3, a4, a5, a6, a7, a8);
  int v10 = *(_DWORD *)(a2 + 220);
  if ((v10 & 0x200) != 0) {
    goto LABEL_31;
  }
LABEL_12:
  if ((v10 & 0x1000000) != 0) {
LABEL_13:
  }
    sub_1B64B0F8C(a1, (void *)a2, a3, a4, a5, a6, a7, a8);
LABEL_14:
  CFArrayRef v11 = sub_1B64A3E10(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v11)
  {
    CFArrayRef v18 = v11;
    CFIndex Count = CFArrayGetCount(v11);
    if (Count >= 1)
    {
      CFIndex v20 = Count;
      for (CFIndex i = 0; i != v20; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v18, i);
        if (!ValueAtIndex) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. There should only be valid audio sources in this array", v23, v24, v25, v26, v27, v28, (uint64_t)"player != NULL");
        }
        sub_1B658F2AC(ValueAtIndex, v22, v23, v24);
      }
    }
  }
  uint64_t v30 = *(void *)(a1 + 480);
  if (v30) {
    sub_1B640D360(v30, a2, v12, v13);
  }
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    return sub_1B66267BC(result, a2, v12, v13, v14, v15, v16, v17);
  }
  return result;
}

uint64_t sub_1B64B1788(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 176))
  {
    if (*((unsigned char *)key + 223))
    {
      int v10 = *(__CFDictionary **)(a1 + 192);
      if (v10) {
        CFDictionaryRemoveValue(v10, key);
      }
    }
  }

  return sub_1B64B17E4(a1, (id *)key, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64B17E4(uint64_t a1, id *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  uint64_t v10 = *(void *)(a1 + 128);
  if (v10) {
    sub_1B64528B8(v10, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
  if (sub_1B64A457C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v11 = *(void *)(a1 + 96);
    uint64_t v56 = (uint64_t)a2;
    CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"nodeConstraints-%p");
    sub_1B660BA40(v11, 0, a2, (uint64_t)v12, v13, v14, v15, v16);
    CFRelease(v12);
  }
  if (sub_1B64A38FC((uint64_t)a2)) {
    sub_1B6454048(*(void *)(a1 + 128));
  }
  if (sub_1B64A4838((uint64_t)a2, v17, v18, v19, v20, v21, v22, v23)) {
    sub_1B6441484((id *)a1, a2);
  }
  if (sub_1B64A4888((uint64_t)a2, v24, v25, v26, v27, v28, v29, v30)) {
    sub_1B64B1474(a1, a2, v32, v33, v34, v35, v36, v37);
  }
  if (*(void *)(a1 + 136) && sub_1B64A3964((uint64_t)a2, v31, v32, v33, v34, v35, v36, v37))
  {
    sub_1B63C1468(*(void *)(a1 + 136), a2);
    sub_1B65E4DEC(a1, (uint64_t)a2, v38, v39, v40, v41, v42, v43, v56);
  }
  if (sub_1B64A0448((uint64_t)a2, v31, v32, v33, v34, v35, v36, v37))
  {
    uint64_t v51 = *(__CFSet **)(a1 + 112);
    if (v51)
    {
      CFSetRemoveValue(v51, a2);
      if (!CFSetGetCount(*(CFSetRef *)(a1 + 112)))
      {
        CFRelease(*(CFTypeRef *)(a1 + 112));
        *(void *)(a1 + 112) = 0;
      }
    }
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", (const void *)a1, 0, 1u);
  }
  sub_1B64A40F0((uint64_t)a2, v44, v45, v46, v47, v48, v49, v50);
  uint64_t v54 = *(void *)(a1 + 480);
  if (v54) {
    sub_1B640D368(v54, (uint64_t)a2, v52, v53);
  }
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    return sub_1B66269D0(result, (uint64_t)a2);
  }
  return result;
}

uint64_t sub_1B64B1998(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 176) && (a2[223] & 1) != 0) {
    sub_1B64B1028(a1, a2, 0, a4, a5, a6, a7, a8);
  }

  return sub_1B64B17E4(a1, (id *)a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64B19F4()
{
  if (qword_1EB9956D8 != -1) {
    dispatch_once(&qword_1EB9956D8, &unk_1F0FB5968);
  }
  return qword_1EB9956E0;
}

double sub_1B64B1A38()
{
  if (!qword_1EB9956E0)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB9956E0);
    qword_1EB9956E0 = (uint64_t)v0;
    CFNumberRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"fogColor", 0x1A0u, 12, 0, 0, 0, v2, v3);
    sub_1B660E400(@"fogDensityExponent", 0x190u, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"fogEndDistance", 0x18Cu, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"fogStartDistance", 0x188u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"wantsScreenSpaceReflection", 0x1B0u, 3, 0, 0, 0, v10, v11);
    sub_1B660E400(@"screenSpaceReflectionSampleCount", 0x1B2u, 2, 0, 0, 0, v12, v13);
    sub_1B660E400(@"screenSpaceReflectionMaximumDistance", 0x1B4u, 1, 0, 0, 0, v14, v15);
    sub_1B660E400(@"screenSpaceReflectionStride", 0x1B8u, 1, 0, 0, 0, v16, v17);
    sub_1B660E3EC();
    *(_OWORD *)&algn_1EB984D50[16] = xmmword_1F0FB8B50;
    *(_OWORD *)&algn_1EB984D50[32] = unk_1F0FB8B60;
    qword_1EB984D80 = qword_1F0FB8B70;
    unk_1EB984D88 = sub_1B64B3CC0;
    qword_1EB984D48 = (uint64_t)sub_1B64B3D58;
    double result = *(double *)&xmmword_1F0FB8B40;
    unk_1EB984DA0 = xmmword_1F0FB8B40;
  }
  return result;
}

uint64_t sub_1B64B1BE8()
{
  return sub_1B64B1BF4(1, 0);
}

uint64_t sub_1B64B1BF4(char a1, const void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (qword_1EB9956D8 != -1) {
    dispatch_once(&qword_1EB9956D8, &unk_1F0FB5968);
  }
  uint64_t v4 = sub_1B63C8D44(qword_1EB9956E0, 0x1E0uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *(void *)(v4 + 48) = v4;
    *(unsigned char *)(v4 + 72) = a1;
    *(void *)(v4 + 88) = sub_1B642183C();
    *(void *)(v5 + 96) = sub_1B660B9D4(v5);
    *(void *)(v5 + 104) = sub_1B660FC24();
    *(void *)(v5 + 136) = sub_1B63C0F5C(v5);
    *(void *)(v5 + 144) = sub_1B662481C();
    *(void *)(v5 + 152) = sub_1B656199C();
    *(void *)(v5 + 248) = 0x3F80000042700000;
    *(_DWORD *)(v5 + 276) = 1065353216;
    *(_DWORD *)(v5 + 288) = 1065353216;
    if (a2) {
      CFTypeRef v6 = CFRetain(a2);
    }
    else {
      CFTypeRef v6 = 0;
    }
    *(void *)(v5 + 80) = v6;
    *(void *)(v5 + 392) = 0;
    *(_DWORD *)(v5 + 400) = 1065353216;
    sub_1B63C8F2C((float *)(v5 + 416), 1.0, 1.0, 1.0, 1.0);
    *(unsigned char *)(v5 + 432) = 0;
    *(_WORD *)(v5 + 434) = 64;
    *(void *)(v5 + 436) = 0x41000000447A0000;
    *(void *)(v5 + 128) = sub_1B64521A0(v5);
    uint64_t v7 = (const void *)sub_1B650F31C(v5);
    *(void *)(v5 + 168) = v7;
    *(void *)(v5 + 160) = sub_1B65C4C94(v7);
    if (prof_getEnabled())
    {
      vfx_counters_get_default_ring_capacity();
      vfx_counters_create();
    }
    sub_1B6424578(*(void *)(v5 + 88), *(CFTypeRef *)(v5 + 104), v8, v9, v10, v11, v12, v13);
    v22.__sig = 0;
    *(void *)v22.__opaque = 0;
    pthread_mutexattr_init(&v22);
    pthread_mutexattr_settype(&v22, 2);
    pthread_mutexattr_setpolicy_np(&v22, 1);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 296), &v22);
    pthread_mutexattr_destroy(&v22);
    if (a1) {
      *(void *)(v5 + 176) = sub_1B6511654(v5, v14, v15, v16, v17, v18, v19, v20);
    }
    *(void *)(v5 + 184) = 0;
  }
  return v5;
}

void sub_1B64B1DE0(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  if (*(uint64_t **)(a1 + 64) != a2)
  {
    sub_1B6453D64(*(void *)(a1 + 128), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    uint64_t v17 = *(void **)(a1 + 64);
    if (v17)
    {
      if (sub_1B63F4F54(v17, v10, v11, v12, v13, v14, v15, v16) == a1) {
        sub_1B63F4AAC(*(void **)(a1 + 64), a1, v18, v19, v20, v21, v22, v23);
      }
      else {
        sub_1B63F2F54(0, @"Warning: CFXWorldSetRootNode - old root node seems to be already connected to another world", v18, v19, v20, v21, v22, v23, v28);
      }
      uint64_t v25 = *(uint64_t **)(a1 + 64);
      uint64_t v24 = a2;
      if (v25 == a2) {
        goto LABEL_17;
      }
      if (v25)
      {
        CFRelease(*(CFTypeRef *)(a1 + 64));
        *(void *)(a1 + 64) = 0;
      }
      if (!a2)
      {
        uint64_t v24 = 0;
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v24 = a2;
      if (!a2) {
        goto LABEL_17;
      }
    }
    uint64_t v24 = (uint64_t *)CFRetain(a2);
LABEL_16:
    *(void *)(a1 + 64) = v24;
LABEL_17:
    uint64_t v26 = *(uint64_t **)(a1 + 448);
    if (v26 != a2)
    {
      if (v26)
      {
        CFRelease(*(CFTypeRef *)(a1 + 448));
        *(void *)(a1 + 448) = 0;
      }
      if (a2) {
        CFTypeRef v27 = CFRetain(a2);
      }
      else {
        CFTypeRef v27 = 0;
      }
      *(void *)(a1 + 448) = v27;
      uint64_t v24 = *(uint64_t **)(a1 + 64);
    }
    if (v24)
    {
      sub_1B63F4CCC(v24, a1, v11, v12, v13, v14, v15, v16);
    }
  }
}

void sub_1B64B1F18(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  if (a3)
  {
    if (!a1) {
      return;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"originator");
    if (!a1) {
      return;
    }
  }
  uint64_t v12 = sub_1B6453474(*(void *)(a1 + 128), a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);

  sub_1B65854A8(v12, v10, a3, a4);
}

void sub_1B64B1FB4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B64B1FBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 64);
}

uint64_t sub_1B64B2008(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 88);
}

uint64_t sub_1B64B2054(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  uint64_t result = *(void *)(a1 + 176);
  if (result)
  {
    return sub_1B6355ECC(result);
  }
  return result;
}

uint64_t sub_1B64B20C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 176);
}

uint64_t sub_1B64B2110(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 80);
}

double sub_1B64B215C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(double *)(a1 + 232);
}

double sub_1B64B21A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(double *)(a1 + 240);
}

void sub_1B64B21F4(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(double *)(a1 + 232) = a2;
}

void sub_1B64B224C(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(double *)(a1 + 240) = a2;
}

float sub_1B64B22A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 248);
}

void sub_1B64B22F0(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(float *)(a1 + 248) = a2;
}

float sub_1B64B2348(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 252);
}

void sub_1B64B2394(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(float *)(a1 + 252) = a2;
}

float sub_1B64B23EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 288);
}

__n128 sub_1B64B2438(__n128 *a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  __n128 result = a1[17];
  *a2 = result;
  return result;
}

uint64_t sub_1B64B248C(uint64_t a1)
{
  return a1 + 296;
}

void sub_1B64B2494(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  ++*(_DWORD *)(a1 + 360);
  sub_1B63C2994(*(void *)(a1 + 136));
  uint64_t v16 = *(void *)(a1 + 168);

  sub_1B65101CC(v16, v9, v10, v11, v12, v13, v14, v15);
}

void sub_1B64B2504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  char v20 = 0;
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = sub_1B64B25F0;
  v16[3] = &unk_1E6142E58;
  v16[4] = &v17;
  sub_1B64B0E00(a1, (uint64_t)v16, a3, a4, a5, a6, a7, a8);
  if (*((unsigned char *)v18 + 24)) {
    sub_1B6510228(*(void *)(a1 + 168), v9, v10, v11, v12, v13, v14, v15);
  }
  _Block_object_dispose(&v17, 8);
}

void sub_1B64B25D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64B25F0(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1B64479BC(a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) |= result;
  return result;
}

uint64_t sub_1B64B262C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(unsigned int *)(a1 + 360);
}

void sub_1B64B2678(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  ++*(_DWORD *)(a1 + 364);
}

uint64_t sub_1B64B26CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(unsigned int *)(a1 + 364);
}

BOOL sub_1B64B2718(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return (a2 & ~*(unsigned __int8 *)(a1 + 72)) == 0;
}

uint64_t sub_1B64B2770(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 104);
}

uint64_t sub_1B64B27BC(uint64_t a1, int a2)
{
  if (a2 && !*(void *)(a1 + 368))
  {
    uint64_t v3 = sub_1B647541C(a1, 23);
    *(void *)(a1 + 368) = v3;
    uint64_t v4 = (const void *)sub_1B643DF88();
    sub_1B64766D8(v3, v4, v5, v6, v7, v8, v9, v10, v12);
  }
  return *(void *)(a1 + 368);
}

uint64_t sub_1B64B2810(uint64_t a1, int a2)
{
  if (a2 && !*(void *)(a1 + 376))
  {
    uint64_t v3 = sub_1B647541C(a1, 24);
    *(void *)(a1 + 376) = v3;
    uint64_t v4 = (const void *)sub_1B643DF88();
    sub_1B64766D8(v3, v4, v5, v6, v7, v8, v9, v10, v12);
  }
  return *(void *)(a1 + 376);
}

uint64_t sub_1B64B2864(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 128);
}

uint64_t sub_1B64B28B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 136);
}

uint64_t sub_1B64B28FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 144);
}

uint64_t sub_1B64B2948(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 152);
}

uint64_t sub_1B64B2994(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 160);
}

uint64_t sub_1B64B29E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 168);
}

float sub_1B64B2A2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 400);
}

void sub_1B64B2A78(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(float *)(a1 + 400) = a2;
}

float sub_1B64B2AD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 396);
}

void sub_1B64B2B1C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(float *)(a1 + 396) = a2;
}

float sub_1B64B2B74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 392);
}

void sub_1B64B2BC0(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(float *)(a1 + 392) = a2;
}

__n128 sub_1B64B2C18(__n128 *a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  __n128 result = *a2;
  a1[26] = *a2;
  return result;
}

uint64_t sub_1B64B2C6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return a1 + 416;
}

void sub_1B64B2CB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
}

uint64_t sub_1B64B2D5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(unsigned __int8 *)(a1 + 432);
}

void sub_1B64B2DA8(unsigned char *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  if (a1[432] != a2)
  {
    a1[432] = a2;
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", a1, 0, 1u);
  }
}

uint64_t sub_1B64B2E3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(unsigned __int16 *)(a1 + 434);
}

void sub_1B64B2E88(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  *(_WORD *)(a1 + 434) = a2;
}

float sub_1B64B2ED8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 436);
}

void sub_1B64B2F24(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(float *)(a1 + 436) = a2;
}

float sub_1B64B2F7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(float *)(a1 + 440);
}

void sub_1B64B2FC8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"world");
  }
  *(float *)(a1 + 440) = a2;
}

void sub_1B64B3020(uint64_t a1, simd_float4x4 *a2)
{
  simd_float4x4 v52 = __invert_f4(*a2);
  simd_float4 v10 = v52.columns[0];
  simd_float4 v11 = v52.columns[1];
  simd_float4 v12 = v52.columns[2];
  if (!a1)
  {
    simd_float4 v42 = v52.columns[1];
    simd_float4 v43 = v52.columns[0];
    simd_float4 v40 = v52.columns[3];
    simd_float4 v41 = v52.columns[2];
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v4, v5, v6, v7, v8, v9, (uint64_t)"world");
    v52.columns[3] = v40;
    simd_float4 v12 = v41;
    simd_float4 v11 = v42;
    simd_float4 v10 = v43;
  }
  float v13 = COERCE_FLOAT(*(void *)(a1 + 280));
  if (v13 == 1.0)
  {
    unint64_t v14 = 0;
    v52.columns[1] = (simd_float4)vrsqrteq_f32((float32x4_t)xmmword_1B6E4F540);
    v52.columns[1] = (simd_float4)vmulq_f32((float32x4_t)v52.columns[1], vrsqrtsq_f32((float32x4_t)xmmword_1B6E4F540, vmulq_f32((float32x4_t)v52.columns[1], (float32x4_t)v52.columns[1])));
    v52.columns[1] = (simd_float4)vmulq_f32(vmulq_f32((float32x4_t)v52.columns[1], vrsqrtsq_f32((float32x4_t)xmmword_1B6E4F540, vmulq_f32((float32x4_t)v52.columns[1], (float32x4_t)v52.columns[1]))), (float32x4_t)xmmword_1B6E4F300);
    float32x4_t v15 = vmulq_f32((float32x4_t)v52.columns[1], (float32x4_t)v52.columns[1]);
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v20 = vmlaq_f32(v15, (float32x4_t)vdupq_n_s32(0xB33BBD2E), vsubq_f32((float32x4_t)v52.columns[0], v15));
    v52.columns[2].f32[0] = vmuls_lane_f32(v52.columns[1].f32[0], *(float32x2_t *)v52.columns[1].f32, 1);
    float v21 = vmuls_lane_f32(v52.columns[1].f32[0], (float32x4_t)v52.columns[1], 2);
    float v22 = vmuls_lane_f32(v52.columns[1].f32[1], (float32x4_t)v52.columns[1], 2);
    *(float *)&unsigned int v23 = v52.columns[1].f32[1] + v21;
    *(float *)&unsigned int v24 = v52.columns[1].f32[2] + v52.columns[2].f32[0];
    v52.columns[0].f32[0] = v21 - v52.columns[1].f32[1];
    v52.columns[0].f32[1] = v52.columns[1].f32[0] + v22;
    v52.columns[0].i64[1] = v20.u32[2];
    *(float *)&unsigned int v25 = v22 - v52.columns[1].f32[0];
    v52.columns[1].i32[0] = v20.i32[0];
    v52.columns[1].f32[1] = v52.columns[2].f32[0] - v52.columns[1].f32[2];
    v52.columns[1].i64[1] = v23;
    v52.columns[2].i64[0] = __PAIR64__(v20.u32[1], v24);
    v52.columns[2].i64[1] = v25;
    simd_float4 v44 = v10;
    simd_float4 v45 = v11;
    simd_float4 v46 = v12;
    simd_float4 v47 = v52.columns[3];
    simd_float4 v48 = 0u;
    simd_float4 v49 = 0u;
    simd_float4 v50 = 0u;
    simd_float4 v51 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v48 + v14) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v52.columns[1], COERCE_FLOAT(*(_OWORD *)((char *)&v44 + v14))), (float32x4_t)v52.columns[2], *(float32x2_t *)&v44.f32[v14 / 4], 1), (float32x4_t)v52.columns[0], *(float32x4_t *)((char *)&v44 + v14), 2), (float32x4_t)xmmword_1B6E4F370, *(float32x4_t *)((char *)&v44 + v14), 3);
      v14 += 16;
    }
    while (v14 != 64);
LABEL_14:
    simd_float4 v10 = v48;
    simd_float4 v11 = v49;
    simd_float4 v12 = v50;
    v52.columns[3] = v51;
    goto LABEL_15;
  }
  if (v13 == -1.0)
  {
    unint64_t v26 = 0;
    v52.columns[1] = (simd_float4)vrsqrteq_f32((float32x4_t)xmmword_1B6E4F540);
    v52.columns[1] = (simd_float4)vmulq_f32((float32x4_t)v52.columns[1], vrsqrtsq_f32((float32x4_t)xmmword_1B6E4F540, vmulq_f32((float32x4_t)v52.columns[1], (float32x4_t)v52.columns[1])));
    v52.columns[0] = (simd_float4)vmulq_f32(vmulq_f32((float32x4_t)v52.columns[1], vrsqrtsq_f32((float32x4_t)xmmword_1B6E4F540, vmulq_f32((float32x4_t)v52.columns[1], (float32x4_t)v52.columns[1]))), (float32x4_t)xmmword_1B6E4F300);
    float32x4_t v27 = vmulq_f32((float32x4_t)v52.columns[0], (float32x4_t)v52.columns[0]);
    __asm { FMOV            V1.4S, #1.0 }
    int8x16_t v28 = (int8x16_t)vmlaq_f32(v27, (float32x4_t)vdupq_n_s32(0xB33BBD2E), vsubq_f32((float32x4_t)v52.columns[1], v27));
    v52.columns[1].f32[0] = vmulq_lane_f32((float32x4_t)v52.columns[0], *(float32x2_t *)v52.columns[0].f32, 1).f32[0];
    v52.columns[2] = (simd_float4)vnegq_f32((float32x4_t)v52.columns[0]);
    *(float *)&unsigned int v29 = v52.columns[1].f32[0] - v52.columns[2].f32[2];
    *(float *)&unsigned int v30 = v52.columns[2].f32[2] + v52.columns[1].f32[0];
    *(float32x2_t *)v52.columns[1].f32 = vmul_laneq_f32(*(float32x2_t *)v52.columns[0].f32, (float32x4_t)v52.columns[0], 2);
    *(float *)&unsigned int v31 = v52.columns[2].f32[1] + v52.columns[1].f32[0];
    float32x2_t v32 = (float32x2_t)vrev64_s32(*(int32x2_t *)v52.columns[2].f32);
    v52.columns[0].i32[0] = vsub_f32(*(float32x2_t *)v52.columns[1].f32, v32).u32[0];
    v52.columns[0].i32[1] = vadd_f32(*(float32x2_t *)(&v52 + 16), v32).i32[1];
    v52.columns[0].i64[1] = vextq_s8(v28, v28, 8uLL).u32[0];
    v32.f32[0] = v52.columns[1].f32[1] - v52.columns[2].f32[0];
    v52.columns[1].i64[0] = __PAIR64__(v29, v28.u32[0]);
    v52.columns[1].i64[1] = v31;
    v52.columns[2].i64[0] = __PAIR64__(v28.u32[1], v30);
    v52.columns[2].i64[1] = v32.u32[0];
    simd_float4 v44 = v10;
    simd_float4 v45 = v11;
    simd_float4 v46 = v12;
    simd_float4 v47 = v52.columns[3];
    simd_float4 v48 = 0u;
    simd_float4 v49 = 0u;
    simd_float4 v50 = 0u;
    simd_float4 v51 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v48 + v26) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v52.columns[1], COERCE_FLOAT(*(_OWORD *)((char *)&v44 + v26))), (float32x4_t)v52.columns[2], *(float32x2_t *)&v44.f32[v26 / 4], 1), (float32x4_t)v52.columns[0], *(float32x4_t *)((char *)&v44 + v26), 2), (float32x4_t)xmmword_1B6E4F370, *(float32x4_t *)((char *)&v44 + v26), 3);
      v26 += 16;
    }
    while (v26 != 64);
    goto LABEL_14;
  }
  if (COERCE_FLOAT(HIDWORD(*(void *)(a1 + 272))) == -1.0)
  {
    unint64_t v33 = 0;
    v52.columns[1] = (simd_float4)vrsqrteq_f32((float32x4_t)xmmword_1B6E4F540);
    v52.columns[1] = (simd_float4)vmulq_f32((float32x4_t)v52.columns[1], vrsqrtsq_f32((float32x4_t)xmmword_1B6E4F540, vmulq_f32((float32x4_t)v52.columns[1], (float32x4_t)v52.columns[1])));
    v52.columns[0] = (simd_float4)vmulq_f32(vmulq_f32((float32x4_t)v52.columns[1], vrsqrtsq_f32((float32x4_t)xmmword_1B6E4F540, vmulq_f32((float32x4_t)v52.columns[1], (float32x4_t)v52.columns[1]))), (float32x4_t)xmmword_1B6E4F300);
    float32x4_t v34 = vmulq_f32((float32x4_t)v52.columns[0], (float32x4_t)v52.columns[0]);
    __asm
    {
      FMOV            V1.4S, #1.0
      FMOV            V2.4S, #-1.0
    }
    int8x16_t v35 = (int8x16_t)vmlaq_f32(v34, (float32x4_t)v52.columns[2], vsubq_f32((float32x4_t)v52.columns[1], v34));
    v52.columns[1].f32[0] = vmulq_lane_f32((float32x4_t)v52.columns[0], *(float32x2_t *)v52.columns[0].f32, 1).f32[0];
    v52.columns[1].f32[0] = v52.columns[1].f32[0] + v52.columns[1].f32[0];
    v52.columns[2] = (simd_float4)vmulq_f32((float32x4_t)v52.columns[0], (float32x4_t)vdupq_n_s32(0x33BBBD2Eu));
    *(float *)&unsigned int v36 = v52.columns[1].f32[0] - v52.columns[2].f32[2];
    *(float *)&unsigned int v37 = v52.columns[2].f32[2] + v52.columns[1].f32[0];
    *(float32x2_t *)v52.columns[0].f32 = vmul_laneq_f32(*(float32x2_t *)v52.columns[0].f32, (float32x4_t)v52.columns[0], 2);
    *(float32x2_t *)v52.columns[1].f32 = vadd_f32(*(float32x2_t *)v52.columns[0].f32, *(float32x2_t *)v52.columns[0].f32);
    *(float *)&unsigned int v38 = v52.columns[2].f32[1] + v52.columns[1].f32[0];
    float32x2_t v39 = (float32x2_t)vrev64_s32(*(int32x2_t *)v52.columns[2].f32);
    v52.columns[0].i32[0] = vsub_f32(*(float32x2_t *)v52.columns[1].f32, v39).u32[0];
    v52.columns[0].i32[1] = vadd_f32(*(float32x2_t *)(&v52 + 16), v39).i32[1];
    v52.columns[0].i64[1] = vextq_s8(v35, v35, 8uLL).u32[0];
    v39.f32[0] = v52.columns[1].f32[1] - v52.columns[2].f32[0];
    v52.columns[1].i64[0] = __PAIR64__(v36, v35.u32[0]);
    v52.columns[1].i64[1] = v38;
    v52.columns[2].i64[0] = __PAIR64__(v35.u32[1], v37);
    v52.columns[2].i64[1] = v39.u32[0];
    simd_float4 v44 = v10;
    simd_float4 v45 = v11;
    simd_float4 v46 = v12;
    simd_float4 v47 = v52.columns[3];
    simd_float4 v48 = 0u;
    simd_float4 v49 = 0u;
    simd_float4 v50 = 0u;
    simd_float4 v51 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v48 + v33) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v52.columns[1], COERCE_FLOAT(*(_OWORD *)((char *)&v44 + v33))), (float32x4_t)v52.columns[2], *(float32x2_t *)&v44.f32[v33 / 4], 1), (float32x4_t)v52.columns[0], *(float32x4_t *)((char *)&v44 + v33), 2), (float32x4_t)xmmword_1B6E4F370, *(float32x4_t *)((char *)&v44 + v33), 3);
      v33 += 16;
    }
    while (v33 != 64);
    goto LABEL_14;
  }
LABEL_15:
  a2->columns[0] = v10;
  a2->columns[1] = v11;
  a2->columns[2] = v12;
  a2->columns[3] = v52.columns[3];
}

double sub_1B64B33CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  float v9 = COERCE_FLOAT(*(void *)(a1 + 280));
  if (v9 == 1.0)
  {
    uint64_t v10 = 0;
    long long v14 = xmmword_1B6E4F300;
    long long v15 = xmmword_1B6E4F320;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v16 = xmmword_1B6E4F2E0;
    long long v17 = xmmword_1B6E4F370;
    do
    {
      *(long long *)((char *)&v18 + v10) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v14 + v10))), (float32x4_t)xmmword_1B6E51290, *(float32x2_t *)((char *)&v14 + v10), 1), (float32x4_t)xmmword_1B6E512A0, *(float32x4_t *)((char *)&v14 + v10), 2), (float32x4_t)xmmword_1B6E4F370, *(float32x4_t *)((char *)&v14 + v10), 3);
      v10 += 16;
    }
    while (v10 != 64);
    return *(double *)&v18;
  }
  if (v9 == -1.0)
  {
    uint64_t v11 = 0;
    long long v14 = xmmword_1B6E4F300;
    long long v15 = xmmword_1B6E4F320;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v16 = xmmword_1B6E4F2E0;
    long long v17 = xmmword_1B6E4F370;
    do
    {
      *(long long *)((char *)&v18 + v11) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v14 + v11))), (float32x4_t)xmmword_1B6E51270, *(float32x2_t *)((char *)&v14 + v11), 1), (float32x4_t)xmmword_1B6E51280, *(float32x4_t *)((char *)&v14 + v11), 2), (float32x4_t)xmmword_1B6E4F370, *(float32x4_t *)((char *)&v14 + v11), 3);
      v11 += 16;
    }
    while (v11 != 64);
    return *(double *)&v18;
  }
  if (COERCE_FLOAT(HIDWORD(*(void *)(a1 + 272))) == -1.0)
  {
    uint64_t v12 = 0;
    long long v14 = xmmword_1B6E4F300;
    long long v15 = xmmword_1B6E4F320;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v16 = xmmword_1B6E4F2E0;
    long long v17 = xmmword_1B6E4F370;
    do
    {
      *(long long *)((char *)&v18 + v12) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v14 + v12))), (float32x4_t)xmmword_1B6E51250, *(float32x2_t *)((char *)&v14 + v12), 1), (float32x4_t)xmmword_1B6E51260, *(float32x4_t *)((char *)&v14 + v12), 2), (float32x4_t)xmmword_1B6E4F370, *(float32x4_t *)((char *)&v14 + v12), 3);
      v12 += 16;
    }
    while (v12 != 64);
    return *(double *)&v18;
  }
  *(void *)&double result = 1065353216;
  return result;
}

uint64_t sub_1B64B35C0(uint64_t result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v4 = result;
    double result = *(void *)(result + 480);
    if (result) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = a2 == 0;
    }
    if (!v5)
    {
      double result = sub_1B640D310(v4, a2, a3, a4);
      *(void *)(v4 + 480) = result;
    }
  }
  return result;
}

void sub_1B64B3604(uint64_t a1, int a2, void *cf, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)cf, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  if (a2 >= 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Only %d layers are available, but layer %d requested", (uint64_t)cf, a4, a5, a6, a7, a8, (uint64_t)"layer < CFX_MAX_LAYERS");
  }
  uint64_t v11 = a1 + 8 * a2;
  uint64_t v12 = *(const void **)(v11 + 448);
  if (v12 != cf)
  {
    float v13 = (void *)(v11 + 448);
    if (v12)
    {
      CFRelease(v12);
      *float v13 = 0;
    }
    if (cf) {
      CFTypeRef v14 = CFRetain(cf);
    }
    else {
      CFTypeRef v14 = 0;
    }
    *float v13 = v14;
  }
  sub_1B64A4D50((uint64_t)cf, a2, (uint64_t)cf, a4, a5, a6, a7, a8);
  if (cf)
  {
    sub_1B63F4CCC((uint64_t *)cf, a1, v15, v16, v17, v18, v19, v20);
  }
}

uint64_t sub_1B64B36FC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  if (a2 >= 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Only %d layers are available, but layer %d requested", a3, a4, a5, a6, a7, a8, (uint64_t)"layer < CFX_MAX_LAYERS");
  }
  return *(void *)(a1 + 8 * a2 + 448);
}

void sub_1B64B377C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  ++*(_DWORD *)(a1 + 384);
}

uint64_t sub_1B64B37D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(unsigned int *)(a1 + 384);
}

BOOL sub_1B64B381C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  uint64_t v9 = *(void *)(a1 + 376);
  if (!v9 || !sub_1B6477268(v9)) {
    return 0;
  }

  return sub_1B6475F88(v9, v10, v11, v12, v13, v14, v15, v16);
}

uint64_t sub_1B64B38A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(unsigned __int8 *)(a1 + 388);
}

void sub_1B64B38EC(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  *(unsigned char *)(a1 + 388) = a2;
}

uint64_t sub_1B64B393C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  return *(void *)(a1 + 488);
}

CFTypeRef sub_1B64B3988(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 184);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 184) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 184) = result;
  }
  return result;
}

id sub_1B64B3A08(uint64_t a1)
{
  sub_1B6595A0C(@"kCFXNotificationWorldWillDie", (const void *)a1, 0, 1u);
  uint64_t v9 = *(const void **)(a1 + 160);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 160) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 168);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 168) = 0;
  }
  uint64_t v11 = *(const void **)(a1 + 136);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 136) = 0;
  }
  uint64_t v12 = *(const void **)(a1 + 144);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v13 = *(const void **)(a1 + 80);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 80) = 0;
  }
  for (uint64_t i = 448; i != 480; i += 8)
  {
    uint64_t v15 = *(void *)(a1 + i);
    if (v15)
    {
      if (sub_1B63F4F08(v15, v2, v3, v4, v5, v6, v7, v8) != *(void *)(a1 + 48)) {
        sub_1B63F2F54(0, @"Warning: RootNode is not retained by the world", v16, v17, v18, v19, v20, v21, v54);
      }
      sub_1B63F4AAC(*(void **)(a1 + i), a1, v16, v17, v18, v19, v20, v21);
    }
  }
  uint64_t v22 = *(void *)(a1 + 96);
  if (v22) {
    *(void *)(v22 + 24) = 0;
  }
  unsigned int v23 = *(const void **)(a1 + 64);
  if (v23)
  {
    CFRelease(v23);
    *(void *)(a1 + 64) = 0;
  }
  unsigned int v24 = *(const void **)(a1 + 88);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a1 + 88) = 0;
  }
  unsigned int v25 = *(const void **)(a1 + 104);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(a1 + 104) = 0;
  }
  unint64_t v26 = *(const void **)(a1 + 96);
  if (v26)
  {
    CFRelease(v26);
    *(void *)(a1 + 96) = 0;
  }
  float32x4_t v27 = *(const void **)(a1 + 112);
  if (v27)
  {
    CFRelease(v27);
    *(void *)(a1 + 112) = 0;
  }
  int8x16_t v28 = *(const void **)(a1 + 120);
  if (v28)
  {
    CFRelease(v28);
    *(void *)(a1 + 120) = 0;
  }
  unsigned int v29 = *(const void **)(a1 + 192);
  if (v29)
  {
    CFRelease(v29);
    *(void *)(a1 + 192) = 0;
  }
  unsigned int v30 = *(const void **)(a1 + 200);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(a1 + 200) = 0;
  }
  unsigned int v31 = *(const void **)(a1 + 368);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(a1 + 368) = 0;
  }
  float32x2_t v32 = *(const void **)(a1 + 376);
  if (v32)
  {
    CFRelease(v32);
    *(void *)(a1 + 376) = 0;
  }
  unint64_t v33 = *(const void **)(a1 + 152);
  if (v33)
  {
    CFRelease(v33);
    *(void *)(a1 + 152) = 0;
  }
  float32x4_t v34 = *(const void **)(a1 + 480);
  if (v34)
  {
    CFRelease(v34);
    *(void *)(a1 + 480) = 0;
  }
  for (uint64_t j = 448; j != 480; j += 8)
  {
    unsigned int v36 = *(const void **)(a1 + j);
    if (v36)
    {
      CFRelease(v36);
      *(void *)(a1 + j) = 0;
    }
  }
  unsigned int v37 = *(const void **)(a1 + 176);
  if (v37)
  {
    unsigned int v38 = (const char *)vfx_counters_null();
    sub_1B65118F4((uint64_t)v37, v38, v39, v40);
    sub_1B6511954(*(void *)(a1 + 176), 0, v41, v42);
    unsigned int v37 = *(const void **)(a1 + 176);
  }
  simd_float4 v43 = *(const void **)(a1 + 184);
  if (v43)
  {
    CFRelease(v43);
    *(void *)(a1 + 184) = 0;
  }
  simd_float4 v44 = *(const void **)(a1 + 208);
  if (v44)
  {
    CFRelease(v44);
    *(void *)(a1 + 208) = 0;
  }
  simd_float4 v45 = *(const void **)(a1 + 128);
  if (v45)
  {
    CFRelease(v45);
    *(void *)(a1 + 128) = 0;
  }
  if (v37) {
    CFRelease(v37);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 296));
  vfx_counters_destroy(*(void **)(a1 + 488));

  return sub_1B658325C(a1, v46, v47, v48, v49, v50, v51, v52);
}

CFStringRef sub_1B64B3C58(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXWorld>");
}

CFStringRef sub_1B64B3C8C(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXWorld>");
}

uint64_t sub_1B64B3CC0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v11, v12, v13, v14, v15, v16, (uint64_t)"world");
  }
  uint64_t v18 = *(const void **)(a1 + 64);

  return sub_1B63F4FC8(v18, (uint64_t)a2);
}

void sub_1B64B3D48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__CFArray *sub_1B64B3D58(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v71 = 2;
  int valuePtr = 5;
  uint64_t v70 = a1 + 64;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v5, @"name", @"root");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v71 = 0;
  int valuePtr = 6;
  uint64_t v70 = a1 + 232;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v9, @"name", @"startTime");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v71 = 0;
  int valuePtr = 6;
  uint64_t v70 = a1 + 240;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v13, @"name", @"endTime");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = v3;
  uint64_t v18 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v19 = CFDictionaryCreateMutable(0, 4, v17, MEMORY[0x1E4F1D540]);
  int v71 = 0;
  int valuePtr = 1;
  uint64_t v70 = a1 + 248;
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v19, @"name", @"frameRate");
  CFDictionarySetValue(v19, @"type", v20);
  CFDictionarySetValue(v19, @"address", v22);
  CFDictionarySetValue(v19, @"semantic", v21);
  CFArrayAppendValue(Mutable, v19);
  CFRelease(v21);
  CFRelease(v19);
  CFRelease(v22);
  CFRelease(v20);
  unsigned int v23 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v18);
  int v71 = 0;
  int valuePtr = 1;
  uint64_t v24 = a1;
  uint64_t v70 = a1 + 252;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v23, @"name", @"playbackSpeed");
  CFDictionarySetValue(v23, @"type", v25);
  CFDictionarySetValue(v23, @"address", v27);
  CFDictionarySetValue(v23, @"semantic", v26);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v26);
  CFRelease(v23);
  CFRelease(v27);
  CFRelease(v25);
  int8x16_t v28 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v18);
  int v71 = 2;
  int valuePtr = 5;
  uint64_t v70 = a1 + 256;
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v28, @"name", @"attributes");
  CFDictionarySetValue(v28, @"type", v29);
  CFDictionarySetValue(v28, @"address", v31);
  CFDictionarySetValue(v28, @"semantic", v30);
  CFArrayAppendValue(Mutable, v28);
  CFRelease(v30);
  CFRelease(v28);
  CFRelease(v31);
  CFRelease(v29);
  float32x2_t v32 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v18);
  int v71 = 0;
  int valuePtr = 8;
  uint64_t v70 = a1 + 272;
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v32, @"name", @"upAxis");
  CFDictionarySetValue(v32, @"type", v33);
  CFDictionarySetValue(v32, @"address", v35);
  CFDictionarySetValue(v32, @"semantic", v34);
  unsigned int v36 = Mutable;
  CFArrayAppendValue(Mutable, v32);
  CFRelease(v34);
  CFRelease(v32);
  CFRelease(v35);
  CFRelease(v33);
  unsigned int v37 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v18);
  int v71 = 0;
  int valuePtr = 1;
  uint64_t v38 = v24;
  uint64_t v70 = v24 + 288;
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v40 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v37, @"name", @"unit");
  CFDictionarySetValue(v37, @"type", v39);
  CFDictionarySetValue(v37, @"address", v41);
  CFDictionarySetValue(v37, @"semantic", v40);
  CFArrayAppendValue(v36, v37);
  CFRelease(v40);
  CFRelease(v37);
  CFRelease(v41);
  CFRelease(v39);
  uint64_t v42 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v18);
  int v71 = 2;
  int valuePtr = 5;
  uint64_t v70 = v24 + 88;
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v44 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v45 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v42, @"name", @"animationManager");
  CFDictionarySetValue(v42, @"type", v43);
  CFDictionarySetValue(v42, @"address", v45);
  CFDictionarySetValue(v42, @"semantic", v44);
  CFArrayAppendValue(v36, v42);
  CFRelease(v44);
  CFRelease(v42);
  CFRelease(v45);
  CFRelease(v43);
  uint64_t v46 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v18);
  int v71 = 2;
  int valuePtr = 5;
  uint64_t v70 = v24 + 368;
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v48 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v46, @"name", @"background");
  CFDictionarySetValue(v46, @"type", v47);
  CFDictionarySetValue(v46, @"address", v49);
  CFDictionarySetValue(v46, @"semantic", v48);
  CFArrayAppendValue(v36, v46);
  CFRelease(v48);
  CFRelease(v46);
  CFRelease(v49);
  CFRelease(v47);
  uint64_t v50 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v51 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v52 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v71 = 2;
  int valuePtr = 5;
  uint64_t v70 = v38 + 376;
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v54 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v55 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v52, @"name", @"environment");
  CFDictionarySetValue(v52, @"type", v53);
  CFDictionarySetValue(v52, @"address", v55);
  CFDictionarySetValue(v52, @"semantic", v54);
  uint64_t v56 = v36;
  CFArrayAppendValue(v36, v52);
  CFRelease(v54);
  CFRelease(v52);
  CFRelease(v55);
  CFRelease(v53);
  int v57 = CFDictionaryCreateMutable(0, 4, v50, v51);
  int v71 = 0;
  int valuePtr = 2;
  uint64_t v70 = v38 + 48;
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v57, @"name", @"worldRef");
  CFDictionarySetValue(v57, @"type", v58);
  CFDictionarySetValue(v57, @"address", v60);
  CFDictionarySetValue(v57, @"semantic", v59);
  CFArrayAppendValue(v36, v57);
  CFRelease(v59);
  CFRelease(v57);
  CFRelease(v60);
  CFRelease(v58);
  uint64_t v61 = CFDictionaryCreateMutable(0, 4, v50, MEMORY[0x1E4F1D540]);
  int v71 = 2;
  int valuePtr = 5;
  uint64_t v70 = v38 + 136;
  CFNumberRef v62 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v63 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v64 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v61, @"name", @"lightingSystem");
  CFDictionarySetValue(v61, @"type", v62);
  CFDictionarySetValue(v61, @"address", v64);
  CFDictionarySetValue(v61, @"semantic", v63);
  CFArrayAppendValue(v36, v61);
  CFRelease(v63);
  CFRelease(v61);
  CFRelease(v64);
  CFRelease(v62);
  uint64_t v65 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v71 = 2;
  int valuePtr = 5;
  uint64_t v70 = v38 + 144;
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberSInt32Type, &v71);
  CFNumberRef v68 = CFNumberCreate(0, kCFNumberLongType, &v70);
  CFDictionarySetValue(v65, @"name", @"raytracingSystem");
  CFDictionarySetValue(v65, @"type", v66);
  CFDictionarySetValue(v65, @"address", v68);
  CFDictionarySetValue(v65, @"semantic", v67);
  CFArrayAppendValue(v56, v65);
  CFRelease(v67);
  CFRelease(v65);
  CFRelease(v68);
  CFRelease(v66);
  return v56;
}

void sub_1B64B4DA8(uint64_t a1)
{
}

CFStringRef sub_1B64B4F04(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  return sub_1B65834BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B5304(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 20));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 24), v10, *(void *)(a1 + 48), v11);
    CFStringRef v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 20);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B64B5518(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64B55E0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64B56BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64B57A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64B5CE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B64B5E3C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B5F18(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B6254(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B639C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B64FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B6664(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B67B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B6920(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B6AC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B6C2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B6EC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B6ED4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B6FB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B709C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

float sub_1B64B7378(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B649C1B8(*(float **)(*(void *)(a1 + 32) + 8), *(float *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

float sub_1B64B74E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B649C684(*(float **)(*(void *)(a1 + 32) + 8), *(float *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

float sub_1B64B7658(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B649C0CC(*(float **)(*(void *)(a1 + 32) + 8), *(float *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B64B77B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B78F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B7A38(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64B7CA8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649A7E4(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B7DFC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649A6CC(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B7F50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649A8FC(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B80A4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649AA14(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B81F8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649AB2C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B834C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649AC44(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B84A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649AD5C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B85F4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649AE74(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B8748(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649B0A4(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B889C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649AF8C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B89F0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649B1BC(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B8B44(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649B2D4(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64B8C98(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B649B3EC(v4, v5, v6, v7, v8, v9, v10, v11);
}

id sub_1B64B8E20(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id result = (id)objc_msgSend_setWithArray_(MEMORY[0x1E4F1CAD0], a2, (uint64_t)&unk_1F103BF48, a4);
  qword_1E9DDAF50 = (uint64_t)result;
  return result;
}

uint64_t VFXSetResourceBundle(uint64_t result)
{
  qword_1E9DDAF60 = result;
  return result;
}

BOOL VFXHasSpecialResourceBundle()
{
  return qword_1E9DDAF60 != 0;
}

uint64_t VFXGetResourceBundle(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = qword_1E9DDAF60;
  if (!qword_1E9DDAF60) {
    return objc_msgSend_mainBundle(MEMORY[0x1E4F28B50], a2, a3, a4);
  }
  return result;
}

uint64_t sub_1B64BA000()
{
  uint64_t v0 = (void *)MEMORY[0x1E4F28B50];
  uint64_t v2 = objc_opt_class();

  return objc_msgSend_bundleForClass_(v0, v1, v2, v3);
}

id VFXSetExternalTextureSource(id result)
{
  if ((id)qword_1E9DDAF68 != result)
  {
    CFAllocatorRef v1 = result;

    uint64_t result = v1;
    qword_1E9DDAF68 = (uint64_t)result;
  }
  return result;
}

uint64_t VFXGetExternalTextureSource()
{
  return qword_1E9DDAF68;
}

id sub_1B64BA090(id result, const char *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v2 = result;
    objc_msgSend_getControlPointAtIndex_values_(result, a2, 1, (uint64_t)v4);
    objc_msgSend_getControlPointAtIndex_values_(v2, v3, 2, (uint64_t)v5);
    return (id)sub_1B6433180(v4[0], v4[1], v5[0], v5[1]);
  }
  return result;
}

uint64_t sub_1B64BA118(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (_DWORD *)sub_1B6433204(a1, a2, a3, a4, a5, a6, a7, a8);
  LODWORD(v12) = *v8;
  LODWORD(v13) = v8[1];
  LODWORD(v14) = v8[2];
  LODWORD(v15) = v8[3];
  CFNumberRef v16 = (void *)MEMORY[0x1E4F39C10];

  return objc_msgSend_functionWithControlPoints__::(v16, v9, v10, v11, v12, v13, v14, v15);
}

uint64_t sub_1B64BA154(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  components[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  components[0] = a1;
  components[1] = a2;
  components[2] = a3;
  components[3] = a4;
  uint64_t v4 = (CGColorSpace *)sub_1B63C93CC();
  uint64_t v5 = CGColorCreate(v4, components);
  uint64_t v8 = objc_msgSend_colorWithCGColor_(MEMORY[0x1E4FB1618], v6, (uint64_t)v5, v7);
  CGColorRelease(v5);
  return v8;
}

uint64_t sub_1B64BA1DC(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  components[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  components[0] = a1;
  components[1] = a2;
  components[2] = a3;
  components[3] = a4;
  uint64_t v4 = (CGColorSpace *)sub_1B63C94EC();
  uint64_t v5 = CGColorCreate(v4, components);
  uint64_t v8 = objc_msgSend_colorWithCGColor_(MEMORY[0x1E4FB1618], v6, (uint64_t)v5, v7);
  CGColorRelease(v5);
  return v8;
}

double sub_1B64BA268(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CGColor *)objc_msgSend_CGColor(a1, a2, a3, a4);

  return sub_1B63C9530(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64BA290(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v3 = sub_1B63C98BC(*a3, a3[1]);
  uint64_t v6 = objc_msgSend_colorWithCGColor_(MEMORY[0x1E4FB1618], v4, (uint64_t)v3, v5);
  CGColorRelease(v3);
  return v6;
}

uint64_t sub_1B64BA2E4(void *a1, const char *a2, float32x2_t *a3, uint64_t a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    if (!a3) {
      return 0;
    }
    float64x2_t v4 = vcvtq_f64_f32(a3[1]);
    float64x2_t v11 = vcvtq_f64_f32(*a3);
    float64x2_t v12 = v4;
    uint64_t v5 = (CGColorSpace *)sub_1B63C921C();
    uint64_t v6 = CGColorCreate(v5, v11.f64);
    uint64_t v9 = objc_msgSend_colorWithCGColor_(MEMORY[0x1E4FB1618], v7, (uint64_t)v6, v8, *(_OWORD *)&v11, *(_OWORD *)&v12);
    CGColorRelease(v6);
    return v9;
  }
  else
  {
    return objc_msgSend_vfx_colorWithCFXColor_(a1, a2, (uint64_t)a3, a4);
  }
}

CGColor *sub_1B64BA3BC(void *a1, const char *a2, uint64_t a3, BOOL *a4)
{
  int v5 = a3;
  uint64_t result = (CGColor *)objc_msgSend_CGColor(a1, a2, a3, (uint64_t)a4);
  uint64_t v13 = result;
  if (result)
  {
    uint64_t result = (CGColor *)sub_1B63C95C8(result, v5, v7, v8, v9, v10, v11, v12);
    if (!a4) {
      return result;
    }
  }
  else if (!a4)
  {
    return result;
  }
  *a4 = v13 != 0;
  return result;
}

uint64_t sub_1B64BA41C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (void *)MEMORY[0x1E4F1CA48];
  uint64_t v7 = objc_msgSend_count(a1, a2, a3, a4);
  uint64_t v10 = objc_msgSend_arrayWithCapacity_(v6, v8, v7, v9);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  v14[2] = sub_1B64BA4C4;
  v14[3] = &unk_1E6142E88;
  long long v14[4] = v10;
  v14[5] = a3;
  objc_msgSend_enumerateObjectsUsingBlock_(a1, v11, (uint64_t)v14, v12);
  return v10;
}

uint64_t sub_1B64BA4C4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v6, v3, v5, v4);
  }
  return result;
}

double sub_1B64BA51C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_valueForKey_(a1, a2, @"x", a4);
  objc_msgSend_floatValue(v5, v6, v7, v8);
  unsigned int v25 = v9;
  uint64_t v12 = objc_msgSend_valueForKey_(a1, v10, @"y", v11);
  objc_msgSend_floatValue(v12, v13, v14, v15);
  unsigned int v24 = v16;
  uint64_t v19 = objc_msgSend_valueForKey_(a1, v17, @"z", v18);
  objc_msgSend_floatValue(v19, v20, v21, v22);
  return COERCE_DOUBLE(__PAIR64__(v24, v25));
}

double sub_1B64BA594(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_valueForKey_(a1, a2, @"x", a4);
  objc_msgSend_floatValue(v5, v6, v7, v8);
  unsigned int v31 = v9;
  uint64_t v12 = objc_msgSend_valueForKey_(a1, v10, @"y", v11);
  objc_msgSend_floatValue(v12, v13, v14, v15);
  unsigned int v30 = v16;
  uint64_t v19 = objc_msgSend_valueForKey_(a1, v17, @"z", v18);
  objc_msgSend_floatValue(v19, v20, v21, v22);
  unsigned int v25 = objc_msgSend_valueForKey_(a1, v23, @"w", v24);
  objc_msgSend_floatValue(v25, v26, v27, v28);
  return COERCE_DOUBLE(__PAIR64__(v30, v31));
}

__n128 sub_1B64BA62C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_valueForKey_(a1, a2, @"m11", a4);
  objc_msgSend_floatValue(v5, v6, v7, v8);
  unsigned int v107 = v9;
  uint64_t v12 = objc_msgSend_valueForKey_(a1, v10, @"m12", v11);
  objc_msgSend_floatValue(v12, v13, v14, v15);
  unsigned int v106 = v16;
  uint64_t v19 = objc_msgSend_valueForKey_(a1, v17, @"m13", v18);
  objc_msgSend_floatValue(v19, v20, v21, v22);
  unsigned int v105 = v23;
  CFNumberRef v26 = objc_msgSend_valueForKey_(a1, v24, @"m14", v25);
  objc_msgSend_floatValue(v26, v27, v28, v29);
  *(void *)&long long v30 = __PAIR64__(v106, v107);
  *((void *)&v30 + 1) = __PAIR64__(v31, v105);
  long long v108 = v30;
  CFNumberRef v34 = objc_msgSend_valueForKey_(a1, v32, @"m21", v33);
  objc_msgSend_floatValue(v34, v35, v36, v37);
  CFNumberRef v40 = objc_msgSend_valueForKey_(a1, v38, @"m22", v39);
  objc_msgSend_floatValue(v40, v41, v42, v43);
  uint64_t v46 = objc_msgSend_valueForKey_(a1, v44, @"m23", v45);
  objc_msgSend_floatValue(v46, v47, v48, v49);
  uint64_t v52 = objc_msgSend_valueForKey_(a1, v50, @"m24", v51);
  objc_msgSend_floatValue(v52, v53, v54, v55);
  CFNumberRef v58 = objc_msgSend_valueForKey_(a1, v56, @"m31", v57);
  objc_msgSend_floatValue(v58, v59, v60, v61);
  CFNumberRef v64 = objc_msgSend_valueForKey_(a1, v62, @"m32", v63);
  objc_msgSend_floatValue(v64, v65, v66, v67);
  uint64_t v70 = objc_msgSend_valueForKey_(a1, v68, @"m33", v69);
  objc_msgSend_floatValue(v70, v71, v72, v73);
  long long v76 = objc_msgSend_valueForKey_(a1, v74, @"m34", v75);
  objc_msgSend_floatValue(v76, v77, v78, v79);
  float32x4_t v82 = objc_msgSend_valueForKey_(a1, v80, @"m41", v81);
  objc_msgSend_floatValue(v82, v83, v84, v85);
  long long v88 = objc_msgSend_valueForKey_(a1, v86, @"m42", v87);
  objc_msgSend_floatValue(v88, v89, v90, v91);
  uint64_t v94 = objc_msgSend_valueForKey_(a1, v92, @"m43", v93);
  objc_msgSend_floatValue(v94, v95, v96, v97);
  uint64_t v100 = objc_msgSend_valueForKey_(a1, v98, @"m44", v99);
  objc_msgSend_floatValue(v100, v101, v102, v103);
  return (__n128)v108;
}

uint64_t sub_1B64BA828(double a1, double a2, uint64_t a3, const char *a4)
{
  *(double *)uint64_t v5 = a1;
  *(double *)&v5[1] = a2;
  return objc_msgSend_valueWithBytes_objCType_(MEMORY[0x1E4F29238], a4, (uint64_t)v5, (uint64_t)"{CGPoint=dd}");
}

double sub_1B64BA860(void *a1, const char *a2)
{
  v3[0] = 0;
  v3[1] = 0;
  objc_msgSend_getValue_size_(a1, a2, (uint64_t)v3, 16);
  return *(double *)v3;
}

uint64_t sub_1B64BA890(float32x2_t a1, uint64_t a2, const char *a3)
{
  float64x2_t v4 = vcvtq_f64_f32(a1);
  return objc_msgSend_valueWithBytes_objCType_(MEMORY[0x1E4F29238], a3, (uint64_t)&v4, (uint64_t)"{CGPoint=dd}");
}

float32x2_t sub_1B64BA8CC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (const char *)objc_msgSend_objCType(a1, a2, a3, a4);
  if (!strcmp(v5, "{?=ff}"))
  {
    v13.f64[0] = 0.0;
    objc_msgSend_getValue_size_(a1, v6, (uint64_t)&v13, 8);
    return *(float32x2_t *)&v13.f64[0];
  }
  else
  {
    unsigned int v9 = (const char *)objc_msgSend_objCType(a1, v6, v7, v8);
    int v10 = strcmp(v9, "{CGPoint=dd}");
    float32x2_t result = 0;
    if (!v10)
    {
      float64x2_t v13 = 0uLL;
      objc_msgSend_getValue_size_(a1, v11, (uint64_t)&v13, 16, 0.0);
      return vcvt_f32_f64(v13);
    }
  }
  return result;
}

uint64_t sub_1B64BA95C(__n128 a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_valueWithCGRect_(MEMORY[0x1E4F29238], a3, a4, a5, a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2], 0.0);
}

double sub_1B64BA984(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (const char *)objc_msgSend_objCType(a1, a2, a3, a4);
  if (!strcmp(v5, "{?=fff}"))
  {
    LODWORD(v14.f64[1]) = 0;
    v14.f64[0] = 0.0;
    objc_msgSend_getValue_size_(a1, v6, (uint64_t)&v14, 12);
    *(float64_t *)&long long v12 = v14.f64[0];
  }
  else
  {
    unsigned int v9 = (const char *)objc_msgSend_objCType(a1, v6, v7, v8);
    int v10 = strcmp(v9, "{CGRect={CGPoint=dd}{CGSize=dd}}");
    long long v12 = 0uLL;
    if (!v10)
    {
      memset(&v14, 0, 32);
      objc_msgSend_getValue_size_(a1, v11, (uint64_t)&v14, 32);
      *(float32x2_t *)&long long v12 = vcvt_f32_f64(v14);
    }
  }
  return *(double *)&v12;
}

uint64_t sub_1B64BAA24(__n128 a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_valueWithCGRect_(MEMORY[0x1E4F29238], a3, a4, a5, a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2], a1.n128_f32[3]);
}

float64_t sub_1B64BAA50(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (const char *)objc_msgSend_objCType(a1, a2, a3, a4);
  if (!strcmp(v5, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
  {
    float64x2_t v13 = 0u;
    float64x2_t v14 = 0u;
    objc_msgSend_getValue_size_(a1, v6, (uint64_t)&v13, 32);
    *(void *)&float64_t result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v13), v14).u64[0];
  }
  else
  {
    unsigned int v9 = (const char *)objc_msgSend_objCType(a1, v6, v7, v8);
    int v10 = strcmp(v9, "{?=ffff}");
    float64_t result = 0.0;
    if (!v10)
    {
      float64x2_t v13 = 0uLL;
      objc_msgSend_getValue_size_(a1, v11, (uint64_t)&v13, 16, 0.0);
      return v13.f64[0];
    }
  }
  return result;
}

uint64_t sub_1B64BAAE8(void *a1, const char *a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, uint64_t a7, uint64_t a8)
{
  v9[0] = vcvtq_f64_f32(*(float32x2_t *)a3.f32);
  v9[1] = vcvt_hight_f64_f32(a3);
  v9[2] = vcvtq_f64_f32(*(float32x2_t *)a4.f32);
  v9[3] = vcvt_hight_f64_f32(a4);
  v9[4] = vcvtq_f64_f32(*(float32x2_t *)a5.f32);
  v9[5] = vcvt_hight_f64_f32(a5);
  v9[6] = vcvtq_f64_f32(*(float32x2_t *)a6.f32);
  v9[7] = vcvt_hight_f64_f32(a6);
  return objc_msgSend_valueWithCATransform3D_(a1, a2, (uint64_t)v9, a8);
}

double sub_1B64BAB3C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (const char *)objc_msgSend_objCType(a1, a2, a3, a4);
  if (strcmp(v5, "{CATransform3D=dddddddddddddddd}")) {
    return *(double *)&VFXMatrix4Identity;
  }
  double result = 0.0;
  if (a1)
  {
    objc_msgSend_CATransform3DValue(a1, v6, v7, v8);
    *(void *)&double result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)0), (float64x2_t)0).u64[0];
  }
  return result;
}

__CFString *sub_1B64BABF0(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend_floatValue(a1, v2, v3, v4);
    return (__CFString *)objc_msgSend_stringWithFormat_(NSString, v6, @"%.2f", v7, v5);
  }
  unsigned int v9 = (const char *)objc_msgSend_objCType(a1, v2, v3, v4);
  if (!strcmp(v9, "{?=ff}"))
  {
    *(void *)&long long v91 = 0;
    objc_msgSend_getValue_size_(a1, v10, (uint64_t)&v91, 8);
    return (__CFString *)objc_msgSend_stringWithFormat_(NSString, v25, @"%.2f %.2f", v26, *(float *)&v91, *((float *)&v91 + 1));
  }
  float64x2_t v13 = (const char *)objc_msgSend_objCType(a1, v10, v11, v12);
  if (!strcmp(v13, "{?=fff}"))
  {
    DWORD2(v91) = 0;
    *(void *)&long long v91 = 0;
    objc_msgSend_getValue_size_(a1, v14, (uint64_t)&v91, 12);
    return (__CFString *)objc_msgSend_stringWithFormat_(NSString, v27, @"%.2f %.2f %.2f", v28, *(float *)&v91, *((float *)&v91 + 1), *((float *)&v91 + 2));
  }
  uint64_t v17 = (const char *)objc_msgSend_objCType(a1, v14, v15, v16);
  if (!strcmp(v17, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
  {
    long long v91 = 0u;
    long long v92 = 0u;
    objc_msgSend_getValue_size_(a1, v18, (uint64_t)&v91, 32);
    return (__CFString *)objc_msgSend_stringWithFormat_(NSString, v29, @"%.2f %.2f %.2f %.2f", v30, v91, v92);
  }
  uint64_t v21 = (const char *)objc_msgSend_objCType(a1, v18, v19, v20);
  if (!strcmp(v21, "{CATransform3D=dddddddddddddddd}"))
  {
    objc_msgSend_VFXMatrix4Value(a1, v22, v23, v24);
    float32x4_t v38 = vmulq_f32(v33, v33);
    float32x4_t v39 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1)));
    v39.f32[0] = sqrtf(v39.f32[0]);
    float32x4_t v40 = vmulq_f32(v34, v34);
    float32x4_t v41 = vmulq_f32(v35, v35);
    float v42 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0]);
    float v43 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0]);
    float32x4_t v44 = v39;
    v44.f32[1] = v42;
    float32x4_t v45 = v44;
    v45.f32[2] = v43;
    uint32x4_t v46 = (uint32x4_t)vceqzq_f32(v45);
    v46.i32[3] = v46.i32[2];
    if ((vmaxvq_u32(v46) & 0x80000000) != 0) {
      return @"non-affine matrix";
    }
    float32x4_t v47 = vdivq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0));
    float32x4_t v48 = vdivq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1));
    float32x4_t v49 = vdivq_f32(v35, (float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2));
    int32x4_t v50 = (int32x4_t)vmulq_f32(v47, v47);
    int32x4_t v51 = (int32x4_t)vmulq_f32(v48, v48);
    int32x4_t v52 = (int32x4_t)vmulq_f32(v49, v49);
    int32x4_t v53 = vzip2q_s32(v50, v52);
    float32x4_t v54 = (float32x4_t)vzip1q_s32(vzip1q_s32(v50, v52), v51);
    float32x4_t v55 = (float32x4_t)vtrn2q_s32(v50, v51);
    v55.i32[2] = v52.i32[1];
    float32x4_t v56 = vaddq_f32((float32x4_t)vzip1q_s32(v53, vdupq_laneq_s32(v51, 2)), vaddq_f32(v54, v55));
    v55.i64[0] = 0x80000000800000;
    v55.i64[1] = 0x80000000800000;
    int8x16_t v57 = (int8x16_t)vcgeq_f32(v55, v56);
    v56.i32[3] = 0;
    float32x4_t v58 = vrsqrteq_f32(v56);
    float32x4_t v59 = vmulq_f32(v58, vrsqrtsq_f32(v56, vmulq_f32(v58, v58)));
    int32x4_t v60 = (int32x4_t)v57;
    v60.i32[3] = 0;
    float32x4_t v61 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v60), (int8x16_t)v56, (int8x16_t)vmulq_f32(v59, vrsqrtsq_f32(v56, vmulq_f32(v59, v59))));
    float32x4_t v62 = vmulq_n_f32(v47, v61.f32[0]);
    float32x4_t v63 = vmulq_lane_f32(v48, *(float32x2_t *)v61.f32, 1);
    float32x4_t v64 = vmulq_laneq_f32(v49, v61, 2);
    int8x16_t v65 = (int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64);
    int8x16_t v66 = (int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63);
    int32x4_t v67 = (int32x4_t)v62;
    if (v57.i32[0])
    {
      int8x16_t v68 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v65, (int8x16_t)v64, 0xCuLL), vnegq_f32(v63)), v64, (float32x4_t)vextq_s8(v66, (int8x16_t)v63, 0xCuLL));
      int32x4_t v67 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), v68, 0xCuLL);
    }
    int8x16_t v69 = (int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62);
    float32x4_t v70 = v63;
    if (v57.i32[1])
    {
      int8x16_t v71 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v69, (int8x16_t)v62, 0xCuLL), vnegq_f32(v64)), v62, (float32x4_t)vextq_s8(v65, (int8x16_t)v64, 0xCuLL));
      float32x4_t v70 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v71, (int32x4_t)v71), v71, 0xCuLL);
    }
    if (v57.i32[2])
    {
      int8x16_t v57 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v66, (int8x16_t)v63, 0xCuLL), vnegq_f32(v62)), v63, (float32x4_t)vextq_s8(v69, (int8x16_t)v62, 0xCuLL));
      float32x4_t v64 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v57, (int32x4_t)v57), v57, 0xCuLL);
    }
    float v72 = (float)(*(float *)v67.i32 + v70.f32[1]) + v64.f32[2];
    if (v72 > 0.0)
    {
      float32x4_t v73 = (float32x4_t)vzip2q_s32((int32x4_t)v70, vuzp1q_s32((int32x4_t)v70, (int32x4_t)v64));
      v73.i32[2] = v67.i32[1];
      float v74 = sqrtf(v72 + 1.0);
      float32x4_t v75 = (float32x4_t)vtrn2q_s32((int32x4_t)v64, vzip2q_s32((int32x4_t)v64, v67));
      v75.i32[2] = v70.i32[0];
      float32x4_t v77 = vsubq_f32(v73, v75);
      v73.f32[3] = v74;
      v75.f32[3] = v74;
      float32x4_t v76 = vmulq_f32(v73, v75);
      v77.i32[3] = v76.i32[3];
LABEL_32:
      v76.f32[0] = 0.5 / v74;
      float32x4_t v87 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v76.f32, 0);
      goto LABEL_33;
    }
    if (*(float *)v67.i32 < v70.f32[1] || *(float *)v67.i32 < v64.f32[2])
    {
      if (v70.f32[1] <= v64.f32[2])
      {
        float v74 = sqrtf((float)((float)(v64.f32[2] + 1.0) - *(float *)v67.i32) - v70.f32[1]);
        *(float32x2_t *)v77.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v67, (int32x4_t)v70), *(float32x2_t *)v64.f32);
        float32x2_t v88 = (float32x2_t)__PAIR64__(v67.u32[1], LODWORD(v74));
        float32x2_t v89 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v70.f32, 0);
        *(float32x2_t *)v76.f32 = vsub_f32(*(float32x2_t *)v67.i8, v89);
        v89.f32[0] = v74;
        v89.i32[0] = vmul_f32(v88, v89).u32[0];
        v89.i32[1] = v76.i32[1];
        *(float32x2_t *)&v77.u32[2] = v89;
        goto LABEL_32;
      }
      float v81 = sqrtf((float)((float)(v70.f32[1] + 1.0) - *(float *)v67.i32) - v64.f32[2]);
      *(int32x2_t *)v57.i8 = vdup_laneq_s32((int32x4_t)v70, 2);
      int8x16_t v79 = v57;
      *(float *)v79.i32 = v81;
      v79.i32[0] = vmul_f32(*(float32x2_t *)v79.i8, (float32x2_t)__PAIR64__(v64.u32[1], LODWORD(v81))).u32[0];
      v79.i32[1] = vadd_f32(*(float32x2_t *)&v57, *(float32x2_t *)&v64).i32[1];
      int8x16_t v80 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v67.i8, 1), v70);
      int32x2_t v86 = (int32x2_t)vsubq_f32(v64, (float32x4_t)vdupq_laneq_s32(v67, 2)).u64[0];
      float32x4_t v87 = (float32x4_t)vextq_s8(vextq_s8(v80, v80, 4uLL), v79, 0xCuLL);
      v87.i32[3] = v86.i32[0];
    }
    else
    {
      float v81 = sqrtf((float)((float)(*(float *)v67.i32 + 1.0) - v70.f32[1]) - v64.f32[2]);
      float32x2_t v82 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v70.f32, 0);
      float32x2_t v83 = vadd_f32(*(float32x2_t *)v67.i8, v82);
      v82.f32[0] = v81;
      v87.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v67.u32[1], LODWORD(v81)), v82).u32[0];
      v87.i32[1] = v83.i32[1];
      float32x2_t v84 = (float32x2_t)vzip2q_s32(v67, (int32x4_t)v70).u64[0];
      LODWORD(v85) = vadd_f32(v84, *(float32x2_t *)v64.f32).u32[0];
      int32x2_t v86 = (int32x2_t)vsub_f32(v84, *(float32x2_t *)v64.f32);
      HIDWORD(v85) = v86.i32[1];
      v87.i64[1] = v85;
    }
    *(float *)v86.i32 = 0.5 / v81;
    float32x4_t v77 = (float32x4_t)vdupq_lane_s32(v86, 0);
LABEL_33:
    float32x4_t v90 = vmulq_f32(v87, v77);
    return (__CFString *)objc_msgSend_stringWithFormat_(NSString, v31, @"p[%.2f %.2f %.2f] q[%.2f %.2f %.2f %.2f] s[%.2f %.2f %.2f]", v32, *(float *)&v36, *((float *)&v36 + 1), v37, v90.f32[0], v90.f32[1], v90.f32[2], v90.f32[3], v39.f32[0], v42, v43);
  }

  return (__CFString *)objc_msgSend_description(a1, v22, v23, v24);
}

uint64_t sub_1B64BB0E0(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1;
  }
  uint64_t v6 = (const char *)objc_msgSend_objCType(a1, v2, v3, v4);
  if (!strcmp(v6, "{CGPoint=dd}")) {
    return 2;
  }
  int v10 = (const char *)objc_msgSend_objCType(a1, v7, v8, v9);
  if (!strcmp(v10, "{?=ff}")) {
    return 2;
  }
  float64x2_t v14 = (const char *)objc_msgSend_objCType(a1, v11, v12, v13);
  if (!strcmp(v14, "{?=fff}")) {
    return 3;
  }
  uint64_t v18 = (const char *)objc_msgSend_objCType(a1, v15, v16, v17);
  if (!strcmp(v18, "{CGRect={CGPoint=dd}{CGSize=dd}}")) {
    return 4;
  }
  uint64_t v22 = (const char *)objc_msgSend_objCType(a1, v19, v20, v21);
  if (!strcmp(v22, "{?=ffff}")) {
    return 4;
  }
  uint64_t v26 = (const char *)objc_msgSend_objCType(a1, v23, v24, v25);
  return 16 * (strcmp(v26, "{CATransform3D=dddddddddddddddd}") == 0);
}

id sub_1B64BB1D4(void *a1, const char *a2, void *a3, uint64_t a4)
{
  int v6 = objc_msgSend_length(a3, a2, (uint64_t)a3, a4);
  if (v6 == 3)
  {
    float32x4_t v34 = (const char *)objc_msgSend_objCType(a1, v7, v8, v9);
    if (!strcmp(v34, "{CATransform3D=dddddddddddddddd}"))
    {
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      if (a1) {
        objc_msgSend_CATransform3DValue(a1, v35, v36, v37);
      }
      int v39 = objc_msgSend_characterAtIndex_(a3, v35, 1, v37);
      unsigned int v42 = objc_msgSend_characterAtIndex_(a3, v40, 2, v41);
      if ((v39 - 49) <= 3 && v42 >= 0x31 && v42 <= 0x34) {
        return (id)objc_msgSend_numberWithDouble_(NSNumber, v43, v44, v45, *((double *)&v54 + 4 * v39 + v42 - 245));
      }
    }
    goto LABEL_12;
  }
  if (v6 != 1 || (int v10 = objc_msgSend_characterAtIndex_(a3, v7, 0, v9), (v10 & 0xFFFC) != 0x78))
  {
LABEL_12:
    v53.receiver = a1;
    v53.super_class = (Class)&off_1F1080100;
    return objc_msgSendSuper2(&v53, sel_valueForUndefinedKey_, a3);
  }
  int v11 = v10;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return a1;
  }
  int v15 = v11 - 120;
  uint64_t v16 = (const char *)objc_msgSend_objCType(a1, v12, v13, v14);
  if (!strcmp(v16, "{?=ff}"))
  {
    *(void *)&long long v54 = 0;
    objc_msgSend_getValue_size_(a1, v17, (uint64_t)&v54, 8);
    int32x4_t v50 = NSNumber;
    int32x4_t v51 = (char *)&v54 + 4;
    if (!v15) {
      int32x4_t v51 = (char *)&v54;
    }
    goto LABEL_24;
  }
  uint64_t v20 = (const char *)objc_msgSend_objCType(a1, v17, v18, v19);
  if (!strcmp(v20, "{CGPoint=dd}"))
  {
    long long v54 = 0uLL;
    objc_msgSend_getValue_size_(a1, v21, (uint64_t)&v54, 16);
    int32x4_t v50 = NSNumber;
    if (v15) {
      int32x4_t v52 = (double *)&v54 + 1;
    }
    else {
      int32x4_t v52 = (double *)&v54;
    }
    double v49 = *v52;
    *(float *)&double v49 = *v52;
    return (id)objc_msgSend_numberWithFloat_(v50, v46, v47, v48, v49);
  }
  uint64_t v24 = (const char *)objc_msgSend_objCType(a1, v21, v22, v23);
  if (!strcmp(v24, "{?=fff}"))
  {
    DWORD2(v54) = 0;
    *(void *)&long long v54 = 0;
    objc_msgSend_getValue_size_(a1, v25, (uint64_t)&v54, 12);
    int32x4_t v50 = NSNumber;
    if (!v15)
    {
      LODWORD(v49) = v54;
      return (id)objc_msgSend_numberWithFloat_(v50, v46, v47, v48, v49);
    }
    int32x4_t v51 = (char *)&v54 + 4;
    if (v15 != 2) {
      int32x4_t v51 = (char *)&v54 + 8;
    }
LABEL_24:
    LODWORD(v49) = *(_DWORD *)v51;
    return (id)objc_msgSend_numberWithFloat_(v50, v46, v47, v48, v49);
  }
  uint64_t v28 = (const char *)objc_msgSend_objCType(a1, v25, v26, v27);
  if (strcmp(v28, "{CGRect={CGPoint=dd}{CGSize=dd}}")) {
    goto LABEL_12;
  }
  long long v54 = 0u;
  long long v55 = 0u;
  objc_msgSend_getValue_size_(a1, v29, (uint64_t)&v54, 32);
  switch(v15)
  {
    case 0:
      return (id)objc_msgSend_numberWithDouble_(NSNumber, v30, v31, v32, *(double *)&v54);
    case 1:
      return (id)objc_msgSend_numberWithDouble_(NSNumber, v30, v31, v32, *((double *)&v54 + 1));
    case 2:
      return (id)objc_msgSend_numberWithDouble_(NSNumber, v30, v31, v32, *(double *)&v55);
    case 3:
      return (id)objc_msgSend_numberWithDouble_(NSNumber, v30, v31, v32, *((double *)&v55 + 1));
    default:
      a1 = &unk_1F103BB40;
      break;
  }
  return a1;
}

CFTypeRef sub_1B64BB4BC(CFTypeRef cf)
{
  if (!cf) {
    return cf;
  }
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 != CGColorGetTypeID()) {
    return cf;
  }
  float v5 = (void *)MEMORY[0x1E4FB1618];

  return (CFTypeRef)objc_msgSend_colorWithCGColor_(v5, v3, (uint64_t)cf, v4);
}

double sub_1B64BB524(void *a1)
{
  CFAllocatorRef v1 = a1;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFURLGetTypeID()) {
    CFAllocatorRef v1 = objc_msgSend_path(v1, v3, v4, v5);
  }
  if (!v1) {
    return 0.0;
  }
  uint64_t v20 = 0;
  uint64_t v6 = objc_msgSend_stringByResolvingSymlinksInPath(v1, v3, v4, v5);
  int v10 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v7, v8, v9);
  uint64_t v12 = objc_msgSend_attributesOfItemAtPath_error_(v10, v11, v6, (uint64_t)&v20);
  int v15 = objc_msgSend_objectForKey_(v12, v13, *MEMORY[0x1E4F28310], v14);
  if (!v15) {
    return 0.0;
  }
  objc_msgSend_timeIntervalSinceReferenceDate(v15, v16, v17, v18);
  return result;
}

uint64_t sub_1B64BB5B8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  uint64_t v11 = a3;
  uint64_t v12 = sub_1B63CA534(a2, a2, a3, a4, a5, a6, a7, a8) + a3;
  uint64_t v13 = malloc_type_malloc(v12, 0xADBA6ABAuLL);
  uint64_t v15 = (uint64_t)v13;
  if (v8) {
    *uint64_t v13 = a2;
  }
  sub_1B66047AC(a1, (uint64_t)&v13[v11], a2, v14);
  uint64_t v17 = (void *)MEMORY[0x1E4F1C9B8];

  return objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(v17, v16, v15, v12, 1);
}

uint64_t VFXDataFromValue(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 0;
  }
  uint64_t v6 = (const char *)objc_msgSend_objCType(a1, a2, a3, a4);
  uint64_t v7 = sub_1B6604568(v6);
  if (!v7) {
    return 0;
  }

  return sub_1B64BB5B8(a1, v7, (uint64_t)a2, v8, v9, v10, v11, v12);
}

void *sub_1B64BB6B0(void *result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = objc_msgSend_bytes(result, a2, a3, a4);
    unint64_t v11 = objc_msgSend_length(v6, v8, v9, v10);
    if (sub_1B63CA534((int)a2, v12, v13, v14, v15, v16, v17, v18) + a3 <= v11)
    {
      sub_1B63CA534((int)a2, v19, v20, v21, v22, v23, v24, v25);
      __memcpy_chk();
      return (void *)sub_1B6604BA0((double *)(v7 + a3), a2, v28, v26, v27);
    }
    else
    {
      if ((byte_1E9DDAF70 & 1) == 0)
      {
        byte_1E9DDAF70 = 1;
        sub_1B63F2F54(16, @"Error: _VFXValueFromDataAndType - out of bounds", v20, v21, v22, v23, v24, v25, v29);
      }
      return 0;
    }
  }
  return result;
}

void *VFXValueFromDataAndType(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return sub_1B64BB6B0(a1, a2, 0, a4);
}

void *VFXValueFromData(void *result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = (const char *)*(unsigned __int8 *)objc_msgSend_bytes(result, a2, a3, a4);
    return sub_1B64BB6B0(v4, v5, 1, v6);
  }
  return result;
}

uint64_t VFXDataFromArrayOfValues(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t result = objc_msgSend_count(a1, a2, a3, a4);
  if (result)
  {
    uint64_t v8 = objc_msgSend_objectAtIndexedSubscript_(a1, v6, 0, v7);
    uint64_t v12 = sub_1B6604B4C(v8, v9, v10, v11);
    uint64_t v20 = sub_1B65625B4((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19);
    if (v20)
    {
      uint64_t v28 = v20;
      uint64_t v29 = sub_1B6562484((uint64_t)v12, v21, v22, v23, v24, v25, v26, v27);
      uint64_t v33 = objc_msgSend_count(a1, v30, v31, v32) * v29 + 6;
      float32x4_t v34 = malloc_type_malloc(v33, 0x3041AA15uLL);
      *(_DWORD *)float32x4_t v34 = objc_msgSend_count(a1, v35, v36, v37);
      void v34[2] = v28;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      uint64_t v39 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v38, (uint64_t)&v47, (uint64_t)v51, 16);
      if (v39)
      {
        uint64_t v42 = v39;
        uint64_t v43 = (uint64_t)(v34 + 3);
        uint64_t v44 = *(void *)v48;
        do
        {
          uint64_t v45 = 0;
          do
          {
            if (*(void *)v48 != v44) {
              objc_enumerationMutation(a1);
            }
            sub_1B66047AC(*(void **)(*((void *)&v47 + 1) + 8 * v45), v43, v28, v41);
            v43 += v29;
            ++v45;
          }
          while (v42 != v45);
          uint64_t v42 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v46, (uint64_t)&v47, (uint64_t)v51, 16);
        }
        while (v42);
      }
      return objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(MEMORY[0x1E4F1C9B8], v40, (uint64_t)v34, v33, 1);
    }
    else
    {
      sub_1B63F2F54(16, @"Error: VFXDataFromArrayOfValues - unknown type", v22, v23, v24, v25, v26, v27, v47);
      return 0;
    }
  }
  return result;
}

void *VFXArrayOfValueFromData(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (unsigned int *)objc_msgSend_bytes(a1, a2, a3, a4);
  __int16 v13 = *((_WORD *)v5 + 2);
  if (!v13)
  {
    uint64_t v30 = @"Error: VFXArrayOfValueFromData - unknown type";
LABEL_9:
    sub_1B63F2F54(16, (uint64_t)v30, v7, v8, v9, v10, v11, v12, *(uint64_t *)&v32[0]);
    return 0;
  }
  uint64_t v14 = v5;
  uint64_t v15 = *v5;
  uint64_t v16 = (const char *)v13;
  uint64_t v17 = sub_1B63CA534(v13, v6, v7, v8, v9, v10, v11, v12);
  if (v17 * v15 + 6 != objc_msgSend_length(a1, v18, v19, v20))
  {
    uint64_t v30 = @"Error: VFXArrayOfValueFromData - unexpected data length";
    goto LABEL_9;
  }
  uint64_t v22 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], v21, v15, v8);
  if (v15)
  {
    uint64_t v23 = (char *)v14 + 6;
    do
    {
      memset(v32, 0, sizeof(v32));
      __memcpy_chk();
      uint64_t v27 = sub_1B6604BA0((double *)v32, v16, v26, v24, v25);
      v23 += v17;
      objc_msgSend_addObject_(v22, v28, v27, v29);
      LODWORD(v15) = v15 - 1;
    }
    while (v15);
  }
  return v22;
}

void sub_1B64BBD60(uint64_t a1)
{
}

CFStringRef sub_1B64BBED0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  return sub_1B65834BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void *sub_1B64BC388(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)a1 != 5) {
    return 0;
  }
  uint64_t v5 = *(unsigned __int8 *)(a1 + 32);
  uint64_t v9 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], a2, v5, a4);
  if (v5)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 8 * v5;
    do
    {
      uint64_t v12 = objc_msgSend_valueWithCGPoint_(MEMORY[0x1E4F29238], v6, v7, v8, vcvtq_f64_f32(*(float32x2_t *)(*(void *)(a1 + 40) + v10)));
      objc_msgSend_addObject_(v9, v13, v12, v14);
      v10 += 8;
    }
    while (v11 != v10);
  }
  return v9;
}

void sub_1B64BC78C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 20));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 24), v10, *(void *)(a1 + 48), v11);
    uint64_t v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 20);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B64BC9A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64BCA68(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64BCB44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64BCC28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64BD168(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B64BD2C4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64BD3A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

id sub_1B64BD5B0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id result = (id)objc_msgSend_setWithArray_(MEMORY[0x1E4F1CAD0], a2, (uint64_t)&unk_1F103BF78, a4);
  qword_1E9DDAF78 = (uint64_t)result;
  return result;
}

void sub_1B64BDDF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BDEE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64BE034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BE18C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64BE2E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BE420(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BE554(uint64_t a1)
{
  uint64_t v2 = sub_1B64FA004(*(const void **)(a1 + 32), 0);
  v10[1] = v3;
  sub_1B6494CAC(*(float32x4_t **)(*(void *)(a1 + 40) + 8), (float *)v10, v4, v5, v6, v7, v8, v9, v2);
}

void sub_1B64BE758(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, uint64_t a11)
{
  a9.i32[0] = *(_DWORD *)(a1 + 40);
  sub_1B6495E54(*(float32x4_t **)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

void sub_1B64BE8AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BE9F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BEB38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64BECE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BEE38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BEF6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BF0C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BF214(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BF368(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BF4BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, uint64_t a11)
{
  a9.i32[0] = *(_DWORD *)(a1 + 40);
  sub_1B6496614(*(float32x4_t **)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

void sub_1B64BF70C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v9 = *(_DWORD *)(a1 + 40);
  sub_1B6494BF4(*(float32x4_t **)(*(void *)(a1 + 32) + 8), v9, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(void *)(a1 + 32);
  v11.i32[0] = *(_DWORD *)(v10 + 72);
  sub_1B6495E54(*(float32x4_t **)(v10 + 8), v12, v13, v14, v15, v16, v17, v18, v11, v19, v35);
  if (v9 == 5)
  {
    sub_1B64BF794(*(void *)(*(void *)(a1 + 32) + 8), *(const char **)(*(void *)(a1 + 32) + 304), *(void **)(*(void *)(a1 + 32) + 336), v20, v21, v22, v23, v24);
    uint64_t v32 = *(__n128 **)(a1 + 32);
    uint64_t v33 = v32->n128_i64[1];
    __n128 v34 = v32[20];
    sub_1B6496F5C(v33, v25, v26, v27, v28, v29, v30, v31, v34);
  }
}

void sub_1B64BF794(uint64_t a1, const char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  switch((unint64_t)a2)
  {
    case 0uLL:
      memset(v31, 0, sizeof(v31));
      goto LABEL_7;
    case 1uLL:
      memset((char *)v31 + 1, 0, 47);
      char v9 = 1;
      goto LABEL_6;
    case 2uLL:
      memset((char *)v31 + 1, 0, 47);
      char v9 = 2;
      goto LABEL_6;
    case 3uLL:
      memset((char *)v31 + 1, 0, 47);
      char v9 = 3;
LABEL_6:
      LOBYTE(v31[0]) = v9;
LABEL_7:
      sub_1B6495014(a1, (unsigned __int8 *)v31, (uint64_t)a3, a4, a5, a6, a7, a8);
      break;
    case 4uLL:
      unint64_t v11 = objc_msgSend_count(a3, a2, (uint64_t)a3, a4);
      if (v11 >= 0xFF) {
        uint64_t v13 = 255;
      }
      else {
        uint64_t v13 = v11;
      }
      double v21 = MEMORY[0x1F4188790](v11, v12);
      uint64_t v23 = (char *)v31 - v22;
      if (v13)
      {
        for (uint64_t i = 0; i != v13; ++i)
        {
          uint64_t v25 = objc_msgSend_objectAtIndexedSubscript_(a3, v14, i, v16, v21);
          objc_msgSend_CGPointValue(v25, v26, v27, v28);
          v30.f64[1] = v29;
          double v21 = COERCE_DOUBLE(vcvt_f32_f64(v30));
          *(double *)&v23[8 * i] = v21;
        }
      }
      LOBYTE(v31[0]) = 4;
      memset((char *)v31 + 1, 0, 24);
      *((void *)&v31[1] + 1) = 0;
      LOBYTE(v31[2]) = v13;
      *(_DWORD *)((char *)&v31[2] + 1) = 0;
      DWORD1(v31[2]) = 0;
      *((void *)&v31[2] + 1) = v23;
      sub_1B6495014(a1, (unsigned __int8 *)v31, v15, v16, v17, v18, v19, v20);
      break;
    default:
      return;
  }
}

void sub_1B64BFA94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BFBF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64BFD2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64BFE84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64BFFDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C0134(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C0280(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C03D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C0530(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C065C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B64C0788(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C08C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C0A08(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C0B48(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

double sub_1B64C0C88(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&double result = sub_1B6497A44((float32x4_t *)*(void *)(a1[3].i64[0] + 8), a1[2], a2, a3, a4, a5, a6, a7, a8).u64[0];
  return result;
}

void sub_1B64C0DC8(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C0F60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B64BF794(*(void *)(*(void *)(a1 + 32) + 8), *(const char **)(*(void *)(a1 + 32) + 304), *(void **)(*(void *)(a1 + 32) + 336), a4, a5, a6, a7, a8);
  uint64_t v16 = *(__n128 **)(a1 + 32);
  uint64_t v17 = v16->n128_i64[1];
  __n128 v18 = v16[20];

  sub_1B6496F5C(v17, v9, v10, v11, v12, v13, v14, v15, v18);
}

void sub_1B64C10F0(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C1234(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C1378(uint64_t a1, float32x4_t a2, float32x4_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

void sub_1B64C14D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64C1620(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B6494BF4(*(float32x4_t **)(*(void *)(a1 + 32) + 8), 6, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = *(void **)(a1 + 40);
  uint64_t v16 = *(float32x4_t **)(*(void *)(a1 + 32) + 8);

  sub_1B64955D4(v16, v15, v9, v10, v11, v12, v13, v14);
}

void sub_1B64C2F58(uint64_t a1)
{
}

uint64_t sub_1B64C3084(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_addWorldReference_(a2, (const char *)a2, *(void *)(a1 + 32), a4);
}

uint64_t sub_1B64C3158(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_removeWorldReference_(a2, (const char *)a2, *(void *)(a1 + 32), a4);
}

CFStringRef sub_1B64C3240(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  return sub_1B65834BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64C3534(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 5) {
    return qword_1B6E51320[a1];
  }
  sub_1B63F2F54(16, @"Error: unknown shading model (2)", a3, a4, a5, a6, a7, a8, vars0);
  return 2;
}

void sub_1B64C4018(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_commonProfile(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 40);

  sub_1B6475B1C(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C4188(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = sub_1B64AF43C(v5, v6, v7, v8, v9, v10, v11, v12);
  float v20 = *(float *)(a1 + 40);

  sub_1B64757F0(v13, 17, v14, v15, v16, v17, v18, v19, v20);
}

void sub_1B64C430C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = sub_1B64AF43C(v5, v6, v7, v8, v9, v10, v11, v12);
  float v20 = *(float *)(a1 + 40);

  sub_1B64757F0(v13, 18, v14, v15, v16, v17, v18, v19, v20);
}

void sub_1B64C4490(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = sub_1B64AF43C(v5, v6, v7, v8, v9, v10, v11, v12);
  float v20 = *(float *)(a1 + 40);

  sub_1B64757F0(v13, 19, v14, v15, v16, v17, v18, v19, v20);
}

void sub_1B64C4614(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = sub_1B64AF43C(v5, v6, v7, v8, v9, v10, v11, v12);
  float v21 = *(float *)(a1 + 40);

  sub_1B6476C90(v13, v14, v15, v16, v17, v18, v19, v20, v21);
}

void sub_1B64C4780(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B64AF224(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C495C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B64AF694(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B64C4A44(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v19 = sub_1B64AF43C(v5, v6, v7, v8, v9, v10, v11, v12);
  unint64_t v20 = *(void *)(a1 + 40);
  if (v20 >= 4)
  {
    sub_1B63F2F54(16, @"Error: unknown shading model", v13, v14, v15, v16, v17, v18, v22);
    uint64_t v21 = 3;
  }
  else
  {
    uint64_t v21 = dword_1B6E51350[v20];
  }

  sub_1B6475724(v19, v21, v13, v14, v15, v16, v17, v18);
}

void sub_1B64C4BE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = sub_1B64AF43C(v5, v6, v7, v8, v9, v10, v11, v12);
  uint64_t v20 = *(unsigned __int8 *)(a1 + 40);

  sub_1B6476AD4(v13, v20, v14, v15, v16, v17, v18, v19);
}

void sub_1B64C4D54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = sub_1B64AF43C(v5, v6, v7, v8, v9, v10, v11, v12);
  uint64_t v20 = *(unsigned __int8 *)(a1 + 40);

  sub_1B64769F4(v13, v20, v14, v15, v16, v17, v18, v19);
}

void sub_1B64C4EC4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 40);

  sub_1B64AF7A8(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C5028(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 40);

  sub_1B64AF2BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C5180(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 40);

  sub_1B64AF8E0(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C53B0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 40);

  sub_1B64AF354(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C5524(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  int v12 = *(_DWORD *)(a1 + 40);

  sub_1B64AF4E4(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C5680(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_materialRef(*(void **)(a1 + 32), a2, a3, a4);
  unsigned int v12 = *(_DWORD *)(a1 + 40);

  sub_1B64AF180(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C5D18(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 168));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 176), v10, *(void *)(a1 + 48), v11);
    unsigned int v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 168);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B64C5F2C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64C5FF4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64C60D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64C61B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64C66F4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B64C6850(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C692C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64C72C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B6584BAC(*(void *)(a1 + 40), *(void **)(a1 + 32), *(__int16 **)(a1 + 48), a4, a5, a6, a7, a8);
  uint64_t v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
  }
}

void sub_1B64C7318(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(__int16 **)(a1 + 48);
  if (v9)
  {
    sub_1B6584BAC(*(void *)(a1 + 56), *(void **)(a1 + 32), v9, a4, a5, a6, a7, a8);
    uint64_t v10 = *(const void **)(a1 + 48);
    CFRelease(v10);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 56);
    CFStringRef v12 = *(void **)(a1 + 32);
    uint64_t v13 = *(__int16 **)(a1 + 40);
    if (v13)
    {
      sub_1B6584BAC(v11, v12, v13, a4, a5, a6, a7, a8);
    }
    else
    {
      sub_1B6584CD4(v11, v12, 0, a4, a5, a6, a7, a8);
    }
  }
}

uint64_t sub_1B64C7460(uint64_t a1, uint64_t a2)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result)
  {
    uint64_t v7 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v7, v5, a2, v6);
  }
  return result;
}

uint64_t sub_1B64C7644(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_compare_(a2, (const char *)a2, a3, a4);
}

uint64_t sub_1B64C7708(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = sub_1B64C775C(a3);
  if (result)
  {
    uint64_t v8 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v8, v6, a2, v7);
  }
  return result;
}

uint64_t sub_1B64C775C(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  uint64_t v6 = NSString;
  uint64_t v7 = objc_msgSend_objCType(a1, v3, v4, v5);
  uint64_t v10 = objc_msgSend_stringWithUTF8String_(v6, v8, v7, v9);

  return objc_msgSend_isEqualToString_(v10, v11, @"{CGRect={CGPoint=dd}{CGSize=dd}}", v12);
}

uint64_t sub_1B64C78F4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = sub_1B64C775C(a3);
  if (result)
  {
    uint64_t v8 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v8, v6, (uint64_t)a3, v7);
  }
  return result;
}

void *sub_1B64C7C3C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(const void **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend_coreEntityHandleRef(*(void **)(a1 + 40), a2, a3, a4);

  return sub_1B63F48A0(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64C8880()
{
  uint64_t v0 = objc_alloc_init(_VFXNullMaterial);
  qword_1E9DDAF90 = (uint64_t)v0;

  return objc_msgSend_setName_(v0, v1, @"_VFXNullMaterial", v2);
}

void sub_1B64C8AF4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id v9 = (id)objc_msgSend_nodeWithNodeRef_(VFXNode, a2, (uint64_t)a2, a4);
  objc_msgSend__setParent_(v9, v5, *(void *)(a1 + 32), v6);
  objc_msgSend_addObject_(*(void **)(*(void *)(a1 + 32) + 32), v7, (uint64_t)v9, v8);
}

void sub_1B64C8BFC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(*(void *)(a1 + 32) + 48))
  {
    id v9 = [VFXNode alloc];
    id inited = (id)objc_msgSend_initPresentationNodeWithNodeRef_(v9, v10, (uint64_t)a2, v11);
  }
  else
  {
    id inited = (id)objc_msgSend_nodeWithNodeRef_(VFXNode, a2, (uint64_t)a2, a4);
  }
  id v14 = inited;
  objc_msgSend__setParent_(inited, v7, *(void *)(a1 + 32), v8);
  objc_msgSend_addObject_(*(void **)(*(void *)(a1 + 32) + 32), v12, (uint64_t)v14, v13);
}

void sub_1B64C8ED0(uint64_t a1)
{
}

CFStringRef sub_1B64C8FA4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  return sub_1B65834BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64CA240(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_setValue_forKey_(*(void **)(a1 + 32), a2, a3, (uint64_t)a2);
}

uint64_t sub_1B64CA4D8(void *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_skinner(a1, (const char *)a2, a3, a4))
  {
    uint64_t v9 = objc_msgSend_skinner(a1, v6, v7, v8);
    uint64_t v13 = (const void *)objc_msgSend_skeleton(v9, v10, v11, v12);
    Value = CFDictionaryGetValue(a2, v13);
    if (Value)
    {
      uint64_t v22 = (uint64_t)Value;
      uint64_t v23 = objc_msgSend_skinner(a1, v15, v16, v17);
      objc_msgSend_setSkeleton_(v23, v24, v22, v25);
    }
    else
    {
      if (v13) {
        sub_1B63F2F54(16, @"Error: failed to find cloned skeleton in cloned tree", v16, v17, v18, v19, v20, v21, v55);
      }
      uint64_t v33 = objc_msgSend_array(MEMORY[0x1E4F1CA48], v15, v16, v17);
      long long v59 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      uint64_t v37 = objc_msgSend_skinner(a1, v34, v35, v36);
      uint64_t v41 = objc_msgSend_bones(v37, v38, v39, v40);
      uint64_t v43 = objc_msgSend_countByEnumeratingWithState_objects_count_(v41, v42, (uint64_t)&v59, (uint64_t)v64, 16);
      if (v43)
      {
        uint64_t v47 = v43;
        uint64_t v48 = *(void *)v60;
LABEL_16:
        uint64_t v49 = 0;
        while (1)
        {
          if (*(void *)v60 != v48) {
            objc_enumerationMutation(v41);
          }
          long long v50 = *(void **)(*((void *)&v59 + 1) + 8 * v49);
          if (!objc_msgSend_name(v50, v44, v45, v46)) {
            break;
          }
          int32x4_t v51 = CFDictionaryGetValue(a2, v50);
          if (!v51) {
            break;
          }
          objc_msgSend_addObject_(v33, v6, (uint64_t)v51, v8);
          if (v47 == ++v49)
          {
            uint64_t v47 = objc_msgSend_countByEnumeratingWithState_objects_count_(v41, v44, (uint64_t)&v59, (uint64_t)v64, 16);
            if (v47) {
              goto LABEL_16;
            }
            goto LABEL_23;
          }
        }
      }
      else
      {
LABEL_23:
        uint64_t v52 = objc_msgSend_skinner(a1, v44, v45, v46);
        objc_msgSend_setBones_(v52, v53, (uint64_t)v33, v54);
      }
    }
  }
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  uint64_t v26 = objc_msgSend_childNodes(a1, v6, v7, v8, 0);
  uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v26, v27, (uint64_t)&v55, (uint64_t)v63, 16);
  if (result)
  {
    uint64_t v29 = result;
    uint64_t v30 = *(void *)v56;
    do
    {
      uint64_t v31 = 0;
      do
      {
        if (*(void *)v56 != v30) {
          objc_enumerationMutation(v26);
        }
        sub_1B64CA4D8(*(void *)(*((void *)&v55 + 1) + 8 * v31++), a2);
      }
      while (v29 != v31);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v26, v32, (uint64_t)&v55, (uint64_t)v63, 16);
      uint64_t v29 = result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1B64CA700(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v5 = objc_msgSend_constraints(a2, (const char *)a2, a3, a4, 0);
  uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v6, (uint64_t)&v13, (uint64_t)v17, 16);
  if (result)
  {
    uint64_t v10 = result;
    uint64_t v11 = *(void *)v14;
    do
    {
      uint64_t v12 = 0;
      do
      {
        if (*(void *)v14 != v11) {
          objc_enumerationMutation(v5);
        }
        objc_msgSend_retargetWithRemapTable_(*(void **)(*((void *)&v13 + 1) + 8 * v12++), v8, *(void *)(a1 + 32), v9);
      }
      while (v10 != v12);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v8, (uint64_t)&v13, (uint64_t)v17, 16);
      uint64_t v10 = result;
    }
    while (result);
  }
  return result;
}

void sub_1B64CA7F0(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  objc_msgSend__copyAnimationsFrom_(a2, (const char *)a2, (uint64_t)a1, a4);
  long long v14 = objc_msgSend_childNodes(a1, v11, v12, v13);
  uint64_t v18 = objc_msgSend_count(v14, v15, v16, v17);
  uint64_t v22 = objc_msgSend_childNodes(a2, v19, v20, v21);
  if (objc_msgSend_count(v22, v23, v24, v25) == v18)
  {
    if (v18)
    {
      for (uint64_t i = 0; i != v18; ++i)
      {
        __n128 v34 = objc_msgSend_childNodes(a1, v26, v27, v28);
        uint64_t v37 = objc_msgSend_objectAtIndex_(v34, v35, i, v36);
        uint64_t v41 = objc_msgSend_childNodes(a2, v38, v39, v40);
        uint64_t v44 = objc_msgSend_objectAtIndex_(v41, v42, i, v43);
        sub_1B64CA7F0(v37, v44);
      }
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: error while transposing animations to cloned tree", v27, v28, v29, v30, v31, v32, a9);
  }
}

void sub_1B64CB3BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64CB3D4(uint64_t a1, char *a2, unsigned char *a3, uint64_t a4)
{
  if (objc_msgSend_isEqualToString_(*(void **)(a1 + 32), a2, @"model", a4)
    && objc_msgSend_model(a2, v7, v8, v9)
    || objc_msgSend_isEqualToString_(*(void **)(a1 + 32), v7, @"kCameraKey", v9)
    && objc_msgSend_camera(a2, v10, v11, v12)
    || (uint64_t result = objc_msgSend_isEqualToString_(*(void **)(a1 + 32), v10, @"kLightKey", v12),
        result)
    && (uint64_t result = objc_msgSend_light(a2, v14, v15, v16)) != 0)
  {
    uint64_t result = 1;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
      *a3 = 1;
    }
  }
  return result;
}

float32x4_t *sub_1B64CC360(float32x4_t *result, __n128 *a2, float32x4_t *a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, __n128 a7)
{
  if (a3)
  {
    float32x4_t v7 = vmulq_f32(a4, a4);
    float32x4_t v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1)));
    v8.f32[0] = sqrtf(v8.f32[0]);
    float32x4_t v9 = vmulq_f32(a5, a5);
    float32x4_t v10 = vmulq_f32(a6, a6);
    v8.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
    v8.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
    *a3 = v8;
  }
  if (a2) {
    *a2 = a7;
  }
  if (result)
  {
    if (a3)
    {
      float32x4_t v11 = *a3;
    }
    else
    {
      float32x4_t v12 = vmulq_f32(a4, a4);
      float32x4_t v11 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1)));
      float32x4_t v13 = vmulq_f32(a5, a5);
      v11.f32[0] = sqrtf(v11.f32[0]);
      float32x4_t v14 = vmulq_f32(a6, a6);
      v11.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
      v11.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
    }
    uint32x4_t v15 = (uint32x4_t)vceqzq_f32(v11);
    v15.i32[3] = v15.i32[2];
    if ((vmaxvq_u32(v15) & 0x80000000) != 0)
    {
      float32x4_t v47 = (float32x4_t)xmmword_1B6E4F370;
LABEL_30:
      *uint64_t result = v47;
      return result;
    }
    float32x4_t v16 = vdivq_f32(a4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0));
    float32x4_t v17 = vdivq_f32(a5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1));
    float32x4_t v18 = vdivq_f32(a6, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2));
    int32x4_t v19 = (int32x4_t)vmulq_f32(v16, v16);
    int32x4_t v20 = (int32x4_t)vmulq_f32(v17, v17);
    int32x4_t v21 = (int32x4_t)vmulq_f32(v18, v18);
    int32x4_t v22 = vzip2q_s32(v19, v21);
    float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip1q_s32(v19, v21), v20);
    float32x4_t v24 = (float32x4_t)vtrn2q_s32(v19, v20);
    v24.i32[2] = v21.i32[1];
    float32x4_t v25 = vaddq_f32((float32x4_t)vzip1q_s32(v22, vdupq_laneq_s32(v20, 2)), vaddq_f32(v23, v24));
    v24.i64[0] = 0x80000000800000;
    v24.i64[1] = 0x80000000800000;
    int32x4_t v26 = vcgeq_f32(v24, v25);
    v25.i32[3] = 0;
    float32x4_t v27 = vrsqrteq_f32(v25);
    float32x4_t v28 = vmulq_f32(v27, vrsqrtsq_f32(v25, vmulq_f32(v27, v27)));
    int32x4_t v29 = v26;
    v29.i32[3] = 0;
    float32x4_t v30 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v29), (int8x16_t)v25, (int8x16_t)vmulq_f32(v28, vrsqrtsq_f32(v25, vmulq_f32(v28, v28))));
    float32x4_t v31 = vmulq_n_f32(v16, v30.f32[0]);
    float32x4_t v32 = vmulq_lane_f32(v17, *(float32x2_t *)v30.f32, 1);
    float32x4_t v33 = vmulq_laneq_f32(v18, v30, 2);
    int8x16_t v34 = (int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33);
    int8x16_t v35 = (int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32);
    int32x4_t v36 = (int32x4_t)v31;
    if (v26.i32[0])
    {
      int32x4_t v37 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v34, (int8x16_t)v33, 0xCuLL), vnegq_f32(v32)), v33, (float32x4_t)vextq_s8(v35, (int8x16_t)v32, 0xCuLL));
      int32x4_t v36 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v37, v37), (int8x16_t)v37, 0xCuLL);
    }
    int8x16_t v38 = (int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31);
    float32x4_t v39 = v32;
    if (v26.i32[1])
    {
      int32x4_t v40 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v38, (int8x16_t)v31, 0xCuLL), vnegq_f32(v33)), v31, (float32x4_t)vextq_s8(v34, (int8x16_t)v33, 0xCuLL));
      float32x4_t v39 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v40, v40), (int8x16_t)v40, 0xCuLL);
    }
    if (v26.i32[2])
    {
      int32x4_t v26 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v35, (int8x16_t)v32, 0xCuLL), vnegq_f32(v31)), v32, (float32x4_t)vextq_s8(v38, (int8x16_t)v31, 0xCuLL));
      float32x4_t v33 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v26, v26), (int8x16_t)v26, 0xCuLL);
    }
    float v41 = (float)(*(float *)v36.i32 + v39.f32[1]) + v33.f32[2];
    if (v41 > 0.0)
    {
      float32x4_t v42 = (float32x4_t)vzip2q_s32((int32x4_t)v39, vuzp1q_s32((int32x4_t)v39, (int32x4_t)v33));
      v42.i32[2] = v36.i32[1];
      float v43 = sqrtf(v41 + 1.0);
      float32x4_t v44 = (float32x4_t)vtrn2q_s32((int32x4_t)v33, vzip2q_s32((int32x4_t)v33, v36));
      v44.i32[2] = v39.i32[0];
      float32x4_t v46 = vsubq_f32(v42, v44);
      v42.f32[3] = v43;
      v44.f32[3] = v43;
      float32x4_t v45 = vmulq_f32(v42, v44);
      v46.i32[3] = v45.i32[3];
LABEL_28:
      v45.f32[0] = 0.5 / v43;
      float32x4_t v57 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 0);
      goto LABEL_29;
    }
    if (*(float *)v36.i32 < v39.f32[1] || *(float *)v36.i32 < v33.f32[2])
    {
      if (v39.f32[1] <= v33.f32[2])
      {
        float v43 = sqrtf((float)((float)(v33.f32[2] + 1.0) - *(float *)v36.i32) - v39.f32[1]);
        *(float32x2_t *)v46.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v36, (int32x4_t)v39), *(float32x2_t *)v33.f32);
        float32x2_t v58 = (float32x2_t)__PAIR64__(v36.u32[1], LODWORD(v43));
        float32x2_t v59 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v39.f32, 0);
        *(float32x2_t *)v45.f32 = vsub_f32(*(float32x2_t *)v36.i8, v59);
        v59.f32[0] = v43;
        v59.i32[0] = vmul_f32(v58, v59).u32[0];
        v59.i32[1] = v45.i32[1];
        *(float32x2_t *)&v46.u32[2] = v59;
        goto LABEL_28;
      }
      float v51 = sqrtf((float)((float)(v39.f32[1] + 1.0) - *(float *)v36.i32) - v33.f32[2]);
      *(int32x2_t *)v26.i8 = vdup_laneq_s32((int32x4_t)v39, 2);
      int8x16_t v49 = (int8x16_t)v26;
      *(float *)v49.i32 = v51;
      v49.i32[0] = vmul_f32(*(float32x2_t *)v49.i8, (float32x2_t)__PAIR64__(v33.u32[1], LODWORD(v51))).u32[0];
      v49.i32[1] = vadd_f32(*(float32x2_t *)&v26, *(float32x2_t *)&v33).i32[1];
      int8x16_t v50 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.i8, 1), v39);
      int32x2_t v56 = (int32x2_t)vsubq_f32(v33, (float32x4_t)vdupq_laneq_s32(v36, 2)).u64[0];
      float32x4_t v57 = (float32x4_t)vextq_s8(vextq_s8(v50, v50, 4uLL), v49, 0xCuLL);
      v57.i32[3] = v56.i32[0];
    }
    else
    {
      float v51 = sqrtf((float)((float)(*(float *)v36.i32 + 1.0) - v39.f32[1]) - v33.f32[2]);
      float32x2_t v52 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v39.f32, 0);
      float32x2_t v53 = vadd_f32(*(float32x2_t *)v36.i8, v52);
      v52.f32[0] = v51;
      v57.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v36.u32[1], LODWORD(v51)), v52).u32[0];
      v57.i32[1] = v53.i32[1];
      float32x2_t v54 = (float32x2_t)vzip2q_s32(v36, (int32x4_t)v39).u64[0];
      LODWORD(v55) = vadd_f32(v54, *(float32x2_t *)v33.f32).u32[0];
      int32x2_t v56 = (int32x2_t)vsub_f32(v54, *(float32x2_t *)v33.f32);
      HIDWORD(v55) = v56.i32[1];
      v57.i64[1] = v55;
    }
    *(float *)v56.i32 = 0.5 / v51;
    float32x4_t v46 = (float32x4_t)vdupq_lane_s32(v56, 0);
LABEL_29:
    float32x4_t v47 = vmulq_f32(v46, v57);
    goto LABEL_30;
  }
  return result;
}

void sub_1B64CC93C(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CCBE8(float32x4_t *a1)
{
}

void sub_1B64CCD10(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CD020(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CD180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B64CD2BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A3854(*(uint64_t **)(*(void *)(a1 + 32) + 8), *(void *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void sub_1B64CD41C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CD5E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CD72C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CD97C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(float32x4_t **)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = (const __CFDictionary *)objc_msgSend_lightRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A39B4(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64CDAC8(uint64_t a1)
{
  return sub_1B64A3934(*(void *)(*(void *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40));
}

void sub_1B64CDBCC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(float32x4_t **)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = (uint64_t *)objc_msgSend_skinnerRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A16B0(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64CDCCC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFDictionaryRef v5 = (const void *)objc_msgSend_morphRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5) {
    float32x4_t v12 = (uint64_t *)sub_1B6588B2C(v5);
  }
  else {
    float32x4_t v12 = 0;
  }
  sub_1B64A155C(*(float32x4_t **)(*(void *)(a1 + 40) + 8), v12, v6, v7, v8, v9, v10, v11);
  if (v12)
  {
    CFRelease(v12);
  }
}

void sub_1B64CDE34(uint64_t a1)
{
}

void sub_1B64CDEFC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = (const __CFDictionary *)objc_msgSend_cameraRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A3BD8(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64CE064(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(float32x4_t **)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = objc_msgSend_geometryRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A0D6C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64CE1BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CE35C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = (const __CFDictionary *)objc_msgSend_coreEntityHandleRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A4B24(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64CE4EC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = (const __CFDictionary *)objc_msgSend_coreEntityHandleRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A4AE4(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64CE630(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = (const __CFDictionary *)objc_msgSend_coreEntityHandleRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A4B04(v4, v5, v6, v7, v8, v9, v10, v11);
}

id sub_1B64CF7D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id result = (id)objc_msgSend_setWithArray_(MEMORY[0x1E4F1CAD0], a2, (uint64_t)&unk_1F103BF90, a4);
  qword_1E9DDAFA0 = (uint64_t)result;
  return result;
}

void sub_1B64CFA74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64CFC98(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 208));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 216), v10, *(void *)(a1 + 48), v11);
    float32x4_t v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 208);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B64CFECC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64CFF94(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64D0070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64D0154(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64D0694(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  float32x4_t v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B64D07F0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B64D08CC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64D094C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B64D0AA4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id v9 = (id)objc_msgSend_nodeWithNodeRef_(VFXNode, a2, (uint64_t)a2, a4);
  objc_msgSend__setParent_(v9, v5, *(void *)(a1 + 32), v6);
  objc_msgSend_addObject_(*(void **)(*(void *)(a1 + 32) + 32), v7, (uint64_t)v9, v8);
}

void sub_1B64D0BB0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B64D0D78(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64D0D90(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = *(void *)(a1 + 56);
  if (!v13)
  {
    uint64_t v20 = *(void **)(a1 + 48);
    uint64_t v21 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v22 = objc_msgSend_nodeRef(v20, v6, v7, v8);
    uint64_t v28 = v21;
    uint64_t v29 = 0;
    goto LABEL_10;
  }
  uint64_t v14 = v5;
  if (v5)
  {
    uint64_t v18 = sub_1B64A1E7C(v5, (uint64_t)v6, v7, v8, v9, v10, v11, v12);
    uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
    if (v18 == v19)
    {
      uint64_t v22 = objc_msgSend_nodeRef(*(void **)(a1 + 48), v15, v16, v17);
      uint64_t v28 = v18;
      goto LABEL_9;
    }
    uint64_t v13 = *(void *)(a1 + 56);
  }
  else
  {
    uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  uint64_t v14 = sub_1B64A1A44(v19, (int)v13 - 1);
  float32x4_t v30 = *(void **)(a1 + 48);
  uint64_t v31 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v22 = objc_msgSend_nodeRef(v30, v32, v33, v34);
  uint64_t v28 = v31;
LABEL_9:
  uint64_t v29 = v14;
LABEL_10:

  return sub_1B64A1C68(v28, v22, v29, v23, v24, v25, v26, v27);
}

void sub_1B64D0F60(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B64D0F78(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v9)
  {
    sub_1B64A1D58(v9, v10, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    sub_1B63F2F54(16, @"Unreachable code: error in removeObjectFromChildNodesAtIndex -> try to remove inconsitent node", v11, v12, v13, v14, v15, v16, a9);
  }
}

void sub_1B64D1128(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B64D1140(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v14 = objc_msgSend_nodeRef(*(void **)(a1 + 40), v11, v12, v13);
  if (v14) {
    BOOL v21 = v10 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  if (v21)
  {
    sub_1B63F2F54(16, @"Unreachable code: error in replaceObjectInChildNodesAtIndex", v15, v16, v17, v18, v19, v20, a9);
  }
  else
  {
    uint64_t v22 = (void *)v14;
    uint64_t v23 = sub_1B64A1E44(*(void *)(*(void *)(a1 + 48) + 8), (uint64_t)v10);
    CFRetain(v22);
    sub_1B64A1D58(v10, v24, v25, v26, v27, v28, v29, v30);
    sub_1B64A1D58(v22, v31, v32, v33, v34, v35, v36, v37);
    sub_1B64A1B88(*(void *)(*(void *)(a1 + 48) + 8), v22, v23, v38, v39, v40, v41, v42);
    CFRelease(v22);
  }
}

void sub_1B64D130C(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B64D1B00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

__n128 sub_1B64D1B14(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v8 = a1[2];
  float32x4_t v9 = a1[3];
  v8.i32[3] = 1.0;
  v9.i32[3] = 1.0;
  v10.i64[0] = 0x3F0000003F000000;
  v10.i64[1] = 0x3F0000003F000000;
  v12[0] = vmulq_f32(vaddq_f32(v8, v9), v10);
  v12[1] = vmulq_f32(vsubq_f32(v9, v8), v10);
  sub_1B649FA7C(*(void *)(a1[4].i64[0] + 8), v12, 1, a4, a5, a6, a7, a8);
  return result;
}

void sub_1B64D20A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B63DB064(*(void *)(a1 + 32), 0, 0, 0, a5, a6, a7, a8);
  if (v9)
  {
    uint64_t v13 = (void *)v9;
    uint64_t v14 = (float32x4_t *)objc_msgSend_nodeRef(*(void **)(a1 + 40), v10, v11, v12);
    sub_1B64A0D6C(v14, v13, v15, v16, v17, v18, v19, v20);
    uint64_t v24 = objc_msgSend_model(*(void **)(a1 + 40), v21, v22, v23);
    objc_msgSend_setGeometryRef_(v24, v25, (uint64_t)v13, v26);
    CFRelease(v13);
  }
}

uint64_t sub_1B64D2394(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v5 = objc_msgSend_animationKeys(*(void **)(a1 + 32), a2, a3, a4, 0);
  uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v6, (uint64_t)&v12, (uint64_t)v16, 16);
  if (result)
  {
    uint64_t v9 = result;
    uint64_t v10 = *(void *)v13;
    do
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v13 != v10) {
          objc_enumerationMutation(v5);
        }
        objc_msgSend__pauseAnimation_forKey_pausedByNode_(*(void **)(a1 + 32), v8, *(unsigned __int8 *)(a1 + 40), *(void *)(*((void *)&v12 + 1) + 8 * v11++), 1);
      }
      while (v9 != v11);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v8, (uint64_t)&v12, (uint64_t)v16, 16);
      uint64_t v9 = result;
    }
    while (result);
  }
  return result;
}

void sub_1B64D2D94(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void **)(a1 + 32);
  if (v9)
  {
    uint64_t v10 = (void *)MEMORY[0x1E4F1CA48];
    uint64_t v11 = objc_msgSend_count(v9, a2, a3, a4);
    long long v14 = objc_msgSend_arrayWithCapacity_(v10, v12, v11, v13);
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v15 = *(void **)(a1 + 32);
    uint64_t v17 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v16, (uint64_t)&v32, (uint64_t)v36, 16);
    if (v17)
    {
      uint64_t v25 = v17;
      uint64_t v26 = *(void *)v33;
      do
      {
        for (uint64_t i = 0; i != v25; ++i)
        {
          if (*(void *)v33 != v26) {
            objc_enumerationMutation(v15);
          }
          uint64_t v28 = objc_msgSend_constraintRef(*(void **)(*((void *)&v32 + 1) + 8 * i), v18, v19, v20);
          objc_msgSend_addObject_(v14, v29, v28, v30);
        }
        uint64_t v25 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v18, (uint64_t)&v32, (uint64_t)v36, 16);
      }
      while (v25);
    }
    sub_1B64A4600(*(void *)(*(void *)(a1 + 40) + 8), (const __CFDictionary *)v14, v19, v20, v21, v22, v23, v24);
  }
  else
  {
    uint64_t v31 = *(void *)(*(void *)(a1 + 40) + 8);
    sub_1B64A4600(v31, 0, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B64D309C(uint64_t a1)
{
  return sub_1B64A2614(*(void *)(*(void *)(a1 + 96) + 8), a1 + 32);
}

void sub_1B64D31B8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  CFDictionaryRef v5 = (const __CFDictionary *)objc_msgSend___CFObject(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64A48D8(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64D3324(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5) {
    sub_1B64A429C(v5, *(const void **)(a1 + 32), 1, v8, v9, v10, v11, v12);
  }
  uint64_t v13 = objc_msgSend_nodeRef(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setNodeRef_(*(void **)(a1 + 32), v14, v13, v15);
  uint64_t v22 = *(void **)(a1 + 32);

  return sub_1B64A3F1C(v13, v22, v16, v17, v18, v19, v20, v21);
}

void sub_1B64D341C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B64A40F0(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64D34E4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B64A429C(v5, *(const void **)(a1 + 40), 1, v6, v7, v8, v9, v10);
  uint64_t v13 = *(void *)(a1 + 40);

  return MEMORY[0x1F4181798](v13, sel_recycle, v11, v12);
}

uint64_t sub_1B64D3630(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v11 = *(void **)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 48);

  return sub_1B64A3FD8(v5, v11, v12, v6, v7, v8, v9, v10);
}

void sub_1B64D3708(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  CFIndex v11 = *(void *)(a1 + 40);

  sub_1B64A41A0(v5, v11, 1, v6, v7, v8, v9, v10);
}

void sub_1B64D3810(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  CFIndex v11 = *(void **)(a1 + 40);
  CFIndex v12 = *(void *)(a1 + 48);

  sub_1B64A4388(v5, v11, v12, v6, v7, v8, v9, v10);
}

uint64_t sub_1B64D4A54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  int v6 = *(unsigned __int8 *)(a1 + 40);

  return sub_1B64A4E18(v5, v6);
}

void sub_1B64D5124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64D5140(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A0A70(*(void *)(*(void *)(a1 + 32) + 8), (long long *)(*(void *)(*(void *)(a1 + 40) + 8) + 32), a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B64D5814(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A2510(*(void *)(a1[3].n128_u64[0] + 8), a2, a3, a4, a5, a6, a7, a8, a1[2]);
}

uint64_t sub_1B64D5C20(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64A2554(*(void *)(a1[3].n128_u64[0] + 8), a2, a3, a4, a5, a6, a7, a8, a1[2]);
}

uint64_t sub_1B64D7838(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 5) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad type", a3, a4, a5, a6, a7, a8, (uint64_t)"mode <= CFXWrapModeMirror");
  }
  return qword_1B6E513E0[a1];
}

uint64_t sub_1B64D7890(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad type", a3, a4, a5, a6, a7, a8, (uint64_t)"mode <= kCFXFilterModeLinear");
  }
  return qword_1B6E51408[a1];
}

uint64_t sub_1B64D78E8(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad type", a3, a4, a5, a6, a7, a8, (uint64_t)"mode <= kCFXFilterModeLinear");
  }
  return qword_1B6E51420[a1];
}

uint64_t sub_1B64D7940(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 8) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad image type", a3, a4, a5, a6, a7, a8, (uint64_t)"type < kCFXImageCount");
  }
  return qword_1B6E51438[a1];
}

uint64_t sub_1B64D7998(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad cull mode", a3, a4, a5, a6, a7, a8, (uint64_t)"cull <= kCFXCullNone");
  }
  return qword_1B6E51478[a1];
}

uint64_t sub_1B64D79F0(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad fill mode", a3, a4, a5, a6, a7, a8, (uint64_t)"fillMode == kCFXFillModeLines || fillMode == kCFXFillModeFill");
  }
  return qword_1B6E51490[a1];
}

uint64_t sub_1B64D7A48(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 0xF) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend mode", a3, a4, a5, a6, a7, a8, (uint64_t)"blend < kCFXBlendFactorCount");
  }
  return qword_1B6E514A0[a1];
}

uint64_t sub_1B64D7AA0(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 5) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend operation", a3, a4, a5, a6, a7, a8, (uint64_t)"blendOp < kCFXBlendOpCount");
  }
  return qword_1B6E51518[a1];
}

uint64_t sub_1B64D7AF8(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 8) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad comparison func", a3, a4, a5, a6, a7, a8, (uint64_t)"func < kCFXComparisonFuncCount");
  }
  return qword_1B6E51540[a1];
}

uint64_t sub_1B64D7B50(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 8) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad comparison func", a3, a4, a5, a6, a7, a8, (uint64_t)"func < kCFXComparisonFuncCount");
  }
  return qword_1B6E51580[a1];
}

uint64_t sub_1B64D7BA8(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 8) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad stencil op", a3, a4, a5, a6, a7, a8, (uint64_t)"op < kCFXStencilOpCount");
  }
  return qword_1B6E515C0[a1];
}

unint64_t sub_1B64D7C00(uint64_t a1)
{
  return ((unint64_t)(a1 - 160) > 0x3A) | (0x20E008302AB00uLL >> (a1 + 96)) & 1;
}

uint64_t sub_1B64D7C2C(char a1)
{
  uint64_t v1 = 81;
  if ((a1 & 8) == 0) {
    uint64_t v1 = 551;
  }
  if ((a1 & 0x10) == 0) {
    uint64_t v1 = 555;
  }
  if (a1) {
    return v1;
  }
  else {
    return 81;
  }
}

uint64_t sub_1B64D7C58(unsigned int a1)
{
  return (a1 < 6) & (0xFu >> a1);
}

uint64_t sub_1B64D7C70(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 0:
      uint64_t result = 3;
      break;
    case 1:
      uint64_t result = 4;
      break;
    case 2:
      uint64_t result = 1;
      break;
    case 4:
      sub_1B63F2F54(17, @"Assertion '%s' failed. Polygon Array not supported in Metal", a3, a4, a5, a6, a7, a8, (uint64_t)"0");
      goto LABEL_7;
    case 5:
      sub_1B63F2F54(17, @"Assertion '%s' failed. Triangle Fan not supported in Metal", a3, a4, a5, a6, a7, a8, (uint64_t)"0");
LABEL_7:
      uint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1B64D7D28(uint64_t a1, uint64_t a2, CGContextRef context, char a4)
{
  __int16 BitmapInfo = CGBitmapContextGetBitmapInfo(context);
  CGColorSpaceRef ColorSpace = CGBitmapContextGetColorSpace(context);
  int v16 = BitmapInfo & 0x7000;
  if ((BitmapInfo & 0x1B) == 2)
  {
    int v17 = 0;
    BOOL v18 = v16 != 4096 && v16 != 0x2000;
LABEL_14:
    if ((BitmapInfo & 0x100) != 0) {
      goto LABEL_30;
    }
    goto LABEL_15;
  }
  if ((BitmapInfo & 0x1B) != 1)
  {
    int v17 = 0;
    goto LABEL_29;
  }
  int v17 = 1;
  if ((BitmapInfo & 0x7000) == 0 || v16 == 12288)
  {
LABEL_29:
    BOOL v18 = 1;
    if ((BitmapInfo & 0x100) != 0) {
      goto LABEL_30;
    }
    goto LABEL_15;
  }
  BOOL v18 = 1;
  if (v16 == 0x4000) {
    goto LABEL_14;
  }
  int v17 = 0;
  if ((BitmapInfo & 0x100) != 0)
  {
LABEL_30:
    if (a2 == 32)
    {
      switch(a1)
      {
        case 1:
          return 55;
        case 4:
          return 125;
        case 2:
          return 105;
      }
    }
    else if (a2 == 16)
    {
      switch(a1)
      {
        case 1:
          return 25;
        case 4:
          return 115;
        case 2:
          return 65;
      }
    }
    goto LABEL_66;
  }
LABEL_15:
  if (ColorSpace == (CGColorSpaceRef)sub_1B63C9410()
    || ColorSpace == (CGColorSpaceRef)sub_1B63C93CC()
    || (uint64_t v20 = sub_1B63C9B90(), (a4 & 1) != 0)
    || ColorSpace == (CGColorSpaceRef)v20)
  {
    if (a2 == 16)
    {
      if (a1 == 1) {
        return 20;
      }
      if (a1 == 4 && (v17 & 1) != 0) {
        return 110;
      }
    }
    else if (a2 == 8)
    {
      if (a1 == 1) {
        return 10;
      }
      if (a1 == 2) {
        return 30;
      }
      if (a1 == 4 && v17 == 1) {
        return 70;
      }
      char v22 = a1 != 4 || v18;
      if ((v22 & 1) == 0) {
        return 80;
      }
    }
LABEL_66:
    sub_1B63F2F54(16, @"Error: Failed to create Metal pixel format for %@ [%d components, %d bits per component, bitmap info: %u (%@|%@), float components: %@, color space: %@]", v9, v10, v11, v12, v13, v14, (uint64_t)context);
    return 70;
  }
  if (a2 != 8) {
    goto LABEL_66;
  }
  if (a1 == 1) {
    return 11;
  }
  if (a1 == 2) {
    return 31;
  }
  if (a1 == 4 && v17 == 1) {
    return 71;
  }
  if (a1 != 4 || v18) {
    goto LABEL_66;
  }
  return 81;
}

uint64_t sub_1B64D7FD8(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 0x36) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad type", a3, a4, a5, a6, a7, a8, (uint64_t)"format < sizeof(__VFXMTLVertexFormatToCFXBaseTypeArray) / sizeof(__VFXMTLVertexFormatToCFXBaseTypeArray[0])");
  }
  return word_1B6E51600[a1];
}

uint64_t sub_1B64D8030(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 45) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad type", a3, a4, a5, a6, a7, a8, (uint64_t)"type < kCFXBaseTypeCount");
  }
  return qword_1B6E51670[a1];
}

uint64_t sub_1B64D8088(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 45) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad type", a3, a4, a5, a6, a7, a8, (uint64_t)"type < kCFXBaseTypeCount");
  }
  return qword_1B6E517D8[a1];
}

uint64_t sub_1B64D80E0(uint64_t a1)
{
  return dword_1B6E51940[a1];
}

uint64_t sub_1B64D80F0(uint64_t a1)
{
  return dword_1B6E51A18[a1];
}

uint64_t sub_1B64D8100()
{
  return 0;
}

__CFString *sub_1B64D8178(uint64_t a1)
{
  if (a1 > 102)
  {
    if (a1 > 251)
    {
      switch(a1)
      {
        case 552:
          uint64_t result = @"BGRA10_XR";
          break;
        case 553:
          uint64_t result = @"BGRA10_XR_sRGB";
          break;
        case 554:
          uint64_t result = @"BGR10_XR";
          break;
        case 555:
          uint64_t result = @"BGR10_XR_sRGB";
          break;
        default:
          if (a1 == 252)
          {
            uint64_t result = @"Depth32Float";
          }
          else if (a1 == 253)
          {
            uint64_t result = @"Stencil8";
          }
          else
          {
LABEL_52:
            uint64_t v4 = NSString;
            uint64_t Name = MTLPixelFormatGetName();
            uint64_t v7 = objc_msgSend_stringWithCString_encoding_(v4, v6, Name, 1);
            uint64_t result = (__CFString *)objc_msgSend_stringByReplacingOccurrencesOfString_withString_(v7, v8, @"MTLPixelFormat", (uint64_t)&stru_1F0FCDBB0);
          }
          break;
      }
    }
    else
    {
      switch(a1)
      {
        case 'g':
          uint64_t result = @"RG32Uint";
          break;
        case 'h':
          uint64_t result = @"RG32Sint";
          break;
        case 'i':
          uint64_t result = @"RG32Float";
          break;
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'o':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
          goto LABEL_52;
        case 'n':
          uint64_t result = @"RGBA16Unorm";
          break;
        case 'p':
          uint64_t result = @"RGBA16Snorm";
          break;
        case 'q':
          uint64_t result = @"RGBA16Uint";
          break;
        case 'r':
          uint64_t result = @"RGBA16Sint";
          break;
        case 's':
          uint64_t result = @"RGBA16Float";
          break;
        case '{':
          uint64_t result = @"RGBA32Uint";
          break;
        case '|':
          uint64_t result = @"RGBA32Sint";
          break;
        case '}':
          uint64_t result = @"RGBA32Float";
          break;
        default:
          if (a1 != 250) {
            goto LABEL_52;
          }
          uint64_t result = @"Depth16Unorm";
          break;
      }
    }
  }
  else
  {
    switch(a1)
    {
      case '5':
        uint64_t result = @"R32Uint";
        break;
      case '6':
        uint64_t result = @"R32Sint";
        break;
      case '7':
        uint64_t result = @"R32Float";
        break;
      case '8':
      case '9':
      case ':':
      case ';':
      case '=':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case '\\':
      case ']':
        goto LABEL_52;
      case '<':
        uint64_t result = @"RG16Unorm";
        break;
      case '>':
        uint64_t result = @"RG16Snorm";
        break;
      case '?':
        uint64_t result = @"RG16Uint";
        break;
      case '@':
        uint64_t result = @"RG16Sint";
        break;
      case 'A':
        uint64_t result = @"RG16Float";
        break;
      case 'F':
        uint64_t result = @"RGBA8Unorm";
        break;
      case 'G':
        uint64_t result = @"RGBA8Unorm_sRGB";
        break;
      case 'H':
        uint64_t result = @"RGBA8Snorm";
        break;
      case 'I':
        uint64_t result = @"RGBA8Uint";
        break;
      case 'J':
        uint64_t result = @"RGBA8Sint";
        break;
      case 'P':
        uint64_t result = @"BGRA8Unorm";
        break;
      case 'Q':
        uint64_t result = @"BGRA8Unorm_sRGB";
        break;
      case 'Z':
        uint64_t result = @"RGB10A2Unorm";
        break;
      case '[':
        uint64_t result = @"RGB10A2Uint";
        break;
      case '^':
        uint64_t result = @"BGR10A2Unorm";
        break;
      default:
        uint64_t result = @"Invalid";
        switch(a1)
        {
          case 0:
            return result;
          case 1:
            uint64_t result = @"A8Unorm";
            break;
          case 10:
            uint64_t result = @"R8Unorm";
            break;
          case 11:
            uint64_t result = @"R8Unorm_sRGB";
            break;
          case 12:
            uint64_t result = @"R8Snorm";
            break;
          case 13:
            uint64_t result = @"R8Uint";
            break;
          case 14:
            uint64_t result = @"R8Sint";
            break;
          case 20:
            uint64_t result = @"R16Unorm";
            break;
          case 22:
            uint64_t result = @"R16Snorm";
            break;
          case 23:
            uint64_t result = @"R16Uint";
            break;
          case 24:
            uint64_t result = @"R16Sint";
            break;
          case 25:
            uint64_t result = @"R16Float";
            break;
          case 30:
            uint64_t result = @"RG8Unorm";
            break;
          case 31:
            uint64_t result = @"RG8Unorm_sRGB";
            break;
          case 32:
            uint64_t result = @"RG8Snorm";
            break;
          case 33:
            uint64_t result = @"RG8Uint";
            break;
          case 34:
            uint64_t result = @"RG8Sint";
            break;
          default:
            goto LABEL_52;
        }
        break;
    }
  }
  return result;
}

uint64_t sub_1B64D86C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 1:
      return 0;
    case 3:
      uint64_t v9 = @"Unreachable code: Kernel functions have no corresponding program stage";
      break;
    case 2:
      return 1;
    default:
      uint64_t v9 = @"Error: VFXMTLFunctionTypeToProgramStage - type not supported";
      break;
  }
  sub_1B63F2F54(16, (uint64_t)v9, a3, a4, a5, a6, a7, a8, vars0);
  return 2;
}

__CFString *sub_1B64D8724(unint64_t a1)
{
  if (a1 > 9) {
    return @"Unkown";
  }
  else {
    return off_1E6143108[a1];
  }
}

uint64_t sub_1B64D8748(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = objc_msgSend_textureType(a1, a2, a3, a4);
  if (v5 < 8 && ((0xA5u >> v5) & 1) != 0) {
    return dword_1B6E51AFC[v5];
  }
  uint64_t v9 = objc_msgSend_textureType(a1, v6, v7, v8);
  sub_1B63F2F54(0, @"Warning: unsupported texture type %d", v10, v11, v12, v13, v14, v15, v9);
  return 0;
}

uint64_t sub_1B64D87B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = sub_1B65625B4(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v19 = (__int16 *)sub_1B6562568(a1, v12, v13, v14, v15, v16, v17, v18);
  uint64_t v23 = v19;
  switch(a2)
  {
    case 3:
      uint64_t result = 0;
      switch((__int16)v11)
      {
        case 1:
          v20.i32[0] = *(_DWORD *)v23;
          goto LABEL_135;
        case 2:
          v20.f32[0] = (float)*(int *)v23;
          goto LABEL_135;
        case 3:
          v20.i32[0] = 0;
          if (*(unsigned char *)v23) {
            v20.f32[0] = 1.0;
          }
          goto LABEL_135;
        case 6:
          v20.f32[0] = *(double *)v23;
          goto LABEL_135;
        case 13:
          v20.f32[0] = (float)*v23;
          goto LABEL_135;
        case 14:
          v20.f32[0] = sub_1B64D90E0((unsigned __int16)*v23);
          goto LABEL_135;
        case 16:
          v20.i16[0] = *v23;
          v20.f32[0] = (float)v20.u32[0];
LABEL_135:
          *(_DWORD *)a3 = v20.i32[0];
          return 1;
        default:
          return result;
      }
    case 4:
      uint64_t result = 0;
      if ((unsigned __int16)v11 > 0x1Bu)
      {
        switch((unsigned __int16)v11)
        {
          case 0x1Cu:
            v20.i16[0] = *v23;
            v20.f32[0] = (float)v20.u32[0];
            LOWORD(v21) = v23[1];
            float v51 = (float)v21;
            break;
          case 0x1Fu:
            v20.f32[0] = (float)*v23;
            float v51 = (float)v23[1];
            break;
          case 0x2Au:
            float v68 = sub_1B64D90E0((unsigned __int16)*v23);
            *(void *)a3 = __PAIR64__(COERCE_UNSIGNED_INT(sub_1B64D90E0((unsigned __int16)v23[1])), LODWORD(v68));
            return 1;
          default:
            return result;
        }
        v20.f32[1] = v51;
        goto LABEL_117;
      }
      if ((unsigned __int16)v11 == 7) {
        goto LABEL_80;
      }
      if ((unsigned __int16)v11 == 17)
      {
        float32x2_t v43 = vcvt_f32_s32(*(int32x2_t *)v23);
        goto LABEL_81;
      }
      return result;
    case 5:
      uint64_t result = 0;
      if ((unsigned __int16)v11 <= 0x1Cu)
      {
        if ((unsigned __int16)v11 == 8 || (unsigned __int16)v11 == 9)
        {
LABEL_85:
          float32x4_t v20 = *(float32x4_t *)v23;
        }
        else
        {
          if ((unsigned __int16)v11 != 18) {
            return result;
          }
          *(float32x2_t *)v20.f32 = vcvt_f32_s32(*(int32x2_t *)v23);
          v20.f32[2] = (float)*((int *)v23 + 2);
        }
LABEL_86:
        *(float32x4_t *)a3 = v20;
        return 1;
      }
      switch((unsigned __int16)v11)
      {
        case 0x1Du:
          v20.i16[0] = *v23;
          v20.f32[0] = (float)v20.u32[0];
          LOWORD(v21) = v23[1];
          float v59 = (float)v21;
          LOWORD(v22) = v23[2];
          float v60 = (float)v22;
          break;
        case 0x20u:
          v20.f32[0] = (float)*v23;
          float v59 = (float)v23[1];
          float v60 = (float)v23[2];
          break;
        case 0x2Bu:
          *(float *)&uint64_t v41 = sub_1B64D90E0((unsigned __int16)*v23);
          *(void *)&long long v67 = v41;
          float v66 = sub_1B64D90E0((unsigned __int16)v23[1]);
          float v42 = sub_1B64D90E0((unsigned __int16)v23[2]);
          long long v35 = v67;
          *((float *)&v35 + 1) = v66;
          *((float *)&v35 + 2) = v42;
LABEL_72:
          *(_OWORD *)a3 = v35;
          return 1;
        default:
          return result;
      }
      v20.f32[1] = v59;
      v20.f32[2] = v60;
      goto LABEL_86;
    case 6:
      uint64_t result = 0;
      if ((unsigned __int16)v11 > 0x1Du)
      {
        if ((unsigned __int16)v11 == 30)
        {
          float32x4_t v20 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v23));
          goto LABEL_86;
        }
        if ((unsigned __int16)v11 != 33)
        {
          if ((unsigned __int16)v11 != 44) {
            return result;
          }
          float v69 = sub_1B64D90E0((unsigned __int16)*v23);
          float v65 = sub_1B64D90E0((unsigned __int16)v23[1]);
          float v64 = sub_1B64D90E0((unsigned __int16)v23[2]);
          float v34 = sub_1B64D90E0((unsigned __int16)v23[3]);
          *(void *)&long long v35 = __PAIR64__(LODWORD(v65), LODWORD(v69));
          *((void *)&v35 + 1) = __PAIR64__(LODWORD(v34), LODWORD(v64));
          goto LABEL_72;
        }
        int32x4_t v44 = vmovl_s16(*(int16x4_t *)v23);
LABEL_101:
        float32x4_t v20 = vcvtq_f32_s32(v44);
        goto LABEL_86;
      }
      if ((unsigned __int16)v11 == 9) {
        goto LABEL_85;
      }
      if ((unsigned __int16)v11 == 19)
      {
        int32x4_t v44 = *(int32x4_t *)v23;
        goto LABEL_101;
      }
      return result;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      goto LABEL_23;
    case 15:
      if (v11 != 10) {
        return 0;
      }
      float32x4_t v20 = *(float32x4_t *)v19;
      long long v36 = *((_OWORD *)v19 + 1);
      long long v37 = *((_OWORD *)v19 + 3);
      *(_OWORD *)(a3 + 32) = *((_OWORD *)v19 + 2);
      *(_OWORD *)(a3 + 48) = v37;
      *(_OWORD *)(a3 + 16) = v36;
      goto LABEL_86;
    case 16:
      uint64_t result = 0;
      switch((__int16)v11)
      {
        case 1:
          v20.i32[0] = *(_DWORD *)v23;
          goto LABEL_133;
        case 2:
          v20.f32[0] = (float)*(int *)v23;
          goto LABEL_133;
        case 3:
          v20.i32[0] = 0;
          if (*(unsigned char *)v23) {
            v20.f32[0] = 1.0;
          }
          goto LABEL_133;
        case 6:
          v20.f32[0] = *(double *)v23;
          goto LABEL_133;
        case 13:
          v20.f32[0] = (float)*v23;
          goto LABEL_133;
        case 14:
          *(_WORD *)a3 = *v23;
          return 1;
        case 16:
          v20.i16[0] = *v23;
          v20.f32[0] = (float)v20.u32[0];
LABEL_133:
          *(_WORD *)a3 = sub_1B64D9130(v20.f32[0]);
          return 1;
        default:
          return result;
      }
    case 17:
      uint64_t result = 0;
      if ((unsigned __int16)v11 > 0x1Bu)
      {
        switch((unsigned __int16)v11)
        {
          case 0x1Cu:
            v20.i16[0] = *v23;
            __int16 v55 = sub_1B64D9130((float)v20.u32[0]);
            LOWORD(v56) = v23[1];
            float v57 = (float)v56;
            break;
          case 0x1Fu:
            __int16 v55 = sub_1B64D9130((float)*v23);
            float v57 = (float)v23[1];
            break;
          case 0x2Au:
LABEL_55:
            int v25 = *(_DWORD *)v23;
LABEL_64:
            *(_DWORD *)a3 = v25;
            return 1;
          default:
            return result;
        }
        *(_WORD *)(a3 + 2) = sub_1B64D9130(v57);
        *(_WORD *)a3 = v55;
        return 1;
      }
      if ((unsigned __int16)v11 == 7)
      {
        LODWORD(v71) = HIDWORD(*(void *)v23);
        __int16 v49 = sub_1B64D9130(COERCE_FLOAT(*(void *)v23));
        float v50 = v71;
      }
      else
      {
        if ((unsigned __int16)v11 != 17) {
          return result;
        }
        int v70 = HIDWORD(*(void *)v23);
        __int16 v49 = sub_1B64D9130((float)(int)*(void *)v23);
        float v50 = (float)v70;
      }
      *(_WORD *)(a3 + 2) = sub_1B64D9130(v50);
      *(_WORD *)a3 = v49;
      return 1;
    case 18:
      uint64_t result = 0;
      if ((unsigned __int16)v11 <= 0x1Cu)
      {
        if ((unsigned __int16)v11 == 8 || (unsigned __int16)v11 == 9)
        {
          __int16 v38 = sub_1B64D9130(*(float *)v23);
          __int16 v39 = sub_1B64D9130(*((float *)v23 + 1));
          float v40 = *((float *)v23 + 2);
        }
        else
        {
          if ((unsigned __int16)v11 != 18) {
            return result;
          }
          __int16 v38 = sub_1B64D9130((float)*(int *)v23);
          __int16 v39 = sub_1B64D9130((float)*((int *)v23 + 1));
          float v40 = (float)*((int *)v23 + 2);
        }
        goto LABEL_116;
      }
      switch((unsigned __int16)v11)
      {
        case 0x1Du:
          v20.i16[0] = *v23;
          __int16 v38 = sub_1B64D9130((float)v20.u32[0]);
          LOWORD(v61) = v23[1];
          __int16 v39 = sub_1B64D9130((float)v61);
          LOWORD(v62) = v23[2];
          float v40 = (float)v62;
          break;
        case 0x20u:
          __int16 v38 = sub_1B64D9130((float)*v23);
          __int16 v39 = sub_1B64D9130((float)v23[1]);
          float v40 = (float)v23[2];
          break;
        case 0x2Bu:
          goto LABEL_80;
        default:
          return result;
      }
LABEL_116:
      __int16 v63 = sub_1B64D9130(v40);
      v20.i16[0] = v38;
      v20.i16[1] = v39;
      v20.i16[2] = v63;
      goto LABEL_117;
    case 19:
      uint64_t result = 0;
      if ((unsigned __int16)v11 <= 0x1Du)
      {
        if ((unsigned __int16)v11 == 9)
        {
          __int16 v45 = sub_1B64D9130(*(float *)v23);
          __int16 v46 = sub_1B64D9130(*((float *)v23 + 1));
          __int16 v47 = sub_1B64D9130(*((float *)v23 + 2));
          float v48 = *((float *)v23 + 3);
        }
        else
        {
          if ((unsigned __int16)v11 != 19) {
            return result;
          }
          __int16 v45 = sub_1B64D9130((float)*(int *)v23);
          __int16 v46 = sub_1B64D9130((float)*((int *)v23 + 1));
          __int16 v47 = sub_1B64D9130((float)*((int *)v23 + 2));
          float v48 = (float)*((int *)v23 + 3);
        }
        goto LABEL_108;
      }
      switch((unsigned __int16)v11)
      {
        case 0x1Eu:
          v20.i16[0] = *v23;
          __int16 v45 = sub_1B64D9130((float)v20.u32[0]);
          LOWORD(v52) = v23[1];
          __int16 v46 = sub_1B64D9130((float)v52);
          LOWORD(v53) = v23[2];
          __int16 v47 = sub_1B64D9130((float)v53);
          LOWORD(v54) = v23[3];
          float v48 = (float)v54;
LABEL_108:
          __int16 v58 = sub_1B64D9130(v48);
          v20.i16[0] = v45;
          v20.i16[1] = v46;
          v20.i16[2] = v47;
          v20.i16[3] = v58;
          goto LABEL_117;
        case 0x21u:
          __int16 v45 = sub_1B64D9130((float)*v23);
          __int16 v46 = sub_1B64D9130((float)v23[1]);
          __int16 v47 = sub_1B64D9130((float)v23[2]);
          float v48 = (float)v23[3];
          goto LABEL_108;
        case 0x2Cu:
          goto LABEL_80;
      }
      return result;
    case 29:
    case 33:
      uint64_t result = 0;
      if ((unsigned __int16)v11 > 0xCu)
      {
        if ((unsigned __int16)v11 == 13 || (unsigned __int16)v11 == 16)
        {
          int v25 = *v23;
          goto LABEL_64;
        }
      }
      else
      {
        if ((unsigned __int16)v11 == 2) {
          goto LABEL_55;
        }
        if ((unsigned __int16)v11 == 3)
        {
          int v25 = *(unsigned __int8 *)v23;
          goto LABEL_64;
        }
      }
      return result;
    case 30:
    case 34:
      if (v11 == 31 || (unsigned __int16)v11 == 28)
      {
        v20.i32[0] = *v19;
        v20.i32[1] = v19[1];
LABEL_117:
        *(void *)a3 = v20.i64[0];
      }
      else
      {
        if ((unsigned __int16)v11 != 17) {
          return 0;
        }
LABEL_80:
        float32x2_t v43 = *(float32x2_t *)v23;
LABEL_81:
        *(float32x2_t *)a3 = v43;
      }
      return 1;
    case 31:
    case 35:
      if (v11 == 32 || (unsigned __int16)v11 == 29)
      {
        float32x4_t v20 = (float32x4_t)vmovl_s16(*(int16x4_t *)v19);
        v20.i32[2] = 0;
        goto LABEL_86;
      }
      if ((unsigned __int16)v11 != 18) {
        return 0;
      }
      goto LABEL_85;
    case 32:
    case 36:
      if (v11 == 33 || (unsigned __int16)v11 == 30)
      {
        float32x4_t v20 = (float32x4_t)vmovl_s16(*(int16x4_t *)v19);
        goto LABEL_86;
      }
      if ((unsigned __int16)v11 == 19) {
        goto LABEL_85;
      }
      return 0;
    default:
      if (a2 == 53)
      {
        if (v11 == 16 || (unsigned __int16)v11 == 13)
        {
          char v26 = *v19 != 0;
          goto LABEL_94;
        }
        if ((unsigned __int16)v11 == 3)
        {
          char v26 = *(unsigned char *)v19;
LABEL_94:
          *(unsigned char *)a3 = v26;
          return 1;
        }
      }
      else
      {
LABEL_23:
        uint64_t v27 = MTLDataTypeString();
        sub_1B63F2F54(0, @"Warning: CFXValueWriteToMTLData - Unsupported data type %@", v28, v29, v30, v31, v32, v33, v27);
      }
      return 0;
  }
}

float sub_1B64D90E0(unsigned int a1)
{
  int v1 = (a1 >> 10) & 0x1F;
  if (v1 && v1 != 31)
  {
    int v1 = (v1 << 23) + 939524096;
  }
  else if (v1 == 31)
  {
    int v1 = 2139095040;
  }
  LODWORD(result) = (a1 << 16) & 0x80000000 | (a1 >> 7) & 7 | (8 * (a1 & 0x3FF)) & 0x1FFF | ((a1 & 0x3FF) << 13) | v1;
  return result;
}

uint64_t sub_1B64D9130(float a1)
{
  int v1 = HIWORD(LODWORD(a1)) & 0x8000;
  unsigned int v2 = (LODWORD(a1) >> 23);
  unsigned int v3 = v2 - 112;
  unsigned int v4 = v2 - 113;
  __int16 v5 = v1 | 0x7BFF;
  if (v2 == 255) {
    __int16 v5 = v1 | ((LODWORD(a1) & 0x7FFFFF) != 0) | 0x7C00;
  }
  if (v2 >= 0x71) {
    __int16 v6 = v5;
  }
  else {
    __int16 v6 = HIWORD(a1) & 0x8000;
  }
  int v7 = HIWORD(LODWORD(a1)) & 0x8000 | (LODWORD(a1) >> 13) & 0x3FF | (v3 << 10);
  if (v4 > 0x1D) {
    LOWORD(v7) = v6;
  }
  return (unsigned __int16)v7;
}

void sub_1B64D9188(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a3 + objc_msgSend_offset(a2, (const char *)a2, a3, a4);
  uint64_t v10 = objc_msgSend_dataType(a2, v7, v8, v9);
  if ((sub_1B64D87B8(a1, v10, v6, v11, v12, v13, v14, v15) & 1) == 0)
  {
    int v23 = sub_1B65625B4(a1, v16, v17, v18, v19, v20, v21, v22);
    sub_1B63F2F54(0, @"Warning: value unsupported %d of member %@", v24, v25, v26, v27, v28, v29, v23);
  }
}

CGImageRef sub_1B64D9208(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_pixelFormat(a1, a2, a3, a4);
  if (v5 <= 79)
  {
    if ((unint64_t)(v5 - 70) < 5)
    {
      uint32_t v9 = 16385;
LABEL_9:
      size_t v10 = 8;
      goto LABEL_10;
    }
    goto LABEL_13;
  }
  if ((unint64_t)(v5 - 80) < 2)
  {
    uint32_t v9 = 8194;
    goto LABEL_9;
  }
  if (v5 == 125)
  {
    uint32_t v9 = 16641;
    size_t v10 = 32;
    goto LABEL_10;
  }
  if (v5 != 115)
  {
LABEL_13:
    uint64_t v37 = objc_msgSend_pixelFormat(a1, v6, v7, v8);
    sub_1B63F2F54(16, @"Error: Unexpected pixel format %lu", v38, v39, v40, v41, v42, v43, v37);
    return 0;
  }
  uint32_t v9 = 12545;
  size_t v10 = 16;
LABEL_10:
  unint64_t v11 = (v10 * objc_msgSend_width(a1, v6, v7, v8)) >> 1;
  uint64_t v15 = objc_msgSend_height(a1, v12, v13, v14);
  size_t v16 = v11 & 0xFFFFFFFC;
  uint64_t v17 = malloc_type_malloc(v16 * v15, 0xECB556AEuLL);
  size_t v21 = objc_msgSend_width(a1, v18, v19, v20);
  size_t v25 = objc_msgSend_height(a1, v22, v23, v24);
  uint64_t v26 = (CGColorSpace *)sub_1B63C9388();
  uint64_t v27 = CGBitmapContextCreate(v17, v21, v25, v10, v16, v26, v9);
  memset(v44, 0, 24);
  v44[3] = objc_msgSend_width(a1, v28, v29, v30);
  v44[4] = objc_msgSend_height(a1, v31, v32, v33);
  v44[5] = 1;
  objc_msgSend_getBytes_bytesPerRow_fromRegion_mipmapLevel_(a1, v34, (uint64_t)v17, v16, v44, 0);
  CGImageRef Image = CGBitmapContextCreateImage(v27);
  CGContextRelease(v27);
  free(v17);
  return Image;
}

uint64_t sub_1B64D9394(const void *a1)
{
  if (CFEqual(a1, @"shaderRead")) {
    return 1;
  }
  if (CFEqual(a1, @"shaderWrite")) {
    return 2;
  }
  if (CFEqual(a1, @"renderTarget")) {
    return 4;
  }
  return 16 * (CFEqual(a1, @"pixelFormatView") != 0);
}

uint64_t sub_1B64D9420(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v3 = Count;
  CFIndex v4 = 0;
  uint64_t v5 = 0;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a1, v4);
    v5 |= sub_1B64D9394(ValueAtIndex);
    ++v4;
  }
  while (v3 != v4);
  return v5;
}

uint64_t sub_1B64D948C(__int16 a1, const void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (a3) {
      goto LABEL_3;
    }
LABEL_6:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mtlVertexFormat");
    goto LABEL_7;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mtlBuffer");
  if (!a3) {
    goto LABEL_6;
  }
LABEL_3:
  if (a3 >= 0x36) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad type", a3, a4, a5, a6, a7, a8, (uint64_t)"format < sizeof(__VFXMTLVertexFormatToCFXBaseTypeArray) / sizeof(__VFXMTLVertexFormatToCFXBaseTypeArray[0])");
  }
LABEL_7:
  unsigned int v14 = word_1B6E51600[a3];
  int v15 = sub_1B63CA908(v14, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v23 = sub_1B63CA958(v14, v16, v17, v18, v19, v20, v21, v22);
  uint64_t v24 = (const void *)sub_1B6534714(v15, v23, a4, a5, a6);
  uint64_t v31 = sub_1B641D0F8(v24, a1);
  if (!v31) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v25, v26, v27, v28, v29, v30, (uint64_t)"meshSource");
  }
  sub_1B6534974((uint64_t)v24, v31);
  if (v24) {
    CFRelease(v24);
  }
  *(void *)(v31 + 72) = CFRetain(a2);
  *(void *)(v31 + 80) = a3;
  return v31;
}

__IOSurface *sub_1B64D95D4(__IOSurface *result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    CFIndex v4 = (void **)a2;
    uint64_t v5 = result;
    uint64_t v6 = a3;
    do
    {
      float result = (__IOSurface *)objc_msgSend_iosurface(*v4, a2, a3, a4);
      if (result)
      {
        uint64_t v7 = result;
        IOSurfaceIncrementUseCount(result);
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 3221225472;
        void v10[2] = sub_1B64D96A0;
        v10[3] = &unk_1E61427F0;
        v10[4] = v7;
        float result = (__IOSurface *)objc_msgSend_addCompletedHandler_(v5, v8, (uint64_t)v10, v9);
      }
      ++v4;
      --v6;
    }
    while (v6);
  }
  return result;
}

void sub_1B64D96A0(uint64_t a1)
{
}

BOOL sub_1B64D96B4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return (unint64_t)objc_msgSend_maxViewportCount(a1, a2, a3, a4) > 1;
}

uint64_t sub_1B64D96DC()
{
  return 0;
}

uint64_t sub_1B64D971C()
{
  return 0;
}

uint64_t sub_1B64D976C(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 3) {
    return qword_1B6E51B20[a1];
  }
  sub_1B63F2F54(16, @"Unreachable code: Unexpected antialiasing mode (%d)", a3, a4, a5, a6, a7, a8, a1);
  return 1;
}

uint64_t sub_1B64D97B8(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if ((uint64_t)a2 < 2) {
    return 1;
  }
  uint64_t v15 = v5;
  uint64_t v16 = v4;
  uint64_t v17 = v6;
  uint64_t v18 = v7;
  unint64_t v9 = (a2 - 1) | (((unint64_t)a2 - 1) >> 1);
  unint64_t v10 = v9 | (v9 >> 2) | ((v9 | (v9 >> 2)) >> 4);
  unsigned int v11 = (((v10 | (v10 >> 8)) >> 16) | v10 | (v10 >> 8)) + 1;
  if (v11 >= 2)
  {
    while ((objc_msgSend_supportsTextureSampleCount_(a1, a2, v11, a4, v15, v16, v17, v18) & 1) == 0)
    {
      unsigned int v13 = v11 >> 1;
      BOOL v14 = v11 > 3;
      v11 >>= 1;
      if (!v14) {
        return v13;
      }
    }
  }
  return v11;
}

uint64_t sub_1B64D9848(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](a1, sel_supportsVertexAmplificationCount_, 2, a4);
}

uint64_t sub_1B64D9854(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_supportsUnalignedVertexFetch(a1, a2, a3, a4) ^ 1;
}

uint64_t sub_1B64D9870()
{
  if (qword_1E9DDAFC0 != -1) {
    dispatch_once(&qword_1E9DDAFC0, &unk_1F0FB5A08);
  }
  if (byte_1E9DDAFB8) {
    return 131075;
  }
  else {
    return 0x20000;
  }
}

void sub_1B64D98C8()
{
  byte_1E9DDAFB8 = 1;
}

void sub_1B64D9EA8(void *a1, char *a2, __CFDictionary *a3, void *a4)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = objc_msgSend_copy(a1, a2, (uint64_t)a3, (uint64_t)a4);
  uint64_t v12 = (const void *)objc_msgSend_asset(a1, v9, v10, v11);
  uint64_t v16 = (const void *)objc_msgSend_asset(v8, v13, v14, v15);
  CFDictionaryAddValue(a3, v12, v16);
  objc_msgSend_addChildNode_(a2, v17, (uint64_t)v8, v18);
  objc_msgSend_asset(a1, v19, v20, v21);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v25 = objc_msgSend_asset(a1, v22, v23, v24);
    uint64_t v29 = objc_msgSend_entityObject(v25, v26, v27, v28);
    uint64_t v33 = objc_msgSend_objectID(v29, v30, v31, v32);
    uint64_t v37 = objc_msgSend_asset(v8, v34, v35, v36);
    uint64_t v41 = objc_msgSend_entityObject(v37, v38, v39, v40);
    uint64_t v45 = objc_msgSend_objectID(v41, v42, v43, v44);
    objc_msgSend_add::(a4, v46, v33, v45);
  }
  __int16 v47 = objc_msgSend_childNodes(a1, v22, v23, v24);
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  uint64_t v49 = objc_msgSend_countByEnumeratingWithState_objects_count_(v47, v48, (uint64_t)&v54, (uint64_t)v58, 16);
  if (v49)
  {
    uint64_t v50 = v49;
    uint64_t v51 = *(void *)v55;
    do
    {
      uint64_t v52 = 0;
      do
      {
        if (*(void *)v55 != v51) {
          objc_enumerationMutation(v47);
        }
        sub_1B64D9EA8(*(void *)(*((void *)&v54 + 1) + 8 * v52++), v8, a3, a4);
      }
      while (v50 != v52);
      uint64_t v50 = objc_msgSend_countByEnumeratingWithState_objects_count_(v47, v53, (uint64_t)&v54, (uint64_t)v58, 16);
    }
    while (v50);
  }
}

const void *sub_1B64DA04C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  uint64_t v5 = objc_msgSend_model(a2, (const char *)a2, a3, a4);
  obuint64_t j = (id)objc_msgSend_materials(v5, v6, v7, v8);
  uint64_t v10 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v9, (uint64_t)&v54, (uint64_t)v59, 16);
  if (v10)
  {
    uint64_t v14 = v10;
    uint64_t v15 = *(void *)v55;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v55 != v15) {
          objc_enumerationMutation(obj);
        }
        uint64_t v17 = *(void **)(*((void *)&v54 + 1) + 8 * i);
        long long v50 = 0u;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        uint64_t v18 = objc_msgSend_properties(v17, v11, v12, v13);
        uint64_t v20 = objc_msgSend_countByEnumeratingWithState_objects_count_(v18, v19, (uint64_t)&v50, (uint64_t)v58, 16);
        if (v20)
        {
          uint64_t v21 = v20;
          uint64_t v22 = *(void *)v51;
          do
          {
            for (uint64_t j = 0; j != v21; ++j)
            {
              if (*(void *)v51 != v22) {
                objc_enumerationMutation(v18);
              }
              uint64_t v24 = *(void **)(*((void *)&v50 + 1) + 8 * j);
              CFDictionaryRef v25 = *(const __CFDictionary **)(a1 + 32);
              uint64_t v26 = (const void *)objc_msgSend_contents(v24, v11, v12, v13);
              Value = CFDictionaryGetValue(v25, v26);
              if (Value) {
                objc_msgSend_setContents_(v24, v11, (uint64_t)Value, v13);
              }
            }
            uint64_t v21 = objc_msgSend_countByEnumeratingWithState_objects_count_(v18, v11, (uint64_t)&v50, (uint64_t)v58, 16);
          }
          while (v21);
        }
      }
      uint64_t v14 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v11, (uint64_t)&v54, (uint64_t)v59, 16);
    }
    while (v14);
  }
  uint64_t v28 = objc_msgSend_light(a2, v11, v12, v13);
  uint64_t v32 = objc_msgSend_gobo(v28, v29, v30, v31);
  float result = (const void *)objc_msgSend_contents(v32, v33, v34, v35);
  if (result)
  {
    uint64_t v37 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), result);
    uint64_t v41 = objc_msgSend_light(a2, v38, v39, v40);
    uint64_t v45 = objc_msgSend_gobo(v41, v42, v43, v44);
    return (const void *)objc_msgSend_setContents_(v45, v46, (uint64_t)v37, v47);
  }
  return result;
}

uint64_t sub_1B64DA230(void *a1, void *a2, void *a3)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result)
  {
    uint64_t v10 = objc_msgSend_entityObject(a1, v7, v8, v9);
    uint64_t v14 = objc_msgSend_objectID(v10, v11, v12, v13);
    uint64_t v18 = objc_msgSend_entityObject(a2, v15, v16, v17);
    uint64_t v23 = objc_msgSend_objectID(v18, v19, v20, v21);
    return objc_msgSend_add::(a3, v22, v14, v23);
  }
  return result;
}

void *sub_1B64DA394(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(const void **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend_coreEntityHandleRef(*(void **)(a1 + 40), a2, a3, a4);

  return sub_1B63F48A0(v4, v5, v6, v7, v8, v9, v10, v11);
}

CFTypeRef sub_1B64DA53C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64B3988(*(void *)(*(void *)(a1 + 32) + 8), 0, a3, a4, a5, a6, a7, a8);
}

void sub_1B64DB098(uint64_t a1)
{
}

void sub_1B64DB3CC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = (uint64_t *)objc_msgSend_nodeRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B64B1DE0(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64DB684(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_worldRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B63DEAB8(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B64DBDBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

double sub_1B64DBEEC(uint64_t a1)
{
  v10.n128_u64[0] = sub_1B64FA004(*(const void **)(a1 + 32), 0);
  v10.n128_u64[1] = v2;
  *(void *)&double result = sub_1B64B2C18((__n128 *)*(void *)(*(void *)(a1 + 40) + 8), &v10, v3, v4, v5, v6, v7, v8).n128_u64[0];
  return result;
}

void sub_1B64DC098(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64DC16C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64DC240(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64DC30C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64DC3D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64DC4AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64DC578(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B64DCA04(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a1 + 32)
    && (uint64_t v7 = objc_msgSend_pathExtension(*(void **)(a1 + 40), a2, a3, a4),
        uint64_t v11 = objc_msgSend_lowercaseString(v7, v8, v9, v10),
        !objc_msgSend_isEqualToString_(*(void **)(a1 + 32), v12, v11, v13)))
  {
    uint64_t v20 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v14, v15, v16);
    uint64_t error = objc_msgSend_URLForDirectory_inDomain_appropriateForURL_create_error_(v20, v21, 99, 1, *(void *)(a1 + 40), 1, a2);
    if (error
      && ((uint64_t v26 = (void *)error,
           PathComponent = objc_msgSend_lastPathComponent(*(void **)(a1 + 40), v23, v24, v25),
           *(void *)(a1 + 32))
        ? (uint64_t v30 = objc_msgSend_stringByAppendingPathExtension_(PathComponent, v28, *(void *)(a1 + 32), v29))
        : (uint64_t v30 = objc_msgSend_stringByAppendingPathExtension_(PathComponent, v28, @"vfx", v29)),
          uint64_t v33 = objc_msgSend_URLByAppendingPathComponent_(v26, v31, v30, v32),
          (*(unsigned int (**)(uint64_t, uint64_t, const char *))(a3 + 16))(a3, v33, a2)))
    {
      uint64_t v37 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v34, v35, v36);
      uint64_t v38 = *(void *)(a1 + 40);
      return MEMORY[0x1F4181798](v37, sel_moveItemAtURL_toURL_error_, v33, v38);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(a3 + 16);
    return v18(a3, v17, a2);
  }
}

uint64_t sub_1B64DCB4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_writeToURLWithUSDKit_, a2, a4);
}

uint64_t sub_1B64DCB58(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (void *)MEMORY[0x1E4F35BB0];
  uint64_t v7 = objc_msgSend_world(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v10 = objc_msgSend_assetWithVFXWorld_(v6, v8, v7, v9);

  return MEMORY[0x1F4181798](v10, sel_exportAssetToURL_error_, a2, a3);
}

uint64_t sub_1B64DE068(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_UUID(MEMORY[0x1E4F29128], a2, a3, a4);
  uint64_t v10 = objc_msgSend_UUIDString(v5, v6, v7, v8);

  return objc_msgSend_setIdentifier_(a2, v9, v10, v11);
}

uint64_t sub_1B64DE0B0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_asset(a2, (const char *)a2, a3, a4);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v9 = objc_msgSend_asset(a2, v6, v7, v8);
    objc_msgSend_resolveTag_remap_(v9, v10, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  uint64_t v11 = objc_msgSend_asset(a2, v6, v7, v8);
  uint64_t result = objc_msgSend_conformsToProtocol_(v11, v12, (uint64_t)&unk_1F1043F78, v13);
  if (result)
  {
    uint64_t v18 = objc_msgSend_asset(a2, v15, v16, v17);
    uint64_t v22 = objc_msgSend_behaviorGraph(v18, v19, v20, v21);
    uint64_t v26 = objc_msgSend_coreEntityHandle(v22, v23, v24, v25);
    uint64_t v28 = *(void *)(a1 + 32);
    uint64_t v29 = *(void *)(a1 + 40);
    return objc_msgSend_resolveTag_remap_(v26, v27, v28, v29);
  }
  return result;
}

uint64_t sub_1B64DE160(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_particleEmitter(a2, (const char *)a2, a3, a4))
  {
    uint64_t v9 = objc_msgSend_particleEmitter(a2, v6, v7, v8);
    uint64_t v13 = objc_msgSend_coreEntityHandle(v9, v10, v11, v12);
    objc_msgSend_resolveTag_remap_(v13, v14, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  if (objc_msgSend_particleCollider(a2, v6, v7, v8))
  {
    uint64_t v18 = objc_msgSend_particleCollider(a2, v15, v16, v17);
    uint64_t v22 = objc_msgSend_coreEntityHandle(v18, v19, v20, v21);
    objc_msgSend_resolveTag_remap_(v22, v23, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  if (objc_msgSend_behaviorGraph(a2, v15, v16, v17))
  {
    uint64_t v27 = objc_msgSend_behaviorGraph(a2, v24, v25, v26);
    objc_msgSend_resolveTag_remap_(v27, v28, *(void *)(a1 + 32), *(void *)(a1 + 40));
    int isHidden = objc_msgSend_isHidden(a2, v29, v30, v31);
    objc_msgSend_setHidden_(a2, v33, isHidden ^ 1u, v34);
    int v38 = objc_msgSend_isHidden(a2, v35, v36, v37);
    objc_msgSend_setHidden_(a2, v39, v38 ^ 1u, v40);
  }
  uint64_t result = objc_msgSend_model(a2, v24, v25, v26);
  if (result)
  {
    uint64_t v45 = objc_msgSend_model(a2, v42, v43, v44);
    uint64_t v49 = objc_msgSend_behaviorGraph(v45, v46, v47, v48);
    long long v53 = objc_msgSend_coreEntityHandle(v49, v50, v51, v52);
    objc_msgSend_resolveTag_remap_(v53, v54, *(void *)(a1 + 32), *(void *)(a1 + 40));
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    __int16 v58 = objc_msgSend_model(a2, v55, v56, v57, 0);
    unsigned int v62 = objc_msgSend_materials(v58, v59, v60, v61);
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v62, v63, (uint64_t)&v76, (uint64_t)v80, 16);
    if (result)
    {
      uint64_t v67 = result;
      uint64_t v68 = *(void *)v77;
      do
      {
        uint64_t v69 = 0;
        do
        {
          if (*(void *)v77 != v68) {
            objc_enumerationMutation(v62);
          }
          int v70 = objc_msgSend_behaviorGraph(*(void **)(*((void *)&v76 + 1) + 8 * v69), v64, v65, v66);
          float v74 = objc_msgSend_coreEntityHandle(v70, v71, v72, v73);
          objc_msgSend_resolveTag_remap_(v74, v75, *(void *)(a1 + 32), *(void *)(a1 + 40));
          ++v69;
        }
        while (v67 != v69);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v62, v64, (uint64_t)&v76, (uint64_t)v80, 16);
        uint64_t v67 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t sub_1B64DE664(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_identifier(a2, (const char *)a2, a3, a4))
  {
    uint64_t v9 = *(void **)(a1 + 32);
    uint64_t v10 = objc_msgSend_identifier(a2, v6, v7, v8);
    objc_msgSend_setValue_forKey_(v9, v11, (uint64_t)a2, v10);
  }
  uint64_t result = objc_msgSend_model(a2, v6, v7, v8);
  if (result)
  {
    uint64_t v16 = objc_msgSend_model(a2, v13, v14, v15);
    if (objc_msgSend_identifier(v16, v17, v18, v19))
    {
      uint64_t v23 = *(void **)(a1 + 32);
      uint64_t v24 = objc_msgSend_model(a2, v20, v21, v22);
      uint64_t v28 = objc_msgSend_model(a2, v25, v26, v27);
      uint64_t v32 = objc_msgSend_identifier(v28, v29, v30, v31);
      objc_msgSend_setValue_forKey_(v23, v33, v24, v32);
    }
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    uint64_t v34 = objc_msgSend_model(a2, v20, v21, v22, 0);
    int v38 = objc_msgSend_materials(v34, v35, v36, v37);
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v38, v39, (uint64_t)&v50, (uint64_t)v54, 16);
    if (result)
    {
      uint64_t v43 = result;
      uint64_t v44 = *(void *)v51;
      do
      {
        uint64_t v45 = 0;
        do
        {
          if (*(void *)v51 != v44) {
            objc_enumerationMutation(v38);
          }
          __int16 v46 = *(void **)(*((void *)&v50 + 1) + 8 * v45);
          if (objc_msgSend_identifier(v46, v40, v41, v42))
          {
            uint64_t v47 = *(void **)(a1 + 32);
            uint64_t v48 = objc_msgSend_identifier(v46, v40, v41, v42);
            objc_msgSend_setValue_forKey_(v47, v49, (uint64_t)v46, v48);
          }
          ++v45;
        }
        while (v43 != v45);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v38, v40, (uint64_t)&v50, (uint64_t)v54, 16);
        uint64_t v43 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t sub_1B64DEC18(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  double v14 = INFINITY;
  uint64_t v5 = objc_msgSend_metalTextureWithEngineContext_textureSampler_nextFrameTime_status_(a2, (const char *)a2, a1, a3, &v14, a4);
  sub_1B6446084(a1, v14, v6, v7, v8, v9, v10, v11, v12);
  return v5;
}

void sub_1B64DEC74(uint64_t a1, void *a2, uint64_t a3)
{
  double v11 = INFINITY;
  objc_msgSend_renderWithEngineContext_textureSampler_nextFrameTime_(a2, (const char *)a2, a1, a3, &v11);
  sub_1B6446084(a1, v11, v4, v5, v6, v7, v8, v9, v10);
}

uint64_t sub_1B64DED18(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_textureSource(a3, a2, (uint64_t)a3, a4);
  if (v5)
  {
    uint64_t v13 = (const void *)v5;
    long long v28 = xmmword_1F0FBAC90;
    uint64_t v14 = sub_1B6451D68();
    sub_1B6451F1C(v14, &v28, v15, v16, v17, v18, v19, v20);
    sub_1B6451E98(v14, v13, v21, v22, v23, v24, v25, v26);
  }
  else
  {
    sub_1B64460E8(a1, v6, v7, v8, v9, v10, v11, v12);
    return 0;
  }
  return v14;
}

VFXSourceRendererRegistry *sub_1B64DEEB0()
{
  uint64_t result = objc_alloc_init(VFXSourceRendererRegistry);
  qword_1EB995FA8 = (uint64_t)result;
  return result;
}

_VFXUIKitSourceRegistry *sub_1B64DF22C()
{
  uint64_t result = objc_alloc_init(_VFXUIKitSourceRegistry);
  qword_1E9DDAFE0 = (uint64_t)result;
  return result;
}

void sub_1B64DF344(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B64DF3A0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B64DF4C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

_VFXUIApplicationObserver *sub_1B64DF590()
{
  uint64_t result = objc_alloc_init(_VFXUIApplicationObserver);
  qword_1E9DDAFE8 = (uint64_t)result;
  return result;
}

BOOL sub_1B64DF5B8()
{
  return qword_1E9DDAFE0 != 0;
}

void sub_1B64DFA70(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_uiView(*(void **)(a1 + 32), a2, a3, a4);
  objc_msgSend_bounds(v5, v6, v7, v8);
  double v10 = v9;
  double v12 = v11;
  double v14 = v13;
  double v16 = v15;
  uint64_t v17 = [_VFXSnapshotWindow alloc];
  id v72 = (id)objc_msgSend_initWithFrame_(v17, v18, v19, v20, v10, v12, v14, v16);
  objc_msgSend_setHidden_(v72, v21, 1, v22);
  LODWORD(v23) = 1.0;
  objc_msgSend_setCharge_(v72, v24, v25, v26, v23);
  objc_msgSend_setWindowLevel_(v72, v27, v28, v29, 10000.0);
  uint64_t v33 = objc_msgSend_uiView(*(void **)(a1 + 32), v30, v31, v32);
  objc_msgSend_addSubview_(v72, v34, v33, v35);
  uint64_t v39 = objc_msgSend_subviews(v72, v36, v37, v38);
  Object = objc_msgSend_firstObject(v39, v40, v41, v42);
  objc_msgSend_setNeedsDisplay(Object, v44, v45, v46);
  objc_msgSend_setNeedsDisplay(v72, v47, v48, v49);
  long long v53 = objc_msgSend_uiView(*(void **)(a1 + 32), v50, v51, v52);
  *(unsigned char *)(*(void *)(a1 + 32) + 32) = objc_msgSend_isOpaque(v53, v54, v55, v56);
  *(void *)(*(void *)(a1 + 32) + 24) = objc_msgSend_layer(v72, v57, v58, v59);
  __int16 v63 = objc_msgSend_superlayer(*(void **)(*(void *)(a1 + 32) + 24), v60, v61, v62);
  objc_msgSend_setValue_forKey_(v63, v64, MEMORY[0x1E4F1CC38], @"VFXIsBackingViewAsMaterialPropertyTag");
  objc_msgSend_setUiWindow_(*(void **)(a1 + 32), v65, (uint64_t)v72, v66);
  objc_msgSend_setPosition_(v72, v67, v68, v69, -10000.0, 0.0);
  objc_msgSend_setHidden_(v72, v70, 0, v71);
}

void sub_1B64DFD54(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 40);
}

void sub_1B64DFED0(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 40);
}

uint64_t sub_1B64E0118(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1B6DABD0C(a1, "PostRender");
  *(void *)uint64_t result = &unk_1F0FB2E68;
  *(_WORD *)(result + 24) = 0;
  *(void *)(result + 32) = a2;
  return result;
}

uint64_t sub_1B64E0168@<X0>(uint64_t a1@<X8>)
{
  v3[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v3, 27275, 51583, -277915706);
  return sub_1B63D0050(a1, v3, 1);
}

void sub_1B64E01E4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = a1 + 2;
}

unint64_t sub_1B64E01F0(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v3 = *(unsigned __int16 *)(a1 + 8);
  uint64_t v4 = *a3;
  if (v4)
  {
    uint64_t v5 = (uint64_t *)*((void *)a3 + 1);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t v10 = v7;
      uint64_t v8 = CFX::RG::ResourceIdentifier::id((CFX::RG::ResourceIdentifier *)&v10);
      unint64_t v3 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) >> 47));
      v6 -= 8;
    }
    while (v6);
  }
  return v3;
}

void sub_1B64E0278(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 32), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  sub_1B64E0788(v41, v10, v11, v12);
  if (sub_1B6447D40(*(void *)(a1 + 32)) && (sub_1B6447D6C(*(void *)(a1 + 32)) & 1) == 0)
  {
    uint64_t v35 = sub_1B6561FDC(a3, v41, *(void *)(a1 + 32), v13, v14, v15, v16, v17);
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v36, 27275, 51583, -277915706);
    unint64_t v31 = v36;
    uint64_t v32 = (uint64_t)a3;
    unint64_t v33 = (unint64_t)v35;
    uint64_t v34 = 0;
  }
  else
  {
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v39, *(_WORD *)(a1 + 24), 9273, 1656467160);
    CFX::RG::ResourceReference::ResourceReference((uint64_t)v40, v39);
    uint64_t v18 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"COLOR", (CFX::RG::ResourceReference *)v40);
    uint64_t v19 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v18);
    CFX::RG::TextureDescriptorReference::withSampleCount(v19, 1, (uint64_t)&v36);
    uint64_t v21 = CFX::RG::copyIfNeeded_r((CFX::RG *)a3, v18, 0, (CFX::RG::Pass *)&v36, (const CFX::RG::TextureDescriptorReference *)"Copy to final resolve", v20);
    double v23 = v22;
    uint64_t v29 = sub_1B6561FDC(a3, v41, *(void *)(a1 + 32), v24, v25, v26, v27, v28);
    *(void *)&long long v36 = v21;
    DWORD2(v36) = 0;
    uint64_t v37 = v29;
    uint64_t v38 = 0x100000000;
    CopyPass = (uint64_t *)CFX::RG::makeCopyPass(a3, (uint64_t)"CopyToFinal", &v36);
    CFX::RG::Pass::dependsOn(CopyPass, v23);
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v36, 27275, 51583, -277915706);
    unint64_t v31 = v36;
    uint64_t v32 = (uint64_t)a3;
    unint64_t v33 = (unint64_t)v29;
    uint64_t v34 = (uint64_t)CopyPass;
  }
  CFX::RG::RenderGraphBuilder::publishResourceReference(v32, v31, v33, v34);
}

uint64_t sub_1B64E0434(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1B6DABD0C(a1, "PostRender");
  *(void *)uint64_t result = &unk_1F0FB2F80;
  *(_WORD *)(result + 24) = 0;
  *(void *)(result + 32) = a2;
  return result;
}

uint64_t sub_1B64E0484@<X0>(uint64_t a1@<X8>)
{
  v3[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v3, 27275, 51583, -277915706);
  return sub_1B63D0050(a1, v3, 1);
}

void sub_1B64E0500(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = a1 + 2;
}

unint64_t sub_1B64E050C(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v3 = *(unsigned __int16 *)(a1 + 8);
  uint64_t v4 = *a3;
  if (v4)
  {
    uint64_t v5 = (uint64_t *)*((void *)a3 + 1);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t v10 = v7;
      uint64_t v8 = CFX::RG::ResourceIdentifier::id((CFX::RG::ResourceIdentifier *)&v10);
      unint64_t v3 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) >> 47));
      v6 -= 8;
    }
    while (v6);
  }
  return v3;
}

void sub_1B64E0594(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 32), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  sub_1B64E0788(v40, v10, v11, v12);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v38, *(_WORD *)(a1 + 24), 9273, 1656467160);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v39, v38);
  uint64_t v13 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"COLOR", (CFX::RG::ResourceReference *)v39);
  uint64_t v14 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v13);
  CFX::RG::TextureDescriptorReference::withSampleCount(v14, 1, (uint64_t)v37);
  uint64_t v15 = sub_1B63CFDE4(a3, (uint64_t)"Resolve", v37);
  v33.n128_u64[0] = (unint64_t)v13;
  v33.n128_u32[2] = 0;
  uint64_t v34 = v15;
  uint64_t v35 = 0x200000000;
  CFX::RG::makeCopyPass(a3, (uint64_t)"Resolve", &v33);
  if (sub_1B6446BAC(*(void *)(a1 + 32), v16, v17, v18, v19, v20, v21, v22))
  {
    CFX::RG::TextureDescriptorReference::finalColor((uint64_t)&v33);
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)&v33, MTLPixelFormatRGBA16Float, (uint64_t)v36);
    uint64_t v28 = sub_1B63CFDE4(a3, (uint64_t)"almost final target", v36);
    unint64_t v29 = *(void *)(a1 + 32);
    v33.n128_u64[0] = (unint64_t)v15;
    v33.n128_u64[1] = (unint64_t)v28;
    sub_1B6460320(a3, v29, (unint64_t)"debug copy stereo to drawable", &v33);
    uint64_t v15 = v28;
  }
  uint64_t v30 = sub_1B6561FDC(a3, v40, *(void *)(a1 + 32), v23, v24, v25, v26, v27);
  v33.n128_u64[0] = (unint64_t)v15;
  v33.n128_u32[2] = 0;
  uint64_t v34 = v30;
  uint64_t v35 = 0x100000000;
  CopyPass = (CFX::RG::ResourceIdentifier *)CFX::RG::makeCopyPass(a3, (uint64_t)"Copy to drawable", &v33);
  unint64_t v32 = CFX::RG::ResourceIdentifier::finalColor(CopyPass);
  CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v32, (unint64_t)v30, (uint64_t)CopyPass);
}

void sub_1B64E075C()
{
}

void sub_1B64E0774()
{
}

float32x4_t *sub_1B64E0788(float32x4_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_attachmentProvider(a2, (const char *)a2, a3, a4);
  if ((objc_opt_respondsToSelector() & 1) != 0
    && (double v9 = objc_msgSend_attachmentProvider(a2, v6, v7, v8),
        (uint64_t v13 = objc_msgSend_drawableDescriptor(v9, v10, v11, v12)) != 0))
  {
    sub_1B64E0880((uint64_t)a1, v13, v7, v8);
  }
  else if (objc_msgSend_textureTarget(a2, v6, v7, v8))
  {
    uint64_t v17 = objc_msgSend_textureTarget(a2, v14, v15, v16);
    sub_1B64E0900((uint64_t)a1, v17, v18, v19);
  }
  else if (objc_msgSend_layerTarget(a2, v14, v15, v16))
  {
    uint64_t v23 = (__n128 *)objc_msgSend_engineContext(a2, v20, v21, v22);
    *a1 = vrndmq_f32((float32x4_t)sub_1B64479C4(v23));
    uint64_t v27 = objc_msgSend_layerTarget(a2, v24, v25, v26);
    objc_msgSend_drawableSize(v27, v28, v29, v30);
    *(float *)&double v31 = v31;
    a1[1].f32[0] = floorf(*(float *)&v31);
    objc_msgSend_drawableSize(v27, v32, v33, v34);
    float v36 = v35;
    a1[1].f32[1] = floorf(v36);
    a1[1].i64[1] = objc_msgSend_pixelFormat(v27, v37, v38, v39);
    int v43 = objc_msgSend_framebufferOnly(v27, v40, v41, v42);
    uint64_t v44 = 4;
    if (!v43) {
      uint64_t v44 = 0;
    }
    a1[2].i64[0] = v44;
  }
  return a1;
}

uint64_t sub_1B64E0880(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(float *)(a1 + 16) = (float)objc_msgSend_width(a2, (const char *)a2, a3, a4);
  *(float *)(a1 + 20) = (float)objc_msgSend_height(a2, v6, v7, v8);
  *(void *)&long long v9 = 0;
  *((void *)&v9 + 1) = *(void *)(a1 + 8);
  *(_OWORD *)a1 = v9;
  *(float *)(a1 + 8) = (float)objc_msgSend_width(a2, v10, v11, v12);
  *(float *)(a1 + 12) = (float)objc_msgSend_height(a2, v13, v14, v15);
  uint64_t result = objc_msgSend_pixelFormat(a2, v16, v17, v18);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = 0;
  return result;
}

uint64_t sub_1B64E0900(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(float *)(a1 + 16) = (float)(unint64_t)objc_msgSend_width(a2, (const char *)a2, a3, a4);
  *(float *)(a1 + 20) = (float)(unint64_t)objc_msgSend_height(a2, v6, v7, v8);
  *(void *)&long long v9 = 0;
  *((void *)&v9 + 1) = *(void *)(a1 + 8);
  *(_OWORD *)a1 = v9;
  *(float *)(a1 + 8) = (float)(unint64_t)objc_msgSend_width(a2, v10, v11, v12);
  *(float *)(a1 + 12) = (float)(unint64_t)objc_msgSend_height(a2, v13, v14, v15);
  *(void *)(a1 + 24) = objc_msgSend_pixelFormat(a2, v16, v17, v18);
  uint64_t result = objc_msgSend_usage(a2, v19, v20, v21);
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t sub_1B64E098C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F0FB4680;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = 0;
  *(unsigned char *)(a1 + 512) = 0;
  *(void *)(a1 + 16) = a2;
  uint64_t v9 = sub_1B644558C(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 24) = v9;
  uint64_t v17 = sub_1B64B28FC(v9, v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 32) = v17;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 52) = 15;
  sub_1B6624920(v17, 0xFu);
  return a1;
}

void sub_1B64E0A54(_Unwind_Exception *a1)
{
  sub_1B6E306F8(v3, v2, v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64E0A70(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB4680;
  sub_1B6624994(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 52));
  for (uint64_t i = 504; i != 488; i -= 8)
  {
    uint64_t v3 = *(void **)(a1 + i);
    if (v3) {
  }
    }
  uint64_t v4 = *(void **)(a1 + 480);
  if (v4) {

  }
  return a1;
}

void sub_1B64E0AE4(_Unwind_Exception *a1)
{
  sub_1B6E30800(v1 + 512, v1 + 496, v1);
  _Unwind_Resume(a1);
}

void sub_1B64E0B04(uint64_t a1)
{
  sub_1B64E0A70(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64E0B3C(uint64_t a1, CFX::RG::RenderGraphContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 16), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = objc_msgSend_resourceManager(v11, v12, v13, v14);
  uint64_t v23 = sub_1B6446564(*(uint64_t **)(a1 + 16), v16, v17, v18, v19, v20, v21, v22);
  if (v23 && sub_1B64A3B48((uint64_t)v23, v24, v25, v26, v27, v28, v29, v30))
  {
    unsigned int v31 = sub_1B6626FAC(*(void *)(a1 + 32));
    unsigned int v69 = v31;
    BOOL v32 = sub_1B6626FBC(*(void *)(a1 + 32)) != 0;
    BOOL v68 = v32;
    uint64_t v33 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, *(const CFX::RG::Resource **)(a3 + 192));
    uint64_t v37 = *v33;
    uint64_t v38 = v33[1];
    unint64_t v39 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v31 ^ 1)) ^ ((0x9DDFEA08EB382D69 * (v31 ^ 1)) >> 47) ^ 1);
    unint64_t v40 = 0x9DDFEA08EB382D69 * (v39 ^ (v39 >> 47));
    unint64_t v41 = 0x9DDFEA08EB382D69
        * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v32)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v32)));
    unint64_t v42 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
    if (*(void *)(a1 + 472) != v42)
    {
      *(void *)(a1 + 472) = v42;
      sub_1B6626AF8(*(void *)(a1 + 32), *(void *)(a1 + 16));
      id v43 = objc_alloc_init(MEMORY[0x1E4F35228]);
      objc_msgSend_setConstantValue_type_withName_(v43, v44, (uint64_t)&v69, 33, @"LightCount");
      objc_msgSend_setConstantValue_type_withName_(v43, v45, (uint64_t)&v68, 33, @"raytracing_use_function_constant");
      uint64_t v46 = sub_1B6626EDC(*(void *)(a1 + 32));
      uint64_t v48 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_linkedFunctions_(v15, v47, @"vfx_rt_direct_lighting_trace", (uint64_t)v43, v46);

      uint64_t v49 = *(void **)(a1 + 480);
      if (v49 != (void *)v48)
      {
        if (v49) {

        }
        *(void *)(a1 + 480) = v48;
      }
      *(_DWORD *)(a1 + 452) = 0;
      sub_1B6626E64(*(void *)(a1 + 32));
      unsigned int v31 = v69;
      unint64_t v50 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69 * (v69 ^ 1)) ^ ((0x9DDFEA08EB382D69 * (v69 ^ 1)) >> 47) ^ 1);
      unint64_t v40 = 0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47));
    }
    unint64_t v51 = 0x9DDFEA08EB382D69
        * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v37)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v37)));
    unint64_t v52 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47))) ^ v38)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47))) ^ v38)));
    unint64_t v53 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
    if (*(void *)(a1 + 488) != v53)
    {
      *(void *)(a1 + 488) = v53;
      long long v54 = objc_msgSend_device(v11, v34, v35, v36);
      uint64_t v55 = 96 * (v37 >> 1) * (unint64_t)(v38 >> 1);
      uint64_t v57 = objc_msgSend_newBufferWithLength_options_(v54, v56, v55, 32);
      uint64_t v61 = *(void **)(a1 + 496);
      if (v61 != (void *)v57)
      {
        uint64_t v62 = v57;
        if (v61) {

        }
        *(void *)(a1 + 496) = v62;
      }
      __int16 v63 = objc_msgSend_device(v11, v58, v59, v60);
      uint64_t v65 = objc_msgSend_newBufferWithLength_options_(v63, v64, v55, 32);
      uint64_t v66 = *(void **)(a1 + 504);
      if (v66 != (void *)v65)
      {
        uint64_t v67 = v65;
        if (v66) {

        }
        *(void *)(a1 + 504) = v67;
      }
      *(_DWORD *)(a1 + 452) = 0;
      unsigned int v31 = v69;
    }
    *(unsigned char *)(a1 + 512) ^= 1u;
    if (v31 < *(_DWORD *)(a1 + 48)) {
      *(_DWORD *)(a1 + 452) = 0;
    }
    *(_DWORD *)(a1 + 48) = v31;
  }
}

uint64_t sub_1B64E0DD8(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  v36[0] = (uint64_t)"RTDirectLightingTracePass";
  v36[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB000, memory_order_acquire) & 1) == 0)
  {
    uint64_t v35 = a3;
    uint64_t v33 = a2;
    int v34 = __cxa_guard_acquire(&qword_1E9DDB000);
    a2 = v33;
    a3 = v35;
    if (v34)
    {
      byte_1E9DDAFF8 = 1;
      __cxa_guard_release(&qword_1E9DDB000);
      a2 = v33;
      a3 = v35;
    }
  }
  if (byte_1E9DDAFF8) {
    uint64_t v9 = 0x8FA5417697CB30C3;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B653860C(a1, a2, a3, v36, v9, 0);
  *(void *)a1 = &unk_1F0FB46A0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  uint64_t v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 400) = v17;
  *(void *)(a1 + 408) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  uint64_t v21 = a4[4];
  unint64_t v22 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v23 = CFX::CrossFrameResourceManager::get(v21, v22);
  *(void *)(a1 + 384) = v23;
  if (!v23)
  {
    CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    v36[0] = *(void *)(a1 + 368);
    sub_1B64E0FA4();
  }
  sub_1B64E0B3C(v23, (CFX::RG::RenderGraphContext *)a4, (uint64_t)a5, v24, v25, v26, v27, v28);
  uint64_t v29 = sub_1B63BE410(*(void **)(a1 + 400), a4[4]);
  uint64_t v30 = *(void *)(a1 + 384);
  *(void *)(v30 + 464) = v29;
  uint64_t v31 = *(void *)(a1 + 376);
  *(void *)(v31 + 248) = v30 + 64;
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(v31 + 192));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 376) + 184));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 376) + 200));
  return a1;
}

void sub_1B64E0F8C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B64E0FA4()
{
}

void sub_1B64E100C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A1C40EB1F0E58);
  _Unwind_Resume(a1);
}

void sub_1B64E1034(uint64_t *a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1[48] + 480))
  {
    uint64_t v10 = *a3;
    uint64_t v11 = sub_1B644558C(a1[46], a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    uint64_t v19 = sub_1B6446564((uint64_t *)a1[46], v12, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      if (sub_1B64A3B48((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26))
      {
        int v34 = sub_1B6446564((uint64_t *)a1[46], v27, v28, v29, v30, v31, v32, v33);
        sub_1B63E0460((uint64_t)v34, (uint64_t)v130, v35, v36, v37, v38, v39, v40);
        unint64_t v41 = (long long *)sub_1B6447988(a1[46], 1);
        long long v126 = v41[1];
        long long v127 = *v41;
        long long v124 = v41[3];
        long long v125 = v41[2];
        __n128 v129 = sub_1B64471F4(a1[46], 0, v42, v43, v44, v45, v46, v47);
        uint64_t v55 = sub_1B64B28FC(v11, v48, v49, v50, v51, v52, v53, v54);
        sub_1B6626AF8(v55, a1[46]);
        uint64_t v56 = (_OWORD *)a1[48];
        v56[4] = v127;
        v56[5] = v126;
        v56[6] = v125;
        v56[7] = v124;
        __int16 v63 = sub_1B649CD50(v130, (uint64_t)&v129, v57, v58, v59, v60, v61, v62);
        uint64_t v64 = 0;
        long long v65 = *((_OWORD *)v63 + 1);
        long long v66 = *((_OWORD *)v63 + 2);
        long long v67 = *((_OWORD *)v63 + 3);
        BOOL v68 = (_OWORD *)a1[48];
        v68[8] = *(_OWORD *)v63;
        v68[9] = v65;
        v68[10] = v66;
        v68[11] = v67;
        unsigned int v69 = (float32x4_t *)a1[48];
        float32x4_t v70 = v69[8];
        float32x4_t v71 = v69[9];
        float32x4_t v72 = v69[10];
        float32x4_t v73 = v69[11];
        float32x4_t v74 = v69[5];
        float32x4_t v75 = v69[6];
        float32x4_t v76 = v69[7];
        v131[0] = v69[4];
        v131[1] = v74;
        v131[2] = v75;
        v131[3] = v76;
        do
        {
          v132[v64] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v70, COERCE_FLOAT(*(_OWORD *)&v131[v64])), v71, *(float32x2_t *)v131[v64].f32, 1), v72, v131[v64], 2), v73, v131[v64], 3);
          ++v64;
        }
        while (v64 != 4);
        float32x4_t v77 = v132[1];
        float32x4_t v78 = v132[2];
        float32x4_t v79 = v132[3];
        unsigned char v69[12] = v132[0];
        v69[13] = v77;
        v69[14] = v78;
        v69[15] = v79;
        *(simd_float4x4 *)(a1[48] + 384) = __invert_f4(*(simd_float4x4 *)(a1[48] + 64));
        *(simd_float4x4 *)(a1[48] + 320) = __invert_f4(*(simd_float4x4 *)(a1[48] + 192));
        objc_msgSend_setBytes_length_atIndex_(v10, v80, a1[48] + 64, 400, 8);
        id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1[47] + 176));
        id v82 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1[47] + 192));
        id v83 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1[47] + 184));
        id v84 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1[47] + 200));
        id v85 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1[47] + 216));
        objc_msgSend_setTexture_atIndex_(v10, v86, (uint64_t)Texture, 0);
        objc_msgSend_setTexture_atIndex_(v10, v87, (uint64_t)v82, 1);
        objc_msgSend_setTexture_atIndex_(v10, v88, (uint64_t)v83, 2);
        objc_msgSend_setTexture_atIndex_(v10, v89, (uint64_t)v84, 3);
        objc_msgSend_setTexture_atIndex_(v10, v90, (uint64_t)v85, 4);
        objc_msgSend_setTexture_atIndex_(v10, v91, *(void *)(a1[48] + 464), 9);
        if (sub_1B6626FAC(v55))
        {
          uint64_t v93 = sub_1B6626ECC(v55);
          objc_msgSend_setBuffer_offset_atIndex_(v10, v94, v93, 0, 0);
        }
        objc_msgSend_setBuffer_offset_atIndex_(v10, v92, *(void *)(a1[48] + 8 * *(unsigned __int8 *)(a1[48] + 512) + 496), 0, 10);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v95, a1[49], 0, 11);
        uint64_t v102 = a1[48];
        uint64_t v103 = *(void *)(v102 + 480);
        if (!v103)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v96, v97, v98, v99, v100, v101, (uint64_t)"_ptr != NULL");
          uint64_t v103 = *(void *)(v102 + 480);
        }
        uint64_t v104 = sub_1B653EFB8(v103);
        objc_msgSend_setComputePipelineState_(v10, v105, v104, v106);
        unint64_t v110 = (unint64_t)objc_msgSend_width(v82, v107, v108, v109) >> 1;
        unint64_t v120 = (unint64_t)objc_msgSend_height(v82, v111, v112, v113) >> 1;
        uint64_t v121 = a1[48];
        uint64_t v122 = *(void *)(v121 + 480);
        if (!v122)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v114, v115, v116, v117, v118, v119, (uint64_t)"_ptr != NULL");
          uint64_t v122 = *(void *)(v121 + 480);
        }
        uint64_t v123 = (void *)sub_1B653EFB8(v122);
        v128[0] = v110;
        v128[1] = v120;
        v128[2] = 1;
        RGMTLComputeCommandEncoderDispatchOnGrid2D(v10, v123, (uint64_t)v128, 1);
        sub_1B6626E64(v55);
        ++*(_DWORD *)(a1[48] + 452);
      }
    }
  }
}

uint64_t sub_1B64E13D4(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  uint64_t v10 = *(void *)a5;
  v52[0] = (uint64_t)"RTDirectLightingSpatialReSTIRPass";
  v52[1] = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB010, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB010))
  {
    byte_1E9DDB008 = 1;
    __cxa_guard_release(&qword_1E9DDB010);
  }
  if (byte_1E9DDB008) {
    uint64_t v11 = 0x59850DCBC38AB58ALL;
  }
  else {
    uint64_t v11 = 0;
  }
  sub_1B653860C(a1, a2, a3, v52, v11, 0);
  *(void *)a1 = &unk_1F0FB4EB0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  uint64_t v19 = (void *)sub_1B6445900(*(void *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  *(void *)(a1 + 400) = v19;
  *(void *)(a1 + 408) = objc_msgSend_resourceManager(v19, v20, v21, v22);
  uint64_t v23 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, *(const CFX::RG::Resource **)(a5 + 192));
  uint64_t v24 = *v23;
  uint64_t v25 = v23[1];
  uint64_t v33 = sub_1B644558C(*(void *)(a1 + 368), v26, v27, v28, v29, v30, v31, v32);
  uint64_t v41 = sub_1B64B28FC(v33, v34, v35, v36, v37, v38, v39, v40);
  LODWORD(v52[0]) = 0;
  LODWORD(v52[0]) = sub_1B6626FBC(v41) != 0;
  unsigned int v51 = sub_1B6626FAC(v41);
  unint64_t v42 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v43 = 0x9DDFEA08EB382D69
      * (v42 ^ ((0x9DDFEA08EB382D69 * (v42 ^ LODWORD(v52[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v42 ^ LODWORD(v52[0]))));
  unint64_t v44 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
  uint64_t v45 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v51)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v51)))) ^ ((0x9DDFEA08EB382D69 * (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v51)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v51)))) >> 47)));
  *(void *)(a1 + 384) = v45;
  if (!v45) {
    operator new();
  }
  unint64_t v46 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v47 = 0x9DDFEA08EB382D69
      * (v46 ^ ((0x9DDFEA08EB382D69 * (v46 ^ v24)) >> 47) ^ (0x9DDFEA08EB382D69 * (v46 ^ v24)));
  unint64_t v48 = 0x9DDFEA08EB382D69 * (v47 ^ (v47 >> 47));
  uint64_t v49 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v25)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v25)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v25)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v25)))) >> 47)));
  *(void *)(a1 + 392) = v49;
  if (!v49) {
    operator new();
  }
  return a1;
}

void sub_1B64E1828(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B64E1868(uint64_t *a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[48];
  if (*(void *)(v8 + 16) && *(void *)(v8 + 24))
  {
    uint64_t v11 = *a3;
    uint64_t v12 = sub_1B644558C(a1[46], a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    uint64_t v20 = sub_1B64B28FC(v12, v13, v14, v15, v16, v17, v18, v19);
    double v21 = sub_1B6626AF8(v20, a1[46]);
    objc_msgSend_setBytes_length_atIndex_(v11, v22, *(void *)(a1[47] + 248), 400, 8, v21);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1[47] + 176));
    id v24 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1[47] + 192));
    objc_msgSend_setTexture_atIndex_(v11, v25, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v11, v26, (uint64_t)v24, 1);
    uint64_t v27 = sub_1B6626EB4(v20);
    objc_msgSend_useHeap_(v11, v28, v27, v29);
    uint64_t v30 = sub_1B6626EBC(v20);
    objc_msgSend_setAccelerationStructure_atBufferIndex_(v11, v31, v30, 1);
    if (sub_1B6626FAC(v20))
    {
      uint64_t v32 = sub_1B6626ECC(v20);
      objc_msgSend_setBuffer_offset_atIndex_(v11, v33, v32, 0, 2);
    }
    uint64_t v34 = sub_1B6626ED4(v20);
    unsigned int v38 = sub_1B6626FCC(v20, v35, v36, v37);
    objc_msgSend_useResources_count_usage_(v11, v39, v34, v38, 1);
    unint64_t v43 = objc_msgSend_width(v24, v40, v41, v42);
    unint64_t v47 = objc_msgSend_height(v24, v44, v45, v46);
    if (sub_1B6626FBC(v20))
    {
      uint64_t v55 = a1[48];
      uint64_t v56 = *(void *)(v55 + 16);
      if (!v56)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v49, v50, v51, v52, v53, v54, (uint64_t)"_ptr != NULL");
        uint64_t v56 = *(void *)(v55 + 16);
      }
      uint64_t v57 = (void *)sub_1B653EFB8(v56);
      uint64_t v58 = sub_1B6626EE4(v20, v57);
      objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v11, v59, (uint64_t)v58, 4);
    }
    else
    {
      uint64_t v58 = 0;
    }
    objc_msgSend_setBuffer_offset_atIndex_(v11, v48, *(void *)(a1[47] + 232), 0, 10);
    objc_msgSend_setBuffer_offset_atIndex_(v11, v60, *(void *)(a1[49] + 16), 0, 11);
    uint64_t v67 = a1[48];
    uint64_t v68 = *(void *)(v67 + 16);
    if (!v68)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v61, v62, v63, v64, v65, v66, (uint64_t)"_ptr != NULL");
      uint64_t v68 = *(void *)(v67 + 16);
    }
    unint64_t v69 = v43 >> 1;
    unint64_t v70 = v47 >> 1;
    uint64_t v71 = sub_1B653EFB8(v68);
    objc_msgSend_setComputePipelineState_(v11, v72, v71, v73);
    uint64_t v80 = a1[48];
    uint64_t v81 = *(void *)(v80 + 16);
    if (!v81)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v74, v75, v76, v77, v78, v79, (uint64_t)"_ptr != NULL");
      uint64_t v81 = *(void *)(v80 + 16);
    }
    id v82 = (void *)sub_1B653EFB8(v81);
    v117[0] = v69;
    v117[1] = v70;
    v117[2] = 1;
    RGMTLComputeCommandEncoderDispatchOnGrid2D(v11, v82, (uint64_t)v117, 1);

    if (sub_1B6626FBC(v20))
    {
      uint64_t v90 = a1[48];
      uint64_t v91 = *(void *)(v90 + 24);
      if (!v91)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v84, v85, v86, v87, v88, v89, (uint64_t)"_ptr != NULL");
        uint64_t v91 = *(void *)(v90 + 24);
      }
      long long v92 = (void *)sub_1B653EFB8(v91);
      uint64_t v93 = sub_1B6626EE4(v20, v92);
      objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v11, v94, (uint64_t)v93, 4);
    }
    else
    {
      uint64_t v93 = 0;
    }
    objc_msgSend_setBuffer_offset_atIndex_(v11, v83, *(void *)(a1[49] + 16), 0, 10);
    objc_msgSend_setBuffer_offset_atIndex_(v11, v95, *(void *)(a1[49] + 24), 0, 11);
    uint64_t v102 = a1[48];
    uint64_t v103 = *(void *)(v102 + 24);
    if (!v103)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v96, v97, v98, v99, v100, v101, (uint64_t)"_ptr != NULL");
      uint64_t v103 = *(void *)(v102 + 24);
    }
    uint64_t v104 = sub_1B653EFB8(v103);
    objc_msgSend_setComputePipelineState_(v11, v105, v104, v106);
    uint64_t v113 = a1[48];
    uint64_t v114 = *(void *)(v113 + 24);
    if (!v114)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v107, v108, v109, v110, v111, v112, (uint64_t)"_ptr != NULL");
      uint64_t v114 = *(void *)(v113 + 24);
    }
    uint64_t v115 = (void *)sub_1B653EFB8(v114);
    v116[0] = v69;
    v116[1] = v70;
    v116[2] = 1;
    RGMTLComputeCommandEncoderDispatchOnGrid2D(v11, v115, (uint64_t)v116, 1);

    sub_1B6626E64(v20);
  }
}

uint64_t sub_1B64E1C28(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  v46[0] = (uint64_t)"RTDirectLightingResolvePass";
  v46[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB020, memory_order_acquire) & 1) == 0)
  {
    uint64_t v42 = a3;
    uint64_t v43 = a2;
    int v44 = __cxa_guard_acquire(&qword_1E9DDB020);
    a2 = v43;
    a3 = v42;
    if (v44)
    {
      qword_1E9DDB018 = (uint64_t)sub_1B64E2BAC("RT_DIRECT_LIGHTING_RESOLVE", 0x1Au);
      __cxa_guard_release(&qword_1E9DDB020);
      a2 = v43;
      a3 = v42;
    }
  }
  sub_1B653860C(a1, a2, a3, v46, qword_1E9DDB018, 0);
  *(void *)a1 = &unk_1F0FB48D0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  uint64_t v16 = (void *)sub_1B6445900(*(void *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
  *(void *)(a1 + 400) = v16;
  *(void *)(a1 + 408) = objc_msgSend_resourceManager(v16, v17, v18, v19);
  uint64_t v27 = sub_1B644558C(*(void *)(a1 + 368), v20, v21, v22, v23, v24, v25, v26);
  uint64_t v35 = sub_1B64B28FC(v27, v28, v29, v30, v31, v32, v33, v34);
  unsigned int v36 = sub_1B6626FAC(v35);
  LODWORD(v46[0]) = v36;
  unint64_t v37 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v38 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v37 ^ ((0x9DDFEA08EB382D69 * (v37 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v37 ^ v36)))) ^ ((0x9DDFEA08EB382D69 * (v37 ^ ((0x9DDFEA08EB382D69 * (v37 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v37 ^ v36)))) >> 47)));
  *(void *)(a1 + 384) = v38;
  if (!v38) {
    operator new();
  }
  uint64_t v39 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(*(void *)(a1 + 376) + 8), MTLPixelFormatRGBA16Float, (uint64_t)v45);
  uint64_t v40 = sub_1B63CFDE4(v39, (uint64_t)"DirectLightingResolve", v45);
  *(void *)(a1 + 392) = v40;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v40);
  return a1;
}

void sub_1B64E1E98(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B64E1ED0(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)(a1 + 384) + 16))
  {
    uint64_t v10 = *a3;
    uint64_t v11 = sub_1B644558C(*(void *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    uint64_t v19 = sub_1B64B28FC(v11, v12, v13, v14, v15, v16, v17, v18);
    double v20 = sub_1B6626AF8(v19, *(void *)(a1 + 368));
    objc_msgSend_setBytes_length_atIndex_(v10, v21, *(void *)(*(void *)(a1 + 376) + 248), 400, 8, v20);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 176));
    id v23 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 192));
    id v24 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 184));
    id v25 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 200));
    objc_msgSend_setTexture_atIndex_(v10, v26, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v10, v27, (uint64_t)v23, 1);
    objc_msgSend_setTexture_atIndex_(v10, v28, (uint64_t)v24, 2);
    objc_msgSend_setTexture_atIndex_(v10, v29, (uint64_t)v25, 3);
    objc_msgSend_setBuffer_offset_atIndex_(v10, v30, *(void *)(*(void *)(a1 + 376) + 240), 0, 0);
    if (sub_1B6626FAC(v19))
    {
      uint64_t v31 = sub_1B6626ECC(v19);
      objc_msgSend_setBuffer_offset_atIndex_(v10, v32, v31, 0, 3);
    }
    id v33 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 392));
    objc_msgSend_setTexture_atIndex_(v10, v34, (uint64_t)v33, 10);
    uint64_t v41 = *(void *)(a1 + 384);
    uint64_t v42 = *(void *)(v41 + 16);
    if (!v42)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v35, v36, v37, v38, v39, v40, (uint64_t)"_ptr != NULL");
      uint64_t v42 = *(void *)(v41 + 16);
    }
    uint64_t v43 = sub_1B653EFB8(v42);
    objc_msgSend_dispatch_onTexture2D_(v10, v44, v43, (uint64_t)v33);
    sub_1B6626E64(v19);
  }
}

uint64_t sub_1B64E20B4(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, const CFX::RG::Resource **a5)
{
  uint64_t v9 = (uint64_t)*a5;
  v45[0] = (uint64_t)"RTDirectLightingDenoisePass";
  v45[1] = v9;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB030, memory_order_acquire) & 1) == 0)
  {
    uint64_t v43 = a2;
    int v44 = __cxa_guard_acquire(&qword_1E9DDB030);
    a2 = v43;
    if (v44)
    {
      qword_1E9DDB028 = (uint64_t)sub_1B64E2BAC("RT_DIRECT_LIGHTING_DENOISE", 0x1Au);
      __cxa_guard_release(&qword_1E9DDB030);
      a2 = v43;
    }
  }
  sub_1B653860C(a1, a2, a3, v45, qword_1E9DDB028, 0);
  *(void *)a1 = &unk_1F0FB4860;
  long long v10 = *(_OWORD *)a5;
  long long v11 = *((_OWORD *)a5 + 1);
  long long v12 = *((_OWORD *)a5 + 3);
  *(_OWORD *)(a1 + 408) = *((_OWORD *)a5 + 2);
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 376) = v10;
  *(_OWORD *)(a1 + 392) = v11;
  long long v13 = *((_OWORD *)a5 + 4);
  long long v14 = *((_OWORD *)a5 + 5);
  long long v15 = *((_OWORD *)a5 + 7);
  *(_OWORD *)(a1 + 472) = *((_OWORD *)a5 + 6);
  *(_OWORD *)(a1 + 488) = v15;
  *(_OWORD *)(a1 + 440) = v13;
  *(_OWORD *)(a1 + 456) = v14;
  long long v16 = *((_OWORD *)a5 + 8);
  long long v17 = *((_OWORD *)a5 + 9);
  long long v18 = *((_OWORD *)a5 + 11);
  *(_OWORD *)(a1 + 536) = *((_OWORD *)a5 + 10);
  *(_OWORD *)(a1 + 552) = v18;
  *(_OWORD *)(a1 + 504) = v16;
  *(_OWORD *)(a1 + 520) = v17;
  long long v19 = *((_OWORD *)a5 + 12);
  long long v20 = *((_OWORD *)a5 + 13);
  long long v21 = *((_OWORD *)a5 + 15);
  *(_OWORD *)(a1 + 600) = *((_OWORD *)a5 + 14);
  *(_OWORD *)(a1 + 616) = v21;
  *(_OWORD *)(a1 + 568) = v19;
  *(_OWORD *)(a1 + 584) = v20;
  *(void *)(a1 + 664) = 0;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  uint64_t v29 = (void *)sub_1B6445900(*(void *)(a1 + 368), v22, v23, v24, v25, v26, v27, v28);
  *(void *)(a1 + 656) = v29;
  *(void *)(a1 + 664) = objc_msgSend_resourceManager(v29, v30, v31, v32);
  id v33 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, a5[24]);
  uint64_t v34 = *v33;
  uint64_t v35 = v33[1];
  unint64_t v36 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v37 = CFX::CrossFrameResourceManager::get(a4[4], v36);
  *(void *)(a1 + 632) = v37;
  if (!v37) {
    sub_1B64E2488();
  }
  unint64_t v38 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v39 = 0x9DDFEA08EB382D69
      * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v34)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v34)));
  unint64_t v40 = 0x9DDFEA08EB382D69 * (v39 ^ (v39 >> 47));
  uint64_t v41 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v35)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v35)))) ^ ((0x9DDFEA08EB382D69 * (v40 ^ ((0x9DDFEA08EB382D69 * (v40 ^ v35)) >> 47) ^ (0x9DDFEA08EB382D69 * (v40 ^ v35)))) >> 47)));
  *(void *)(a1 + 640) = v41;
  if (!v41) {
    operator new();
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 552));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 592));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 640) + 8 * (*(unsigned char *)(*(void *)(a1 + 632) + 24) == 0) + 16));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 640) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 632) + 24) + 16));
  return a1;
}

void sub_1B64E2460(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B64E2488()
{
}

__n128 sub_1B64E2574(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 result)
{
  if (*(void *)(*(void *)(a1 + 632) + 16))
  {
    long long v11 = *a3;
    long long v12 = sub_1B6446564(*(uint64_t **)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (v12)
    {
      if (sub_1B64A3B48((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19))
      {
        uint64_t v27 = sub_1B6446564(*(uint64_t **)(a1 + 368), v20, v21, v22, v23, v24, v25, v26);
        sub_1B63E0460((uint64_t)v27, (uint64_t)v97, v28, v29, v30, v31, v32, v33);
        uint64_t v34 = (long long *)sub_1B6447988(*(void *)(a1 + 368), 1);
        long long v94 = v34[1];
        long long v95 = *v34;
        long long v92 = v34[3];
        long long v93 = v34[2];
        __n128 v96 = sub_1B64471F4(*(void *)(a1 + 368), 0, v35, v36, v37, v38, v39, v40);
        uint64_t v41 = *(_OWORD **)(a1 + 632);
        v41[2] = v95;
        float32x4_t v41[3] = v94;
        v41[4] = v93;
        v41[5] = v92;
        unint64_t v48 = sub_1B649CD50(v97, (uint64_t)&v96, v42, v43, v44, v45, v46, v47);
        uint64_t v49 = 0;
        long long v50 = *((_OWORD *)v48 + 1);
        long long v51 = *((_OWORD *)v48 + 2);
        long long v52 = *((_OWORD *)v48 + 3);
        uint64_t v53 = *(_OWORD **)(a1 + 632);
        v53[6] = *(_OWORD *)v48;
        v53[7] = v50;
        v53[8] = v51;
        v53[9] = v52;
        uint64_t v54 = *(float32x4_t **)(a1 + 632);
        float32x4_t v55 = v54[6];
        float32x4_t v56 = v54[7];
        float32x4_t v57 = v54[8];
        float32x4_t v58 = v54[9];
        float32x4_t v59 = v54[3];
        float32x4_t v60 = v54[4];
        float32x4_t v61 = v54[5];
        v98[0] = v54[2];
        v98[1] = v59;
        v98[2] = v60;
        v98[3] = v61;
        do
        {
          v99[v49] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v55, COERCE_FLOAT(v98[v49])), v56, *(float32x2_t *)&v98[v49], 1), v57, (float32x4_t)v98[v49], 2), v58, (float32x4_t)v98[v49], 3);
          ++v49;
        }
        while (v49 != 4);
        float32x4_t v62 = (float32x4_t)v99[1];
        float32x4_t v63 = (float32x4_t)v99[2];
        float32x4_t v64 = (float32x4_t)v99[3];
        v54[10] = (float32x4_t)v99[0];
        v54[11] = v62;
        v54[12] = v63;
        v54[13] = v64;
        *(simd_float4x4 *)(*(void *)(a1 + 632) + 352) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 632) + 32));
        *(simd_float4x4 *)(*(void *)(a1 + 632) + 288) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 632) + 160));
        objc_msgSend_setBytes_length_atIndex_(v11, v65, *(void *)(a1 + 632) + 32, 400, 8);
        id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 648));
        id v67 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 552));
        uint64_t v68 = *(const CFX::RG::Resource **)(a1 + 584);
        if (v68) {
          id v69 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v68);
        }
        else {
          id v69 = 0;
        }
        id v70 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 592));
        objc_msgSend_setTexture_atIndex_(v11, v71, (uint64_t)Texture, 0);
        objc_msgSend_setTexture_atIndex_(v11, v72, (uint64_t)v67, 1);
        objc_msgSend_setTexture_atIndex_(v11, v73, (uint64_t)v69, 2);
        objc_msgSend_setTexture_atIndex_(v11, v74, (uint64_t)v70, 3);
        id v75 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 640)+ 8 * *(unsigned __int8 *)(*(void *)(a1 + 632) + 24)+ 16));
        id v76 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 640)+ 8 * (*(unsigned char *)(*(void *)(a1 + 632) + 24) == 0)+ 16));
        objc_msgSend_setTexture_atIndex_(v11, v77, (uint64_t)v75, 10);
        objc_msgSend_setTexture_atIndex_(v11, v78, (uint64_t)v76, 11);
        uint64_t v85 = *(void *)(a1 + 632);
        uint64_t v86 = *(void *)(v85 + 16);
        if (!v86)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v79, v80, v81, v82, v83, v84, (uint64_t)"_ptr != NULL");
          uint64_t v86 = *(void *)(v85 + 16);
        }
        uint64_t v87 = sub_1B653EFB8(v86);
        objc_msgSend_dispatch_onTexture2D_(v11, v88, v87, (uint64_t)v75);
        uint64_t v89 = *(void *)(a1 + 632);
        *(unsigned char *)(v89 + 24) ^= 1u;
        long long v90 = *(_OWORD *)(v89 + 304);
        *(_OWORD *)(v89 + 224) = *(_OWORD *)(v89 + 288);
        *(_OWORD *)(v89 + 240) = v90;
        uint64_t result = *(__n128 *)(v89 + 320);
        long long v91 = *(_OWORD *)(v89 + 336);
        *(__n128 *)(v89 + 256) = result;
        *(_OWORD *)(v89 + 272) = v91;
        ++*(_DWORD *)(*(void *)(a1 + 632) + 420);
      }
    }
  }
  return result;
}

uint64_t *sub_1B64E286C(CFX::RG::RenderGraphContext *a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a1);
  uint64_t v5 = (CFX::RG::Pass *)sub_1B64E295C(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  a2[29] = *(void *)(*((void *)v5 + 48) + 8 * *(unsigned __int8 *)(*((void *)v5 + 48) + 512) + 496);
  uint64_t v6 = (uint64_t *)sub_1B64E29B4(v4, (CFX::CrossFrameResourceManager **)a1, (uint64_t)a2);
  CFX::RG::Pass::dependsOn(v6, v5);
  uint64_t v7 = *(void *)(v6[49] + 24);
  a2[30] = v7;
  *((void *)v5 + 49) = v7;
  uint64_t v8 = (uint64_t *)sub_1B64E2A0C(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  CFX::RG::Pass::dependsOn(v8, (CFX::RG::Pass *)v6);
  uint64_t v9 = (uint64_t *)sub_1B64E2A64(v4, (CFX::CrossFrameResourceManager **)a1, (const CFX::RG::Resource **)a2);
  long long v10 = (CFX::RG::Resource *)v8[49];
  v9[81] = (uint64_t)v10;
  CFX::RG::Pass::readFrom(v9, v10);
  CFX::RG::Pass::dependsOn(v9, (CFX::RG::Pass *)v8);
  a2[28] = *(void *)(v9[80] + 8 * *(unsigned __int8 *)(v9[79] + 24) + 16);
  return v9;
}

uint64_t sub_1B64E295C(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64E3090(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B64E29B4(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64E30F0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B64E2A0C(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64E3150(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B64E2A64(uint64_t *a1, CFX::CrossFrameResourceManager **a2, const CFX::RG::Resource **a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64E31B0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B64E2AC0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64E2AFC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64E2B38(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64E2B74(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B64E2BAC(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      uint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      uint64_t result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B64E2C98(void *a1)
{
  *a1 = &unk_1F0FB4E70;
  for (uint64_t i = 3; i != 1; --i)
  {
    uint64_t v3 = (void *)a1[i];
    if (v3) {
  }
    }
  return a1;
}

void sub_1B64E2CF4(void *a1)
{
  *a1 = &unk_1F0FB4E70;
  uint64_t v2 = 3;
  while (1)
  {
    uint64_t v3 = (void *)a1[v2];
    if (v3) {

    }
    if (--v2 == 1)
    {
      JUMPOUT(0x1BA9B6D80);
    }
  }
}

void *sub_1B64E2D70(void *a1)
{
  *a1 = &unk_1F0FB4E90;
  for (uint64_t i = 3; i != 1; --i)
  {
    uint64_t v3 = (void *)a1[i];
    if (v3) {
  }
    }
  return a1;
}

void sub_1B64E2DCC(void *a1)
{
  *a1 = &unk_1F0FB4E90;
  uint64_t v2 = 3;
  while (1)
  {
    uint64_t v3 = (void *)a1[v2];
    if (v3) {

    }
    if (--v2 == 1)
    {
      JUMPOUT(0x1BA9B6D80);
    }
  }
}

void *sub_1B64E2E48(void *a1)
{
  *a1 = &unk_1F0FB48B0;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B64E2E94(void *a1)
{
  *a1 = &unk_1F0FB48B0;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B64E2F00(void *a1)
{
  *a1 = &unk_1F0FB4820;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B64E2F4C(void *a1)
{
  *a1 = &unk_1F0FB4820;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B64E2FB8(void *a1)
{
  *a1 = &unk_1F0FB4840;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B64E3014(void *a1)
{
  *a1 = &unk_1F0FB4840;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B64E3090(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A0u, 8u);
  return sub_1B64E0DD8(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64E30F0(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A0u, 8u);
  return sub_1B64E13D4(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64E3150(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A0u, 8u);
  return sub_1B64E1C28(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64E31B0(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, const CFX::RG::Resource **a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x2A0u, 8u);
  return sub_1B64E20B4(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64E3210(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B64E3240(uint64_t a1, uint64_t a2)
{
  if (qword_1E9DDB040 != -1) {
    dispatch_once_f(&qword_1E9DDB040, &qword_1E9DDB038, (dispatch_function_t)sub_1B64E3210);
  }
  uint64_t result = sub_1B63C8D44(qword_1E9DDB038, 0x30uLL);
  if (a2 > 3) {
    return 0;
  }
  *(void *)(result + 48) = a2;
  if (a2 < 1)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    int v6 = 0;
    uint64_t v7 = (__int8 *)(a1 + 2);
    uint64_t v8 = (void *)(result + 16);
    do
    {
      *uint64_t v8 = *(void *)(v7 - 2);
      if (*(v7 - 2))
      {
        v5.i8[0] = *v7;
        v5.i8[4] = v7[1];
        int8x16_t v9 = v5;
        v9.i8[1] = v5.i8[4];
        v9.i8[8] = *v7;
        v9.i8[9] = v5.i8[4];
        *(int8x8_t *)v5.i8 = vceq_s8(vqtbl1_s8(v9, (int8x8_t)0x101000000000101), (int8x8_t)0xB0D0A0C0B0D0A0CLL);
        v5.i8[0] = vmaxv_u8(*(uint8x8_t *)v5.i8);
        v6 |= v5.i32[0];
        if (*(v7 - 1))
        {
          v5.i8[0] = v7[3];
          v5.i8[4] = v7[4];
          int8x16_t v10 = v5;
          v10.i8[1] = v5.i8[4];
          v10.i8[8] = v5.i8[0];
          v10.i8[9] = v5.i8[4];
          *(int8x8_t *)v5.i8 = vceq_s8(vqtbl1_s8(v10, (int8x8_t)0x101000000000101), (int8x8_t)0xB0D0A0C0B0D0A0CLL);
          v5.i8[0] = vmaxv_u8(*(uint8x8_t *)v5.i8);
          v6 |= v5.i32[0];
        }
      }
      v7 += 8;
      ++v8;
      --a2;
    }
    while (a2);
  }
  *(unsigned char *)(result + 56) = v6 & 1;
  return result;
}

uint64_t sub_1B64E3388(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"states");
  }
  if (*(void *)(a1 + 48) <= a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong target index", a3, a4, a5, a6, a7, a8, (uint64_t)"renderTargetIndex < states->_targetCount");
  }
  return *(void *)(a1 + 8 * a2 + 16);
}

uint64_t sub_1B64E3404(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"states");
  }
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t sub_1B64E3450()
{
  if (qword_1E9DDB050 != -1) {
    dispatch_once(&qword_1E9DDB050, &unk_1F0FB5A88);
  }
  return qword_1E9DDB048;
}

uint64_t sub_1B64E3494()
{
  uint64_t v1 = 0x1010001010001;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB048 = result;
  return result;
}

uint64_t sub_1B64E34D4()
{
  if (qword_1E9DDB060 != -1) {
    dispatch_once(&qword_1E9DDB060, &unk_1F0FB62E8);
  }
  return qword_1E9DDB058;
}

uint64_t sub_1B64E3518()
{
  uint64_t v1 = 0x2000002000001;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB058 = result;
  return result;
}

uint64_t sub_1B64E3558()
{
  if (qword_1E9DDB070 != -1) {
    dispatch_once(&qword_1E9DDB070, &unk_1F0FB63C8);
  }
  return qword_1E9DDB068;
}

uint64_t sub_1B64E359C()
{
  uint64_t v1 = 0x10002000101;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB068 = result;
  return result;
}

uint64_t sub_1B64E35DC()
{
  if (qword_1E9DDB080 != -1) {
    dispatch_once(&qword_1E9DDB080, &unk_1F0FB6548);
  }
  return qword_1E9DDB078;
}

uint64_t sub_1B64E3620()
{
  uint64_t v1 = 0x5010005010001;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB078 = result;
  return result;
}

uint64_t sub_1B64E3664()
{
  if (qword_1E9DDB090 != -1) {
    dispatch_once(&qword_1E9DDB090, &unk_1F0FB6788);
  }
  return qword_1E9DDB088;
}

uint64_t sub_1B64E36A8()
{
  uint64_t v1 = 0x10000010000;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB088 = result;
  return result;
}

uint64_t sub_1B64E36E4()
{
  if (qword_1E9DDB0A0 != -1) {
    dispatch_once(&qword_1E9DDB0A0, &unk_1F0FB6968);
  }
  return qword_1E9DDB098;
}

uint64_t sub_1B64E3728()
{
  uint64_t v1 = 0x1000201010101;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB098 = result;
  return result;
}

uint64_t sub_1B64E3768()
{
  if (qword_1E9DDB0B0 != -1) {
    dispatch_once(&qword_1E9DDB0B0, &unk_1F0FB6B48);
  }
  return qword_1E9DDB0A8;
}

uint64_t sub_1B64E37AC()
{
  uint64_t v1 = 0x401010401010001;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB0A8 = result;
  return result;
}

uint64_t sub_1B64E37F0()
{
  if (qword_1E9DDB0C0 != -1) {
    dispatch_once(&qword_1E9DDB0C0, &unk_1F0FB6C28);
  }
  return qword_1E9DDB0B8;
}

uint64_t sub_1B64E3834()
{
  uint64_t v1 = 0x5010003010101;
  uint64_t result = sub_1B64E3240((uint64_t)&v1, 1);
  qword_1E9DDB0B8 = result;
  return result;
}

__CFString *sub_1B64E3884(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CFXBlendStates %p targetCount:%d needsBlendColor:%d\n", a1, *(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 56));
  if (*(uint64_t *)(a1 + 48) >= 1)
  {
    uint64_t v9 = 0;
    int8x16_t v10 = (unsigned __int8 *)(a1 + 23);
    theString = Mutable;
    uint64_t v31 = a1;
    do
    {
      uint64_t v11 = *(v10 - 5);
      uint64_t v12 = *(v10 - 4);
      uint64_t v13 = *(v10 - 3);
      if (*(v10 - 6))
      {
        uint64_t v18 = *v10;
        uint64_t v19 = *(v10 - 1);
        uint64_t v20 = *(v10 - 2);
        uint64_t v21 = "true";
        if ((*(v10 - 7) & 1) == 0) {
          uint64_t v21 = "false";
        }
        uint64_t v32 = v21;
        if (v11 >= 0xF) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend mode", v3, v4, v5, v6, v7, v8, (uint64_t)"blend < kCFXBlendFactorCount");
        }
        uint64_t v22 = off_1E6143258[v11];
        if (v13 >= 5) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend operation", v3, v4, v5, v6, v7, v8, (uint64_t)"blendOp < kCFXBlendOpCount");
        }
        uint64_t v23 = off_1E61432D0[v13];
        if (v12 >= 0xF) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend mode", v3, v4, v5, v6, v7, v8, (uint64_t)"blend < kCFXBlendFactorCount");
        }
        uint64_t v24 = off_1E6143258[v12];
        if (v20 >= 0xF) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend mode", v3, v4, v5, v6, v7, v8, (uint64_t)"blend < kCFXBlendFactorCount");
        }
        uint64_t v25 = off_1E6143258[v20];
        if (v18 >= 5) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend operation", v3, v4, v5, v6, v7, v8, (uint64_t)"blendOp < kCFXBlendOpCount");
        }
        uint64_t v26 = off_1E61432D0[v18];
        if (v19 >= 0xF) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend mode", v3, v4, v5, v6, v7, v8, (uint64_t)"blend < kCFXBlendFactorCount");
        }
        uint64_t v29 = v25;
        CFDictionaryRef Mutable = theString;
        CFStringAppendFormat(theString, 0, @"  blend:%s col[(src * %@) %@ (dst * %@)] alpha[(src * %@) %@ (dst * %@)]\n", v32, v22, v23, v24, v29, v26, off_1E6143258[v19]);
        a1 = v31;
      }
      else
      {
        uint64_t v14 = Mutable;
        if (*(v10 - 7)) {
          uint64_t v15 = "true";
        }
        else {
          uint64_t v15 = "false";
        }
        if (v11 >= 0xF) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend mode", v3, v4, v5, v6, v7, v8, (uint64_t)"blend < kCFXBlendFactorCount");
        }
        uint64_t v16 = off_1E6143258[v11];
        if (v13 >= 5) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend operation", v3, v4, v5, v6, v7, v8, (uint64_t)"blendOp < kCFXBlendOpCount");
        }
        uint64_t v17 = off_1E61432D0[v13];
        if (v12 >= 0xF) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. bad blend mode", v3, v4, v5, v6, v7, v8, (uint64_t)"blend < kCFXBlendFactorCount");
        }
        uint64_t v28 = v15;
        CFDictionaryRef Mutable = v14;
        CFStringAppendFormat(v14, 0, @"  blend:%s col[(src * %@) %@ (dst * %@)]\n", v28, v16, v17, off_1E6143258[v12]);
      }
      ++v9;
      v10 += 8;
    }
    while (v9 < *(void *)(a1 + 48));
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

void sub_1B64E3E18(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64E3E2C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v18 = sub_1B644558C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v8 || (uint64_t v8 = (uint64_t)sub_1B6446564(a2, v11, v12, v13, v14, v15, v16, v17)) != 0)
  {
    CFDictionaryRef v19 = sub_1B64A3B48(v8, v11, v12, v13, v14, v15, v16, v17);
    if (v19)
    {
      uint64_t v27 = (uint64_t)v19;
      int v28 = sub_1B6446A8C((uint64_t)a2, v20, v21, v22, v23, v24, v25, v26);
      *(unsigned char *)a1 = sub_1B649BF98(v27, v29, v30, v31, v32, v33, v34, v35);
      char v43 = sub_1B64B2D5C(v18, v36, v37, v38, v39, v40, v41, v42);
      if (v28 == 3) {
        char v51 = 0;
      }
      else {
        char v51 = v43;
      }
      if (v28 == 1) {
        char v51 = 0;
      }
      *(unsigned char *)(a1 + 2) = v51;
      *(unsigned char *)(a1 + 3) = sub_1B649B4B8(v27, v44, v45, v46, v47, v48, v49, v50);
      *(unsigned char *)(a1 + 4) = sub_1B649B788(v27, v52, v53, v54, v55, v56, v57, v58);
      *(unsigned char *)(a1 + 5) = sub_1B649B548(v27, v59, v60, v61, v62, v63, v64, v65);
      *(unsigned char *)(a1 + 1) = sub_1B649B668(v27, v66, v67, v68, v69, v70, v71, v72);
      *(unsigned char *)(a1 + 6) = sub_1B649BA58(v27, v73, v74, v75, v76, v77, v78, v79);
      *(unsigned char *)(a1 + 7) = sub_1B649BB78(v27, v80, v81, v82, v83, v84, v85, v86);
      *(void *)(a1 + 16) = v8;
    }
  }
  return a1;
}

uint64_t sub_1B64E3F24(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  int8x16_t v10 = (const void *)*((void *)a3 + 2);
  if (v10 || (int8x16_t v10 = sub_1B6446564(a2, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0)
  {
    CFDictionaryRef v11 = sub_1B64A3B48((uint64_t)v10, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (v11)
    {
      uint64_t v19 = (uint64_t)v11;
      int v20 = *a3;
      if (*a3) {
        char v21 = sub_1B649B5D8((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18);
      }
      else {
        char v21 = 0;
      }
      if (sub_1B649B938(v19, v12, v13, v14, v15, v16, v17, v18)) {
        BOOL v29 = sub_1B649AAE0(v19, v22, v23, v24, v25, v26, v27, v28) != 0;
      }
      else {
        BOOL v29 = 0;
      }
      if (v20) {
        BOOL v30 = v29;
      }
      else {
        BOOL v30 = 0;
      }
      if (a3[1]) {
        BOOL v31 = a3[7] == 0;
      }
      else {
        BOOL v31 = 0;
      }
      unsigned __int8 v32 = a3[3];
      char v33 = sub_1B649B818(v19, v22, v23, v24, v25, v26, v27, v28);
      char v41 = sub_1B649B6F8(v19, v34, v35, v36, v37, v38, v39, v40);
      char v75 = sub_1B649B8A8(v19, v42, v43, v44, v45, v46, v47, v48);
      unsigned __int8 v76 = v32;
      char v77 = v33;
      if (sub_1B649B788(v19, v49, v50, v51, v52, v53, v54, v55)) {
        BOOL v63 = a3[7] == 0;
      }
      else {
        BOOL v63 = 0;
      }
      char v71 = v41;
      BOOL v72 = (sub_1B649B9C8(v19, v56, v57, v58, v59, v60, v61, v62) & 1) != 0
         || sub_1B649AF40(v19, v64, v65, v66, v67, v68, v69, v70) != 0;
      char v73 = sub_1B649BB78(v19, v64, v65, v66, v67, v68, v69, v70);
      *(unsigned char *)a1 = v20;
      *(unsigned char *)(a1 + 1) = v21;
      *(unsigned char *)(a1 + 2) = v30;
      *(unsigned char *)(a1 + 3) = v31;
      *(unsigned char *)(a1 + 4) = a3[5];
      *(unsigned char *)(a1 + 5) = v76;
      *(unsigned char *)(a1 + 6) = v63;
      *(unsigned char *)(a1 + 7) = v77;
      *(unsigned char *)(a1 + 8) = v72;
      *(unsigned char *)(a1 + 9) = v71;
      *(unsigned char *)(a1 + 10) = v75;
      *(unsigned char *)(a1 + 11) = v73;
      *(void *)(a1 + 16) = v19;
    }
  }
  return a1;
}

BOOL sub_1B64E40C8(unsigned char *a1)
{
  return *a1 || a1[1] || a1[2] || a1[3] || a1[5] || a1[7] || a1[8] || a1[9] || a1[10] || a1[6] || a1[11] != 0;
}

void sub_1B64E4130(uint64_t *a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = (void *)sub_1B6445900((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  int v20 = *(const void **)(a2 + 16);
  if (v20 || (int v20 = sub_1B6446564(a1, v12, v13, v14, v15, v16, v17, v18)) != 0)
  {
    CFDictionaryRef v21 = sub_1B64A3B48((uint64_t)v20, v12, v13, v14, v15, v16, v17, v18);
    if (v21)
    {
      uint64_t v29 = (uint64_t)v21;
      int32x2_t v251 = *(int32x2_t *)(a2 + 8);
      *(_OWORD *)(a4 + 224) = 0u;
      *(_OWORD *)(a4 + 240) = 0u;
      *(_OWORD *)(a4 + 192) = 0u;
      *(_OWORD *)(a4 + 208) = 0u;
      *(_OWORD *)(a4 + 160) = 0u;
      *(_OWORD *)(a4 + 176) = 0u;
      *(_OWORD *)(a4 + 128) = 0u;
      *(_OWORD *)(a4 + 144) = 0u;
      *(_OWORD *)(a4 + 96) = 0u;
      *(_OWORD *)(a4 + 112) = 0u;
      *(_OWORD *)(a4 + 64) = 0u;
      *(_OWORD *)(a4 + 80) = 0u;
      *(_OWORD *)(a4 + 32) = 0u;
      *(_OWORD *)(a4 + 48) = 0u;
      *(_OWORD *)a4 = 0u;
      *(_OWORD *)(a4 + 16) = 0u;
      float v30 = 1.0;
      if (a3[1])
      {
        uint64_t v31 = sub_1B649A9C8((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28);
        if (v31)
        {
          float v32 = sub_1B6529330(v31, v22, v23, v24, v25, v26, v27, v28);
          float v30 = exp2f(v32);
        }
      }
      *(float *)(a4 + 28) = v30;
      if ((sub_1B649B938(v29, v22, v23, v24, v25, v26, v27, v28) & 1) != 0
        && (uint64_t v40 = sub_1B649AAE0(v29, v33, v34, v35, v36, v37, v38, v39)) != 0
        && a3[2])
      {
        sub_1B652A820(v40, v41, v42, v43, v44, v45, v46, (uint64_t)v252);
      }
      else
      {
        sub_1B652A7EC((uint64_t)v252);
      }
      long long v54 = v252[2];
      *(_OWORD *)(a4 + 196) = v252[3];
      long long v55 = v252[5];
      *(_OWORD *)(a4 + 212) = v252[4];
      *(_OWORD *)(a4 + 228) = v55;
      *(_DWORD *)(a4 + 244) = v253;
      long long v56 = v252[1];
      *(_OWORD *)(a4 + 148) = v252[0];
      *(_OWORD *)(a4 + 164) = v56;
      *(_OWORD *)(a4 + 180) = v54;
      uint64_t v57 = sub_1B649ABF8(v29, v47, v48, v49, v50, v51, v52, v53);
      if (v57) {
        float v65 = sub_1B6529330(v57, v58, v59, v60, v61, v62, v63, v64);
      }
      else {
        float v65 = 0.0;
      }
      *(float *)a4 = v65;
      if (a3[9] && (uint64_t v66 = sub_1B649AD10(v29, v58, v59, v60, v61, v62, v63, v64)) != 0)
      {
        uint64_t v67 = v66;
        *(float *)(a4 + 4) = fminf(fmaxf(sub_1B6529330(v66, v58, v59, v60, v61, v62, v63, v64), 0.0), 1.0);
        float v68 = vdiv_f32((float32x2_t)vdup_lane_s32(v251, 1), (float32x2_t)v251).f32[0];
        *(float *)(a4 + 16) = v68
                            + (float)(fminf(fmaxf(sub_1B6529878(v67, v69, v70, v71, v72, v73, v74, v75), 0.0), 1.0)
                                    * (float)(1.0 - v68));
        *(float *)(a4 + 8) = fminf(fmaxf(1.0 - sub_1B65299B8(v67, v76, v77, v78, v79, v80, v81, v82), 0.0), 1.0);
        float v90 = sub_1B6529CA8(v67, v83, v84, v85, v86, v87, v88, v89);
      }
      else
      {
        *(_DWORD *)(a4 + 16) = 1065353216;
        *(_DWORD *)(a4 + 4) = 0;
        *(_DWORD *)(a4 + 8) = 0;
        float v90 = 0.0;
      }
      *(float *)(a4 + 12) = v90;
      if (a3[7] && (uint64_t v91 = sub_1B649B058(v29, v58, v59, v60, v61, v62, v63, v64)) != 0)
      {
        uint64_t v92 = v91;
        *(float *)(a4 + 20) = sub_1B6529878(v91, v58, v59, v60, v61, v62, v63, v64);
        float v100 = sub_1B6529330(v92, v93, v94, v95, v96, v97, v98, v99);
      }
      else
      {
        *(_DWORD *)(a4 + 20) = 0;
        float v100 = 0.0;
      }
      *(float *)(a4 + 24) = v100;
      if (sub_1B649B9C8(v29, v58, v59, v60, v61, v62, v63, v64)
        && (uint64_t v108 = sub_1B649AF40(v29, (uint64_t)v101, v102, v103, v104, v105, v106, v107)) != 0)
      {
        uint64_t v109 = (__n128 *)v108;
        *(float *)(a4 + 32) = fminf(fmaxf(sub_1B6529330(v108, (uint64_t)v101, v102, v103, v104, v105, v106, v107), 0.00000011921), 2.0);
        *(float *)(a4 + 36) = fminf(fmaxf(sub_1B6529878((uint64_t)v109, v110, v111, v112, v113, v114, v115, v116), 0.00000011921), 2.0);
        *(float *)v124.i32 = sub_1B652AE6C((uint64_t)v109, v117, v118, v119, v120, v121, v122, v123);
        float32x4_t v246 = vaddq_f32((float32x4_t)sub_1B652ADCC(v109, v125, v126, v127, v128, v129, v130, v131), (float32x4_t)vdupq_lane_s32(v124, 0));
        float32x4_t v139 = vmulq_f32((float32x4_t)sub_1B652ADCC(v109, v132, v133, v134, v135, v136, v137, v138), (float32x4_t)xmmword_1B6E51B70);
        *(float32x4_t *)(a4 + 64) = vsubq_f32(v246, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 2), vaddq_f32(v139, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v139.f32, 1))), 0));
        *(float *)v147.i32 = sub_1B652B3B4((uint64_t)v109, v140, v141, v142, v143, v144, v145, v146) + 1.0;
        float32x4_t v247 = vaddq_f32((float32x4_t)sub_1B652B314(v109, v148, v149, v150, v151, v152, v153, v154), (float32x4_t)vdupq_lane_s32(v147, 0));
        float32x4_t v162 = vmulq_f32((float32x4_t)sub_1B652B314(v109, v155, v156, v157, v158, v159, v160, v161), (float32x4_t)xmmword_1B6E51B70);
        *(float32x4_t *)(a4 + 80) = vsubq_f32(v247, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v162, 2), vaddq_f32(v162, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v162.f32, 1))), 0));
        *(float *)v170.i32 = sub_1B652B4F8((uint64_t)v109, v163, v164, v165, v166, v167, v168, v169) + 1.0;
        float32x4_t v248 = vaddq_f32((float32x4_t)sub_1B652B458(v109, v171, v172, v173, v174, v175, v176, v177), (float32x4_t)vdupq_lane_s32(v170, 0));
        char v185 = 0;
        float32x4_t v186 = vmulq_f32((float32x4_t)sub_1B652B458(v109, v178, v179, v180, v181, v182, v183, v184), (float32x4_t)xmmword_1B6E51B70);
        *(float32x4_t *)(a4 + 96) = vsubq_f32(v248, (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v186, 2), vaddq_f32(v186, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v186.f32, 1))), 0));
      }
      else
      {
        uint64_t v109 = 0;
        __asm { FMOV            V0.2S, #1.0 }
        *(void *)(a4 + 32) = _D0;
        __asm { FMOV            V1.4S, #1.0 }
        *(_OWORD *)(a4 + 64) = 0u;
        *(_OWORD *)(a4 + 80) = _Q1;
        *(_OWORD *)(a4 + 96) = _Q1;
        char v185 = 1;
      }
      if (a3[10]) {
        uint64_t v193 = sub_1B649A8B0(v29, (uint64_t)v101, v102, v103, v104, v105, v106, v107);
      }
      else {
        uint64_t v193 = 0;
      }
      objc_msgSend_renderTime(v19, v101, v102, v103);
      double v202 = 30.0;
      float v203 = floor(v201 * 30.0);
      if (v193)
      {
        *(float *)v213.i32 = sub_1B6529878(v193, v194, v195, v196, v197, v198, v199, v200);
        float v211 = 0.0039062 / *(float *)v213.i32;
        BOOL v212 = *(float *)v213.i32 <= 0.0039062;
        v213.i32[0] = 1.0;
        if (!v212) {
          *(float *)v213.i32 = v211;
        }
        int32x2_t v250 = v213;
        float v214 = sub_1B6529330(v193, v204, v205, v206, v207, v208, v209, v210);
      }
      else
      {
        float v214 = 0.0;
        LODWORD(v202) = 998244352;
        int32x2_t v250 = *(int32x2_t *)&v202;
      }
      *(float *)(a4 + 112) = v214;
      float v249 = sinf((float)(v203 * 0.1) + 0.05);
      v222.f32[0] = sinf(v203 * 0.01);
      v222.f32[1] = v249;
      float32x2_t v223 = vmul_f32(v222, (float32x2_t)vdup_n_s32(0x45849000u));
      *(int32x2_t *)&long long v224 = vdup_lane_s32(v250, 0);
      *((float32x2_t *)&v224 + 1) = vminnm_f32(vsub_f32(v223, vrndm_f32(v223)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
      *(_OWORD *)(a4 + 128) = v224;
      if (v193) {
        char v225 = sub_1B652991C(v193, v215, v216, v217, v218, v219, v220, v221);
      }
      else {
        char v225 = 0;
      }
      *(unsigned char *)(a4 + 116) = v225;
      if ((v185 & 1) == 0
        && (sub_1B65299B8((uint64_t)v109, v215, v216, v217, v218, v219, v220, v221) != 0.0
         || sub_1B6529CA8((uint64_t)v109, v215, v216, v217, v218, v219, v220, v221) != 0.0))
      {
        float v226 = sub_1B65299B8((uint64_t)v109, v215, v216, v217, v218, v219, v220, v221) * -0.1 + 0.31271;
        float v234 = v226 * -3.0 * v226
             + v226 * 2.87
             + -0.275
             + sub_1B6529CA8((uint64_t)v109, v227, v228, v229, v230, v231, v232, v233) * 0.1;
        float v235 = v226 / v234;
        float v236 = (1.0 - v226 - v234) / v234;
        *(float32x4_t *)(a4 + 48) = vdivq_f32((float32x4_t)xmmword_1B6E51BB0, vmlaq_n_f32(vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E51B80, v235), (float32x4_t)xmmword_1B6E51B90), (float32x4_t)xmmword_1B6E51BA0, v236));
        *(unsigned char *)(a4 + 40) = 1;
      }
      if (a3[6])
      {
        uint64_t v244 = sub_1B649AE28(v29, v215, v216, v217, v218, v219, v220, v221);
        if (!v244) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v238, v239, v240, v241, v242, v243, (uint64_t)"lensBlur");
        }
        float v245 = sub_1B6529330(v244, v237, v238, v239, v240, v241, v242, v243) * 0.01 * *(float *)&v251.i32[1];
        *(float *)(a4 + 144) = v245;
      }
    }
  }
}

uint64_t sub_1B64E4734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &qword_1E9DDB000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB0D0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v16 = a2;
    uint64_t v17 = a3;
    int v15 = __cxa_guard_acquire(&qword_1E9DDB0D0);
    uint64_t v8 = &qword_1E9DDB000;
    a2 = v16;
    a3 = v17;
    if (v15)
    {
      byte_1E9DDB0C8 = 1;
      __cxa_guard_release(&qword_1E9DDB0D0);
      uint64_t v8 = &qword_1E9DDB000;
      a2 = v16;
      a3 = v17;
    }
  }
  if (*((unsigned char *)v8 + 200)) {
    uint64_t v9 = 0x8D0488668FE8A629;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v9, 0);
  *(void *)a1 = &unk_1F0FB3408;
  long long v10 = *(_OWORD *)(a5 + 40);
  long long v11 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 384) = *(_OWORD *)(a5 + 24);
  *(_OWORD *)(a1 + 400) = v10;
  *(_OWORD *)(a1 + 416) = v11;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  CFX::RG::TextureDescriptorReference::finalColor((uint64_t)v18);
  float v12 = sub_1B6447C30(*(void *)(a1 + 368));
  CFX::RG::TextureDescriptorReference::withSizeFactor(v18, v12, v19);
  uint64_t v13 = sub_1B63CFDE4(a4, (uint64_t)"COMPOSITING OUTPUT", v19);
  *(void *)(a1 + 472) = v13;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v13, 0x100000000, 0);
  return a1;
}

void sub_1B64E486C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B64E4884(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  prof_beginFlame((uint64_t)"Composite", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/CompositePass.mm", 252);
  uint64_t v83 = (void *)sub_1B6445900(*(void *)(a1 + 368), v3, v4, v5, v6, v7, v8, v9);
  uint64_t v82 = objc_msgSend_resourceManager(v83, v10, v11, v12);
  unint64_t v13 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v14 = CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 472));
  uint64_t v85 = *(unsigned __int8 *)(v14 + 9);
  uint64_t v84 = *(void *)(v14 + 16);
  uint64_t v15 = *(unsigned __int8 *)(a1 + 413);
  uint64_t v16 = *(unsigned __int8 *)(a1 + 411);
  uint64_t v17 = *(unsigned __int8 *)(a1 + 414);
  uint64_t v18 = *(unsigned __int8 *)(a1 + 415);
  uint64_t v19 = *(unsigned __int8 *)(a1 + 417);
  uint64_t v20 = *(unsigned __int8 *)(a1 + 418);
  uint64_t v21 = *(unsigned __int8 *)(a1 + 416);
  uint64_t v22 = *(void *)(a1 + 424);
  if ((sub_1B649B938(v22, v23, v24, v25, v26, v27, v28, v29) & 1) != 0
    && (uint64_t v37 = sub_1B649AAE0(v22, v30, v31, v32, v33, v34, v35, v36)) != 0)
  {
    unsigned int v45 = sub_1B652A278(v37, v38, v39, v40, v41, v42, v43, v44);
  }
  else
  {
    unsigned int v45 = 2;
  }
  unint64_t v46 = 0x9DDFEA08EB382D69
      * (v13 ^ ((0x9DDFEA08EB382D69 * (v84 ^ v13)) >> 47) ^ (0x9DDFEA08EB382D69 * (v84 ^ v13)));
  unint64_t v47 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v46 ^ (v46 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v46 ^ (v46 >> 47))) ^ v85)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v46 ^ (v46 >> 47))) ^ v85)));
  unint64_t v48 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v47 ^ (v47 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v47 ^ (v47 >> 47))) ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v47 ^ (v47 >> 47))) ^ v15)));
  unint64_t v49 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v48 ^ (v48 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v48 ^ (v48 >> 47))) ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v48 ^ (v48 >> 47))) ^ v16)));
  unint64_t v50 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v49 ^ (v49 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v49 ^ (v49 >> 47))) ^ v17)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v49 ^ (v49 >> 47))) ^ v17)));
  unint64_t v51 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ v18)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ v18)));
  unint64_t v52 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47))) ^ v19)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47))) ^ v19)));
  unint64_t v53 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47))) ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47))) ^ v20)));
  unint64_t v54 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v53 ^ (v53 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v53 ^ (v53 >> 47))) ^ v21)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v53 ^ (v53 >> 47))) ^ v21)));
  unint64_t v55 = 0x9DDFEA08EB382D69 * (v54 ^ (v54 >> 47));
  v106[0] = v45;
  uint64_t v56 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v45)))) ^ ((0x9DDFEA08EB382D69 * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v45)))) >> 47));
  uint64_t v57 = CFX::CrossFrameResourceManager::get(a2[4], v56);
  *(void *)(a1 + 432) = v57;
  if (!v57)
  {
    *(void *)(a1 + 432) = sub_1B64E4C60(a2[4], v56);
    id v58 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v59, a1 + 413, 53, 0);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v60, a1 + 411, 53, 1);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v61, a1 + 414, 53, 2);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v62, a1 + 415, 53, 3);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v63, a1 + 417, 53, 4);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v64, a1 + 418, 53, 5);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v65, a1 + 416, 53, 6);
    objc_msgSend_setConstantValue_type_atIndex_(v58, v66, (uint64_t)v106, 49, 7);
    uint64_t v67 = *(void *)(a1 + 432);
    memset(v87, 0, sizeof(v87));
    uint64_t v88 = 0;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    uint64_t v100 = 0;
    uint64_t v102 = 0;
    long long v104 = 0u;
    uint64_t v105 = 0;
    float v68 = (void *)sub_1B653EFAC((uint64_t)v82);
    uint64_t v89 = objc_msgSend_frameworkLibrary(v68, v69, v70, v71);
    *(void *)&long long v90 = v84;
    LOBYTE(v95) = v85;
    id v101 = v58;
    uint64_t v103 = @"vfx_draw_fullscreen_triangle_vertex";
    *(void *)&long long v104 = @"vfx_post_process";
    uint64_t v74 = objc_msgSend_newRenderPipelineStateWithDesc_(v82, v72, (uint64_t)v87, v73);
    uint64_t v75 = *(void **)(v67 + 16);
    if (v75 != (void *)v74)
    {
      if (v75) {

      }
      *(void *)(v67 + 16) = v74;
    }
  }
  uint64_t v76 = sub_1B63BE7D8(v83, a2[4]);
  uint64_t v77 = *(void *)(a1 + 432);
  *(void *)(v77 + 24) = v76;
  sub_1B64E4130(*(uint64_t **)(a1 + 368), a1 + 384, (unsigned char *)(a1 + 408), v77 + 32, v78, v79, v80, v81);
  prof_endFlame();
}

void sub_1B64E4C38(_Unwind_Exception *a1)
{
}

uint64_t sub_1B64E4C60(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B64E4D0C(uint64_t a1, uint64_t a2)
{
  prof_beginFlame((uint64_t)"Composite", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/CompositePass.mm", 309);
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), v4, v5, v6, v7, v8, v9, v10);
  uint64_t v22 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  uint64_t v23 = *(void *)(a1 + 432);
  uint64_t v24 = *(void **)(v23 + 16);
  if (!v24)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v16, v17, v18, v19, v20, v21, (uint64_t)"_ptr != NULL");
    uint64_t v24 = *(void **)(v23 + 16);
  }
  uint64_t v25 = objc_msgSend_state(v24, v15, v16, v17);
  objc_msgSend_setRenderPipelineState_(*(void **)(v22 + 16), v26, v25, v27);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 440));
  sub_1B63C6ED0(v22, Texture, 0, v29);
  sub_1B63C6ED0(v22, *(void **)(*(void *)(a1 + 432) + 24), 3, v30);
  if (*(unsigned char *)(a1 + 413))
  {
    id v31 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 448));
    sub_1B63C6ED0(v22, v31, 2, v32);
  }
  if (*(unsigned char *)(a1 + 411))
  {
    id v33 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 456));
    sub_1B63C6ED0(v22, v33, 1, v34);
  }
  if (*(unsigned char *)(a1 + 414))
  {
    id v35 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 464));
    sub_1B63C6ED0(v22, v35, 4, v36);
  }
  uint64_t v37 = (const void *)(*(void *)(a1 + 432) + 32);
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  sub_1B649F334(*(void *)(v22 + 24), v37, 0x100uLL, &v40);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v22 + 16), v38, v41, v42, 0);
  sub_1B63C6F54(v22, v39);
  prof_endFlame();
}

void sub_1B64E4E7C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1B64E4EA0(uint64_t *this, CFX::RG::Resource *a2)
{
  this[55] = (uint64_t)a2;
  return CFX::RG::Pass::readFrom(this, a2);
}

uint64_t *sub_1B64E4EA8(uint64_t *this, CFX::RG::Resource *a2)
{
  this[56] = (uint64_t)a2;
  return CFX::RG::Pass::readFrom(this, a2);
}

uint64_t *sub_1B64E4EB0(uint64_t *this, CFX::RG::Resource *a2)
{
  this[57] = (uint64_t)a2;
  return CFX::RG::Pass::readFrom(this, a2);
}

uint64_t *sub_1B64E4EB8(uint64_t *this, CFX::RG::Resource *a2)
{
  this[58] = (uint64_t)a2;
  return CFX::RG::Pass::readFrom(this, a2);
}

uint64_t sub_1B64E4EC0(uint64_t *a1, uint64_t *a2, long long *a3, long long *a4)
{
  uint64_t v4 = *a2;
  v6[0] = "Composite";
  v6[1] = v4;
  __int16 v7 = 0;
  long long v8 = *a3;
  uint64_t v9 = *((void *)a3 + 2);
  long long v10 = *a4;
  uint64_t v11 = *((void *)a4 + 2);
  return sub_1B64E4F1C(a1, a1, (uint64_t)v6);
}

uint64_t sub_1B64E4F1C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64E5068(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B64E4F78(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B64E4FB0(void *a1)
{
  *a1 = &unk_1F0FB33E8;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B64E4FFC(void *a1)
{
  *a1 = &unk_1F0FB33E8;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B64E5068(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1E0u, 8u);
  return sub_1B64E4734(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64E5238(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v4 = objc_msgSend_model(a2, (const char *)a2, a3, a4);
  obuint64_t j = (id)objc_msgSend_materials(v4, v5, v6, v7);
  uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v8, (uint64_t)&v33, (uint64_t)v38, 16);
  uint64_t v28 = result;
  if (result)
  {
    uint64_t v27 = *(void *)v34;
    do
    {
      uint64_t v13 = 0;
      do
      {
        if (*(void *)v34 != v27) {
          objc_enumerationMutation(obj);
        }
        uint64_t v14 = *(void **)(*((void *)&v33 + 1) + 8 * v13);
        long long v29 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        uint64_t v15 = objc_msgSend_properties(v14, v10, v11, v12);
        uint64_t v17 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v16, (uint64_t)&v29, (uint64_t)v37, 16);
        if (v17)
        {
          uint64_t v18 = v17;
          uint64_t v19 = *(void *)v30;
          do
          {
            for (uint64_t i = 0; i != v18; ++i)
            {
              if (*(void *)v30 != v19) {
                objc_enumerationMutation(v15);
              }
              uint64_t v21 = *(void **)(*((void *)&v29 + 1) + 8 * i);
              uint64_t v22 = objc_msgSend_contents(v21, v10, v11, v12);
              objc_opt_class();
              if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_respondsToSelector())
              {
                uint64_t v23 = objc_msgSend_filename(v22, v10, v11, v12);
                objc_msgSend_setContents_(v21, v24, v23, v25);
              }
            }
            uint64_t v18 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v10, (uint64_t)&v29, (uint64_t)v37, 16);
          }
          while (v18);
        }
        ++v13;
      }
      while (v13 != v28);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v10, (uint64_t)&v33, (uint64_t)v38, 16);
      uint64_t v28 = result;
    }
    while (result);
  }
  return result;
}

void sub_1B64E57E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B64E5800(uint64_t a1, uint64_t a2)
{
}

void sub_1B64E5810(uint64_t a1)
{
}

uint64_t sub_1B64E581C(uint64_t a1, void *a2, unsigned char *a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_camera(a2, (const char *)a2, (uint64_t)a3, a4);
  if (result == *(void *)(a1 + 32))
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = a2;
    *a3 = 1;
  }
  return result;
}

unint64_t sub_1B64E58F0(void *a1)
{
  uint64_t v2 = sub_1B64D7C2C(0);
  objc_msgSend_setPixelFormat_(a1, v3, v2, v4);
  objc_msgSend_setFramebufferOnly_(a1, v5, 1, v6);
  unint64_t result = objc_msgSend_maximumDrawableCount(a1, v7, v8, v9);
  if (result >= 3)
  {
    return MEMORY[0x1F4181798](a1, sel_setFenceEnabled_, 1, v11);
  }
  return result;
}

uint64_t sub_1B64E669C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__setNeedsDisplay(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B64E6BE8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__drawAtTime_(*(void **)(a1 + 32), a2, a3, a4, *(double *)(a1 + 40));
}

uint64_t sub_1B64E7DB0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)(a1 + 32);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  void v10[2] = sub_1B64E7E38;
  v10[3] = &unk_1E6143238;
  long long v11 = *(_OWORD *)(a1 + 40);
  objc_msgSend_performAsCurrentTraitCollection_(v5, a2, (uint64_t)v10, a4);
  return objc_msgSend__setNeedsDisplay(*(void **)(a1 + 40), v6, v7, v8);
}

uint64_t sub_1B64E7E38(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_setBackgroundColor_(*(void **)(*(void *)(a1 + 32) + 440), a2, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B64E7F30(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)(a1 + 32);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  void v10[2] = sub_1B64E7FD0;
  v10[3] = &unk_1E61422C0;
  void v10[4] = *(void *)(a1 + 40);
  objc_msgSend_performAsCurrentTraitCollection_(v5, a2, (uint64_t)v10, a4);
  *(unsigned char *)(*(void *)(a1 + 40) + 424) |= 0x40u;
  return objc_msgSend__setNeedsDisplay(*(void **)(a1 + 40), v6, v7, v8);
}

uint64_t sub_1B64E7FD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(a1 + 32) + 440), sel_resolvedBackgroundColorDidChange, a3, a4);
}

MTLCommandQueue *__cdecl sub_1B64E807C(VFXView *self, SEL a2)
{
  return (MTLCommandQueue *)objc_msgSend_commandQueue(self->_renderer, a2, v2, v3);
}

void sub_1B64E8304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B64E8328(uint64_t a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  uint64_t v3[2] = sub_1B64E83C0;
  v3[3] = &unk_1E6143490;
  objc_copyWeak(&v4, (id *)(a1 + 32));
  v3[4] = a2;
  dispatch_async(MEMORY[0x1E4F14428], v3);
  objc_destroyWeak(&v4);
}

id sub_1B64E83C0(uint64_t a1)
{
  id result = objc_loadWeak((id *)(a1 + 40));
  if (result)
  {
    uint64_t v7 = result;
    *(float *)&double v6 = (float)*((uint64_t *)result + 59);
    objc_msgSend_setPreferredFrameRate_(*(void **)(a1 + 32), v3, v4, v5, v6);
    objc_msgSend_setDisplayLink_(v7, v8, *(void *)(a1 + 32), v9);
    return (id)objc_msgSend__setNeedsDisplay(v7, v10, v11, v12);
  }
  return result;
}

uint64_t sub_1B64E86CC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__setNeedsDisplay(*(void **)(a1 + 32), a2, a3, a4);
}

BOOL sub_1B64E8A74(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_camera(a2, (const char *)a2, a3, a4) != 0;
}

void sub_1B64E8C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

float sub_1B64E8C94(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  double v3 = Current - Current;
  double v4 = 0.0;
  if (Current - Current < *(double *)(a1 + 48))
  {
    int v5 = 0;
    do
    {
      double v6 = (void *)MEMORY[0x1BA9B76E0]();
      objc_msgSend__drawAtTime_(*(void **)(a1 + 32), v7, v8, v9, 0.0);
      ++v5;
      double v3 = CFAbsoluteTimeGetCurrent() - Current;
    }
    while (v3 < *(double *)(a1 + 48));
    double v4 = (double)v5;
  }
  float result = v4 / v3;
  *(float *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t sub_1B64E8EFC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 424) |= 8u;
  return objc_msgSend__drawAtTime_(*(void **)(a1 + 32), a2, a3, a4, 0.0);
}

uint64_t sub_1B64E9A2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v31 = a2;
  *((void *)&v31 + 1) = a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB0E8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v17 = a2;
    uint64_t v18 = a3;
    int v16 = __cxa_guard_acquire(&qword_1E9DDB0E8);
    a2 = v17;
    a3 = v18;
    if (v16)
    {
      qword_1E9DDB0E0 = (uint64_t)sub_1B64EA644("IRRADIANCE_PROBE_RENDER_CUBEMAP_PASS", 0x24u);
      __cxa_guard_release(&qword_1E9DDB0E8);
      a2 = v17;
      a3 = v18;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, qword_1E9DDB0E0, 0);
  *(void *)a1 = &unk_1F0FB4E20;
  uint64_t v8 = *(void *)(a5 + 40);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 24);
  *(_WORD *)(a1 + 376) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 416) = v8;
  *(unsigned char *)(CFX::RG::Pass::commonRenderParameters(v9) + 277) = 6;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  RGTextureDescriptorMakeCube(*(_DWORD *)(a1 + 400), *(void *)(a1 + 408), (uint64_t)&v26);
  *((void *)&v28 + 1) = 5;
  v25[0] = v26;
  v25[1] = v27;
  v25[3] = v29;
  v25[4] = v30;
  v25[2] = v28;
  long long v10 = sub_1B63C7D8C(a4, (uint64_t)"IRRADIANCE_PROBE_CUBEMAP_COLOR_TARGET", (uint64_t)v25);
  *(void *)(a1 + 424) = v10;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v10, 0x100000002, 0);
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  RGTextureDescriptorMakeCube(*(_DWORD *)(a1 + 400), 252, (uint64_t)&v20);
  *((void *)&v28 + 1) = 4;
  void v19[2] = v22;
  v19[3] = v23;
  v19[4] = v24;
  v19[0] = v20;
  v19[1] = v21;
  uint64_t v11 = sub_1B63C7D8C(a4, (uint64_t)"IRRADIANCE_PROBE_CUBEMAP_DEPTH_TARGET", (uint64_t)v19);
  *(void *)(a1 + 432) = v11;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v11, 0x200000002, -1);
  *(void *)&long long v32 = *(void *)(a1 + 368);
  LOBYTE(v36) = 0;
  char v37 = 0;
  uint64_t v34 = 0;
  long long v33 = 0uLL;
  long long v38 = xmmword_1B6E4FC80;
  char v39 = *(unsigned char *)(a1 + 376);
  char v40 = 2;
  uint64_t v41 = 4;
  int v42 = 1;
  __int16 v43 = 1;
  *(void *)(a1 + 384) = sub_1B63F9384(v31, *((uint64_t *)&v31 + 1), (uint64_t *)&v31, (uint64_t *)&v32, &v33);
  *(void *)&long long v33 = 0;
  WORD4(v33) = 0;
  BYTE10(v33) = *(unsigned char *)(a1 + 377);
  uint64_t v34 = 3;
  __int16 v35 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB0E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB0E8))
  {
    qword_1E9DDB0E0 = (uint64_t)sub_1B64EA644("IRRADIANCE_PROBE_RENDER_CUBEMAP_PASS", 0x24u);
    __cxa_guard_release(&qword_1E9DDB0E8);
  }
  uint64_t v36 = qword_1E9DDB0E0;
  uint64_t v12 = *(void *)(a1 + 368);
  long long v32 = v31;
  uint64_t v13 = sub_1B63C8330(&v32, 0x40u, 8u);
  sub_1B6460520(v13, v12, (uint64_t)&v33, *(void *)(a1 + 384));
  *(void *)(a1 + 392) = v14;
  return a1;
}

void sub_1B64E9D1C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B64E9D40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 384);
  *(void *)(v6 + 32) = *(void *)(a1 + 416);
  unsigned int v7 = *(_DWORD *)(a1 + 400);
  if (!*(unsigned char *)(v6 + 80)) {
    *(unsigned char *)(v6 + 80) = 1;
  }
  *(void *)&long long v8 = 0;
  *((float *)&v8 + 2) = (float)v7;
  *((float *)&v8 + 3) = (float)v7;
  *(_OWORD *)(v6 + 64) = v8;
  sub_1B65A8594(*(__n128 **)(a1 + 384), (const char *)a2, a3, a4);
  sub_1B65A88F8(*(void *)(a1 + 384), v9, v10, v11, v12, v13, v14, v15);
  sub_1B65A8D10(*(void *)(a1 + 384));
  sub_1B65A8D3C(*(void *)(a1 + 384), v16, v17, v18, v19, v20, v21, v22);
  long long v24 = *(uint64_t **)(a1 + 384);
  uint64_t v25 = *(const char **)a2;
  uint64_t v26 = *(void *)(a2 + 8);

  sub_1B65A8F34(v24, v25, v26, v23);
}

void sub_1B64E9DD0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B64E9DD8(uint64_t a1, const char *a2, uint64_t a3)
{
}

uint64_t *sub_1B64E9DE8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  long long v8 = &qword_1E9DDB000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB0F8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v16 = a2;
    uint64_t v17 = a3;
    int v15 = __cxa_guard_acquire(&qword_1E9DDB0F8);
    long long v8 = &qword_1E9DDB000;
    a2 = v16;
    a3 = v17;
    if (v15)
    {
      byte_1E9DDB0F0 = 1;
      __cxa_guard_release(&qword_1E9DDB0F8);
      long long v8 = &qword_1E9DDB000;
      a2 = v16;
      a3 = v17;
    }
  }
  if (*((unsigned char *)v8 + 240)) {
    uint64_t v9 = 0x64936801F5A4BA5BLL;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B653860C((uint64_t)a1, a2, a3, a5, v9, 0);
  *a1 = (uint64_t)&unk_1F0FB4A40;
  uint64_t v10 = a5[2];
  a1[49] = 0;
  a1[50] = 0;
  a1[48] = v10;
  RGBufferDescriptorMake();
  Buffer_0 = RGBuilderCreateBuffer_0(a4, (uint64_t)"IRRADIANCE_SH", v11, v12);
  a1[50] = (uint64_t)Buffer_0;
  CFX::RG::Pass::writeTo(a1, Buffer_0);
  return a1;
}

void sub_1B64E9F04(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

CFX::RG::Resource *RGBuilderCreateBuffer_0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[0] = a3;
  v11[1] = a4;
  uint64_t v10 = a2;
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  char v9 = 1;
  unsigned int v7 = (CFX::RG::Resource *)sub_1B64EA890(v5, v6, &v10, v11, &v9);
  CFX::RG::RenderGraphBuilder::appendResource(a1, v7);
  return v7;
}

void sub_1B64E9F7C(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned __int8 *)(a1 + 388));
  uint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  uint64_t v7 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
  *(void *)(a1 + 376) = v7;
  if (!v7)
  {
    *(void *)(a1 + 376) = sub_1B64EA0CC(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
    int v15 = (void *)sub_1B6445900(*(void *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    uint64_t v21 = objc_msgSend_resourceManager(v15, v16, v17, v18);
    if (*(unsigned char *)(a1 + 388)) {
      uint64_t v22 = objc_msgSend_stringWithFormat_(NSString, v19, @"compute_sh%d_from_cubemap_threadgroup_mem", v20, *(unsigned int *)(a1 + 384));
    }
    else {
      uint64_t v22 = objc_msgSend_stringWithFormat_(NSString, v19, @"compute_sh%d_from_cubemap", v20, *(unsigned int *)(a1 + 384));
    }
    uint64_t v25 = *(void *)(a1 + 376);
    uint64_t v26 = objc_msgSend_newComputePipelineStateWithFunctionName_(v21, v23, v22, v24);
    long long v29 = *(void **)(v25 + 16);
    if (v29 != (void *)v26)
    {
      uint64_t v30 = v26;
      if (v29) {

      }
      *(void *)(v25 + 16) = v30;
    }
    if (*(unsigned char *)(a1 + 388))
    {
      uint64_t v31 = objc_msgSend_stringWithFormat_(NSString, v27, @"sum_sh%d", v28, *(unsigned int *)(a1 + 384));
      uint64_t v32 = *(void *)(a1 + 376);
      uint64_t v35 = objc_msgSend_newComputePipelineStateWithFunctionName_(v21, v33, v31, v34);
      uint64_t v36 = *(void **)(v32 + 24);
      if (v36 != (void *)v35)
      {
        uint64_t v37 = v35;
        if (v36) {

        }
        *(void *)(v32 + 24) = v37;
      }
    }
  }
}

uint64_t sub_1B64EA0CC(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B64EA154(uint64_t a1, uint64_t a2, void **a3)
{
  unint64_t v5 = *a3;
  CFX::GPUResourceManager::getBuffer(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400), &v91);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 392));
  if (*(unsigned char *)(a1 + 388))
  {
    uint64_t v14 = (void *)sub_1B6445900(*(void *)(a1 + 368), (uint64_t)v6, v7, v8, v9, v10, v11, v12);
    unsigned int v15 = *(_DWORD *)(a1 + 384) * *(_DWORD *)(a1 + 384);
    uint64_t v19 = objc_msgSend_device(v14, v16, v17, v18);
    uint64_t v21 = objc_msgSend_newBufferWithLength_options_(v19, v20, 72 * v15, 32);
    objc_msgSend_setBuffer_offset_atIndex_(v5, v22, (uint64_t)v21, 0, 1);
    uint64_t v29 = (16 * *(_DWORD *)(a1 + 384) * *(_DWORD *)(a1 + 384));
    uint64_t v30 = *(void *)(a1 + 376);
    uint64_t v31 = *(void *)(v30 + 16);
    if (!v31)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v23, v24, v25, v26, v27, v28, (uint64_t)"_ptr != NULL");
      uint64_t v31 = *(void *)(v30 + 16);
    }
    uint64_t v32 = (void *)sub_1B653EFB8(v31);
    unint64_t v36 = objc_msgSend_threadExecutionWidth(v32, v33, v34, v35);
    unint64_t v38 = 0x7FFF / v29;
    if (v36 < v38) {
      unint64_t v38 = v36;
    }
    if (v38 >= 0x40) {
      uint64_t v39 = 64;
    }
    else {
      uint64_t v39 = v38;
    }
    objc_msgSend_setThreadgroupMemoryLength_atIndex_(v5, v37, v39 * v29, 0);
    uint64_t v46 = *(void *)(a1 + 376);
    uint64_t v47 = *(void *)(v46 + 16);
    if (!v47)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v40, v41, v42, v43, v44, v45, (uint64_t)"_ptr != NULL");
      uint64_t v47 = *(void *)(v46 + 16);
    }
    uint64_t v48 = sub_1B653EFB8(v47);
    objc_msgSend_setComputePipelineState_(v5, v49, v48, v50);
    objc_msgSend_setTexture_atIndex_(v5, v51, (uint64_t)Texture, 0);
    long long v89 = xmmword_1B6E51BE0;
    uint64_t v90 = 1;
    uint64_t v87 = v39;
    int64x2_t v88 = vdupq_n_s64(1uLL);
    objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v5, v52, (uint64_t)&v89, (uint64_t)&v87);
    uint64_t v59 = *(void *)(a1 + 376);
    uint64_t v60 = *(void *)(v59 + 24);
    if (!v60)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v53, v54, v55, v56, v57, v58, (uint64_t)"_ptr != NULL");
      uint64_t v60 = *(void *)(v59 + 24);
    }
    uint64_t v61 = sub_1B653EFB8(v60);
    objc_msgSend_setComputePipelineState_(v5, v62, v61, v63);
    objc_msgSend_setBuffer_offset_atIndex_(v5, v64, v91, v92, 0);
    int64x2_t v85 = vdupq_n_s64(1uLL);
    uint64_t v86 = 1;
    int64x2_t v83 = v85;
    uint64_t v84 = 1;
    objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v5, v65, (uint64_t)&v85, (uint64_t)&v83);
  }
  else
  {
    objc_msgSend_setBuffer_offset_atIndex_(v5, v6, v91, v92, 0);
    objc_msgSend_setTexture_atIndex_(v5, v66, (uint64_t)Texture, 0);
    uint64_t v73 = *(void *)(a1 + 376);
    uint64_t v74 = *(void *)(v73 + 16);
    if (!v74)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v67, v68, v69, v70, v71, v72, (uint64_t)"_ptr != NULL");
      uint64_t v74 = *(void *)(v73 + 16);
    }
    uint64_t v75 = sub_1B653EFB8(v74);
    objc_msgSend_setComputePipelineState_(v5, v76, v75, v77);
    uint64_t v82 = 1;
    long long v81 = xmmword_1B6E51BF0;
    uint64_t v80 = 1;
    long long v79 = xmmword_1B6E51BF0;
    objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v5, v78, (uint64_t)&v81, (uint64_t)&v79);
  }
}

uint64_t sub_1B64EA3F8@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v12 = *(void *)(a2 + 16);
  *(void *)a9 = v12;
  *(void *)(a9 + 8) = 0;
  *(void *)(a9 + 16) = a9 + 24;
  uint64_t result = sub_1B655035C(a1, v12, *(void *)a3, a4, a5, a6, a7, a8);
  uint64_t v14 = *(void *)(a3 + 8);
  if (*(_DWORD *)(v14 + 8))
  {
    uint64_t v15 = result;
    unint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(*(void *)(v14 + 16) + 8 * v16);
      uint64_t v24 = 0;
      uint64_t v18 = *(void *)a3;
      v27[0] = "Irradiance probe render cubemap pass";
      v27[1] = v18;
      __int16 v28 = 0;
      int v29 = 1024;
      uint64_t v30 = 115;
      uint64_t v31 = v17;
      uint64_t v19 = (uint64_t *)sub_1B64EA720(a1, a1, (uint64_t)v27);
      uint64_t v20 = v19;
      if (v15) {
        CFX::RG::Pass::readFrom(v19, *(CFX::RG::Resource **)(v15 + 424));
      }
      uint64_t v21 = *(void *)a3;
      v25[0] = (uint64_t)"Irradiance probe compute sh pass";
      v25[1] = v21;
      uint64_t v26 = 0x100000000;
      LODWORD(v26) = *(_DWORD *)(a3 + 16);
      uint64_t v22 = (uint64_t *)sub_1B64EA778(a1, a1, v25);
      uint64_t v23 = (CFX::RG::Resource *)v20[53];
      v22[49] = (uint64_t)v23;
      CFX::RG::Pass::readFrom(v22, v23);
      uint64_t v24 = v22;
      uint64_t result = (uint64_t)sub_1B64EA528((_DWORD *)a9, &v24);
      ++v16;
      uint64_t v14 = *(void *)(a3 + 8);
    }
    while (v16 < *(unsigned int *)(v14 + 8));
  }
  return result;
}

_DWORD *sub_1B64EA528(_DWORD *result, void *a2)
{
  double v3 = result;
  unsigned int v4 = result[2];
  unsigned int v5 = result[3];
  unsigned int v6 = v4 + 1;
  uint64_t v7 = (const void *)*((void *)result + 2);
  if (v4 + 1 > v5)
  {
    unsigned int v8 = ((double)(v5 + 1) * 1.5);
    Aligned = CStackAllocatorAllocateAligned(*(uint64_t **)result, 8 * v8, 8, 2);
    uint64_t result = memcpy(Aligned, v7, 8 * v3[2]);
    *((void *)v3 + 2) = Aligned;
    v3[3] = v8;
    unsigned int v4 = v3[2];
    unsigned int v6 = v4 + 1;
    uint64_t v7 = Aligned;
  }
  *((void *)v7 + v4) = *a2;
  uint64_t v3[2] = v6;
  return result;
}

void sub_1B64EA5D0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64EA60C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B64EA644(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0xC6A4A7935BD1E995 * a2;
    do
    {
      unint64_t v3 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * *(void *)&result[v2]) ^ ((0xC6A4A7935BD1E995 * *(void *)&result[v2]) >> 47))) ^ v3);
      v2 += 8;
    }
    while (v2 != 32);
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_11;
      case 2u:
        goto LABEL_10;
      case 3u:
        goto LABEL_9;
      case 4u:
        goto LABEL_8;
      case 5u:
        goto LABEL_7;
      case 6u:
        goto LABEL_6;
      case 7u:
        v3 ^= (unint64_t)result[38] << 48;
LABEL_6:
        v3 ^= (unint64_t)result[37] << 40;
LABEL_7:
        v3 ^= (unint64_t)result[36] << 32;
LABEL_8:
        v3 ^= (unint64_t)result[35] << 24;
LABEL_9:
        v3 ^= (unint64_t)result[34] << 16;
LABEL_10:
        v3 ^= (unint64_t)result[33] << 8;
LABEL_11:
        unint64_t v3 = 0xC6A4A7935BD1E995 * (v3 ^ result[32]);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v3 ^ (v3 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) >> 47));
  }
  return result;
}

uint64_t sub_1B64EA720(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64EA7D0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B64EA778(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = (uint64_t)sub_1B64EA830(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B64EA7D0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B8u, 8u);
  return sub_1B64E9A2C(v8, *a3, a3[1], a4, a5);
}

uint64_t *sub_1B64EA830(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = (uint64_t *)sub_1B63C8330(v10, 0x198u, 8u);
  return sub_1B64E9DE8(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64EA890(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, char *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0xE0u, 8u);
  return CFX::RG::Resource::Resource(v8, *a3, *a4, a4[1], *a5);
}

void *sub_1B64EA8F0(void *a1)
{
  *a1 = &unk_1F0FB4A20;
  uint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  unint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  return a1;
}

void sub_1B64EA948(void *a1)
{
  *a1 = &unk_1F0FB4A20;
  uint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  unint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64EA9C0(CFStringRef theString, uint64_t a2, int a3)
{
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, @"\n");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  CFMutableStringRef Mutable = CFStringCreateMutable(v5, 0);
  *(_WORD *)(a2 + 72) = 0;
  if (Count < 1) {
    goto LABEL_39;
  }
  CFIndex v9 = 0;
  int v10 = 4;
  do
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v9);
    if (sub_1B63CB778(ValueAtIndex, @"//")) {
      goto LABEL_12;
    }
    if (a3)
    {
      if (!sub_1B63CB778(ValueAtIndex, @"uniform")) {
        goto LABEL_12;
      }
      CFStringRef v12 = ValueAtIndex;
      uint64_t v13 = a2;
      char v14 = 1;
      goto LABEL_11;
    }
    if (sub_1B63CB778(ValueAtIndex, @"#pragma opaque"))
    {
      *(_WORD *)(a2 + 72) |= 1u;
      goto LABEL_12;
    }
    if (sub_1B63CB778(ValueAtIndex, @"uniform"))
    {
      CFStringRef v12 = ValueAtIndex;
      uint64_t v13 = a2;
      char v14 = 0;
LABEL_11:
      sub_1B64EAD3C(v12, v13, v14);
      goto LABEL_12;
    }
    if (sub_1B63CB778(ValueAtIndex, @"#pragma declaration"))
    {
LABEL_15:
      int v10 = 0;
    }
    else if (sub_1B63CB778(ValueAtIndex, @"#pragma arguments"))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_1F0FCDBB0);
      }
LABEL_20:
      int v10 = 1;
    }
    else if (sub_1B63CB778(ValueAtIndex, @"#pragma varyings"))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_1F0FCDBB0);
      }
LABEL_25:
      int v10 = 2;
    }
    else if (sub_1B63CB778(ValueAtIndex, @"#pragma body"))
    {
      if (v10 == 4 && CFStringGetLength(Mutable))
      {
        CFStringAppend(*(CFMutableStringRef *)a2, Mutable);
        CFStringReplaceAll(Mutable, &stru_1F0FCDBB0);
      }
LABEL_35:
      int v10 = 3;
    }
    else if (!sub_1B63CB778(ValueAtIndex, @"#pragma "))
    {
      switch(v10)
      {
        case 0:
          sub_1B64EB124(ValueAtIndex, a2);
          CFStringAppend(*(CFMutableStringRef *)a2, ValueAtIndex);
          CFStringAppend(*(CFMutableStringRef *)a2, @"\n");
          goto LABEL_15;
        case 1:
          sub_1B64EB310(ValueAtIndex, a2);
          goto LABEL_20;
        case 2:
          sub_1B64EB5E0(ValueAtIndex, a2);
          goto LABEL_25;
        case 3:
          sub_1B64EB124(ValueAtIndex, a2);
          CFStringAppend(*(CFMutableStringRef *)(a2 + 8), ValueAtIndex);
          CFStringAppend(*(CFMutableStringRef *)(a2 + 8), @"\n");
          goto LABEL_35;
        case 4:
          sub_1B64EB124(ValueAtIndex, a2);
          CFStringAppend(Mutable, ValueAtIndex);
          CFStringAppend(Mutable, @"\n");
          int v10 = 4;
          break;
        default:
          break;
      }
    }
LABEL_12:
    ++v9;
  }
  while (Count != v9);
  if (v10 == 4)
  {
LABEL_39:
    if (CFStringGetLength(Mutable))
    {
      CFStringAppend(*(CFMutableStringRef *)(a2 + 8), Mutable);
      CFStringReplaceAll(Mutable, &stru_1F0FCDBB0);
    }
  }
  CFRelease(Mutable);

  CFRelease(ArrayBySeparatingStrings);
}

void sub_1B64EAD3C(const __CFString *a1, uint64_t a2, char a3)
{
  memset(v30, 0, 240);
  CFIndex Length = CFStringGetLength(a1);
  sub_1B63CB5AC((uint64_t)v30, a1, 0, Length, 1);
  sub_1B63CB63C((uint64_t)v30);
  if (sub_1B63CBCB0((uint64_t)v30)) {
    sub_1B63CB63C((uint64_t)v30);
  }
  v31.location = sub_1B63CB644((uint64_t)v30);
  v31.length = v6;
  if (CFStringCompareWithOptions(a1, @"uniform", v31, 0))
  {
    sub_1B63F2F54(16, @"Error: syntax error in the uniform declaration : %@", v7, v8, v9, v10, v11, v12, (uint64_t)a1);
    return;
  }
  if ((a3 & 1) == 0) {
    CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, @"%@\n", a1);
  }
  if (sub_1B63CB63C((uint64_t)v30))
  {
    int v27 = 0;
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      int v13 = v27;
      if ((_WORD)v27) {
        goto LABEL_47;
      }
      if (sub_1B63CBCB0((uint64_t)v30)) {
        sub_1B63CB63C((uint64_t)v30);
      }
      v32.location = sub_1B63CB644((uint64_t)v30);
      v32.length = v14;
      CFStringRef v15 = CFStringCreateWithSubstring(alloc, a1, v32);
      int v13 = sub_1B63CA610(v15);
      CFRelease(v15);
      sub_1B63CB63C((uint64_t)v30);
      if (v13)
      {
LABEL_47:
        if (sub_1B63CBCB0((uint64_t)v30)) {
          sub_1B63CB63C((uint64_t)v30);
        }
        v33.location = sub_1B63CB644((uint64_t)v30);
        v33.length = v16;
        CFStringRef v17 = CFStringCreateWithSubstring(alloc, a1, v33);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 24), v17, (const void *)(__int16)v13);
        CFRelease(v17);
      }
      if (sub_1B63CB63C((uint64_t)v30)) {
        break;
      }
LABEL_42:
      if ((sub_1B63CB63C((uint64_t)v30) & 1) == 0) {
        return;
      }
    }
    BOOL v18 = 0;
    char v19 = 0;
    char v20 = 0;
    char v21 = 0;
    while (1)
    {
      CFIndex v23 = sub_1B63CB644((uint64_t)v30);
      CFIndex v24 = v22;
      if (v20)
      {
        v34.location = v23;
        v34.length = v22;
        if (CFStringCompareWithOptions(a1, @"/", v34, 0) == kCFCompareEqualTo)
        {
          char v25 = 0;
          char v19 = !v18;
          goto LABEL_35;
        }
        v35.location = v23;
        v35.length = v24;
        char v25 = 0;
        BOOL v18 = CFStringCompareWithOptions(a1, @"*", v35, 0) == kCFCompareEqualTo;
        char v19 = 1;
      }
      else
      {
        v36.location = v23;
        v36.length = v22;
        if (CFStringCompareWithOptions(a1, @";", v36, 0) == kCFCompareEqualTo)
        {
          sub_1B63CB63C((uint64_t)v30);
          if (sub_1B63CBCB0((uint64_t)v30)) {
            sub_1B63CB63C((uint64_t)v30);
          }
          v42.location = sub_1B63CB644((uint64_t)v30);
          v42.length = v26;
          if (CFStringCompareWithOptions(a1, @"uniform", v42, 0) == kCFCompareEqualTo)
          {
            int v27 = 0;
            goto LABEL_42;
          }
          return;
        }
        v37.location = v23;
        v37.length = v24;
        if (CFStringCompareWithOptions(a1, @"/", v37, 0) == kCFCompareEqualTo)
        {
          if (v19) {
            return;
          }
          char v19 = 0;
          BOOL v18 = 0;
          char v25 = 1;
          goto LABEL_36;
        }
        v38.location = v23;
        v38.length = v24;
        if (CFStringCompareWithOptions(a1, @"*", v38, 0))
        {
          v39.location = v23;
          v39.length = v24;
          if (CFStringCompareWithOptions(a1, @"("), v39, 0)
          {
            v40.location = v23;
            v40.length = v24;
            if (CFStringCompareWithOptions(a1, @""), v40, 0) == kCFCompareEqualTo)
            {
              char v21 = 0;
LABEL_34:
              char v19 = 0;
              char v25 = 0;
LABEL_35:
              BOOL v18 = 0;
              goto LABEL_36;
            }
            v41.location = v23;
            v41.length = v24;
            if (CFStringCompareWithOptions(a1, @",", v41, 0)) {
              goto LABEL_34;
            }
            if ((v21 & 1) == 0)
            {
              int v27 = v13;
              goto LABEL_42;
            }
          }
          char v19 = 0;
          char v25 = 0;
          BOOL v18 = 0;
          char v21 = 1;
        }
        else
        {
          char v25 = 0;
          BOOL v18 = 1;
        }
      }
LABEL_36:
      char v20 = v19;
      char v19 = v25;
      if ((sub_1B63CB63C((uint64_t)v30) & 1) == 0) {
        goto LABEL_42;
      }
    }
  }
}

uint64_t sub_1B64EB124(const __CFString *a1, uint64_t a2)
{
  memset(v18, 0, 240);
  CFIndex Length = CFStringGetLength(a1);
  sub_1B63CB5AC((uint64_t)v18, a1, 0, Length, 1);
  CFDictionaryRef v5 = (const __CFDictionary *)sub_1B662DD38();
  uint64_t result = sub_1B63CB63C((uint64_t)v18);
  if (result)
  {
    BOOL v7 = 0;
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      if (sub_1B63CBCB0((uint64_t)v18)) {
        sub_1B63CB63C((uint64_t)v18);
      }
      CFIndex v9 = sub_1B63CB644((uint64_t)v18);
      CFIndex v11 = v10;
      v19.location = v9;
      v19.length = v10;
      uint64_t result = CFStringCompareWithOptions(a1, @"/", v19, 0);
      BOOL v12 = result == 0;
      if (!result)
      {
        if (v7) {
          return result;
        }
        goto LABEL_14;
      }
      v20.location = v9;
      v20.length = v11;
      if (CFStringCompareWithOptions(a1, @"vfx_node", v20, 0))
      {
        v21.location = v9;
        v21.length = v11;
        if (CFStringCompareWithOptions(a1, @"vfx_frame", v21, 0)) {
          goto LABEL_10;
        }
      }
      sub_1B63CB63C((uint64_t)v18);
      v22.location = sub_1B63CB644((uint64_t)v18);
      CFIndex v14 = v13;
      v22.length = v13;
      if (CFStringCompareWithOptions(a1, @".", v22, 0) == kCFCompareEqualTo) {
        break;
      }
LABEL_14:
      uint64_t result = sub_1B63CB63C((uint64_t)v18);
      BOOL v7 = v12;
      if ((result & 1) == 0) {
        return result;
      }
    }
    sub_1B63CB63C((uint64_t)v18);
    sub_1B63CB644((uint64_t)v18);
    v11 += v14 + v15;
LABEL_10:
    v23.location = v9;
    v23.length = v11;
    CFStringRef v16 = CFStringCreateWithSubstring(v8, a1, v23);
    Value = (const void **)CFDictionaryGetValue(v5, v16);
    if (Value) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 64), v16, *Value);
    }
    CFRelease(v16);
    goto LABEL_14;
  }
  return result;
}

void sub_1B64EB310(const __CFString *a1, uint64_t a2)
{
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v44 = 0u;
  CFIndex Length = CFStringGetLength(a1);
  sub_1B63CB5AC((uint64_t)&v44, a1, 0, Length, 1);
  sub_1B63CBCB8((uint64_t)&v44, 1);
  if (sub_1B63CBCB0((uint64_t)&v44)) {
    sub_1B63CBCB8((uint64_t)&v44, 1);
  }
  v59.location = sub_1B63CB644((uint64_t)&v44);
  v59.length = v5;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v7 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v59);
  sub_1B63CBCB8((uint64_t)&v44, 1);
  v60.location = sub_1B63CB644((uint64_t)&v44);
  v60.length = v8;
  if (CFStringCompareWithOptions(a1, @"<", v60, 0))
  {
    MutableCFArrayRef Copy = (CFMutableStringRef)v7;
  }
  else
  {
    MutableCFArrayRef Copy = CFStringCreateMutableCopy(v6, 0, v7);
    do
    {
      CFIndex v10 = sub_1B63CB644((uint64_t)&v44);
      CFIndex v12 = v11;
      v61.location = v10;
      v61.length = v11;
      CFStringRef v13 = CFStringCreateWithSubstring(v6, a1, v61);
      CFStringAppend(MutableCopy, v13);
      CFRelease(v13);
      v62.location = v10;
      v62.length = v12;
      CFComparisonResult v14 = CFStringCompareWithOptions(a1, @">", v62, 0);
      char v15 = sub_1B63CBCB8((uint64_t)&v44, 1);
    }
    while (v14 && (v15 & 1) != 0);
    CFRelease(v7);
  }
  if (sub_1B63CBCB0((uint64_t)&v44)) {
    sub_1B63CBCB8((uint64_t)&v44, 1);
  }
  CFIndex v16 = sub_1B63CB644((uint64_t)&v44);
  CFIndex v18 = v17;
  v63.location = v16;
  v63.length = v17;
  CFStringRef v19 = CFStringCreateWithSubstring(v6, a1, v63);
  if (CFStringGetLength(MutableCopy) >= 1)
  {
    int v20 = sub_1B63CA610(MutableCopy);
    if (v20)
    {
      int v21 = v20;
      CFIndex v22 = v16 + v18;
      CFIndex v23 = CFStringGetLength(a1);
      if (v23 > v22)
      {
        v64.location = v22;
        v64.length = v23 - v22;
        CFIndex v24 = (__CFString *)CFStringCreateWithSubstring(v6, a1, v64);
        uint64_t v27 = objc_msgSend_rangeOfString_(v24, v25, @"=", v26, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58);
        if (v28)
        {
          CFStringRef v30 = (const __CFString *)objc_msgSend_substringFromIndex_(v24, v28, v27 + 1, v29);
          CFRange v37 = (const void *)sub_1B65623D0(v21, 1, v31, v32, v33, v34, v35, v36);
          sub_1B65629C8((uint64_t)v37, v30, v38, v39, v40, v41, v42, v43);
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 40), v19, v37);
          CFRelease(v37);
        }
        CFRelease(v24);
      }
    }
  }
  if (CFStringGetLength(v19) >= 1 && CFStringGetLength(MutableCopy) >= 1) {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 32), v19, MutableCopy);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

void sub_1B64EB5E0(const __CFString *a1, uint64_t a2)
{
  memset(v10, 0, sizeof(v10));
  CFIndex Length = CFStringGetLength(a1);
  sub_1B63CB5AC((uint64_t)v10, a1, 0, Length, 1);
  sub_1B63CB63C((uint64_t)v10);
  if (sub_1B63CBCB0((uint64_t)v10)) {
    sub_1B63CB63C((uint64_t)v10);
  }
  v11.location = sub_1B63CB644((uint64_t)v10);
  v11.length = v5;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v7 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v11);
  sub_1B63CB63C((uint64_t)v10);
  if (sub_1B63CBCB0((uint64_t)v10)) {
    sub_1B63CB63C((uint64_t)v10);
  }
  v12.location = sub_1B63CB644((uint64_t)v10);
  v12.length = v8;
  CFStringRef v9 = CFStringCreateWithSubstring(v6, a1, v12);
  if (CFStringGetLength(v9) >= 1 && CFStringGetLength(v7) >= 1) {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 48), v9, v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v7) {
    CFRelease(v7);
  }
}

CFMutableDictionaryRef sub_1B64EB724@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  if (a1)
  {
    CFMutableDictionaryRef Mutable = 0;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  else
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)a2 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    *(void *)(a2 + 8) = CFStringCreateMutable(v4, 0);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  *(void *)(a2 + 16) = Mutable;
  CFIndex v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  *(void *)(a2 + 24) = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], 0);
  CFAllocatorRef v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  *(void *)(a2 + 56) = CFDictionaryCreateMutable(v4, 0, v5, MEMORY[0x1E4F1D540]);
  *(void *)(a2 + 32) = CFDictionaryCreateMutable(v4, 0, v5, v6);
  *(void *)(a2 + 40) = CFDictionaryCreateMutable(v4, 0, v5, v6);
  *(void *)(a2 + 48) = CFDictionaryCreateMutable(v4, 0, v5, v6);
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(v4, 0, v5, v6);
  *(void *)(a2 + 64) = result;
  return result;
}

void sub_1B64EB864(uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(void *)a1 = 0;
  }
  unint64_t v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 8) = 0;
  }
  CFAllocatorRef v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16) = 0;
  }
  CFIndex v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 24) = 0;
  }
  CFAllocatorRef v6 = *(const void **)(a1 + 56);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 56) = 0;
  }
  CFStringRef v7 = *(const void **)(a1 + 40);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 40) = 0;
  }
  CFIndex v8 = *(const void **)(a1 + 32);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 32) = 0;
  }
  CFStringRef v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 48) = 0;
  }
  CFIndex v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 64) = 0;
  }
}

void sub_1B64ECF6C(_Unwind_Exception *a1)
{
}

void sub_1B64EE1B4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9 || (uint64_t v9 = objc_msgSend_worldRef(*(void **)(a1 + 32), a2, a3, a4)) != 0)
  {
    sub_1B64B0C28(v9, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    char v10 = 0;
  }
  else
  {
    char v10 = 1;
  }
  CFRange v11 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v19 = sub_1B6446518(*(void *)(*(void *)(a1 + 40) + 184), v12, v13, v14, v15, v16, v17, v18);
  if (v19 && (CFDictionaryRef v27 = sub_1B64A3B48(v19, v20, v21, v22, v23, v24, v25, v26)) != 0)
  {
    uint64_t v29 = (uint64_t)v27;
    int v30 = sub_1B649B4B8((uint64_t)v27, v28, v21, v22, v23, v24, v25, v26);
    BOOL v38 = sub_1B649CB18(v29, v31, v32, v33, v34, v35, v36, v37) != 0;
  }
  else
  {
    int v30 = 0;
    BOOL v38 = 0;
  }
  sub_1B6445D60(*(void *)(*(void *)(a1 + 40) + 184), v11, v21, v22, v23, v24, v25, v26);
  if (v11)
  {
    CFDictionaryRef v46 = sub_1B64A3B48((uint64_t)v11, v39, v40, v41, v42, v43, v44, v45);
    if (v46)
    {
      uint64_t v54 = (uint64_t)v46;
      int v55 = sub_1B649B4B8((uint64_t)v46, (uint64_t)v47, v48, v49, v50, v51, v52, v53);
      BOOL v63 = sub_1B649CB18(v54, v56, v57, v58, v59, v60, v61, v62) != 0;
    }
    else
    {
      int v55 = 0;
      BOOL v63 = 0;
    }
    CFRange v64 = objc_msgSend_defaultCenter(MEMORY[0x1E4F28EB8], v47, v48, v49);
    uint64_t v72 = sub_1B63F4F54(v11, v65, v66, v67, v68, v69, v70, v71);
    objc_msgSend_postNotificationName_object_(v64, v73, @"kCFXWorldDidUpdateNotification", v72);
    BOOL v74 = v55 != v30 || v63;
    if (v74 || v38)
    {
      uint64_t v75 = (const void *)sub_1B63F4F54(v11, v39, v40, v41, v42, v43, v44, v45);
      sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v75, 0, 1u);
    }
  }
  if ((v10 & 1) == 0)
  {
    sub_1B64B0CB4(v9, v39, v40, v41, v42, v43, v44, v45);
  }
}

float sub_1B64EE358(float a1, double a2)
{
  double v3 = __tanpi(a1 / 360.0);
  float v4 = atan(v3 * a2);
  if (v4 < 0.0)
  {
    float v5 = 3.14159265 - v4;
    float v4 = v5;
  }
  return v4 * 114.591559;
}

float sub_1B64EE3C8(float a1, double a2)
{
  double v3 = __tanpi(a1 / 360.0);
  float v4 = atan(v3 / a2);
  if (v4 < 0.0)
  {
    float v5 = 3.14159265 - v4;
    float v4 = v5;
  }
  return v4 * 114.591559;
}

CFTypeRef sub_1B64EE4E4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  float v5 = (const void *)objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 184);

  return sub_1B64466C4(v12, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B64EECA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = sub_1B644689C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v8) {
    return 0;
  }
  if ((*(_WORD *)(v8 + 252) & 0x200) == 0)
  {
    if ((*(_WORD *)(v8 + 256) & 0x200) == 0) {
      return 0;
    }
    uint64_t v8 = *(void *)(v8 + 296);
  }

  return MEMORY[0x1F4181798](v8, sel__wantsCustomMainPassProcessForRenderer_, v8, v9);
}

uint64_t sub_1B64EECF4(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B644689C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if ((*(_WORD *)(result + 252) & 0x200) != 0)
    {
      uint64_t v11 = 0;
      uint64_t result = objc_msgSend__customMainPassProcessUsesExtraRenderTargetForRenderer_pixelFormat_((void *)result, v10, result, (uint64_t)&v11);
    }
    else
    {
      if ((*(_WORD *)(result + 256) & 0x200) == 0) {
        return 0;
      }
      uint64_t v11 = 0;
      uint64_t result = objc_msgSend__customMainPassProcessUsesExtraRenderTargetForRenderer_pixelFormat_(*(void **)(result + 296), v10, result, (uint64_t)&v11);
    }
    *a2 = v11;
  }
  return result;
}

uint64_t sub_1B64EED68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B644689C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = v9;
  if ((*(_WORD *)(v9 + 252) & 0x200) == 0)
  {
    if ((*(_WORD *)(v9 + 256) & 0x200) == 0) {
      return 0;
    }
    uint64_t v9 = *(void *)(v9 + 296);
  }

  return MEMORY[0x1F4181798](v9, sel__usesSpecificMainPassClearColorForRenderer_clearColor_, v10, a2);
}

BOOL sub_1B64EEEA4(uint64_t a1, void *a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_camera(a2, (const char *)a2, (uint64_t)a3, a4);
  if (v5) {
    *a3 = 1;
  }
  return v5 != 0;
}

void sub_1B64EF0B0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t **)(v4 + 184);
  if (v5)
  {
    uint64_t v6 = (const void *)objc_msgSend_worldRef(*(void **)(v4 + 8), a2, a3, a4);
    sub_1B644745C(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

uint64_t sub_1B64EF104(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1B64EF1F4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t **)(v4 + 184);
  if (v5)
  {
    uint64_t v6 = (const void *)objc_msgSend_worldRef(*(void **)(v4 + 8), a2, a3, a4);
    sub_1B644745C(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

uint64_t sub_1B64EF8D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B644689C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v17 = result;
    uint64_t v18 = (id *)sub_1B644558C(a1, v10, v11, v12, v13, v14, v15, v16);
    uint64_t v19 = sub_1B6583674(v18);
    return MEMORY[0x1F4181798](v17, sel__willRenderWorld_, v19, v20);
  }
  return result;
}

uint64_t sub_1B64EF92C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B644689C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v17 = result;
    uint64_t v18 = (id *)sub_1B644558C(a1, v10, v11, v12, v13, v14, v15, v16);
    uint64_t v19 = sub_1B6583674(v18);
    return MEMORY[0x1F4181798](v17, sel__didRenderWorld_, v19, v20);
  }
  return result;
}

uint64_t sub_1B64EF988(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B644689C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    return MEMORY[0x1F4181798](result, sel__readSubdivCacheForHash_, a2, v10);
  }
  return result;
}

uint64_t sub_1B64EF9D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B644689C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    return MEMORY[0x1F4181798](result, sel__writeSubdivCacheForHash_dataProvider_, a2, a3);
  }
  return result;
}

uint64_t sub_1B64EFA20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B644689C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v11 = result;
    if ((*(_WORD *)(result + 252) & 0x200) != 0) {
      uint64_t result = objc_msgSend__encodeCustomMainPassProcessForRenderer_atTime_helper_((void *)result, v10, result, a2, *(double *)(result + 128));
    }
    if ((*(_WORD *)(v11 + 256) & 0x200) != 0)
    {
      uint64_t v12 = *(void **)(v11 + 296);
      double v13 = *(double *)(v11 + 128);
      return objc_msgSend__encodeCustomMainPassProcessForRenderer_atTime_helper_(v12, v10, (uint64_t)v12, a2, v13);
    }
  }
  return result;
}

void sub_1B64F0F60(_Unwind_Exception *a1)
{
}

uint64_t sub_1B64F171C(uint64_t result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= 1)
  {
    uint64_t v20 = v9;
    uint64_t v21 = v8;
    uint64_t v22 = v7;
    uint64_t v23 = v6;
    uint64_t v24 = v5;
    uint64_t v25 = v4;
    uint64_t v26 = v10;
    uint64_t v27 = v11;
    uint64_t v12 = a3;
    double v13 = (uint64_t *)a2;
    uint64_t v14 = result;
    do
    {
      uint64_t v15 = *(void **)(v14 + 32);
      uint64_t v16 = *v13++;
      uint64_t v17 = objc_msgSend_nodeWithNodeRef_(VFXNode, a2, v16, a4, v20, v21, v22, v23, v24, v25, v26, v27);
      uint64_t result = objc_msgSend_addObject_(v15, v18, v17, v19);
      --v12;
    }
    while (v12);
  }
  return result;
}

void sub_1B64F1BE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B64F1CA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

double sub_1B64F1D6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&double result = sub_1B6446BF8(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

unint64_t sub_1B64F22E8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(*(void *)(a1 + 32) + 184);
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 40), a2, a3, a4);

  return sub_1B658F374(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B64F3750(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = objc_msgSend_world(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v9 = objc_msgSend_rootNode(v5, v6, v7, v8);
  objc_msgSend_childNodesPassingTest_(v9, v10, (uint64_t)&unk_1F0FB6BC8, v11);
  uint64_t v15 = objc_msgSend_world(*(void **)(a1 + 32), v12, v13, v14);
  uint64_t v19 = objc_msgSend_rootNode(v15, v16, v17, v18);
  uint64_t v22 = objc_msgSend_childNodesPassingTest_(v19, v20, (uint64_t)&unk_1F0FB6BE8, v21);
  uint64_t v26 = objc_msgSend_array(MEMORY[0x1E4F1CA48], v23, v24, v25);
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  uint64_t v28 = objc_msgSend_countByEnumeratingWithState_objects_count_(v22, v27, (uint64_t)&v89, (uint64_t)v93, 16);
  if (v28)
  {
    uint64_t v32 = v28;
    uint64_t v33 = *(void *)v90;
    do
    {
      for (uint64_t i = 0; i != v32; ++i)
      {
        if (*(void *)v90 != v33) {
          objc_enumerationMutation(v22);
        }
        uint64_t v35 = *(void **)(*((void *)&v89 + 1) + 8 * i);
        uint64_t v36 = NSNumber;
        uint64_t isHidden = objc_msgSend_isHidden(v35, v29, v30, v31);
        uint64_t v40 = objc_msgSend_numberWithBool_(v36, v38, isHidden, v39);
        objc_msgSend_addObject_(v26, v41, v40, v42);
        uint64_t v46 = objc_msgSend_nodeRef(v35, v43, v44, v45);
        sub_1B64A0CE8(v46, 1, v47, v48, v49, v50, v51, v52);
      }
      uint64_t v32 = objc_msgSend_countByEnumeratingWithState_objects_count_(v22, v29, (uint64_t)&v89, (uint64_t)v93, 16);
    }
    while (v32);
  }
  objc_msgSend_updateAtTime_(*(void **)(a1 + 32), v29, v30, v31, *(double *)(*(void *)(a1 + 32) + 128));
  uint64_t v53 = sub_1B6445BA0(*(void *)(*(void *)(a1 + 32) + 184));
  uint64_t v54 = (uint64_t *)sub_1B63D44F8();
  sub_1B65F4980(v53, v54);
  objc_msgSend_beginFrame_(*(void **)(*(void *)(a1 + 32) + 240), v55, 0, v56);
  sub_1B65F4318(v53, v57, v58, v59);
  objc_msgSend_endFrameWaitingUntilCompleted_status_error_(*(void **)(*(void *)(a1 + 32) + 240), v60, 1, 0, 0);
  if (objc_msgSend_count(v26, v61, v62, v63))
  {
    unint64_t v66 = 0;
    do
    {
      uint64_t v67 = objc_msgSend_objectAtIndexedSubscript_(v22, v64, v66, v65);
      uint64_t v71 = objc_msgSend_nodeRef(v67, v68, v69, v70);
      BOOL v74 = objc_msgSend_objectAtIndexedSubscript_(v26, v72, v66, v73);
      int v78 = objc_msgSend_BOOLValue(v74, v75, v76, v77);
      sub_1B64A0CE8(v71, v78, v79, v80, v81, v82, v83, v84);
      ++v66;
    }
    while (v66 < objc_msgSend_count(v26, v85, v86, v87));
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1B64F3ACC;
  block[3] = &unk_1E61435C8;
  block[4] = *(void *)(a1 + 48);
  dispatch_async(MEMORY[0x1E4F14428], block);
}

uint64_t sub_1B64F39D8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_light(a2, (const char *)a2, a3, a4);
  if (result)
  {
    uint64_t v9 = objc_msgSend_nodeRef(a2, v6, v7, v8);
    if (sub_1B64A3178(v9, v10, v11, v12, v13, v14, v15, v16))
    {
      return 0;
    }
    else
    {
      uint64_t v20 = objc_msgSend_light(a2, v17, v18, v19);
      uint64_t result = objc_msgSend_isBaked(v20, v21, v22, v23);
      if (result)
      {
        uint64_t v27 = objc_msgSend_light(a2, v24, v25, v26);
        if (objc_msgSend_type(v27, v28, v29, v30) == 2)
        {
          return 1;
        }
        else
        {
          uint64_t v34 = objc_msgSend_light(a2, v31, v32, v33);
          uint64_t result = objc_msgSend_type(v34, v35, v36, v37);
          if (result != 1)
          {
            uint64_t v41 = objc_msgSend_light(a2, v38, v39, v40);
            return objc_msgSend_type(v41, v42, v43, v44) == 3;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1B64F3A70(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_light(a2, (const char *)a2, a3, a4);
  if (result)
  {
    uint64_t v9 = objc_msgSend_light(a2, v6, v7, v8);
    uint64_t result = 0;
    if (objc_msgSend_type(v9, v10, v11, v12) == 4)
    {
      uint64_t v16 = objc_msgSend_light(a2, v13, v14, v15);
      if (!objc_msgSend_probeType(v16, v17, v18, v19)) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_1B64F3ACC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

uint64_t sub_1B64F3B64(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__engineContext(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t result = objc_msgSend_isAborting(*(void **)(a1 + 40), v6, v7, v8);
  if ((result & 1) == 0)
  {
    objc_msgSend_lock(*(void **)(a1 + 32), v10, v11, v12);
    uint64_t v20 = sub_1B644558C(v5, v13, v14, v15, v16, v17, v18, v19);
    sub_1B64B0C28(v20, v21, v22, v23, v24, v25, v26, v27);
    sub_1B6447D28(v5, 1);
    sub_1B6447D50(v5, *(_DWORD *)(a1 + 48));
    sub_1B6447D60(v5, *(unsigned char *)(a1 + 56));
    id v28 = objc_alloc_init(MEMORY[0x1E4F28B28]);
    objc_msgSend__beginFrame(*(void **)(a1 + 32), v29, v30, v31);
    objc_msgSend__render(*(void **)(a1 + 32), v32, v33, v34);
    sub_1B6447D60(v5, 1);
    sub_1B6447D28(v5, 0);
    objc_msgSend__endFrame(*(void **)(a1 + 32), v35, v36, v37);
    sub_1B64B0CB4(v20, v38, v39, v40, v41, v42, v43, v44);
    if (*(unsigned char *)(a1 + 57)) {
      objc_msgSend__jitterRedisplay(*(void **)(*(void *)(a1 + 32) + 296), v45, v46, v47);
    }
    objc_msgSend_drain(v28, v45, v46, v47);
    uint64_t v51 = *(void **)(a1 + 32);
    return objc_msgSend_unlock(v51, v48, v49, v50);
  }
  return result;
}

uint64_t sub_1B64F3CEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(a1 + 32) + 240), sel_addCommandBufferScheduledHandler_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B64F3D74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(a1 + 32) + 240), sel_addCommandBufferCompletedHandler_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B64F3E58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(a1 + 32) + 240), sel_addDrawablePresentedHandler_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B64F3EE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(*(void *)(a1 + 32) + 240), sel__allowGPUBackgroundExecution, a3, a4);
}

void sub_1B64F40B0(uint64_t a1)
{
}

uint64_t CFXGetSharedCommandQueueForDevice(uint64_t a1)
{
  uint64_t v1 = sub_1B653A10C((uint64_t)VFXMTLResourceManager, a1);

  return sub_1B653EFC4((uint64_t)v1);
}

const void *sub_1B64F41F0(void *a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  uint64_t v5 = (const void *)objc_msgSend_CGImage(a1, v2, v3, v4);
  uint64_t v6 = v5;
  if (v5) {
    CFRetain(v5);
  }
  return v6;
}

void VFXSetPerformanceStatisticsEnabled(int a1)
{
  if (qword_1EB9886F8 != -1) {
    dispatch_once(&qword_1EB9886F8, &unk_1F0FB5B08);
  }
  if ((byte_1E9DDB108 != 0) != a1)
  {
    byte_1E9DDB108 = a1;
    if (a1)
    {
      if (qword_1E9DDB140 != -1)
      {
        dispatch_once(&qword_1E9DDB140, &unk_1F0FB70C8);
      }
    }
  }
}

uint64_t sub_1B64F42F4()
{
  if (qword_1EB9886F8 != -1) {
    dispatch_once(&qword_1EB9886F8, &unk_1F0FB5B08);
  }
  return byte_1E9DDB108;
}

void sub_1B64F4338()
{
  uint64_t v0 = getenv("VFX_ENABLE_COLLECTION");
  if (v0)
  {
    if (!strcmp(v0, "YES"))
    {
      byte_1E9DDB108 = 1;
      if (qword_1E9DDB140 != -1)
      {
        dispatch_once(&qword_1E9DDB140, &unk_1F0FB70C8);
      }
    }
  }
}

float sub_1B64F43B0(uint64_t a1, unsigned char *a2, int a3)
{
  *a2 = 2;
  double v3 = *(double *)(a1 + 328);
  if (v3 == 0.0) {
    float v4 = 0.0;
  }
  else {
    float v4 = 1.0 / v3;
  }
  uint64_t v5 = &a2[52 * a3];
  *((_DWORD *)v5 + 1) = *(_DWORD *)(a1 + 4);
  *((_DWORD *)v5 + 2) = vcvtas_u32_f32(v4);
  v6.f64[0] = *(float64_t *)(a1 + 96);
  v7.f64[0] = *(float64_t *)(a1 + 120);
  v8.f64[0] = *(float64_t *)(a1 + 168);
  v7.f64[1] = *(double *)(a1 + 128) + *(double *)(a1 + 136) + *(double *)(a1 + 144);
  v6.f64[1] = *(float64_t *)(a1 + 112);
  *(float32x4_t *)(v5 + 12) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v7);
  v6.f64[0] = *(float64_t *)(a1 + 152);
  v8.f64[1] = *(float64_t *)(a1 + 184);
  v6.f64[1] = *(float64_t *)(a1 + 104);
  *(float32x4_t *)(v5 + 28) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v8);
  *(float *)v6.f64 = *(double *)(a1 + 192);
  *((_DWORD *)v5 + 11) = LODWORD(v6.f64[0]);
  float result = *(double *)(a1 + 288);
  *((float *)v5 + 13) = result;
  *((_DWORD *)v5 + 12) = *(_DWORD *)(a1 + 280);
  a2[1] = a3;
  return result;
}

void sub_1B64F4464(uint64_t a1)
{
  if (qword_1E9DDB110 != -1) {
    dispatch_once(&qword_1E9DDB110, &unk_1F0FB6AC8);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&dword_1E9DDB118);
  sub_1B64F43B0(a1, &_vfxPerformanceData, (byte_1E9E48D85 & 1) == 0);

  os_unfair_lock_unlock((os_unfair_lock_t)&dword_1E9DDB118);
}

void sub_1B64F44EC()
{
  dword_1E9DDB118 = 0;
}

void VFXGetPerformanceStatistics(_OWORD *a1@<X8>)
{
  if (qword_1E9DDB110 != -1) {
    dispatch_once(&qword_1E9DDB110, &unk_1F0FB6EE8);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&dword_1E9DDB118);
  long long v2 = unk_1E9E48DD4;
  a1[4] = xmmword_1E9E48DC4;
  a1[5] = v2;
  *(_OWORD *)((char *)a1 + 92) = unk_1E9E48DE0;
  long long v3 = unk_1E9E48D94;
  *a1 = _vfxPerformanceData;
  a1[1] = v3;
  long long v4 = unk_1E9E48DB4;
  a1[2] = xmmword_1E9E48DA4;
  a1[3] = v4;

  os_unfair_lock_unlock((os_unfair_lock_t)&dword_1E9DDB118);
}

void sub_1B64F458C()
{
  dword_1E9DDB118 = 0;
}

void *VFXGetPerformanceStatisticsAsPlist()
{
  memset(v3, 0, 108);
  VFXGetPerformanceStatistics(v3);
  return sub_1B64F45DC((unsigned __int8 *)v3, (const char *)BYTE1(v3[0]), v0, v1);
}

void *sub_1B64F45DC(unsigned __int8 *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v4 = (int)a2;
  float64x2_t v6 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], a2, a3, a4);
  float64x2_t v7 = (unsigned int *)&a1[52 * v4];
  uint64_t v10 = objc_msgSend_numberWithUnsignedInt_(NSNumber, v8, v7[2], v9);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v11, v10, @"vfx.fps");
  uint64_t v14 = objc_msgSend_numberWithUnsignedInt_(NSNumber, v12, v7[1], v13);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v15, v14, @"vfx.primcnt");
  LODWORD(v16) = v7[3];
  uint64_t v20 = objc_msgSend_numberWithFloat_(NSNumber, v17, v18, v19, v16);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v21, v20, @"vfx.frmtime");
  LODWORD(v22) = v7[4];
  uint64_t v26 = objc_msgSend_numberWithFloat_(NSNumber, v23, v24, v25, v22);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v27, v26, @"vfx.phytime");
  LODWORD(v28) = v7[5];
  uint64_t v32 = objc_msgSend_numberWithFloat_(NSNumber, v29, v30, v31, v28);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v33, v32, @"vfx.prttime");
  LODWORD(v34) = v7[6];
  uint64_t v38 = objc_msgSend_numberWithFloat_(NSNumber, v35, v36, v37, v34);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v39, v38, @"vfx.animtime");
  LODWORD(v40) = v7[9];
  uint64_t v44 = objc_msgSend_numberWithFloat_(NSNumber, v41, v42, v43, v40);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v45, v44, @"vfx.clientTime");
  LODWORD(v46) = v7[7];
  uint64_t v50 = objc_msgSend_numberWithFloat_(NSNumber, v47, v48, v49, v46);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v51, v50, @"vfx.rendertime");
  LODWORD(v52) = v7[8];
  uint64_t v56 = objc_msgSend_numberWithFloat_(NSNumber, v53, v54, v55, v52);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v57, v56, @"vfx.consttime");
  LODWORD(v58) = v7[10];
  uint64_t v62 = objc_msgSend_numberWithFloat_(NSNumber, v59, v60, v61, v58);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v63, v62, @"vfx.cpuidletime");
  LODWORD(v64) = v7[11];
  uint64_t v68 = objc_msgSend_numberWithFloat_(NSNumber, v65, v66, v67, v64);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v69, v68, @"vfx.cawaittime");
  if (*a1 < 2u)
  {
    objc_msgSend_setObject_forKeyedSubscript_(v6, v70, (uint64_t)&unk_1F103C008, @"vfx.shaderCompilationTime");
    objc_msgSend_setObject_forKeyedSubscript_(v6, v81, (uint64_t)&unk_1F103C008, @"vfx.shaderGenerationCount");
  }
  else
  {
    BOOL v74 = &a1[52 * v4];
    LODWORD(v73) = *((_DWORD *)v74 + 13);
    uint64_t v75 = objc_msgSend_numberWithFloat_(NSNumber, v70, v71, v72, v73);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v76, v75, @"vfx.shaderCompilationTime");
    uint64_t v79 = objc_msgSend_numberWithUnsignedInt_(NSNumber, v77, *((unsigned int *)v74 + 12), v78);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v80, v79, @"vfx.shaderGenerationCount");
  }
  uint64_t v82 = (void *)sub_1B64F488C();
  uint64_t v85 = objc_msgSend_objectForKeyedSubscript_(v82, v83, @"Device Utilization %", v84);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v86, v85, @"vfx.deviceutil");
  uint64_t v89 = objc_msgSend_objectForKeyedSubscript_(v82, v87, @"Renderer Utilization %", v88);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v90, v89, @"vfx.rendererutil");
  uint64_t v93 = objc_msgSend_objectForKeyedSubscript_(v82, v91, @"Tiler Utilization %", v92);
  objc_msgSend_setObject_forKeyedSubscript_(v6, v94, v93, @"vfx.tilerutil");

  return v6;
}

uint64_t sub_1B64F488C()
{
  double v3 = CACurrentMediaTime();
  if (v3 - *(double *)&qword_1E9DCAA00 > 1.0)
  {
    io_registry_entry_t v4 = dword_1E9DDB11C;
    if (!dword_1E9DDB11C)
    {
      io_iterator_t existing = 0;
      mach_port_t v5 = *MEMORY[0x1E4F2EEF0];
      CFDictionaryRef v6 = IOServiceMatching("IOAcceleratorES");
      if (!IOServiceGetMatchingServices(v5, v6, &existing)) {
        dword_1E9DDB11C = IOIteratorNext(existing);
      }
      IOObjectRelease(existing);
      io_registry_entry_t v4 = dword_1E9DDB11C;
    }
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v4, @"PerformanceStatistics", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (CFProperty)
    {
      uint64_t v8 = (uint64_t)CFProperty;
      if (qword_1E9DDB120) {
        CFRelease((CFTypeRef)qword_1E9DDB120);
      }
      qword_1E9DDB120 = v8;
    }
    qword_1E9DCAA00 = *(void *)&v3;
  }
  return objc_msgSend_copy((void *)qword_1E9DDB120, v0, v1, v2);
}

uint64_t _VFXStartCollectingPerformanceStatisticsForPid(int a1)
{
  int v18 = a1;
  uint64_t v1 = CSSymbolicatorCreateWithPid();
  uint64_t v3 = v2;
  if (CSIsNull()) {
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x4012000000;
  uint64_t v13 = sub_1B64F4B98;
  uint64_t v14 = nullsub_87;
  uint64_t v15 = "";
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  CSSymbolicatorForeachSymbolWithMangledNameAtTime();
  uint64_t v5 = v11[6];
  uint64_t v6 = v11[7];
  if (CSIsNull()
    || (CSSymbolicatorGetTask(), (mapped_memory_cache_for_tasunint64_t k = create_mapped_memory_cache_for_task()) == 0))
  {
    CSRelease();
    uint64_t v4 = 0;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB170, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1E9DDB170))
    {
      xmmword_1E9DDB148 = 0u;
      unk_1E9DDB158 = 0u;
      dword_1E9DDB168 = 1065353216;
      __cxa_atexit((void (*)(void *))sub_1B64F4CF4, &xmmword_1E9DDB148, &dword_1B6287000);
      __cxa_guard_release(&qword_1E9DDB170);
    }
    uint64_t v19 = &v18;
    uint64_t v8 = sub_1B64F54CC((uint64_t)&xmmword_1E9DDB148, &v18, (uint64_t)&unk_1B6E4FDF8, &v19);
    *((void *)v8 + 3) = v1;
    *((void *)v8 + 4) = v3;
    *((void *)v8 + 5) = v5;
    *((void *)v8 + 6) = v6;
    uint64_t v4 = 1;
    *((void *)v8 + 7) = mapped_memory_cache_for_task;
  }
  _Block_object_dispose(&v10, 8);
  return v4;
}

void sub_1B64F4B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 sub_1B64F4B98(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

uint64_t sub_1B64F4BA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = CSIsNull();
  if ((result & 1) == 0)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    *(void *)(v7 + 48) = a2;
    *(void *)(v7 + 56) = a3;
  }
  return result;
}

uint64_t _VFXStopCollectingPerformanceStatisticsForPid(int a1)
{
  int v4 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB170, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB170))
  {
    xmmword_1E9DDB148 = 0u;
    unk_1E9DDB158 = 0u;
    dword_1E9DDB168 = 1065353216;
    __cxa_atexit((void (*)(void *))sub_1B64F4CF4, &xmmword_1E9DDB148, &dword_1B6287000);
    __cxa_guard_release(&qword_1E9DDB170);
  }
  sub_1B64F56FC((uint64_t)v3, (uint64_t)&xmmword_1E9DDB148);
  uint64_t v1 = sub_1B64F5998(v3, &v4);
  if (v1)
  {
    destroy_mapped_memory_cache();
    v1[5] = 0;
    v1[6] = 0;
    v1[7] = 0;
    CSRelease();
    v1[3] = 0;
    v1[4] = 0;
    sub_1B63C8AF8(v3, v1);
  }
  sub_1B6491404((uint64_t)v3);
  return 1;
}

void sub_1B64F4CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *_VFXGetPerformanceStatisticsForPid(int a1)
{
  int v4 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB170, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB170))
  {
    xmmword_1E9DDB148 = 0u;
    unk_1E9DDB158 = 0u;
    dword_1E9DDB168 = 1065353216;
    __cxa_atexit((void (*)(void *))sub_1B64F4CF4, &xmmword_1E9DDB148, &dword_1B6287000);
    __cxa_guard_release(&qword_1E9DDB170);
  }
  sub_1B64F56FC((uint64_t)v3, (uint64_t)&xmmword_1E9DDB148);
  uint64_t v1 = sub_1B64F5998(v3, &v4);
  if (v1)
  {
    if (CSSymbolGetRange())
    {
      clear_mapped_memory();
      uint64_t v1 = 0;
      mapped_memory_read();
    }
    else
    {
      uint64_t v1 = 0;
    }
  }
  sub_1B6491404((uint64_t)v3);
  return v1;
}

void sub_1B64F4E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1B6491404((uint64_t)va);
  _Unwind_Resume(a1);
}

void *_VFXGetCollectedShadersForPid()
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  CSSymbolicatorCreateWithPid();
  if (CSIsNull())
  {
    uint64_t v2 = &unk_1F103C018;
  }
  else
  {
    v64[0] = 0;
    v64[1] = v64;
    v64[2] = 0x4012000000;
    v64[3] = sub_1B64F4B98;
    v64[4] = nullsub_87;
    v64[5] = "";
    v64[6] = 0;
    v64[7] = 0;
    uint64_t v59 = MEMORY[0x1E4F143A8];
    uint64_t v60 = 3221225472;
    uint64_t v61 = sub_1B64F5480;
    uint64_t v62 = &unk_1E61436D8;
    uint64_t v63 = v64;
    CSSymbolicatorForeachSymbolWithMangledNameAtTime();
    if (CSIsNull())
    {
      CSRelease();
      uint64_t v2 = &unk_1F103C040;
    }
    else
    {
      CSSymbolicatorGetTask();
      if (create_mapped_memory_cache_for_task())
      {
        if (CSSymbolGetRange())
        {
          clear_mapped_memory();
          uint64_t v58 = 0;
          uint64_t v2 = &unk_1F103C0B8;
          mapped_memory_read();
        }
        else
        {
          uint64_t v2 = &unk_1F103C090;
        }
      }
      else
      {
        CSRelease();
        uint64_t v2 = &unk_1F103C068;
      }
    }
    _Block_object_dispose(v64, 8);
  }
  uint64_t v53 = v2;
  if (objc_msgSend_valueForKey_(v2, v0, @"containerPath", v1))
  {
    uint64_t v6 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v3, v4, v5);
    uint64_t v10 = objc_msgSend_temporaryDirectory(v6, v7, v8, v9);
    uint64_t v13 = objc_msgSend_URLByAppendingPathComponent_(v10, v11, @"VFXShaderCache", v12);
    uint64_t v17 = objc_msgSend_path(v13, v14, v15, v16);
    uint64_t v53 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], v18, v19, v20);
    double v52 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v21, v22, v23);
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    uint64_t v25 = objc_msgSend_contentsOfDirectoryAtPath_error_(v52, v24, (uint64_t)v17, 0);
    uint64_t v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(v25, v26, (uint64_t)&v54, (uint64_t)v65, 16);
    if (v29)
    {
      uint64_t v30 = *(void *)v55;
      do
      {
        for (uint64_t i = 0; i != v29; ++i)
        {
          if (*(void *)v55 != v30) {
            objc_enumerationMutation(v25);
          }
          uint64_t v32 = *(void **)(*((void *)&v54 + 1) + 8 * i);
          if (objc_msgSend_hasPrefix_(v32, v27, @"commonProfile_", v28))
          {
            double v34 = objc_msgSend_pathExtension(v32, v27, v33, v28);
            if (objc_msgSend_isEqualToString_(v34, v35, @"metal", v36))
            {
              uint64_t v37 = objc_msgSend_stringByAppendingPathComponent_(v17, v27, (uint64_t)v32, v28);
              uint64_t v39 = objc_msgSend_stringWithContentsOfFile_encoding_error_(NSString, v38, v37, 4, 0);
              uint64_t v42 = objc_msgSend_substringFromIndex_(v32, v40, 14, v41);
              uint64_t v46 = objc_msgSend_stringByDeletingPathExtension(v42, v43, v44, v45);
              if (v39)
              {
                uint64_t v28 = v46;
                if (v46)
                {
                  objc_msgSend_setValue_forKey_(v53, v27, v39, v46);
                  uint64_t v49 = objc_msgSend_fileURLWithPath_(MEMORY[0x1E4F1CB10], v47, v37, v48);
                  objc_msgSend_removeItemAtURL_error_(v52, v50, v49, 0);
                }
              }
            }
          }
        }
        uint64_t v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(v25, v27, (uint64_t)&v54, (uint64_t)v65, 16);
      }
      while (v29);
    }
  }
  return v53;
}

void sub_1B64F5260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VFXGetShaderCollectionOutputURL(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], a2, a3, a4);
  uint64_t v8 = objc_msgSend_temporaryDirectory(v4, v5, v6, v7);

  return objc_msgSend_URLByAppendingPathComponent_(v8, v9, @"VFXShaderCache", v10);
}

CFTypeRef VFXSetShaderCollectionEnabled(CFTypeRef result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (byte_1E9DDB128 != result)
  {
    byte_1E9DDB128 = (char)result;
    if (result)
    {
      uint64_t v4 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], a2, a3, a4);
      uint64_t v8 = objc_msgSend_temporaryDirectory(v4, v5, v6, v7);
      uint64_t v11 = objc_msgSend_URLByAppendingPathComponent_(v8, v9, @"VFXShaderCache", v10);
      uint64_t v15 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v12, v13, v14);
      uint64_t v19 = objc_msgSend_path(v11, v16, v17, v18);
      if (objc_msgSend_fileExistsAtPath_(v15, v20, v19, v21)) {
        objc_msgSend_removeItemAtURL_error_(v15, v22, (uint64_t)v11, 0);
      }
      uint64_t v29 = 0;
      if ((objc_msgSend_createDirectoryAtURL_withIntermediateDirectories_attributes_error_(v15, v22, (uint64_t)v11, 1, 0, &v29) & 1) == 0)
      {
        sub_1B63F2F54(16, @"Error: unable to create the shader cache folder at %@ (%@)", v23, v24, v25, v26, v27, v28, (uint64_t)v11);
        uint64_t v11 = 0;
      }
      return sub_1B63CC74C(v11);
    }
  }
  return result;
}

BOOL sub_1B64F53A4()
{
  if (byte_1E9DDB128) {
    return 1;
  }
  if (qword_1E9DDB130 != -1) {
    dispatch_once(&qword_1E9DDB130, &unk_1F0FB7028);
  }
  return byte_1E9DDB138 != 0;
}

uint64_t sub_1B64F5404(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_standardUserDefaults(MEMORY[0x1E4F1CB18], a2, a3, a4);
  uint64_t result = objc_msgSend_BOOLForKey_(v4, v5, @"com.apple.vfx.traceResources", v6);
  byte_1E9DDB138 = result;
  return result;
}

char *sub_1B64F5438(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], a2, a3, a4);
  uint64_t v8 = objc_msgSend_temporaryDirectory(v4, v5, v6, v7);
  uint64_t v12 = objc_msgSend_path(v8, v9, v10, v11);
  PathComponent = objc_msgSend_stringByDeletingLastPathComponent(v12, v13, v14, v15);
  uint64_t v20 = (const char *)objc_msgSend_UTF8String(PathComponent, v17, v18, v19);
  uint64_t result = strncpy(byte_1E9E48C81, v20, 0x100uLL);
  result[256] = 0;
  return result;
}

uint64_t sub_1B64F5480(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = CSIsNull();
  if ((result & 1) == 0)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    *(void *)(v7 + 48) = a2;
    *(void *)(v7 + 56) = a3;
  }
  return result;
}

char *sub_1B64F54CC(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((void *)v11 + 7) = 0;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_1B63C8630(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *(void *)uint64_t v11 = *v20;
LABEL_38:
    *uint64_t v20 = v11;
    goto LABEL_39;
  }
  *(void *)uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*(void *)v11)
  {
    unint64_t v21 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1B64F56E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64F56FC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_1B63C8630(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(int **)(a2 + 16); i; uint64_t i = *(int **)i)
    sub_1B64F5774(a1, i + 4, (_OWORD *)i + 1);
  return a1;
}

void sub_1B64F575C(_Unwind_Exception *a1)
{
  sub_1B6491404(v1);
  _Unwind_Resume(a1);
}

void *sub_1B64F5774(uint64_t a1, int *a2, _OWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x40uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  long long v12 = a3[1];
  *((_OWORD *)v10 + 1) = *a3;
  *((_OWORD *)v10 + 2) = v12;
  *((_OWORD *)v10 + 3) = a3[2];
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_1B63C8630(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *uint64_t v10 = *v20;
LABEL_38:
    *uint64_t v20 = v10;
    goto LABEL_39;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v21 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1B64F5984(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1B64F5998(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  unint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1B64F5D08(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    uint64_t v6 = result;
    float v7 = *(float *)(a1 + 32);
    float v8 = *(float *)(a1 + 36);
    float v9 = *(float *)(a1 + 40);
    BOOL v10 = fabsf(v9) <= 0.70711;
    float v11 = (float)(v8 * v8) + (float)(v7 * v7);
    float v12 = 1.0 / sqrtf(v11);
    float v13 = -(float)(v8 * v12);
    float v14 = v7 * v12;
    float v15 = -(float)(v9 * (float)(v7 * v12));
    float v16 = v9 * v13;
    float v17 = v11 * v12;
    float v18 = 0.0;
    float v19 = (float)(v9 * v9) + (float)(v8 * v8);
    float v20 = 1.0 / sqrtf(v19);
    float v21 = -(float)(v9 * v20);
    float v22 = v8 * v20;
    float v23 = v19 * v20;
    float v24 = v7 * v21;
    if (v10)
    {
      float v23 = v15;
    }
    else
    {
      float v14 = v21;
      float v13 = 0.0;
      float v18 = v22;
      float v16 = -(float)(v7 * v22);
    }
    LODWORD(v25) = *(_DWORD *)(a1 + 32);
    *((float *)&v25 + 1) = v13;
    HIDWORD(v27) = 0;
    *((void *)&v25 + 1) = LODWORD(v23);
    LODWORD(v26) = *(_DWORD *)(a1 + 36);
    *((float *)&v26 + 1) = v14;
    *((void *)&v26 + 1) = LODWORD(v16);
    LODWORD(v27) = *(_DWORD *)(a1 + 40);
    if (v10) {
      float v28 = v17;
    }
    else {
      float v28 = v24;
    }
    *((float *)&v27 + 1) = v18;
    *((float *)&v27 + 2) = v28;
    *(_OWORD *)(result + 80) = v25;
    *(_OWORD *)(result + 96) = v26;
    *(_OWORD *)(result + 112) = v27;
    v29.n128_f64[0] = sub_1B6E00364((float32x4_t *)result, (float32x4_t *)(*(void *)(result + 40) + 16), (float32x4_t *)(*(void *)(result + 48) + 16));
    uint64_t v30 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v6 + 16);
    return v30(v6, v29);
  }
  return result;
}

uint64_t sub_1B64F5EEC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    uint64_t v6 = result;
    float v7 = *(float *)(a1 + 32);
    float v8 = *(float *)(a1 + 36);
    float v9 = *(float *)(a1 + 40);
    BOOL v10 = fabsf(v9) <= 0.70711;
    float v11 = (float)(v8 * v8) + (float)(v7 * v7);
    float v12 = 1.0 / sqrtf(v11);
    float v13 = -(float)(v8 * v12);
    float v14 = v7 * v12;
    float v15 = -(float)(v9 * (float)(v7 * v12));
    float v16 = v9 * v13;
    float v17 = v11 * v12;
    float v18 = 0.0;
    float v19 = (float)(v9 * v9) + (float)(v8 * v8);
    float v20 = 1.0 / sqrtf(v19);
    float v21 = -(float)(v9 * v20);
    float v22 = v8 * v20;
    float v23 = v19 * v20;
    float v24 = v7 * v21;
    if (v10)
    {
      float v23 = v15;
    }
    else
    {
      float v14 = v21;
      float v13 = 0.0;
      float v18 = v22;
      float v16 = -(float)(v7 * v22);
    }
    LODWORD(v25) = *(_DWORD *)(a1 + 32);
    *((float *)&v25 + 1) = v13;
    HIDWORD(v27) = 0;
    *((void *)&v25 + 1) = LODWORD(v23);
    LODWORD(v26) = *(_DWORD *)(a1 + 36);
    *((float *)&v26 + 1) = v14;
    *((void *)&v26 + 1) = LODWORD(v16);
    LODWORD(v27) = *(_DWORD *)(a1 + 40);
    if (v10) {
      float v28 = v17;
    }
    else {
      float v28 = v24;
    }
    *((float *)&v27 + 1) = v18;
    *((float *)&v27 + 2) = v28;
    *(_OWORD *)(result + 144) = v25;
    *(_OWORD *)(result + 160) = v26;
    *(_OWORD *)(result + 176) = v27;
    v29.n128_f64[0] = sub_1B6E00364((float32x4_t *)result, (float32x4_t *)(*(void *)(result + 40) + 16), (float32x4_t *)(*(void *)(result + 48) + 16));
    uint64_t v30 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v6 + 16);
    return v30(v6, v29);
  }
  return result;
}

uint64_t sub_1B64F60D0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    uint64_t v6 = result;
    long long v7 = *(_OWORD *)(a1 + 32);
    HIDWORD(v7) = 0;
    *(_OWORD *)(result + 128) = v7;
    v8.n128_f64[0] = sub_1B6E00364((float32x4_t *)result, (float32x4_t *)(*(void *)(result + 40) + 16), (float32x4_t *)(*(void *)(result + 48) + 16));
    float v9 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v6 + 16);
    return v9(v6, v8);
  }
  return result;
}

uint64_t sub_1B64F6208(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__sliderHandle(*(void **)(a1 + 48), a2, a3, a4);
  if (result)
  {
    uint64_t v6 = result;
    long long v7 = *(_OWORD *)(a1 + 32);
    HIDWORD(v7) = 0;
    *(_OWORD *)(result + 192) = v7;
    v8.n128_f64[0] = sub_1B6E00364((float32x4_t *)result, (float32x4_t *)(*(void *)(result + 40) + 16), (float32x4_t *)(*(void *)(result + 48) + 16));
    float v9 = *(uint64_t (**)(uint64_t, __n128))(*(void *)v6 + 16);
    return v9(v6, v8);
  }
  return result;
}

float sub_1B64F6344(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v5 + 212) = result;
  }
  return result;
}

float sub_1B64F6428(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v5 + 216) = result;
  }
  return result;
}

void sub_1B64F650C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    uint64_t v6 = v5;
    float v7 = fmodf(*(float *)(a1 + 40), 6.2832);
    if (v7 >= -3.1416)
    {
      if (v7 > 3.1416) {
        float v7 = v7 + -6.2832;
      }
    }
    else
    {
      float v7 = v7 + 6.2832;
    }
    *(float *)(v6 + 220) = v7;
  }
}

void sub_1B64F6640(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    uint64_t v6 = v5;
    float v7 = fmodf(*(float *)(a1 + 40), 6.2832);
    if (v7 >= -3.1416)
    {
      if (v7 > 3.1416) {
        float v7 = v7 + -6.2832;
      }
    }
    else
    {
      float v7 = v7 + 6.2832;
    }
    *(float *)(v6 + 224) = v7;
  }
}

uint64_t sub_1B64F6774(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    float v6 = *(float *)(a1 + 40);
    *(unsigned char *)(result + 1216) = v6 != 0.0;
    *(float *)(result + 1220) = v6;
  }
  return result;
}

float sub_1B64F6864(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v5 + 1224) = result;
  }
  return result;
}

uint64_t sub_1B64F6948(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    float v6 = *(float *)(a1 + 40);
    *(unsigned char *)(result + 1232) = v6 != 0.0;
    *(float *)(result + 1236) = v6;
  }
  return result;
}

float sub_1B64F6A38(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__sliderHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v5 + 1240) = result;
  }
  return result;
}

void sub_1B64F6D5C(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

void sub_1B64F72FC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  BOOL v10 = *(const void **)(a1 + 112);
  if (v10)
  {
    if (*(void *)(a1 + 144)) {
      return;
    }
    CFRelease(v10);
    *(void *)(a1 + 112) = 0;
  }
  float v11 = *(const void **)(a1 + 144);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 144) = 0;
  }
  free(*(void **)(a1 + 168));
  *(void *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  free(*(void **)(a1 + 176));
  *(void *)(a1 + 176) = 0;
  uint64_t v171 = 0;
  CFMutableArrayRef v172 = 0;
  uint64_t v170 = 0;
  int v169 = 0;
  uint64_t v168 = 0;
  sub_1B64F855C(a1, &v172, &v171, &v170, &v169, &v168);
  CFArrayRef v18 = v172;
  if (!v172)
  {
    sub_1B63F2F54(16, @"Error: Failed to build renderable data for mesh %p", v12, v13, v14, v15, v16, v17, a1);
    uint64_t v127 = v171;
    if (!v171) {
      return;
    }
    goto LABEL_217;
  }
  CFArrayRef v19 = v171;
  if (!v171)
  {
    sub_1B63F2F54(16, @"Error: Failed to build renderable data for mesh %p", v12, v13, v14, v15, v16, v17, a1);
    uint64_t v127 = v18;
LABEL_217:
    CFRelease(v127);
    return;
  }
  CFIndex Count = CFArrayGetCount(v172);
  if (Count < 1)
  {
LABEL_14:
    CFStringRef ValueAtIndex = 0;
  }
  else
  {
    CFIndex v21 = Count;
    CFIndex v22 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v18, v22);
      if (!sub_1B641D56C((uint64_t)ValueAtIndex, v24, v25, v26, v27, v28, v29, v30)) {
        break;
      }
      if (v21 == ++v22) {
        goto LABEL_14;
      }
    }
  }
  uint64_t v31 = CFArrayGetCount(v19);
  CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v31, MEMORY[0x1E4F1D510]);
  if (v31 < 1) {
    goto LABEL_219;
  }
  CFAllocatorRef allocator = v32;
  CFIndex v34 = 0;
  CFAllocatorRef v152 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  for (uint64_t i = v31; i != v34; v31 = i)
  {
    uint64_t v35 = (CFDataRef *)CFArrayGetValueAtIndex(v171, v34);
    uint64_t v42 = v35;
    if (*((unsigned char *)v35 + 88) != 4)
    {
      uint64_t v62 = CFRetain(v35);
      if (!v62) {
        goto LABEL_216;
      }
      goto LABEL_37;
    }
    if (!v35[12]) {
      goto LABEL_216;
    }
    if (sub_1B63D11A8((uint64_t)v35) != 1)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. %s - Cannot create a renderable topology from indexed vertices", v43, v44, v45, v46, v47, v48, (uint64_t)"channelCount == 1");
      goto LABEL_216;
    }
    uint64_t v49 = *((unsigned __int8 *)v42 + 80);
    unint64_t Length = CFDataGetLength(v42[12]);
    BytePtr = CFDataGetBytePtr(v42[12]);
    uint64_t v52 = *((unsigned int *)v42 + 26);
    if (!v52)
    {
      uint64_t v62 = (_OWORD *)sub_1B63D0314();
      sub_1B63D05D4((uint64_t)v62, 0, 0, 0, 0, v67, v68, v69);
      if (!v62) {
        goto LABEL_216;
      }
      goto LABEL_37;
    }
    uint64_t v53 = BytePtr;
    unint64_t v54 = 0;
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    LOBYTE(v57) = 1;
    do
    {
      v54 += v49;
      if (v54 > Length)
      {
        sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v55);
LABEL_214:
        if ((byte_1E9DDB179 & 1) == 0)
        {
          byte_1E9DDB179 = 1;
          sub_1B63F2F54(16, @"Error: %s - Invalid polygon edge count (%u)", v36, v37, v38, v39, v40, v41, (uint64_t)"__CFXMeshElementCreateRenderablePrimitiveTypeCopy");
        }
LABEL_216:
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v36, v37, v38, v39, v40, v41, (uint64_t)"renderableElement");
        uint64_t v127 = Mutable;
        goto LABEL_217;
      }
      switch(v49)
      {
        case 4:
          unsigned int v58 = *(_DWORD *)&BytePtr[4 * v55];
          break;
        case 2:
          unsigned int v58 = *(unsigned __int16 *)&BytePtr[2 * v55];
          break;
        case 1:
          unsigned int v58 = BytePtr[v55];
          break;
        default:
          sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", v36, v37, v38, v39, v40, v41, (uint64_t)"false");
          goto LABEL_214;
      }
      if (v58 <= 2) {
        goto LABEL_214;
      }
      ++v55;
      int v57 = (v58 == 3) & v57;
      v56 += v58 - 2;
    }
    while (v52 != v55);
    uint64_t v167 = *((unsigned int *)v42 + 26);
    if (v57)
    {
      CFIndex v59 = CFDataGetLength(v42[12]);
      uint64_t v60 = Mutable;
      CFDataRef v61 = CFDataCreate(allocator, &v53[v167 * (unint64_t)v49], v59 - v167 * (unint64_t)v49);
      uint64_t v62 = (_OWORD *)sub_1B63D0314();
      sub_1B63D05D4((uint64_t)v62, 0, *((unsigned int *)v42 + 26), v61, v49, v63, v64, v65);
      CFDataRef v66 = v61;
      CFMutableDictionaryRef Mutable = v60;
      CFRelease(v66);
      if (!v62) {
        goto LABEL_216;
      }
      goto LABEL_37;
    }
    size_t v161 = v56 * 3 * v49;
    bytes = (UInt8 *)malloc_type_malloc(v161, 0x9DD64415uLL);
    if (!bytes) {
      goto LABEL_216;
    }
    int v145 = a2;
    uint64_t v71 = 0;
    uint64_t v154 = 0;
    int v72 = 0;
    uint64_t v73 = v167;
    int v147 = v167 + 2;
    int v148 = v167 + 1;
    int v146 = v167 + 3;
    uint64_t v150 = Mutable;
    float32x4_t v162 = v53;
    while (2)
    {
      uint64_t v74 = v71 + 1;
      if ((v71 + 1) * v49 > Length)
      {
        sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v71);
        goto LABEL_45;
      }
      if (v49 == 4)
      {
        unsigned int v75 = *(_DWORD *)&v53[4 * v71];
      }
      else if (v49 == 2)
      {
        unsigned int v75 = *(unsigned __int16 *)&v53[2 * v71];
      }
      else
      {
        unsigned int v75 = v53[v71];
      }
      if (v75 < 3) {
        goto LABEL_206;
      }
      uint64_t v76 = v75;
      uint64_t v77 = (v72 + v73);
      if (v49 * (unint64_t)(v77 + v75 - 1) > Length)
      {
        sub_1B63F2F54(16, @"Error: __CFXMeshElementCreateRenderablePrimitiveTypeCopy - polygon %u (%u vertices, indices [%u, %u]) does not fit in index buffer (%u elements)", v36, v37, v38, v39, v40, v41, v71);
        uint64_t v73 = v167;
        v56 -= (v76 - 2);
        goto LABEL_54;
      }
      if (v75 == 4)
      {
        if (v49 * (unint64_t)(v77 + 1) <= Length)
        {
          uint64_t v79 = v162;
          if (v49 == 4)
          {
            int v102 = *(_DWORD *)&v162[4 * v77];
          }
          else if (v49 == 2)
          {
            int v102 = *(unsigned __int16 *)&v162[2 * v77];
          }
          else
          {
            int v102 = v162[v77];
          }
          int v164 = v102;
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, (v72 + v73));
          int v164 = 0;
          uint64_t v79 = v162;
        }
        unsigned int v105 = v72 + v148;
        int v156 = v72;
        if (v49 * (unint64_t)(v72 + v148 + 1) <= Length)
        {
          if (v49 == 4)
          {
            int v109 = *(_DWORD *)&v79[4 * v105];
          }
          else if (v49 == 2)
          {
            int v109 = *(unsigned __int16 *)&v79[2 * v105];
          }
          else
          {
            int v109 = v79[v105];
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, (v72 + v148));
          int v109 = 0;
        }
        unsigned int v110 = v156 + v147;
        if (v49 * (unint64_t)(v156 + v147 + 1) <= Length)
        {
          if (v49 == 4)
          {
            int v111 = *(_DWORD *)&v79[4 * v110];
          }
          else if (v49 == 2)
          {
            int v111 = *(unsigned __int16 *)&v79[2 * v110];
          }
          else
          {
            int v111 = v79[v110];
          }
          int v160 = v111;
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, (v156 + v147));
          int v160 = 0;
        }
        unsigned int v114 = v146 + v156;
        if (v49 * (unint64_t)(v146 + v156 + 1) > Length)
        {
          sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, (v146 + v156));
          int v149 = 0;
          goto LABEL_148;
        }
        if (v49 == 4)
        {
          int v149 = *(_DWORD *)&v79[4 * v114];
LABEL_148:
          unint64_t v115 = v161;
        }
        else
        {
          unint64_t v115 = v161;
          if (v49 == 2) {
            int v116 = *(unsigned __int16 *)&v79[2 * v114];
          }
          else {
            int v116 = v79[v114];
          }
          int v149 = v116;
        }
        uint64_t v118 = (v154 + 1);
        if (v49 * (unint64_t)v118 <= v115)
        {
          if (v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v154] = v164;
          }
          else if (v49 == 2)
          {
            *(_WORD *)&bytes[2 * v154] = v164;
          }
          else
          {
            bytes[v154] = v164;
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v154);
          unint64_t v115 = v161;
        }
        uint64_t v119 = (v154 + 2);
        if (v49 * (unint64_t)v119 <= v115)
        {
          if (v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v118] = v109;
          }
          else if (v49 == 2)
          {
            *(_WORD *)&bytes[2 * v118] = v109;
          }
          else
          {
            bytes[v118] = v109;
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v118);
          unint64_t v115 = v161;
        }
        uint64_t v120 = (v154 + 3);
        CFMutableDictionaryRef Mutable = v150;
        if (v49 * (unint64_t)v120 <= v115)
        {
          if (v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v119] = v160;
          }
          else if (v49 == 2)
          {
            *(_WORD *)&bytes[2 * v119] = v160;
          }
          else
          {
            bytes[v119] = v160;
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v119);
          unint64_t v115 = v161;
        }
        uint64_t v121 = (v154 + 4);
        if (v49 * (unint64_t)v121 <= v115)
        {
          if (v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v120] = v164;
          }
          else if (v49 == 2)
          {
            *(_WORD *)&bytes[2 * v120] = v164;
          }
          else
          {
            bytes[v120] = v164;
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v120);
          unint64_t v115 = v161;
        }
        uint64_t v122 = (v154 + 5);
        if (v49 * (unint64_t)v122 <= v115)
        {
          if (v49 == 4)
          {
            *(_DWORD *)&bytes[4 * v121] = v160;
          }
          else if (v49 == 2)
          {
            *(_WORD *)&bytes[2 * v121] = v160;
          }
          else
          {
            bytes[v121] = v160;
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v121);
          unint64_t v115 = v161;
        }
        int v158 = v156 + 4;
        uint64_t v154 = (v154 + 6);
        uint64_t v53 = v162;
        if (v49 * (unint64_t)v154 <= v115)
        {
          if (v49 != 4)
          {
            uint64_t v73 = v167;
            if (v49 == 2) {
              *(_WORD *)&bytes[2 * v122] = v149;
            }
            else {
              bytes[v122] = v149;
            }
            goto LABEL_205;
          }
          *(_DWORD *)&bytes[4 * v122] = v149;
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v122);
        }
LABEL_204:
        uint64_t v73 = v167;
        goto LABEL_205;
      }
      if (v75 != 3)
      {
        if (!ValueAtIndex)
        {
LABEL_54:
          CFMutableDictionaryRef Mutable = v150;
          uint64_t v53 = v162;
          goto LABEL_206;
        }
        int v155 = v72;
        uint64_t v165 = (unsigned int *)malloc_type_malloc(4 * v75, 0x100004052888210uLL);
        for (uint64_t j = 0; j != v76; ++j)
        {
          int v87 = v77 + j;
          if (v49 * (unint64_t)(v77 + j + 1) <= Length)
          {
            if (v49 == 4)
            {
              unsigned int v88 = *(_DWORD *)&v162[4 * v87];
            }
            else if (v49 == 2)
            {
              unsigned int v88 = *(unsigned __int16 *)&v162[2 * v87];
            }
            else
            {
              unsigned int v88 = v162[v87];
            }
          }
          else
          {
            sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v80, v81, v82, v83, v84, v85, v77 + j);
            unsigned int v88 = 0;
          }
          v165[j] = v88;
        }
        v173[0] = 0;
        uint64_t v89 = sub_1B6585D2C((uint64_t)ValueAtIndex, v165, v76, (int *)v173, v82, v83, v84, v85);
        unsigned int v96 = v76 - 2;
        CFMutableDictionaryRef Mutable = v150;
        if (v173[0])
        {
          uint64_t v159 = v89;
          if (v173[0] == 3 * v96)
          {
            unint64_t v97 = 0;
            unint64_t v98 = v161;
            do
            {
              int v99 = v154 + v97;
              if (v49 * (unint64_t)(v154 + v97 + 1) <= v98)
              {
                int v100 = v159[v97];
                if (v49 == 4)
                {
                  *(_DWORD *)&bytes[4 * v99] = v100;
                }
                else if (v49 == 2)
                {
                  *(_WORD *)&bytes[2 * v99] = v100;
                }
                else
                {
                  bytes[v99] = v100;
                }
              }
              else
              {
                sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v90, v91, v92, v93, v94, v95, v154 + v97);
                unint64_t v98 = v161;
              }
              ++v97;
            }
            while (v97 < v173[0]);
            uint64_t v154 = (v154 + v97);
            CFMutableDictionaryRef Mutable = v150;
            uint64_t v89 = v159;
LABEL_91:
            free(v89);
LABEL_92:
            free(v165);
            int v72 = v76 + v155;
            uint64_t v53 = v162;
LABEL_45:
            uint64_t v73 = v167;
            goto LABEL_206;
          }
          sub_1B63F2F54(16, @"Error: Inconsistent index count after triangulation.", v90, v91, v92, v93, v94, v95, v143);
          uint64_t v89 = v159;
        }
        v56 -= v96;
        if (v89) {
          goto LABEL_91;
        }
        goto LABEL_92;
      }
      if (v49 * (unint64_t)(v77 + 1) <= Length)
      {
        uint64_t v78 = v162;
        if (v49 == 4)
        {
          int v101 = *(_DWORD *)&v162[4 * v77];
        }
        else if (v49 == 2)
        {
          int v101 = *(unsigned __int16 *)&v162[2 * v77];
        }
        else
        {
          int v101 = v162[v77];
        }
        int v163 = v101;
      }
      else
      {
        sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, (v72 + v73));
        int v163 = 0;
        uint64_t v78 = v162;
      }
      unsigned int v103 = v72 + v148;
      if (v49 * (unint64_t)(v72 + v148 + 1) <= Length)
      {
        if (v49 == 4)
        {
          int v104 = *(_DWORD *)&v78[4 * v103];
        }
        else if (v49 == 2)
        {
          int v104 = *(unsigned __int16 *)&v78[2 * v103];
        }
        else
        {
          int v104 = v78[v103];
        }
        int v144 = v104;
      }
      else
      {
        sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, (v72 + v148));
        int v144 = 0;
      }
      unsigned int v106 = v72 + v147;
      int v157 = v72;
      if (v49 * (unint64_t)(v72 + v147 + 1) > Length)
      {
        sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, (v72 + v147));
        int v107 = 0;
        goto LABEL_125;
      }
      if (v49 == 4)
      {
        int v107 = *(_DWORD *)&v78[4 * v106];
LABEL_125:
        unint64_t v108 = v161;
      }
      else
      {
        unint64_t v108 = v161;
        if (v49 == 2) {
          int v107 = *(unsigned __int16 *)&v78[2 * v106];
        }
        else {
          int v107 = v78[v106];
        }
      }
      int v112 = v154;
      uint64_t v113 = (v154 + 1);
      if (v49 * (unint64_t)v113 <= v108)
      {
        if (v49 == 4)
        {
          int v112 = v154;
          *(_DWORD *)&bytes[4 * v154] = v163;
        }
        else
        {
          int v112 = v154;
          if (v49 == 2) {
            *(_WORD *)&bytes[2 * v154] = v163;
          }
          else {
            bytes[v154] = v163;
          }
        }
      }
      else
      {
        sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v154);
        unint64_t v108 = v161;
      }
      uint64_t v117 = (v112 + 2);
      if (v49 * (unint64_t)v117 <= v108)
      {
        if (v49 == 4)
        {
          *(_DWORD *)&bytes[4 * v113] = v144;
        }
        else if (v49 == 2)
        {
          *(_WORD *)&bytes[2 * v113] = v144;
        }
        else
        {
          bytes[v113] = v144;
        }
      }
      else
      {
        sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v113);
        unint64_t v108 = v161;
      }
      int v158 = v157 + 3;
      uint64_t v154 = (v154 + 3);
      uint64_t v53 = v162;
      if (v49 * (unint64_t)v154 > v108)
      {
        sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v36, v37, v38, v39, v40, v41, v117);
        goto LABEL_171;
      }
      if (v49 == 4)
      {
        *(_DWORD *)&bytes[4 * v117] = v107;
LABEL_171:
        CFMutableDictionaryRef Mutable = v150;
        goto LABEL_204;
      }
      uint64_t v73 = v167;
      if (v49 == 2) {
        *(_WORD *)&bytes[2 * v117] = v107;
      }
      else {
        bytes[v117] = v107;
      }
      CFMutableDictionaryRef Mutable = v150;
LABEL_205:
      int v72 = v158;
LABEL_206:
      uint64_t v71 = v74;
      if (v74 != v73) {
        continue;
      }
      break;
    }
    CFDataRef v123 = CFDataCreateWithBytesNoCopy(allocator, bytes, v56 * 3 * v49, v152);
    uint64_t v62 = (_OWORD *)sub_1B63D0314();
    sub_1B63D05D4((uint64_t)v62, 0, v56, v123, v49, v124, v125, v126);
    CFRelease(v123);
    a2 = v145;
    if (!v62) {
      goto LABEL_216;
    }
LABEL_37:
    uint64_t v70 = sub_1B64ABD78(a1, v34);
    if (v70)
    {
      v62[11] = *(_OWORD *)(v70 + 176);
      v62[12] = *(_OWORD *)(v70 + 192);
    }
    CFArrayAppendValue(Mutable, v62);
    CFRelease(v62);
    ++v34;
  }
  CFArrayRef v19 = v171;
LABEL_219:
  CFRelease(v19);
  if (v31 != CFArrayGetCount(Mutable)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Consistency error: there must be as many renderable elements as original elements", v128, v129, v130, v131, v132, v133, (uint64_t)"elementCount == CFArrayGetCount(deindexedTriangleElements)");
  }
  *(void *)(a1 + 112) = v172;
  *(void *)(a1 + 144) = Mutable;
  uint64_t v134 = v170;
  *(_DWORD *)(a1 + 160) = v169;
  uint64_t v135 = v168;
  *(void *)(a1 + 168) = v134;
  *(void *)(a1 + 176) = v135;
  sub_1B64AABCC(a1);
  if ((a2 & 1) == 0) {
    sub_1B64AAE18(a1, v136, v137, v138, v139, v140, v141, v142);
  }
}

void sub_1B64F855C(uint64_t a1, CFMutableArrayRef *a2, __CFArray **a3, void *a4, _DWORD *a5, void *a6)
{
  float v6 = a6;
  BOOL v10 = a2;
  uint64_t v11 = a1;
  uint64_t v395 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  CFIndex v359 = CFArrayGetCount(*(CFArrayRef *)(v11 + 96));
  v373 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))Count;
  uint64_t v360 = v11;
  if (Count < 1)
  {
    uint64_t v21 = 0;
    goto LABEL_131;
  }
  BOOL v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  while (1)
  {
    unsigned __int8 v23 = sub_1B64ACE44(v11, v22, v14, v15, v16, v17, v18, v19);
    if (!v22)
    {
      uint64_t v21 = v23;
      goto LABEL_7;
    }
    if (v21 != v23) {
      break;
    }
LABEL_7:
    BOOL v20 = ++v22 >= (uint64_t)v373;
    if (v373 == (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v22) {
      goto LABEL_131;
    }
  }
  if (v20 || v359 < 1) {
    goto LABEL_131;
  }
  uint64_t v24 = sub_1B64ABD78(v11, 0);
  v348 = a4;
  if (!sub_1B63D1960(v24, v25, v26, v27, v28, v29, v30, v31)) {
    goto LABEL_20;
  }
  CFAllocatorRef v32 = v6;
  uint64_t v33 = 1;
  do
  {
    CFIndex v34 = v33;
    if (sub_1B63D11A8(v24) >= 2 && (byte_1E9DDB178 & 1) == 0)
    {
      byte_1E9DDB178 = 1;
      sub_1B63F2F54(16, @"Warning: Mesh element %p of mesh %p has %d channels but they all define the same topology", v14, v15, v16, v17, v18, v19, v24);
    }
    if (v359 == v34) {
      break;
    }
    uint64_t v24 = sub_1B64ABD78(v360, v34);
    int v42 = sub_1B63D1960(v24, v35, v36, v37, v38, v39, v40, v41);
    uint64_t v33 = v34 + 1;
  }
  while (v42);
  BOOL v43 = v34 < v359;
  float v6 = v32;
  uint64_t v11 = v360;
  if (!v43)
  {
LABEL_131:
    unsigned int v281 = sub_1B64ABD08(v11, v13, v14, v15, v16, v17, v18, v19);
    unsigned int v282 = v281;
    if (v281)
    {
      CFIndex v283 = 0;
      uint64_t v284 = v281;
      while (1)
      {
        uint64_t v285 = sub_1B64ABD78(v11, v283);
        unsigned int v286 = sub_1B63D11A8(v285);
        if (v286 <= v21)
        {
          sub_1B63F2F54(16, @"Unreachable code: Requested channel (%d) does not exist in element (%p)", v287, v288, v289, v290, v291, v292, v21);
          return;
        }
        if (v286 >= 2) {
          break;
        }
        if (v284 == ++v283) {
          goto LABEL_136;
        }
      }
      v350 = v10;
      v351 = a3;
      uint64_t v375 = *MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)v375, v282, MEMORY[0x1E4F1D510]);
      MutableCFArrayRef Copy = Mutable;
      CFIndex v296 = 0;
      uint64_t v374 = v21;
      v373 = &v378;
      CFAllocatorRef v372 = (CFAllocatorRef)*MEMORY[0x1E4F1CF90];
      if (v282 <= 1) {
        uint64_t v297 = 1;
      }
      else {
        uint64_t v297 = v282;
      }
      CFMutableArrayRef v371 = Mutable;
      CFAllocatorRef v370 = (const __CFAllocator *)v297;
      do
      {
        v298 = (CFDataRef *)sub_1B64ABD78(v11, v296);
        if (sub_1B63D11A8((uint64_t)v298) == 1)
        {
          CFArrayAppendValue(MutableCopy, v298);
        }
        else
        {
          int v306 = sub_1B63D0C08((uint64_t)v298, v299, v300, v301, v302, v303, v304, v305);
          unsigned int v307 = sub_1B63D11E8((uint64_t)v298);
          uint64_t v315 = sub_1B63D1BA0((uint64_t)v298, v308, v309, v310, v311, v312, v313, v314);
          unsigned int v323 = sub_1B63D0CA8((uint64_t)v298, v316, v317, v318, v319, v320, v321, v322);
          if (v306 == 4)
          {
            unint64_t v324 = v315 * (unint64_t)(v323 + v307);
            v325 = malloc_type_malloc(v324, 0xBA2B2CF1uLL);
            uint64_t v326 = v307;
            BytePtr = CFDataGetBytePtr(v298[12]);
            memcpy(v325, BytePtr, v307 * (unint64_t)v315);
          }
          else
          {
            unint64_t v324 = v323 * (unint64_t)v315;
            v325 = malloc_type_malloc(v324, 0x142254F0uLL);
            uint64_t v326 = v307;
            unsigned int v307 = 0;
          }
          v393[0] = 0;
          v393[1] = v393;
          v393[2] = 0x2000000000;
          int v394 = 0;
          uint64_t v392 = 0;
          long long v390 = 0u;
          long long v391 = 0u;
          long long v389 = 0u;
          sub_1B63D11F0((uint64_t)v298, v374, v328, v329, v330, v331, v332, v333, (uint64_t)&v389);
          long long v385 = v389;
          long long v386 = v390;
          long long v387 = v391;
          uint64_t v388 = v392;
          uint64_t v376 = MEMORY[0x1E4F143A8];
          uint64_t v377 = 0x40000000;
          v378 = sub_1B64F9708;
          v379 = &unk_1E6143700;
          unsigned int v384 = v307;
          v381 = v325;
          v380 = v393;
          uint64_t v382 = v315;
          unint64_t v383 = v324;
          sub_1B63D1BEC((uint64_t *)&v385, (uint64_t)&v376, v334, v335, v336, v337, v338, v339);
          CFDataRef v340 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)v375, (const UInt8 *)v325, v324, v372);
          v341 = (const void *)sub_1B63D0314();
          sub_1B63D05D4((uint64_t)v341, v306, v326, v340, v315, v342, v343, v344);
          MutableCFArrayRef Copy = v371;
          CFArrayAppendValue(v371, v341);
          CFRelease(v340);
          CFRelease(v341);
          _Block_object_dispose(v393, 8);
          uint64_t v11 = v360;
          uint64_t v297 = (uint64_t)v370;
        }
        ++v296;
      }
      while (v297 != v296);
      a3 = v351;
      BOOL v10 = v350;
      if (MutableCopy)
      {
LABEL_151:
        *BOOL v10 = CFArrayCreateMutableCopy((CFAllocatorRef)v375, 0, *(CFArrayRef *)(v11 + 64));
        *a3 = MutableCopy;
      }
    }
    else
    {
LABEL_136:
      CFArrayRef v293 = *(const __CFArray **)(v11 + 96);
      uint64_t v375 = *MEMORY[0x1E4F1CF80];
      MutableCFArrayRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)v375, 0, v293);
      if (MutableCopy) {
        goto LABEL_151;
      }
    }
  }
  else
  {
LABEL_20:
    v346 = a5;
    v347 = v6;
    v350 = v10;
    v351 = a3;
    CFAllocatorRef v44 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v45 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFIndex v46 = (CFIndex)v373;
    CFMutableArrayRef v355 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFIndex)v373, MEMORY[0x1E4F1D510]);
    CFAllocatorRef v370 = v44;
    CFArrayRef v354 = CFArrayCreateMutable(v44, v359, v45);
    uint64_t v345 = (uint64_t)&v345;
    MEMORY[0x1F4188790](v354, v47);
    uint64_t v48 = &v345 - 8 * v46;
    unsigned __int8 v49 = 0;
    LODWORD(v50) = 0;
    CFIndex v51 = 0;
    v349 = v48;
    do
    {
      uint64_t v52 = v360;
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v360 + 64), v51);
      uint64_t v61 = sub_1B641E1A8((uint64_t)ValueAtIndex, v54, v55, v56, v57, v58, v59, v60);
      unsigned __int8 v68 = sub_1B64ACE44(v52, v51, v62, v63, v64, v65, v66, v67);
      unsigned int v69 = sub_1B6534800(v61);
      int v70 = sub_1B6534654(v61);
      uint64_t v71 = sub_1B653465C(v61);
      uint64_t v79 = sub_1B63CA534(v70, v72, v73, v74, v75, v76, v77, v78);
      if (v70 == 14 && v71 == 3)
      {
        uint64_t v88 = 4 * sub_1B63CA534(14, v80, v81, v82, v83, v84, v85, v86);
        uint64_t v71 = 4;
      }
      else
      {
        uint64_t v88 = v79 * v71;
      }
      *uint64_t v48 = (uint64_t)ValueAtIndex;
      v48[1] = v61;
      *((unsigned char *)v48 + 16) = v68;
      v48[3] = v88;
      *((_WORD *)v48 + 16) = v70;
      v48[5] = v71;
      *((_DWORD *)v48 + 14) = 0;
      *((_DWORD *)v48 + 15) = v69;
      v48[6] = (uint64_t)malloc_type_malloc(v88 * v69, 0x97DC89ADuLL);
      int v96 = sub_1B641D56C((uint64_t)ValueAtIndex, v89, v90, v91, v92, v93, v94, v95);
      if (v96) {
        size_t v50 = v50;
      }
      else {
        size_t v50 = v69;
      }
      if (!v96) {
        unsigned __int8 v49 = v68;
      }
      ++v51;
      v48 += 8;
    }
    while (v373 != (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v51);
    long long v389 = 0uLL;
    *(void *)&long long v390 = 0;
    size_t v352 = v50;
    v368 = malloc_type_calloc(v50, 4uLL, 0x100004052888210uLL);
    *(void *)&long long v386 = 0;
    *((void *)&v385 + 1) = 0;
    *(void *)&long long v385 = (char *)&v385 + 8;
    uint64_t v103 = v360;
    int v104 = v355;
    if (v359 < 1) {
      goto LABEL_88;
    }
    CFIndex v105 = 0;
    int v365 = 0;
    uint64_t v367 = v49;
    v364 = &v390;
    CFAllocatorRef v353 = (CFAllocatorRef)*MEMORY[0x1E4F1CF90];
    v369 = (char **)(v349 + 6);
    CFAllocatorRef v106 = v370;
    do
    {
      uint64_t v107 = sub_1B64ABD78(v103, v105);
      int v115 = sub_1B63D0C08(v107, v108, v109, v110, v111, v112, v113, v114);
      uint64_t v116 = sub_1B63D11E8(v107);
      uint64_t v124 = sub_1B63D1BA0(v107, v117, v118, v119, v120, v121, v122, v123);
      unsigned int v132 = sub_1B63D0CA8(v107, v125, v126, v127, v128, v129, v130, v131);
      CFIndex v358 = v105;
      int v357 = v115;
      uint64_t v356 = v132;
      if (v115 == 4)
      {
        unint64_t v133 = (v132 + v116) * v124;
        uint64_t v134 = (UInt8 *)malloc_type_malloc(v133, 0x3EFDF2C3uLL);
        uint64_t v135 = CFDataGetBytePtr(*(CFDataRef *)(v107 + 96));
        v366 = v134;
        memcpy(v134, v135, v116 * v124);
        uint64_t v361 = v116;
      }
      else
      {
        unint64_t v133 = v132 * (unint64_t)v124;
        v366 = (const UInt8 *)malloc_type_malloc(v133, 0xD3679E4FuLL);
        uint64_t v361 = 0;
      }
      uint64_t v362 = v116;
      if (v116 < 1)
      {
        uint64_t v363 = 0;
      }
      else
      {
        uint64_t v142 = 0;
        uint64_t v363 = 0;
        CFAllocatorRef v372 = (CFAllocatorRef)v124;
        CFMutableArrayRef v371 = (CFMutableArrayRef)v133;
        do
        {
          uint64_t v375 = sub_1B63D1304(v107, v142, v136, v137, v138, v139, v140, v141);
          if (v375 >= 1)
          {
            uint64_t v143 = 0;
            uint64_t v374 = v363 + v361;
            do
            {
              int v144 = v386;
              uint64_t v376 = v107;
              uint64_t v377 = v142;
              v378 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v143;
              LODWORD(v379) = v386;
              int v145 = sub_1B64F9834((uint64_t **)&v385, &v376, (uint64_t)&v376);
              char v147 = v146;
              if (v124 * (unint64_t)(v374 + v143 + 1) <= v133)
              {
                int v185 = *((_DWORD *)v145 + 14);
                switch(v124)
                {
                  case 4:
                    *(_DWORD *)&v366[4 * (v374 + v143)] = v185;
                    break;
                  case 2:
                    *(_WORD *)&v366[2 * (v374 + v143)] = v185;
                    break;
                  case 1:
                    v366[(v374 + v143)] = v185;
                    break;
                  default:
                    sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", v136, v137, v138, v139, v140, v141, (uint64_t)"false");
                    break;
                }
              }
              else
              {
                sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", v136, v137, v138, v139, v140, v141, v374 + v143);
              }
              CFIndex v148 = (CFIndex)v373;
              int v149 = v369;
              if (v147)
              {
                do
                {
                  uint64_t v151 = *((unsigned int *)v149 + 2);
                  int v150 = *((_DWORD *)v149 + 3);
                  if (v150 == v151)
                  {
                    uint64_t v152 = (2 * v150);
                    *((_DWORD *)v149 + 3) = v152;
                    size_t v153 = (size_t)*(v149 - 3);
                    uint64_t v154 = (char *)malloc_type_realloc(*v149, v153 * v152, 0xDEE44663uLL);
                    *int v149 = v154;
                  }
                  else
                  {
                    uint64_t v154 = *v149;
                    size_t v153 = (size_t)*(v149 - 3);
                  }
                  int v155 = &v154[v153 * v151];
                  unsigned int v156 = sub_1B63D14A0(v107, v142, v143, *((unsigned __int8 *)v149 - 32), v138, v139, v140, v141);
                  int v163 = sub_1B6534808(*(v149 - 5), v156, v157, v158, v159, v160, v161, v162);
                  if (v163)
                  {
                    memcpy(v155, v163, v153);
                  }
                  else
                  {
                    bzero(v155, v153);
                    uint64_t v166 = (uint64_t)*(v149 - 6);
                    int v174 = sub_1B641D56C(v166, v167, v168, v169, v170, v171, v172, v173);
                    sub_1B641CDD4(v174);
                    sub_1B63F2F54(16, @"Error: Deindexer failed - Source %p (%@) has no original data at index %u", v175, v176, v177, v178, v179, v180, v166);
                  }
                  if (v151 != v144) {
                    sub_1B63F2F54(17, @"Assertion '%s' failed. Deindexer failed - Hash value inconsistency", v164, v165, v138, v139, v140, v141, (uint64_t)"value == sourceInfo.dataVectorCount");
                  }
                  *((_DWORD *)v149 + 2) = v151 + 1;
                  v149 += 8;
                  --v148;
                }
                while (v148);
                int v181 = sub_1B63D14A0(v107, v142, v143, v367, v138, v139, v140, v141);
                int v182 = v181;
                uint64_t v183 = (char *)*((void *)&v389 + 1);
                if (*((void *)&v389 + 1) >= (unint64_t)v390)
                {
                  float32x4_t v186 = (char *)v389;
                  uint64_t v187 = (uint64_t)(*((void *)&v389 + 1) - v389) >> 2;
                  unint64_t v188 = v187 + 1;
                  uint64_t v124 = (uint64_t)v372;
                  if ((unint64_t)(v187 + 1) >> 62) {
LABEL_153:
                  }
                    abort();
                  uint64_t v189 = v390 - v389;
                  if ((uint64_t)(v390 - v389) >> 1 > v188) {
                    unint64_t v188 = v189 >> 1;
                  }
                  if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFFCLL) {
                    unint64_t v190 = 0x3FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v190 = v188;
                  }
                  if (v190)
                  {
                    v191 = (char *)sub_1B64282E0((uint64_t)v364, v190);
                    uint64_t v183 = (char *)*((void *)&v389 + 1);
                    float32x4_t v186 = (char *)v389;
                  }
                  else
                  {
                    v191 = 0;
                  }
                  CFAllocatorRef v106 = v370;
                  v192 = &v191[4 * v187];
                  *(_DWORD *)v192 = v182;
                  uint64_t v184 = v192 + 4;
                  while (v183 != v186)
                  {
                    int v193 = *((_DWORD *)v183 - 1);
                    v183 -= 4;
                    *((_DWORD *)v192 - 1) = v193;
                    v192 -= 4;
                  }
                  *(void *)&long long v389 = v192;
                  *((void *)&v389 + 1) = v184;
                  *(void *)&long long v390 = &v191[4 * v190];
                  if (v186) {
                    operator delete(v186);
                  }
                }
                else
                {
                  **((_DWORD **)&v389 + 1) = v181;
                  uint64_t v184 = v183 + 4;
                  CFAllocatorRef v106 = v370;
                  uint64_t v124 = (uint64_t)v372;
                }
                *((void *)&v389 + 1) = v184;
                if (!v368[v182]) {
                  v368[v182] = (unint64_t)((unint64_t)v184 - v389) >> 2;
                }
              }
              else
              {
                int v365 = 1;
                CFAllocatorRef v106 = v370;
                uint64_t v124 = (uint64_t)v372;
              }
              ++v143;
              unint64_t v133 = (unint64_t)v371;
            }
            while (v143 != v375);
          }
          v363 += v375;
          ++v142;
        }
        while (v142 != v362);
      }
      if (v363 != v356) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Deindexing failed - Vertex count inconsistency", v136, v137, v138, v139, v140, v141, (uint64_t)"overallVertexIndex == (CFIndex)indexCount");
      }
      CFDataRef v194 = CFDataCreateWithBytesNoCopy(v106, v366, v133, v353);
      uint64_t v195 = (const void *)sub_1B63D0314();
      sub_1B63D05D4((uint64_t)v195, v357, v362, v194, v124, v196, v197, v198);
      CFArrayAppendValue(v354, v195);
      CFRelease(v195);
      CFRelease(v194);
      CFIndex v105 = v358 + 1;
      uint64_t v103 = v360;
      int v104 = v355;
    }
    while (v358 + 1 != v359);
    if ((v365 & 1) == 0) {
LABEL_88:
    }
      sub_1B63F2F54(0, @"Warning: Mesh %p has multiple channels but deindexing didn't have any effect", v97, v98, v99, v100, v101, v102, v103);
    size_t v199 = v352;
    if (v352)
    {
      uint64_t v200 = 0;
      char v201 = 0;
      int v202 = 0;
      float v203 = (char **)(v349 + 6);
      uint64_t v204 = v368;
      do
      {
        int v205 = v204[v200];
        if (v205)
        {
          int v206 = v205 - 1;
        }
        else
        {
          sub_1B63F2F54(0, @"Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element", v97, v98, v99, v100, v101, v102, v200);
          CFIndex v207 = (CFIndex)v373;
          uint64_t v208 = v203;
          if (v201)
          {
            char v201 = 1;
            int v206 = v202;
            int v104 = v355;
            size_t v199 = v352;
          }
          else
          {
            do
            {
              uint64_t v210 = *((unsigned int *)v208 + 2);
              int v209 = *((_DWORD *)v208 + 3);
              if (v209 == v210)
              {
                uint64_t v211 = (2 * v209);
                *((_DWORD *)v208 + 3) = v211;
                size_t v212 = (size_t)*(v208 - 3);
                int32x2_t v213 = (char *)malloc_type_realloc(*v208, v212 * v211, 0x20C5E437uLL);
                *uint64_t v208 = v213;
              }
              else
              {
                int32x2_t v213 = *v208;
                size_t v212 = (size_t)*(v208 - 3);
              }
              float v214 = &v213[v212 * v210];
              uint64_t v215 = sub_1B6534808(*(v208 - 5), 0, v97, v98, v99, v100, v101, v102);
              if (v215)
              {
                memcpy(v214, v215, v212);
              }
              else
              {
                bzero(v214, v212);
                uint64_t v216 = (uint64_t)*(v208 - 6);
                int v224 = sub_1B641D56C(v216, v217, v218, v219, v220, v221, v222, v223);
                sub_1B641CDD4(v224);
                sub_1B63F2F54(16, @"Error: Deindexer failed - Source %p (%@) has no original data at index %u", v225, v226, v227, v228, v229, v230, v216);
              }
              *((_DWORD *)v208 + 2) = v210 + 1;
              v208 += 8;
              --v207;
            }
            while (v207);
            uint64_t v231 = (char *)*((void *)&v389 + 1);
            if (*((void *)&v389 + 1) >= (unint64_t)v390)
            {
              uint64_t v233 = (char *)v389;
              uint64_t v234 = (uint64_t)(*((void *)&v389 + 1) - v389) >> 2;
              unint64_t v235 = v234 + 1;
              if ((unint64_t)(v234 + 1) >> 62) {
                goto LABEL_153;
              }
              uint64_t v236 = v390 - v389;
              if ((uint64_t)(v390 - v389) >> 1 > v235) {
                unint64_t v235 = v236 >> 1;
              }
              if ((unint64_t)v236 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v237 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v237 = v235;
              }
              if (v237)
              {
                uint64_t v238 = (char *)sub_1B64282E0((uint64_t)&v390, v237);
                uint64_t v231 = (char *)*((void *)&v389 + 1);
                uint64_t v233 = (char *)v389;
              }
              else
              {
                uint64_t v238 = 0;
              }
              int v104 = v355;
              uint64_t v239 = &v238[4 * v234];
              *(_DWORD *)uint64_t v239 = v200;
              uint64_t v232 = v239 + 4;
              while (v231 != v233)
              {
                int v240 = *((_DWORD *)v231 - 1);
                v231 -= 4;
                *((_DWORD *)v239 - 1) = v240;
                v239 -= 4;
              }
              *(void *)&long long v389 = v239;
              *((void *)&v389 + 1) = v232;
              *(void *)&long long v390 = &v238[4 * v237];
              if (v233) {
                operator delete(v233);
              }
            }
            else
            {
              **((_DWORD **)&v389 + 1) = v200;
              uint64_t v232 = v231 + 4;
              int v104 = v355;
            }
            size_t v199 = v352;
            *((void *)&v389 + 1) = v232;
            int v206 = ((unint64_t)((unint64_t)v232 - v389) >> 2) - 1;
            char v201 = 1;
            int v202 = v206;
          }
        }
        uint64_t v241 = v368;
        v368[v200] = v206;
        uint64_t v204 = v241;
        ++v200;
      }
      while (v200 != v199);
    }
    uint64_t v242 = (*((void *)&v389 + 1) - (void)v389) >> 2;
    size_t v243 = (*((void *)&v389 + 1) - v389) & 0x3FFFFFFFCLL;
    uint64_t v244 = malloc_type_malloc(v243, 0x2B0A4ADAuLL);
    memcpy(v244, (const void *)v389, v243);
    v252 = (__int16 *)(v349 + 4);
    CFIndex v253 = (CFIndex)v373;
    CFAllocatorRef v254 = v370;
    do
    {
      uint64_t v255 = *((unsigned int *)v252 + 6);
      __int16 v256 = sub_1B641D56C(*((void *)v252 - 4), v245, v246, v247, v248, v249, v250, v251);
      uint64_t v257 = *((void *)v252 - 1);
      CFDataRef v258 = CFDataCreate(v254, *((const UInt8 **)v252 + 2), v257 * v255);
      v260 = (const void *)sub_1B641D00C(v256, v258, *v252, *((void *)v252 + 1), v255, v257, 0, v259);
      CFArrayAppendValue(v104, v260);
      CFRelease(v260);
      CFRelease(v258);
      v252 += 32;
      --v253;
    }
    while (v253);
    v261 = (void **)(v349 + 6);
    CFIndex v262 = (CFIndex)v373;
    do
    {
      v263 = *v261;
      v261 += 8;
      free(v263);
      --v262;
    }
    while (v262);
    CFIndex v264 = CFArrayGetCount(v104);
    v271 = v351;
    v272 = v350;
    v273 = v346;
    if (v373 != (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v264) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Deindexing failed - Count of deindexed mesh sources does not match count of indexed mesh sources", v265, v266, v267, v268, v269, v270, (uint64_t)"sourceCount == CFArrayGetCount(deindexedSources)");
    }
    CFIndex v274 = CFArrayGetCount(v354);
    if (v359 != v274) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Deindexing failed - Count of deindexed mesh elements does not match count of indexed mesh elements", v275, v276, v277, v278, v279, v280, (uint64_t)"elementCount == CFArrayGetCount(deindexedElements)");
    }
    *v272 = v104;
    *v271 = v354;
    void *v348 = v244;
    _DWORD *v273 = v242;
    void *v347 = v368;
    sub_1B643670C((uint64_t)&v385, *((void **)&v385 + 1));
    if ((void)v389)
    {
      *((void *)&v389 + 1) = v389;
      operator delete((void *)v389);
    }
  }
}

void sub_1B64F9708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if (a4)
  {
    uint64_t v11 = 0;
    do
    {
      unsigned int v12 = v11 + *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + *(_DWORD *)(a1 + 64);
      uint64_t v13 = *(void *)(a1 + 48);
      if (v13 * (unint64_t)(v12 + 1) <= *(void *)(a1 + 56))
      {
        uint64_t v14 = *(void *)(a1 + 40);
        int v15 = *(_DWORD *)(a3 + 4 * v11);
        switch(v13)
        {
          case 4:
            *(_DWORD *)(v14 + 4 * v12) = v15;
            break;
          case 2:
            *(_WORD *)(v14 + 2 * v12) = v15;
            break;
          case 1:
            *(unsigned char *)(v14 + v12) = v15;
            break;
          default:
            sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", a3, a4, a5, a6, a7, a8, (uint64_t)"false");
            break;
        }
      }
      else
      {
        sub_1B63F2F54(16, @"Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)", a3, a4, a5, a6, a7, a8, v11 + (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + *(_DWORD *)(a1 + 64)));
      }
      ++v11;
    }
    while (v8 != v11);
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v8;
}

_OWORD *sub_1B64F9834(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = (void **)sub_1B64F98C8((uint64_t)a1, &v9, a2);
  float v6 = *v5;
  if (!*v5)
  {
    float v7 = (uint64_t **)v5;
    float v6 = operator new(0x40uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    sub_1B644FF08(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

void *sub_1B64F98C8(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint8x8_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        int v8 = v4;
        uint64_t v9 = v4 + 4;
        if (!sub_1B64F9968(v7, a3, v4 + 4)) {
          break;
        }
        uint8x8_t v4 = (void *)*v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_1B64F9968(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint8x8_t v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    int v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL sub_1B64F9968(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unsigned int v5 = sub_1B63D11A8(*a2);
  if (v5 != sub_1B63D11A8(*a3)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Two elements in the same mesh do not have the same number of index channels", v6, v7, v8, v9, v10, v11, (uint64_t)"channelCount == CFXMeshElementGetIndicesChannelCount(rhs.element)");
  }
  if (!v5) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t v13 = v5 - 1;
  do
  {
    uint64_t v14 = sub_1B63D14A0(*a2, a2[1], a2[2], v12, v8, v9, v10, v11);
    uint64_t v19 = sub_1B63D14A0(*a3, a3[1], a3[2], v12, v15, v16, v17, v18);
    BOOL result = v14 < v19;
  }
  while (v14 >= v19 && v14 <= v19 && v13 != v12++);
  return result;
}

BOOL sub_1B64F9EE8(void *a1, char *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = objc_msgSend_rangeOfString_(a1, a2, @".", a4);
  uint64_t v9 = v8;
  if (v8 == 1)
  {
    uint64_t v10 = v7;
    *(void *)a2 = objc_msgSend_substringWithRange_(a1, (const char *)1, 0, v7);
    uint64_t v14 = objc_msgSend_length(a1, v11, v12, v13);
    uint64_t v16 = objc_msgSend_substringWithRange_(a1, v15, v10 + 1, v14 + ~v10);
  }
  else
  {
    uint64_t v16 = 0;
    *(void *)a2 = a1;
  }
  *a3 = v16;
  return v9 == 1;
}

CFTypeRef sub_1B64F9F8C(void *a1)
{
  uint64_t v2 = sub_1B6540584();

  return sub_1B654085C(v2, a1);
}

void sub_1B64F9FC4(const void *a1, void *a2)
{
  uint64_t v4 = sub_1B6540584();

  sub_1B6540954(v4, a2, a1, v5, v6, v7, v8, v9);
}

uint64_t sub_1B64FA004(const void *a1, uint64_t a2)
{
  unint64_t v3 = (void *)sub_1B64BB4BC(a1);

  return objc_msgSend_vfx_CFXColorIgnoringColorSpace_success_(v3, v4, a2, 0);
}

double sub_1B64FA040(const void *a1)
{
  uint64_t v1 = (void *)sub_1B64BB4BC(a1);
  uint64_t v5 = (CGColor *)objc_msgSend_CGColor(v1, v2, v3, v4);
  if (!v5) {
    return 0.0;
  }

  return sub_1B63C9454(v5, v6, v7, v8, v9, v10, v11, v12);
}

uint64_t sub_1B64FA080(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_vfx_colorWithCFXColor_(MEMORY[0x1E4FB1618], a2, a1, a4);
}

uint64_t sub_1B64FA090(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (objc_msgSend_isEqualToString_(a1, a2, @"directional", a4)) {
    return 2;
  }
  if (objc_msgSend_isEqualToString_(a1, v5, @"spot", v6)) {
    return 3;
  }
  if (objc_msgSend_isEqualToString_(a1, v8, @"omni", v9)) {
    return 1;
  }
  if (objc_msgSend_isEqualToString_(a1, v10, @"ambient", v11)) {
    return 0;
  }
  if (objc_msgSend_isEqualToString_(a1, v12, @"area", v13)) {
    return 5;
  }
  if (objc_msgSend_isEqualToString_(a1, v14, @"ies", v15)) {
    return 6;
  }
  if ((objc_msgSend_isEqualToString_(a1, v16, @"probe", v17) & 1) == 0)
  {
    sub_1B63F2F54(16, @"Error: unknown legacy light type: %@", v18, v19, v20, v21, v22, v23, (uint64_t)a1);
    return 2;
  }
  return 4;
}

uint64_t sub_1B64FA18C(void *a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)sub_1B64BB4BC(cf);
  uint64_t v9 = (CGColor *)objc_msgSend_CGColor(v5, v6, v7, v8);
  if (v9) {
    *(double *)&long long v17 = sub_1B63C9454(v9, (uint64_t)v10, v11, v12, v13, v14, v15, v16);
  }
  else {
    long long v17 = xmmword_1B6E4F370;
  }
  long long v19 = v17;
  return objc_msgSend_encodeBytes_length_forKey_(a1, v10, (uint64_t)&v19, 16, a3);
}

uint64_t sub_1B64FA21C(void *a1, const char *a2)
{
  uint64_t v10 = 0;
  uint64_t v2 = (float32x4_t *)objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v10);
  float32x4_t v3 = 0uLL;
  if (v10 == 16) {
    float32x4_t v3 = *v2;
  }
  CGColorRef v4 = sub_1B63C9830(v3);
  if (!v4) {
    return 0;
  }
  CGColorRef v7 = v4;
  uint64_t v8 = objc_msgSend_colorWithCGColor_(MEMORY[0x1E4FB1618], v5, (uint64_t)v4, v6);
  CFRelease(v7);
  return v8;
}

uint64_t sub_1B64FA298(void *a1, const char *a2, double a3)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  *(double *)CGColorRef v4 = a3;
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)v4, 8, a2);
}

uint64_t sub_1B64FA2F4(void *a1, const char *a2, __n128 a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a3.n128_u64[0];
  unsigned __int32 v5 = a3.n128_u32[2];
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)&v4, 12, a2);
}

uint64_t sub_1B64FA35C(void *a1, const char *a2, __n128 a3)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  __n128 v4 = a3;
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)&v4, 16, a2);
}

uint64_t sub_1B64FA3B8(void *a1, const char *a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  v7[0] = a3;
  v7[1] = a4;
  uint64_t v7[2] = a5;
  v7[3] = a6;
  return objc_msgSend_encodeBytes_length_forKey_(a1, a2, (uint64_t)v7, 64, a2);
}

double sub_1B64FA3EC(void *a1, const char *a2)
{
  uint64_t v4 = 0;
  uint64_t v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v4);
  double result = 0.0;
  if (v4 == 8) {
    return *(double *)v2;
  }
  return result;
}

double sub_1B64FA42C(void *a1, const char *a2)
{
  uint64_t v4 = 0;
  uint64_t v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v4);
  double result = 0.0;
  if (v4 == 12) {
    return *(double *)v2;
  }
  return result;
}

__n128 sub_1B64FA474(void *a1, const char *a2)
{
  uint64_t v4 = 0;
  uint64_t v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v4);
  result.n128_u64[0] = 0;
  if (v4 == 16) {
    return *(__n128 *)v2;
  }
  return result;
}

__n128 sub_1B64FA4B4(void *a1, const char *a2)
{
  uint64_t v5 = 0;
  uint64_t v2 = objc_msgSend_decodeBytesForKey_returnedLength_(a1, a2, (uint64_t)a2, (uint64_t)&v5);
  if (v5 == 64) {
    float32x4_t v3 = (long long *)v2;
  }
  else {
    float32x4_t v3 = &VFXMatrix4Identity;
  }
  return (__n128)*v3;
}

uint64_t sub_1B64FA4FC(void *a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], (const char *)a2, a3, a4);
  int v7 = *a2;
  uint64_t v10 = objc_msgSend_numberWithInt_(NSNumber, v8, *a2, v9);
  objc_msgSend_setValue_forKey_(v6, v11, v10, @"type");
  uint64_t v12 = (double *)*((void *)a2 + 1);
  uint64_t v23 = objc_msgSend_array(MEMORY[0x1E4F1CA48], v13, v14, v15);
  switch(v7)
  {
    case 0:
    case 1:
      uint64_t v24 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E4F29238], v16, v17, v18, *v12, v12[1]);
      goto LABEL_6;
    case 2:
      uint64_t v27 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E4F29238], v16, v17, v18, *v12, v12[1]);
      objc_msgSend_addObject_(v23, v28, v27, v29);
      uint64_t v24 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E4F29238], v30, v31, v32, v12[2], v12[3]);
      goto LABEL_6;
    case 3:
      uint64_t v33 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E4F29238], v16, v17, v18, *v12, v12[1]);
      objc_msgSend_addObject_(v23, v34, v33, v35);
      uint64_t v39 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E4F29238], v36, v37, v38, v12[2], v12[3]);
      objc_msgSend_addObject_(v23, v40, v39, v41);
      uint64_t v24 = objc_msgSend_VFX_valueWithCGPoint_(MEMORY[0x1E4F29238], v42, v43, v44, v12[4], v12[5]);
LABEL_6:
      objc_msgSend_addObject_(v23, v25, v24, v26);
      break;
    case 4:
      break;
    default:
      sub_1B63F2F54(0, @"Warning: CGPath archiving: unknown path element type", v17, v18, v19, v20, v21, v22, v48);
      break;
  }
  objc_msgSend_setValue_forKey_(v6, v16, (uint64_t)v23, @"points");

  return objc_msgSend_addObject_(a1, v45, (uint64_t)v6, v46);
}

CGPath *sub_1B64FA680(void *a1)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  CFMutableDictionaryRef Mutable = CGPathCreateMutable();
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  uint64_t v4 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v3, (uint64_t)&v75, (uint64_t)v79, 16);
  if (v4)
  {
    uint64_t v7 = v4;
    uint64_t v8 = *(void *)v76;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v76 != v8) {
          objc_enumerationMutation(a1);
        }
        uint64_t v10 = *(void **)(*((void *)&v75 + 1) + 8 * i);
        uint64_t v11 = objc_msgSend_objectForKey_(v10, v5, @"type", v6);
        int v15 = objc_msgSend_intValue(v11, v12, v13, v14);
        uint64_t v18 = objc_msgSend_objectForKey_(v10, v16, @"points", v17);
        uint64_t v19 = v18;
        switch(v15)
        {
          case 0:
            uint64_t v20 = objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v20, v21, v22, v23);
            CGPathMoveToPoint(Mutable, 0, v24, v25);
            break;
          case 1:
            uint64_t v26 = objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v26, v27, v28, v29);
            CGPathAddLineToPoint(Mutable, 0, v30, v31);
            break;
          case 2:
            uint64_t v32 = objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v32, v33, v34, v35);
            CGFloat v37 = v36;
            CGFloat v39 = v38;
            int v42 = objc_msgSend_objectAtIndex_(v19, v40, 1, v41);
            objc_msgSend_VFX_CGPointValue(v42, v43, v44, v45);
            CGPathAddQuadCurveToPoint(Mutable, 0, v37, v39, v46, v47);
            break;
          case 3:
            uint64_t v48 = objc_msgSend_objectAtIndex_(v18, v5, 0, v6);
            objc_msgSend_VFX_CGPointValue(v48, v49, v50, v51);
            CGFloat v53 = v52;
            CGFloat v55 = v54;
            uint64_t v58 = objc_msgSend_objectAtIndex_(v19, v56, 1, v57);
            objc_msgSend_VFX_CGPointValue(v58, v59, v60, v61);
            CGFloat v63 = v62;
            CGFloat v65 = v64;
            unsigned __int8 v68 = objc_msgSend_objectAtIndex_(v19, v66, 2, v67);
            objc_msgSend_VFX_CGPointValue(v68, v69, v70, v71);
            CGPathAddCurveToPoint(Mutable, 0, v53, v55, v63, v65, v72, v73);
            break;
          case 4:
            CGPathCloseSubpath(Mutable);
            break;
          default:
            continue;
        }
      }
      uint64_t v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v5, (uint64_t)&v75, (uint64_t)v79, 16);
    }
    while (v7);
  }
  return Mutable;
}

uint64_t sub_1B64FA904(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t result = objc_msgSend_CGPath(a2, (const char *)a2, a3, a4);
  if (result)
  {
    uint64_t v11 = (const CGPath *)result;
    uint64_t v12 = objc_msgSend_array(MEMORY[0x1E4F1CA48], v8, v9, v10);
    CGPathApply(v11, v12, (CGPathApplierFunction)sub_1B64FA4FC);
    objc_msgSend_flatness(a2, v13, v14, v15);
    *(float *)&double v16 = v16;
    v23[0] = @"path";
    v23[1] = @"flatness";
    v24[0] = v12;
    v24[1] = objc_msgSend_numberWithFloat_(NSNumber, v17, v18, v19, v16);
    uint64_t v21 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v20, (uint64_t)v24, (uint64_t)v23, 2);
    return objc_msgSend_encodeObject_forKey_(a1, v22, v21, a3);
  }
  return result;
}

void *sub_1B64FAA08(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v11 = objc_msgSend_setWithObjects_(v4, v9, v5, v10, v6, v7, v8, 0);
  uint64_t v13 = objc_msgSend_decodeObjectOfClasses_forKey_(a1, v12, v11, a2);
  objc_opt_class();
  float v16 = -1.0;
  if (objc_opt_isKindOfClass())
  {
    uint64_t v17 = objc_msgSend_valueForKey_(v13, v14, @"flatness", v15);
    objc_msgSend_floatValue(v17, v18, v19, v20);
    float v16 = v21;
    uint64_t v13 = objc_msgSend_valueForKey_(v13, v22, @"path", v23);
  }
  CGFloat v24 = sub_1B64FA680(v13);
  if (!v24) {
    return 0;
  }
  uint64_t v27 = v24;
  uint64_t v28 = objc_msgSend_bezierPathWithCGPath_(MEMORY[0x1E4FB14C0], v25, (uint64_t)v24, v26);
  CFRelease(v27);
  if (v16 >= 0.0) {
    objc_msgSend_setFlatness_(v28, v29, v30, v31, v16);
  }
  return v28;
}

uint64_t sub_1B64FAB54(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(a2, (const char *)a2, a3, a4);
  uint64_t result = sub_1B6583544(v5, v6, v7, v8, v9, v10, v11, v12);
  if (result)
  {
    return objc_msgSend_encodeObject_forKey_(a1, v14, result, @"entityID");
  }
  return result;
}

CFTypeRef sub_1B64FABB0(void *a1, void *a2)
{
  uint64_t v4 = objc_opt_class();
  CFTypeRef result = (CFTypeRef)objc_msgSend_decodeObjectOfClass_forKey_(a1, v5, v4, @"entityID");
  if (result)
  {
    uint64_t v10 = result;
    uint64_t v11 = objc_msgSend___CFObject(a2, v7, v8, v9);
    return sub_1B65835F8(v11, v10, v12, v13, v14, v15, v16, v17);
  }
  return result;
}

uint64_t sub_1B64FAC24(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1B64D98D8(a2);
  if (result) {
    return objc_msgSend_encodeObject_forKey_(a1, v6, result, a3);
  }
  return result;
}

uint64_t sub_1B64FAC90(void *a1, const char *a2, uint64_t a3)
{
  uint64_t result = objc_msgSend_archivedDataWithRootObject_requiringSecureCoding_error_(MEMORY[0x1E4F28DB0], a2, (uint64_t)a2, 1, 0);
  if (result) {
    return objc_msgSend_encodeObject_forKey_(a1, v6, result, a3);
  }
  return result;
}

uint64_t sub_1B64FAD0C(void *a1, uint64_t a2, void *a3)
{
  float32x4_t v3 = a3;
  if (a3)
  {
    uint64_t v6 = objc_opt_class();
    uint64_t v9 = objc_msgSend_setByAddingObject_(v3, v7, v6, v8);
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v12 = objc_opt_class();
    uint64_t v9 = objc_msgSend_setWithObject_(v11, v13, v12, v14);
  }
  uint64_t v15 = objc_msgSend_decodeObjectOfClasses_forKey_(a1, v10, v9, a2);
  if (v15)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if (objc_msgSend_requiresSecureCoding(a1, v16, v17, v18))
      {
        id v20 = objc_alloc(MEMORY[0x1E4F28DC0]);
        uint64_t v23 = objc_msgSend_initForReadingFromData_error_(v20, v21, v15, 0);
        if (!v3)
        {
          if (qword_1E9DDB1A8 != -1) {
            dispatch_once(&qword_1E9DDB1A8, &unk_1F0FB6168);
          }
          float32x4_t v3 = (void *)qword_1E9DDB1A0;
        }
        uint64_t v15 = objc_msgSend_decodeObjectOfClasses_forKey_(v23, v22, (uint64_t)v3, *MEMORY[0x1E4F284E8]);
        objc_msgSend_finishDecoding(v23, v24, v25, v26);
      }
      else
      {
        return objc_msgSend_unarchivedObjectOfClasses_fromData_error_(MEMORY[0x1E4F28DC0], v19, (uint64_t)v3, v15, 0);
      }
    }
  }
  return v15;
}

void sub_1B64FAE54(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1B64FAE24);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1B64FAE78()
{
  if (qword_1E9DDB1A8 != -1) {
    dispatch_once(&qword_1E9DDB1A8, &unk_1F0FB6168);
  }
  return qword_1E9DDB1A0;
}

void *sub_1B64FAEBC(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = objc_msgSend_animationKeys(a2, (const char *)a2, a3, a4);
  if (v5)
  {
    uint64_t v9 = v5;
    if (objc_msgSend_count(v5, v6, v7, v8))
    {
      uint64_t v10 = (void *)MEMORY[0x1E4F1CA48];
      uint64_t v11 = objc_msgSend_count(v9, v6, v7, v8);
      uint64_t v14 = objc_msgSend_arrayWithCapacity_(v10, v12, v11, v13);
      uint64_t v15 = (void *)MEMORY[0x1E4F1CA48];
      uint64_t v19 = objc_msgSend_count(v9, v16, v17, v18);
      uint64_t v22 = objc_msgSend_arrayWithCapacity_(v15, v20, v19, v21);
      long long v75 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      uint64_t v24 = objc_msgSend_countByEnumeratingWithState_objects_count_(v9, v23, (uint64_t)&v75, (uint64_t)v82, 16);
      if (v24)
      {
        uint64_t v28 = v24;
        uint64_t v29 = *(void *)v76;
        do
        {
          for (uint64_t i = 0; i != v28; ++i)
          {
            if (*(void *)v76 != v29) {
              objc_enumerationMutation(v9);
            }
            uint64_t v31 = *(void *)(*((void *)&v75 + 1) + 8 * i);
            uint64_t v32 = objc_msgSend_animationPlayerForKey_(a2, v25, v31, v27);
            objc_msgSend_addObject_(v22, v33, v31, v34);
            objc_msgSend_addObject_(v14, v35, v32, v36);
          }
          uint64_t v28 = objc_msgSend_countByEnumeratingWithState_objects_count_(v9, v25, (uint64_t)&v75, (uint64_t)v82, 16);
        }
        while (v28);
      }
      if (objc_msgSend_count(v22, v25, v26, v27))
      {
        objc_msgSend_encodeObject_forKey_(a1, v6, (uint64_t)v14, @"animation-players");
        objc_msgSend_encodeObject_forKey_(a1, v37, (uint64_t)v22, @"animation-keys");
      }
    }
  }
  uint64_t result = objc_msgSend__vfxBindings(a2, v6, v7, v8);
  if (result)
  {
    int v42 = result;
    uint64_t v43 = (void *)MEMORY[0x1E4F1CA48];
    uint64_t v44 = objc_msgSend_count(result, v39, v40, v41);
    CGFloat v47 = objc_msgSend_arrayWithCapacity_(v43, v45, v44, v46);
    long long v71 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    uint64_t v49 = objc_msgSend_countByEnumeratingWithState_objects_count_(v42, v48, (uint64_t)&v71, (uint64_t)v81, 16);
    if (v49)
    {
      uint64_t v52 = v49;
      uint64_t v53 = *(void *)v72;
      do
      {
        for (uint64_t j = 0; j != v52; ++j)
        {
          if (*(void *)v72 != v53) {
            objc_enumerationMutation(v42);
          }
          CGFloat v55 = objc_msgSend_valueForKey_(v42, v50, *(void *)(*((void *)&v71 + 1) + 8 * j), v51);
          if (objc_msgSend_sourceObject(v55, v56, v57, v58))
          {
            v79[0] = @"sourceObject";
            v80[0] = objc_msgSend_sourceObject(v55, v50, v59, v51);
            v79[1] = @"keyPathSrc";
            v80[1] = objc_msgSend_keyPathSrc(v55, v60, v61, v62);
            v79[2] = @"keyPathDst";
            v80[2] = objc_msgSend_keyPathDst(v55, v63, v64, v65);
            uint64_t v67 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v66, (uint64_t)v80, (uint64_t)v79, 3);
            objc_msgSend_addObject_(v47, v68, v67, v69);
          }
        }
        uint64_t v52 = objc_msgSend_countByEnumeratingWithState_objects_count_(v42, v50, (uint64_t)&v71, (uint64_t)v81, 16);
      }
      while (v52);
    }
    return objc_msgSend_encodeObject_forKey_(a1, v50, (uint64_t)v47, @"bindings");
  }
  return result;
}

void *sub_1B64FB19C(void *a1, void *a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_opt_class();
  uint64_t v6 = objc_msgSend_vfx_decodeArrayOfObjectsOfClass_forKey_(a1, v5, v4, @"animation-keys");
  uint64_t v7 = objc_opt_class();
  uint64_t v9 = objc_msgSend_vfx_decodeArrayOfObjectsOfClass_forKey_(a1, v8, v7, @"animation-players");
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  uint64_t v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v10, (uint64_t)&v41, (uint64_t)v46, 16);
  if (v11)
  {
    uint64_t v14 = v11;
    uint64_t v15 = 0;
    uint64_t v16 = *(void *)v42;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v42 != v16) {
          objc_enumerationMutation(v6);
        }
        uint64_t v18 = *(void *)(*((void *)&v41 + 1) + 8 * i);
        uint64_t v19 = objc_msgSend_objectAtIndex_(v9, v12, v15 + i, v13);
        if (v19) {
          objc_msgSend_addAnimationPlayer_forKey_(a2, v12, v19, v18);
        }
      }
      uint64_t v14 = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v12, (uint64_t)&v41, (uint64_t)v46, 16);
      v15 += i;
    }
    while (v14);
  }
  if (qword_1E9DDB198 != -1) {
    dispatch_once(&qword_1E9DDB198, &unk_1F0FB60E8);
  }
  uint64_t result = objc_msgSend_vfx_decodeArrayOfObjectsOfClasses_forKey_(a1, v12, qword_1E9DDB190, @"bindings");
  obuint64_t j = result;
  if (result)
  {
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(result, v21, (uint64_t)&v37, (uint64_t)v45, 16);
    if (result)
    {
      uint64_t v24 = result;
      uint64_t v25 = *(void *)v38;
      do
      {
        uint64_t v26 = 0;
        do
        {
          if (*(void *)v38 != v25) {
            objc_enumerationMutation(obj);
          }
          uint64_t v27 = *(void **)(*((void *)&v37 + 1) + 8 * (void)v26);
          uint64_t v28 = objc_msgSend_objectForKeyedSubscript_(v27, v22, @"keyPathDst", v23);
          uint64_t v31 = objc_msgSend_objectForKeyedSubscript_(v27, v29, @"sourceObject", v30);
          uint64_t v34 = objc_msgSend_objectForKeyedSubscript_(v27, v32, @"keyPathSrc", v33);
          objc_msgSend_bindAnimatablePath_toObject_withKeyPath_options_(a2, v35, v28, v31, v34, 0);
          uint64_t v26 = (char *)v26 + 1;
        }
        while (v24 != v26);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v22, (uint64_t)&v37, (uint64_t)v45, 16);
        uint64_t v24 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t sub_1B64FB420()
{
  if (qword_1E9DDB198 != -1) {
    dispatch_once(&qword_1E9DDB198, &unk_1F0FB60E8);
  }
  return qword_1E9DDB190;
}

uint64_t sub_1B64FB464(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_path(a1, a2, a3, a4);
  uint64_t v8 = objc_msgSend_rangeOfString_(v5, v6, @".app/Contents/", v7);
  if (!v9 || (uint64_t v12 = objc_msgSend_substringFromIndex_(v5, v9, (uint64_t)&v9[v8], v11)) == 0)
  {
    uint64_t v12 = objc_msgSend_path(a1, v9, v10, v11);
    if (!v12) {
      return 0;
    }
  }
  uint64_t v13 = objc_msgSend_pathComponents(v12, v9, v10, v11);
  uint64_t v17 = objc_msgSend_count(v13, v14, v15, v16);
  if (!v17) {
    return 0;
  }
  uint64_t v21 = v17;
  CGFloat v63 = a1;
  uint64_t v22 = (void *)VFXGetResourceBundle(v17, v18, v19, v20);
  PathComponent = objc_msgSend_lastPathComponent(v12, v23, v24, v25);
  uint64_t v30 = objc_msgSend_stringByDeletingPathExtension(PathComponent, v27, v28, v29);
  uint64_t v34 = objc_msgSend_pathExtension(v12, v31, v32, v33);
  uint64_t v38 = v21 - 1;
  if (v21 == 1)
  {
LABEL_12:
    uint64_t v50 = (void *)MEMORY[0x1E4FB1818];
    uint64_t v51 = objc_msgSend_lastPathComponent(v63, v35, v36, v37);
    id v54 = (id)objc_msgSend_imageNamed_(v50, v52, v51, v53);
  }
  else
  {
    uint64_t v39 = v34;
    unint64_t v40 = 0;
    while (1)
    {
      unint64_t v43 = objc_msgSend_count(v13, v35, v36, v37) - 1;
      long long v44 = &stru_1F0FCDBB0;
      if (v43 > v40)
      {
        long long v44 = &stru_1F0FCDBB0;
        uint64_t v45 = v40;
        do
        {
          uint64_t v46 = objc_msgSend_objectAtIndex_(v13, v41, v45, v42);
          long long v44 = (__CFString *)objc_msgSend_stringByAppendingPathComponent_(v44, v47, v46, v48);
          ++v45;
        }
        while (v43 != v45);
      }
      uint64_t v49 = objc_msgSend_pathForResource_ofType_inDirectory_(v22, v41, v30, v39, v44);
      if (v49) {
        break;
      }
      if (++v40 == v38) {
        goto LABEL_12;
      }
    }
    uint64_t v59 = v49;
    id v60 = objc_alloc(MEMORY[0x1E4FB1818]);
    id v54 = (id)objc_msgSend_initWithContentsOfFile_(v60, v61, v59, v62);
  }

  return objc_msgSend_CGImage(v54, v55, v56, v57);
}

void *VFXResolveImageContents(void *a1, void *a2)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v7 = 0;
  }
  else
  {
    objc_opt_class();
    uint64_t v8 = 0;
    uint64_t v7 = a1;
    a1 = 0;
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      return (void *)v8;
    }
  }
  uint64_t v9 = objc_msgSend_scheme(a1, v4, v5, v6);
  if (objc_msgSend_isEqualToString_(v9, v10, @"imageNamed", v11))
  {
    uint64_t v15 = objc_msgSend_absoluteString(a1, v12, v13, v14);
  }
  else
  {
    if (v7) {
      goto LABEL_9;
    }
    if (!objc_msgSend_isFileURL(a1, v12, v13, v14) || objc_msgSend_query(a1, v12, v16, v14)) {
      goto LABEL_21;
    }
    uint64_t v15 = objc_msgSend_path(a1, v12, v16, v14);
  }
  uint64_t v7 = (void *)v15;
  if (!v15)
  {
LABEL_21:
    uint64_t v7 = 0;
    if (!a1) {
      return 0;
    }
    char v48 = 0;
    goto LABEL_23;
  }
LABEL_9:
  if (objc_msgSend_hasPrefix_(v7, v12, @"imageNamed://", v14))
  {
    uint64_t v19 = objc_msgSend_substringFromIndex_(v7, v17, 13, v18);
    uint64_t v22 = objc_msgSend_imageNamed_(MEMORY[0x1E4FB1818], v20, v19, v21);
    if (v22) {
      return (void *)v22;
    }
    else {
      return (void *)v19;
    }
  }
  uint64_t v23 = objc_msgSend_rangeOfString_(v7, v17, @".app/Contents/", v18);
  if (!v24
    || (uint64_t v23 = objc_msgSend_substringFromIndex_(v7, v24, (uint64_t)&v24[v23], v26)) == 0
    || (uint64_t v27 = (void *)v23,
        uint64_t v28 = (void *)VFXGetResourceBundle(v23, v24, v25, v26),
        uint64_t v32 = objc_msgSend_stringByDeletingPathExtension(v27, v29, v30, v31),
        uint64_t v36 = objc_msgSend_pathExtension(v27, v33, v34, v35),
        uint64_t v23 = objc_msgSend_URLForResource_withExtension_(v28, v37, v32, v36),
        (uint64_t v8 = v23) == 0))
  {
    uint64_t v38 = (void *)VFXGetResourceBundle(v23, v24, v25, v26);
    uint64_t v42 = objc_msgSend_stringByDeletingPathExtension(v7, v39, v40, v41);
    uint64_t v46 = objc_msgSend_pathExtension(v7, v43, v44, v45);
    uint64_t v8 = objc_msgSend_URLForResource_withExtension_(v38, v47, v42, v46);
    if (!v8)
    {
      if (!a1)
      {
        uint64_t v52 = objc_msgSend_fileURLWithPath_(MEMORY[0x1E4F1CB10], v12, (uint64_t)v7, v14);
        uint64_t v57 = (void *)v52;
        int v56 = 1;
        char v48 = 1;
LABEL_30:
        uint64_t v58 = (void *)VFXGetResourceBundle(v52, v53, v54, v55);
        uint64_t PathComponent = objc_msgSend_lastPathComponent(v57, v59, v60, v61);
        uint64_t v66 = objc_msgSend_pathExtension(v57, v63, v64, v65);
        uint64_t v8 = objc_msgSend_URLForResource_withExtension_(v58, v67, PathComponent, v66);
        if (!v8)
        {
          uint64_t v8 = (uint64_t)v57;
          if ((objc_msgSend_checkResourceIsReachableAndReturnError_(v57, v68, 0, v69) & 1) == 0)
          {
            char v72 = v48 ^ 1;
            if (!a2) {
              char v72 = 1;
            }
            if (v72) {
              goto LABEL_41;
            }
            long long v73 = objc_msgSend_URLByAppendingPathComponent_(a2, v70, (uint64_t)v7, v71);
            long long v77 = objc_msgSend_URLByStandardizingPath(v73, v74, v75, v76);
            if (v77 == v73
              || (uint64_t v8 = (uint64_t)v77, (objc_msgSend_checkResourceIsReachableAndReturnError_(v77, v78, 0, v79) & 1) == 0))
            {
              uint64_t v8 = (uint64_t)v73;
              if ((objc_msgSend_checkResourceIsReachableAndReturnError_(v73, v78, 0, v79) & 1) == 0)
              {
                uint64_t v83 = objc_msgSend_lastPathComponent(v7, v80, v81, v82);
                uint64_t v86 = objc_msgSend_URLByAppendingPathComponent_(a2, v84, v83, v85);
                uint64_t v90 = objc_msgSend_URLByStandardizingPath(v86, v87, v88, v89);
                if (v90 == v86
                  || (uint64_t v8 = (uint64_t)v90,
                      (objc_msgSend_checkResourceIsReachableAndReturnError_(v90, v91, 0, v92) & 1) == 0))
                {
                  uint64_t v8 = (uint64_t)v86;
                  if ((objc_msgSend_checkResourceIsReachableAndReturnError_(v86, v91, 0, v92) & 1) == 0)
                  {
LABEL_41:
                    if (v56) {
                      return v7;
                    }
                    else {
                      return a1;
                    }
                  }
                }
              }
            }
          }
        }
        return (void *)v8;
      }
      char v48 = 1;
LABEL_23:
      if (!objc_msgSend_isFileURL(a1, v12, v16, v14)) {
        return a1;
      }
      uint64_t v52 = objc_msgSend_query(a1, v49, v50, v51);
      if (v52) {
        return a1;
      }
      int v56 = 0;
      uint64_t v57 = a1;
      goto LABEL_30;
    }
  }
  return (void *)v8;
}

id sub_1B64FB914(id result)
{
  if (result)
  {
    uint64_t v1 = result;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v9 = objc_msgSend_valueForKey_(v1, v2, @"type", v4);
      if (objc_msgSend_isEqualToString_(v9, v10, @"MDLSkyCubeTexture", v11))
      {
        id v14 = objc_alloc(MEMORY[0x1E4F35C20]);
        uint64_t v17 = objc_msgSend_objectForKeyedSubscript_(v1, v15, @"name", v16);
        uint64_t v20 = objc_msgSend_objectForKeyedSubscript_(v1, v18, @"channelEncoding", v19);
        uint64_t v24 = objc_msgSend_integerValue(v20, v21, v22, v23);
        uint64_t v27 = objc_msgSend_objectForKeyedSubscript_(v1, v25, @"dimensions.x", v26);
        objc_msgSend_floatValue(v27, v28, v29, v30);
        unsigned int v167 = v31;
        uint64_t v34 = objc_msgSend_objectForKeyedSubscript_(v1, v32, @"dimensions.x", v33);
        objc_msgSend_floatValue(v34, v35, v36, v37);
        double v39 = COERCE_DOUBLE(vcvt_s32_f32((float32x2_t)__PAIR64__(v38, v167)));
        uint64_t v42 = objc_msgSend_objectForKeyedSubscript_(v1, v40, @"turbidity", v41);
        objc_msgSend_floatValue(v42, v43, v44, v45);
        int v47 = v46;
        uint64_t v50 = objc_msgSend_objectForKeyedSubscript_(v1, v48, @"sunElevation", v49);
        objc_msgSend_floatValue(v50, v51, v52, v53);
        int v55 = v54;
        uint64_t v58 = objc_msgSend_objectForKeyedSubscript_(v1, v56, @"upperAtmosphereScattering", v57);
        objc_msgSend_floatValue(v58, v59, v60, v61);
        int v63 = v62;
        uint64_t v66 = objc_msgSend_objectForKeyedSubscript_(v1, v64, @"groundAlbedo", v65);
        objc_msgSend_floatValue(v66, v67, v68, v69);
        LODWORD(v71) = v70;
        LODWORD(v72) = v47;
        LODWORD(v73) = v55;
        LODWORD(v74) = v63;
        uint64_t v76 = objc_msgSend_initWithName_channelEncoding_textureDimensions_turbidity_sunElevation_upperAtmosphereScattering_groundAlbedo_(v14, v75, v17, v24, v39, v72, v73, v74, v71);
        uint64_t v79 = objc_msgSend_objectForKeyedSubscript_(v1, v77, @"horizonElevation", v78);
        objc_msgSend_floatValue(v79, v80, v81, v82);
        objc_msgSend_setHorizonElevation_(v76, v83, v84, v85);
        uint64_t v88 = objc_msgSend_objectForKeyedSubscript_(v1, v86, @"gamma", v87);
        objc_msgSend_floatValue(v88, v89, v90, v91);
        objc_msgSend_setGamma_(v76, v92, v93, v94);
        uint64_t v97 = objc_msgSend_objectForKeyedSubscript_(v1, v95, @"exposure", v96);
        objc_msgSend_floatValue(v97, v98, v99, v100);
        objc_msgSend_setExposure_(v76, v101, v102, v103);
        CFAllocatorRef v106 = objc_msgSend_objectForKeyedSubscript_(v1, v104, @"brightness", v105);
        objc_msgSend_floatValue(v106, v107, v108, v109);
        objc_msgSend_setBrightness_(v76, v110, v111, v112);
        int v115 = objc_msgSend_objectForKeyedSubscript_(v1, v113, @"contrast", v114);
        objc_msgSend_floatValue(v115, v116, v117, v118);
        objc_msgSend_setContrast_(v76, v119, v120, v121);
        uint64_t v124 = objc_msgSend_objectForKeyedSubscript_(v1, v122, @"saturation", v123);
        objc_msgSend_floatValue(v124, v125, v126, v127);
        objc_msgSend_setSaturation_(v76, v128, v129, v130);
        uint64_t v133 = objc_msgSend_objectForKeyedSubscript_(v1, v131, @"groundColor", v132);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v136 = (void *)MEMORY[0x1E4F28DC0];
          uint64_t v137 = objc_opt_class();
          uint64_t v139 = objc_msgSend_unarchivedObjectOfClass_fromData_error_(v136, v138, v137, v133, 0);
          if (v139)
          {
            uint64_t v141 = objc_msgSend_CGColor(v139, v134, v140, v135);
            objc_msgSend_setGroundColor_(v76, v142, v141, v143);
          }
        }
        int v144 = objc_msgSend_objectForKeyedSubscript_(v1, v134, @"highDynamicRangeCompression.x", v135);
        objc_msgSend_floatValue(v144, v145, v146, v147);
        unsigned int v168 = v148;
        uint64_t v151 = objc_msgSend_objectForKeyedSubscript_(v1, v149, @"highDynamicRangeCompression.y", v150);
        objc_msgSend_floatValue(v151, v152, v153, v154);
        objc_msgSend_setHighDynamicRangeCompression_(v76, v155, v156, v157, COERCE_DOUBLE(__PAIR64__(v158, v168)));
        objc_msgSend_updateTexture(v76, v159, v160, v161);
        return v76;
      }
      else
      {
        uint64_t result = (id)objc_msgSend_valueForKey_(v1, v12, @"data", v13);
        if (!result)
        {
          uint64_t result = (id)objc_msgSend_valueForKey_(v1, v162, @"path", v163);
          if (!result)
          {
            return (id)objc_msgSend_valueForKey_(v1, v164, @"URL", v165);
          }
        }
      }
    }
    else
    {
      sub_1B63F2F54(16, @"Error: VFXDecodemage: invalid archive", v3, v4, v5, v6, v7, v8, v166);
      return 0;
    }
  }
  return result;
}

id sub_1B64FBCA0(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v5 = objc_opt_class();
  uint64_t v8 = objc_msgSend_setWithObject_(v4, v6, v5, v7);
  uint64_t v9 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v16 = objc_msgSend_setWithObjects_(v9, v14, v10, v15, v11, v12, v13, 0);
  uint64_t v18 = objc_msgSend_vfx_decodeDictionaryWithKeysOfClasses_objectsOfClasses_forKey_(a1, v17, v8, v16, a2);

  return sub_1B64FB914(v18);
}

uint64_t sub_1B64FBD7C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1B64FBDC4(a1, a3);

  return objc_msgSend_encodeObject_forKey_(a1, v5, (uint64_t)v6, a2);
}

void *sub_1B64FBDC4(void *a1, uint64_t a2)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v11 = objc_msgSend_options(a1, v4, v5, v6);
    id v14 = objc_msgSend_objectForKeyedSubscript_(v11, v12, @"VFXWorldExportEmbedImages", v13);
    int v18 = objc_msgSend_BOOLValue(v14, v15, v16, v17);
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = (void *)sub_1B6439EF8(a2, (uint64_t)v4, v5, v6, v7, v8, v9, v10);
  uint64_t v23 = (uint64_t)v19;
  if (v19)
  {
    uint64_t v24 = objc_msgSend_query(v19, v20, v21, v22);
    BOOL v28 = objc_msgSend_length(v24, v25, v26, v27) == 0;
  }
  else
  {
    BOOL v28 = 0;
  }
  uint64_t v29 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], v20, v21, v22);
  uint64_t v37 = v29;
  if (!v28 || v18)
  {
    uint64_t v45 = sub_1B643B460(a2, (uint64_t)v30, v31, v32, v33, v34, v35, v36);
    if (v45
      || (CGImageRef v47 = sub_1B643AA68(a2, (uint64_t)v38, v39, v40, v41, v42, v43, v44)) != 0
      && (uint64_t v50 = v47,
          uint64_t v51 = (UIImage *)objc_msgSend_imageWithCGImage_(MEMORY[0x1E4FB1818], v48, (uint64_t)v47, v49),
          uint64_t v45 = (uint64_t)UIImagePNGRepresentation(v51),
          CGImageRelease(v50),
          v45))
    {
      objc_msgSend_setObject_forKey_(v37, v38, v45, @"data");
    }
  }
  else
  {
    objc_msgSend_setObject_forKey_(v29, v30, v23, @"URL");
  }
  return v37;
}

void *sub_1B64FBEF4(void *result, const char *a2)
{
  if (a2) {
    return objc_msgSend_encodeObject_forKey_(result, a2, (uint64_t)a2, @"name");
  }
  return result;
}

uint64_t sub_1B64FBF0C()
{
  if (qword_1E9DDB188 != -1) {
    dispatch_once(&qword_1E9DDB188, &unk_1F0FB5B28);
  }
  return qword_1E9DDB180;
}

uint64_t sub_1B64FBF50()
{
  id v0 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t result = objc_msgSend_initWithObjects_(v0, v9, v1, v10, v2, v3, v4, v5, v6, v7, v8, 0);
  qword_1E9DDB180 = result;
  return result;
}

uint64_t sub_1B64FC03C()
{
  id v27 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v26 = objc_opt_class();
  uint64_t v25 = objc_opt_class();
  uint64_t v24 = objc_opt_class();
  uint64_t v23 = objc_opt_class();
  uint64_t v22 = objc_opt_class();
  uint64_t v21 = objc_opt_class();
  uint64_t v20 = objc_opt_class();
  uint64_t v19 = objc_opt_class();
  uint64_t v18 = objc_opt_class();
  uint64_t v17 = objc_opt_class();
  uint64_t v16 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  uint64_t v14 = objc_opt_class();
  uint64_t v0 = objc_opt_class();
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = (uint64_t)sub_1B650AC68();
  if (!v2) {
    uint64_t v2 = objc_opt_class();
  }
  uint64_t v3 = (uint64_t)sub_1B650AC74();
  if (!v3) {
    uint64_t v3 = objc_opt_class();
  }
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t result = objc_msgSend_initWithObjects_(v27, v11, v26, v12, v25, v24, v23, v22, v21, v20, v19, v18, v17, v16, v15, v14, v0, v1, v2,
             v3,
             v4,
             v5,
             v6,
             v7,
             v8,
             v9,
             v10,
             0);
  qword_1E9DDB190 = result;
  return result;
}

id sub_1B64FC2A4()
{
  void v6[2] = *MEMORY[0x1E4F143B8];
  if (qword_1E9DDB198 != -1) {
    dispatch_once(&qword_1E9DDB198, &unk_1F0FB60E8);
  }
  uint64_t v0 = (void *)qword_1E9DDB190;
  v6[0] = objc_opt_class();
  v6[1] = objc_opt_class();
  uint64_t v2 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v1, (uint64_t)v6, 2);
  id result = (id)objc_msgSend_setByAddingObjectsFromArray_(v0, v3, v2, v4);
  qword_1E9DDB1A0 = (uint64_t)result;
  return result;
}

void sub_1B64FC36C(void *a1, uint64_t a2, void *a3)
{
  v165[18] = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v9 = objc_msgSend_options(a1, v6, v7, v8);
    uint64_t v12 = objc_msgSend_objectForKeyedSubscript_(v9, v10, @"VFXWorldExportEmbedImages", v11);
    int v16 = objc_msgSend_BOOLValue(v12, v13, v14, v15) ^ 1;
  }
  else
  {
    int v16 = 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && v16)
  {
    uint64_t v20 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], v17, v18, v19);
    objc_msgSend_setObject_forKey_(v20, v21, (uint64_t)a3, @"path");
LABEL_7:
    objc_msgSend_encodeObject_forKey_(a1, v22, (uint64_t)v20, a2);
    return;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & v16) == 1)
  {
    uint64_t v26 = objc_msgSend_query(a3, v23, v24, v25);
    if (!objc_msgSend_length(v26, v27, v28, v29))
    {
      uint64_t v20 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], v30, v31, v32);
      objc_msgSend_setObject_forKey_(v20, v50, (uint64_t)a3, @"URL");
      goto LABEL_7;
    }
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if (objc_msgSend_groundColor(a3, v33, v34, v35))
    {
      uint64_t v39 = (void *)MEMORY[0x1E4FB1618];
      uint64_t v40 = objc_msgSend_groundColor(a3, v36, v37, v38);
      uint64_t v43 = objc_msgSend_colorWithCGColor_(v39, v41, v40, v42);
      uint64_t v45 = objc_msgSend_archivedDataWithRootObject_requiringSecureCoding_error_(MEMORY[0x1E4F28DB0], v44, v43, 1, 0);
    }
    else
    {
      uint64_t v45 = 0;
    }
    v165[0] = @"MDLSkyCubeTexture";
    v164[0] = @"type";
    v164[1] = @"name";
    uint64_t v51 = objc_msgSend_name(a3, v36, v37, v38);
    if (v51) {
      int v55 = (__CFString *)v51;
    }
    else {
      int v55 = &stru_1F0FCDBB0;
    }
    v165[1] = v55;
    v164[2] = @"turbidity";
    int v56 = NSNumber;
    objc_msgSend_turbidity(a3, v52, v53, v54);
    v165[2] = objc_msgSend_numberWithFloat_(v56, v57, v58, v59);
    v164[3] = @"sunElevation";
    uint64_t v60 = NSNumber;
    objc_msgSend_sunElevation(a3, v61, v62, v63);
    v165[3] = objc_msgSend_numberWithFloat_(v60, v64, v65, v66);
    v164[4] = @"upperAtmosphereScattering";
    uint64_t v67 = NSNumber;
    objc_msgSend_upperAtmosphereScattering(a3, v68, v69, v70);
    v165[4] = objc_msgSend_numberWithFloat_(v67, v71, v72, v73);
    v164[5] = @"groundAlbedo";
    double v74 = NSNumber;
    objc_msgSend_groundAlbedo(a3, v75, v76, v77);
    v165[5] = objc_msgSend_numberWithFloat_(v74, v78, v79, v80);
    v164[6] = @"horizonElevation";
    uint64_t v81 = NSNumber;
    objc_msgSend_horizonElevation(a3, v82, v83, v84);
    v165[6] = objc_msgSend_numberWithFloat_(v81, v85, v86, v87);
    v164[7] = @"gamma";
    uint64_t v88 = NSNumber;
    objc_msgSend_gamma(a3, v89, v90, v91);
    v165[7] = objc_msgSend_numberWithFloat_(v88, v92, v93, v94);
    v164[8] = @"exposure";
    uint64_t v95 = NSNumber;
    objc_msgSend_exposure(a3, v96, v97, v98);
    v165[8] = objc_msgSend_numberWithFloat_(v95, v99, v100, v101);
    v164[9] = @"brightness";
    uint64_t v102 = NSNumber;
    objc_msgSend_brightness(a3, v103, v104, v105);
    v165[9] = objc_msgSend_numberWithFloat_(v102, v106, v107, v108);
    v164[10] = @"contrast";
    uint64_t v109 = NSNumber;
    objc_msgSend_contrast(a3, v110, v111, v112);
    v165[10] = objc_msgSend_numberWithFloat_(v109, v113, v114, v115);
    v164[11] = @"saturation";
    uint64_t v116 = NSNumber;
    objc_msgSend_saturation(a3, v117, v118, v119);
    v165[11] = objc_msgSend_numberWithFloat_(v116, v120, v121, v122);
    v164[12] = @"channelEncoding";
    uint64_t v123 = NSNumber;
    uint64_t v127 = objc_msgSend_channelEncoding(a3, v124, v125, v126);
    v165[12] = objc_msgSend_numberWithInteger_(v123, v128, v127, v129);
    v164[13] = @"dimensions.x";
    uint64_t v130 = NSNumber;
    objc_msgSend_dimensions(a3, v131, v132, v133);
    v165[13] = objc_msgSend_numberWithInt_(v130, v135, v134, v136);
    v164[14] = @"dimensions.y";
    uint64_t v137 = NSNumber;
    objc_msgSend_dimensions(a3, v138, v139, v140);
    v165[14] = objc_msgSend_numberWithInt_(v137, v142, v141, v143);
    v164[15] = @"highDynamicRangeCompression.x";
    int v144 = NSNumber;
    objc_msgSend_highDynamicRangeCompression(a3, v145, v146, v147);
    v165[15] = objc_msgSend_numberWithFloat_(v144, v148, v149, v150);
    v164[16] = @"highDynamicRangeCompression.y";
    uint64_t v151 = NSNumber;
    objc_msgSend_highDynamicRangeCompression(a3, v152, v153, v154);
    LODWORD(v155) = HIDWORD(v155);
    uint64_t v159 = objc_msgSend_numberWithFloat_(v151, v156, v157, v158, v155);
    v164[17] = @"groundColor";
    if (v45) {
      uint64_t v161 = (__CFString *)v45;
    }
    else {
      uint64_t v161 = &stru_1F0FCDBB0;
    }
    v165[16] = v159;
    v165[17] = v161;
    uint64_t v162 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v160, (uint64_t)v165, (uint64_t)v164, 18);
    objc_msgSend_encodeObject_forKey_(a1, v163, v162, a2);
  }
  else
  {
    uint64_t v46 = objc_msgSend_copyCFXImageFromImage_(VFXMaterialProperty, v33, (uint64_t)a3, v35);
    if (v46)
    {
      CGImageRef v47 = (const void *)v46;
      char v48 = sub_1B64FBDC4(a1, v46);
      objc_msgSend_encodeObject_forKey_(a1, v49, (uint64_t)v48, a2);
      CFRelease(v47);
    }
  }
}

uint64_t sub_1B64FC890(void *a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = objc_msgSend_array(MEMORY[0x1E4F1CA48], a2, (uint64_t)a3, a4);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v9 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v8, (uint64_t)&v20, (uint64_t)v24, 16);
  if (v9)
  {
    uint64_t v12 = v9;
    uint64_t v13 = *(void *)v21;
    do
    {
      uint64_t v14 = 0;
      do
      {
        if (*(void *)v21 != v13) {
          objc_enumerationMutation(a3);
        }
        uint64_t v15 = objc_msgSend_copyCFXImageFromImage_(VFXMaterialProperty, v10, *(void *)(*((void *)&v20 + 1) + 8 * v14), v11);
        if (v15)
        {
          int v16 = sub_1B64FBDC4(a1, v15);
          objc_msgSend_addObject_(v7, v17, (uint64_t)v16, v18);
        }
        ++v14;
      }
      while (v12 != v14);
      uint64_t v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v10, (uint64_t)&v20, (uint64_t)v24, 16);
    }
    while (v12);
  }
  return objc_msgSend_encodeObject_forKey_(a1, v10, (uint64_t)v7, (uint64_t)a2);
}

void *sub_1B64FC9D0(void *a1, const char *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (qword_1E9DDB188 != -1) {
    dispatch_once(&qword_1E9DDB188, &unk_1F0FB5B28);
  }
  uint64_t v4 = objc_msgSend_decodeObjectOfClasses_forKey_(a1, a2, qword_1E9DDB180, (uint64_t)a2);
  if (!v4) {
    return 0;
  }
  uint64_t v8 = (void *)v4;
  uint64_t v9 = objc_msgSend_array(MEMORY[0x1E4F1CA48], v5, v6, v7);
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v10, (uint64_t)&v19, (uint64_t)v23, 16);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = *(void *)v20;
    do
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (*(void *)v20 != v13) {
          objc_enumerationMutation(v8);
        }
        id v15 = sub_1B64FB914(*(id *)(*((void *)&v19 + 1) + 8 * i));
        if (v15) {
          objc_msgSend_addObject_(v9, v16, (uint64_t)v15, v17);
        }
      }
      uint64_t v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v16, (uint64_t)&v19, (uint64_t)v23, 16);
    }
    while (v12);
  }
  return v9;
}

void *sub_1B64FCB28(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = objc_msgSend_mutableCopy(a1, a2, a3, a4);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v6, (uint64_t)&v20, (uint64_t)v24, 16);
  if (v7)
  {
    uint64_t v8 = v7;
    int v9 = 0;
    uint64_t v10 = *(void *)v21;
    do
    {
      uint64_t v11 = 0;
      uint64_t v12 = v9;
      do
      {
        if (*(void *)v21 != v10) {
          objc_enumerationMutation(a1);
        }
        uint64_t v13 = *(void **)(*((void *)&v20 + 1) + 8 * v11);
        if (objc_opt_respondsToSelector())
        {
          uint64_t v17 = objc_msgSend_VFXMutableDeepCopy(v13, v14, v15, v16);
          objc_msgSend_replaceObjectAtIndex_withObject_(v5, v18, v12 + v11, (uint64_t)v17);
        }
        ++v11;
      }
      while (v8 != v11);
      uint64_t v8 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v14, (uint64_t)&v20, (uint64_t)v24, 16);
      int v9 = v12 + v11;
    }
    while (v8);
  }
  return v5;
}

void *sub_1B64FCC6C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend_mutableCopy(a1, a2, a3, a4);
  uint64_t v8 = objc_msgSend_allKeys(v4, v5, v6, v7);
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v10 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v9, (uint64_t)&v22, (uint64_t)v26, 16);
  if (v10)
  {
    uint64_t v13 = v10;
    uint64_t v14 = *(void *)v23;
    do
    {
      for (uint64_t i = 0; i != v13; ++i)
      {
        if (*(void *)v23 != v14) {
          objc_enumerationMutation(v8);
        }
        uint64_t v16 = *(void *)(*((void *)&v22 + 1) + 8 * i);
        uint64_t v17 = objc_msgSend_objectForKey_(v4, v11, v16, v12);
        if (objc_opt_respondsToSelector())
        {
          long long v19 = objc_msgSend_VFXMutableDeepCopy(v17, v11, v18, v12);
          objc_msgSend_setValue_forKey_(v4, v20, (uint64_t)v19, v16);
        }
      }
      uint64_t v13 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v11, (uint64_t)&v22, (uint64_t)v26, 16);
    }
    while (v13);
  }
  return v4;
}

uint64_t sub_1B64FD404(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_valueForKey_(a1, a2, (uint64_t)a2, a4);
}

uint64_t sub_1B64FD40C(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_setValue_forKey_(a1, a2, a3, (uint64_t)a2);
}

uint64_t sub_1B64FD414(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_removeObjectForKey_(a1, a2, (uint64_t)a2, a4);
}

uint64_t sub_1B64FD41C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](a1, sel_applyFunction_withContext_, a2, a3);
}

VFXOrderedDictionary *sub_1B64FD428()
{
  return objc_alloc_init(VFXOrderedDictionary);
}

uint64_t sub_1B64FEBBC(uint64_t result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v4 = (void *)result;
    if (objc_msgSend_isEqualToString_((void *)result, a2, *MEMORY[0x1E4F39FB0], a4))
    {
      return 0;
    }
    else if (objc_msgSend_isEqualToString_(v4, v5, *MEMORY[0x1E4F39FA8], v6))
    {
      return 1;
    }
    else if (objc_msgSend_isEqualToString_(v4, v7, *MEMORY[0x1E4F39F98], v8))
    {
      return 2;
    }
    else
    {
      return 3;
    }
  }
  return result;
}

uint64_t sub_1B64FECAC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 0:
      uint64_t v8 = (uint64_t *)MEMORY[0x1E4F39FB0];
      goto LABEL_7;
    case 1:
      uint64_t v8 = (uint64_t *)MEMORY[0x1E4F39FA8];
      goto LABEL_7;
    case 2:
      uint64_t v8 = (uint64_t *)MEMORY[0x1E4F39F98];
      goto LABEL_7;
    case 3:
      uint64_t v8 = (uint64_t *)MEMORY[0x1E4F39FA0];
LABEL_7:
      uint64_t result = *v8;
      break;
    default:
      sub_1B63F2F54(16, @"Error: unknown fill mode", a3, a4, a5, a6, a7, a8, vars0);
      uint64_t result = 0;
      break;
  }
  return result;
}

void *sub_1B64FEE18(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t result = objc_msgSend_count(a1, a2, a3, a4);
  if (result)
  {
    uint64_t v8 = objc_msgSend_sortedArrayUsingComparator_(a1, v6, (uint64_t)&unk_1F0FB5B48, v7);
    size_t v12 = objc_msgSend_count(v8, v9, v10, v11);
    uint64_t v13 = (void *)sub_1B661A788(v12);
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    uint64_t v15 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v14, (uint64_t)&v35, (uint64_t)v39, 16);
    if (v15)
    {
      uint64_t v19 = v15;
      uint64_t v20 = *(void *)v36;
      do
      {
        for (uint64_t i = 0; i != v19; ++i)
        {
          if (*(void *)v36 != v20) {
            objc_enumerationMutation(v8);
          }
          long long v22 = *(void **)(*((void *)&v35 + 1) + 8 * i);
          objc_msgSend_time(v22, v16, v17, v18);
          double v24 = v23;
          uint64_t v28 = objc_msgSend_eventBlock(v22, v25, v26, v27);
          sub_1B661A810(v13, v28, v29, v30, v31, v32, v33, v34, v24);
        }
        uint64_t v19 = objc_msgSend_countByEnumeratingWithState_objects_count_(v8, v16, (uint64_t)&v35, (uint64_t)v39, 16);
      }
      while (v19);
    }
    return v13;
  }
  return result;
}

void *sub_1B64FEFC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v9 = sub_1B661AB84(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], v10, v9, v11);
  if (v9 >= 1)
  {
    for (uint64_t i = 0; i != v9; ++i)
    {
      float v20 = sub_1B661AC28(a1, i, v12, v13, v14, v15, v16, v17);
      uint64_t v27 = sub_1B661ABD0(a1, i, v21, v22, v23, v24, v25, v26);
      *(float *)&double v28 = v20;
      uint64_t v31 = objc_msgSend_animationEventWithKeyTime_block_(VFXAnimationEvent, v29, v27, v30, v28);
      objc_msgSend_addObject_(v18, v32, v31, v33);
    }
  }
  return v18;
}

uint64_t sub_1B64FF504(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if (objc_msgSend_fromValue(a1, v2, v3, v4))
    {
      uint64_t v8 = objc_msgSend_fromValue(a1, v5, v6, v7);
    }
    else if (objc_msgSend_toValue(a1, v5, v6, v7))
    {
      uint64_t v8 = objc_msgSend_toValue(a1, v28, v29, v30);
    }
    else
    {
      uint64_t v8 = objc_msgSend_byValue(a1, v28, v29, v30);
    }
    uint64_t v26 = (void *)v8;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      goto LABEL_12;
    }
    sub_1B63F2F54(0, @"Warning: unable to infer the type of a basic animation: %@", v17, v18, v31, v32, v33, v34, (uint64_t)a1);
    return 0;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  uint64_t v12 = objc_msgSend_values(a1, v9, v10, v11);
  if (!objc_msgSend_count(v12, v13, v14, v15)
    || (uint64_t v23 = objc_msgSend_values(a1, v16, v17, v18),
        uint64_t v26 = objc_msgSend_objectAtIndexedSubscript_(v23, v24, 0, v25),
        objc_opt_class(),
        (objc_opt_isKindOfClass() & 1) == 0))
  {
    sub_1B63F2F54(0, @"Warning: unable to infer the type of a keyframed animation: %@", v17, v18, v19, v20, v21, v22, (uint64_t)a1);
    return 0;
  }
LABEL_12:
  long long v35 = (const char *)objc_msgSend_objCType(v26, v27, v17, v18);

  return sub_1B6604568(v35);
}

uint64_t sub_1B64FF64C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_animationTimingFunction(VFXTransaction, a2, a3, a4);
  if (!result)
  {
    uint64_t v7 = (void *)MEMORY[0x1E4F39C10];
    uint64_t v8 = *MEMORY[0x1E4F3A480];
    return objc_msgSend_functionWithName_(v7, v5, v8, v6);
  }
  return result;
}

uint64_t sub_1B64FF69C(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_animationPlayerWithAnimationPlayerRef_(VFXAnimationPlayer, a2, (uint64_t)a2, a4);
  if (result)
  {
    return objc_msgSend_setValue_forKey_(a3, v7, result, a1);
  }
  return result;
}

_WORD *sub_1B64FF6FC(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 == 2)
  {
    sub_1B63F2F54(16, @"Error: animating between instances is not supported", a3, a4, a5, a6, a7, a8, v66);
    return 0;
  }
  int v8 = a3;
  uint64_t v9 = a2;
  if (!a2)
  {
    if (objc_msgSend_toValue(a1, a2, a3, a4))
    {
      uint64_t v14 = objc_msgSend_toValue(a1, v11, v12, v13);
LABEL_10:
      uint64_t v22 = (const char *)objc_msgSend_objCType(v14, v15, v16, v17);
      uint64_t v9 = (const char *)sub_1B6604568(v22);
      goto LABEL_11;
    }
    if (objc_msgSend_fromValue(a1, v11, v12, v13))
    {
      uint64_t v14 = objc_msgSend_fromValue(a1, v18, v19, v20);
      goto LABEL_10;
    }
    if (objc_msgSend_byValue(a1, v18, v19, v20))
    {
      uint64_t v14 = objc_msgSend_byValue(a1, v21, a3, a4);
      goto LABEL_10;
    }
    uint64_t v9 = 0;
  }
LABEL_11:
  uint64_t v23 = sub_1B65623D0((int)v9, 1, a3, a4, a5, a6, a7, a8);
  if (!v23) {
    return 0;
  }
  uint64_t v31 = (const void *)v23;
  uint64_t v32 = (void *)sub_1B6562568(v23, v24, v25, v26, v27, v28, v29, v30);
  uint64_t v33 = (_WORD *)sub_1B6494178();
  sub_1B64FF8A8(v33, a1, v34, v35);
  if (objc_msgSend_toValue(a1, v36, v37, v38))
  {
    uint64_t v42 = objc_msgSend_toValue(a1, v39, v40, v41);
    if (sub_1B64FF934(v42, v9, v8, v32)) {
      sub_1B6494324((uint64_t)v33, (uint64_t)v31, v40, v41, v43, v44, v45, v46);
    }
  }
  if (objc_msgSend_fromValue(a1, v39, v40, v41))
  {
    uint64_t v50 = objc_msgSend_fromValue(a1, v47, v48, v49);
    if (sub_1B64FF934(v50, v9, v8, v32)) {
      sub_1B6494414((uint64_t)v33, (uint64_t)v31, v48, v49, v51, v52, v53, v54);
    }
  }
  if (objc_msgSend_byValue(a1, v47, v48, v49))
  {
    uint64_t v58 = objc_msgSend_byValue(a1, v55, v56, v57);
    if (sub_1B64FF934(v58, v9, v8, v32)) {
      sub_1B6494504((uint64_t)v33, (uint64_t)v31, v59, v60, v61, v62, v63, v64);
    }
  }
  CFRelease(v31);

  return v33;
}

void sub_1B64FF8A8(_WORD *a1, void *a2, uint64_t a3, uint64_t a4)
{
  sub_1B65062EC(a1, a2, a3, a4);
  CFStringRef v9 = (const __CFString *)objc_msgSend_keyPath(a2, v6, v7, v8);
  CFStringRef v10 = sub_1B63CC80C(v9);
  sub_1B6492CA0((uint64_t)a1, v10);
  if (v10) {
    CFRelease(v10);
  }
  int isAdditive = objc_msgSend_isAdditive(a2, v11, v12, v13);
  sub_1B6493080((uint64_t)a1, isAdditive, v15, v16, v17, v18, v19, v20);
  int isCumulative = objc_msgSend_isCumulative(a2, v21, v22, v23);

  sub_1B6493138((uint64_t)a1, isCumulative, v25, v26, v27, v28, v29, v30);
}

uint64_t sub_1B64FF934(void *a1, const char *a2, int a3, void *a4)
{
  if (a2 == 5)
  {
    if (a3 == 2)
    {
      uint64_t v5 = objc_msgSend_copyCFXImageFromImage_(VFXMaterialProperty, a2, (uint64_t)a1, (uint64_t)a4);
      uint64_t result = 0;
      if (a4)
      {
        if (v5)
        {
          *a4 = v5;
          id v7 = v5;
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return sub_1B66047AC(a1, (uint64_t)a4, (uint64_t)a2, (uint64_t)a4);
  }
  return result;
}

_WORD *sub_1B64FF9CC(void *a1, uint64_t a2, char a3)
{
  uint64_t v205 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v13 = objc_msgSend_cfxAnimation(a1, v6, v7, v8);
    if (v13)
    {
      uint64_t v14 = v13;
      sub_1B64FFFA8(v13, a1, v7, v8, v9, v10, v11, v12);
      return (_WORD *)v14;
    }
  }
  if (!a2)
  {
    uint64_t v15 = objc_msgSend_values(a1, v6, v7, v8);
    if (objc_msgSend_count(v15, v16, v17, v18))
    {
      uint64_t v19 = objc_msgSend_values(a1, v6, v7, v8);
      uint64_t v22 = objc_msgSend_objectAtIndexedSubscript_(v19, v20, 0, v21);
      uint64_t v26 = (const char *)objc_msgSend_objCType(v22, v23, v24, v25);
      a2 = sub_1B6604568(v26);
    }
    else
    {
      a2 = 0;
    }
  }
  unint64_t v27 = sub_1B63CA534(a2, (uint64_t)v6, v7, v8, v9, v10, v11, v12);
  if (v27 >= 0x41)
  {
    uint64_t v185 = v27;
    uint64_t v35 = @"Error: CAKeyframeAnimationToCFXAnimation :: too large value to animate : %d bytes";
LABEL_10:
    sub_1B63F2F54(16, (uint64_t)v35, v29, v30, v31, v32, v33, v34, v185);
    return 0;
  }
  if (objc_msgSend_path(a1, v28, v29, v30))
  {
    NSLog(&cfstr_Cakeyframeanim.isa);
    return 0;
  }
  uint64_t v40 = objc_msgSend_values(a1, v36, v37, v38);
  unsigned int v44 = objc_msgSend_count(v40, v41, v42, v43);
  if (!v44)
  {
    uint64_t v35 = @"Error: CAKeyframeAnimation has no keyframe - skipping conversion";
    goto LABEL_10;
  }
  unsigned int v191 = v44;
  v192 = (_WORD *)sub_1B6437DF4();
  sub_1B64FF8A8(v192, a1, v45, v46);
  uint64_t v50 = objc_msgSend_keyTimes(a1, v47, v48, v49);
  uint64_t v54 = objc_msgSend_values(a1, v51, v52, v53);
  uint64_t v58 = objc_msgSend_timingFunctions(a1, v55, v56, v57);
  uint64_t v189 = objc_msgSend_calculationMode(a1, v59, v60, v61);
  uint64_t v65 = objc_msgSend_tensionValues(a1, v62, v63, v64);
  uint64_t v69 = objc_msgSend_continuityValues(a1, v66, v67, v68);
  uint64_t v73 = objc_msgSend_biasValues(a1, v70, v71, v72);
  uint64_t v196 = v58;
  unint64_t v197 = objc_msgSend_count(v50, v74, v75, v76);
  unint64_t v80 = objc_msgSend_count(v58, v77, v78, v79);
  uint64_t v195 = v65;
  unint64_t v84 = objc_msgSend_count(v65, v81, v82, v83);
  CFDataRef v194 = v69;
  unint64_t v88 = objc_msgSend_count(v69, v85, v86, v87);
  int v193 = v73;
  unint64_t v92 = objc_msgSend_count(v73, v89, v90, v91);
  objc_msgSend_duration(a1, v93, v94, v95);
  double v97 = v96;
  uint64_t v186 = *MEMORY[0x1E4F39D68];
  if (objc_msgSend_isEqualToString_(v189, v98, *MEMORY[0x1E4F39D68], v99))
  {
    char v190 = a3;
    BOOL v104 = a2 == 1 || a2 == 6;
LABEL_32:
    BOOL v187 = v104;
    if (objc_msgSend_count(v196, v100, v101, v102)) {
      int v111 = !v104;
    }
    else {
      int v111 = 1;
    }
    int v188 = v111;
    if (objc_msgSend_count(v196, v108, v109, v110)) {
      int v112 = v187;
    }
    else {
      int v112 = 0;
    }
    unsigned int v113 = v191;
    uint64_t v116 = (const void *)sub_1B642525C(v191, a2, v190, v111, v112);
    long long v203 = 0u;
    long long v204 = 0u;
    long long __src = 0u;
    long long v202 = 0u;
    if (v188)
    {
      unint64_t v117 = 0;
      double v118 = 0.0;
      while (v50)
      {
        if (v197 > v117)
        {
          uint64_t v119 = objc_msgSend_objectAtIndex_(v50, v114, v117, v115);
          objc_msgSend_doubleValue(v119, v120, v121, v122);
LABEL_44:
          double v118 = v97 * v123;
        }
        float v124 = 0.0;
        float v125 = 0.0;
        if (v84 > v117)
        {
          uint64_t v126 = objc_msgSend_objectAtIndex_(v195, v114, v117, v115);
          objc_msgSend_floatValue(v126, v127, v128, v129);
          float v125 = v130;
        }
        if (v88 > v117)
        {
          uint64_t v131 = objc_msgSend_objectAtIndex_(v194, v114, v117, v115);
          objc_msgSend_floatValue(v131, v132, v133, v134);
          float v124 = v135;
        }
        float v136 = 0.0;
        if (v92 > v117)
        {
          uint64_t v137 = objc_msgSend_objectAtIndex_(v193, v114, v117, v115);
          objc_msgSend_floatValue(v137, v138, v139, v140);
          float v136 = v141;
        }
        uint64_t v143 = objc_msgSend_objectAtIndex_(v54, v114, v117, v115);
        sub_1B66047AC(v143, (uint64_t)&__src, a2, v144);
        float v142 = v118;
        double v118 = v142;
        sub_1B6425394((uint64_t)v116, v117++, &__src, 0, 0, v145, v146, v147, v118, v125, v124, v136);
        if (v191 == v117) {
          goto LABEL_68;
        }
      }
      double v123 = (float)((float)v117 / (float)v191);
      goto LABEL_44;
    }
    goto LABEL_54;
  }
  char isEqualToString = objc_msgSend_isEqualToString_(v189, v100, *MEMORY[0x1E4F39D70], v102);
  BOOL v107 = a2 == 1 || a2 == 6;
  if (isEqualToString)
  {
    char v190 = a3;
    BOOL v104 = v107;
    goto LABEL_32;
  }
  unsigned int v113 = v191;
  uint64_t v116 = (const void *)sub_1B642525C(v191, a2, a3, 0, 0);
  long long v203 = 0u;
  long long v204 = 0u;
  long long __src = 0u;
  long long v202 = 0u;
LABEL_54:
  unint64_t v149 = 0;
  uint64_t v199 = 0;
  uint64_t v200 = 0;
  uint64_t v198 = 0;
  double v150 = 0.0;
  do
  {
    if (!v50)
    {
      double v155 = (float)((float)v149 / (float)v113);
      goto LABEL_59;
    }
    if (v197 > v149)
    {
      uint64_t v151 = objc_msgSend_objectAtIndex_(v50, v114, v149, v115);
      objc_msgSend_doubleValue(v151, v152, v153, v154);
LABEL_59:
      double v150 = v97 * v155;
    }
    uint64_t v156 = objc_msgSend_objectAtIndex_(v54, v114, v149, v115);
    sub_1B66047AC(v156, (uint64_t)&__src, a2, v157);
    if (a2 == 6 || (unsigned __int16)a2 == 1)
    {
      if (v80 > v149 && (uint64_t v163 = objc_msgSend_objectAtIndex_(v196, v158, v149, v159)) != 0)
      {
        uint64_t v165 = v163;
        uint64_t v166 = &v199;
        objc_msgSend_getControlPointAtIndex_values_(v163, v164, 1, (uint64_t)&v199);
        objc_msgSend_getControlPointAtIndex_values_(v165, v167, 2, (uint64_t)&v198);
        unsigned int v168 = &v200;
      }
      else
      {
        uint64_t v199 = 0;
        unsigned int v168 = &v200;
        uint64_t v166 = &v199;
      }
    }
    else
    {
      uint64_t v166 = 0;
      unsigned int v168 = 0;
    }
    float v169 = v150;
    double v150 = v169;
    sub_1B6425394((uint64_t)v116, v149, &__src, v168, v166, v160, v161, v162, v169, 0.0, 0.0, 0.0);
    uint64_t v200 = v198;
    ++v149;
  }
  while (v113 != v149);
LABEL_68:
  uint64_t v170 = objc_msgSend_calculationMode(a1, v114, v148, v115);
  if (v170 == *MEMORY[0x1E4F39D78])
  {
    char v178 = 0;
    unsigned int v177 = 1;
LABEL_77:
    sub_1B6425BCC((uint64_t)v116, v178, v171, v172, v173, v174, v175, v176);
    sub_1B6425C68((uint64_t)v116, v177, v179, v180, v181, v182, v183, v184);
    goto LABEL_78;
  }
  if (v170 == *MEMORY[0x1E4F39D90])
  {
    unsigned int v177 = 0;
LABEL_75:
    char v178 = 1;
    goto LABEL_77;
  }
  if (v170 == v186)
  {
    char v178 = 0;
    unsigned int v177 = 2;
    goto LABEL_77;
  }
  if (v170 == *MEMORY[0x1E4F39D70])
  {
    unsigned int v177 = 2;
    goto LABEL_75;
  }
LABEL_78:
  sub_1B6437E54((uint64_t)v192, (uint64_t)v116, v171, v172, v173, v174, v175, v176);
  CFRelease(v116);
  return v192;
}

uint64_t sub_1B64FFFA8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)sub_1B64937D0(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  objc_msgSend_delegate(a2, v10, v11, v12);
  uint64_t result = objc_opt_respondsToSelector();
  if (result) {
    *uint64_t v9 = sub_1B6503B60;
  }
  v9[1] = sub_1B6503D58;
  return result;
}

_WORD *sub_1B6500008(void *a1, void *a2)
{
  uint64_t v2 = sub_1B6500064(a1, a2);
  if (v2)
  {
    uint64_t v3 = sub_1B6540E1C();
    if (v3 == CFGetTypeID(v2))
    {
      uint64_t v11 = (void *)sub_1B654DF18((uint64_t)v2, v4, v5, v6, v7, v8, v9, v10);
      if (v11)
      {
        uint64_t v12 = v11;
        id v13 = v11;
        return v12;
      }
    }
  }
  return v2;
}

_WORD *sub_1B6500064(void *a1, void *a2)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      uint64_t v40 = (objc_class *)objc_opt_class();
      uint64_t v41 = NSStringFromClass(v40);
      sub_1B63F2F54(16, @"Error: Unsupported CAAnimation class (%@)", v42, v43, v44, v45, v46, v47, (uint64_t)v41);
      return 0;
    }
    uint64_t v8 = objc_msgSend_keyPath(a1, v5, v6, v7);
    CFArrayRef v13 = (const __CFArray *)objc_msgSend_copyAnimationChannelForKeyPath_animation_(a2, v9, v8, (uint64_t)a1);
    if (v13
      && (uint64_t v14 = objc_msgSend___CFObject(a2, v10, v11, v12), (v15 = sub_1B660C900(v14, v13, 1)) != 0)
      && (uint64_t v23 = (const void *)v15, sub_1B660F8C4(v15, v16, v17, v18, v19, v20, v21, v22)))
    {
      uint64_t v31 = (const char *)sub_1B660FA40((uint64_t)v23, v24, v25, v26, v27, v28, v29, v30);
      uint64_t v39 = sub_1B660F9A8((uint64_t)v23, v32, v33, v34, v35, v36, v37, v38);
      CFRelease(v23);
    }
    else
    {
      uint64_t v31 = 0;
      uint64_t v39 = 0;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v54 = sub_1B64FF6FC(a1, v31, v39, v49, v50, v51, v52, v53);
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        int v55 = (objc_class *)objc_opt_class();
        uint64_t v56 = NSStringFromClass(v55);
        sub_1B63F2F54(16, @"Error: Unsupported CAPropertyAnimation subclass (%@)", v57, v58, v59, v60, v61, v62, (uint64_t)v56);
        uint64_t v48 = 0;
LABEL_20:

        return v48;
      }
      uint64_t v54 = sub_1B64FF9CC(a1, (uint64_t)v31, v39);
    }
    uint64_t v48 = v54;
    if (v13 && v54) {
      sub_1B6492CA0((uint64_t)v54, v13);
    }
    goto LABEL_20;
  }

  return sub_1B65066A8(a1, (uint64_t)a2);
}

void *sub_1B6500244(const void *a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (v2 == sub_1B6437D6C())
    {
      if (sub_1B6437F0C((uint64_t)a1, v3, v4, v5, v6, v7, v8, v9))
      {
        uint64_t v17 = objc_alloc_init(VFXKeyframeAnimation);
        objc_msgSend_setCfxAnimation_(v17, v18, (uint64_t)a1, v19);
        uint64_t v20 = v17;
LABEL_8:
        uint64_t v21 = v20;
LABEL_31:
        float v129 = sub_1B6492D84((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
        objc_msgSend_setDuration_(v21, v130, v131, v132, v129);
        return v21;
      }
    }
    else
    {
      CFTypeID v22 = CFGetTypeID(a1);
      if (v22 == sub_1B6540E1C())
      {
        uint64_t v20 = (VFXKeyframeAnimation *)sub_1B650685C((uint64_t)a1);
        goto LABEL_8;
      }
      CFTypeID v23 = CFGetTypeID(a1);
      if (v23 == sub_1B649378C())
      {
        uint64_t v21 = objc_msgSend_animation(MEMORY[0x1E4F39B48], v24, v25, v26);
        uint64_t v34 = sub_1B6494490((uint64_t)a1, v27, v28, v29, v30, v31, v32, v33);
        if (v34)
        {
          uint64_t v42 = (const void *)v34;
          uint64_t v43 = (double *)sub_1B6562568(v34, v35, v36, v37, v38, v39, v40, v41);
          uint64_t v51 = (const char *)sub_1B65625B4((uint64_t)v42, v44, v45, v46, v47, v48, v49, v50);
          uint64_t v55 = sub_1B6604BA0(v43, v51, v54, v52, v53);
          if (v55) {
            objc_msgSend_setFromValue_(v21, v56, v55, v58);
          }
          else {
            sub_1B63F2F54(0, @"Warning: VFXSimpleAnimationToCABasicAnimation - can't convert startValue", v57, v58, v59, v60, v61, v62, v134);
          }
          CFRelease(v42);
        }
        uint64_t v71 = sub_1B64943A0((uint64_t)a1, v35, v36, v37, v38, v39, v40, v41);
        if (v71)
        {
          uint64_t v79 = (const void *)v71;
          unint64_t v80 = (double *)sub_1B6562568(v71, v72, v73, v74, v75, v76, v77, v78);
          unint64_t v88 = (const char *)sub_1B65625B4((uint64_t)v79, v81, v82, v83, v84, v85, v86, v87);
          uint64_t v92 = sub_1B6604BA0(v80, v88, v91, v89, v90);
          if (v92) {
            objc_msgSend_setToValue_(v21, v93, v92, v95);
          }
          else {
            sub_1B63F2F54(0, @"Warning: VFXSimpleAnimationToCABasicAnimation - can't convert endValue", v94, v95, v96, v97, v98, v99, v134);
          }
          CFRelease(v79);
        }
        uint64_t v100 = sub_1B6494580((uint64_t)a1, v72, v73, v74, v75, v76, v77, v78);
        if (v100)
        {
          uint64_t v108 = (const void *)v100;
          uint64_t v109 = (double *)sub_1B6562568(v100, v101, v102, v103, v104, v105, v106, v107);
          unint64_t v117 = (const char *)sub_1B65625B4((uint64_t)v108, v110, v111, v112, v113, v114, v115, v116);
          uint64_t v121 = sub_1B6604BA0(v109, v117, v120, v118, v119);
          if (v121) {
            objc_msgSend_setByValue_(v21, v122, v121, v124);
          }
          else {
            sub_1B63F2F54(0, @"Warning: VFXSimpleAnimationToCABasicAnimation - can't convert byValue", v123, v124, v125, v126, v127, v128, v134);
          }
          CFRelease(v108);
        }
        sub_1B650650C(v21, (uint64_t)a1, v102, v103, v104, v105, v106, v107);
        goto LABEL_31;
      }
      CFTypeID v63 = CFGetTypeID(a1);
      if (v63 == sub_1B654DC68())
      {
        uint64_t v70 = (const void *)sub_1B654DE60((uint64_t)a1);
        uint64_t v21 = sub_1B650685C((uint64_t)v70);
        if (v70) {
          CFRelease(v70);
        }
        goto LABEL_31;
      }
      sub_1B63F2F54(16, @"Error: CFXAnimationToCAAnimation: unsupported animation", v64, v65, v66, v67, v68, v69, v134);
    }
    uint64_t v21 = 0;
    goto LABEL_31;
  }
  return 0;
}

__CFString *sub_1B6500480(void *a1, __CFString *a2, uint64_t a3, uint64_t a4)
{
  if (!objc_msgSend_length(a2, (const char *)a2, a3, a4)) {
    return 0;
  }
  uint64_t v9 = objc_msgSend___CFObject(a1, v6, v7, v8);
  uint64_t v10 = (__CFString *)sub_1B63CC80C(a2);
  uint64_t v11 = sub_1B660C900(v9, (const __CFArray *)v10, 0);
  uint64_t v19 = (const void *)v11;
  if (v11 && sub_1B660F8C4(v11, v12, v13, v14, v15, v16, v17, v18))
  {
    uint64_t v20 = v10;
LABEL_12:
    CFRelease(v19);
    return v20;
  }
  uint64_t v21 = sub_1B6604FE8(a1, a2);
  if (v21
    && (uint64_t v25 = (__int16 *)v21,
        uint64_t v26 = (const void *)objc_msgSend___CFObject(a1, v22, v23, v24),
        sub_1B6583B18(v26))
    && (sub_1B6584BAC((uint64_t)v26, a2, v25, v27, v28, v29, v30, v31),
        CFRelease(v25),
        sub_1B6584D68((uint64_t)v26, a2, v32, v33, v34, v35, v36, v37)))
  {
    uint64_t v41 = (void *)MEMORY[0x1E4F1CA48];
    uint64_t v42 = objc_msgSend_count(v10, v38, v39, v40);
    uint64_t v20 = (__CFString *)(id)objc_msgSend_arrayWithCapacity_(v41, v43, v42 + 1, v44);
    objc_msgSend_addObject_(v20, v45, @"customProperty", v46);
    objc_msgSend_addObjectsFromArray_(v20, v47, (uint64_t)v10, v48);
  }
  else
  {
    uint64_t v20 = 0;
  }
  CFRelease(v10);
  if (v19) {
    goto LABEL_12;
  }
  return v20;
}

uint64_t sub_1B65005BC(void *a1, char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    if (a1) {
      goto LABEL_3;
    }
LABEL_10:
    sub_1B63F2F54(16, @"Error: can't add a NULL animation to %@", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)a2);
    return 0;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, a4, a5, a6, a7, a8, (uint64_t)"key");
  if (!a1) {
    goto LABEL_10;
  }
LABEL_3:
  uint64_t result = objc_msgSend_animationPlayerRef(a1, a2, (uint64_t)a3, a4);
  if (result)
  {
    uint64_t v15 = (uint64_t *)result;
    uint64_t v16 = objc_msgSend___CFObject(a2, v12, v13, v14);
    if (v16)
    {
      uint64_t v17 = v16;
      if ((sub_1B6583B18(v16) & 1) == 0) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. VFXAddAnimationGroup target is not an entity", v18, v19, v20, v21, v22, v23, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
      }
      sub_1B6583FDC(v17, v15, a3, v19, v20, v21, v22, v23);
    }
    return 1;
  }
  return result;
}

void sub_1B6500690(void *a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_1B6583B18(v5) & 1) == 0) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. VFXRemoveAnimation target is not an entity", v7, v8, v9, v10, v11, v12, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    }
    sub_1B6584118(v6, a2, 0, v8, v9, v10, v11, v12);
  }
}

void sub_1B6500714(void *a1, char *a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v7 = objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_1B6583B18(v7) & 1) == 0) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. VFXFadeAndRemoveAnimation target is not an entity", v9, v10, v11, v12, v13, v14, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    }
    sub_1B658436C(v8, a2, v9, v10, v11, v12, v13, v14, a5);
  }
}

void sub_1B65007A8(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v4)
  {
    uint64_t v5 = v4;
    if ((sub_1B6583B18(v4) & 1) == 0) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. VFXRemoveAllAnimations target is not an entity", v7, v8, v9, v10, v11, v12, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    }
    sub_1B65832C8(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

void sub_1B6500820(void *a1, const char *a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v6 = objc_msgSend___CFObject(a1, a2, a3, a4);
  if (v6)
  {
    uint64_t v7 = v6;
    if ((sub_1B6583B18(v6) & 1) == 0) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. VFXFadeAndRemoveAllAnimations target is not an entity", v9, v10, v11, v12, v13, v14, (uint64_t)"CFTypeIsCFXEntity(rootCF)");
    }
    sub_1B6584278(v7, v8, v9, v10, v11, v12, v13, v14, a5);
  }
}

uint64_t sub_1B65008AC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_valueForKey_(a1, a2, @"VFXAnimationFadeInDurationKey", a4);

  return objc_msgSend_floatValue(v4, v5, v6, v7);
}

uint64_t sub_1B65008DC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_numberWithFloat_(NSNumber, a2, a3, a4);

  return objc_msgSend_setValue_forKey_(a1, v5, v6, @"VFXAnimationFadeInDurationKey");
}

uint64_t sub_1B6500928(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_valueForKey_(a1, a2, @"VFXAnimationFadeOutDurationKey", a4);

  return objc_msgSend_floatValue(v4, v5, v6, v7);
}

uint64_t sub_1B6500958(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_numberWithFloat_(NSNumber, a2, a3, a4);

  return objc_msgSend_setValue_forKey_(a1, v5, v6, @"VFXAnimationFadeOutDurationKey");
}

uint64_t sub_1B65009A4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_valueForKey_(a1, a2, @"VFXAnimationCommitOnCompletion", a4);

  return objc_msgSend_BOOLValue(v4, v5, v6, v7);
}

uint64_t sub_1B65009D4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_numberWithBool_(NSNumber, a2, a3, a4);

  return objc_msgSend_setValue_forKey_(a1, v5, v6, @"VFXAnimationCommitOnCompletion");
}

void sub_1B6500A20(void *a1, const char *a2, void *a3, uint64_t a4)
{
  id v6 = (id)objc_msgSend_copy(a3, a2, (uint64_t)a3, a4);
  objc_msgSend_setValue_forKey_(a1, v5, (uint64_t)v6, @"VFXAnimationEventsKey");
}

uint64_t sub_1B6500A7C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_valueForKey_(a1, a2, @"VFXAnimationEventsKey", a4);
}

uint64_t sub_1B6500A88(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  return objc_msgSend_caAnimation(a3, a2, (uint64_t)a3, a4);
}

void *sub_1B6500A90(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v125 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = objc_msgSend_copy(a1, a2, a3, a4);
  uint64_t v9 = objc_msgSend_fillMode(a1, v6, v7, v8);
  objc_msgSend_setFillMode_(v5, v10, v9, v11);
  objc_msgSend_speed(a1, v12, v13, v14);
  objc_msgSend_setSpeed_(v5, v15, v16, v17);
  uint64_t v21 = objc_msgSend_autoreverses(a1, v18, v19, v20);
  objc_msgSend_setAutoreverses_(v5, v22, v21, v23);
  objc_msgSend_repeatCount(a1, v24, v25, v26);
  objc_msgSend_setRepeatCount_(v5, v27, v28, v29);
  uint64_t isRemovedOnCompletion = objc_msgSend_isRemovedOnCompletion(a1, v30, v31, v32);
  objc_msgSend_setRemovedOnCompletion_(v5, v34, isRemovedOnCompletion, v35);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v39 = objc_msgSend_keyPath(a1, v36, v37, v38);
      objc_msgSend_setKeyPath_(v5, v40, v39, v41);
      uint64_t isAdditive = objc_msgSend_isAdditive(a1, v42, v43, v44);
      objc_msgSend_setAdditive_(v5, v46, isAdditive, v47);
      uint64_t isCumulative = objc_msgSend_isCumulative(a1, v48, v49, v50);
      objc_msgSend_setCumulative_(v5, v52, isCumulative, v53);
    }
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v57 = objc_msgSend_calculationMode(a1, v54, v55, v56);
      objc_msgSend_setCalculationMode_(v5, v58, v57, v59);
      uint64_t v63 = objc_msgSend_values(a1, v60, v61, v62);
      objc_msgSend_setValues_(v5, v64, v63, v65);
      uint64_t v69 = objc_msgSend_keyTimes(a1, v66, v67, v68);
      objc_msgSend_setKeyTimes_(v5, v70, v69, v71);
    }
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      objc_msgSend_mass(a1, v72, v73, v74);
      objc_msgSend_setMass_(v5, v75, v76, v77);
      objc_msgSend_initialVelocity(a1, v78, v79, v80);
      objc_msgSend_setInitialVelocity_(v5, v81, v82, v83);
      objc_msgSend_stiffness(a1, v84, v85, v86);
      objc_msgSend_setStiffness_(v5, v87, v88, v89);
      objc_msgSend_damping(a1, v90, v91, v92);
      objc_msgSend_setDamping_(v5, v93, v94, v95);
    }
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v99 = objc_msgSend_animations(v5, v96, v97, v98);
    id v100 = objc_alloc(MEMORY[0x1E4F1CA48]);
    uint64_t v104 = objc_msgSend_count(v99, v101, v102, v103);
    uint64_t v107 = objc_msgSend_initWithCapacity_(v100, v105, v104, v106);
    long long v120 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    long long v123 = 0u;
    uint64_t v109 = objc_msgSend_countByEnumeratingWithState_objects_count_(v99, v108, (uint64_t)&v120, (uint64_t)v124, 16);
    if (v109)
    {
      uint64_t v113 = v109;
      uint64_t v114 = *(void *)v121;
      do
      {
        uint64_t v115 = 0;
        do
        {
          if (*(void *)v121 != v114) {
            objc_enumerationMutation(v99);
          }
          uint64_t v116 = objc_msgSend_vfx_deepCopy(*(void **)(*((void *)&v120 + 1) + 8 * v115), v110, v111, v112);
          objc_msgSend_addObject_(v107, v117, (uint64_t)v116, v118);

          ++v115;
        }
        while (v113 != v115);
        uint64_t v113 = objc_msgSend_countByEnumeratingWithState_objects_count_(v99, v110, (uint64_t)&v120, (uint64_t)v124, 16);
      }
      while (v113);
    }
    objc_msgSend_setAnimations_(v5, v110, (uint64_t)v107, v112);
  }
  return v5;
}

uint64_t sub_1B6500DAC(void *a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  uint64_t v12 = objc_msgSend_cfxAnimation(a1, v9, v10, v11);
  if (!v12) {
    return 0;
  }

  return sub_1B6437F58(v12, a4, a5, v13, v14, v15, v16, v17, a2);
}

void sub_1B65029F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6502A10(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id v6 = objc_msgSend_animationKeys(a2, (const char *)a2, a3, a4, 0);
  uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v7, (uint64_t)&v31, (uint64_t)v35, 16);
  if (result)
  {
    uint64_t v11 = result;
    uint64_t v12 = *(void *)v32;
    do
    {
      uint64_t v13 = 0;
      do
      {
        if (*(void *)v32 != v12) {
          objc_enumerationMutation(v6);
        }
        uint64_t v14 = objc_msgSend_animationPlayerForKey_(a2, v9, *(void *)(*((void *)&v31 + 1) + 8 * v13), v10);
        double v15 = *(double *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        uint64_t v19 = objc_msgSend_animation(v14, v16, v17, v18);
        objc_msgSend_duration(v19, v20, v21, v22);
        if (v15 >= v26) {
          double v26 = v15;
        }
        *(double *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v26;
        uint64_t v27 = *(void **)(a1 + 32);
        uint64_t v28 = objc_msgSend_animation(v14, v23, v24, v25);
        objc_msgSend_addObject_(v27, v29, v28, v30);
        ++v13;
      }
      while (v11 != v13);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v9, (uint64_t)&v31, (uint64_t)v35, 16);
      uint64_t v11 = result;
    }
    while (result);
  }
  return result;
}

void sub_1B6502FD4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B65030CC(uint64_t a1)
{
  CFStringRef v2 = sub_1B63CC80C(*(const __CFString **)(a1 + 32));
  sub_1B6492CA0(*(void *)(*(void *)(a1 + 40) + 8), v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

float sub_1B65031FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8 = *(double *)(a1 + 40);
  sub_1B6492D2C(*(void *)(*(void *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

void sub_1B65032D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B6503430(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B6503500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B65035C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B6503690(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = sub_1B649399C(*(void *)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8) & 0xFE | *(unsigned char *)(a1 + 40);
  uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);

  sub_1B64939EC(v16, v9, v10, v11, v12, v13, v14, v15);
}

void sub_1B6503794(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = sub_1B649399C(*(void *)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8) & 0xFD | (2
                                                                                                  * *(unsigned char *)(a1 + 40));
  uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);

  sub_1B64939EC(v16, v9, v10, v11, v12, v13, v14, v15);
}

CFTypeRef sub_1B65038A0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (const void *)objc_msgSend_cfxTimingFunction(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);

  return sub_1B6492FB8(v12, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B6503998(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B6503A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64935F8(*(_WORD **)(*(void *)(a1 + 32) + 8), *(unsigned __int8 *)(a1 + 40), a3, a4, a5, a6, a7, a8);
}

void *sub_1B6503B30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float result = (void *)sub_1B64937D0(*(void *)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
  *float result = sub_1B6503B60;
  return result;
}

uint64_t sub_1B6503B60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (id *)sub_1B6438704(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = sub_1B6583674(v9);
  uint64_t v14 = objc_msgSend_userAnimation(v10, v11, v12, v13);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    uint64_t v14 = 0;
  }
  uint64_t v18 = objc_msgSend_delegate(v14, v15, v16, v17);
  if (objc_opt_respondsToSelector())
  {
    v33[0] = MEMORY[0x1E4F143A8];
    v33[1] = 3221225472;
    v33[2] = sub_1B65069A8;
    v33[3] = &unk_1E6143238;
    v33[4] = v18;
    v33[5] = v14;
    dispatch_async(MEMORY[0x1E4F14428], v33);
  }
  uint64_t result = objc_msgSend_animationDidStart(v10, v19, v20, v21);
  if (result)
  {
    uint64_t v30 = result;
    long long v31 = (id *)sub_1B6438750(a1, v23, v24, v25, v26, v27, v28, v29);
    long long v32 = sub_1B6583674(v31);
    return (*(uint64_t (**)(uint64_t, id *, id *))(v30 + 16))(v30, v10, v32);
  }
  return result;
}

uint64_t sub_1B6503D28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B64937D0(*(void *)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
  *(void *)(result + 8) = sub_1B6503D58;
  return result;
}

uint64_t sub_1B6503D58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a4;
  uint64_t v9 = a2;
  uint64_t v10 = a1;
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (id *)sub_1B6438704(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = sub_1B6583674(v11);
  id v16 = (id)objc_msgSend_userAnimation(v12, v13, v14, v15);
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v24 = objc_msgSend_delegate(v16, v17, v18, v19);
  }
  else {
    uint64_t v24 = 0;
  }
  if (!sub_1B64931F0((uint64_t)v11, (uint64_t)v17, v18, v19, v20, v21, v22, v23)) {
    goto LABEL_26;
  }
  long long v32 = (id *)sub_1B6438750(v10, v25, v26, v27, v28, v29, v30, v31);
  long long v33 = sub_1B6583674(v32);
  if (sub_1B64936B8((uint64_t)v11, v34, v35, v36, v37, v38, v39, v40))
  {
    uint64_t v42 = sub_1B654DC68();
    if (v42 == CFGetTypeID(v11))
    {
      uint64_t v111 = v8;
      unsigned int v112 = v9;
      uint64_t v43 = sub_1B654E8C8((uint64_t)v11);
      objc_msgSend_begin(VFXTransaction, v44, v45, v46);
      objc_msgSend_setAnimationDuration_(VFXTransaction, v47, v48, v49, 0.0);
      long long v117 = 0u;
      long long v118 = 0u;
      long long v115 = 0u;
      long long v116 = 0u;
      uint64_t v51 = objc_msgSend_countByEnumeratingWithState_objects_count_(v43, v50, (uint64_t)&v115, (uint64_t)v119, 16);
      if (v51)
      {
        uint64_t v55 = v51;
        uint64_t v56 = *(void *)v116;
        do
        {
          uint64_t v57 = 0;
          do
          {
            if (*(void *)v116 != v56) {
              objc_enumerationMutation(v43);
            }
            uint64_t v58 = *(void *)(*((void *)&v115 + 1) + 8 * v57);
            uint64_t v59 = objc_msgSend_presentationObject(v33, v52, v53, v54);
            uint64_t v62 = objc_msgSend_valueForKeyPath_(v59, v60, v58, v61);
            objc_msgSend_setValue_forKeyPath_(v33, v63, v62, v58);
            ++v57;
          }
          while (v55 != v57);
          uint64_t v55 = objc_msgSend_countByEnumeratingWithState_objects_count_(v43, v52, (uint64_t)&v115, (uint64_t)v119, 16);
        }
        while (v55);
      }
      objc_msgSend_commit(VFXTransaction, v52, v53, v54);

      uint64_t v9 = v112;
      uint64_t v8 = v111;
    }
    else
    {
      uint64_t v64 = sub_1B6492CF4((uint64_t)v11);
      if (v64)
      {
        CFArrayRef v71 = (const __CFArray *)v64;
        if (v33)
        {
          uint64_t v72 = v33;
        }
        else
        {
          if (v10)
          {
            while (1)
            {
              uint64_t v73 = sub_1B6438AD0(v10, (uint64_t)v41, v65, v66, v67, v68, v69, v70);
              uint64_t v10 = v73;
              if (!v73) {
                break;
              }
              uint64_t v78 = (id *)sub_1B6438750(v73, (uint64_t)v41, v65, v66, v74, v75, v76, v77);
              uint64_t v79 = sub_1B6583674(v78);
              if (v79)
              {
                uint64_t v72 = v79;
                goto LABEL_23;
              }
            }
          }
          uint64_t v72 = 0;
        }
LABEL_23:
        objc_msgSend_begin(VFXTransaction, v41, v65, v66);
        objc_msgSend_setAnimationDuration_(VFXTransaction, v80, v81, v82, 0.0);
        CFArrayRef v83 = sub_1B63CC828(v71);
        uint64_t v87 = objc_msgSend_presentationObject(v72, v84, v85, v86);
        uint64_t v90 = objc_msgSend_valueForKeyPath_(v87, v88, (uint64_t)v83, v89);
        objc_msgSend_setValue_forKeyPath_(v72, v91, v90, (uint64_t)v83);

        objc_msgSend_commit(VFXTransaction, v92, v93, v94);
      }
    }
  }
  if (v9) {
    uint64_t v95 = objc_msgSend___removeAnimation_forKey_(v33, v41, (uint64_t)v12, v8);
  }
  else {
LABEL_26:
  }
    uint64_t v95 = 0;
  if (objc_opt_respondsToSelector())
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_1B65069B4;
    block[3] = &unk_1E6143788;
    block[4] = v24;
    void block[5] = v16;
    char v114 = v9;
    dispatch_async(MEMORY[0x1E4F14428], block);
  }
  uint64_t v99 = objc_msgSend_animationDidStop(v12, v96, v97, v98);
  if (v99)
  {
    uint64_t v107 = v99;
    uint64_t v108 = (id *)sub_1B6438750(v10, v100, v101, v102, v103, v104, v105, v106);
    uint64_t v109 = sub_1B6583674(v108);
    (*(void (**)(uint64_t, id *, id *, uint64_t))(v107 + 16))(v107, v12, v109, v9);
  }

  return v95;
}

CFTypeRef sub_1B6504174(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = sub_1B64FEE18(*(void **)(a1 + 40), a2, a3, a4);

  return sub_1B6493868(v4, v5, v6, v7, v8, v9, v10, v11);
}

float sub_1B6504284(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8 = *(double *)(a1 + 40);
  sub_1B64934B0(*(void *)(*(void *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

float sub_1B650436C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8 = *(double *)(a1 + 40);
  sub_1B6493554(*(void *)(*(void *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

void sub_1B6504438(uint64_t a1)
{
  uint64_t v2 = sub_1B654DC68();
  if (v2 == CFGetTypeID(*(CFTypeRef *)(*(void *)(a1 + 32) + 8))) {
    sub_1B63F2F54(16, @"Error: This animation can't be changed to additive. To make this animation additive first convert it to a CAAnimation, set it to additive and convert back to VFXAnimation", v3, v4, v5, v6, v7, v8, v11);
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  int v10 = *(unsigned __int8 *)(a1 + 40);

  sub_1B6493080(v9, v10, v3, v4, v5, v6, v7, v8);
}

void sub_1B6504554(uint64_t a1)
{
  uint64_t v2 = sub_1B654DC68();
  if (v2 == CFGetTypeID(*(CFTypeRef *)(*(void *)(a1 + 32) + 8))) {
    sub_1B63F2F54(16, @"Error: This animation can't be changed to cumulative. To make this animation cumulative first convert it to a CAAnimation, set it to cumulative and convert back to VFXAnimation", v3, v4, v5, v6, v7, v8, v11);
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  int v10 = *(unsigned __int8 *)(a1 + 40);

  sub_1B6493138(v9, v10, v3, v4, v5, v6, v7, v8);
}

void sub_1B6504788(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == sub_1B6540E1C())
  {
    int v10 = sub_1B6541028((uint64_t)a1, v3, v4, v5, v6, v7, v8, v9);
    if (v10 >= 1)
    {
      CFIndex v17 = 0;
      uint64_t v18 = v10;
      do
      {
        uint64_t v19 = sub_1B6541084((uint64_t)a1, v17, v11, v12, v13, v14, v15, v16);
        sub_1B6504788(v19);
        ++v17;
      }
      while (v18 != v17);
    }
  }
  else
  {
    CFTypeID v20 = CFGetTypeID(a1);
    if (v20 == sub_1B6437D6C())
    {
      uint64_t v28 = sub_1B6437F0C((uint64_t)a1, v21, v22, v23, v24, v25, v26, v27);
      char v35 = 0;
      sub_1B6426270(v28, &v35, v29, v30, v31, v32, v33, v34);
    }
  }
}

void sub_1B6504EFC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 36));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 40), v10, *(void *)(a1 + 48), v11);
    uint64_t v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 36);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B6505110(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B65051D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B65052B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B6505398(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B65058D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B6505A34(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B6505B10(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B6505C4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B6505D00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B6505DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

CFIndex sub_1B6505E40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B6421448(*(void *)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
}

CFIndex sub_1B6505ED0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B64214E0(*(void *)(*(void *)(a1 + 32) + 8), a2, a3, a4, a5, a6, a7, a8);
}

CFIndex sub_1B6505F64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v8 = *(double *)(a1 + 40);
  return sub_1B6421580(*(void *)(*(void *)(a1 + 32) + 8), v8, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B6506014(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B6506280(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  objc_msgSend_time(a2, (const char *)a2, (uint64_t)a3, a4);
  double v7 = v6;
  objc_msgSend_time(a3, v8, v9, v10);
  if (v7 < v14) {
    return -1;
  }
  objc_msgSend_time(a2, v11, v12, v13);
  double v17 = v16;
  objc_msgSend_time(a3, v18, v19, v20);
  return v17 != v21;
}

uint64_t sub_1B65062EC(_WORD *a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_duration(a2, (const char *)a2, a3, a4);
  double v7 = v6;
  int v11 = objc_msgSend_autoreverses(a2, v8, v9, v10);
  float v12 = v7;
  sub_1B6492D2C((uint64_t)a1, v12, v13, v14, v15, v16, v17, v18, v19);
  objc_msgSend_repeatCount(a2, v20, v21, v22);
  float v24 = v23;
  objc_msgSend_repeatDuration(a2, v25, v26, v27);
  if (v24 == 0.0)
  {
    float v36 = v35;
    if (v36 != 0.0 && v7 != 0.0)
    {
      double v37 = v36;
      objc_msgSend_duration(a2, v28, v29, v30);
      float v39 = v37 / v38;
      if (v11) {
        float v24 = v39 * 0.5;
      }
      else {
        float v24 = v39;
      }
    }
  }
  sub_1B6492E68((uint64_t)a1, v24, (uint64_t)v28, v29, v30, v31, v32, v33, v34);
  sub_1B6492F0C((uint64_t)a1, v11, v40, v41, v42, v43, v44, v45);
  objc_msgSend_beginTime(a2, v46, v47, v48);
  sub_1B6439720((uint64_t)a1, v56, v49, v50, v51, v52, v53, v54, v55);
  objc_msgSend_timeOffset(a2, v57, v58, v59);
  sub_1B6493368((uint64_t)a1, v67, v60, v61, v62, v63, v64, v65, v66);
  objc_msgSend_speed(a2, v68, v69, v70);
  sub_1B649340C((uint64_t)a1, v78, v71, v72, v73, v74, v75, v76, v77);
  int isRemovedOnCompletion = objc_msgSend_isRemovedOnCompletion(a2, v79, v80, v81);
  sub_1B6493240((uint64_t)a1, isRemovedOnCompletion, v83, v84, v85, v86, v87, v88);
  objc_msgSend_fadeInDuration(a2, v89, v90, v91);
  sub_1B64934B0((uint64_t)a1, v99, v92, v93, v94, v95, v96, v97, v98);
  objc_msgSend_fadeOutDuration(a2, v100, v101, v102);
  sub_1B6493554((uint64_t)a1, v110, v103, v104, v105, v106, v107, v108, v109);
  uint64_t v114 = objc_msgSend_commitsOnCompletion(a2, v111, v112, v113);
  sub_1B64935F8(a1, v114, v115, v116, v117, v118, v119, v120);
  uint64_t v124 = objc_msgSend_fillMode(a2, v121, v122, v123);
  char v128 = sub_1B64FEBBC(v124, v125, v126, v127);
  sub_1B64939EC((uint64_t)a1, v128, v129, v130, v131, v132, v133, v134);
  uint64_t v138 = objc_msgSend_animationEvents(a2, v135, v136, v137);
  float v142 = sub_1B64FEE18(v138, v139, v140, v141);
  sub_1B6493868((uint64_t)a1, v142, v143, v144, v145, v146, v147, v148);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend_mass(a2, v149, v150, v151);
    float v153 = v152;
    objc_msgSend_stiffness(a2, v154, v155, v156);
    float v158 = v157;
    objc_msgSend_damping(a2, v159, v160, v161);
    float v163 = v162;
    objc_msgSend_initialVelocity(a2, v164, v165, v166);
    float v168 = v167;
    float v169 = (const void *)sub_1B6433074(v153, v158, v163, v168);
    sub_1B6492FB8((uint64_t)a1, v169, v170, v171, v172, v173, v174, v175);
    CFRelease(v169);
  }
  else
  {
    uint64_t v182 = objc_msgSend_timingFunction(a2, v149, v150, v151);
    if (v182)
    {
      id v184 = sub_1B64BA090(v182, v183);
      sub_1B6492FB8((uint64_t)a1, v184, v185, v186, v187, v188, v189, v190);
    }
  }

  return sub_1B64FFFA8((uint64_t)a1, a2, v176, v177, v178, v179, v180, v181);
}

uint64_t sub_1B650650C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B64931A0(a2, a2, a3, a4, a5, a6, a7, a8);
  objc_msgSend_setAdditive_(a1, v11, v10, v12);
  uint64_t v20 = sub_1B64930E8(a2, v13, v14, v15, v16, v17, v18, v19);
  objc_msgSend_setCumulative_(a1, v21, v20, v22);

  return sub_1B6506570(a1, a2, v23, v24, v25, v26, v27, v28);
}

uint64_t sub_1B6506570(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v10 = sub_1B6492D84(a2, a2, a3, a4, a5, a6, a7, a8);
  objc_msgSend_setDuration_(a1, v11, v12, v13, v10);
  *(float *)&double v21 = sub_1B6492EC0(a2, v14, v15, v16, v17, v18, v19, v20);
  objc_msgSend_setRepeatCount_(a1, v22, v23, v24, v21);
  uint64_t v32 = sub_1B6492F68(a2, v25, v26, v27, v28, v29, v30, v31);
  objc_msgSend_setAutoreverses_(a1, v33, v32, v34);
  double v42 = sub_1B64396D4(a2, v35, v36, v37, v38, v39, v40, v41);
  objc_msgSend_setBeginTime_(a1, v43, v44, v45, v42);
  double v53 = sub_1B64933C0(a2, v46, v47, v48, v49, v50, v51, v52);
  objc_msgSend_setTimeOffset_(a1, v54, v55, v56, v53);
  *(float *)&double v64 = sub_1B6493464(a2, v57, v58, v59, v60, v61, v62, v63);
  objc_msgSend_setSpeed_(a1, v65, v66, v67, v64);
  *(float *)&double v75 = sub_1B6493508(a2, v68, v69, v70, v71, v72, v73, v74);
  objc_msgSend_setFadeInDuration_(a1, v76, v77, v78, v75);
  *(float *)&double v86 = sub_1B64935AC(a2, v79, v80, v81, v82, v83, v84, v85);
  objc_msgSend_setFadeOutDuration_(a1, v87, v88, v89, v86);
  uint64_t v97 = sub_1B64931F0(a2, v90, v91, v92, v93, v94, v95, v96);
  objc_msgSend_setRemovedOnCompletion_(a1, v98, v97, v99);
  uint64_t v107 = sub_1B64936B8(a2, v100, v101, v102, v103, v104, v105, v106);
  objc_msgSend_setCommitsOnCompletion_(a1, v108, v107, v109);
  int v117 = sub_1B649399C(a2, v110, v111, v112, v113, v114, v115, v116);
  uint64_t v125 = sub_1B64FECAC(v117, v118, v119, v120, v121, v122, v123, v124);
  objc_msgSend_setFillMode_(a1, v126, v125, v127);
  uint64_t v135 = sub_1B649381C(a2, v128, v129, v130, v131, v132, v133, v134);
  uint64_t v143 = sub_1B64FEFC8(v135, v136, v137, v138, v139, v140, v141, v142);
  objc_msgSend_setAnimationEvents_(a1, v144, (uint64_t)v143, v145);
  uint64_t result = sub_1B6493034(a2, v146, v147, v148, v149, v150, v151, v152);
  if (result)
  {
    uint64_t v162 = sub_1B64BA118(result, v154, v155, v156, v157, v158, v159, v160);
    return objc_msgSend_setTimingFunction_(a1, v161, v162, v163);
  }
  return result;
}

_WORD *sub_1B65066A8(void *a1, uint64_t a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (_WORD *)sub_1B6540EA4();
  sub_1B65062EC(v4, a1, v5, v6);
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  float v10 = objc_msgSend_animations(a1, v7, v8, v9);
  uint64_t v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(v10, v11, (uint64_t)&v47, (uint64_t)v51, 16);
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v48;
    do
    {
      uint64_t v15 = 0;
      do
      {
        if (*(void *)v48 != v14) {
          objc_enumerationMutation(v10);
        }
        uint64_t v16 = *(void **)(*((void *)&v47 + 1) + 8 * v15);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v17 = (void *)sub_1B65066A8(v16, a2);
          sub_1B6540F24((uint64_t)v4, v17, v18, v19, v20, v21, v22, v23);
        }
        else
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v27 = objc_msgSend_keyPath(v16, v24, v25, v26);
            uint64_t v31 = objc_msgSend_copy(v27, v28, v29, v30);
            if (v31)
            {
              uint64_t v38 = (void *)v31;
              uint64_t v39 = (void *)sub_1B6500064(v16, a2);
              if (v39) {
                sub_1B6540F24((uint64_t)v4, v39, v40, v41, v42, v43, v44, v45);
              }
            }
            else
            {
              sub_1B63F2F54(16, @"Error: sub-animation %@ of %@ has no keyPath - ignoring", v32, v33, v34, v35, v36, v37, (uint64_t)v16);
            }
          }
        }
        ++v15;
      }
      while (v13 != v15);
      uint64_t v13 = objc_msgSend_countByEnumeratingWithState_objects_count_(v10, v24, (uint64_t)&v47, (uint64_t)v51, 16);
    }
    while (v13);
  }
  return v4;
}

id sub_1B650685C(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x1E4F39B38]);
  sub_1B6506570(v2, a1, v3, v4, v5, v6, v7, v8);
  CFArrayRef v16 = (const __CFArray *)sub_1B65410E8(a1, v9, v10, v11, v12, v13, v14, v15);
  if (v16)
  {
    CFIndex Count = CFArrayGetCount(v16);
    uint64_t v29 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], v20, Count, v21);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        uint64_t v31 = sub_1B6541084(a1, i, v23, v24, v25, v26, v27, v28);
        uint64_t v32 = (void *)sub_1B6500244();
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v35 = (void *)sub_1B6492CF4((uint64_t)v31);
          if (v35)
          {
            uint64_t v43 = objc_msgSend_componentsJoinedByString_(v35, v36, @".", v38);
            objc_msgSend_setKeyPath_(v32, v44, v43, v45);
          }
          else
          {
            sub_1B63F2F54(0, @"Warning: VFXAnimationGroupToCAAnimationGroup - no target path", v37, v38, v39, v40, v41, v42, v47);
          }
        }
        objc_msgSend_addObject_(v29, v33, (uint64_t)v32, v34);
      }
    }
  }
  else
  {
    uint64_t v29 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], v17, 0, v18);
  }
  objc_msgSend_setAnimations_(v2, v22, (uint64_t)v29, v24);

  return v2;
}

uint64_t sub_1B65069A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_animationDidStart_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B65069B4(uint64_t a1)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel_animationDidStop_finished_, *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
}

#error "1B6507558: call analysis failed (funcsize=93)"

void sub_1B65076B0(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6508190()
{
  uint64_t result = CGImageGetImageProvider();
  if (result)
  {
    return MEMORY[0x1F40DA9F8]();
  }
  return result;
}

void sub_1B6508A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B6508A18(uint64_t a1, uint64_t a2)
{
}

void sub_1B6508A28(uint64_t a1)
{
}

uint64_t sub_1B6508A34(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_sharedRegistry(VFXSourceRendererRegistry, a2, a3, a4);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);

  return MEMORY[0x1F4181798](v5, sel_removeSourceRenderersForSource_, v7, v6);
}

uint64_t sub_1B6508B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialColor_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B6508DFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialNumber_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B6509074(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialLayer_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B6509080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialAsset_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B6509564(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B6509620(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B65096DC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B6509844(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t IfNeeded = objc_msgSend_materialPropertyCreateIfNeeded_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40) != 0, a4);
  if (IfNeeded)
  {
    uint64_t v17 = *(void *)(a1 + 40);
    sub_1B6476570(IfNeeded, v17, v11, v12, v13, v14, v15, v16, a9);
  }
}

void sub_1B65099CC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t IfNeeded = objc_msgSend_materialPropertyCreateIfNeeded_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40) != 15, a4);
  if (IfNeeded)
  {
    int v17 = *(unsigned __int8 *)(a1 + 40);
    sub_1B6477BB4(IfNeeded, v17, v11, v12, v13, v14, v15, v16, a9);
  }
}

void sub_1B6509B04(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = objc_msgSend_materialProperty(*(void **)(a1 + 32), a2, a3, a4);
  if (v10)
  {
    float v18 = *(float *)(a1 + 40);
    sub_1B64763F8(v10, v18, v11, v12, v13, v14, v15, v16, v17, a9);
  }
}

uint64_t sub_1B6509D1C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B6509E78(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__updateMaterialFilters(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B6509FB0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (objc_msgSend_materialProperty(*(void **)(a1 + 32), a2, a3, a4))
  {
    uint64_t v13 = objc_msgSend_materialProperty(*(void **)(a1 + 32), v10, v11, v12);
    int v20 = *(unsigned __int8 *)(a1 + 40);
    sub_1B6477D28(v13, v20, v14, v15, v16, v17, v18, v19, a9);
  }
}

uint64_t sub_1B650A198(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialImage_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650A45C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialLayer_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650A544(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialAVPlayer_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650A62C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialCaptureDevice_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650A714(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialCaptureDeviceOutputConsumerSource_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650A7FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialTextureProvider_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650A8E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updatePrecomputedLightingEnvironment_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650AB74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialUIComponent_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650AC5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialUIComponent_, *(void *)(a1 + 40), a4);
}

Class sub_1B650AC68()
{
  return NSClassFromString(&cfstr_Avplayer.isa);
}

Class sub_1B650AC74()
{
  return NSClassFromString(&cfstr_Avcapturedevic.isa);
}

int8x8_t sub_1B650B2FC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_textureSampler(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    float v14 = *(float *)(a1 + 40);
    return sub_1B643DACC(v5, v14, v6, v7, v8, v9, v10, v11, v12);
  }
  return result;
}

uint64_t sub_1B650B408(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateMaterialMTLTexture_, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B650B56C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 96), sel__updateMaterialPropertyTransform_, a3, a4);
}

void sub_1B650C230(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 24));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 32), v10, *(void *)(a1 + 48), v11);
    uint64_t v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 24);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B650C444(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B650C50C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B650C5E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B650C6CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B650CC0C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B650CD68(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B650CE44(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B650EB58(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = objc_msgSend_resourceManager(a2, (const char *)a2, a3, a4);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return a1;
}

uint64_t sub_1B650EB94(uint64_t a1)
{
  id v2 = *(id **)(a1 + 16);
  uint64_t v3 = *(id **)(a1 + 24);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {

      }
      v2 += 12;
    }
    while (v2 != v3);
    id v2 = *(id **)(a1 + 16);
  }
  if (v2)
  {
    *(void *)(a1 + 24) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1B650EBF8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 16);
  if (v3)
  {
    *(void *)(v1 + 24) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B650EC18(uint64_t a1, unsigned __int16 *a2, void *a3, uint64_t a4)
{
  id v4 = a3;
  unint64_t v7 = *(unsigned int *)(a1 + 40);
  if (v7)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = v9 + 96 * v7;
    while (1)
    {
      if (*(unsigned __int16 *)(v9 + v8 + 8) == *a2
        && *(unsigned __int16 *)(v9 + v8 + 10) == a2[1]
        && *(unsigned __int16 *)(v9 + v8 + 12) == a2[2]
        && *(unsigned __int16 *)(v9 + v8 + 14) == a2[3]
        && *(unsigned __int8 *)(v9 + v8 + 16) == *((unsigned __int8 *)a2 + 8)
        && *(unsigned __int8 *)(v9 + v8 + 17) == *((unsigned __int8 *)a2 + 9)
        && *(unsigned __int8 *)(v9 + v8 + 18) == *((unsigned __int8 *)a2 + 10)
        && *(void *)(v9 + v8 + 24) == *((void *)a2 + 2)
        && *(void *)(v9 + v8 + 32) == *((void *)a2 + 3)
        && *(void *)(v9 + v8 + 40) == *((void *)a2 + 4)
        && *(void *)(v9 + v8 + 48) == *((void *)a2 + 5)
        && *(void *)(v9 + v8 + 56) == *((void *)a2 + 6)
        && *(void *)(v9 + v8 + 64) == *((void *)a2 + 7)
        && *(void *)(v9 + v8 + 72) == *((void *)a2 + 8)
        && *(unsigned __int8 *)(v9 + v8 + 80) == *((unsigned __int8 *)a2 + 72)
        && *(unsigned __int8 *)(v9 + v8 + 81) == *((unsigned __int8 *)a2 + 73)
        && *(unsigned __int8 *)(v9 + v8 + 82) == *((unsigned __int8 *)a2 + 74)
        && *(unsigned __int8 *)(v9 + v8 + 83) == *((unsigned __int8 *)a2 + 75))
      {
        uint64_t v11 = (long long *)(v9 + v8);
        if (!a4 || *((_DWORD *)v11 + 22) >= 3u) {
          break;
        }
      }
      v8 += 96;
      if (96 * v7 == v8) {
        goto LABEL_24;
      }
    }
    uint64_t v20 = *(void *)v11;
    *((_DWORD *)v11 + 22) = 0;
    if (96 * v7 - 96 != v8)
    {
      unint64_t v7 = v10 - 96;
      long long v45 = v11[3];
      long long v58 = v11[2];
      long long v59 = v45;
      long long v46 = v11[5];
      long long v60 = v11[4];
      long long v61 = v46;
      long long v47 = v11[1];
      long long v56 = *v11;
      long long v57 = v47;
      long long v48 = *(_OWORD *)(v10 - 80);
      *uint64_t v11 = *(_OWORD *)(v10 - 96);
      v11[1] = v48;
      long long v49 = *(_OWORD *)(v10 - 16);
      long long v51 = *(_OWORD *)(v10 - 64);
      long long v50 = *(_OWORD *)(v10 - 48);
      v11[4] = *(_OWORD *)(v10 - 32);
      v11[5] = v49;
      uint64_t v11[2] = v51;
      v11[3] = v50;
      long long v52 = v61;
      *(_OWORD *)(v7 + 64) = v60;
      *(_OWORD *)(v7 + 80) = v52;
      long long v53 = v59;
      *(_OWORD *)(v7 + 32) = v58;
      *(_OWORD *)(v7 + 48) = v53;
      long long v54 = v57;
      *(_OWORD *)unint64_t v7 = v56;
      *(_OWORD *)(v7 + 16) = v54;
      LODWORD(v7) = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(a1 + 40) = v7 - 1;
  }
  else
  {
LABEL_24:
    if (!a3)
    {
      id v4 = objc_alloc_init(MEMORY[0x1E4F35330]);
      long long v12 = *((_OWORD *)a2 + 3);
      v55[2] = *((_OWORD *)a2 + 2);
      v55[3] = v12;
      v55[4] = *((_OWORD *)a2 + 4);
      long long v13 = *((_OWORD *)a2 + 1);
      v55[0] = *(_OWORD *)a2;
      v55[1] = v13;
      RGTextureDescriptorFillMTLDescriptor((unsigned __int16 *)v55, v4);
    }
    uint64_t v20 = objc_msgSend_newTextureWithDescriptor_(*(void **)(a1 + 8), (const char *)a2, (uint64_t)v4, a4);
    long long v21 = *((_OWORD *)a2 + 3);
    long long v58 = *((_OWORD *)a2 + 2);
    long long v59 = v21;
    long long v60 = *((_OWORD *)a2 + 4);
    long long v22 = *((_OWORD *)a2 + 1);
    long long v56 = *(_OWORD *)a2;
    long long v57 = v22;
    if (v20)
    {
      unint64_t v23 = *(void *)(a1 + 32);
      unint64_t v24 = *(void *)(a1 + 24);
      if (v24 >= v23)
      {
        uint64_t v28 = *(void *)(a1 + 16);
        unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v28) >> 5);
        unint64_t v30 = v29 + 1;
        if (v29 + 1 > 0x2AAAAAAAAAAAAAALL) {
          abort();
        }
        unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v28) >> 5);
        if (2 * v31 > v30) {
          unint64_t v30 = 2 * v31;
        }
        if (v31 >= 0x155555555555555) {
          unint64_t v32 = 0x2AAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v32 = v30;
        }
        if (v32) {
          uint64_t v33 = (char *)sub_1B650F2A4(a1 + 32, v32);
        }
        else {
          uint64_t v33 = 0;
        }
        uint64_t v34 = &v33[96 * v29];
        long long v35 = v57;
        *(_OWORD *)(v34 + 8) = v56;
        *(_OWORD *)(v34 + 72) = v60;
        long long v36 = v58;
        *(_OWORD *)(v34 + 56) = v59;
        *(_OWORD *)(v34 + 40) = v36;
        uint64_t v37 = &v33[96 * v32];
        *(void *)uint64_t v34 = v20;
        *(_OWORD *)(v34 + 24) = v35;
        *((void *)v34 + 11) = 0;
        uint64_t v27 = v34 + 96;
        uint64_t v39 = *(char **)(a1 + 16);
        uint64_t v38 = *(char **)(a1 + 24);
        if (v38 != v39)
        {
          do
          {
            long long v40 = *((_OWORD *)v38 - 5);
            *((_OWORD *)v34 - 6) = *((_OWORD *)v38 - 6);
            *((_OWORD *)v34 - 5) = v40;
            long long v41 = *((_OWORD *)v38 - 4);
            long long v42 = *((_OWORD *)v38 - 3);
            long long v43 = *((_OWORD *)v38 - 1);
            *((_OWORD *)v34 - 2) = *((_OWORD *)v38 - 2);
            *((_OWORD *)v34 - 1) = v43;
            *((_OWORD *)v34 - 4) = v41;
            *((_OWORD *)v34 - 3) = v42;
            v34 -= 96;
            v38 -= 96;
          }
          while (v38 != v39);
          uint64_t v38 = *(char **)(a1 + 16);
        }
        *(void *)(a1 + 16) = v34;
        *(void *)(a1 + 24) = v27;
        *(void *)(a1 + 32) = v37;
        if (v38) {
          operator delete(v38);
        }
      }
      else
      {
        *(void *)unint64_t v24 = v20;
        long long v25 = v56;
        *(_OWORD *)(v24 + 24) = v57;
        long long v26 = v59;
        *(_OWORD *)(v24 + 40) = v58;
        *(_OWORD *)(v24 + 56) = v26;
        *(_OWORD *)(v24 + 72) = v60;
        *(_OWORD *)(v24 + 8) = v25;
        uint64_t v27 = (char *)(v24 + 96);
        *(void *)(v24 + 88) = 0;
      }
      *(void *)(a1 + 24) = v27;
    }
    else
    {
      sub_1B63F2F54(16, @"Error: Could not create texture with descriptor : %@", v14, v15, v16, v17, v18, v19, (uint64_t)v4);
    }
  }
  return v20;
}

void *sub_1B650F004(void **a1, unsigned __int16 *a2, void *a3, uint64_t a4)
{
  int v4 = a4;
  if (a4)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 2;
    *((void *)a2 + 5) |= 2uLL;
  }
  *((void *)a2 + 4) = v8;
  long long v9 = *((_OWORD *)a2 + 4);
  long long v10 = *((_OWORD *)a2 + 1);
  v57[0] = *(_OWORD *)a2;
  v57[1] = v10;
  long long v11 = *((_OWORD *)a2 + 2);
  v57[3] = *((_OWORD *)a2 + 3);
  v57[4] = v9;
  v57[2] = v11;
  long long v12 = (void *)sub_1B650EC18((uint64_t)a1, (unsigned __int16 *)v57, 0, a4);
  unint64_t v13 = (unint64_t)sub_1B64D8100() >> 3;
  unint64_t v14 = v13 * *a2;
  unint64_t v15 = v14 * a2[1];
  uint64_t v19 = objc_msgSend_width(v12, v16, v17, v18);
  uint64_t v23 = objc_msgSend_height(v12, v20, v21, v22);
  uint64_t v27 = objc_msgSend_depth(v12, v24, v25, v26);
  if (v4)
  {
    memset(v56, 0, 24);
    v56[3] = v19;
    v56[4] = v23;
    v56[5] = v27;
    objc_msgSend_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_(v12, v28, (uint64_t)v56, 0, 0, *a3, v14, v15);
  }
  else
  {
    v54[0] = v13;
    v54[1] = v14;
    int v55 = v15;
    if (objc_msgSend_pixelFormat(v12, v28, v29, v30) != 23
      && objc_msgSend_pixelFormat(v12, v31, v32, v33) != 63
      && objc_msgSend_pixelFormat(v12, v31, v34, v33) != 113)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Only uint16 format are supported for the compute path of the copy buffer to texture", v35, v33, v36, v37, v38, v39, (uint64_t)"(tex.pixelFormat == MTLPixelFormatR16Uint) || (tex.pixelFormat == MTLPixelFormatRG16Uint) || (tex.pixelFormat == MTLPixelFormatRGBA16Uint)");
    }
    uint64_t v40 = objc_msgSend_computePipelineStateForKernel_(a1[1], v31, @"copy_texture_3D_from_buffer_ushort", v33);
    uint64_t v44 = (void **)objc_msgSend_resourceComputeEncoder(*a1, v41, v42, v43);
    uint64_t v45 = sub_1B653EFB8(v40);
    objc_msgSend_setComputePipelineState_(*v44, v46, v45, v47);
    objc_msgSend_setBuffer_offset_atIndex_(*v44, v48, a3[1], a3[2], 0);
    objc_msgSend_setBytes_length_atIndex_(*v44, v49, (uint64_t)v54, 8, 1);
    objc_msgSend_setTexture_atIndex_(*v44, v50, (uint64_t)v12, 0);
    objc_msgSend_dispatchOnTexture3D_(*v44, v51, (uint64_t)v12, v52);
  }
  return v12;
}

void sub_1B650F1F8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  if (v3 == v2)
  {
    uint64_t v3 = *(void *)(a1 + 24);
  }
  else
  {
    do
    {
      unsigned int v4 = *(_DWORD *)(v3 + 88);
      *(_DWORD *)(v3 + 88) = v4 + 1;
      if (v4 < 0x65)
      {
        v3 += 96;
      }
      else
      {

        uint64_t v5 = *(void *)(a1 + 24);
        uint64_t v6 = v5 - (v3 + 96);
        if (v5 != v3 + 96) {
          memmove((void *)v3, (const void *)(v3 + 96), v5 - (v3 + 96));
        }
        uint64_t v2 = v3 + v6;
        *(void *)(a1 + 24) = v3 + v6;
      }
    }
    while (v3 != v2);
    uint64_t v2 = *(void *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 40) = -1431655765 * ((unint64_t)(v3 - v2) >> 5);
}

void *sub_1B650F2A4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    sub_1B63C8620();
  }
  return operator new(96 * a2);
}

uint64_t sub_1B650F2EC(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B650F31C(uint64_t a1)
{
  if (qword_1E9DDB1B8 != -1) {
    dispatch_once_f(&qword_1E9DDB1B8, &qword_1E9DDB1B0, (dispatch_function_t)sub_1B650F2EC);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1E9DDB1B0, 0x40uLL);
  *(void *)(v2 + 16) = a1;
  *(void *)(v2 + 24) = 0;
  *(void *)(v2 + 32) = 0;
  *(void *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 48) = -1;
  *(void *)(v2 + 56) = 0;
  *(_DWORD *)(v2 + 64) = 0;
  *(void *)(v2 + 72) = 0;
  sub_1B6510690(v2, 1);
  return v2;
}

uint64_t sub_1B650F3B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }

  return sub_1B650F424(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B650F424(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 == -1)
  {
    int v11 = -1;
    int v12 = -1;
  }
  else
  {
    long long v10 = (int *)(*(void *)(a1 + 24) + 8 * (int)a3);
    int v11 = *v10;
    int v12 = v10[1];
  }
  unsigned int v13 = v11;
  uint64_t v14 = v11 + 1;
  if ((int)v14 >= *(_DWORD *)(a1 + 64)) {
    sub_1B6510690(a1, v11 + 2);
  }
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = v15 + 80 * v14;
  int v18 = *(_DWORD *)(v16 + 72);
  int v17 = *(_DWORD *)(v16 + 76);
  uint64_t v19 = (int *)(v16 + 72);
  if (v18 == v17)
  {
    sub_1B651080C(v15 + 80 * v14, 2 * v18);
    int v18 = *v19;
  }
  uint64_t v20 = v15 + 80 * v14;
  uint64_t v23 = *(char **)(v20 + 24);
  uint64_t v22 = (void *)(v20 + 24);
  uint64_t v21 = v23;
  uint64_t v24 = v18;
  if (!v18) {
    goto LABEL_16;
  }
  unint64_t v25 = v18;
  uint64_t v26 = v21;
  uint64_t v27 = &v21[4 * v18];
  do
  {
    unint64_t v28 = v25 >> 1;
    uint64_t v29 = (int *)&v26[4 * (v25 >> 1)];
    int v31 = *v29;
    uint64_t v30 = (char *)(v29 + 1);
    v25 += ~(v25 >> 1);
    if (v12 < v31) {
      unint64_t v25 = v28;
    }
    else {
      uint64_t v26 = v30;
    }
  }
  while (v25);
  if (v26 == v27)
  {
LABEL_16:
    unint64_t v32 = 4 * v24;
  }
  else
  {
    unint64_t v32 = v26 - v21;
    sub_1B6510C00(a1, v14 | ((unint64_t)((unint64_t)(v26 - v21) >> 2) << 32), v13 | ((unint64_t)v12 << 32), 1, a5, a6, a7, a8);
  }
  if ((v32 >> 2) == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. no more handle available", a3, a4, a5, a6, a7, a8, (uint64_t)"handle.index != kCFXTransformIndexInvalid");
  }
  ++*v19;
  uint64_t v33 = (void *)(v15 + 80 * v14);
  *(void *)(v33[5] + ((uint64_t)(v32 << 30) >> 29)) = a2;
  uint64_t v34 = (uint64_t)(v32 << 30) >> 30;
  *(_DWORD *)(v33[7] + v34) = *(_DWORD *)(a2 + 216);
  *(_DWORD *)(*v22 + v34) = v12;
  *(_DWORD *)(v33[4] + v34) = -1;
  *(double *)&long long v35 = sub_1B649FE9C(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v36 = (_OWORD *)(v33[2] + ((uint64_t)(v32 << 30) >> 26));
  *uint64_t v36 = v35;
  v36[1] = v37;
  uint64_t v36[2] = v38;
  v36[3] = v39;
  uint64_t v40 = v14 | (v32 << 30);
  sub_1B6510DA4(a1, v40);
  uint64_t v45 = sub_1B6510EC4(a1, v40);
  *(_DWORD *)(v33[6] + v34) = v45;
  if (v13 != -1)
  {
    uint64_t v46 = *(void *)(*(void *)(a1 + 56) + 80 * (int)v13 + 32);
    if (*(_DWORD *)(v46 + 4 * v12) == -1) {
      *(_DWORD *)(v46 + 4 * v12) = v32 >> 2;
    }
  }
  sub_1B6510FD4(a1, v40, v13 | ((unint64_t)v12 << 32), 0xFFFFFFFFLL, v41, v42, v43, v44);
  ++*(_DWORD *)(a1 + 72);
  return v45;
}

void sub_1B650F670(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }

  sub_1B650F6D4(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B650F6D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  if (a2 == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. invalid handle (%d) given", a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  }
  uint64_t v10 = *(void *)(a1 + 24);
  int v11 = (unsigned int *)(v10 + 8 * (int)a2);
  unsigned int v12 = *v11;
  unint64_t v13 = v11[1];
  ++*(_DWORD *)(a1 + 72);
  if (v13 == -1)
  {
    *int v11 = -1;
    *(_DWORD *)(v10 + 8 * (int)a2 + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a1 + 48) = a2;
    return;
  }
  uint64_t v103 = a2;
  uint64_t v104 = (int)a2;
  uint64_t v102 = (os_unfair_lock_s *)(a1 + 76);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 76));
  uint64_t v101 = (uint64_t)&v101;
  MEMORY[0x1F4188790](v14, v15);
  int v17 = (char *)&v101 - ((v16 + 15) & 0x7FFFFFFF0);
  uint64_t v18 = *(unsigned int *)(a1 + 64);
  MEMORY[0x1F4188790](v19, v20);
  unint64_t v28 = (char *)&v101 - v27;
  uint64_t v105 = (char *)&v101 - v27;
  if ((int)v18 >= 1)
  {
    memset_pattern16(v17, &unk_1B6E51D50, 4 * v18);
    unint64_t v28 = v105;
    memset_pattern16(v105, &unk_1B6E51D60, 4 * v18);
  }
  *(_DWORD *)&v17[4 * v12] = v13;
  *(_DWORD *)&v28[4 * v12] = v13;
  int v29 = v12 + 1;
  LODWORD(v30) = v18;
  if ((int)(v12 + 1) < (int)v18)
  {
    LODWORD(v31) = v12;
    unint64_t v32 = v13;
    while (1)
    {
      uint64_t v33 = v31 | (v13 << 32);
      unint64_t v34 = v12 | (v32 << 32);
      int64_t v31 = sub_1B6511280(a1, v33, v34, v22, v23, v24, v25, v26);
      unint64_t v13 = HIDWORD(v31);
      unint64_t v40 = sub_1B651135C(a1, v33, v34, v35, v36, v37, v38, v39);
      unint64_t v32 = HIDWORD(v40);
      if (HIDWORD(v31) == -1 && HIDWORD(v40) == -1) {
        break;
      }
      unsigned int v12 = v40;
      if (HIDWORD(v31) == -1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v21, v22, v23, v24, v25, v26, (uint64_t)"firstChild.index != kCFXTransformIndexInvalid");
      }
      if (v32 == -1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v21, v22, v23, v24, v25, v26, (uint64_t)"lastChild.index != kCFXTransformIndexInvalid");
      }
      if (v12 != v31) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v21, v22, v23, v24, v25, v26, (uint64_t)"lastChild.level == firstChild.level");
      }
      if ((int)v32 < SHIDWORD(v31)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v21, v22, v23, v24, v25, v26, (uint64_t)"lastChild.index >= firstChild.index");
      }
      uint64_t v42 = *(int *)&v17[4 * (int)v31];
      if ((int)v42 >= SHIDWORD(v31)) {
        int v43 = HIDWORD(v31);
      }
      else {
        int v43 = *(_DWORD *)&v17[4 * (int)v31];
      }
      *(_DWORD *)&v17[4 * (int)v31] = v43;
      uint64_t v44 = v105;
      int v45 = *(_DWORD *)&v105[4 * v12];
      if (v45 <= (int)v32) {
        int v45 = v32;
      }
      *(_DWORD *)&v105[4 * v12] = v45;
      int v46 = *(_DWORD *)&v44[4 * (int)v31];
      if (v43 <= v46)
      {
        uint64_t v47 = *(void *)(a1 + 24);
        if (v42 >= v31 >> 32) {
          uint64_t v42 = v31 >> 32;
        }
        long long v48 = (uint64_t *)(*(void *)(*(void *)(a1 + 56) + 80 * (int)v31 + 40) + 8 * v42);
        int v49 = v46 - v43 + 1;
        do
        {
          uint64_t v50 = *v48++;
          *(void *)(v47 + 8 * *(int *)(v50 + 88)) = -1;
          --v49;
        }
        while (v49);
      }
      ++v29;
      LODWORD(v30) = *(_DWORD *)(a1 + 64);
      if (v29 >= (int)v30) {
        goto LABEL_34;
      }
    }
    LODWORD(v30) = *(_DWORD *)(a1 + 64);
LABEL_34:
    unint64_t v28 = v105;
  }
  if ((int)v30 < 1)
  {
    int v93 = 0;
    int v96 = v103;
    uint64_t v92 = v104;
    goto LABEL_91;
  }
  uint64_t v51 = 0;
  do
  {
    uint64_t v52 = v51;
    uint64_t v53 = *(void *)(a1 + 56);
    int v54 = *(_DWORD *)&v28[4 * v51];
    uint64_t v55 = *(int *)&v17[4 * v51];
    if (v54 >= (int)v55)
    {
      uint64_t v58 = v53 + 80 * v51;
      signed int v56 = v54 - v55 + 1;
      sub_1B651106C(v58, v54 + 1, ~(v54 - v55), v22, v23, v24, v25, v26);
      int v59 = *(_DWORD *)(v58 + 72);
      long long v57 = (int *)(v58 + 72);
      int v60 = v59 - v56;
      *long long v57 = v59 - v56;
      if (v54 - v55 == -1)
      {
        signed int v56 = 0;
      }
      else
      {
        long long v61 = (int32x2_t *)(v53 + 80 * v51);
        int32x2_t v63 = v61[8];
        uint64_t v62 = v61 + 8;
        int32x2_t v64 = v63;
        int v65 = v63.i32[0];
        int v66 = v63.i32[1];
        if (v63.i32[0] <= v63.i32[1])
        {
          if ((int)v55 <= v65)
          {
            *uint64_t v62 = vmax_s32(vsub_s32(v64, vdup_n_s32(v56)), 0);
          }
          else if (v54 <= v66)
          {
            __int32 v67 = v60 - 1;
            if (v66 < v67) {
              __int32 v67 = v66;
            }
            v62->i32[1] = v67;
          }
        }
      }
    }
    else
    {
      signed int v56 = 0;
      long long v57 = (int *)(v53 + 80 * v51 + 72);
    }
    ++v51;
    if (v52 + 1 < *(int *)(a1 + 64))
    {
      int v68 = *(_DWORD *)&v28[4 * v51];
      int v69 = *(_DWORD *)&v17[4 * v51];
      if (v68 >= v69 && *v57 >= 1)
      {
        uint64_t v70 = 0;
        uint64_t v71 = *(void *)(v53 + 80 * v52 + 32);
        uint64_t v72 = *(void *)(a1 + 56) + 80 * v51;
        uint64_t v73 = (_DWORD *)(v72 + 72);
        uint64_t v74 = (void *)(v72 + 24);
        uint64_t v75 = v68 + 1;
        while (1)
        {
          int v76 = *(_DWORD *)(v71 + 4 * v70);
          if (v76 > v68) {
            break;
          }
          if (v76 >= v69)
          {
            if ((int)v75 >= *v73 || (int v77 = v69, v70 != *(_DWORD *)(*v74 + 4 * v75))) {
              int v77 = -1;
            }
            goto LABEL_58;
          }
LABEL_59:
          if (++v70 >= *v57) {
            goto LABEL_60;
          }
        }
        int v77 = v69 + ~v68 + v76;
LABEL_58:
        *(_DWORD *)(v71 + 4 * v70) = v77;
        goto LABEL_59;
      }
    }
LABEL_60:
    if (v52)
    {
      int v78 = *(_DWORD *)&v28[4 * (v52 - 1)];
      int v79 = *(_DWORD *)&v17[4 * (v52 - 1)];
      if (v78 >= v79)
      {
        LODWORD(v80) = v55 == 0x7FFFFFFF ? 0 : v55;
        int v81 = *v57;
        if ((int)v80 < *v57)
        {
          int v82 = v79 + ~v78;
          uint64_t v83 = *(void *)(v53 + 80 * v52 + 24);
          uint64_t v80 = (int)v80;
          do
          {
            int v84 = *(_DWORD *)(v83 + 4 * v80);
            if (v84 >= v79)
            {
              *(_DWORD *)(v83 + 4 * v80) = v82 + v84;
              int v81 = *v57;
            }
            ++v80;
          }
          while (v80 < v81);
        }
      }
    }
    uint64_t v85 = v17;
    if (v56 >= 1)
    {
      if (v55 == 0x7FFFFFFF) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v21, v22, v23, v24, v25, v26, (uint64_t)"firstChildToRemainAfterDeletion != INT32_MAX");
      }
      int v86 = *v57;
      if ((int)v55 < *v57)
      {
        uint64_t v87 = (void *)(v53 + 80 * v52 + 40);
        uint64_t v88 = *(void *)(a1 + 24);
        uint64_t v89 = v55;
        do
        {
          uint64_t v90 = *(void *)(*v87 + 8 * v89);
          uint64_t v91 = *(int *)(v90 + 88);
          if (*(void *)(v88 + 8 * v91) != -1)
          {
            if (v52 != *(_DWORD *)(v88 + 8 * v91))
            {
              sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v21, v22, v23, v24, v25, v26, (uint64_t)"_handles[ node->_transformHandle ].level == l");
              uint64_t v91 = *(int *)(v90 + 88);
              uint64_t v88 = *(void *)(a1 + 24);
            }
            if (*(_DWORD *)(v88 + 8 * v91 + 4) < (int)v55)
            {
              sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v21, v22, v23, v24, v25, v26, (uint64_t)"_handles[ node->_transformHandle ].index >= minIndexToDestroyPerLevel[ l ]");
              uint64_t v91 = *(int *)(v90 + 88);
              uint64_t v88 = *(void *)(a1 + 24);
            }
            *(_DWORD *)(v88 + 8 * v91 + 4) -= v56;
            int v86 = *v57;
          }
          ++v89;
        }
        while (v89 < v86);
      }
    }
    uint64_t v30 = *(int *)(a1 + 64);
    int v17 = v85;
    unint64_t v28 = v105;
  }
  while (v51 < v30);
  uint64_t v92 = v104;
  int v93 = 0;
  if ((int)v30 < 1)
  {
    int v96 = v103;
  }
  else
  {
    uint64_t v94 = *(unsigned int *)(a1 + 64);
    uint64_t v95 = (int *)(*(void *)(a1 + 56) + 72);
    int v96 = v103;
    do
    {
      int v97 = *v95;
      v95 += 20;
      if (v97) {
        ++v93;
      }
      --v94;
    }
    while (v94);
  }
LABEL_91:
  if (v93 < (int)v30) {
    sub_1B6510690(a1, v93);
  }
  uint64_t v98 = (_DWORD *)(*(void *)(a1 + 24) + 8 * v92);
  int v99 = *(_DWORD *)(a1 + 48);
  *uint64_t v98 = -1;
  v98[1] = v99;
  *(_DWORD *)(a1 + 48) = v96;
  uint64_t v100 = v102;

  os_unfair_lock_unlock(v100);
}

void sub_1B650FDCC(uint64_t a1, int a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }

  sub_1B650FE40(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B650FE40(uint64_t a1, int a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. invalid handle (%d) given", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  }
  int v11 = (int *)(*(void *)(a1 + 24) + 8 * a2);
  int v12 = v11[1];
  if (v12 != -1)
  {
    int v13 = *v11;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 76));
    *(unsigned char *)(a1 + 68) = 1;
    if (v13 >= *(_DWORD *)(a1 + 64)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v14, v15, v16, v17, v18, v19, (uint64_t)"handle.level < _levelCount");
    }
    uint64_t v20 = *(void *)(a1 + 56);
    long long v21 = a3[1];
    long long v22 = a3[2];
    long long v23 = a3[3];
    uint64_t v24 = v20 + 80 * v13;
    uint64_t v25 = (_OWORD *)(*(void *)(v24 + 16) + ((uint64_t)v12 << 6));
    *uint64_t v25 = *a3;
    v25[1] = v21;
    uint64_t v25[2] = v22;
    v25[3] = v23;
    int v27 = *(_DWORD *)(v24 + 64);
    uint64_t v26 = (_DWORD *)(v24 + 64);
    if (v12 < v27) {
      *uint64_t v26 = v12;
    }
    uint64_t v28 = v20 + 80 * v13;
    int v30 = *(_DWORD *)(v28 + 68);
    int v29 = (_DWORD *)(v28 + 68);
    if (v12 > v30) {
      *int v29 = v12;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 76));
  }
}

void sub_1B650FF78(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }
  if (a2 == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. invalid handle (%d) given", a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  }
  int v11 = (int *)(*(void *)(a1 + 24) + 8 * a2);
  uint64_t v12 = v11[1];
  if (v12 != -1)
  {
    int v13 = *v11;
    if (*v11 >= *(_DWORD *)(a1 + 64)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"handle.level < transformTree->_levelCount");
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 80 * v13 + 56) + 4 * v12) = v8;
  }
}

uint64_t sub_1B651004C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }
  if (a2 == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. invalid handle (%d) given", a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  }
  unint64_t v10 = *(void *)(*(void *)(a1 + 24) + 8 * a2);
  if (*(unsigned char *)(a1 + 68)) {
    sub_1B65102B8(a1);
  }
  if (HIDWORD(v10) == 0xFFFFFFFF) {
    LODWORD(v11) = 0;
  }
  else {
    unint64_t v11 = HIDWORD(v10);
  }
  if (HIDWORD(v10) == 0xFFFFFFFF) {
    int v12 = 0;
  }
  else {
    int v12 = -1;
  }
  if (v10 == 0xFFFFFFFFLL) {
    LODWORD(v13) = v11;
  }
  else {
    unint64_t v13 = HIDWORD(v10);
  }
  if (v10 == 0xFFFFFFFFLL) {
    int v14 = v12;
  }
  else {
    int v14 = v10;
  }
  return *(void *)(*(void *)(a1 + 56) + 80 * v14) + ((uint64_t)(int)v13 << 6);
}

uint64_t sub_1B6510114(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }
  if (a2 == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. invalid handle (%d) given", a3, a4, a5, a6, a7, a8, (uint64_t)"hnd != kCFXTransformHandleInvalid");
  }
  unint64_t v10 = *(void *)(*(void *)(a1 + 24) + 8 * a2);
  unint64_t v11 = HIDWORD(v10);
  if (HIDWORD(v10) == 0xFFFFFFFF) {
    int v12 = 0;
  }
  else {
    int v12 = -1;
  }
  if (HIDWORD(v10) == 0xFFFFFFFF) {
    LODWORD(v13) = 0;
  }
  else {
    unint64_t v13 = HIDWORD(v10);
  }
  if (*(void *)(*(void *)(a1 + 24) + 8 * a2) == 0xFFFFFFFFLL)
  {
    LODWORD(v10) = v12;
    LODWORD(v11) = v13;
  }
  return *(void *)(*(void *)(a1 + 56) + 80 * (int)v10 + 8) + ((uint64_t)(int)v11 << 6);
}

void sub_1B65101CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }

  sub_1B65102B8(a1);
}

void sub_1B6510228(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformTree");
  }
  if (*(int *)(a1 + 64) >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    do
    {
      memcpy(*(void **)(*(void *)(a1 + 56) + v9 + 8), *(const void **)(*(void *)(a1 + 56) + v9), (uint64_t)*(int *)(*(void *)(a1 + 56) + v9 + 72) << 6);
      ++v10;
      v9 += 80;
    }
    while (v10 < *(int *)(a1 + 64));
  }
}

void sub_1B65102B8(uint64_t a1)
{
  locunint64_t k = (os_unfair_lock_s *)(a1 + 76);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 76));
  *(unsigned char *)(a1 + 68) = 0;
  if (*(_DWORD *)(a1 + 64))
  {
    uint64_t v9 = sub_1B63F4F54(**(void ***)(*(void *)(a1 + 56) + 40), v2, v3, v4, v5, v6, v7, v8);
    if (v9)
    {
      uint64_t v17 = sub_1B64B2994(v9, v10, v11, v12, v13, v14, v15, v16);
      int v23 = *(_DWORD *)(a1 + 64);
      if (v23 >= 1)
      {
        uint64_t v24 = v17;
        uint64_t v25 = 0;
        uint64_t v26 = *(uint64_t **)(a1 + 56);
        while (1)
        {
          uint64_t v27 = *(void *)(a1 + 56);
          uint64_t v28 = v27 + 80 * v25;
          int v30 = (_DWORD *)(v28 + 68);
          int v29 = *(_DWORD *)(v28 + 68);
          unint64_t v32 = (_DWORD *)(v28 + 64);
          uint64_t v31 = *(int *)(v28 + 64);
          if (v29 >= (int)v31) {
            break;
          }
LABEL_23:
          ++v25;
          uint64_t v26 = (uint64_t *)v28;
          if (v25 >= v23) {
            goto LABEL_27;
          }
        }
        if (v25)
        {
          uint64_t v33 = v27 + 80 * v25;
          uint64_t v34 = *v26;
          uint64_t v36 = *(void *)(v33 + 16);
          uint64_t v35 = *(void *)(v33 + 24);
          int v37 = v29 + 1;
          uint64_t v38 = *(void *)v28 + (v31 << 6);
          uint64_t v39 = v36 + (v31 << 6);
          float32x4_t v40 = 0uLL;
          int v41 = -1;
          float32x4_t v42 = 0uLL;
          float32x4_t v43 = 0uLL;
          float32x4_t v44 = 0uLL;
          do
          {
            int v45 = *(_DWORD *)(v35 + 4 * v31);
            if (v41 != v45)
            {
              int v46 = (float32x4_t *)(v34 + ((uint64_t)v45 << 6));
              float32x4_t v40 = *v46;
              float32x4_t v42 = v46[1];
              float32x4_t v43 = v46[2];
              float32x4_t v44 = v46[3];
              int v41 = *(_DWORD *)(v35 + 4 * v31);
            }
            for (uint64_t i = 0; i != 64; i += 16)
              *(float32x4_t *)(v38 + i) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v42, *(float32x2_t *)(v39 + i), 1), v40, COERCE_FLOAT(*(_OWORD *)(v39 + i))), v43, *(float32x4_t *)(v39 + i), 2), v44, *(float32x4_t *)(v39 + i), 3);
            ++v31;
            v38 += 64;
            v39 += 64;
          }
          while (v37 != v31);
          if (!v24) {
            goto LABEL_15;
          }
        }
        else
        {
          memcpy((void *)(*(void *)v28 + (v31 << 6)), (const void *)(*(void *)(v27 + 16) + (v31 << 6)), (uint64_t)(v29 - (int)v31 + 1) << 6);
          if (!v24) {
            goto LABEL_15;
          }
        }
        sub_1B65C510C(v24, (int *)(*(void *)(v27 + 80 * v25 + 56) + 4 * *v32), *(void *)v28 + ((unint64_t)*v32 << 6), (*v30 - *v32 + 1), v19, v20, v21, v22);
LABEL_15:
        if (v25 != *(_DWORD *)(a1 + 64) - 1)
        {
          uint64_t v48 = *(void *)(a1 + 56);
          uint64_t v49 = v25 + 1;
          unint64_t v50 = v25 | ((unint64_t)*v32 << 32);
          unint64_t v51 = v25 | ((unint64_t)*v30 << 32);
          unint64_t v52 = sub_1B6511280(a1, v50, v51, v18, v19, v20, v21, v22);
          if (HIDWORD(v52) != -1)
          {
            uint64_t v58 = v48 + 80 * v49;
            int v60 = *(_DWORD *)(v58 + 64);
            int v59 = (_DWORD *)(v58 + 64);
            if (v60 > SHIDWORD(v52)) {
              *int v59 = HIDWORD(v52);
            }
          }
          unint64_t v61 = sub_1B651135C(a1, v50, v51, v53, v54, v55, v56, v57);
          if (HIDWORD(v61) != -1)
          {
            uint64_t v62 = v48 + 80 * v49;
            int v64 = *(_DWORD *)(v62 + 68);
            int32x2_t v63 = (_DWORD *)(v62 + 68);
            if (v64 < SHIDWORD(v61)) {
              *int32x2_t v63 = HIDWORD(v61);
            }
          }
        }
        *(void *)unint64_t v32 = 0x800000007FFFFFFFLL;
        int v23 = *(_DWORD *)(a1 + 64);
        goto LABEL_23;
      }
    }
  }
LABEL_27:

  os_unfair_lock_unlock(lock);
}

CFStringRef sub_1B6510524(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXTransformTree %p>", a1);
}

CFStringRef sub_1B6510564(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXTransformTree %p>", a1);
}

uint64_t sub_1B65105A4(uint64_t a1)
{
  if (*(int *)(a1 + 64) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      sub_1B6510624(*(void *)(a1 + 56) + v2);
      ++v3;
      v2 += 80;
    }
    while (v3 < *(int *)(a1 + 64));
  }
  free(*(void **)(a1 + 56));
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + 32) = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_1B6510624(uint64_t a1)
{
  free(*(void **)a1);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  free(*(void **)(a1 + 24));
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  uint64_t v2 = *(void **)(a1 + 56);

  free(v2);
}

void sub_1B6510690(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 64) != a2)
  {
    uint64_t v4 = (char *)malloc_type_calloc(0x50uLL, a2, 0x6604B0D5uLL);
    uint64_t v5 = v4;
    int v6 = *(_DWORD *)(a1 + 64);
    if (v6 >= a2)
    {
      if (a2 < 1)
      {
        int v20 = 0;
      }
      else
      {
        uint64_t v14 = 0;
        do
        {
          uint64_t v15 = &v4[v14];
          uint64_t v16 = (_OWORD *)(*(void *)(a1 + 56) + v14);
          *(_OWORD *)uint64_t v15 = *v16;
          long long v17 = v16[1];
          long long v18 = v16[2];
          long long v19 = v16[4];
          *((_OWORD *)v15 + 3) = v16[3];
          *((_OWORD *)v15 + 4) = v19;
          *((_OWORD *)v15 + 1) = v17;
          *((_OWORD *)v15 + 2) = v18;
          v14 += 80;
        }
        while (80 * a2 != v14);
        int v6 = *(_DWORD *)(a1 + 64);
        int v20 = a2;
      }
      if (v20 < v6)
      {
        uint64_t v23 = 80 * v20;
        do
        {
          sub_1B6510624(*(void *)(a1 + 56) + v23);
          v23 += 80;
          ++v20;
        }
        while (*(_DWORD *)(a1 + 64) > v20);
      }
    }
    else
    {
      if (v6 < 1)
      {
        LODWORD(v8) = 0;
      }
      else
      {
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        do
        {
          uint64_t v9 = &v4[v7];
          uint64_t v10 = (_OWORD *)(*(void *)(a1 + 56) + v7);
          *(_OWORD *)uint64_t v9 = *v10;
          long long v11 = v10[1];
          long long v12 = v10[2];
          long long v13 = v10[4];
          *((_OWORD *)v9 + 3) = v10[3];
          *((_OWORD *)v9 + 4) = v13;
          *((_OWORD *)v9 + 1) = v11;
          *((_OWORD *)v9 + 2) = v12;
          ++v8;
          v7 += 80;
        }
        while (v8 < *(int *)(a1 + 64));
      }
      if ((int)v8 < a2)
      {
        uint64_t v21 = (uint64_t)&v4[80 * v8];
        unint64_t v22 = a2 - (unint64_t)v8;
        do
        {
          sub_1B651080C(v21, 0x80u);
          v21 += 80;
          --v22;
        }
        while (v22);
      }
    }
    free(*(void **)(a1 + 56));
    *(void *)(a1 + 56) = v5;
    *(_DWORD *)(a1 + 64) = a2;
  }
}

double sub_1B651080C(uint64_t a1, unsigned int a2)
{
  size_t v4 = (unint64_t)a2 << 6;
  uint64_t v5 = *(int *)(a1 + 76);
  uint64_t v6 = v5 << 6;
  uint64_t v7 = *(void **)a1;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = (char *)memptr;
  }
  if (v5) {
    memcpy(v8, v7, v5 << 6);
  }
  size_t v9 = (v4 - v6);
  if ((int)v9 >= 1) {
    bzero(&v8[v6], (v4 - v6));
  }
  if (v7) {
    free(v7);
  }
  *(void *)a1 = v8;
  uint64_t v10 = *(void **)(a1 + 8);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL)) {
    long long v11 = 0;
  }
  else {
    long long v11 = (char *)memptr;
  }
  if (v5) {
    memcpy(v11, v10, v5 << 6);
  }
  if ((int)v9 >= 1) {
    bzero(&v11[v6], (v4 - v6));
  }
  if (v10) {
    free(v10);
  }
  *(void *)(a1 + 8) = v11;
  long long v12 = *(void **)(a1 + 16);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, v4, 0xBA8A1232uLL)) {
    long long v13 = 0;
  }
  else {
    long long v13 = (char *)memptr;
  }
  if (v5) {
    memcpy(v13, v12, v5 << 6);
  }
  int v14 = 4 * a2;
  if ((int)v9 >= 1) {
    bzero(&v13[v6], v9);
  }
  uint64_t v15 = 4 * v5;
  if (v12) {
    free(v12);
  }
  *(void *)(a1 + 16) = v13;
  uint64_t v16 = *(void **)(a1 + 24);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    long long v17 = 0;
  }
  else {
    long long v17 = (char *)memptr;
  }
  if (v5) {
    memcpy(v17, v16, 4 * v5);
  }
  int v18 = v14 - v15;
  if (v14 - (int)v15 >= 1) {
    bzero(&v17[v15], (v14 - v15));
  }
  if (v16) {
    free(v16);
  }
  *(void *)(a1 + 24) = v17;
  long long v19 = *(void **)(a1 + 32);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    int v20 = 0;
  }
  else {
    int v20 = (char *)memptr;
  }
  if (v5) {
    memcpy(v20, v19, 4 * v5);
  }
  if (v18 >= 1) {
    bzero(&v20[v15], (v14 - v15));
  }
  uint64_t v21 = 8 * v5;
  if (v19) {
    free(v19);
  }
  *(void *)(a1 + 32) = v20;
  unint64_t v22 = *(void **)(a1 + 40);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 8 * a2, 0xBA8A1232uLL)) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = (char *)memptr;
  }
  if (v5) {
    memcpy(v23, v22, 8 * v5);
  }
  size_t v24 = 8 * a2 - v21;
  if ((int)v24 >= 1) {
    bzero(&v23[v21], v24);
  }
  if (v22) {
    free(v22);
  }
  *(void *)(a1 + 40) = v23;
  uint64_t v25 = *(void **)(a1 + 48);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = (char *)memptr;
  }
  if (v5) {
    memcpy(v26, v25, 4 * v5);
  }
  if (v18 >= 1) {
    bzero(&v26[v15], (v14 - v15));
  }
  if (v25) {
    free(v25);
  }
  *(void *)(a1 + 48) = v26;
  uint64_t v27 = *(void **)(a1 + 56);
  uint64_t v28 = *(int *)(a1 + 76);
  uint64_t v29 = 4 * v28;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 4 * a2, 0xBA8A1232uLL)) {
    int v30 = 0;
  }
  else {
    int v30 = (char *)memptr;
  }
  if (v28) {
    memcpy(v30, v27, 4 * v28);
  }
  size_t v31 = (v14 - v29);
  if ((int)v31 >= 1) {
    bzero(&v30[v29], v31);
  }
  if (v27) {
    free(v27);
  }
  *(void *)(a1 + 56) = v30;
  if ((int)v24 >= 1) {
    bzero((void *)(*(void *)(a1 + 40) + v21), v24);
  }
  uint64_t v32 = a2 - 1;
  uint64_t v33 = *(unsigned int *)(a1 + 76);
  uint64_t v34 = *(void *)(a1 + 24);
  if (v33 < v32)
  {
    do
    {
      *(_DWORD *)(v34 + 4 * v33) = v33 + 1;
      ++v33;
    }
    while (v32 != v33);
  }
  *(_DWORD *)(v34 + 4 * v32) = -1;
  *(void *)&double result = 0x800000007FFFFFFFLL;
  *(void *)(a1 + 64) = 0x800000007FFFFFFFLL;
  *(_DWORD *)(a1 + 76) = a2;
  return result;
}

void sub_1B6510C00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  uint64_t v12 = HIDWORD(a2);
  uint64_t v13 = *(void *)(a1 + 56);
  int v14 = a2;
  uint64_t v15 = v13 + 80 * (int)a2;
  uint64_t v16 = *(int *)(v15 + 72);
  if ((int)v16 > SHIDWORD(a2))
  {
    uint64_t v17 = *(void *)(a1 + 24);
    int v18 = (int *)(*(void *)(v13 + 80 * (int)a2 + 48) + 4 * (a2 >> 32));
    uint64_t v19 = v16 - (a2 >> 32);
    do
    {
      uint64_t v20 = *v18++;
      uint64_t v21 = v17 + 8 * v20;
      LODWORD(v20) = *(_DWORD *)(v21 + 4);
      unint64_t v22 = (_DWORD *)(v21 + 4);
      int v23 = v20;
      if ((int)v20 >= SHIDWORD(a2)) {
        *unint64_t v22 = v23 + a4;
      }
      --v19;
    }
    while (v19);
  }
  sub_1B651106C(v15, SHIDWORD(a2), a4, a4, a5, a6, a7, a8);
  uint64_t v28 = v13 + 80 * v14;
  int v31 = *(_DWORD *)(v28 + 68);
  uint64_t v29 = (_DWORD *)(v28 + 68);
  int v30 = v31;
  if (v31 >= (int)v12)
  {
    uint64_t v32 = v13 + 80 * v14;
    int v35 = *(_DWORD *)(v32 + 64);
    uint64_t v33 = (_DWORD *)(v32 + 64);
    int v34 = v35;
    if (v35 > (int)v12) {
      *uint64_t v33 = v34 + a4;
    }
    *uint64_t v29 = v30 + a4;
  }
  if (a3 != -1) {
    sub_1B65111E4(*(void *)(a1 + 56) + 80 * (int)a3, SHIDWORD(a3), v12, a4, v24, v25, v26, v27);
  }
  uint64_t v36 = v10 + 1;
  if ((int)v36 < *(_DWORD *)(a1 + 64))
  {
    uint64_t v37 = v12;
    while ((int)v37 >= 2)
    {
      uint64_t v38 = *(void *)(v13 + 80 * v14 + 32) + 4 * v37--;
      LODWORD(v38) = *(_DWORD *)(v38 - 4);
      if (v38 != -1) {
        goto LABEL_18;
      }
    }
    LODWORD(v38) = 0;
LABEL_18:
    uint64_t v39 = *(void *)(a1 + 56);
    uint64_t v40 = v39 + 80 * v36;
    int v43 = *(_DWORD *)(v40 + 72);
    int v41 = (int *)(v40 + 72);
    int v42 = v43;
    if ((int)v38 < v43)
    {
      uint64_t v44 = *(void *)(v39 + 80 * v36 + 24);
      uint64_t v38 = (int)v38;
      do
      {
        int v45 = *(_DWORD *)(v44 + 4 * v38);
        if (v45 >= (int)v12)
        {
          *(_DWORD *)(v44 + 4 * v38) = v45 + a4;
          int v42 = *v41;
        }
        ++v38;
      }
      while (v38 < v42);
    }
  }
}

__n128 sub_1B6510DA4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  int v3 = a2;
  size_t v4 = (void *)(v2 + 80 * (int)a2);
  uint64_t v5 = a2 >> 32;
  int v6 = a2 - 1;
  if (a2 == 0x100000000)
  {
    uint64_t v7 = (long long *)(*(void *)(v2 + 80 * (int)a2 + 16) + (v5 << 6));
    uint64_t v8 = (_OWORD *)(*v4 + (v5 << 6));
    long long v9 = *v7;
    long long v10 = v7[1];
    long long v11 = v7[3];
    v8[2] = v7[2];
    v8[3] = v11;
    *uint64_t v8 = v9;
    v8[1] = v10;
  }
  else
  {
    uint64_t v13 = v2 + 80 * (int)a2;
    uint64_t v14 = *(int *)(*(void *)(v13 + 24) + 4 * v5);
    sub_1B6510DA4();
    uint64_t v15 = 0;
    uint64_t v16 = (float32x4_t *)(*(void *)(*(void *)(a1 + 56) + 80 * v6) + (v14 << 6));
    uint64_t v17 = *v4 + (v5 << 6);
    uint64_t v18 = *(void *)(v13 + 16) + (v5 << 6);
    do
    {
      *(float32x4_t *)(v17 + v15) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v16[1], *(float32x2_t *)(v18 + v15), 1), *v16, COERCE_FLOAT(*(_OWORD *)(v18 + v15))), v16[2], *(float32x4_t *)(v18 + v15), 2), v16[3], *(float32x4_t *)(v18 + v15), 3);
      v15 += 16;
    }
    while (v15 != 64);
  }
  uint64_t v19 = *v4 + (v5 << 6);
  uint64_t v20 = *(void *)(v2 + 80 * v3 + 8) + (v5 << 6);
  __n128 result = *(__n128 *)v19;
  long long v22 = *(_OWORD *)(v19 + 16);
  long long v23 = *(_OWORD *)(v19 + 48);
  *(_OWORD *)(v20 + 32) = *(_OWORD *)(v19 + 32);
  *(_OWORD *)(v20 + 48) = v23;
  *(__n128 *)uint64_t v20 = result;
  *(_OWORD *)(v20 + 16) = v22;
  return result;
}

uint64_t sub_1B6510EC4(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(unsigned int *)(a1 + 48);
  if (result == -1)
  {
    unint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void **)(a1 + 32);
    if ((unint64_t)v7 >= v6)
    {
      uint64_t v9 = *(void *)(a1 + 24);
      uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v6 - v9;
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13) {
        uint64_t v14 = (char *)sub_1B64285D4(a1 + 40, v13);
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v15 = &v14[8 * v10];
      uint64_t v16 = &v14[8 * v13];
      *(void *)uint64_t v15 = a2;
      uint64_t v8 = v15 + 8;
      uint64_t v18 = *(char **)(a1 + 24);
      uint64_t v17 = *(char **)(a1 + 32);
      if (v17 != v18)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *((void *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        uint64_t v17 = *(char **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v15;
      *(void *)(a1 + 32) = v8;
      *(void *)(a1 + 40) = v16;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      *uint64_t v7 = a2;
      uint64_t v8 = v7 + 1;
    }
    *(void *)(a1 + 32) = v8;
    return (((unint64_t)v8 - *(void *)(a1 + 24)) >> 3) - 1;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 24) + 8 * (int)result;
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v5 + 4);
    *(void *)uint64_t v5 = a2;
  }
  return result;
}

void sub_1B6510FD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  int v10 = HIDWORD(a2);
  if (a3 + 1 != a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. child must be one level under parent", a3, a4, a5, a6, a7, a8, (uint64_t)"newHandle.level == (parentHandle.level + 1)");
  }
  if (a3 != -1)
  {
    uint64_t v12 = *(void *)(a1 + 56);
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 80 * (int)a3 + 32);
      if (*(_DWORD *)(v13 + 4 * (a3 >> 32)) == v8) {
        *(_DWORD *)(v13 + 4 * (a3 >> 32)) = v10;
      }
    }
  }
}

void sub_1B651106C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 72);
  unsigned int v9 = v8 - a2;
  if (v8 - a2 < 0)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. can't move negative number of data", a3, a4, a5, a6, a7, a8, (uint64_t)"countToMove >= 0");
  }
  else if (v8 != a2)
  {
    int v10 = a3;
    if (v8 + (int)a3 > *(_DWORD *)(a1 + 76)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. overflow !", a3, a4, a5, a6, a7, a8, (uint64_t)"(handle + offset + countToMove) <= _capacity");
    }
    uint64_t v13 = (char *)(*(void *)(a1 + 24) + 4 * a2);
    memmove(&v13[4 * v10], v13, 4 * v9);
    uint64_t v14 = (char *)(*(void *)(a1 + 32) + 4 * a2);
    memmove(&v14[4 * v10], v14, 4 * v9);
    uint64_t v15 = (char *)(*(void *)(a1 + 40) + 8 * a2);
    memmove(&v15[8 * v10], v15, 8 * v9);
    uint64_t v16 = (char *)(*(void *)(a1 + 48) + 4 * a2);
    memmove(&v16[4 * v10], v16, 4 * v9);
    uint64_t v17 = (char *)(*(void *)(a1 + 56) + 4 * a2);
    memmove(&v17[4 * v10], v17, 4 * v9);
    memmove((void *)(*(void *)a1 + ((uint64_t)a2 << 6) + ((uint64_t)v10 << 6)), (const void *)(*(void *)a1 + ((uint64_t)a2 << 6)), (unint64_t)v9 << 6);
    uint64_t v18 = (char *)(*(void *)(a1 + 8) + ((uint64_t)a2 << 6));
    memmove(&v18[64 * (uint64_t)v10], v18, (unint64_t)v9 << 6);
    uint64_t v19 = (char *)(*(void *)(a1 + 16) + ((uint64_t)a2 << 6));
    memmove(&v19[64 * (uint64_t)v10], v19, (unint64_t)v9 << 6);
  }
}

void sub_1B65111E4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  int v9 = a3;
  int v12 = *(_DWORD *)(a1 + 72);
  if (v12 <= a2)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"startParentHandle < _count");
    int v12 = *(_DWORD *)(a1 + 72);
  }
  if (v12 > a2)
  {
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = a2;
    do
    {
      int v15 = *(_DWORD *)(v13 + 4 * v14);
      if (v15 >= v9)
      {
        *(_DWORD *)(v13 + 4 * v14) = v15 + v8;
        int v12 = *(_DWORD *)(a1 + 72);
      }
      ++v14;
    }
    while (v14 < v12);
  }
}

unint64_t sub_1B6511280(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = HIDWORD(a2);
  unint64_t v11 = HIDWORD(a3);
  if (a2 != a3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.level == lastHandle.level");
  }
  if ((int)v10 > (int)v11)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.index <= lastHandle.index");
LABEL_9:
    unsigned int v12 = -1;
    uint64_t v15 = 0xFFFFFFFFLL;
    return v12 | (unint64_t)(v15 << 32);
  }
  unsigned int v12 = a2 + 1;
  if (a2 + 1 == *(_DWORD *)(a1 + 64)) {
    goto LABEL_9;
  }
  uint64_t v13 = (unsigned int *)(*(void *)(*(void *)(a1 + 56) + 80 * (int)a2 + 32) + 4 * (a2 >> 32));
  int v14 = v11 - HIDWORD(a2) + 1;
  while (1)
  {
    unsigned int v16 = *v13++;
    uint64_t v15 = v16;
    if (v16 != -1) {
      return v12 | (unint64_t)(v15 << 32);
    }
    if (!--v14) {
      goto LABEL_9;
    }
  }
}

unint64_t sub_1B651135C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11 = HIDWORD(a2);
  unint64_t v12 = HIDWORD(a3);
  if (a2 != a3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.level == lastHandle.level");
  }
  if ((int)v11 > (int)v12)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"firstHandle.index <= lastHandle.index");
LABEL_6:
    uint64_t v13 = 0xFFFFFFFFLL;
    LODWORD(v14) = -1;
    return v14 | (unint64_t)(v13 << 32);
  }
  if (a2 + 1 == *(_DWORD *)(a1 + 64)) {
    goto LABEL_6;
  }
  uint64_t v14 = (a3 + 1);
  uint64_t v16 = a3 >> 32;
  while (1)
  {
    uint64_t v13 = *(unsigned int *)(*(void *)(*(void *)(a1 + 56) + 80 * (int)a2 + 32) + 4 * v16);
    if (v13 != -1) {
      break;
    }
    if (v16-- <= a2 >> 32)
    {
      uint64_t v13 = 0xFFFFFFFFLL;
      LODWORD(v14) = -1;
      return v14 | (unint64_t)(v13 << 32);
    }
  }
  unint64_t v18 = sub_1B6511498(a1, v14 | (v13 << 32));
  unint64_t v19 = HIDWORD(v18);
  if (HIDWORD(v18) != -1)
  {
    do
    {
      int v20 = v18;
      uint64_t v13 = v19;
      unint64_t v18 = sub_1B6511498(a1, v18);
      unint64_t v19 = HIDWORD(v18);
    }
    while (HIDWORD(v18) != -1);
    LODWORD(v14) = v20;
  }
  return v14 | (unint64_t)(v13 << 32);
}

unint64_t sub_1B6511498(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  int v3 = HIDWORD(a2) + 1;
  if (HIDWORD(a2) + 1 < *(_DWORD *)(v2 + 80 * (int)a2 + 72)
    && (uint64_t v4 = *(void *)(v2 + 80 * (int)a2 + 24), *(_DWORD *)(v4 + 4 * v3) == *(_DWORD *)(v4 + 4 * (a2 >> 32))))
  {
    return a2 | ((unint64_t)v3 << 32);
  }
  else
  {
    return -1;
  }
}

void sub_1B65114F0()
{
  if (!qword_1E9DDB1C0)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1E9DDB1C0);
    qword_1E9DDB1C0 = (uint64_t)v0;
    uint64_t v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E3EC();
  }
}

uint64_t sub_1B6511564(uint64_t a1)
{
  if (qword_1E9DDB1C8 != -1) {
    dispatch_once(&qword_1E9DDB1C8, &unk_1F0FB5B68);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1E9DDB1C0, 0x10uLL);
  int v3 = *(void **)(a1 + 16);
  *(void *)(v2 + 16) = v3;
  *(void *)(v2 + 24) = (id)objc_msgSend_makeDefaultCamera(v3, v4, v5, v6);
  return v2;
}

void sub_1B65115E0()
{
  if (!qword_1E9DDB1D0)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1E9DDB1D0);
    qword_1E9DDB1D0 = (uint64_t)v0;
    uint64_t v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E3EC();
  }
}

uint64_t sub_1B6511654(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!sub_1B64B2718(a1, 1, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  if (qword_1E9DDB1D8 != -1) {
    dispatch_once(&qword_1E9DDB1D8, &unk_1F0FB6388);
  }
  uint64_t v9 = sub_1B63C8D44(qword_1E9DDB1D0, 8uLL);
  BOOL v16 = sub_1B64B2718(a1, 2, v10, v11, v12, v13, v14, v15);
  uint64_t v17 = objc_opt_new();
  objc_msgSend_setWorld_(v17, v18, a1, v19);
  objc_msgSend_setIsVFX2_(v17, v20, 1, v21);
  objc_msgSend_setSetupRenderer_(v17, v22, 1, v23);
  objc_msgSend_setIsAuthoringWorld_(v17, v24, v16, v25);
  objc_msgSend_setAutomaticallyPrepareScene_(v17, v26, 0, v27);
  objc_msgSend_setEnableRuntimeScriptCompilation_(v17, v28, v16, v29);
  uint64_t v37 = sub_1B64B2110(a1, v30, v31, v32, v33, v34, v35, v36);
  objc_msgSend_setMetalLibraryURL_(v17, v38, v37, v39);
  objc_msgSend_setSetupAsyncRuntime_(v17, v40, 0, v41);
  uint64_t v42 = sub_1B64B248C(a1);
  objc_msgSend_setAsyncRuntimeLock_(v17, v43, v42, v44);
  uint64_t v52 = sub_1B64B393C(a1, v45, v46, v47, v48, v49, v50, v51);
  objc_msgSend_setCounterStorage_(v17, v53, v52, v54);
  id v55 = MTLCreateSystemDefaultDevice();
  uint64_t v56 = sub_1B653A10C((uint64_t)VFXMTLResourceManager, (uint64_t)v55);
  uint64_t v57 = sub_1B653EFC4((uint64_t)v56);
  objc_msgSend_setCommandQueue_(v17, v58, v57, v59);
  objc_msgSend_registerVFX2AuthoringSystems_(v17, v60, v16, v61);
  uint64_t v62 = [_TtC3VFX8VFXScene alloc];
  *(void *)(v9 + 16) = objc_msgSend_initWithOptions_(v62, v63, (uint64_t)v17, v64);

  return v9;
}

uint64_t sub_1B65117D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!sub_1B64B2718(a1, 1, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  if (qword_1E9DDB1D8 != -1) {
    dispatch_once(&qword_1E9DDB1D8, &unk_1F0FB6388);
  }
  uint64_t v9 = sub_1B63C8D44(qword_1E9DDB1D0, 8uLL);
  uint64_t v10 = objc_opt_new();
  objc_msgSend_setWorld_(v10, v11, a1, v12);
  objc_msgSend_setIsVFX2_(v10, v13, 1, v14);
  objc_msgSend_setSetupRenderer_(v10, v15, 0, v16);
  BOOL v23 = sub_1B64B2718(a1, 2, v17, v18, v19, v20, v21, v22);
  objc_msgSend_setIsAuthoringWorld_(v10, v24, v23, v25);
  objc_msgSend_setAutomaticallyPrepareScene_(v10, v26, 0, v27);
  uint64_t v35 = sub_1B64B2110(a1, v28, v29, v30, v31, v32, v33, v34);
  objc_msgSend_setMetalLibraryURL_(v10, v36, v35, v37);
  objc_msgSend_setSetupAsyncRuntime_(v10, v38, 0, v39);
  uint64_t v40 = [_TtC3VFX8VFXScene alloc];
  *(void *)(v9 + 16) = objc_msgSend_initWithOptions_(v40, v41, (uint64_t)v10, v42);

  return v9;
}

uint64_t sub_1B65118DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 16), sel_setSourceReplicationDelegate_, a2, a4);
}

uint64_t sub_1B65118E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 16), sel_setDestinationReplicationDelegate_, a2, a4);
}

uint64_t sub_1B65118F4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_opaqueEntityManager(*(void **)(a1 + 16), a2, a3, a4);

  return sub_1B69E1674(v5, a2);
}

uint64_t sub_1B6511930(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 16), sel_selectObject_selected_, a2, a3);
}

uint64_t sub_1B6511940(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 16), sel_buildAccelerationStructureDescriptorsWithEntity_, a2, a4);
}

uint64_t sub_1B651194C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 16), sel_invalidateCachedScriptParams, a3, a4);
}

uint64_t sub_1B6511954(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_setWorld_(*(void **)(a1 + 16), a2, (uint64_t)a2, a4);
}

uint64_t sub_1B6511960(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B6445900(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v14 = objc_msgSend_renderTargetInfo(v10, v11, v12, v13);
  uint64_t v17 = objc_msgSend_colorPixelFormatAtIndex_(v14, v15, 0, v16);
  objc_msgSend_depthStencilPixelFormat(v14, v18, v19, v20);
  objc_msgSend_sampleCount(v14, v21, v22, v23);
  uint64_t v24 = *(void *)(a1 + 16);

  return MEMORY[0x1F4181798](v24, sel_encodeAuthoringWithEncoder_colorFormat_depthStencilFormat_sampleCount_, a3, v17);
}

uint64_t sub_1B65119E8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B64B2054(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v12 = result;
    uint64_t result = (uint64_t)sub_1B64B11F0(a1, a2);
    if (result)
    {
      return MEMORY[0x1F4181798](v12, sel_setDirectionalLightUniformOverridesOn_world_proj_, result, a3);
    }
  }
  return result;
}

uint64_t sub_1B6511A74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 16), sel_setDebugUIOptions_, a2, a4);
}

void sub_1B6511A80(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"vfxRenderContext");
  }
  uint64_t v15 = sub_1B644558C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v15)
  {
    uint64_t v23 = (void *)v15;
    uint64_t v24 = *(void **)(a1 + 16);
    uint64_t v25 = (void *)sub_1B6445900((uint64_t)a2, v16, v17, v18, v19, v20, v21, v22);
    uint64_t v26 = *(void **)(a1 + 16);
    uint64_t v27 = *(void *)(a1 + 24);
    uint64_t v31 = objc_msgSend_currentCommandBuffer(v25, v28, v29, v30);
    objc_msgSend_updateVFX2RenderOutputWithPointOfView_commandBuffer_(v26, v32, v27, v31);
    CFDictionaryRef v40 = (const __CFDictionary *)sub_1B64B1100((uint64_t)v23, v33, v34, v35, v36, v37, v38, v39);
    if (v40) {
      CFDictionaryApplyFunction(v40, (CFDictionaryApplierFunction)sub_1B6512314, v23);
    }
    CFArrayRef v41 = (const __CFArray *)sub_1B64B1230((uint64_t)v23);
    if (v41)
    {
      CFArrayRef v49 = v41;
      if (CFArrayGetCount(v41))
      {
        context = v23;
        CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v49);
        sub_1B64B1238((uint64_t)v23);
        v93.length = CFArrayGetCount(Copy);
        v93.location = 0;
        CFArrayApplyFunction(Copy, v93, (CFArrayApplierFunction)sub_1B6512428, &context);
        CFRelease(Copy);
      }
    }
    uint64_t v51 = *(void **)(a1 + 24);
    uint64_t v52 = sub_1B6446564(a2, v42, v43, v44, v45, v46, v47, v48);
    if (v52)
    {
      uint64_t v60 = (uint64_t)v52;
      uint64_t v61 = (long long *)sub_1B64A01D4((uint64_t)v52, (uint64_t)v53, v54, v55, v56, v57, v58, v59);
      long long v90 = v61[3];
      long long v88 = v61[2];
      long long v86 = v61[1];
      long long v84 = *v61;
      int v69 = (long long *)sub_1B64A2250(v60, v62, v63, v64, v65, v66, v67, v68);
      long long v89 = v69[3];
      long long v87 = v69[2];
      long long v85 = v69[1];
      long long v83 = *v69;
      objc_msgSend_setWorldTransform_(v51, v70, v71, v72, *(double *)&v84, *(double *)&v86, *(double *)&v88, *(double *)&v90);
      objc_msgSend_setLastFrameWorldTransform_(v51, v73, v74, v75, *(double *)&v83, *(double *)&v85, *(double *)&v87, *(double *)&v89);
      int v76 = (double *)sub_1B6447988((uint64_t)a2, 0);
      objc_msgSend_setProjection_(v51, v77, v78, v79, *v76, v76[2], v76[4], v76[6]);
    }
    uint64_t v80 = objc_msgSend_currentFrameIndex(v25, v53, v54, v55);
    objc_msgSend_updateAtTime_deltaTime_frameIndex_(v24, v81, v80, v82, a9, a10);
  }
  else
  {
    sub_1B63F2F54(0, @"Warning: CFXVFXSimulateAndPrepareDrawCalls -> no world yet", v17, v18, v19, v20, v21, v22, a11);
  }
}

void sub_1B6511CC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B644558C(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = *(void **)(sub_1B64B20C4(v10, v11, v12, v13, v14, v15, v16, v17) + 16);
  CFDictionaryRef v26 = sub_1B64A04D4(*(void *)(a2 + 8), v19, v20, v21, v22, v23, v24, v25);
  uint64_t v34 = sub_1B65357D8((uint64_t)v26, v27, v28, v29, v30, v31, v32, v33);
  prof_beginFlame((uint64_t)"CFXVFXUpdateRendererElement", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/CFXVFX/CFXVFXRenderContext.m", 433);
  v38[0] = 0;
  v38[1] = v38;
  v38[2] = 0x2020000000;
  int v39 = 0;
  v37[0] = MEMORY[0x1E4F143A8];
  v37[1] = 3221225472;
  v37[2] = sub_1B6511DD0;
  v37[3] = &unk_1E6143A30;
  v37[4] = v34;
  void v37[5] = v38;
  v37[6] = a3;
  v37[7] = a2;
  objc_msgSend_enumerateDrawCall_(v18, v35, (uint64_t)v37, v36);
  _Block_object_dispose(v38, 8);
  prof_endFlame();
}

void sub_1B6511DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  prof_endFlame();
  _Unwind_Resume(a1);
}

id sub_1B6511DD0(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (void *)a1[4];
  uint64_t v7 = objc_msgSend_emitterIdentifier(a2, (const char *)a2, a3, a4);
  id result = (id)objc_msgSend_isEqualToString_(v6, v8, v7, v9);
  if (result)
  {
    uint64_t v14 = *(void *)(a1[5] + 8);
    uint64_t v17 = *(int *)(v14 + 24);
    uint64_t v15 = (_DWORD *)(v14 + 24);
    int v16 = v17;
    if (a1[6] == v17)
    {
      objc_msgSend_boundingBoxMin(a2, v11, v12, v13);
      float32x4_t v69 = v18;
      objc_msgSend_boundingBoxMax(a2, v19, v20, v21);
      float32x4_t v68 = v22;
      *(_WORD *)(a1[7] + 80) = *(_WORD *)(a1[7] + 80) & 0xFFF7 | (8
                                                                    * (objc_msgSend_materialType(a2, v23, v24, v25) == 0));
      *(_WORD *)(a1[7] + 80) = *(_WORD *)(a1[7] + 80) & 0xFFF8 | 4;
      CFDictionaryRef v26 = (float32x4_t *)a1[7];
      float32x4_t v28 = v68;
      float32x4_t v27 = v69;
      v27.i32[3] = 1.0;
      v28.i32[3] = 1.0;
      float32x4_t v29 = vaddq_f32(v27, v28);
      float32x4_t v30 = v28;
      float32x4_t v31 = v27;
      v27.i64[0] = 0x3F0000003F000000;
      v27.i64[1] = 0x3F0000003F000000;
      v26[1] = vmulq_f32(v29, v27);
      v26[2] = vmulq_f32(vsubq_f32(v30, v31), v27);
      *(_DWORD *)(a1[7] + 72) = objc_msgSend_renderingOrder(a2, v32, v33, v34);
      if (objc_msgSend_isAdditive(a2, v35, v36, v37)) {
        __int16 v45 = 0x8000;
      }
      else {
        __int16 v45 = 0;
      }
      *(_WORD *)(a1[7] + 80) = v45 & 0x8000 | *(_WORD *)(a1[7] + 80) & 0x7FFF;
      uint64_t v46 = *(void *)(a1[7] + 8);
      if (v46)
      {
        *(double *)v47.i64 = sub_1B64A2220(v46, (uint64_t)v38, v39, v40, v41, v42, v43, v44);
        uint64_t v48 = (float32x4_t *)a1[7];
        float32x4_t v52 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v50, v49, v48[1], 2), v51, *(float32x2_t *)v48[1].f32, 1), v47, COERCE_FLOAT(*(_OWORD *)&v48[1]));
        v52.i32[3] = HIDWORD(*(_OWORD *)&v48[1]);
        float32x4_t v53 = v48[2];
        v53.i32[1] = v53.i32[0];
        v53.i32[2] = (__int32)v48[2];
        float32x4_t v54 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v48[2].f32, 1), (int32x4_t)v48[2]), vabsq_f32(v51)), v53, vabsq_f32(v47)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v48[2], (int32x4_t)v48[2]), (int32x4_t)v48[2]), vabsq_f32(v49));
        v70[0] = v52;
        v70[1] = v54;
        sub_1B649FA7C(v48->i64[1], v70, 0, v55, v56, v57, v58, v59);
        sub_1B649FB10(*(void *)(a1[7] + 8), (__n128 *)(a1[7] + 16), v60, v61, v62, v63, v64, v65);
      }
      id result = (id)objc_msgSend_customHandler(a2, v38, v39, v40);
      *(void *)(a1[7] + 48) = result;
      uint64_t v66 = *(void *)(a1[5] + 8);
      int v67 = *(_DWORD *)(v66 + 24);
      uint64_t v15 = (_DWORD *)(v66 + 24);
      int v16 = v67;
    }
    *uint64_t v15 = v16 + 1;
  }
  return result;
}

uint64_t sub_1B6511F94(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"vfxRenderContext");
  }
  uint64_t Completion = objc_msgSend_recycleBuffersGetCompletion(*(void **)(a1 + 16), a2, a3, a4);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  v14[2] = sub_1B651203C;
  v14[3] = &unk_1E6143A58;
  long long v14[4] = Completion;
  return objc_msgSend_addCompletedHandler_(a2, v11, (uint64_t)v14, v12);
}

uint64_t sub_1B651203C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1B651204C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"emitter");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"coreEM");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = *(void **)(a2 + 16);
  uint64_t v17 = 0;
  float32x4_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  int v20 = 0;
  uint64_t v11 = sub_1B65357D8(a1, a2, a3, a4, a5, a6, a7, a8);
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = sub_1B6512170;
  v16[3] = &unk_1E6143A80;
  v16[4] = v11;
  void v16[5] = &v17;
  objc_msgSend_enumerateDrawCall_(v10, v12, (uint64_t)v16, v13);
  uint64_t v14 = *((unsigned int *)v18 + 6);
  _Block_object_dispose(&v17, 8);
  return v14;
}

void sub_1B6512158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6512170(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = objc_msgSend_emitterIdentifier(a2, (const char *)a2, a3, a4);
  uint64_t result = objc_msgSend_isEqualToString_(v5, v7, v6, v8);
  if (result) {
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  }
  return result;
}

uint64_t sub_1B65121C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 16), sel_setAdditiveWritesToAlpha_, a2, a4);
}

void sub_1B65121D0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 24) = 0;
  }
  int v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 16) = 0;
  }
}

CFStringRef sub_1B6512210(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXVFXRenderContext>");
}

CFStringRef sub_1B6512244(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXVFXRenderContext>");
}

void sub_1B651227C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

CFStringRef sub_1B65122AC(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXCoreEntityManager>");
}

CFStringRef sub_1B65122E0(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXCoreEntityManager>");
}

void sub_1B6512314(uint64_t a1, void *a2)
{
  prof_beginFlame((uint64_t)"_updateVFXCoreFromNodes", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/CFXVFX/CFXVFXRenderContext.m", 243);
  uint64_t v17 = (void *)sub_1B6535608(a2, 1, v4, v5, v6, v7, v8, v9);
  if (v17)
  {
    float32x4_t v18 = (float32x4_t *)sub_1B64A01D4(a1, v10, v11, v12, v13, v14, v15, v16);
    objc_msgSend_transform(v17, v19, v20, v21);
    if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v30, v18[1]), (int8x16_t)vceqq_f32(v29, *v18)), vandq_s8((int8x16_t)vceqq_f32(v31, v18[2]), (int8x16_t)vceqq_f32(v32, v18[3])))) & 0x80000000) == 0)objc_msgSend_setTransform_(v17, v22, v23, v24); {
    sub_1B64A2F68(a1, (uint64_t)v22, v23, v24, v25, v26, v27, v28);
    }
    float v34 = v33;
    objc_msgSend_opacity(v17, v35, v36, v37);
    if (*(float *)&v41 != v34)
    {
      *(float *)&double v41 = v34;
      objc_msgSend_setOpacity_(v17, v38, v39, v40, v41);
    }
  }

  prof_endFlame();
}

void sub_1B6512408(_Unwind_Exception *a1)
{
}

void sub_1B6512428(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t v10 = (void *)sub_1B64B2054(*a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v14 = v10;
    int v15 = *(_DWORD *)(a1 + 24);
    switch(v15)
    {
      case 3:
        CFDictionaryRef v20 = sub_1B64B11F0(v9, *(const void **)(a1 + 16));
        if (v20)
        {
          CFDictionaryRef v22 = v20;
          objc_msgSend_setLightParametersOn_parameters_(v14, v21, (uint64_t)v20, *(void *)(a1 + 40));
          uint64_t v23 = *(unsigned __int8 *)(a1 + 48);
          MEMORY[0x1F4181798](v14, sel_setShadowParametersOn_castsShadows_tiles_count_depthBias_, v22, v23);
        }
        break;
      case 2:
        if (*(void *)(a1 + 32) == 5)
        {
          objc_msgSend_removeSkyboxes(v10, v11, v12, v13);
        }
        else
        {
          CFDictionaryRef v25 = sub_1B64B11F0(v9, *(const void **)(a1 + 16));
          if (!v25) {
            return;
          }
          objc_msgSend_removeLightWithId_(v14, v26, (uint64_t)v25, v27);
        }
        uint64_t v28 = *(const void **)(a1 + 16);
        sub_1B64B11E0(v9, v28);
        break;
      case 1:
        uint64_t v16 = *(void *)(a1 + 32);
        if (v16 == 5)
        {
          objc_msgSend_removeSkyboxes(v10, v11, 5, v13);
          uint64_t SkyboxWithParameters = objc_msgSend_createSkyboxWithParameters_(v14, v17, *(void *)(a1 + 40), v18);
        }
        else
        {
          uint64_t SkyboxWithParameters = objc_msgSend_addLightWithType_(v10, v11, v16, v13);
        }
        if (SkyboxWithParameters)
        {
          uint64_t v24 = *(const void **)(a1 + 16);
          sub_1B64B114C(v9, v24, SkyboxWithParameters);
        }
        break;
    }
  }
}

uint64_t sub_1B6512594(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B65125C4()
{
  if (qword_1EB996E80 != -1) {
    dispatch_once_f(&qword_1EB996E80, &qword_1EB995690, (dispatch_function_t)sub_1B6512594);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995690, 0x20uLL);
  *(void *)(v0 + 16) = sub_1B6621374(8, 0);
  return v0;
}

void sub_1B6512640(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(v8) = a2;
  uint64_t v10 = sub_1B6621460(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  if (v10 <= v8) {
    unint64_t v11 = v8;
  }
  else {
    unint64_t v11 = v10;
  }
  if (v8 >= v11 >> 1) {
    int64_t v8 = v11;
  }
  else {
    int64_t v8 = v8;
  }
  if (v8 != v10)
  {
    uint64_t v12 = v10;
    sub_1B6621594(*(void *)(a1 + 16), v8);
    sub_1B66215D8(*(_DWORD **)(a1 + 16), v8);
    BOOL v20 = v8 <= v12;
    int64_t v21 = v8 - v12;
    if (!v20)
    {
      CFDictionaryRef v22 = (void *)(sub_1B6621548(*(void *)(a1 + 16), v13, v14, v15, v16, v17, v18, v19) + 8 * v12);
      memset(v22, 255, 8 * v21);
    }
  }
}

uint64_t sub_1B65126E8(uint64_t result)
{
  *(unsigned char *)(result + 40) = 1;
  return result;
}

void sub_1B65126F4(void *a1, int a2, void *__base, size_t __nel)
{
}

uint64_t sub_1B6512718(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (unsigned __int16 *)a2;
  uint64_t v10 = sub_1B6621548(*(void *)(a1 + 16), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  LODWORD(v9) = sub_1B661AF18(*v9, v9[1]);
  int v11 = sub_1B661AF18(*a3, a3[1]);
  unint64_t v12 = *(void *)(v10 + 8 * (int)v9);
  unint64_t v13 = *(void *)(v10 + 8 * v11);
  BOOL v14 = v12 > v13;
  if (v12 == v13) {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v15 = -1;
  }
  if (v14) {
    return 1;
  }
  else {
    return v15;
  }
}

CFIndex sub_1B6512780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B6621414(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B6453580(a2, v11, v12, v13, v14, v15, v16, v17);
  uint64_t v19 = sub_1B661C110(v18);
  if (v19 != *(void *)(a1 + 32))
  {
    *(void *)(a1 + 32) = v19;
    unsigned int v27 = sub_1B661C0D8(v18, v20, v21, v22, v23, v24, v25, v26);
    __int16 v28 = 1;
    if (v27 >= 2)
    {
      char v29 = 0;
      do
      {
        ++v29;
        BOOL v30 = v27 > 3;
        v27 >>= 1;
      }
      while (v30);
      __int16 v28 = (v29 + 1) & 0x1F;
    }
    *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 24) & 0xFFE0 | v28;
    *(unsigned char *)(a1 + 40) = 1;
  }
  CFIndex result = sub_1B661C0F4(v18, v20, v21, v22, v23, v24, v25, v26);
  unsigned int v39 = *(unsigned __int16 *)(a1 + 24);
  if (result >= (uint64_t)(2 << (v39 >> 5)))
  {
    if (result >= 2)
    {
      __int16 v41 = 0;
      do
      {
        ++v41;
        BOOL v30 = result > 3;
        LODWORD(result) = result >> 1;
      }
      while (v30);
      __int16 v40 = (32 * v41 + 32) & 0x3E0;
    }
    else
    {
      __int16 v40 = 32;
    }
    *(_WORD *)(a1 + 24) = v40 | v39 & 0xFC1F;
    *(unsigned char *)(a1 + 40) = 1;
    goto LABEL_16;
  }
  if (*(unsigned char *)(a1 + 40))
  {
LABEL_16:
    uint64_t v42 = (void *)sub_1B6621548(*(void *)(a1 + 16), v32, v33, v34, v35, v36, v37, v38);
    CFIndex result = (CFIndex)memset(v42, 255, 8 * v10);
    *(unsigned char *)(a1 + 40) = 0;
  }
  return result;
}

void sub_1B65128B4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a4;
  uint64_t v10 = (unsigned int *)a3;
  uint64_t v12 = sub_1B6446564(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v20 = sub_1B644558C((uint64_t)a2, v13, v14, v15, v16, v17, v18, v19);
  uint64_t v28 = sub_1B64B2864(v20, v21, v22, v23, v24, v25, v26, v27);
  uint64_t v125 = sub_1B6446190((uint64_t)a2, v29, v30, v31, v32, v33, v34, v35);
  uint64_t v43 = sub_1B6453580(v28, v36, v37, v38, v39, v40, v41, v42);
  if (v12)
  {
    uint64_t v51 = v43;
    simd_float4x4 v139 = *(simd_float4x4 *)sub_1B64A01D4((uint64_t)v12, v44, v45, v46, v47, v48, v49, v50);
    simd_float4x4 v140 = __invert_f4(v139);
    float32x4_t v135 = (float32x4_t)v140.columns[1];
    float32x4_t v136 = (float32x4_t)v140.columns[0];
    float32x4_t v134 = (float32x4_t)v140.columns[2];
    float32x4_t v132 = (float32x4_t)v140.columns[3];
    if (v9 >= 1)
    {
      float32x4_t v131 = vabsq_f32((float32x4_t)v140.columns[0]);
      float32x4_t v129 = vabsq_f32((float32x4_t)v140.columns[2]);
      float32x4_t v130 = vabsq_f32((float32x4_t)v140.columns[1]);
      uint64_t v133 = v51;
      while (1)
      {
        unsigned int v58 = *v10++;
        unint64_t v8 = v8 & 0xFFFFFFFF00000000 | v58;
        uint64_t v59 = (float32x4_t *)sub_1B661BF3C(v51, v8, v52, v53, v54, v55, v56, v57);
        uint64_t v66 = (void *)sub_1B66214AC(*(void *)(a1 + 16), v59->u32[0], v60, v61, v62, v63, v64, v65);
        char v67 = sub_1B63F16E0((uint64_t)v59);
        char v68 = v67;
        if (*v66 == -1) {
          break;
        }
        if ((v67 & 1) == 0)
        {
          *v66 &= 0xFFFFFFFF00000000;
          goto LABEL_28;
        }
LABEL_40:
        if (!--v9) {
          return;
        }
      }
      uint64_t v69 = sub_1B661C0C0(v51, (uint64_t)v59, v52, v53, v54, v55, v56, v57);
      int v70 = sub_1B63F16E0((uint64_t)v59);
      if (v70 && !sub_1B63F1400((uint64_t)v59) && sub_1B63F1710((uint64_t)v59))
      {
        uint64_t v71 = (void *)sub_1B63F6BFC(v125, (char *)v59, 0, a5);
        uint64_t v78 = sub_1B63F6D20(v125, v71, v72, v73, v74, v75, v76, v77);
        uint64_t v79 = v51;
        uint64_t v80 = v78;
        uint64_t v87 = sub_1B661C0CC(v79, (uint64_t)v59, v81, v82, v83, v84, v85, v86);
      }
      else
      {
        uint64_t v80 = 0;
        uint64_t v87 = 0;
      }
      uint64_t v88 = v59->i64[1];
      if (v88) {
        uint64_t v89 = sub_1B64A4DAC(v88) << 61;
      }
      else {
        uint64_t v89 = 0;
      }
      unsigned int v90 = *(unsigned __int16 *)(a1 + 24);
      int v91 = (v90 >> 5) & 0x1F;
      int v92 = v90 & 0x1F;
      int v93 = (60 - (v91 + v92)) & ~((60 - (v91 + v92)) >> 31);
      char v94 = v92;
      if (v70) {
        int v95 = v91;
      }
      else {
        int v95 = 0;
      }
      if (v70) {
        int v96 = v93;
      }
      else {
        int v96 = 0;
      }
      char v97 = 60 - v94;
      unint64_t v98 = (v69 << (61 - v94)) | v89 | ((unint64_t)(v70 ^ 1u) << (60 - v94));
      char v99 = 60 - v94 - v96;
      if (v96)
      {
        v98 |= (v80 & ~(-1 << v96)) << (v97 - v96);
        char v100 = v99;
      }
      else
      {
        char v100 = v97;
      }
      uint64_t v101 = v87 << (v100 - v95);
      if (v95) {
        uint64_t v102 = v101;
      }
      else {
        uint64_t v102 = 0;
      }
      *uint64_t v66 = v102 | v98;
      uint64_t v51 = v133;
      if (v68) {
        goto LABEL_40;
      }
LABEL_28:
      uint64_t v103 = sub_1B63F1678((uint64_t)v59);
      uint64_t v104 = sub_1B63F1730((uint64_t)v59);
      if (v104)
      {
        uint64_t v105 = v104;
        uint64_t v106 = (float32x4_t *)sub_1B63F1750((uint64_t)v59);
        if (v106)
        {
          uint64_t v108 = v106;
          sub_1B64AB970(v105, v107, v52, v53, v54, v55, v56, v57);
          float32x4_t v110 = v108[11];
          float32x4_t v111 = v108[12];
          v110.i32[3] = 1.0;
          v111.i32[3] = 1.0;
          v112.i64[0] = 0x3F0000003F000000;
          v112.i64[1] = 0x3F0000003F000000;
          float32x4_t v113 = vmulq_f32(vaddq_f32(v110, v111), v112);
          int32x4_t v114 = (int32x4_t)vmulq_f32(vsubq_f32(v111, v110), v112);
          if (v103)
          {
            float32x4_t v127 = v113;
            int32x4_t v128 = v114;
            uint64_t v115 = sub_1B64A01D4(v103, v109, v52, v53, v54, v55, v56, v57);
            float32x4_t v116 = *(float32x4_t *)(v115 + 16);
            float32x4_t v117 = *(float32x4_t *)(v115 + 32);
            float32x4_t v118 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v115 + 48), v117, v127, 2), v116, *(float32x2_t *)v127.f32, 1), *(float32x4_t *)v115, v127.f32[0]);
            v118.i32[3] = v127.i32[3];
            float32x4_t v119 = (float32x4_t)v128;
            v119.i32[1] = v128.i32[0];
            v119.i32[2] = v128.i32[0];
            float32x4_t v113 = v118;
            int32x4_t v114 = (int32x4_t)vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v128.i8, 1), v128), vabsq_f32(v116)), v119, vabsq_f32(*(float32x4_t *)v115)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v128, v128), v128), vabsq_f32(v117));
          }
          goto LABEL_38;
        }
      }
      else
      {
        if ((v59[5].i16[0] & 7) != 4)
        {
          float32x4_t v113 = (float32x4_t)xmmword_1B6E4F370;
          int32x4_t v114 = (int32x4_t)xmmword_1B6E51230;
          if (v103)
          {
            *(uint64_t *)((char *)v138[0].i64 + 4) = 0;
            v138[0].i32[0] = 0;
            sub_1B64A1EC8(v103, (__n128 *)v138, v52, v53, v54, v55, v56, v57);
            float32x4_t v121 = v138[0];
            v121.i32[3] = 1.0;
            v122.i64[0] = 0x3F0000003F000000;
            v122.i64[1] = 0x3F0000003F000000;
            float32x4_t v113 = vmulq_f32(vaddq_f32(v121, (float32x4_t)xmmword_1B6E4F370), v122);
            int32x4_t v114 = (int32x4_t)vmulq_f32(vsubq_f32((float32x4_t)xmmword_1B6E4F370, v121), v122);
          }
          goto LABEL_38;
        }
        if ((v59[5].i16[0] & 0x4000) == 0)
        {
          float32x4_t v113 = v59[1];
          int32x4_t v114 = (int32x4_t)v59[2];
LABEL_38:
          float32x4_t v123 = (float32x4_t)v114;
          v123.i32[1] = v114.i32[0];
          v123.i32[2] = v114.i32[0];
          float32x4_t v124 = vaddq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v114.i8, 1), v114), v130), v123, v131), (float32x4_t)vzip2q_s32(vtrn1q_s32(v114, v114), v114), v129), vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v132, v134, v113, 2), v135, *(float32x2_t *)v113.f32, 1), v136, v113.f32[0]));
          uint64_t v120 = ((v124.i32[2] >> 31) | 0x80000000) ^ v124.i32[2];
          goto LABEL_39;
        }
      }
      uint64_t v120 = 3212836864;
LABEL_39:
      *v66 |= v120;
      goto LABEL_40;
    }
  }
}

void *sub_1B6512CCC(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  CFIndex result = (void *)sub_1B6621460(*(void *)(a1 + 16), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t)result > v9)
  {
    CFIndex result = (void *)sub_1B66214AC(*(void *)(a1 + 16), v9, v11, v12, v13, v14, v15, v16);
    *CFIndex result = -1;
  }
  return result;
}

uint64_t sub_1B6512D14(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B6621414(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  uint64_t result = sub_1B661AF18((unsigned __int16)a2, WORD1(a2));
  if (v10 > result)
  {
    unint64_t v19 = HIDWORD(a2);
    uint64_t result = sub_1B6621548(*(void *)(a1 + 16), v12, v13, v14, v15, v16, v17, v18);
    if (HIDWORD(a2))
    {
      uint64_t v20 = result;
      unint64_t v21 = a2 >> 16;
      do
      {
        uint64_t result = sub_1B661AF18((unsigned __int16)a2, (unsigned __int16)v21);
        *(void *)(v20 + 8 * result) = -1;
        LODWORD(v21) = v21 + 1;
        LODWORD(v19) = v19 - 1;
      }
      while (v19);
    }
  }
  return result;
}

void sub_1B6512DA4(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

CFStringRef sub_1B6512DD4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXSortSystem %p>", a1);
}

CFStringRef sub_1B6512E14(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXSortSystem %p>", a1);
}

double sub_1B6512E54(std::string *__str, uint64_t a2, int a3)
{
  std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  int v6 = (char)size;
  std::string::size_type v7 = 0;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  if (size)
  {
    unint64_t v8 = (std::string *)__str->__r_.__value_.__r.__words[0];
    if (v6 >= 0) {
      unint64_t v8 = __str;
    }
    while (1)
    {
      int v9 = v8->__r_.__value_.__s.__data_[v7];
      BOOL v10 = v9 == 10 || v9 == 13;
      if (!v10 && (char)v9 > 32) {
        break;
      }
      if (size == ++v7)
      {
LABEL_21:
        std::string::size_type v7 = size;
        goto LABEL_22;
      }
    }
  }
  if (v7 < size && a3 != 0)
  {
    uint64_t v12 = (std::string *)__str->__r_.__value_.__r.__words[0];
    if (v6 >= 0) {
      uint64_t v12 = __str;
    }
    while (v12->__r_.__value_.__s.__data_[v7] == 44)
    {
      if (size == ++v7) {
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  std::string::basic_string(&v14, __str, v7, size - v7, (std::allocator<char> *)&v15);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  double result = *(double *)&v14.__r_.__value_.__l.__data_;
  *(std::string *)a2 = v14;
  return result;
}

double sub_1B6512F3C(std::string *a1, std::string *a2, std::string *a3, char a4, int a5)
{
  sub_1B6512E54(a1, (uint64_t)a2, 0);
  uint64_t size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) == 0) {
    uint64_t v11 = a1;
  }
  else {
    uint64_t v11 = (std::string *)a1->__r_.__value_.__r.__words[0];
  }
  if ((size & 0x80u) != 0) {
    uint64_t size = a1->__r_.__value_.__l.__size_;
  }
  unint64_t v12 = (unint64_t)v11 + size;
  uint64_t v13 = v11;
  if (size >= 1)
  {
    do
    {
      int v14 = v13->__r_.__value_.__s.__data_[0];
      if (v14 == 10 || v14 == 13) {
        break;
      }
      char v16 = (char)v14 < 33 ? a4 : 0;
      char v17 = v14 == 44 ? a5 : 0;
      if (v16) {
        break;
      }
      if (v17) {
        break;
      }
      uint64_t v13 = (std::string *)((char *)v13 + 1);
    }
    while ((unint64_t)v13 < v12);
  }
  std::string::assign(a3, a1, 0, (char *)v13 - (char *)v11);
  if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v18 = (std::string::size_type)a1;
  }
  else {
    std::string::size_type v18 = a1->__r_.__value_.__r.__words[0];
  }
  std::string::assign(a2, a1, (std::string::size_type)v13 - v18, v12 - (void)v13);

  return sub_1B6512E54(a2, (uint64_t)a2, a5);
}

float sub_1B6513040(std::string *a1, std::string *a2, float *a3, char a4, int a5)
{
  memset(&v16, 0, sizeof(v16));
  sub_1B6512F3C(a1, a2, &v16, a4, a5);
  std::string::size_type size = HIBYTE(v16.__r_.__value_.__r.__words[2]);
  if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v16.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    if ((*((unsigned char *)&v16.__r_.__value_.__s + 23) & 0x80) == 0)
    {
LABEL_5:
      float result = atof((const char *)&v16);
      *a3 = result;
      return result;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v6, v7, v8, v9, v10, v11, (uint64_t)"!line.empty()");
    if ((*((unsigned char *)&v16.__r_.__value_.__s + 23) & 0x80) == 0) {
      goto LABEL_5;
    }
  }
  int v14 = (void *)v16.__r_.__value_.__r.__words[0];
  float v15 = atof(v16.__r_.__value_.__l.__data_);
  *a3 = v15;
  operator delete(v14);
  return result;
}

void sub_1B65130E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B6513104(std::string *a1, std::string *a2, int *a3, char a4, int a5)
{
  memset(&v14, 0, sizeof(v14));
  sub_1B6512F3C(a1, a2, &v14, a4, a5);
  std::string::size_type size = HIBYTE(v14.__r_.__value_.__r.__words[2]);
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v14.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    if ((*((unsigned char *)&v14.__r_.__value_.__s + 23) & 0x80) == 0)
    {
LABEL_5:
      *a3 = atoi((const char *)&v14);
      return;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v6, v7, v8, v9, v10, v11, (uint64_t)"!line.empty()");
    if ((*((unsigned char *)&v14.__r_.__value_.__s + 23) & 0x80) == 0) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = (void *)v14.__r_.__value_.__r.__words[0];
  *a3 = atoi(v14.__r_.__value_.__l.__data_);
  operator delete(v13);
}

void sub_1B65131A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B65131C0(unsigned char *__src, size_t __len, _OWORD *a3, int a4)
{
  if (__len < 5) {
    return 0;
  }
  if (a4)
  {
    if (*(_DWORD *)__src != 1314080073 || __src[4] != 65) {
      return 0;
    }
  }
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v7 = (std::string *)sub_1B651440C(&__dst, __src, __len);
  memset(&__str, 0, sizeof(__str));
  memset(&v62, 0, sizeof(v62));
  sub_1B6512F3C(v7, &__str, &v62, 0, 0);
  do
  {
    while (1)
    {
      std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __str.__r_.__value_.__l.__size_;
      }
      if (!size) {
        goto LABEL_86;
      }
      memset(&__p, 0, sizeof(__p));
      sub_1B6512F3C(&__str, &__str, &__p, 0, 0);
      int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        size_t v10 = __p.__r_.__value_.__l.__size_ >= 9 ? 9 : __p.__r_.__value_.__l.__size_;
      }
      else
      {
        size_t v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]) >= 9u ? 9 : HIBYTE(__p.__r_.__value_.__r.__words[2]);
        p_p = &__p;
      }
      int v12 = memcmp(p_p, "TILT=NONE", v10);
      if (v10 >= 9 && v12 == 0) {
        goto LABEL_54;
      }
      if (v9 < 0)
      {
        float v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
        size_t v14 = __p.__r_.__value_.__l.__size_ >= 0xA ? 10 : __p.__r_.__value_.__l.__size_;
      }
      else
      {
        size_t v14 = v9 >= 0xAu ? 10 : v9;
        float v15 = &__p;
      }
      int v16 = memcmp(v15, "TILT= NONE", v14);
      if (v14 >= 0xA && !v16) {
        goto LABEL_54;
      }
      if (v9 < 0)
      {
        std::string::size_type v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
        size_t v17 = __p.__r_.__value_.__l.__size_ >= 0xA ? 10 : __p.__r_.__value_.__l.__size_;
      }
      else
      {
        size_t v17 = v9 >= 0xAu ? 10 : v9;
        std::string::size_type v18 = &__p;
      }
      if (((int v19 = memcmp(v18, "TILT =NONE", v17), v17 < 0xA) || v19)
        && (v9 < 0
          ? (std::string *)((unint64_t v21 = (std::string *)__p.__r_.__value_.__r.__words[0], __p.__r_.__value_.__l.__size_ >= 0xB)
                          ? (size_t v20 = 11)
                          : (size_t v20 = __p.__r_.__value_.__l.__size_))
          : (v9 >= 0xBu ? (size_t v20 = 11) : (size_t v20 = v9), v21 = &__p),
            (int v22 = memcmp(v21, "TILT = NONE", v20), v20 < 0xB) || v22))
      {
        if (v9 < 0)
        {
          uint64_t v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
          size_t v24 = __p.__r_.__value_.__l.__size_ >= 5 ? 5 : __p.__r_.__value_.__l.__size_;
        }
        else
        {
          size_t v24 = v9 >= 5u ? 5 : v9;
          uint64_t v25 = &__p;
        }
        int v26 = memcmp(v25, "TILT=", v24);
        if (v24 < 5 || v26)
        {
          if (v9 < 0)
          {
            uint64_t v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
            size_t v27 = __p.__r_.__value_.__l.__size_ >= 5 ? 5 : __p.__r_.__value_.__l.__size_;
          }
          else
          {
            size_t v27 = v9 >= 5u ? 5 : v9;
            uint64_t v28 = &__p;
          }
          int v29 = memcmp(v28, "TILT =", v27);
          BOOL v30 = v27 > 4 && v29 == 0;
          int v23 = v30;
        }
        else
        {
          int v23 = 1;
        }
      }
      else
      {
LABEL_54:
        int v23 = 3;
      }
      if (v9 < 0) {
        break;
      }
      if (v23) {
        goto LABEL_85;
      }
    }
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  while (!v23);
LABEL_85:
  if (v23 != 3)
  {
LABEL_104:
    uint64_t v6 = 0;
    goto LABEL_105;
  }
LABEL_86:
  sub_1B6513040(&__str, &__str, (float *)&v56, 1, 0);
  uint64_t v6 = 0;
  if (*(float *)&v56 >= 0.0 && *(float *)&v56 <= 32767.0)
  {
    sub_1B6513040(&__str, &__str, (float *)&v56 + 1, 1, 0);
    if (*((float *)&v56 + 1) < 0.0) {
      goto LABEL_104;
    }
    sub_1B6513040(&__str, &__str, (float *)&v56 + 2, 1, 0);
    if (*((float *)&v56 + 2) < 0.0) {
      goto LABEL_104;
    }
    sub_1B6513104(&__str, &__str, (int *)count + 1, 1, 0);
    if (HIDWORD(count[0]) >> 15) {
      goto LABEL_104;
    }
    sub_1B6513104(&__str, &__str, (int *)count, 1, 0);
    if (LODWORD(count[0]) >> 15) {
      goto LABEL_104;
    }
    sub_1B6513104(&__str, &__str, (int *)&v57 + 2, 1, 0);
    sub_1B6513104(&__str, &__str, (int *)&v57 + 3, 1, 0);
    sub_1B6513040(&__str, &__str, (float *)&count[1] + 1, 1, 0);
    sub_1B6513040(&__str, &__str, (float *)&v59, 1, 0);
    sub_1B6513040(&__str, &__str, (float *)&v59 + 1, 1, 0);
    sub_1B6513040(&__str, &__str, (float *)&v59 + 2, 1, 0);
    sub_1B6513040(&__str, &__str, (float *)&v59 + 3, 1, 0);
    sub_1B6513040(&__str, &__str, (float *)&v60, 1, 0);
    int v31 = HIDWORD(count[0]);
    uint64_t v32 = (char *)malloc_type_calloc(SHIDWORD(count[0]), 4uLL, 0x100004052888210uLL);
    *(void *)&long long v61 = v32;
    int v33 = count[0];
    uint64_t v34 = (char *)malloc_type_calloc(SLODWORD(count[0]), 4uLL, 0x100004052888210uLL);
    *((void *)&v60 + 1) = v34;
    if (v31 >= 1)
    {
      uint64_t v35 = 0;
      float v36 = -3.4028e38;
      while (1)
      {
        LODWORD(__p.__r_.__value_.__l.__data_) = 0;
        sub_1B6513040(&__str, &__str, (float *)&__p, 1, 1);
        int data = (int)__p.__r_.__value_.__l.__data_;
        if (*(float *)&__p.__r_.__value_.__l.__data_ < v36) {
          goto LABEL_103;
        }
        *(_DWORD *)&v32[v35] = __p.__r_.__value_.__l.__data_;
        v35 += 4;
        float v36 = *(float *)&data;
        if (4 * v31 == v35) {
          goto LABEL_98;
        }
      }
    }
    int data = -8388609;
LABEL_98:
    uint64_t v38 = v33;
    if (v33 >= 1)
    {
      uint64_t v39 = 0;
      float v40 = -3.4028e38;
      while (1)
      {
        LODWORD(__p.__r_.__value_.__l.__data_) = 0;
        sub_1B6513040(&__str, &__str, (float *)&__p, 1, 1);
        int v41 = (int)__p.__r_.__value_.__l.__data_;
        if (*(float *)&__p.__r_.__value_.__l.__data_ < v40) {
          break;
        }
        *(_DWORD *)&v34[v39] = __p.__r_.__value_.__l.__data_;
        v39 += 4;
        float v40 = *(float *)&v41;
        if (4 * v38 == v39) {
          goto LABEL_113;
        }
      }
LABEL_103:
      free(v32);
      free(v34);
      goto LABEL_104;
    }
    int v41 = -8388609;
LABEL_113:
    LODWORD(v57) = v41;
    LODWORD(count[1]) = v38 * v31;
    uint64_t v43 = (float *)malloc_type_calloc((int)v38 * v31, 4uLL, 0x100004052888210uLL);
    *((void *)&v61 + 1) = v43;
    float v44 = *((float *)&v56 + 2);
    if ((int)v38 < 1)
    {
      float v47 = 0.0;
    }
    else
    {
      int v45 = 0;
      int v46 = 0;
      float v47 = 0.0;
      do
      {
        uint64_t v48 = v31;
        if (v31 >= 1)
        {
          do
          {
            LODWORD(__p.__r_.__value_.__l.__data_) = 0;
            sub_1B6513040(&__str, &__str, (float *)&__p, 1, 1);
            float v49 = *(float *)&__p.__r_.__value_.__l.__data_;
            v43[v46++] = *(float *)&__p.__r_.__value_.__l.__data_ * v44;
            if (v49 >= v47) {
              float v47 = v49;
            }
            --v48;
          }
          while (v48);
        }
        ++v45;
      }
      while (v45 != v38);
    }
    *((float *)&v56 + 3) = v47 * v44;
    DWORD1(v57) = data;
    sub_1B6512E54(&__str, (uint64_t)&__str, 0);
    std::string::size_type v50 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v50 = __str.__r_.__value_.__l.__size_;
    }
    if (v50)
    {
      memset(&__p, 0, sizeof(__p));
      sub_1B6512F3C(&__str, &__str, &__p, 1, 0);
      if (sub_1B65139B4((const void **)&__p.__r_.__value_.__l.__data_, "END")) {
        sub_1B6512E54(&__str, (uint64_t)&__str, 0);
      }
      std::string::size_type v51 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v51 = __str.__r_.__value_.__l.__size_;
      }
      if (v51)
      {
        free(v32);
        free(v34);
        free(v43);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        goto LABEL_104;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    long long v52 = v59;
    a3[2] = *(_OWORD *)count;
    a3[3] = v52;
    long long v53 = v61;
    a3[4] = v60;
    a3[5] = v53;
    long long v54 = v57;
    uint64_t v6 = 1;
    *a3 = v56;
    a3[1] = v54;
  }
LABEL_105:
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v62.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v65 < 0) {
    operator delete(__dst);
  }
  return v6;
}

void sub_1B6513944(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (*(char *)(v39 - 121) < 0) {
    operator delete(*(void **)(v39 - 144));
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1B65139B4(const void **a1, char *__s)
{
  int v4 = *((char *)a1 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (v5 != strlen(__s)) {
    return 0;
  }
  if (v4 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *a1;
  }
  return memcmp(v6, __s, v5) == 0;
}

uint64_t sub_1B6513A2C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t result = objc_msgSend_dataWithContentsOfURL_(MEMORY[0x1E4F1C9B8], (const char *)a2, (uint64_t)a1, a4);
  if (result)
  {
    size_t v10 = (void *)result;
    uint64_t v11 = objc_msgSend_path(a1, v7, v8, v9);
    float v15 = objc_msgSend_pathExtension(v11, v12, v13, v14);
    int v19 = objc_msgSend_lowercaseString(v15, v16, v17, v18);
    int v22 = objc_msgSend_isEqualToString_(v19, v20, @"ies", v21) ^ 1;
    int v26 = (unsigned char *)objc_msgSend_bytes(v10, v23, v24, v25);
    size_t v30 = objc_msgSend_length(v10, v27, v28, v29);
    return sub_1B65131C0(v26, v30, (_OWORD *)a2, v22);
  }
  return result;
}

void sub_1B6513AE4(float *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (a2 <= 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"anglesCount > 0");
  }
  if (*a1 <= a9)
  {
    unint64_t v12 = a2 - 1;
    if (a1[v12] >= a9)
    {
      unint64_t v13 = 0;
      if (a2 != 1)
      {
        while (1)
        {
          unint64_t v14 = (v13 + v12 + 1) >> 1;
          if (a1[v14] <= a9) {
            break;
          }
          unint64_t v15 = v14 - 1;
          int v16 = "end != index - 1";
          if (v12 == v15) {
            goto LABEL_10;
          }
          unint64_t v12 = v15;
LABEL_12:
          if (v13 >= v12) {
            return;
          }
        }
        int v16 = "start != index";
        if (v13 != v14)
        {
          unint64_t v13 = (v13 + v12 + 1) >> 1;
          goto LABEL_12;
        }
LABEL_10:
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)v16);
        goto LABEL_12;
      }
    }
  }
}

float sub_1B6513C3C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 32);
  int v10 = *(_DWORD *)(a1 + 36);
  int v11 = v9 - 1;
  if (v9 - 1 >= a2) {
    int v11 = a2;
  }
  int v12 = v11 & ~(v11 >> 31);
  int v13 = v10 - 1;
  if (v10 - 1 >= (int)a3) {
    int v13 = a3;
  }
  int v14 = v13 & ~(v13 >> 31);
  if (v12 >= v9) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"x < anglesNumH");
  }
  if (v14 >= v10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"y < anglesNumV");
  }
  return *(float *)(*(void *)(a1 + 88) + 4 * (v14 + v12 * v10));
}

float sub_1B6513CE4(uint64_t a1, float a2, float a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v12 = vcvtms_s32_f32(a2);
  LODWORD(v10) = vcvtms_s32_f32(a3);
  float v13 = a2 - (float)(int)floorf(a2);
  float v119 = a3 - (float)(int)floorf(a3);
  float v127 = sub_1B6513C3C(a1, v12 - 1, (v10 - 1), a6, a7, a8, a9, a10);
  float v124 = sub_1B6513C3C(a1, v12, (v10 - 1), v14, v15, v16, v17, v18);
  float v120 = sub_1B6513C3C(a1, v12 + 1, (v10 - 1), v19, v20, v21, v22, v23);
  float v29 = sub_1B6513C3C(a1, v12 + 2, (v10 - 1), v24, v25, v26, v27, v28);
  v30.i64[0] = __PAIR64__(LODWORD(v124), LODWORD(v127));
  v30.i64[1] = __PAIR64__(LODWORD(v29), LODWORD(v120));
  float32x4_t v128 = v30;
  float v125 = sub_1B6513C3C(a1, v12 - 1, v10, v31, v32, v33, v34, v35);
  float v121 = sub_1B6513C3C(a1, v12, v10, v36, v37, v38, v39, v40);
  float v116 = sub_1B6513C3C(a1, v12 + 1, v10, v41, v42, v43, v44, v45);
  float v51 = sub_1B6513C3C(a1, v12 + 2, v10, v46, v47, v48, v49, v50);
  v52.i64[0] = __PAIR64__(LODWORD(v121), LODWORD(v125));
  v52.i64[1] = __PAIR64__(LODWORD(v51), LODWORD(v116));
  float32x4_t v126 = v52;
  float v122 = sub_1B6513C3C(a1, v12 - 1, (v10 + 1), v53, v54, v55, v56, v57);
  float v117 = sub_1B6513C3C(a1, v12, (v10 + 1), v58, v59, v60, v61, v62);
  float v114 = sub_1B6513C3C(a1, v12 + 1, (v10 + 1), v63, v64, v65, v66, v67);
  float v73 = sub_1B6513C3C(a1, v12 + 2, (v10 + 1), v68, v69, v70, v71, v72);
  v74.i64[0] = __PAIR64__(LODWORD(v117), LODWORD(v122));
  v74.i64[1] = __PAIR64__(LODWORD(v73), LODWORD(v114));
  float32x4_t v123 = v74;
  uint64_t v75 = (v10 + 2);
  float v118 = sub_1B6513C3C(a1, v12 - 1, v75, v76, v77, v78, v79, v80);
  float v115 = sub_1B6513C3C(a1, v12, v75, v81, v82, v83, v84, v85);
  float v113 = sub_1B6513C3C(a1, v12 + 1, v75, v86, v87, v88, v89, v90);
  float v96 = sub_1B6513C3C(a1, v12 + 2, v75, v91, v92, v93, v94, v95);
  v97.i64[0] = __PAIR64__(LODWORD(v115), LODWORD(v118));
  v97.i64[1] = __PAIR64__(LODWORD(v96), LODWORD(v113));
  _Q5 = v97;
  __asm { FMOV            V0.4S, #3.0 }
  v97.i64[0] = 0x3F0000003F000000;
  v97.i64[1] = 0x3F0000003F000000;
  __asm { FMOV            V2.4S, #-3.0 }
  float32x4_t v105 = vmlaq_f32(vmlaq_f32(vmlsq_f32(vmulq_f32(vmulq_f32(v126, _Q0), v97), v97, v128), v97, vmulq_f32(v123, _Q2)), v97, _Q5);
  __asm { FMOV            V2.4S, #5.0 }
  _Q6 = vmlaq_n_f32(v126, vmlaq_n_f32(vmulq_f32(vsubq_f32(v123, v128), v97), vmlaq_n_f32(vaddq_f32(v123, vaddq_f32(v123, vmlsq_f32(v128, v97, vmlaq_f32(_Q5, _Q2, v126)))), v105, v119), v119), v119);
  _S4 = 3.0;
  __asm { FMLA            S3, S4, V6.S[1] }
  _S4 = -3.0;
  __asm { FMLA            S3, S4, V6.S[2] }
  _Q5.i32[0] = 5.0;
  __asm { FMLA            S2, S5, V6.S[1] }
  return _Q6.f32[1]
       + (float)((float)((float)((float)(_Q6.f32[2] - _Q6.f32[0]) * 0.5)
                       + (float)((float)((float)(_Q6.f32[2]
                                               + (float)(_Q6.f32[2] + (float)(_Q6.f32[0] - (float)(_Q2.f32[0] * 0.5))))
                                       + (float)((float)((float)(_Q6.f32[3] + _S3) * 0.5) * v13))
                               * v13))
               * v13);
}

uint64_t sub_1B6513FB0(uint64_t a1, int16x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a6;
  int v9 = a5;
  unsigned int v10 = a4;
  uint64_t v11 = a3;
  int v12 = a2;
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (!a3) {
      goto LABEL_6;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"data");
    if (!v11)
    {
LABEL_6:
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"width > 0 && height > 0");
      goto LABEL_7;
    }
  }
  if (!v10) {
    goto LABEL_6;
  }
LABEL_7:
  if (v9 != 1 && v9 != 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"channelCount == 1 || channelCount == 4");
  }
  if (v8 > 4 || ((1 << v8) & 0x16) == 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"channelSize == 1 || channelSize == 2 || channelSize == 4");
  }
  float v14 = *(float *)(a1 + 12);
  double v17 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v19 = (float *)&v71[-v18];
  if (v11)
  {
    uint64_t v20 = 0;
    float v21 = *(float *)&v17 / 180.0;
    do
    {
      float v22 = acosf((float)((float)((float)v20 * -2.0) * (float)(1.0 / (float)v11)) + 1.0)
          / 3.14159265
          * 180.0;
      sub_1B6513AE4(*(float **)(a1 + 80), *(_DWORD *)(a1 + 36), v23, v24, v25, v26, v27, v28, v21 * v22);
      v19[v20++] = v29;
    }
    while (v11 != v20);
  }
  uint64_t v74 = v11;
  MEMORY[0x1F4188790](v15, v16);
  uint64_t v37 = &v71[-v36];
  if (v10)
  {
    uint64_t v38 = 0;
    float v39 = 1.0 / v14;
    do
    {
      sub_1B6513AE4(*(float **)(a1 + 72), *(_DWORD *)(a1 + 32), v30, v31, v32, v33, v34, v35, (float)((float)(1.0 / (float)v10) * (float)v38) * 180.0);
      *(_DWORD *)&v37[4 * v38++] = v41;
    }
    while (v10 != v38);
    uint64_t v42 = 0;
    BOOL v43 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    int32x4_t v76 = _Q0;
    uint64_t v49 = v12;
    uint64_t v77 = (int32x4_t *)v12;
    uint64_t v73 = v11;
    do
    {
      uint64_t v75 = v42;
      if (v11)
      {
        BOOL v72 = v43;
        float v50 = *(float *)&v37[4 * v42];
        uint64_t v51 = v74;
        float32x4_t v52 = v19;
        do
        {
          float v53 = v39 * sub_1B6513CE4(a1, v50, *v52, v40, v30, v31, v32, v33, v34, v35);
          switch(v8)
          {
            case 1u:
              int v56 = (int)(float)((float)(v53 * 255.0) + 0.5);
              if (v9 == 4)
              {
                v12->i8[0] = v56;
                v12->i8[1] = v56;
                v12->i8[2] = v56;
                v12->i8[3] = -1;
                int v12 = (int16x4_t *)((char *)v12 + 4);
              }
              else
              {
                if (v9 != 1) {
                  goto LABEL_48;
                }
                v12->i8[0] = v56;
                int v12 = (int16x4_t *)((char *)v12 + 1);
              }
              break;
            case 2u:
              int v57 = HIWORD(LODWORD(v53)) & 0x8000;
              unsigned int v58 = (LODWORD(v53) >> 23);
              unsigned int v59 = v58 - 112;
              unsigned int v60 = v58 - 113;
              __int16 v61 = v57 | 0x7BFF;
              if (v58 == 255) {
                __int16 v61 = v57 | ((LODWORD(v53) & 0x7FFFFF) != 0) | 0x7C00;
              }
              if (v58 >= 0x71) {
                __int16 v62 = v61;
              }
              else {
                __int16 v62 = HIWORD(v53) & 0x8000;
              }
              int v63 = HIWORD(LODWORD(v53)) & 0x8000 | (LODWORD(v53) >> 13) & 0x3FF | (v59 << 10);
              if (v60 > 0x1D) {
                LOWORD(v63) = v62;
              }
              if (v9 == 4)
              {
                int16x4_t v67 = (int16x4_t)-1;
                v67.i16[0] = v63;
                int16x4_t v68 = vzip1_s16(v67, v67);
                v68.i16[2] = v63;
                *v49++ = v68;
              }
              else
              {
                if (v9 != 1)
                {
LABEL_48:
                  char v69 = v72;
                  return v69 & 1;
                }
                v49->i16[0] = v63;
                uint64_t v49 = (int16x4_t *)((char *)v49 + 2);
              }
              break;
            case 4u:
              if (v9 == 4)
              {
                int32x4_t v64 = v76;
                *(float *)v64.i32 = v53;
                int32x4_t v65 = vzip1q_s32(v64, v64);
                *(float *)&v65.i32[2] = v53;
                uint64_t v66 = v77;
                *uint64_t v77 = v65;
                uint64_t v55 = v66 + 1;
              }
              else
              {
                if (v9 != 1) {
                  goto LABEL_48;
                }
                uint64_t v54 = v77;
                *(float *)v77->i32 = v53;
                uint64_t v55 = (int32x4_t *)((char *)v54->i64 + 4);
              }
              uint64_t v77 = v55;
              break;
            default:
              goto LABEL_48;
          }
          ++v52;
          --v51;
        }
        while (v51);
      }
      uint64_t v42 = v75 + 1;
      BOOL v43 = v75 + 1 >= (unint64_t)v10;
      LODWORD(v11) = v73;
    }
    while (v75 + 1 != v10);
  }
  char v69 = 1;
  return v69 & 1;
}

void sub_1B65143C8(void **a1)
{
  a1[9] = 0;
  free(a1[10]);
  a1[10] = 0;
  free(a1[11]);
  a1[11] = 0;
}

void *sub_1B651440C(void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    void *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void sub_1B65144B4(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 72) >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(a1 + 80);
      *(void *)(*(void *)(v3 + 8 * v2) + 40) = 0;
      CFRelease(*(CFTypeRef *)(v3 + 8 * v2++));
    }
    while (v2 < *(void *)(a1 + 72));
  }
  int v4 = *(void **)(a1 + 80);
  if (v4) {
    free(v4);
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 120);
  if (v5)
  {
    CFIndex Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
        *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 120), i) + 16) = 0;
    }
  }
  if ((*(unsigned char *)(a1 + 88) & 0x10) != 0) {
    sub_1B65145B8(a1);
  }
  int v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 120) = 0;
  }
  unsigned int v10 = *(const void **)(a1 + 104);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 104) = 0;
  }
  uint64_t v11 = *(const void **)(a1 + 144);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 144) = 0;
  }
  int v12 = *(const void **)(a1 + 152);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 152) = 0;
  }
  float v13 = *(void **)(a1 + 136);
}

void sub_1B65145B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    if (*(void *)v2)
    {
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v2 + 16), (CFDictionaryApplierFunction)sub_1B65161A8, *(void **)v2);
      uint64_t v2 = *(void *)(a1 + 96);
    }
    if (*(void *)(v2 + 16))
    {
      CFRelease(*(CFTypeRef *)(v2 + 16));
      uint64_t v2 = *(void *)(a1 + 96);
      *(void *)(v2 + 16) = 0;
    }
    if (*(void *)v2)
    {
      free(*(void **)v2);
      uint64_t v2 = *(void *)(a1 + 96);
    }
    free((void *)v2);
    *(void *)(a1 + 96) = 0;
  }
}

uint64_t sub_1B6514638()
{
  if (qword_1EB995478 != -1) {
    dispatch_once(&qword_1EB995478, &unk_1F0FB5B88);
  }
  return qword_1EB995480;
}

void sub_1B651467C()
{
  if (!qword_1EB995480)
  {
    qword_1EB995480 = sub_1B63C8D10(&qword_1EB995480);
    qword_1EB983C68 = (uint64_t)sub_1B6516234;
  }
}

uint64_t sub_1B65146D4(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"description");
  }
  if (qword_1EB995478 != -1) {
    dispatch_once(&qword_1EB995478, &unk_1F0FB5B88);
  }
  uint64_t v10 = sub_1B63C8D44(qword_1EB995480, 0x90uLL);
  sub_1B65147A4(v10, a1, v11, v12, v13, v14, v15, v16);
  if (!v10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v18, v19, v20, v21, v22, v23, (uint64_t)"td");
  }
  *(void *)(v10 + 112) = a2;
  sub_1B6514820(v10, v17, v18, v19, v20, v21, v22, v23);
  *(_DWORD *)(v10 + 92) = -1;
  return v10;
}

CFTypeRef sub_1B65147A4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"td");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 104);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 104) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 104) = result;
  }
  return result;
}

uint64_t sub_1B6514820(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v295 = *MEMORY[0x1E4F143B8];
  char v9 = *(unsigned char *)(a1 + 88);
  if (v9)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. compiling a renderGraph twice", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph->_isCompiled==false");
    char v9 = *(unsigned char *)(a1 + 88);
  }
  *(unsigned char *)(a1 + 88) = v9 | 1;
  uint64_t v10 = *(void **)(a1 + 104);
  CFTypeRef cf = *(CFTypeRef *)(a1 + 112);
  *(void *)(a1 + 144) = (id)objc_msgSend_valueForKey_(v10, a2, @"bundle", a4);
  *(void *)(a1 + 152) = (id)objc_msgSend_valueForKey_(v10, v11, @"metalLibraryName", v12);
  uint64_t v15 = objc_msgSend_valueForKey_(v10, v13, @"sequence", v14);
  unsigned int v282 = objc_msgSend_valueForKey_(v10, v16, @"passes", v17);
  obuint64_t j = v15;
  uint64_t size = objc_msgSend_count(v15, v18, v19, v20);
  uint64_t v26 = objc_msgSend_valueForKey_(v10, v21, @"symbols", v22);
  if (!*(void *)(a1 + 96))
  {
    *(void *)(a1 + 96) = malloc_type_calloc(0x18uLL, 1uLL, 0xBF75870FuLL);
    *(unsigned char *)(a1 + 88) |= 0x10u;
  }
  CFIndex v27 = objc_msgSend_count(v26, v23, v24, v25);
  *(void *)(*(void *)(a1 + 96) + 16) = CFDictionaryCreateMutable(0, v27, MEMORY[0x1E4F1D530], 0);
  long long v291 = 0u;
  long long v292 = 0u;
  long long v289 = 0u;
  long long v290 = 0u;
  uint64_t v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(v26, v28, (uint64_t)&v289, (uint64_t)v294, 16);
  if (v29)
  {
    uint64_t v33 = v29;
    uint64_t v34 = *(void *)v290;
    do
    {
      for (uint64_t i = 0; i != v33; ++i)
      {
        if (*(void *)v290 != v34) {
          objc_enumerationMutation(v26);
        }
        uint64_t v36 = *(void **)(*((void *)&v289 + 1) + 8 * i);
        uint64_t v37 = objc_msgSend_valueForKey_(v26, v30, (uint64_t)v36, v32);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if (!objc_msgSend_valueForKey_(v37, v38, @"semantic", v40))
          {
            uint64_t v45 = (__CFString *)objc_msgSend_valueForKey_(v37, v30, @"type", v32);
            if ((objc_msgSend_isEqualToString_(v45, v46, @"color", v47) & 1) == 0
              && (objc_msgSend_isEqualToString_(v45, v30, @"depth", v32) & 1) == 0)
            {
              unsigned __int8 v48 = sub_1B63CA58C(v45);
              CFComparisonResult v49 = sub_1B63CA610(v45);
              if (v49) {
                sub_1B6515514(a1, v36, v49, v48, v50, v51, v52, v53);
              }
            }
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: invalue description for input named %@ - expect a dictionary", v39, v40, v41, v42, v43, v44, (uint64_t)v36);
        }
      }
      uint64_t v33 = objc_msgSend_countByEnumeratingWithState_objects_count_(v26, v30, (uint64_t)&v289, (uint64_t)v294, 16);
    }
    while (v33);
  }
  if (!size)
  {
    if (objc_msgSend_count(v282, v30, v31, v32)) {
      sub_1B63F2F54(16, @"Error: CFXFXRenderGraphCompile - invalid description (sequence missing or empty) %@", v64, v65, v66, v67, v68, v69, (uint64_t)v10);
    }
    return 1;
  }
  *(void *)(a1 + 80) = malloc_type_calloc(8uLL, size, 0xDF1982DDuLL);
  *(void *)(a1 + 64) = size;
  if (cf)
  {
    CFTypeID v55 = CFGetTypeID(cf);
    if (v55 == sub_1B64B19F4())
    {
      uint64_t v63 = sub_1B64B1FBC((uint64_t)cf, v56, v57, v58, v59, v60, v61, v62);
    }
    else
    {
      CFTypeID v70 = CFGetTypeID(cf);
      if (v70 == sub_1B64A06D4()) {
        uint64_t v63 = (uint64_t)cf;
      }
      else {
        uint64_t v63 = 0;
      }
    }
  }
  else
  {
    uint64_t v63 = 0;
  }
  long long v287 = 0u;
  long long v288 = 0u;
  long long v285 = 0u;
  long long v286 = 0u;
  uint64_t v71 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v54, (uint64_t)&v285, (uint64_t)v293, 16);
  if (v71)
  {
    uint64_t v72 = v71;
    uint64_t v73 = 0;
    CFTypeRef cfa = *(CFTypeRef *)v286;
    do
    {
      for (uint64_t j = 0; j != v72; ++j)
      {
        if (*(CFTypeRef *)v286 != cfa) {
          objc_enumerationMutation(obj);
        }
        CFStringRef v75 = *(const __CFString **)(*((void *)&v285 + 1) + 8 * j);
        uint64_t v76 = sub_1B65F6884();
        sub_1B65F6D94(v76, v75, v77, v78, v79, v80, v81, v82);
        uint64_t v85 = objc_msgSend_valueForKey_(v282, v83, (uint64_t)v75, v84);
        sub_1B65F70DC(v76, v85, (uint64_t)v10, v86, v87, v88, v89, v90);
        if (!sub_1B65F6BF8(v76, v91, v92, v93, v94, v95, v96, v97))
        {
          float32x4_t v105 = (const void *)objc_msgSend_objectForKey_(v85, v98, @"program", v100);
          sub_1B65F693C(v76, v105, v106, v107, v108, v109, v110, v111);
          float v114 = (const void *)objc_msgSend_objectForKey_(v85, v112, @"metalLibraryFile", v113);
          if (v114) {
            sub_1B65F6AB0(v76, v114, v116, v117, v118, v119, v120, v121);
          }
          float v122 = (const void *)objc_msgSend_objectForKey_(v85, v115, @"metalVertexShader", v117);
          sub_1B65F69B8(v76, v122, v123, v124, v125, v126, v127, v128);
          float32x4_t v131 = (const void *)objc_msgSend_objectForKey_(v85, v129, @"metalFragmentShader", v130);
          sub_1B65F6A34(v76, v131, v132, v133, v134, v135, v136, v137);
          simd_float4x4 v140 = objc_msgSend_objectForKey_(v85, v138, @"clientProgram", v139);
          if (v140) {
            char v148 = objc_msgSend_BOOLValue(v140, v141, v142, v143);
          }
          else {
            char v148 = 1;
          }
          sub_1B65F6B2C(v76, v148, v142, v143, v144, v145, v146, v147);
        }
        int v149 = *(_DWORD *)(v76 + 24);
        if (v149 == 6 || v149 == 3)
        {
          uint64_t v150 = *(void *)(v76 + 96);
          if (v150)
          {
            uint64_t v151 = sub_1B64AFA68(v150, (uint64_t)v98, v99, v100, v101, v102, v103, v104);
            if (v151)
            {
              uint64_t v157 = v151;
              if (*(uint64_t *)(v151 + 72) <= 0) {
                sub_1B63F2F54(17, @"Assertion '%s' failed. CFXFXRenderGraphGetPassAtIndex index %ld is out of bounds (%ld)", v152, v100, v153, v154, v155, v156, (uint64_t)"index < renderGraph->_count");
              }
              uint64_t v158 = **(void **)(v157 + 80);
              if (v158)
              {
                CFDictionaryRef v159 = (const __CFDictionary *)objc_msgSend_valueForKey_(v85, v98, @"inputs", v100);
                sub_1B65F8588(v158, v159, v157, v160, v161, v162, v163, v164);
              }
            }
          }
        }
        CFDictionaryRef v165 = (const __CFDictionary *)objc_msgSend_valueForKey_(v85, v98, @"inputs", v100);
        sub_1B65F8588(v76, v165, a1, v166, v167, v168, v169, v170);
        uint64_t v173 = objc_msgSend_valueForKey_(v10, v171, @"owners", v172);
        uint64_t v176 = objc_msgSend_objectAtIndex_(v173, v174, v73 + j, v175);
        uint64_t v177 = sub_1B6515CD4(@"pointOfView", v85, a1, v176, v63, (const void **)(v76 + 504));
        if (v177) {
          sub_1B65F6EE0(v76, v177, v178, v179, v180, v181, v182, v183);
        }
        id v184 = (const void *)sub_1B6515CD4(@"mirrorNode", v85, a1, v176, v63, (const void **)(v76 + 496));
        if (v184) {
          sub_1B65F6FAC(v76, v184, v185, v186, v187, v188, v189, v190);
        }
        unsigned int v191 = (const void *)sub_1B6515CD4(@"node", v85, a1, v176, v63, (const void **)(v76 + 488));
        if (v191) {
          sub_1B65F6F30(v76, v191, v193, v194, v195, v196, v197, v198);
        }
        CFDictionaryRef v199 = (const __CFDictionary *)objc_msgSend_valueForKey_(v85, v192, @"outputs", v194);
        sub_1B65F88E4(v76, v199, a1, v200, v201, v202, v203, v204);
        sub_1B65152BC((void *)a1, (CFTypeRef)v76, v205, v206, v207, v208, v209, v210, v277);
        CFRelease((CFTypeRef)v76);
      }
      uint64_t v72 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v211, (uint64_t)&v285, (uint64_t)v293, 16);
      v73 += j;
    }
    while (v72);
  }
  uint64_t v212 = *(void *)(a1 + 72);
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
  uint64_t v220 = Mutable;
  if (v212 < 1)
  {
    CFRelease(Mutable);
    char v265 = *(unsigned char *)(a1 + 88);
    goto LABEL_118;
  }
  uint64_t v221 = 0;
  int v283 = 0;
  char v222 = 0;
  do
  {
    uint64_t v223 = sub_1B6515448(a1, v221, v214, v215, v216, v217, v218, v219);
    uint64_t v225 = v223;
    if ((v222 & 1) == 0 && (v283 & 1) == 0)
    {
      uint64_t v226 = *(void *)(v223 + 520);
      if (v226 < 1) {
        goto LABEL_66;
      }
      char v222 = 0;
      uint64_t v227 = *(uint64_t **)(v223 + 512);
      do
      {
        uint64_t v228 = *v227++;
        v222 |= *(unsigned char *)(v228 + 88);
        --v226;
      }
      while (v226);
    }
    if (v222)
    {
      char v222 = 1;
      goto LABEL_67;
    }
LABEL_66:
    char v222 = 0;
    v283 |= *(unsigned __int8 *)(v223 + 186) >> 7;
LABEL_67:
    if (*(_DWORD *)(v223 + 440))
    {
      unint64_t v229 = 0;
      do
      {
        unsigned __int8 v284 = 0;
        unint64_t v230 = *(void *)(v225 + 432) + (v229 << 6);
        unsigned int v233 = *(_DWORD *)(v230 + 20);
        uint64_t v232 = (_DWORD *)(v230 + 20);
        unsigned int v231 = v233;
        uint64_t v234 = *(const void **)(v232 - 3);
        if (v234)
        {
          if (v231 > 0x7FFFFFFD)
          {
            if (v231 == 0x7FFFFFFF) {
              unsigned int v235 = 0x7FFFFFFF;
            }
            else {
              unsigned int v235 = 2147483646;
            }
          }
          else
          {
            unsigned int v235 = sub_1B6515DD0(a1, v234, v221, (uint64_t)&v284, 0, v217, v218, v219);
          }
          if (!CFSetContainsValue(v220, v234))
          {
            CFSetAddValue(v220, v234);
            *(_DWORD *)(*(void *)(v225 + 432) + (v229 << 6) + 20) = v235;
          }
          if (v284) {
            *(_DWORD *)(v225 + 184) |= 0x10u;
          }
          if (v235 >= 2) {
            *(_DWORD *)(v225 + 184) |= 0x400000u;
          }
        }
        else
        {
          *uint64_t v232 = v231 + 1;
          uint64_t v236 = v221 + 1;
          if (v221 + 1 < v212)
          {
            do
            {
              uint64_t v237 = sub_1B6515448(a1, v236, v214, v215, v216, v217, v218, v219);
              uint64_t v238 = *(void *)(v237 + 520);
              if (v238 >= 1)
              {
                uint64_t v239 = *(void *)(v237 + 512);
                do
                {
                  if ((*(unsigned char *)(*(void *)v239 + 88) & 3) != 0) {
                    ++*(_DWORD *)(*(void *)(v225 + 432) + (v229 << 6) + 20);
                  }
                  v239 += 8;
                  --v238;
                }
                while (v238);
              }
              uint64_t v240 = *(unsigned int *)(v237 + 440);
              if (v240)
              {
                uint64_t v241 = (uint64_t *)(*(void *)(v237 + 432) + 8);
                LOBYTE(v242) = 1;
                do
                {
                  uint64_t v243 = *v241;
                  v241 += 8;
                  int v242 = (v243 != 0) & v242;
                  --v240;
                }
                while (v240);
              }
              else
              {
                int v242 = 1;
              }
              ++v236;
            }
            while (v236 < v212 && v242);
          }
        }
        ++v229;
      }
      while (v229 < *(unsigned int *)(v225 + 440));
    }
    unsigned int v244 = *(_DWORD *)(v225 + 184);
    if ((v244 & 0x800010) == 0x800000)
    {
      unsigned __int8 v284 = 0;
      sub_1B6515DD0(a1, @"COLOR", v221, (uint64_t)&v284, 1, v217, v218, v219);
      unsigned int v244 = *(_DWORD *)(v225 + 184) & 0xFFFFFFEF | (16 * v284);
      *(_DWORD *)(v225 + 184) = v244;
    }
    if ((v244 & 0x400000) == 0)
    {
      if ((v244 & 0x800000) != 0)
      {
        uint64_t v245 = *(void *)(a1 + 72);
        uint64_t v246 = v221 + 1;
        if (v221 + 1 < v245)
        {
          BOOL v247 = 1;
          while (1)
          {
            uint64_t v248 = sub_1B6515448(a1, v246, v214, v215, v216, v217, v218, v219);
            uint64_t v249 = *(void *)(v248 + 520);
            if (v249 >= 1) {
              break;
            }
LABEL_106:
            BOOL v247 = ++v246 < v245;
            if (v246 == v245) {
              goto LABEL_107;
            }
          }
          uint64_t v250 = *(void *)(v248 + 512);
          while ((*(unsigned char *)(*(void *)v250 + 88) & 1) == 0)
          {
            v250 += 8;
            if (!--v249) {
              goto LABEL_106;
            }
          }
LABEL_107:
          unsigned int v244 = *(_DWORD *)(v225 + 184);
          if (v247) {
            goto LABEL_110;
          }
        }
      }
      if ((v244 & 0x1000000) != 0
        && (v251 = sub_1B6515C1C(a1, v221, v214, v215, v216, v217, v218, v219), unsigned int v244 = *(_DWORD *)(v225 + 184), v251))
      {
LABEL_110:
        *(_DWORD *)(v225 + 184) = v244 | 0x400000;
      }
      else if ((v244 & 0x1A00000) == 0x200000)
      {
        uint64_t v252 = sub_1B65F6E44(v225, v224, v214, v215, v216, v217, v218, v219);
        sub_1B63F2F54(0, @"Info: pass named %@ appears to be useless - skipping", v253, v254, v255, v256, v257, v258, v252);
        sub_1B65F6934(v225, 0);
      }
    }
    ++v221;
  }
  while (v221 != v212);
  CFRelease(v220);
  char v265 = *(unsigned char *)(a1 + 88);
  if (v283) {
    v265 |= 8u;
  }
LABEL_118:
  *(unsigned char *)(a1 + 88) = v265 | 4;
  if (size >= 1)
  {
    uint64_t v266 = sub_1B6515448(a1, size - 1, v259, v260, v261, v262, v263, v264);
    if (v266)
    {
      if (*(unsigned char *)(v266 + 185))
      {
        if (sub_1B65F6C44(v266, v267, v268, v269, v270, v271, v272, v273)) {
          char v275 = 4;
        }
        else {
          char v275 = 0;
        }
        char v274 = *(unsigned char *)(a1 + 88) & 0xFB | v275;
      }
      else
      {
        char v274 = *(unsigned char *)(a1 + 88) & 0xFB;
      }
      *(unsigned char *)(a1 + 88) = v274;
    }
  }
  return 1;
}

uint64_t sub_1B65151FC(size_t a1)
{
  if (qword_1EB995478 != -1) {
    dispatch_once(&qword_1EB995478, &unk_1F0FB5B88);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1EB995480, 0x90uLL);
  if (a1) {
    uint64_t v3 = malloc_type_calloc(8uLL, a1, 0x4CD25E05uLL);
  }
  else {
    uint64_t v3 = 0;
  }
  *(void *)(v2 + 80) = v3;
  *(void *)(v2 + 64) = a1;
  *(_DWORD *)(v2 + 92) = -1;
  return v2;
}

uint64_t sub_1B651528C()
{
  uint64_t result = qword_1E9DDB1E0;
  if (!qword_1E9DDB1E0)
  {
    uint64_t result = sub_1B65151FC(0);
    qword_1E9DDB1E0 = result;
  }
  return result;
}

void sub_1B65152BC(void *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    if (cf) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (cf) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"pass");
LABEL_3:
  if (a1[9] >= a1[8])
  {
    sub_1B63F2F54(16, @"Error: CFXFXRenderGraphAppendPass out of capacity", a3, a4, a5, a6, a7, a8, a9);
  }
  else
  {
    CFTypeRef v11 = CFRetain(cf);
    uint64_t v13 = a1[9];
    uint64_t v12 = a1[10];
    a1[9] = v13 + 1;
    *(void *)(v12 + 8 * v13) = v11;
    *((void *)cf + 5) = a1;
  }
}

uint64_t sub_1B6515384(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  return *(void *)(a1 + 72);
}

uint64_t sub_1B65153D0(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v6 = *(const void **)(*(void *)(*(void *)(a1 + 80) + 8 * v5) + 16);
    if (v6) {
      break;
    }
LABEL_6:
    if (++v5 >= v2) {
      return 0;
    }
  }
  if (!CFEqual(cf1, v6))
  {
    uint64_t v2 = *(void *)(a1 + 72);
    goto LABEL_6;
  }
  return *(void *)(*(void *)(a1 + 80) + 8 * v5);
}

uint64_t sub_1B6515448(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  if (*(void *)(a1 + 72) <= a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXFXRenderGraphGetPassAtIndex index %ld is out of bounds (%ld)", a3, a4, a5, a6, a7, a8, (uint64_t)"index < renderGraph->_count");
  }
  return *(void *)(*(void *)(a1 + 80) + 8 * a2);
}

uint64_t sub_1B65154C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  return *(void *)(a1 + 104);
}

void sub_1B6515514(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  int v9 = a3;
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (key) {
      goto LABEL_3;
    }
LABEL_18:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"symbolName");
    goto LABEL_3;
  }
  if (!key) {
    goto LABEL_18;
  }
LABEL_3:
  uint64_t v12 = *(void **)(a1 + 96);
  if (!v12
    || *v12
    && (sub_1B63F2F54(17, @"Assertion '%s' failed. Must declare upfront", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph->_parameterStorage == NULL || renderGraph->_parameterStorage->storage == NULL"), (uint64_t v12 = *(void **)(a1 + 96)) == 0))
  {
    uint64_t v12 = malloc_type_calloc(0x18uLL, 1uLL, 0xBF75870FuLL);
    *(void *)(a1 + 96) = v12;
    *(unsigned char *)(a1 + 88) |= 0x10u;
  }
  CFDictionaryRef Mutable = (const __CFDictionary *)v12[2];
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], 0);
    *(void *)(*(void *)(a1 + 96) + 16) = Mutable;
  }
  if (CFDictionaryGetValue(Mutable, key)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Cannot declare twice the same symbol (%@)", v15, v16, v17, v18, v19, v20, (uint64_t)"CFDictionaryGetValue(renderGraph->_parameterStorage->parameters, symbolName) == 0");
  }
  uint64_t v21 = *(int **)(a1 + 96);
  if (v9 == 5)
  {
    int v22 = *v21;
    uint64_t v23 = *((void *)v21 + 1);
    uint64_t v24 = (v22 + (int)v23) & 7;
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v23 = *((void *)v21 + 1);
  }
  uint64_t v25 = v8;
  uint64_t v26 = (const void *)(((v23 + v24) << 16) | ((unint64_t)v8 << 8) | v9 & 0x3F);
  uint64_t v27 = v24 + sub_1B63CA534(v9, v14, v15, v16, v17, v18, v19, v20) * v25;
  uint64_t v28 = *(void *)(a1 + 96);
  uint64_t v29 = *(__CFDictionary **)(v28 + 16);
  *(void *)(v28 + 8) += v27;

  CFDictionarySetValue(v29, key, v26);
}

void sub_1B65156B4(uint64_t a1, void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"paramName");
LABEL_3:
  if (!*(void *)(a1 + 96))
  {
    *(void *)(a1 + 96) = malloc_type_calloc(0x18uLL, 1uLL, 0xBF75870FuLL);
    *(unsigned char *)(a1 + 88) |= 0x10u;
  }
  sub_1B6515924((void *)a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 96) + 16), a2);
  if (Value)
  {
    uint64_t v20 = WORD1(Value);
    if ((Value & 0x3F) == 5)
    {
      if (v8 != 1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Assumed count is 1", v14, v15, v16, v17, v18, v19, (uint64_t)"count == 1");
      }
      if (a3)
      {
        CFTypeID v21 = CFGetTypeID(a3);
        if (v21 == sub_1B6439F58())
        {
          uint64_t v22 = sub_1B6439F58();
          if (v22 == CFGetTypeID(a3))
          {
            uint64_t v35 = (const void *)sub_1B6515974(a1, a2, 0, v24, v25, v26, v27, v28);
            if (!v35)
            {
              uint64_t v35 = (const void *)sub_1B6564EC0();
              sub_1B65156B4(a1, a2, v35, 1);
              CFRelease(v35);
            }
            sub_1B6564F64((uint64_t)v35, a3, v29, v30, v31, v32, v33, v34);
          }
          else
          {
            sub_1B63F2F54(16, @"Error: CFXFXRenderGraphSetValueForSymbol - expect an image for paramName %@", v23, v24, v25, v26, v27, v28, (uint64_t)a2);
          }
        }
        else
        {
          uint64_t v42 = *(uint64_t **)(a1 + 96);
          uint64_t v43 = *v42;
          uint64_t v44 = *(const void **)(*v42 + v20);
          if (v44 != a3)
          {
            if (v44)
            {
              CFRelease(v44);
              *(void *)(v43 + v20) = 0;
            }
            *(void *)(v43 + v20) = CFRetain(a3);
          }
        }
      }
      else
      {
        uint64_t v39 = *(uint64_t **)(a1 + 96);
        uint64_t v40 = *v39;
        uint64_t v41 = *(const void **)(*v39 + v20);
        if (v41)
        {
          CFRelease(v41);
          *(void *)(v40 + v20) = 0;
        }
      }
    }
    else if (a3)
    {
      if (BYTE1(Value) >= v8) {
        int v36 = v8;
      }
      else {
        int v36 = BYTE1(Value);
      }
      size_t v37 = sub_1B63CA534(Value & 0x3F, v13, v14, v15, v16, v17, v18, v19) * v36;
      uint64_t v38 = (void *)(**(void **)(a1 + 96) + v20);
      memcpy(v38, a3, v37);
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: CFXFXRenderGraphSetValueForSymbol - unknown param named %@", v14, v15, v16, v17, v18, v19, (uint64_t)a2);
  }
}

void *sub_1B6515924(void *result)
{
  CFAllocatorRef v1 = (void *)result[12];
  if (v1 && !*v1)
  {
    uint64_t v2 = result;
    uint64_t result = (void *)v1[1];
    if (result)
    {
      uint64_t result = malloc_type_calloc((size_t)result, 1uLL, 0x39AC6DDAuLL);
      *(void *)v2[12] = result;
    }
  }
  return result;
}

uint64_t sub_1B6515974(uint64_t a1, void *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  if (!a2) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"paramName");
LABEL_4:
  sub_1B6515924((void *)a1);
  __int16 v18 = 0;
  uint64_t v15 = sub_1B6515A60(a1, a2, &v18, 0, v11, v12, v13, v14);
  if (v15 == -1) {
    return 0;
  }
  uint64_t v16 = v15;
  if (a3) {
    *a3 = v18;
  }
  sub_1B6515924((void *)a1);
  uint64_t result = **(void **)(a1 + 96) + v16;
  if (v18 == 5) {
    return *(void *)result;
  }
  return result;
}

void sub_1B6515A58(uint64_t a1, void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B6515A60(uint64_t a1, void *key, _WORD *a3, BOOL *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (key) {
      goto LABEL_3;
    }
LABEL_13:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"paramName");
    goto LABEL_3;
  }
  if (!key) {
    goto LABEL_13;
  }
LABEL_3:
  uint64_t v12 = *(void *)(a1 + 96);
  if (v12
    && (CFDictionaryRef v13 = *(const __CFDictionary **)(v12 + 16)) != 0
    && (unint64_t Value = (unint64_t)CFDictionaryGetValue(v13, key),
        Value & 0xFFFFFFFF0000FFFFLL | ((unint64_t)WORD1(Value) << 16)))
  {
    char v15 = Value;
    uint64_t result = WORD1(Value);
    if (a3) {
      *a3 = v15 & 0x3F;
    }
    if (a4) {
      *a4 = (v15 & 0x40) != 0;
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: CFXFXRenderGraphGetValueForSymbol - unknown param named %@", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)key);
    return -1;
  }
  return result;
}

uint64_t sub_1B6515B48(uint64_t a1, void *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"paramName");
LABEL_3:
  sub_1B6515924((void *)a1);
  __int16 v18 = 0;
  uint64_t v15 = sub_1B6515A60(a1, a2, &v18, 0, v11, v12, v13, v14);
  if (v15 == -1) {
    return 0;
  }
  uint64_t v16 = v15;
  if (a3) {
    *a3 = v18;
  }
  sub_1B6515924((void *)a1);
  return **(void **)(a1 + 96) + v16;
}

BOOL sub_1B6515C1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  uint64_t v10 = *(void *)(a1 + 72);
  uint64_t v11 = a2 + 1;
  if (v11 >= v10)
  {
    return 0;
  }
  else
  {
    BOOL v12 = 1;
    while (1)
    {
      uint64_t v13 = sub_1B6515448(a1, v11, a3, a4, a5, a6, a7, a8);
      uint64_t v14 = *(void *)(v13 + 520);
      if (v14 >= 1) {
        break;
      }
LABEL_9:
      BOOL v12 = ++v11 < v10;
      if (v11 == v10) {
        return v12;
      }
    }
    uint64_t v15 = *(void *)(v13 + 512);
    while ((*(unsigned char *)(*(void *)v15 + 88) & 2) == 0)
    {
      v15 += 8;
      if (!--v14) {
        goto LABEL_9;
      }
    }
  }
  return v12;
}

uint64_t sub_1B6515CD4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void **a6)
{
  uint64_t v8 = a4;
  uint64_t v10 = objc_msgSend_objectForKey_(a2, (const char *)a2, a1, a4);
  if (!v10) {
    return 0;
  }
  uint64_t v13 = v10;
  if (objc_msgSend_isEqualToString_(v10, v11, @"self", v12))
  {
    if (!v8)
    {
      if (!a3) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v14, v15, v16, v17, v18, v19, (uint64_t)"td");
      }
      return *(void *)(a3 + 112);
    }
    return v8;
  }
  if (!a5)
  {
    CFTypeID v21 = *a6;
    if (*a6 != v13)
    {
      if (v21)
      {
        CFRelease(v21);
        *a6 = 0;
      }
      uint64_t v8 = 0;
      *a6 = CFRetain(v13);
      return v8;
    }
    return 0;
  }

  return sub_1B64A293C(a5, (uint64_t)v13, v14, v15, v16, v17, v18, v19);
}

uint64_t sub_1B6515DD0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  uint64_t v12 = a1;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  uint64_t v13 = *(void *)(v12 + 72);
  uint64_t v14 = a3 + 1;
  uint64_t v27 = (unsigned char *)a4;
  int v26 = v8;
  if (a3 + 1 >= v13)
  {
    LOBYTE(v16) = 0;
    LOBYTE(v15) = 0;
    uint64_t v17 = 1;
  }
  else
  {
    int v15 = 0;
    int v16 = 0;
    uint64_t v17 = 1;
    uint64_t v28 = v12;
    do
    {
      uint64_t v18 = sub_1B6515448(v12, v14, a3, a4, a5, a6, a7, a8);
      if (*(uint64_t *)(v18 + 520) >= 1)
      {
        uint64_t v19 = 0;
        do
        {
          uint64_t v20 = *(const void **)(*(void *)(*(void *)(v18 + 512) + 8 * v19) + 56);
          if (v20 && CFEqual(v20, a2))
          {
            ++v17;
            v16 |= v15 ^ 1;
          }
          ++v19;
        }
        while (v19 < *(void *)(v18 + 520));
      }
      if (*(_DWORD *)(v18 + 440))
      {
        unint64_t v21 = 0;
        uint64_t v22 = 8;
        do
        {
          uint64_t v23 = *(const void **)(*(void *)(v18 + 432) + v22);
          if (v23 && CFEqual(v23, a2))
          {
            v15 |= v16 ^ 1;
            ++v17;
          }
          ++v21;
          v22 += 64;
        }
        while (v21 < *(unsigned int *)(v18 + 440));
      }
      ++v14;
      uint64_t v12 = v28;
    }
    while (v14 != v13);
  }
  if (v27)
  {
    if (v26) {
      char v24 = ~(_BYTE)v15;
    }
    else {
      char v24 = v16;
    }
    *uint64_t v27 = v24 & 1;
  }
  return v17;
}

uint64_t sub_1B6515F54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  return (*(unsigned __int8 *)(a1 + 88) >> 1) & 1;
}

uint64_t sub_1B6515FA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  return (*(unsigned __int8 *)(a1 + 88) >> 2) & 1;
}

void sub_1B6515FF4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  if (a2) {
    char v10 = 4;
  }
  else {
    char v10 = 0;
  }
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a1 + 88) & 0xFB | v10;
}

uint64_t sub_1B651605C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  return *(void *)(a1 + 128);
}

void sub_1B65160A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"renderGraph");
  }
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9 >= 1)
  {
    for (uint64_t i = 0; i != v9; ++i)
    {
      uint64_t v11 = *(void (**)(void))(sub_1B6515448(a1, i, a3, a4, a5, a6, a7, a8) + 232);
      if (v11) {
        v11();
      }
    }
  }
}

uint64_t sub_1B6516134(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if (*(uint64_t *)(result + 72) <= 0) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. CFXFXRenderGraphGetPassAtIndex index %ld is out of bounds (%ld)", a3, a4, a5, a6, a7, a8, (uint64_t)"index < renderGraph->_count");
    }
    uint64_t v9 = **(void **)(v8 + 80);
    return sub_1B65F6BF8(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

void sub_1B65161A8(uint64_t a1, int a2, uint64_t a3)
{
  if ((a2 & 0x3F) == 5)
  {
    uint64_t v3 = *(const void **)(a3 + HIWORD(a2));
    if (v3) {
      CFRelease(v3);
    }
  }
}

CFStringRef sub_1B65161CC(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXFXRenderGraph>");
}

CFStringRef sub_1B6516200(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXFXRenderGraph>");
}

__CFArray *sub_1B6516234(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (*(uint64_t *)(a1 + 72) >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"pass %d", v4);
      uint64_t v6 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v16 = 2;
      int valuePtr = 5;
      uint64_t v15 = *(void *)(a1 + 80) + v3;
      CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt32Type, &v16);
      CFNumberRef v9 = CFNumberCreate(0, kCFNumberLongType, &v15);
      CFDictionarySetValue(v6, @"name", v5);
      CFDictionarySetValue(v6, @"type", v7);
      CFDictionarySetValue(v6, @"address", v9);
      CFDictionarySetValue(v6, @"semantic", v8);
      CFArrayAppendValue(Mutable, v6);
      CFRelease(v8);
      CFRelease(v6);
      CFRelease(v9);
      CFRelease(v7);
      CFRelease(v5);
      ++v4;
      v3 += 8;
    }
    while (v4 < *(void *)(a1 + 72));
  }
  char v10 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v16 = 2;
  int valuePtr = 5;
  uint64_t v15 = a1 + 104;
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberSInt32Type, &v16);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberLongType, &v15);
  CFDictionarySetValue(v10, @"name", @"plist");
  CFDictionarySetValue(v10, @"type", v11);
  CFDictionarySetValue(v10, @"address", v13);
  CFDictionarySetValue(v10, @"semantic", v12);
  CFArrayAppendValue(Mutable, v10);
  CFRelease(v12);
  CFRelease(v10);
  CFRelease(v13);
  CFRelease(v11);
  return Mutable;
}

uint64_t sub_1B65164D0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a4 == a3) {
    return 0;
  }
  uint64_t v4 = 0;
  *(_WORD *)(a1 + 7) = 257;
  *(unsigned char *)(a1 + 9) = 1;
  if (a4 > 36755)
  {
    if (a4 > 37807)
    {
      switch(a4)
      {
        case 37808:
        case 37840:
          int v5 = 2;
          goto LABEL_66;
        case 37809:
        case 37841:
          *(_DWORD *)a1 = 2;
          int v6 = 83952768;
          goto LABEL_86;
        case 37810:
        case 37842:
          *(_DWORD *)a1 = 2;
          int v13 = 83952768;
          goto LABEL_49;
        case 37811:
        case 37843:
          *(_DWORD *)a1 = 2;
          int v13 = 100729984;
          goto LABEL_49;
        case 37812:
        case 37844:
          *(_DWORD *)a1 = 2;
          int v14 = 100729984;
          goto LABEL_51;
        case 37813:
        case 37845:
          *(_DWORD *)a1 = 2;
          int v13 = 134284416;
          goto LABEL_49;
        case 37814:
        case 37846:
          *(_DWORD *)a1 = 2;
          int v14 = 134284416;
          goto LABEL_51;
        case 37815:
        case 37847:
          *(_DWORD *)a1 = 2;
          int v15 = 134284416;
          goto LABEL_53;
        case 37816:
        case 37848:
          *(_DWORD *)a1 = 2;
          int v13 = 167838848;
LABEL_49:
          *(_DWORD *)(a1 + 4) = v13;
          char v7 = 5;
          goto LABEL_87;
        case 37817:
        case 37849:
          *(_DWORD *)a1 = 2;
          int v14 = 167838848;
LABEL_51:
          *(_DWORD *)(a1 + 4) = v14;
          char v7 = 6;
          goto LABEL_87;
        case 37818:
        case 37850:
          *(_DWORD *)a1 = 2;
          int v15 = 167838848;
LABEL_53:
          *(_DWORD *)(a1 + 4) = v15;
          char v7 = 8;
          goto LABEL_87;
        case 37819:
        case 37851:
          *(_DWORD *)a1 = 2;
          int v16 = 167838848;
          goto LABEL_56;
        case 37820:
        case 37852:
          *(_DWORD *)a1 = 2;
          int v16 = 201393280;
LABEL_56:
          *(_DWORD *)(a1 + 4) = v16;
          char v7 = 10;
          goto LABEL_87;
        case 37821:
        case 37853:
          *(_DWORD *)a1 = 2;
          *(_DWORD *)(a1 + 4) = 201393280;
          char v7 = 12;
          goto LABEL_87;
        default:
          return v4;
      }
    }
    switch(a4)
    {
      case 37488:
      case 37489:
        *(_DWORD *)a1 = 5;
        int v6 = 67109184;
        goto LABEL_86;
      case 37490:
      case 37491:
        *(_DWORD *)a1 = 5;
        int v6 = 67109504;
        goto LABEL_86;
      case 37492:
      case 37493:
        int v11 = 5;
        goto LABEL_60;
      case 37494:
      case 37495:
        int v12 = 5;
        goto LABEL_85;
      case 37496:
      case 37497:
        int v5 = 5;
        goto LABEL_66;
      default:
        switch(a4)
        {
          case 36756:
            goto LABEL_26;
          case 36757:
            goto LABEL_69;
          case 36758:
          case 36762:
            return v4;
          case 36759:
            *(unsigned char *)(a1 + 6) = 1;
            *(_WORD *)(a1 + 4) = 1056;
LABEL_119:
            LODWORD(v4) = 72;
            goto LABEL_210;
          case 36760:
            goto LABEL_70;
          case 36761:
            goto LABEL_71;
          case 36763:
            goto LABEL_72;
          default:
            if (a4 == 36975) {
              goto LABEL_79;
            }
            break;
        }
        break;
    }
    return v4;
  }
  if (a4 > 35839)
  {
    if (a4 > 36193)
    {
      if (a4 > 36491)
      {
        if ((a4 - 36492) < 2)
        {
          char v7 = 4;
          *(_DWORD *)a1 = 4;
          int v8 = 67175552;
        }
        else
        {
          if ((a4 - 36494) >= 2) {
            return v4;
          }
          char v7 = 4;
          *(_DWORD *)a1 = 4;
          int v8 = 67109760;
        }
      }
      else if ((a4 - 36283) < 2)
      {
        char v7 = 4;
        *(_DWORD *)a1 = 4;
        int v8 = 67109184;
      }
      else
      {
        if ((a4 - 36285) >= 2)
        {
          if (a4 != 36194) {
            return v4;
          }
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 784;
          goto LABEL_118;
        }
        char v7 = 4;
        *(_DWORD *)a1 = 4;
        int v8 = 67109504;
      }
      *(_DWORD *)(a1 + 4) = v8;
      goto LABEL_87;
    }
    if (a4 > 35900)
    {
      if (a4 <= 35917)
      {
        if (a4 == 35901)
        {
LABEL_74:
          *(unsigned char *)(a1 + 6) = 1;
          __int16 v9 = 800;
LABEL_80:
          *(_WORD *)(a1 + 4) = v9;
          goto LABEL_88;
        }
        if (a4 == 35907)
        {
          *(unsigned char *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1056;
          BOOL v17 = a3 == 32993;
          LODWORD(v4) = 71;
          int v18 = 81;
LABEL_139:
          if (v17) {
            LODWORD(v4) = v18;
          }
          goto LABEL_210;
        }
        int v10 = 35917;
LABEL_83:
        if (a4 != v10) {
          return v4;
        }
        int v12 = 3;
LABEL_85:
        *(_DWORD *)a1 = v12;
        int v6 = 67175488;
        goto LABEL_86;
      }
      if ((a4 - 35918) >= 2) {
        return v4;
      }
LABEL_65:
      int v5 = 3;
LABEL_66:
      *(_DWORD *)a1 = v5;
      int v6 = 67175552;
LABEL_86:
      *(_DWORD *)(a1 + 4) = v6;
      char v7 = 4;
LABEL_87:
      *(unsigned char *)(a1 + 8) = v7;
LABEL_88:
      uint64_t v4 = 1;
      if (a4 > 36755)
      {
        if (a4 > 37807)
        {
          switch(a4)
          {
            case 37808:
              LODWORD(v4) = 204;
              goto LABEL_210;
            case 37809:
              LODWORD(v4) = 205;
              goto LABEL_210;
            case 37810:
              LODWORD(v4) = 206;
              goto LABEL_210;
            case 37811:
              LODWORD(v4) = 207;
              goto LABEL_210;
            case 37812:
              LODWORD(v4) = 208;
              goto LABEL_210;
            case 37813:
              LODWORD(v4) = 210;
              goto LABEL_210;
            case 37814:
              LODWORD(v4) = 211;
              goto LABEL_210;
            case 37815:
              LODWORD(v4) = 212;
              goto LABEL_210;
            case 37816:
              LODWORD(v4) = 213;
              goto LABEL_210;
            case 37817:
              LODWORD(v4) = 214;
              goto LABEL_210;
            case 37818:
              LODWORD(v4) = 215;
              goto LABEL_210;
            case 37819:
              LODWORD(v4) = 216;
              goto LABEL_210;
            case 37820:
              LODWORD(v4) = 217;
              goto LABEL_210;
            case 37821:
              LODWORD(v4) = 218;
              goto LABEL_210;
            case 37840:
              LODWORD(v4) = 186;
              goto LABEL_210;
            case 37841:
              LODWORD(v4) = 187;
              goto LABEL_210;
            case 37842:
              LODWORD(v4) = 188;
              goto LABEL_210;
            case 37843:
              LODWORD(v4) = 189;
              goto LABEL_210;
            case 37844:
              LODWORD(v4) = 190;
              goto LABEL_210;
            case 37845:
              LODWORD(v4) = 192;
              goto LABEL_210;
            case 37846:
              LODWORD(v4) = 193;
              goto LABEL_210;
            case 37847:
              LODWORD(v4) = 194;
              goto LABEL_210;
            case 37848:
              LODWORD(v4) = 195;
              goto LABEL_210;
            case 37849:
              LODWORD(v4) = 196;
              goto LABEL_210;
            case 37850:
              LODWORD(v4) = 197;
              goto LABEL_210;
            case 37851:
              LODWORD(v4) = 198;
              goto LABEL_210;
            case 37852:
              LODWORD(v4) = 199;
              goto LABEL_210;
            case 37853:
              LODWORD(v4) = 200;
              goto LABEL_210;
            default:
              return v4;
          }
          return v4;
        }
        switch(a4)
        {
          case 37488:
            LODWORD(v4) = 170;
            break;
          case 37489:
            LODWORD(v4) = 172;
            break;
          case 37490:
            LODWORD(v4) = 174;
            break;
          case 37491:
            LODWORD(v4) = 176;
            break;
          case 37492:
            LODWORD(v4) = 180;
            break;
          case 37493:
            LODWORD(v4) = 181;
            break;
          case 37494:
            LODWORD(v4) = 182;
            break;
          case 37495:
            LODWORD(v4) = 183;
            break;
          case 37496:
            LODWORD(v4) = 178;
            break;
          case 37497:
            LODWORD(v4) = 179;
            break;
          default:
            switch(a4)
            {
              case 36756:
                LODWORD(v4) = 12;
                goto LABEL_210;
              case 36757:
                LODWORD(v4) = 32;
                goto LABEL_210;
              case 36758:
              case 36762:
                return v4;
              case 36759:
                goto LABEL_119;
              case 36760:
                LODWORD(v4) = 22;
                goto LABEL_210;
              case 36761:
                LODWORD(v4) = 62;
                goto LABEL_210;
              case 36763:
                LODWORD(v4) = 112;
                goto LABEL_210;
              default:
                if (a4 != 36975) {
                  return v4;
                }
                LODWORD(v4) = 91;
                break;
            }
            break;
        }
LABEL_210:
        *(_DWORD *)(a1 + 24) = v4;
        return 1;
      }
      if (a4 <= 34835)
      {
        uint64_t v4 = 25;
        switch(a4)
        {
          case 33321:
            LODWORD(v4) = 10;
            goto LABEL_210;
          case 33322:
            LODWORD(v4) = 20;
            goto LABEL_210;
          case 33323:
            LODWORD(v4) = 30;
            goto LABEL_210;
          case 33324:
            LODWORD(v4) = 60;
            goto LABEL_210;
          case 33325:
            goto LABEL_210;
          case 33326:
            goto LABEL_132;
          case 33327:
            goto LABEL_134;
          case 33328:
            goto LABEL_136;
          case 33329:
            LODWORD(v4) = 14;
            goto LABEL_210;
          case 33330:
            LODWORD(v4) = 13;
            goto LABEL_210;
          case 33331:
            LODWORD(v4) = 24;
            goto LABEL_210;
          case 33332:
            LODWORD(v4) = 23;
            goto LABEL_210;
          case 33333:
            LODWORD(v4) = 54;
            goto LABEL_210;
          case 33334:
            LODWORD(v4) = 53;
            goto LABEL_210;
          case 33335:
            LODWORD(v4) = 34;
            goto LABEL_210;
          case 33336:
            LODWORD(v4) = 33;
            goto LABEL_210;
          case 33337:
            LODWORD(v4) = 64;
            goto LABEL_210;
          case 33338:
            LODWORD(v4) = 63;
            goto LABEL_210;
          case 33339:
            LODWORD(v4) = 104;
            goto LABEL_210;
          case 33340:
            LODWORD(v4) = 103;
            goto LABEL_210;
          default:
            if (a4 == 32857)
            {
              LODWORD(v4) = 90;
            }
            else
            {
              if (a4 != 32859) {
                return v4;
              }
              LODWORD(v4) = 110;
            }
            break;
        }
        goto LABEL_210;
      }
      if (a4 <= 35897)
      {
        if (a4 <= 35839)
        {
          switch(a4)
          {
            case 35412:
              LODWORD(v4) = 161;
              goto LABEL_210;
            case 35413:
              LODWORD(v4) = 163;
              goto LABEL_210;
            case 35414:
              LODWORD(v4) = 165;
              goto LABEL_210;
            case 35415:
              LODWORD(v4) = 167;
              goto LABEL_210;
            default:
              if (a4 == 34836) {
                goto LABEL_123;
              }
              if (a4 == 34842) {
                goto LABEL_122;
              }
              return v4;
          }
        }
        switch(a4)
        {
          case 35840:
            LODWORD(v4) = 162;
            goto LABEL_210;
          case 35841:
            LODWORD(v4) = 160;
            goto LABEL_210;
          case 35842:
            LODWORD(v4) = 166;
            goto LABEL_210;
          case 35843:
            LODWORD(v4) = 164;
            goto LABEL_210;
          default:
            return v4;
        }
        return v4;
      }
      if (a4 > 36213)
      {
        if (a4 <= 36225)
        {
          if (a4 == 36214)
          {
            LODWORD(v4) = 113;
          }
          else
          {
            if (a4 != 36220) {
              return v4;
            }
            LODWORD(v4) = 73;
          }
        }
        else
        {
          switch(a4)
          {
            case 36226:
              LODWORD(v4) = 124;
              break;
            case 36232:
              LODWORD(v4) = 114;
              break;
            case 36238:
              LODWORD(v4) = 74;
              break;
            default:
              return v4;
          }
        }
        goto LABEL_210;
      }
      if (a4 <= 35906)
      {
        if (a4 == 35898)
        {
          LODWORD(v4) = 92;
        }
        else
        {
          if (a4 != 35901) {
            return v4;
          }
          LODWORD(v4) = 93;
        }
        goto LABEL_210;
      }
      if (a4 != 36194)
      {
        if (a4 != 36208) {
          return v4;
        }
        LODWORD(v4) = 123;
        goto LABEL_210;
      }
LABEL_118:
      LODWORD(v4) = 40;
      goto LABEL_210;
    }
    switch(a4)
    {
      case 35840:
LABEL_38:
        int v11 = 1;
LABEL_60:
        *(_DWORD *)a1 = v11;
        int v6 = 67109696;
        goto LABEL_86;
      case 35841:
LABEL_34:
        *(_DWORD *)a1 = 1;
        int v6 = 134218560;
        goto LABEL_86;
      case 35842:
LABEL_40:
        int v12 = 1;
        goto LABEL_85;
      case 35843:
LABEL_39:
        *(_DWORD *)a1 = 1;
        int v6 = 134284352;
        goto LABEL_86;
      default:
        if (a4 == 35898) {
          goto LABEL_74;
        }
        break;
    }
  }
  else
  {
    if (a4 <= 33777)
    {
      switch(a4)
      {
        case 33321:
LABEL_26:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v9 = 264;
          goto LABEL_80;
        case 33322:
LABEL_70:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v9 = 272;
          goto LABEL_80;
        case 33323:
LABEL_69:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v9 = 528;
          goto LABEL_80;
        case 33324:
LABEL_71:
          *(unsigned char *)(a1 + 6) = 0;
          __int16 v9 = 544;
          goto LABEL_80;
        case 33325:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 272;
          LODWORD(v4) = 25;
          goto LABEL_210;
        case 33326:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 288;
LABEL_132:
          LODWORD(v4) = 55;
          goto LABEL_210;
        case 33327:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 544;
LABEL_134:
          LODWORD(v4) = 65;
          goto LABEL_210;
        case 33328:
          *(unsigned char *)(a1 + 6) = 0;
          *(_WORD *)(a1 + 4) = 576;
LABEL_136:
          LODWORD(v4) = 105;
          goto LABEL_210;
        default:
          switch(a4)
          {
            case 32854:
              *(unsigned char *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1040;
              LODWORD(v4) = 42;
              goto LABEL_210;
            case 32855:
              *(unsigned char *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1040;
              LODWORD(v4) = 41;
              goto LABEL_210;
            case 32856:
              *(unsigned char *)(a1 + 6) = 1;
              *(_WORD *)(a1 + 4) = 1056;
              BOOL v17 = a3 == 32993;
              LODWORD(v4) = 70;
              int v18 = 80;
              goto LABEL_139;
            case 32857:
LABEL_79:
              *(unsigned char *)(a1 + 6) = 1;
              __int16 v9 = 1056;
              goto LABEL_80;
            case 32858:
              return v4;
            case 32859:
LABEL_72:
              *(unsigned char *)(a1 + 6) = 1;
              __int16 v9 = 1088;
              goto LABEL_80;
            default:
              int v10 = 33777;
              goto LABEL_83;
          }
      }
      return v4;
    }
    if (a4 <= 35411)
    {
      if ((a4 - 33778) >= 2)
      {
        if (a4 == 34836)
        {
          *(unsigned char *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1152;
LABEL_123:
          LODWORD(v4) = 125;
        }
        else
        {
          if (a4 != 34842) {
            return v4;
          }
          *(unsigned char *)(a1 + 6) = 1;
          *(_WORD *)(a1 + 4) = 1088;
LABEL_122:
          LODWORD(v4) = 115;
        }
        goto LABEL_210;
      }
      goto LABEL_65;
    }
    switch(a4)
    {
      case 35412:
        goto LABEL_34;
      case 35413:
        goto LABEL_38;
      case 35414:
        goto LABEL_39;
      case 35415:
        goto LABEL_40;
      default:
        return v4;
    }
  }
  return v4;
}

uint64_t sub_1B65172D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B643B460(a1, a2, a3, a4, a5, a6, a7, a8)) {
    return 1;
  }
  BOOL v17 = sub_1B6439E60(a1, v9, v10, v11, v12, v13, v14, v15);
  if (!v17) {
    return 0;
  }
  int v18 = v17;
  BOOL v16 = CFEqual(v17, @"ktx") != 0;
  CFRelease(v18);
  return v16;
}

uint64_t sub_1B6517338(uint64_t a1)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = sub_1B63F2EE0();
  os_signpost_id_t v3 = os_signpost_id_generate(v2);
  uint64_t v4 = sub_1B63F2EE0();
  unint64_t v12 = v3 - 1;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v13 = v4;
    if (os_signpost_enabled(v4))
    {
      *(_DWORD *)buf = 67109120;
      int v72 = 1;
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v13, OS_SIGNPOST_INTERVAL_BEGIN, v3, "LoadImage (KTX)", "dd %d", buf, 8u);
    }
  }
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v6, v7, v8, v9, v10, v11, (uint64_t)"image");
  }
  CFDataRef v14 = (const __CFData *)sub_1B643B460(a1, v5, v6, v7, v8, v9, v10, v11);
  if (v14)
  {
    CFDataRef v22 = v14;
    CFRetain(v14);
  }
  else
  {
    uint64_t v36 = sub_1B6439EF8(a1, v15, v16, v17, v18, v19, v20, v21);
    if (!v36 || (CFDataRef v22 = (const __CFData *)sub_1B65F40FC(v36)) == 0)
    {
      uint64_t v35 = 0;
      goto LABEL_20;
    }
  }
  unint64_t Length = CFDataGetLength(v22);
  if (Length > 0x3F)
  {
    unint64_t v32 = Length;
    BytePtr = CFDataGetBytePtr(v22);
    if (*(void *)BytePtr != 0xBB31312058544BABLL || *((_DWORD *)BytePtr + 2) != 169478669) {
      goto LABEL_15;
    }
    uint64_t v40 = BytePtr;
    if (*((_DWORD *)BytePtr + 3) != 67305985)
    {
      uint64_t v30 = @"Error: Only big endian ktx are supported";
      int v31 = 16;
      goto LABEL_10;
    }
    sub_1B643BD50(a1);
    sub_1B643A0DC(a1, 0, 0, COERCE_DOUBLE(vcvt_f32_u32(*(uint32x2_t *)(v40 + 36))));
    if (*((_DWORD *)v40 + 13) == 6) {
      sub_1B643BEE8(a1, 3, v41, v42, v43, v44, v45, v46);
    }
    uint64_t v47 = (CFMutableArrayRef *)sub_1B643A1CC(a1);
    if ((sub_1B65164D0((uint64_t)v47, v48, *((_DWORD *)v40 + 6), *((_DWORD *)v40 + 7)) & 1) == 0)
    {
      uint64_t v57 = @"Error: Unsupported format in KTX file";
      int v58 = 16;
LABEL_54:
      sub_1B63F2F54(v58, (uint64_t)v57, v49, v50, v51, v52, v53, v54, v67);
      sub_1B643BD50(a1);
      goto LABEL_15;
    }
    uint64_t v55 = *(unsigned int *)v47;
    if (v55)
    {
      char v56 = (v55 - 5) < 0xFFFFFFFE;
      if (v55 == 2)
      {
        char v56 = sub_1B63CC3B8();
        uint64_t v55 = *(unsigned int *)v47;
      }
      if (v55 == 5)
      {
        if ((sub_1B63CC3B8() & 1) == 0)
        {
          uint64_t v55 = *(unsigned int *)v47;
LABEL_53:
          uint64_t v67 = v55;
          uint64_t v57 = @"Warning: Compression type %d not supported";
          int v58 = 0;
          goto LABEL_54;
        }
      }
      else if ((v56 & 1) == 0)
      {
        goto LABEL_53;
      }
    }
    uint64_t v59 = 0;
    unint64_t v60 = *((unsigned int *)v40 + 15) + 64;
    if (*((_DWORD *)v40 + 13) <= 1u) {
      int v61 = 1;
    }
    else {
      int v61 = *((_DWORD *)v40 + 13);
    }
    if (*((_DWORD *)v40 + 14) <= 1u) {
      int v62 = 1;
    }
    else {
      int v62 = *((_DWORD *)v40 + 14);
    }
    int v68 = v62;
    unint64_t v69 = v3 - 1;
    os_signpost_id_t v70 = v3;
    while (v60 <= v32)
    {
      uint64_t v63 = 0;
      CFIndex v64 = *(unsigned int *)&v40[v60];
      v60 += 4;
      while (1)
      {
        unint64_t v65 = v60 + v64;
        if (v60 + v64 > v32) {
          break;
        }
        CFDataRef v66 = CFDataCreate(0, &v40[v60], v64);
        CFArrayAppendValue(v47[4], v66);
        CFRelease(v66);
        unint64_t v60 = (v65 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v63 = (v63 + 1);
        if (v61 == v63) {
          goto LABEL_50;
        }
      }
      sub_1B63F2F54(16, @"Error: overflow reading slice[%d] / mip[%d] (%zu > %zu)", v49, v50, v51, v52, v53, v54, v63);
LABEL_50:
      uint64_t v59 = (v59 + 1);
      uint64_t v35 = 1;
      unint64_t v12 = v69;
      os_signpost_id_t v3 = v70;
      if (v59 == v68) {
        goto LABEL_16;
      }
    }
    sub_1B63F2F54(16, @"Error: overflow reading mip[%d] (%zu > %zu)", v49, v50, v51, v52, v53, v54, v59);
    uint64_t v35 = 1;
    goto LABEL_16;
  }
  uint64_t v30 = @"Warning: KTX file seems too small or is not a KTX";
  int v31 = 0;
LABEL_10:
  sub_1B63F2F54(v31, (uint64_t)v30, v24, v25, v26, v27, v28, v29, v67);
LABEL_15:
  uint64_t v35 = 0;
LABEL_16:
  CFRelease(v22);
LABEL_20:
  size_t v37 = sub_1B63F2EE0();
  if (v12 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v38 = v37;
    if (os_signpost_enabled(v37))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v38, OS_SIGNPOST_INTERVAL_END, v3, "LoadImage (KTX)", "", buf, 2u);
    }
  }
  return v35;
}

uint64_t sub_1B65176EC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id v4 = a1;
  uint64_t v165 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = objc_msgSend_width(a1, a2, a3, a4);
  uint64_t v9 = objc_msgSend_height(v4, v6, v7, v8);
  signed int v13 = objc_msgSend_depth(v4, v10, v11, v12);
  if (objc_msgSend_textureType(v4, v14, v15, v16) == 5) {
    uint64_t v20 = 6;
  }
  else {
    uint64_t v20 = 1;
  }
  uint64_t v21 = objc_msgSend_mipmapLevelCount(v4, v17, v18, v19);
  uint64_t v154 = v21;
  if (objc_msgSend_storageMode(v4, v22, v23, v24) == 2)
  {
    uint64_t v151 = v9;
    uint64_t v152 = v5;
    id v28 = objc_alloc_init(MEMORY[0x1E4F35330]);
    uint64_t v32 = objc_msgSend_textureType(v4, v29, v30, v31);
    objc_msgSend_setTextureType_(v28, v33, v32, v34);
    uint64_t v38 = objc_msgSend_pixelFormat(v4, v35, v36, v37);
    objc_msgSend_setPixelFormat_(v28, v39, v38, v40);
    uint64_t v44 = objc_msgSend_width(v4, v41, v42, v43);
    objc_msgSend_setWidth_(v28, v45, v44, v46);
    uint64_t v50 = objc_msgSend_height(v4, v47, v48, v49);
    objc_msgSend_setHeight_(v28, v51, v50, v52);
    uint64_t v56 = objc_msgSend_depth(v4, v53, v54, v55);
    objc_msgSend_setDepth_(v28, v57, v56, v58);
    uint64_t v62 = objc_msgSend_mipmapLevelCount(v4, v59, v60, v61);
    objc_msgSend_setMipmapLevelCount_(v28, v63, v62, v64);
    objc_msgSend_setUsage_(v28, v65, 0, v66);
    os_signpost_id_t v70 = objc_msgSend_device(v4, v67, v68, v69);
    uint64_t v73 = objc_msgSend_newTextureWithDescriptor_(v70, v71, (uint64_t)v28, v72);
    uint64_t v77 = objc_msgSend_device(v4, v74, v75, v76);
    uint64_t v81 = objc_msgSend_newCommandQueue(v77, v78, v79, v80);
    uint64_t v85 = objc_msgSend_commandBuffer(v81, v82, v83, v84);
    uint64_t v92 = objc_msgSend_blitCommandEncoder(v85, v86, v87, v88);
    if (v21)
    {
      uint64_t v94 = 0;
      *(void *)&long long v93 = __PAIR64__(v151, v152);
      signed int v95 = v13;
      do
      {
        uint64_t v96 = 0;
        *(_OWORD *)v153[0].i8 = v93;
        *(void *)&long long v97 = (int)v93;
        *((void *)&v97 + 1) = SDWORD1(v93);
        long long v155 = v97;
        uint64_t v98 = v95;
        do
        {
          long long v159 = v155;
          uint64_t v160 = v98;
          unint64_t v161 = 0;
          uint64_t v162 = 0;
          *(void *)&long long v163 = 0;
          memset(v158, 0, sizeof(v158));
          objc_msgSend_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_(v92, v89, (uint64_t)v4, v96, v94, &v161, &v159, v73, v96, v94, v158);
          ++v96;
        }
        while (v20 != v96);
        *((uint32x2_t *)&v93 + 1) = v153[1];
        *(uint32x2_t *)&long long v93 = vshl_u32(v153[0], (uint32x2_t)vcgt_s32((int32x2_t)v153[0], (int32x2_t)0x100000001));
        signed int v95 = v98 >> ((int)v98 > 1);
        ++v94;
        uint64_t v21 = v154;
      }
      while (v94 != v154);
    }
    objc_msgSend_endEncoding(v92, v89, v90, v91);
    objc_msgSend_commit(v85, v99, v100, v101);
    objc_msgSend_waitUntilCompleted(v85, v102, v103, v104);

    id v4 = v73;
    uint64_t v9 = v151;
    uint64_t v5 = v152;
  }
  memset(v164, 0, sizeof(v164));
  long long v163 = 0u;
  unint64_t v161 = 0xBB31312058544BABLL;
  uint64_t v162 = 0x40302010A1A0A0DLL;
  uint64_t v105 = objc_msgSend_pixelFormat(v4, v25, v26, v27);
  if (v105 > 79)
  {
    switch(v105)
    {
      case 'P':
        long long v109 = xmmword_1B6E51DE0;
        goto LABEL_24;
      case 's':
        long long v109 = xmmword_1B6E51E10;
        int v112 = 8;
        goto LABEL_26;
      case 'Q':
        long long v109 = xmmword_1B6E51E30;
        goto LABEL_24;
    }
LABEL_36:
    uint64_t v150 = sub_1B64D8178(v105);
    sub_1B63F2F54(16, @"Error: Unsupported pixel format %@ (%u) in KTX encoder", v144, v145, v146, v147, v148, v149, (uint64_t)v150);
    return 0;
  }
  switch(v105)
  {
    case 10:
      long long v109 = xmmword_1B6E51E00;
      int v110 = 1;
      break;
    case 25:
      long long v109 = xmmword_1B6E51DF0;
      int v110 = 2;
      break;
    case 71:
      long long v109 = xmmword_1B6E51E20;
LABEL_24:
      int v112 = 4;
LABEL_26:
      unsigned int v156 = v112;
      int v111 = 6408;
      goto LABEL_27;
    default:
      goto LABEL_36;
  }
  unsigned int v156 = v110;
  int v111 = 6403;
LABEL_27:
  long long v163 = v109;
  LODWORD(v164[0]) = v111;
  if (objc_msgSend_textureType(v4, v106, v107, v108) != 2 && objc_msgSend_textureType(v4, v113, v114, v115) != 5)
  {
    unint64_t v133 = objc_msgSend_textureType(v4, v113, v114, v115);
    uint64_t v134 = sub_1B64D8724(v133);
    objc_msgSend_textureType(v4, v135, v136, v137);
    sub_1B63F2F54(16, @"Error: Unsupported texture type %@ (%u) in KTX encoder", v138, v139, v140, v141, v142, v143, (uint64_t)v134);
    return 0;
  }
  DWORD1(v164[0]) = objc_msgSend_width(v4, v113, v114, v115);
  DWORD2(v164[0]) = objc_msgSend_height(v4, v116, v117, v118);
  *(void *)((char *)v164 + 12) = 0;
  *(void *)((char *)&v164[1] + 4) = __PAIR64__(v21, v20);
  uint64_t v121 = objc_msgSend_dataWithCapacity_(MEMORY[0x1E4F1CA58], v119, 0, v120);
  objc_msgSend_appendBytes_length_(v121, v122, (uint64_t)&v161, 64);
  uint64_t v124 = malloc_type_malloc(v9 * v5 * v156, 0x34030420uLL);
  if (v21)
  {
    uint64_t v125 = 0;
    int v126 = v9;
    do
    {
      LODWORD(v158[0]) = v5 * v156 * v126;
      objc_msgSend_appendBytes_length_(v121, v123, (uint64_t)v158, 4);
      for (uint64_t i = 0; i != v20; ++i)
      {
        memset(v157, 0, 24);
        v157[3] = (int)v5;
        v157[4] = v126;
        v157[5] = 1;
        objc_msgSend_getBytes_bytesPerRow_bytesPerImage_fromRegion_mipmapLevel_slice_(v4, v123, (uint64_t)v124, (int)(v5 * v156), LODWORD(v158[0]), v157, v125, i);
        objc_msgSend_appendBytes_length_(v121, v128, (uint64_t)v124, LODWORD(v158[0]));
      }
      LODWORD(v5) = v5 >> ((int)v5 > 1);
      int v126 = v126 >> (v126 > 1);
      ++v125;
    }
    while (v125 != v154);
  }
  free(v124);
  return objc_msgSend_copy(v121, v129, v130, v131);
}

void sub_1B6518308(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B651997C(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

uint64_t sub_1B65183F8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v6 = (unint64_t)(float)*(unint64_t *)(a1 + 40);

  return sub_1B6519B04(v5, v6);
}

uint64_t sub_1B6518574(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v6 = *(float *)(a1 + 40);

  return sub_1B6519AE4(v5, v6);
}

uint64_t sub_1B65186F8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v6 = *(float *)(a1 + 40);

  return sub_1B6519AF4(v5, v6);
}

void sub_1B65188F4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6519884(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B6518A70(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B651978C(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B6518C58(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(void *)(a1 + 40);

  sub_1B6519A5C(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B6518DD4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6519694(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

uint64_t sub_1B65191F8(uint64_t a1, float32x4_t *a2, __n128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x2_t a9)
{
  uint64_t v12 = (__n128 *)sub_1B63F4F54((void *)a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (v12)
  {
    v27.i32[2] = 0;
    v27.i64[0] = 0;
    __n128 v19 = sub_1B64B2438(v12, (__n128 *)&v27, v13, v14, v15, v16, v17, v18);
    int8x16_t v20 = v27;
  }
  else
  {
    int8x16_t v20 = (int8x16_t)xmmword_1B6E4F320;
  }
  v19.n128_u64[0] = (unint64_t)vbsl_s8((int8x8_t)vceqz_f32(*(float32x2_t *)(a1 + 228)), (int8x8_t)vdup_lane_s32(a9, 0), *(int8x8_t *)(a1 + 228));
  if (*(float *)&v20.i32[1] == 0.0)
  {
    if (*(float *)&v20.i32[2] == 0.0)
    {
      v24.i32[0] = 0;
      v24.i32[3] = 0;
      v24.f32[1] = -v19.n128_f32[0];
      v24.f32[2] = -v19.n128_f32[1];
      *a2 = v24;
      v20.i32[0] = 925353388;
      __n128 v19 = (__n128)vextq_s8(vextq_s8(v20, v20, 4uLL), (int8x16_t)v19, 0xCuLL);
    }
    else
    {
      *(float *)&unint64_t v23 = -v19.n128_f32[0];
      *((float *)&v23 + 1) = -v19.n128_f32[1];
      *a2 = (float32x4_t)v23;
      v19.n128_u32[2] = 925353388;
    }
  }
  else
  {
    float32x4_t v21 = vnegq_f32((float32x4_t)vzip1q_s32((int32x4_t)v19, (int32x4_t)v19));
    v21.i32[1] = 0;
    *a2 = v21;
    int8x16_t v22 = (int8x16_t)vdupq_n_s32(0x3727C5ACu);
    __n128 v19 = (__n128)vextq_s8((int8x16_t)vzip1q_s32((int32x4_t)v22, (int32x4_t)v19), v22, 4uLL);
  }
  *a3 = v19;
  return 1;
}

uint64_t sub_1B651930C()
{
  if (qword_1EB995488 != -1) {
    dispatch_once(&qword_1EB995488, &unk_1F0FB5BA8);
  }
  return qword_1EB995490;
}

double sub_1B6519350()
{
  if (!qword_1EB995490)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995490);
    qword_1EB995490 = (uint64_t)v0;
    CFAllocatorRef v1 = (const void *)sub_1B63CD970();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"reflectionFalloffEnd", 0xD8u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"reflectionFalloffStart", 0xD4u, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"reflectivity", 0xD0u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"width", 0xE4u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"length", 0xE8u, 1, 0, 0, 0, v10, v11);
    sub_1B660E3EC();
    unk_1EB983D48 = xmmword_1F0FB8830;
    unk_1EB983D58 = xmmword_1F0FB8840;
    qword_1EB983D40 = (uint64_t)sub_1B6519B7C;
    unk_1EB983D68 = *(_OWORD *)algn_1F0FB8850;
    qword_1EB983D78 = qword_1F0FB8860;
    unk_1EB983D80 = sub_1B651A3AC;
    double result = *(double *)&xmmword_1F0FB8820;
    xmmword_1EB983D30 = xmmword_1F0FB8820;
  }
  return result;
}

float sub_1B65195F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  return *(float *)(a1 + 208);
}

void sub_1B651963C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B63CE8F0(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v16 = (const void *)sub_1B63F4F54(a1, v9, v10, v11, v12, v13, v14, v15);

  sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v16, 0, 1u);
}

void sub_1B6519694(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  float v11 = *(float *)(a1 + 208);
  if (a9 == 0.0 || v11 != 0.0)
  {
    *(float *)(a1 + 208) = a9;
    if (a9 != 0.0 || v11 == 0.0) {
      return;
    }
  }
  else
  {
    *(float *)(a1 + 208) = a9;
  }

  sub_1B651963C((void *)a1, a2, a3, a4, a5, a6, a7, a8);
}

float sub_1B6519740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  return *(float *)(a1 + 212);
}

void sub_1B651978C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  float v11 = *(float *)(a1 + 212);
  if (a9 == 0.0 || v11 != 0.0)
  {
    *(float *)(a1 + 212) = a9;
    if (a9 != 0.0 || v11 == 0.0) {
      return;
    }
  }
  else
  {
    *(float *)(a1 + 212) = a9;
  }

  sub_1B651963C((void *)a1, a2, a3, a4, a5, a6, a7, a8);
}

float sub_1B6519838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  return *(float *)(a1 + 216);
}

void sub_1B6519884(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  float v11 = *(float *)(a1 + 216);
  if (a9 == 0.0 || v11 != 0.0)
  {
    *(float *)(a1 + 216) = a9;
    if (a9 != 0.0 || v11 == 0.0) {
      return;
    }
  }
  else
  {
    *(float *)(a1 + 216) = a9;
  }

  sub_1B651963C((void *)a1, a2, a3, a4, a5, a6, a7, a8);
}

float sub_1B6519930(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  return *(float *)(a1 + 220);
}

void sub_1B651997C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  if (a9 != 0.0 && *(float *)(a1 + 220) != a9)
  {
    *(float *)(a1 + 220) = a9;
    sub_1B651963C((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B6519A10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  return *(unsigned int *)(a1 + 224);
}

void sub_1B6519A5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"floor");
  }
  if (*(_DWORD *)(a1 + 224) != v8)
  {
    *(_DWORD *)(a1 + 224) = v8;
    sub_1B651963C((void *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

float sub_1B6519ADC(uint64_t a1)
{
  return *(float *)(a1 + 228);
}

uint64_t sub_1B6519AE4(uint64_t result, float a2)
{
  *(float *)(result + 228) = a2;
  return result;
}

float sub_1B6519AEC(uint64_t a1)
{
  return *(float *)(a1 + 232);
}

uint64_t sub_1B6519AF4(uint64_t result, float a2)
{
  *(float *)(result + 232) = a2;
  return result;
}

uint64_t sub_1B6519AFC(uint64_t a1)
{
  return *(void *)(a1 + 240);
}

uint64_t sub_1B6519B04(uint64_t result, uint64_t a2)
{
  *(void *)(result + 240) = a2;
  return result;
}

CFStringRef sub_1B6519B14(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXFloor>");
}

CFStringRef sub_1B6519B48(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXFloor>");
}

__CFArray *sub_1B6519B7C(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 208;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v5, @"name", @"reflectivity");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 212;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v9, @"name", @"reflectionFalloffStart");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 216;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v13, @"name", @"reflectionFalloffEnd");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 220;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v17, @"name", @"resolutionScaleFactor");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  float32x4_t v21 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 224;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v21, @"name", @"sampleCount");
  CFDictionarySetValue(v21, @"type", v22);
  CFDictionarySetValue(v21, @"address", v24);
  CFDictionarySetValue(v21, @"semantic", v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  uint64_t v25 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v40 = 0;
  int valuePtr = 2;
  uint64_t v39 = a1 + 240;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v25, @"name", @"reflectionBitMask");
  CFDictionarySetValue(v25, @"type", v26);
  CFDictionarySetValue(v25, @"address", v28);
  CFDictionarySetValue(v25, @"semantic", v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  uint64_t v29 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 228;
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v29, @"name", @"width");
  CFDictionarySetValue(v29, @"type", v30);
  CFDictionarySetValue(v29, @"address", v32);
  CFDictionarySetValue(v29, @"semantic", v31);
  CFArrayAppendValue(Mutable, v29);
  CFRelease(v31);
  CFRelease(v29);
  CFRelease(v32);
  CFRelease(v30);
  uint64_t v33 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v40 = 0;
  int valuePtr = 1;
  uint64_t v39 = a1 + 232;
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, &v40);
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberLongType, &v39);
  CFDictionarySetValue(v33, @"name", @"length");
  CFDictionarySetValue(v33, @"type", v34);
  CFDictionarySetValue(v33, @"address", v36);
  CFDictionarySetValue(v33, @"semantic", v35);
  CFArrayAppendValue(Mutable, v33);
  CFRelease(v35);
  CFRelease(v33);
  CFRelease(v36);
  CFRelease(v34);
  uint64_t v37 = sub_1B63CD140(a1);
  v42.length = CFArrayGetCount(v37);
  v42.location = 0;
  CFArrayAppendArray(Mutable, v37, v42);
  CFRelease(v37);
  return Mutable;
}

uint64_t sub_1B651A32C(uint64_t a1, int32x2_t a2, uint64_t a3, float32x4_t *a4, __n128 *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  a2.i32[0] = *(_DWORD *)"(knN";
  sub_1B65191F8(a1, a4, a5, (uint64_t)a5, a6, a7, a8, a9, a2);
  return 1;
}

const void *sub_1B651A358(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double result = (const void *)sub_1B63CCE68(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    return (const void *)sub_1B63F49F8(result, a2, a3, v11, v12, v13, v14, v15);
  }
  return result;
}

uint64_t sub_1B651A3AC(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

void sub_1B651A3E4(uint64_t a1, void *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((void *)(a1 + 208) == __dst)
  {
    sub_1B6519694(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, *__src);
  }
  else if ((void *)(a1 + 216) == __dst)
  {
    sub_1B6519884(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, *__src);
  }
  else
  {
    memcpy(__dst, __src, __n);
  }
}

void sub_1B651ABA4(uint64_t a1)
{
}

CFStringRef sub_1B651AC84(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  return sub_1B65834BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B651B008(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend_meshRef(*(void **)(a1 + 40), a2, a3, a4);

  sub_1B63CDBD0(v4, v5, v6, v7, v8, v9, v10, v11);
}

void *sub_1B651B440(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(const void **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = objc_msgSend_coreEntityHandleRef(*(void **)(a1 + 40), a2, a3, a4);

  return sub_1B63F48A0(v4, v5, v6, v7, v8, v9, v10, v11);
}

void sub_1B651B738(uint64_t a1)
{
}

__n128 sub_1B651B748(float32x4_t *a1)
{
  float32x4_t v1 = a1[2];
  float32x4_t v2 = a1[3];
  v1.i32[3] = 1.0;
  v2.i32[3] = 1.0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v5[0] = vmulq_f32(vaddq_f32(v1, v2), v3);
  v5[1] = vmulq_f32(vsubq_f32(v2, v1), v3);
  sub_1B63CD0A4(*(void *)(a1[4].i64[0] + 8), v5);
  return result;
}

uint64_t sub_1B651BA7C(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_setValue_forKey_(*(void **)(a1 + 32), a2, a3, (uint64_t)a2);
}

uint64_t sub_1B651BBDC(uint64_t a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_setValue_forUndefinedKey_(*(void **)(a1 + 32), a2, a3, (uint64_t)a2);
}

id sub_1B651BD80(VFXModel *self, SEL a2)
{
  uint64_t v4 = objc_msgSend_copy(self, a2, v2, v3);
  uint64_t v8 = objc_msgSend_mesh(v4, v5, v6, v7);
  id v12 = (id)objc_msgSend_interleavedCopy(v8, v9, v10, v11);
  objc_msgSend_setMesh_(v4, v13, (uint64_t)v12, v14);
  return v4;
}

id sub_1B651BDC0(VFXModel *self, SEL a2)
{
  uint64_t v4 = objc_msgSend_copy(self, a2, v2, v3);
  uint64_t v8 = objc_msgSend_mesh(v4, v5, v6, v7);
  id v12 = (id)objc_msgSend__renderableCopy(v8, v9, v10, v11);
  objc_msgSend_setMesh_(v4, v13, (uint64_t)v12, v14);
  return v4;
}

uint64_t sub_1B651C034(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_addWorldReference_(a2, (const char *)a2, *(void *)(a1 + 32), a4);
}

uint64_t sub_1B651C108(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_removeWorldReference_(a2, (const char *)a2, *(void *)(a1 + 32), a4);
}

void sub_1B651C238(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B651C530(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v6 = objc_msgSend_materialRef(*(void **)(a1 + 40), a2, a3, a4);
  CFIndex v12 = *(void *)(a1 + 48);

  sub_1B63CE524(v5, v6, v12, v7, v8, v9, v10, v11);
}

void sub_1B651C67C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B651C794(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v6 = objc_msgSend_materialRef(*(void **)(a1 + 40), a2, a3, a4);
  uint64_t v12 = *(void *)(a1 + 48);

  sub_1B63CE5B4(v5, v6, v12, v7, v8, v9, v10, v11);
}

void sub_1B651CCB8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v4)
  {
    sub_1B63CE464(v4, v5, v6, v7, v8, v9, v10, v11);
  }
}

uint64_t sub_1B651D2AC(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_thresholdMode(a2, (const char *)a2, (uint64_t)a3, a4);
  uint64_t v10 = objc_msgSend_thresholdValue(a2, v7, v8, v9);
  objc_msgSend_doubleValue(v10, v11, v12, v13);
  double v15 = v14;
  CFNumberRef v19 = objc_msgSend_thresholdValue(a3, v16, v17, v18);
  objc_msgSend_doubleValue(v19, v20, v21, v22);
  BOOL v24 = v15 > v23;
  if (!v6) {
    BOOL v24 = v15 < v23;
  }
  if (v24) {
    return -1;
  }
  else {
    return 1;
  }
}

void sub_1B651D328(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)MEMORY[0x1E4F1CA48];
  uint64_t v6 = objc_msgSend_count(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v9 = objc_msgSend_arrayWithCapacity_(v5, v7, v6, v8);
  uint64_t v10 = *(void **)(a1 + 32);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  void v19[2] = sub_1B651D3D4;
  v19[3] = &unk_1E6141E50;
  v19[4] = v9;
  objc_msgSend_enumerateObjectsUsingBlock_(v10, v11, (uint64_t)v19, v12);
  sub_1B63CDEBC(*(void *)(*(void *)(a1 + 40) + 8), v9, v13, v14, v15, v16, v17, v18);
}

uint64_t sub_1B651D3D4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v6 = objc_msgSend___CFObject(a2, (const char *)a2, a3, a4);

  return objc_msgSend_addObject_(v4, v5, v6, v7);
}

void sub_1B651D548(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    int v6 = *(_DWORD *)(a1 + 40);
    sub_1B647F588(v5, v6);
  }
}

void sub_1B651D66C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 40);
    sub_1B647F3D0(v5, v12, v6, v7, v8, v9, v10, v11);
  }
}

void sub_1B651D770(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    int v12 = *(unsigned __int8 *)(a1 + 40);
    sub_1B647F514(v5, v12, v6, v7, v8, v9, v10, v11);
  }
}

void sub_1B651D8B8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    uint64_t v9 = (__n128 *)v5;
    uint64_t v10 = (const void *)objc_msgSend_meshElement(*(void **)(*(void *)(a1 + 32) + 112), v6, v7, v8);
    sub_1B647F6A8(v9, v10);
  }
}

void sub_1B651DA20(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    uint64_t v9 = (__n128 *)v5;
    uint64_t v10 = (const void *)objc_msgSend_meshSource(*(void **)(*(void *)(a1 + 32) + 104), v6, v7, v8);
    sub_1B647F610(v9, v10);
  }
}

void sub_1B651E080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B6584BAC(*(void *)(a1 + 40), *(void **)(a1 + 32), *(__int16 **)(a1 + 48), a4, a5, a6, a7, a8);
  uint64_t v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
  }
}

void sub_1B651E0D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(__int16 **)(a1 + 48);
  if (v9)
  {
    sub_1B6584BAC(*(void *)(a1 + 56), *(void **)(a1 + 32), v9, a4, a5, a6, a7, a8);
    uint64_t v10 = *(const void **)(a1 + 48);
    CFRelease(v10);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 56);
    int v12 = *(void **)(a1 + 32);
    uint64_t v13 = *(__int16 **)(a1 + 40);
    if (v13)
    {
      sub_1B6584BAC(v11, v12, v13, a4, a5, a6, a7, a8);
    }
    else
    {
      sub_1B6584CD4(v11, v12, 0, a4, a5, a6, a7, a8);
    }
  }
}

uint64_t sub_1B651E21C(uint64_t a1, uint64_t a2)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result)
  {
    uint64_t v7 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v7, v5, a2, v6);
  }
  return result;
}

uint64_t sub_1B651E400(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_compare_(a2, (const char *)a2, a3, a4);
}

uint64_t sub_1B651E4C4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = sub_1B64C775C(a3);
  if (result)
  {
    uint64_t v8 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v8, v6, a2, v7);
  }
  return result;
}

uint64_t sub_1B651E5D4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = sub_1B64C775C(a3);
  if (result)
  {
    uint64_t v8 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v8, v6, (uint64_t)a3, v7);
  }
  return result;
}

void sub_1B651EA30(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 56));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 64), v10, *(void *)(a1 + 48), v11);
    int v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 56);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B651EC44(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B651ED0C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B651EDE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B651EECC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B651F40C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  BOOL v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B651F568(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B651F644(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t VFXVector3EqualToVector3(float32x4_t a1, float32x4_t a2)
{
  int16x4_t v2 = vmovn_s32(vceqq_f32(a1, a2));
  if (v2.i16[0] & v2.i16[1]) {
    __int8 v3 = v2.i8[4];
  }
  else {
    __int8 v3 = 0;
  }
  return v3 & 1;
}

uint64_t VFXVector4EqualToVector4(float32x4_t a1, float32x4_t a2)
{
  __int8 v2 = 0;
  int32x4_t v3 = vceqq_f32(a1, a2);
  int16x4_t v4 = vmovn_s32(v3);
  if (v4.i8[4] & 1) != 0 && (vand_s8(*(int8x8_t *)v3.i8, (int8x8_t)vdup_n_s32(v4.u16[1])).u8[0]) {
    __int8 v2 = v4.i8[6];
  }
  return v2 & 1;
}

float64x2_t sub_1B651FE74(float32x2_t *a1, float64x2_t *a2)
{
  float64x2_t result = vcvtq_f64_f32(*a1);
  float64x2_t v3 = vcvtq_f64_f32(a1[1]);
  float64x2_t v4 = vcvtq_f64_f32(a1[2]);
  float64x2_t v5 = vcvtq_f64_f32(a1[3]);
  float64x2_t v6 = vcvtq_f64_f32(a1[4]);
  float64x2_t v7 = vcvtq_f64_f32(a1[5]);
  float64x2_t v8 = vcvtq_f64_f32(a1[6]);
  float64x2_t v9 = vcvtq_f64_f32(a1[7]);
  *a2 = result;
  a2[1] = v3;
  a2[2] = v4;
  a2[3] = v5;
  a2[4] = v6;
  a2[5] = v7;
  a2[6] = v8;
  a2[7] = v9;
  return result;
}

float64x2_t sub_1B651FEB8(float32x4_t *a1, float64x2_t *a2)
{
  float32x4_t v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a2[2]), a2[3]);
  float32x4_t v3 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a2[4]), a2[5]);
  float64x2_t result = a2[7];
  float32x4_t v5 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(a2[6]), result);
  *a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a2), a2[1]);
  a1[1] = v2;
  a1[2] = v3;
  a1[3] = v5;
  return result;
}

double VFXMatrix4Scale(float32x4_t a1, double a2, double a3, double a4, float a5)
{
  *(void *)&double result = vmulq_n_f32(a1, a5).u64[0];
  return result;
}

__n64 VFXMatrix4MakeRotation(float a1, float32x4_t a2, float32_t a3, float32_t a4)
{
  a2.f32[1] = a3;
  a2.f32[2] = a4;
  float32x4_t v4 = vmulq_f32(a2, a2);
  v4.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u64[0];
  float32x4_t v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 0);
  v5.i32[3] = 0;
  float32x4_t v6 = vrsqrteq_f32(v5);
  float32x4_t v7 = vmulq_f32(v6, vrsqrtsq_f32(v5, vmulq_f32(v6, v6)));
  int8x16_t v8 = (int8x16_t)vmulq_f32(v7, vrsqrtsq_f32(v5, vmulq_f32(v7, v7)));
  int32x4_t v9 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v4.f32[0] != 0.0)), 0x1FuLL));
  v9.i32[3] = 0;
  __asm { FMOV            V4.4S, #1.0 }
  float32x4_t v19 = vmulq_f32(a2, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v9), v8, _Q4));
  float32x4_t v20 = (float32x4_t)_Q4;
  __float2 v15 = __sincosf_stret(a1);
  float32x4_t v16 = v19;
  float32x4_t v17 = vmulq_f32(v16, v16);
  result.n64_u32[0] = vmlaq_n_f32(v17, vsubq_f32(v20, v17), v15.__cosval).u32[0];
  result.n64_f32[1] = (float)((float)(1.0 - v15.__cosval) * vmulq_lane_f32(v16, *(float32x2_t *)v16.f32, 1).f32[0])
                    - COERCE_FLOAT(vmulq_n_f32(v19, -*(float *)&v15).i32[2]);
  return result;
}

BOOL VFXMatrix4EqualToMatrix4(__n128 a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8)
{
  __s1[0] = a1;
  __s1[1] = a2;
  __s1[2] = a3;
  __s1[3] = a4;
  v9[0] = a5;
  v9[1] = a6;
  v9[2] = a7;
  v9[3] = a8;
  return memcmp(__s1, v9, 0x40uLL) == 0;
}

BOOL VFXMatrix4IsIdentity(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __s1[0] = a1;
  __s1[1] = a2;
  __s1[2] = a3;
  __s1[3] = a4;
  v5[0] = xmmword_1B6E4F300;
  v5[1] = xmmword_1B6E4F320;
  _OWORD v5[2] = xmmword_1B6E4F2E0;
  v5[3] = xmmword_1B6E4F370;
  return memcmp(__s1, v5, 0x40uLL) == 0;
}

double VFXMatrix4Rotate(__n128 a1, float32x4_t a2, __n128 a3, __n128 a4, float a5, float32_t a6, float32_t a7, float32_t a8)
{
  float32x4_t v15 = a2;
  a2.f32[0] = a6;
  *(__n64 *)v8.f32 = VFXMatrix4MakeRotation(a5, a2, a7, a8);
  uint64_t v12 = 0;
  v18[0] = a1;
  v18[1] = v15;
  v18[2] = a3;
  v18[3] = a4;
  memset(v19, 0, sizeof(v19));
  do
  {
    v19[v12] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, COERCE_FLOAT(v18[v12])), v9, *(float32x2_t *)&v18[v12], 1), v10, (float32x4_t)v18[v12], 2), v11, (float32x4_t)v18[v12], 3);
    ++v12;
  }
  while (v12 != 4);
  return *(double *)v19;
}

uint64_t sub_1B6520164(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v70 = a2;
  *((void *)&v70 + 1) = a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB1F0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB1F0))
  {
    byte_1E9DDB1E8 = 1;
    __cxa_guard_release(&qword_1E9DDB1F0);
  }
  if (byte_1E9DDB1E8) {
    uint64_t v10 = 0xDFD87824203AD5B5;
  }
  else {
    uint64_t v10 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, a4, v10, a5);
  *(void *)a1 = &unk_1F0FB3130;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  uint64_t v18 = sub_1B6446564(*(uint64_t **)(a1 + 368), v11, v12, v13, v14, v15, v16, v17);
  CFDictionaryRef v26 = sub_1B64A3B48((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
  if (v26)
  {
    if (sub_1B649B548((uint64_t)v26, v27, v28, v29, v30, v31, v32, v33)) {
      __int16 v34 = 2560;
    }
    else {
      __int16 v34 = 512;
    }
  }
  else
  {
    __int16 v34 = 512;
  }
  uint64_t v36 = a4[4];
  uint64_t v35 = a4[5];
  *(void *)&long long v71 = *(void *)(a1 + 368);
  uint64_t v73 = 0;
  long long v72 = (unint64_t)sub_1B6446564((uint64_t *)v71, v27, v28, v29, v30, v31, v32, v33);
  __n128 v75 = sub_1B64471F4(*(void *)(a1 + 368), 0, v37, v38, v39, v40, v41, v42);
  char v76 = 1;
  long long v77 = xmmword_1B6E4FC80;
  char v78 = *(unsigned char *)(a1 + 376);
  char v79 = 2;
  uint64_t v80 = 34;
  int v81 = 1;
  __int16 v82 = 1;
  *(void *)(a1 + 384) = sub_1B63F9384(v70, *((uint64_t *)&v70 + 1), (uint64_t *)&v70, (uint64_t *)&v71, &v72);
  long long v43 = v70;
  uint64_t v44 = *(void *)(a1 + 368);
  *(void *)&long long v72 = 0;
  WORD4(v72) = v34;
  BYTE10(v72) = *(unsigned char *)(a1 + 377);
  uint64_t v73 = 2;
  __int16 v74 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB1F0, memory_order_acquire) & 1) == 0)
  {
    long long v69 = v43;
    int v68 = __cxa_guard_acquire(&qword_1E9DDB1F0);
    long long v43 = v69;
    if (v68)
    {
      byte_1E9DDB1E8 = 1;
      __cxa_guard_release(&qword_1E9DDB1F0);
      long long v43 = v69;
    }
  }
  if (byte_1E9DDB1E8) {
    unint64_t v45 = 0xDFD87824203AD5B5;
  }
  else {
    unint64_t v45 = 0;
  }
  v75.n128_u64[0] = v45;
  long long v71 = v43;
  uint64_t v46 = sub_1B63C8330(&v71, 0x40u, 8u);
  sub_1B6460520(v46, v44, (uint64_t)&v72, *(void *)(a1 + 384));
  *(void *)(a1 + 392) = v47;
  if (v36) {
    CFX::RG::Pass::renderTo(a1, v36, 0x100000002, 0);
  }
  if (v35) {
    CFX::RG::Pass::renderTo(a1, v35, 0x200000002, -1);
  }
  CFX::RG::Pass::renderTo(a1, a4[6], 0x100000002, 3);
  CFX::RG::Pass::renderTo(a1, a4[7], 0x100000002, 1);
  CFX::RG::Pass::renderTo(a1, a4[8], 0x100000002, 2);
  CFX::RG::Pass::renderTo(a1, a4[9], 0x100000002, 0);
  CFX::RG::Pass::renderTo(a1, a4[10], 0x100000002, 4);
  CFX::RG::Pass::renderTo(a1, a4[11], 0x100000002, 5);
  CFX::RG::Pass::renderTo(a1, a4[12], 0x100000002, 6);
  for (uint64_t i = 0; i != 256; i += 32)
  {
    uint64_t v49 = (_OWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + i);
    *uint64_t v49 = 0u;
    v49[1] = 0u;
  }
  sub_1B64479B4(*(void *)(a1 + 368), a4[10] != 0);
  sub_1B65A8594(*(__n128 **)(a1 + 384), v50, v51, v52);
  sub_1B65A88F8(*(void *)(a1 + 384), v53, v54, v55, v56, v57, v58, v59);
  sub_1B65A8D10(*(void *)(a1 + 384));
  sub_1B65A8D3C(*(void *)(a1 + 384), v60, v61, v62, v63, v64, v65, v66);
  return a1;
}

void sub_1B652051C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6520548(CFX::RG::Pass *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 50);
  if (!v4)
  {
    float32x4_t v5 = *(CFX::CrossFrameResourceManager **)(a2 + 32);
    unint64_t v6 = CFX::RG::Pass::hash(this);
    *((void *)this + 50) = sub_1B6520618(v5, v6);
    uint64_t v7 = sub_1B64AED1C();
    sub_1B65834BC(v7, @"--GBufferMaterial--", v8, v9, v10, v11, v12, v13);
    uint64_t v21 = sub_1B64AF43C(v7, v14, v15, v16, v17, v18, v19, v20);
    sub_1B6475724(v21, 0, v22, v23, v24, v25, v26, v27);
    uint64_t v4 = *((void *)this + 50);
    uint64_t v28 = *(const void **)(v4 + 16);
    if (v28 != (const void *)v7)
    {
      uint64_t v29 = *((void *)this + 50);
      if (v28)
      {
        CFRelease(v28);
        uint64_t v29 = *((void *)this + 50);
      }
      *(void *)(v4 + 16) = v7;
      uint64_t v4 = v29;
    }
  }
  sub_1B65A8DB4(*((void *)this + 48), v4 + 32, 0x10u);
  sub_1B6460548(*((void *)this + 49), (const char *)a2, v30, v31);
  uint64_t v33 = (uint64_t *)*((void *)this + 48);
  __int16 v34 = *(const char **)a2;
  uint64_t v35 = *(void *)(a2 + 8);

  sub_1B65A8F34(v33, v34, v35, v32);
}

uint64_t sub_1B6520618(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B6520684(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A1C407E34DEDDLL);
  _Unwind_Resume(a1);
}

void sub_1B65206A8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B65206B0(uint64_t a1, const char *a2, uint64_t a3)
{
  sub_1B6460C38(*(void *)(a1 + 392), a2, a3, 0);
  sub_1B65A8E14(*(void *)(a1 + 384), *(void *)(a1 + 400) + 32, 0x10u);
  sub_1B65A8E74(*(void *)(a1 + 384), *(void *)(a1 + 400) + 1056, 0x10u);
  sub_1B65A8ED4(*(void *)(a1 + 384), *(void *)(a1 + 400) + 2080, 0x10u);
  if (sub_1B6447FD4(*(void *)(a1 + 368)) && *(unsigned char *)(*(void *)(a1 + 384) + 132))
  {
    unint64_t v6 = 0;
    do
    {
      float32x2_t v7 = sub_1B6447FE4(*(float32x2_t **)(a1 + 368), 0, v4, v5);
      float32x2_t v10 = sub_1B6447FE4(*(float32x2_t **)(a1 + 368), (const char *)1, v8, v9);
      uint64_t v11 = 0;
      uint64_t v12 = (int8x16_t *)(*(void *)(a1 + 400) + (v6 << 6));
      int8x16_t v13 = v12[132];
      *(float32x2_t *)v14.i8 = vadd_f32(vsub_f32(v10, v7), *(float32x2_t *)v13.i8);
      v14.i64[1] = vextq_s8(v13, v13, 8uLL).u64[0];
      v12[132] = v14;
      uint64_t v15 = *(void *)(a1 + 400);
      uint64_t v16 = (float32x4_t *)(v15 + (v6 << 6));
      float32x4_t v17 = v16[130];
      float32x4_t v18 = v16[131];
      float32x4_t v19 = v16[132];
      float32x4_t v20 = v16[133];
      float32x4_t v21 = v16[67];
      float32x4_t v22 = v16[68];
      float32x4_t v23 = v16[69];
      v28[0] = v16[66];
      v28[1] = v21;
      v28[2] = v22;
      v28[3] = v23;
      do
      {
        v29[v11] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(v28[v11])), v18, *(float32x2_t *)&v28[v11], 1), v19, (float32x4_t)v28[v11], 2), v20, (float32x4_t)v28[v11], 3);
        ++v11;
      }
      while (v11 != 4);
      long long v24 = v29[1];
      long long v25 = v29[2];
      long long v26 = v29[3];
      uint64_t v27 = (_OWORD *)(v15 + (v6 << 6));
      void v27[2] = v29[0];
      v27[3] = v24;
      _OWORD v27[4] = v25;
      v27[5] = v26;
      ++v6;
    }
    while (v6 < *(unsigned __int8 *)(*(void *)(a1 + 384) + 132));
  }
}

uint64_t sub_1B6520810(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B644558C(a2[1], (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  unint64_t v11 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v10) ^ ((0x9DDFEA08EB382D69 * v10) >> 47));
  unint64_t v13 = 0x9DDFEA08EB382D69 * (v11 ^ (v11 >> 47));
  return sub_1B652087C(a1, a2, (uint64_t *)&v13);
}

uint64_t sub_1B652087C(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6520A5C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B65208D8(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6520910(uint64_t result)
{
  *(unsigned char *)(result + 8) = 0;
  *(void *)__n64 result = &unk_1F0FB3110;
  *(void *)(result + 16) = 0;
  for (uint64_t i = 1056; i != 2080; i += 64)
  {
    uint64_t v2 = (_OWORD *)(result + i);
    *(_OWORD *)(result + i - 1024) = xmmword_1B6E4F300;
    *(_OWORD *)(result + i - 1008) = xmmword_1B6E4F320;
    *(_OWORD *)(result + i - 992) = xmmword_1B6E4F2E0;
    *(_OWORD *)(result + i - 976) = xmmword_1B6E4F370;
    *uint64_t v2 = xmmword_1B6E4F300;
    v2[1] = xmmword_1B6E4F320;
    v2[2] = xmmword_1B6E4F2E0;
    v2[3] = xmmword_1B6E4F370;
    v2[64] = xmmword_1B6E4F300;
    v2[65] = xmmword_1B6E4F320;
    v2[66] = xmmword_1B6E4F2E0;
    v2[67] = xmmword_1B6E4F370;
  }
  return result;
}

void *sub_1B65209A4(void *a1)
{
  *a1 = &unk_1F0FB3110;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1B65209F0(void *a1)
{
  *a1 = &unk_1F0FB3110;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6520A5C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x198u, 8u);
  return sub_1B6520164(v8, *a3, a3[1], a4, *a5);
}

uint64_t sub_1B6520ABC(uint64_t a1, float a2)
{
  float v3 = (1.0 - a2) * 6.28318531;
  __float2 v10 = __sincosf_stret(v3);
  uint64_t v11 = 0;
  v12.i32[3] = 0;
  v12.i64[0] = LODWORD(v10.__cosval);
  v13.i64[0] = LODWORD(v10.__sinval);
  v13.i64[1] = LODWORD(v10.__cosval);
  long long v24 = xmmword_1B6E4F300;
  long long v25 = xmmword_1B6E4F320;
  long long v26 = xmmword_1B6E509F0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  do
  {
    v12.f32[2] = -v10.__sinval;
    *(long long *)((char *)&v19 + v11) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(*(long long *)((char *)&v24 + v11))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v24 + v11), 1), v13, *(float32x4_t *)((char *)&v24 + v11), 2);
    v11 += 16;
  }
  while (v11 != 48);
  uint64_t v14 = 0;
  v23[0] = v19;
  v23[1] = v20;
  void v23[2] = v21;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  do
  {
    *(long long *)((char *)&v24 + v14 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E51EC0, COERCE_FLOAT(v23[v14])), (float32x4_t)xmmword_1B6E51ED0, *(float32x2_t *)&v23[v14], 1), (float32x4_t)xmmword_1B6E4F2E0, (float32x4_t)v23[v14], 2);
    ++v14;
  }
  while (v14 != 3);
  long long v15 = v24;
  long long v16 = v25;
  long long v17 = v26;
  HIDWORD(v15) = 0;
  HIDWORD(v16) = 0;
  HIDWORD(v17) = 0;
  long long v19 = v15;
  long long v20 = v16;
  long long v21 = v17;
  long long v22 = xmmword_1B6E4F370;
  return sub_1B63DD3C4(a1, (float *)&v19, *(void *)&v4, *(void *)&v5, *(void *)&v6, *(void *)&v7, *(void *)&v8, *(void *)&v9);
}

void sub_1B6520C1C(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  BOOL v11 = a5 < 0.0;
  float v12 = -1.0;
  if (!v11) {
    float v12 = 1.0;
  }
  if (a2 == 3)
  {
    float v18 = (1.0 - a8 + (float)((float)(a4 * a8) / a3)) * 0.5;
    double v19 = v18;
    __double2 v20 = __sincos_stret(a9 * 6.28318531);
    float v21 = v19 * v20.__cosval + 0.5;
    *a1 = v21;
    float v17 = v19 * v20.__sinval + 0.5;
    uint64_t v22 = 1;
  }
  else
  {
    if (a2 == 1)
    {
      *a1 = 0.0;
      a1[1] = v12;
      float v17 = 0.0;
    }
    else
    {
      if (a2) {
        return;
      }
      float v13 = (float)(a4 * a8) + (1.0 - a8) * a3;
      double v14 = (float)(v12 * v13);
      __double2 v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v16 = v15.__sinval * v14;
      *a1 = v16;
      a1[1] = a5;
      float v17 = v15.__cosval * v13;
    }
    uint64_t v22 = 2;
  }
  a1[v22] = v17;
}

void sub_1B6520D44(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  double v11 = 1.0 - a8;
  if (a2 == 3)
  {
    *a1 = a9;
    uint64_t v18 = 1;
  }
  else
  {
    float v12 = (a5 + -0.5) * a8 + (a4 + -0.5) * v11;
    if (a2 == 1)
    {
      __double2 v19 = __sincos_stret(v12 * 3.14159265);
      __double2 v20 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v21 = v20.__sinval * v19.__cosval;
      float sinval = v19.__sinval;
      *a1 = v21;
      a1[1] = sinval;
      double v11 = v20.__cosval * v19.__cosval;
    }
    else
    {
      if (a2) {
        return;
      }
      double v13 = a3;
      __double2 v14 = __sincos_stret(v12 * 3.14159265);
      __double2 v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v16 = v15.__sinval * (v14.__cosval * v13);
      float v17 = v14.__sinval * v13;
      *a1 = v16;
      a1[1] = v17;
      double v11 = v15.__cosval * (v14.__cosval * v13);
    }
    uint64_t v18 = 2;
  }
  float v23 = v11;
  a1[v18] = v23;
}

void sub_1B6520E6C(float *a1, int a2, float a3, float a4, double a5, double a6, double a7, float a8, float a9)
{
  BOOL v12 = a4 <= 0.0;
  float v13 = 3.1416;
  if (v12) {
    float v13 = 0.0;
  }
  if (a2 == 3)
  {
    if (a4 <= 0.0)
    {
      *a1 = 1.0 - a9;
      a1[1] = a8;
    }
    else
    {
      *a1 = a9;
      a1[1] = 1.0 - a8;
    }
  }
  else
  {
    if (a2 == 1)
    {
      __double2 v19 = __sincos_stret(v13 + a9 * 6.28318531);
      float sinval = v19.__sinval;
      *a1 = sinval;
      a1[1] = 0.0;
      float cosval = v19.__cosval;
    }
    else
    {
      if (a2) {
        return;
      }
      double v14 = a3;
      __double2 v15 = __sincos_stret(v13 + a9 * 6.28318531);
      float v16 = v15.__sinval * v14;
      float v17 = (a8 + -0.5) * a4;
      *a1 = v16;
      a1[1] = v17;
      float cosval = v15.__cosval * v14;
    }
    a1[2] = cosval;
  }
}

void sub_1B6520F68(float *a1, int a2, float a3, float a4, float a5, double a6, double a7, float a8, float a9)
{
  if (a2 == 3)
  {
    *a1 = a9;
    a1[1] = 1.0 - a8;
  }
  else
  {
    if (a2 == 1)
    {
      __double2 v19 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float sinval = v19.__sinval;
      float v21 = (float)(a4 - a3) / a5;
      float cosval = v19.__cosval;
      float v23 = sqrtf((float)((float)(v21 * v21) + (float)(sinval * sinval)) + (float)(cosval * cosval));
      *a1 = sinval / v23;
      a1[1] = v21 / v23;
      float v18 = cosval / v23;
    }
    else
    {
      if (a2) {
        return;
      }
      double v13 = a8;
      double v14 = (float)(a3 * a8) + (1.0 - a8) * a4;
      __double2 v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v16 = v14 * v15.__sinval;
      float v17 = (v13 + -0.5) * a5;
      *a1 = v16;
      a1[1] = v17;
      float v18 = v14 * v15.__cosval;
    }
    a1[2] = v18;
  }
}

void sub_1B652107C(float *a1, int a2, float a3, float a4, double a5, double a6, double a7, float a8, float a9)
{
  if (a2 == 3)
  {
    *a1 = a9;
    float v19 = 1.0 - a8;
    uint64_t v20 = 1;
  }
  else
  {
    if (a2 == 1)
    {
      __double2 v21 = __sincos_stret((a8 + -0.5) * 6.28318531);
      __double2 v22 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v23 = v21.__cosval * v22.__sinval;
      float sinval = v21.__sinval;
      *a1 = v23;
      a1[1] = sinval;
      double v18 = v21.__cosval * v22.__cosval;
    }
    else
    {
      if (a2) {
        return;
      }
      double v11 = a3;
      double v12 = a4;
      __double2 v13 = __sincos_stret((a8 + -0.5) * 6.28318531);
      double v14 = v11 + v12 * v13.__cosval;
      __double2 v15 = __sincos_stret(a9 * 6.28318531 + 3.14159265);
      float v16 = v15.__sinval * v14;
      float v17 = v13.__sinval * v12;
      *a1 = v16;
      a1[1] = v17;
      double v18 = v15.__cosval * v14;
    }
    float v19 = v18;
    uint64_t v20 = 2;
  }
  a1[v20] = v19;
}

void sub_1B6521194(float *a1, int a2, int a3, float a4, float a5, double a6, double a7, double a8, float a9, float a10)
{
  if (a2 == 3)
  {
    *a1 = a10;
    double v22 = (float)(a4 / a5);
    double v23 = 1.0 - v22;
    double v24 = 1.0 - a9;
    double v25 = (float)((float)(a4 / a5) * a9) + (1.0 - v22) * v24;
    uint64_t v26 = 1;
    double v27 = v24 * v22;
    double v28 = v24 + a9 * v23;
    if (!a3) {
      double v27 = v28;
    }
    if (a3 == 1) {
      double v27 = v25;
    }
    else {
      uint64_t v26 = 1;
    }
    goto LABEL_24;
  }
  if (a2 != 1)
  {
    if (a2) {
      return;
    }
    if (a3 == 2)
    {
      double v30 = a4;
      __double2 v31 = __sincos_stret(a9 * 1.57079633);
      __double2 v32 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
      float v33 = v31.__cosval * v30 * v32.__sinval;
      float v34 = a5 * 0.5 + v30 * v31.__sinval - v30;
      *a1 = v33;
      a1[1] = v34;
      double v27 = v31.__cosval * v30 * v32.__cosval;
    }
    else
    {
      if (a3 == 1)
      {
        double v17 = a4;
        __double2 v35 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
        double cosval = v35.__cosval;
        float v20 = v35.__sinval * v17;
        double v21 = (a9 + -0.5) * (float)(a5 + (float)(a4 * -2.0));
      }
      else
      {
        if (a3) {
          return;
        }
        double v15 = a4;
        __double2 v16 = __sincos_stret((a9 + -1.0) * 1.57079633);
        double v17 = v16.__cosval * v15;
        __double2 v19 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
        double cosval = v19.__cosval;
        float v20 = v19.__sinval * (v16.__cosval * v15);
        double v21 = a5 * -0.5 + v15 * v16.__sinval + v15;
      }
      float v36 = v21;
      *a1 = v20;
      a1[1] = v36;
      double v27 = cosval * v17;
    }
    goto LABEL_23;
  }
  if (a3 == 2)
  {
    double v29 = a9;
  }
  else
  {
    if (a3 == 1)
    {
      __double2 v41 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
      double v27 = v41.__cosval;
      float sinval = v41.__sinval;
      *a1 = sinval;
      a1[1] = 0.0;
      goto LABEL_23;
    }
    if (a3) {
      return;
    }
    double v29 = a9 + -1.0;
  }
  __double2 v37 = __sincos_stret(v29 * 1.57079633);
  __double2 v38 = __sincos_stret(a10 * 6.28318531 + 3.14159265);
  float v39 = v37.__cosval * v38.__sinval;
  float v40 = v37.__sinval;
  *a1 = v39;
  a1[1] = v40;
  double v27 = v37.__cosval * v38.__cosval;
LABEL_23:
  uint64_t v26 = 2;
LABEL_24:
  float v43 = v27;
  a1[v26] = v43;
}

void sub_1B6521424(uint64_t a1, int a2, float a3, float32x4_t a4, float a5, float a6, float a7, float a8, float a9)
{
  _S21 = a3;
  float32x2_t v12 = vcvt_f32_s32((int32x2_t)(*(void *)&vceqz_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32((int)a7), (int8x8_t)0x200000001)) | 0x100000001));
  if (((int)a7 & 4) != 0) {
    int v13 = 1;
  }
  else {
    int v13 = -1;
  }
  float v14 = (float)v13;
  if (a9 != 0.0)
  {
    if (a8 != 0.0)
    {
      float v29 = _S21 / 1.41421356;
      float v30 = _S21 / 1.73205081;
      float v31 = v29 * v12.f32[0];
      float v32 = v29 * v14;
      float32x2_t v33 = vmul_n_f32(v12, v30);
      float v34 = vmuls_lane_f32(v29, v12, 1);
      double v35 = 1.0 - a8;
      double v36 = 1.0 - a9;
      v37.i32[0] = 0;
      v37.f32[1] = v34;
      float32x4_t v38 = (float32x4_t)vcvtq_f64_f32(vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v37, a8)), (float64x2_t)0, v35)));
      *(float32x2_t *)v38.f32 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v33, a8)), (float64x2_t)COERCE_UNSIGNED_INT64(v31), v35)), a9)), (float64x2_t)v38, v36));
      float v39 = (float)(v32 * a8) + v35 * (float)(v14 * _S21);
      float v40 = (float)((float)(v30 * v14) * a8) + v35 * v32;
      float32_t v41 = (float)(v40 * a9) + v36 * v39;
      v38.f32[2] = v41;
      int32x4_t v42 = (int32x4_t)vmulq_f32(v38, v38);
      v42.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v42, 2), vadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v42.i8, 1))).u32[0];
      float32x2_t v43 = vrsqrte_f32((float32x2_t)v42.u32[0]);
      float32x2_t v44 = vmul_f32(v43, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v43, v43)));
      _Q0 = vmulq_n_f32(v38, vmul_f32(v44, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v44, v44))).f32[0]);
      if (!a2)
      {
        a4.f32[1] = a5;
        *(float32x2_t *)a4.f32 = vmla_n_f32(*(float32x2_t *)a4.f32, *(float32x2_t *)_Q0.f32, _S21);
        __asm { FMLA            S3, S21, V0.S[2] }
        a4.i32[2] = _S3;
        _Q0 = a4;
      }
      *(void *)a1 = _Q0.i64[0];
      float v51 = _Q0.f32[2];
      goto LABEL_20;
    }
    if (a2 != 1)
    {
      if (a2) {
        return;
      }
      double v20 = a4.f32[0];
      double v21 = (float)(_S21 * v12.f32[0]);
      float v56 = a6;
      float v57 = _S21;
      __double2 v22 = __sincos_stret(a9 * 0.785398163);
      double cosval = v22.__cosval;
      float v23 = v20 + v21 * v22.__sinval;
      *(float *)a1 = v23;
      *(float *)(a1 + 4) = a5;
      goto LABEL_12;
    }
    double v52 = v12.f32[0];
    __double2 v53 = __sincos_stret(a9 * 0.785398163);
    double v26 = v53.__cosval;
    float v54 = v53.__sinval * v52;
    *(float *)a1 = v54;
    *(_DWORD *)(a1 + 4) = 0;
LABEL_18:
    double v24 = v26 * v14;
    goto LABEL_19;
  }
  if (a2 == 1)
  {
    *(_DWORD *)a1 = 0;
    double v25 = v12.f32[1];
    __double2 v27 = __sincos_stret(a8 * 0.785398163);
    double v26 = v27.__cosval;
    float v28 = v27.__sinval * v25;
    *(float *)(a1 + 4) = v28;
    goto LABEL_18;
  }
  if (a2) {
    return;
  }
  *(_DWORD *)a1 = a4.i32[0];
  double v15 = a5;
  double v16 = vmuls_lane_f32(_S21, v12, 1);
  float v56 = a6;
  float v57 = _S21;
  __double2 v18 = __sincos_stret(a8 * 0.785398163);
  double cosval = v18.__cosval;
  float v19 = v15 + v16 * v18.__sinval;
  *(float *)(a1 + 4) = v19;
LABEL_12:
  double v24 = v56 + (float)(v14 * v57) * cosval;
LABEL_19:
  float v51 = v24;
LABEL_20:
  *(float *)(a1 + 8) = v51;
}

void sub_1B65216E0(float *a1, int a2, int a3, int a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, double a12)
{
  *(float *)&a12 = a8;
  float v16 = a6;
  if (a9 >= 4.0)
  {
    float32x4_t v27 = (float32x4_t)xmmword_1B6E4F300;
    if (a9 == 4.0)
    {
      float32x4_t v91 = (float32x4_t)xmmword_1B6E512A0;
      float32x4_t v31 = (float32x4_t)xmmword_1B6E51290;
      float32x4_t v29 = (float32x4_t)xmmword_1B6E51280;
      float32x4_t v92 = (float32x4_t)xmmword_1B6E4F300;
      float32x4_t v30 = (float32x4_t)xmmword_1B6E51270;
    }
    else
    {
      float32x4_t v91 = (float32x4_t)xmmword_1B6E51280;
      float32x4_t v31 = (float32x4_t)xmmword_1B6E51270;
      float32x4_t v29 = (float32x4_t)xmmword_1B6E512A0;
      float32x4_t v92 = (float32x4_t)xmmword_1B6E4F300;
      float32x4_t v30 = (float32x4_t)xmmword_1B6E51290;
    }
  }
  else
  {
    double v20 = a9;
    float v21 = a9 * 1.57079633;
    float v82 = a5;
    double v87 = a12;
    float v78 = a7;
    __float2 v22 = __sincosf_stret(v21);
    v23.i32[3] = 0;
    v23.i64[0] = LODWORD(v22.__cosval);
    v23.f32[2] = -v22.__sinval;
    v24.i64[0] = LODWORD(v22.__sinval);
    v24.i64[1] = LODWORD(v22.__cosval);
    float32x4_t v91 = v24;
    float32x4_t v92 = v23;
    float v25 = v20 * -1.57079633;
    __float2 v26 = __sincosf_stret(v25);
    a7 = v78;
    float v16 = a6;
    v27.i32[3] = 0;
    v27.i64[0] = LODWORD(v26.__cosval);
    v27.f32[2] = -v26.__sinval;
    a5 = v82;
    a12 = v87;
    v28.i64[0] = LODWORD(v26.__sinval);
    v28.i64[1] = LODWORD(v26.__cosval);
    float32x4_t v29 = v28;
    float32x4_t v30 = (float32x4_t)xmmword_1B6E4F320;
    float32x4_t v31 = (float32x4_t)xmmword_1B6E4F320;
  }
  float32x4_t v33 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v29, a7), v30, v16), v27, a5);
  float v32 = fabsf(v33.f32[0]);
  *(float32x2_t *)v33.f32 = vabs_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 4uLL));
  if (a2 == 3)
  {
    float v39 = *(float *)&a12 / v32;
    if (a4)
    {
      if (a4 != 2)
      {
        if (a4 != 1) {
          goto LABEL_40;
        }
        float v40 = v39 * a11;
LABEL_39:
        *a1 = v40;
LABEL_40:
        float v52 = 1.0 - a10;
        float v53 = *(float *)&a12 / v33.f32[0];
        if (a3)
        {
          if (a3 != 1)
          {
            float v55 = v52 * v53;
            goto LABEL_46;
          }
          double v54 = v52 + (1.0 - v53) * (1.0 - v52);
        }
        else
        {
          double v54 = (1.0 - v53) * v52 + (1.0 - v52) * v53;
        }
        float v55 = v54;
LABEL_46:
        a1[1] = v55;
        return;
      }
      double v51 = a11;
      double v49 = 1.0 - a11;
      double v50 = 1.0 - v39;
    }
    else
    {
      double v49 = 1.0 - a11;
      double v50 = v39;
      double v51 = (1.0 - v50) * a11;
    }
    float v40 = v51 + v49 * v50;
    goto LABEL_39;
  }
  float v34 = v32 * 0.5;
  float32x2_t v35 = vmul_f32(*(float32x2_t *)v33.f32, (float32x2_t)0x3F0000003F000000);
  if (a2 != 1)
  {
    if (a2) {
      return;
    }
    float v36 = v33.f32[0] + (float)(*(float *)&a12 * -2.0);
    if (a4 != 2)
    {
      if (a4 != 1)
      {
        if (!a4)
        {
          float v37 = (a11 + -0.5) * (float)(v32 + (float)(*(float *)&a12 * -2.0));
          *a1 = v37;
          if (a3 != 2)
          {
            if (a3 != 1)
            {
              if (!a3)
              {
                float v38 = (a10 + -0.5) * v36;
                a1[1] = v38;
                a1[2] = v35.f32[1];
              }
              goto LABEL_70;
            }
            double v69 = (float)(*(float *)&a12 - v35.f32[0]);
            double v70 = *(float *)&a12;
            float32x4_t v85 = v31;
            float v90 = *(float *)&a12;
            float v81 = v35.f32[1];
            __double2 v71 = __sincos_stret(a10 * 0.785398163 + -0.785398163);
            float32x4_t v31 = v85;
            float v72 = v69 + v70 * v71.__sinval;
            double v73 = (float)(v81 - v90) + v70 * v71.__cosval;
            goto LABEL_69;
          }
          float32x2_t v67 = vsub_f32(v35, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a12, 0));
          double v89 = *(float *)&a12;
          float32x4_t v84 = v31;
          __double2 v68 = __sincos_stret(a10 * 0.785398163);
          float32x4_t v31 = v84;
          float32x2_t v41 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(v67), (float64x2_t)v68, v89));
          goto LABEL_64;
        }
        goto LABEL_70;
      }
      float32x4_t v83 = v31;
      if (a3 != 2)
      {
        if (a3 != 1)
        {
          if (a3) {
            goto LABEL_70;
          }
          double v42 = (float)(*(float *)&a12 - v34);
          double v43 = *(float *)&a12;
          double v44 = a11 * 0.785398163 + -0.785398163;
LABEL_35:
          float v88 = *(float *)&a12;
          float v80 = v35.f32[1];
          __double2 v45 = __sincos_stret(v44);
          float v46 = v42 + v43 * v45.__sinval;
          float v47 = (a10 + -0.5) * v36;
          *a1 = v46;
          a1[1] = v47;
          float32x4_t v31 = v83;
          float cosval = (float)(v80 - v88) + v43 * v45.__cosval;
LABEL_56:
          a1[2] = cosval;
          goto LABEL_70;
        }
        goto LABEL_61;
      }
      goto LABEL_60;
    }
    float32x4_t v83 = v31;
    if (a3 != 2)
    {
      if (a3 != 1)
      {
        if (a3) {
          goto LABEL_70;
        }
        double v42 = (float)(v34 - *(float *)&a12);
        double v43 = *(float *)&a12;
        double v44 = a11 * 0.785398163;
        goto LABEL_35;
      }
      goto LABEL_58;
    }
LABEL_57:
    v33.f32[0] = v34 - *(float *)&a12;
    float v59 = v35.f32[0] - *(float *)&a12;
    float v60 = v35.f32[1] - *(float *)&a12;
    float v61 = 7.0;
    uint64_t v62 = (uint64_t)a1;
    int v63 = a2;
    float v64 = *(float *)&a12;
    float v65 = a10;
LABEL_59:
    float v66 = a11;
LABEL_62:
    sub_1B6521424(v62, v63, v64, v33, v59, v60, v61, v65, v66);
    float32x4_t v31 = v83;
    goto LABEL_70;
  }
  if (a4 == 2)
  {
    float32x4_t v83 = v31;
    if (a3 == 2) {
      goto LABEL_57;
    }
    if (a3 == 1)
    {
LABEL_58:
      v33.f32[0] = v34 - *(float *)&a12;
      float v59 = *(float *)&a12 - v35.f32[0];
      float v60 = v35.f32[1] - *(float *)&a12;
      float v65 = 1.0 - a10;
      float v61 = 5.0;
      uint64_t v62 = (uint64_t)a1;
      int v63 = a2;
      float v64 = *(float *)&a12;
      goto LABEL_59;
    }
    if (a3) {
      goto LABEL_70;
    }
    double v56 = a11 * 0.785398163;
LABEL_55:
    __double2 v57 = __sincos_stret(v56);
    float32x4_t v31 = v83;
    float sinval = v57.__sinval;
    *a1 = sinval;
    a1[1] = 0.0;
    float cosval = v57.__cosval;
    goto LABEL_56;
  }
  if (a4 == 1)
  {
    float32x4_t v83 = v31;
    if (a3 == 2)
    {
LABEL_60:
      v33.f32[0] = *(float *)&a12 - v34;
      float v59 = v35.f32[0] - *(float *)&a12;
      float v60 = v35.f32[1] - *(float *)&a12;
      float v66 = 1.0 - a11;
      float v61 = 6.0;
      uint64_t v62 = (uint64_t)a1;
      int v63 = a2;
      float v64 = *(float *)&a12;
      float v65 = a10;
      goto LABEL_62;
    }
    if (a3 == 1)
    {
LABEL_61:
      v33.f32[0] = *(float *)&a12 - v34;
      float v59 = *(float *)&a12 - v35.f32[0];
      float v60 = v35.f32[1] - *(float *)&a12;
      float v65 = 1.0 - a10;
      float v66 = 1.0 - a11;
      float v61 = 4.0;
      uint64_t v62 = (uint64_t)a1;
      int v63 = a2;
      float v64 = *(float *)&a12;
      goto LABEL_62;
    }
    if (a3) {
      goto LABEL_70;
    }
    double v56 = a11 * 0.785398163 + -0.785398163;
    goto LABEL_55;
  }
  if (a4) {
    goto LABEL_70;
  }
  *a1 = 0.0;
  switch(a3)
  {
    case 2:
      double v74 = a10 * 0.785398163;
LABEL_68:
      float32x4_t v86 = v31;
      __double2 v75 = __sincos_stret(v74);
      double v73 = v75.__cosval;
      float32x4_t v31 = v86;
      float v72 = v75.__sinval;
LABEL_69:
      float v76 = v73;
      a1[1] = v72;
      a1[2] = v76;
      break;
    case 1:
      double v74 = a10 * 0.785398163 + -0.785398163;
      goto LABEL_68;
    case 0:
      float32x2_t v41 = (float32x2_t)0x3F80000000000000;
LABEL_64:
      *(float32x2_t *)(a1 + 1) = v41;
      break;
  }
LABEL_70:
  float32x4_t v77 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v91, a1[2]), v31, a1[1]), v92, *a1);
  *(void *)a1 = v77.i64[0];
  a1[2] = v77.f32[2];
}

void sub_1B6521CF0(float *a1, int a2, float a3, float a4, float a5, float a6, double a7, float a8, float a9)
{
  double v13 = a6;
  float v14 = a6 * 1.57079633;
  __float2 v15 = __sincosf_stret(v14);
  float v16 = v13 * -1.57079633;
  __float2 v17 = __sincosf_stret(v16);
  v18.i32[3] = 0;
  v18.i64[0] = LODWORD(v17.__cosval);
  v18.f32[2] = -v17.__sinval;
  v19.i64[0] = LODWORD(v17.__sinval);
  v19.i64[1] = LODWORD(v17.__cosval);
  float32x4_t v20 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v19, a5), (float32x4_t)xmmword_1B6E4F320, a4), v18, a3);
  float v21 = fabsf(v20.f32[1]);
  float v22 = fabsf(v20.f32[2]);
  if (a2)
  {
    if (a2 == 1)
    {
      v20.f32[0] = v22 * 0.5;
      float v27 = sqrtf((float)(v20.f32[1] * v20.f32[1]) + (float)(v20.f32[0] * v20.f32[0]));
      float v25 = v20.f32[0] / v27;
      float v26 = v21 / v27;
      float v24 = 0.0;
    }
    else
    {
      if (a2 == 3)
      {
        *a1 = a9;
        a1[1] = 1.0 - a8;
        return;
      }
      float v24 = *a1;
      float v25 = a1[1];
      float v26 = a1[2];
    }
  }
  else
  {
    double v23 = 1.0 - a8;
    float v24 = (a9 + -0.5) * (v23 * fabsf(v20.f32[0]));
    float v25 = v21 * a8;
    float v26 = v23 * (v22 * 0.5);
  }
  v28.i32[3] = 0;
  v28.i64[0] = LODWORD(v15.__cosval);
  v28.f32[2] = -v15.__sinval;
  v29.i64[0] = LODWORD(v15.__sinval);
  v29.i64[1] = LODWORD(v15.__cosval);
  float32x4_t v30 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v29, v26), (float32x4_t)xmmword_1B6E4F320, v25), v28, v24);
  *(void *)a1 = v30.i64[0];
  a1[2] = v30.f32[2];
}

uint64_t sub_1B6521E90(void (*a1)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float), unsigned int a2, int *a3, int a4, int a5, int a6, int *a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  if (!sub_1B63D0BFC(a2)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v24, v25, v26, v27, v28, v29, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  values[0] = (void *)sub_1B6522774(a1, 0, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  values[1] = (void *)sub_1B6522774(a1, 1, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  values[2] = (void *)sub_1B6522774(a1, 3, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14);
  CFTypeRef cf = 0;
  if (!sub_1B63D0BFC(a2)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v30, v31, v32, v33, v34, v35, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v133 = (a4 - 1);
  uint64_t v37 = 0;
  if (a4 >= 1)
  {
    float v38 = a3;
    uint64_t v39 = a4;
    do
    {
      uint64_t v40 = *v38++;
      v37 += v40 + 1;
      --v39;
    }
    while (v39);
  }
  CFDataRef v41 = Mutable;
  if (a8 < 1)
  {
    int v47 = 0;
    uint64_t v48 = 2;
    goto LABEL_116;
  }
  uint64_t v42 = 0;
  uint64_t v43 = a8;
  double v44 = a7;
  uint64_t v113 = a8;
  do
  {
    uint64_t v45 = *v44++;
    v42 += v45 + 1;
    --v43;
  }
  while (v43);
  int v131 = a5;
  int v120 = v37;
  if (v42 * v37 >= 0x10000)
  {
    uint64_t v69 = 0;
    int v47 = 0;
    int v115 = 0;
    uint64_t v48 = 4;
    while (1)
    {
      int v70 = a7[v69];
      if (v70 < 1) {
        goto LABEL_115;
      }
      uint64_t v71 = 0;
      int v124 = v37 * v115;
      int v126 = v37 + v37 * v115;
      uint64_t v117 = v69;
      do
      {
        if (a4 < 1) {
          goto LABEL_114;
        }
        uint64_t v72 = 0;
        int v73 = 0;
        uint64_t v119 = v71;
        uint64_t v128 = v71 | v69;
        do
        {
          int v74 = a3[v72];
          int v130 = v73;
          if (v74 >= 1)
          {
            int v75 = 0;
            if (a6) {
              BOOL v76 = v72 == v133;
            }
            else {
              BOOL v76 = 0;
            }
            int v77 = v76;
            int v78 = v126 + v73;
            int v79 = v124 + v73;
            do
            {
              *(_DWORD *)uint64_t v140 = v79 + v75;
              *(_DWORD *)&v140[4] = v78 + v75 + 1;
              int v80 = v75 + 1;
              *(_DWORD *)&v140[8] = v79 + v75 + 1;
              v141[0] = v79 + v75;
              v141[1] = v78 + v75;
              v141[2] = *(_DWORD *)&v140[4];
              if (!a5 || v75 | v72)
              {
                if (v80 == v74) {
                  int v83 = v77;
                }
                else {
                  int v83 = 0;
                }
                if (v83 == 1)
                {
                  switch(a2)
                  {
                    case 3u:
                      *(_DWORD *)uint64_t v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v78 + v75 + 1;
                      goto LABEL_103;
                    case 2u:
                      *(_DWORD *)uint64_t v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v78 + v75;
                      int v138 = v78 + v75;
                      int v139 = v78 + v75 + 1;
LABEL_99:
                      float32x4_t v85 = v137;
                      float32x4_t v86 = v41;
                      CFIndex v87 = 16;
LABEL_104:
                      CFDataAppendBytes(v86, v85, v87);
                      CFDictionaryRef Mutable = v41;
                      v47 += 2;
                      break;
                    case 0u:
                      float v82 = v41;
                      float v81 = (UInt8 *)v141;
                      goto LABEL_90;
                  }
                }
                else
                {
                  switch(a2)
                  {
                    case 3u:
LABEL_96:
                      *(_DWORD *)uint64_t v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v79 + v75 + 1;
LABEL_103:
                      float32x4_t v85 = v137;
                      float32x4_t v86 = v41;
                      CFIndex v87 = 8;
                      goto LABEL_104;
                    case 2u:
                      *(_DWORD *)uint64_t v137 = v79 + v75;
                      *(_DWORD *)&v137[4] = v78 + v75;
                      int v138 = v78 + v75;
                      int v139 = v78 + v75 + 1;
                      float v88 = Mutable;
                      CFDataAppendBytes(Mutable, v137, 16);
                      if (v128)
                      {
                        v47 += 2;
                      }
                      else
                      {
                        *(_DWORD *)uint64_t v137 = *(_DWORD *)v140;
                        *(_DWORD *)&v137[4] = *(_DWORD *)&v140[8];
                        CFDataAppendBytes(v88, v137, 8);
                        v47 += 3;
                      }
                      a5 = v131;
                      if (v72 != v133 || v75 != a3[v72] - 1)
                      {
                        CFDictionaryRef Mutable = v41;
                        break;
                      }
                      *(void *)uint64_t v137 = *(void *)&v140[4];
                      float v81 = v137;
                      float v82 = v41;
                      CFIndex v84 = 8;
                      goto LABEL_91;
                    case 0u:
                      float32x4_t v85 = v140;
                      float32x4_t v86 = v41;
                      CFIndex v87 = 24;
                      goto LABEL_104;
                  }
                }
              }
              else
              {
                switch(a2)
                {
                  case 3u:
                    goto LABEL_96;
                  case 2u:
                    *(_DWORD *)uint64_t v137 = v79 + v75;
                    *(_DWORD *)&v137[4] = v78 + v75 + 1;
                    int v138 = v79 + v75;
                    int v139 = v79 + v75 + 1;
                    goto LABEL_99;
                  case 0u:
                    float v81 = v140;
                    float v82 = v41;
LABEL_90:
                    CFIndex v84 = 12;
LABEL_91:
                    CFDataAppendBytes(v82, v81, v84);
                    CFDictionaryRef Mutable = v41;
                    ++v47;
                    break;
                }
              }
              int v74 = a3[v72];
              ++v75;
            }
            while (v80 < v74);
          }
          int v73 = v130 + v74 + 1;
          ++v72;
        }
        while (v72 != a4);
        LODWORD(v37) = v120;
        uint64_t v69 = v117;
        uint64_t v71 = v119;
        int v70 = a7[v117];
        uint64_t v48 = 4;
LABEL_114:
        ++v71;
        v126 += v37;
        v124 += v37;
      }
      while (v71 < v70);
LABEL_115:
      v115 += v70 + 1;
      if (++v69 == v113) {
        goto LABEL_116;
      }
    }
  }
  uint64_t v46 = 0;
  int v47 = 0;
  __int16 v116 = 0;
  uint64_t v48 = 2;
  do
  {
    int v49 = a7[v46];
    if (v49 < 1) {
      goto LABEL_60;
    }
    int v50 = 0;
    uint64_t v114 = v46;
    do
    {
      int v51 = v50 + 1;
      if (a4 < 1) {
        goto LABEL_59;
      }
      uint64_t v52 = 0;
      int v53 = 0;
      BOOL v54 = v46 == 0;
      int v118 = v50 + 1;
      __int16 v123 = (v116 + v51) * v37;
      __int16 v125 = (v116 + v50) * v37;
      if ((_WORD)v50) {
        BOOL v54 = 0;
      }
      BOOL v127 = v54;
      do
      {
        int v55 = a3[v52];
        int v129 = v53;
        if (v55 >= 1)
        {
          int v56 = 0;
          int v57 = 0;
          __int16 v58 = v53 + v125;
          __int16 v59 = v53 + v123;
          do
          {
            *(_WORD *)uint64_t v140 = v57 + v58;
            int v60 = v57 + 1;
            *(_WORD *)&v140[2] = v57 + 1 + v59;
            *(_WORD *)&v140[4] = v57 + 1 + v58;
            *(_WORD *)&v140[6] = v57 + v58;
            *(_WORD *)&v140[8] = v57 + v59;
            *(_WORD *)&v140[10] = *(_WORD *)&v140[2];
            int v61 = (__int16)(v57 + 1);
            if (v52 || (_WORD)v57 || !a5)
            {
              if (v52 == v133 && a6 && v55 == v61)
              {
                switch(a2)
                {
                  case 3u:
                    *(_WORD *)uint64_t v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + 1 + v59;
                    goto LABEL_46;
                  case 2u:
                    *(_WORD *)uint64_t v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + v59;
                    *(_WORD *)&v137[4] = v57 + v59;
                    *(_WORD *)&v137[6] = v57 + 1 + v59;
LABEL_44:
                    float v65 = v137;
                    float v66 = v41;
                    CFIndex v67 = 8;
LABEL_47:
                    CFDataAppendBytes(v66, v65, v67);
                    CFDictionaryRef Mutable = v41;
                    v47 += 2;
                    break;
                  case 0u:
                    int v63 = v41;
                    uint64_t v62 = &v140[6];
                    goto LABEL_35;
                }
              }
              else
              {
                switch(a2)
                {
                  case 3u:
LABEL_41:
                    *(_WORD *)uint64_t v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + 1 + v58;
LABEL_46:
                    float v65 = v137;
                    float v66 = v41;
                    CFIndex v67 = 4;
                    goto LABEL_47;
                  case 2u:
                    *(_WORD *)uint64_t v137 = v57 + v58;
                    *(_WORD *)&v137[2] = v57 + v59;
                    *(_WORD *)&v137[4] = v57 + v59;
                    *(_WORD *)&v137[6] = v57 + 1 + v59;
                    __double2 v68 = Mutable;
                    CFDataAppendBytes(Mutable, v137, 8);
                    if (v127)
                    {
                      *(_WORD *)uint64_t v137 = *(_WORD *)v140;
                      *(_WORD *)&v137[2] = *(_WORD *)&v140[4];
                      CFDataAppendBytes(v68, v137, 4);
                      v47 += 3;
                    }
                    else
                    {
                      v47 += 2;
                    }
                    a5 = v131;
                    if (v52 != v133 || a3[v52] - 1 != v56)
                    {
                      CFDictionaryRef Mutable = v41;
                      break;
                    }
                    *(_DWORD *)uint64_t v137 = *(_DWORD *)&v140[2];
                    uint64_t v62 = v137;
                    int v63 = v41;
                    CFIndex v64 = 4;
                    goto LABEL_36;
                  case 0u:
                    float v65 = v140;
                    float v66 = v41;
                    CFIndex v67 = 12;
                    goto LABEL_47;
                }
              }
            }
            else
            {
              switch(a2)
              {
                case 3u:
                  goto LABEL_41;
                case 2u:
                  *(_WORD *)uint64_t v137 = v57 + v58;
                  *(_WORD *)&v137[2] = v57 + 1 + v59;
                  *(_WORD *)&v137[4] = v57 + v58;
                  *(_WORD *)&v137[6] = v57 + 1 + v58;
                  goto LABEL_44;
                case 0u:
                  uint64_t v62 = v140;
                  int v63 = v41;
LABEL_35:
                  CFIndex v64 = 6;
LABEL_36:
                  CFDataAppendBytes(v63, v62, v64);
                  CFDictionaryRef Mutable = v41;
                  ++v47;
                  break;
              }
            }
            int v55 = a3[v52];
            int v56 = v61;
            int v57 = v60;
          }
          while (v55 > (__int16)v60);
        }
        int v53 = v129 + v55 + 1;
        ++v52;
      }
      while (v52 != a4);
      LOWORD(v37) = v120;
      uint64_t v46 = v114;
      int v49 = a7[v114];
      uint64_t v48 = 2;
      int v51 = v118;
LABEL_59:
      int v50 = v51;
    }
    while (v49 > (__int16)v51);
LABEL_60:
    v116 += v49 + 1;
    ++v46;
  }
  while (v46 != v113);
LABEL_116:
  double v89 = (const void *)sub_1B63D0314();
  sub_1B63D0D7C((uint64_t)v89, 0, v90, v91, v92, v93, v94, v95);
  CFDataRef Copy = CFDataCreateCopy(allocator, v41);
  sub_1B63D05D4((uint64_t)v89, a2, v47, Copy, v48, v97, v98, v99);
  CFRelease(Copy);
  CFRelease(v41);
  CFTypeRef cf = v89;
  v140[2] = 0;
  *(_WORD *)uint64_t v140 = 0;
  uint64_t v100 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef v101 = CFArrayCreate(allocator, (const void **)values, 3, MEMORY[0x1E4F1D510]);
  CFArrayRef v102 = CFArrayCreate(allocator, &cf, 1, v100);
  uint64_t v108 = sub_1B63DC55C(v101, v102, (uint64_t)v140, v103, v104, v105, v106, v107);
  CFRelease(v101);
  CFRelease(v102);
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  for (uint64_t i = 0; i != 3; ++i)
  {
    int v110 = values[i];
    if (v110)
    {
      CFRelease(v110);
      values[i] = 0;
    }
  }
  return v108;
}

uint64_t sub_1B6522774(void (*a1)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float), uint64_t a2, int *a3, int a4, int *a5, int a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a4;
  int v24 = a4;
  if (a4 >= 1)
  {
    uint64_t v25 = a4;
    uint64_t v26 = a3;
    int v24 = a4;
    do
    {
      int v27 = *v26++;
      v24 += v27;
      --v25;
    }
    while (v25);
  }
  uint64_t v51 = a6;
  int v28 = a6;
  if (a6 >= 1)
  {
    uint64_t v29 = a6;
    uint64_t v30 = a5;
    int v28 = a6;
    do
    {
      int v31 = *v30++;
      v28 += v31;
      --v29;
    }
    while (v29);
  }
  if (a2 == 3) {
    uint64_t v32 = 2;
  }
  else {
    uint64_t v32 = 3;
  }
  int v49 = v28 * v24;
  uint64_t v50 = v32;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4 * v28 * v24 * (int)v32);
  if (a6 >= 1)
  {
    uint64_t v34 = 0;
    do
    {
      int v35 = a5[v34];
      if ((v35 & 0x80000000) == 0)
      {
        int v36 = 0;
        do
        {
          if (a4 >= 1)
          {
            uint64_t v37 = 0;
            int v53 = v36;
            float v38 = (float)v36 * a12;
            do
            {
              int v39 = a3[v37];
              if ((v39 & 0x80000000) == 0)
              {
                int v40 = -1;
                do
                {
                  a1(bytes, a2, v37, v34, a7, a8, a9, a10, a11, (float)((float)++v40 / (float)v39) + 0.0, (float)(v38 / (float)a5[v34]) + 0.0);
                  CFDataAppendBytes(Mutable, bytes, (4 * v50));
                  int v39 = a3[v37];
                }
                while (v40 < v39);
              }
              ++v37;
            }
            while (v37 != v23);
            int v35 = a5[v34];
            int v36 = v53;
          }
        }
        while (v36++ < v35);
      }
      ++v34;
    }
    while (v34 != v51);
  }
  CFDataRef Copy = CFDataCreateCopy(allocator, Mutable);
  uint64_t v46 = sub_1B641CF98(Copy, a2, v49, v50, 1, v43, v44, v45);
  CFRelease(Mutable);
  CFRelease(Copy);
  return v46;
}

uint64_t sub_1B65229E8(unsigned int a1, int a2, float a3, float a4, float a5, float a6)
{
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  int v19 = a2;
  int v20 = 1;
  return sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6520C1C, a1, &v20, 1, 0, a4 == 0.0, &v19, 1, a3, a4, a5, 0.0, 0.0, a6);
}

uint64_t sub_1B6522AAC(unsigned int a1, uint64_t a2, int a3, float a4, float a5)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v10, v11, v12, v13, v14, v15, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  if (a4 <= 0.0) {
    return 0;
  }
  if (a3 != 1)
  {
    int v57 = a2;
    if (a5 == 1.0)
    {
      float v18 = 0.0;
      if (a3 == 2) {
        float v18 = 0.5;
      }
      return sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6520D44, a1, &v57, 1, a3 != 2, 1, &v57, 1, a4, v18, 1.0, 0.0, 0.0, 1.0);
    }
    else
    {
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      float v19 = 0.0;
      if (a3 == 2)
      {
        float v19 = 0.5;
        float v20 = 0.25;
      }
      else
      {
        float v20 = 0.5;
      }
      values = (void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6520D44, a1, &v57, 1, a3 != 2, 1, &v57, 1, a4, v19, 1.0, 0.0, 0.0, a5);
      uint64_t v21 = sub_1B65229E8(a1, a2, a4, 0.0, 0.0, v20);
      int v28 = (const void *)v21;
      uint64_t v29 = 0;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v58 = xmmword_1B6E4F300;
      long long v59 = xmmword_1B6E51290;
      long long v60 = xmmword_1B6E512A0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      do
      {
        *(long long *)((char *)&v61 + v29) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E51EE0, COERCE_FLOAT(*(long long *)((char *)&v58 + v29))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v58 + v29), 1), (float32x4_t)xmmword_1B6E51EF0, *(float32x4_t *)((char *)&v58 + v29), 2);
        v29 += 16;
      }
      while (v29 != 48);
      uint64_t v30 = 0;
      long long v58 = v61;
      long long v59 = v62;
      long long v60 = v63;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      do
      {
        *(long long *)((char *)&v61 + v30) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v58 + v30))), (float32x4_t)xmmword_1B6E50A20, *(float32x2_t *)((char *)&v58 + v30), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v58 + v30), 2);
        v30 += 16;
      }
      while (v30 != 48);
      long long v31 = v61;
      long long v32 = v62;
      long long v33 = v63;
      HIDWORD(v31) = 0;
      HIDWORD(v32) = 0;
      HIDWORD(v33) = 0;
      long long v53 = v31;
      long long v54 = v32;
      long long v55 = v33;
      long long v56 = xmmword_1B6E4F370;
      uint64_t v34 = sub_1B63DD3C4(v21, (float *)&v53, v22, v23, v24, v25, v26, v27);
      uint64_t v65 = v34;
      if (v28) {
        CFRelease(v28);
      }
      float v35 = (1.0 - a5) * 6.28318531;
      __float2 v42 = __sincosf_stret(v35);
      uint64_t v43 = 0;
      v44.i32[3] = 0;
      v44.i64[0] = LODWORD(v42.__cosval);
      v45.i64[0] = LODWORD(v42.__sinval);
      v45.i64[1] = LODWORD(v42.__cosval);
      long long v58 = xmmword_1B6E4F300;
      long long v59 = xmmword_1B6E4F320;
      long long v60 = xmmword_1B6E509F0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      do
      {
        v44.f32[2] = -v42.__sinval;
        *(long long *)((char *)&v61 + v43) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v44, COERCE_FLOAT(*(long long *)((char *)&v58 + v43))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v58 + v43), 1), v45, *(float32x4_t *)((char *)&v58 + v43), 2);
        v43 += 16;
      }
      while (v43 != 48);
      uint64_t v46 = 0;
      long long v58 = v61;
      long long v59 = v62;
      long long v60 = v63;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      do
      {
        *(long long *)((char *)&v61 + v46) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E51EC0, COERCE_FLOAT(*(long long *)((char *)&v58 + v46))), (float32x4_t)xmmword_1B6E51ED0, *(float32x2_t *)((char *)&v58 + v46), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v58 + v46), 2);
        v46 += 16;
      }
      while (v46 != 48);
      long long v47 = v61;
      long long v48 = v62;
      long long v49 = v63;
      HIDWORD(v47) = 0;
      HIDWORD(v48) = 0;
      HIDWORD(v49) = 0;
      long long v53 = v47;
      long long v54 = v48;
      long long v55 = v49;
      long long v56 = xmmword_1B6E4F370;
      uint64_t v66 = sub_1B63DD3C4(v34, (float *)&v53, *(void *)&v36, *(void *)&v37, *(void *)&v38, *(void *)&v39, *(void *)&v40, *(void *)&v41);
      CFArrayRef v50 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 3, MEMORY[0x1E4F1D510]);
      uint64_t v17 = sub_1B63DC648(v50);
      CFRelease(v50);
      for (uint64_t i = 0; i != 24; i += 8)
      {
        uint64_t v52 = *(void **)((char *)&values + i);
        if (v52)
        {
          CFRelease(v52);
          *(void **)((char *)&values + i) = 0;
        }
      }
    }
    return v17;
  }

  return sub_1B63F41C8(a1, a2, a4);
}

uint64_t sub_1B6522F4C(unsigned int a1, int a2, uint64_t a3, float a4, float a5, float a6)
{
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  if (a4 <= 0.0) {
    return 0;
  }
  int v63 = a3;
  int v62 = a2;
  float v18 = (const void **)malloc_type_calloc(5uLL, 8uLL, 0x2004093837F09uLL);
  if (a5 <= 0.0)
  {
    unsigned int v19 = 0;
  }
  else
  {
    unsigned int v19 = 1;
    *float v18 = (const void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6520E6C, a1, &v63, 1, 0, 0, &v62, 1, a4, a5, 0.0, 0.0, 0.0, a6);
  }
  unsigned int v21 = v19 + 1;
  v18[v19] = (const void *)sub_1B65229E8(a1, a2, a4, 0.0, a5 * 0.5, a6);
  if (a5 > 0.0)
  {
    uint64_t v22 = (const void *)sub_1B65229E8(a1, a2, a4, 0.0, a5 * -0.5, a6);
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    float v23 = a6 * 6.28318531;
    __float2 v30 = __sincosf_stret(v23);
    uint64_t v31 = 0;
    v32.i32[3] = 0;
    v32.i64[0] = LODWORD(v30.__cosval);
    v33.i64[0] = LODWORD(v30.__sinval);
    v33.i64[1] = LODWORD(v30.__cosval);
    long long v64 = xmmword_1B6E4F300;
    long long v65 = xmmword_1B6E4F320;
    long long v66 = xmmword_1B6E509F0;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    do
    {
      v32.f32[2] = -v30.__sinval;
      *(long long *)((char *)&v67 + v31) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v32, COERCE_FLOAT(*(long long *)((char *)&v64 + v31))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v64 + v31), 1), v33, *(float32x4_t *)((char *)&v64 + v31), 2);
      v31 += 16;
    }
    while (v31 != 48);
    uint64_t v34 = 0;
    long long v64 = v67;
    long long v65 = v68;
    long long v66 = v69;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    do
    {
      *(long long *)((char *)&v67 + v34) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v64 + v34))), (float32x4_t)xmmword_1B6E50A20, *(float32x2_t *)((char *)&v64 + v34), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v64 + v34), 2);
      v34 += 16;
    }
    while (v34 != 48);
    long long v35 = v67;
    long long v36 = v68;
    long long v37 = v69;
    HIDWORD(v35) = 0;
    HIDWORD(v36) = 0;
    HIDWORD(v37) = 0;
    long long v58 = v35;
    long long v59 = v36;
    long long v60 = v37;
    long long v61 = xmmword_1B6E4F370;
    uint64_t v38 = v19 | 2;
    v18[v21] = (const void *)sub_1B63DD3C4((uint64_t)v22, (float *)&v58, *(void *)&v24, *(void *)&v25, *(void *)&v26, *(void *)&v27, *(void *)&v28, *(void *)&v29);
    if (v22) {
      CFRelease(v22);
    }
    if (a6 >= 1.0)
    {
      unsigned int v21 = v19 | 2;
    }
    else
    {
      uint64_t v39 = sub_1B6549D0C(a1, 1, a3, 0, a4, a5, 0.0);
      uint64_t v46 = (const void *)v39;
      uint64_t v47 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v64 = xmmword_1B6E4F300;
      long long v65 = xmmword_1B6E4F320;
      long long v66 = xmmword_1B6E509F0;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      do
      {
        *(long long *)((char *)&v67 + v47) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E50250, COERCE_FLOAT(*(long long *)((char *)&v64 + v47))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v64 + v47), 1), (float32x4_t)xmmword_1B6E50260, *(float32x4_t *)((char *)&v64 + v47), 2);
        v47 += 16;
      }
      while (v47 != 48);
      uint64_t v48 = 0;
      long long v64 = v67;
      long long v65 = v68;
      long long v66 = v69;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      do
      {
        *(long long *)((char *)&v67 + v48) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v64 + v48))), (float32x4_t)xmmword_1B6E50A20, *(float32x2_t *)((char *)&v64 + v48), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v64 + v48), 2);
        v48 += 16;
      }
      while (v48 != 48);
      long long v49 = v67;
      long long v50 = v68;
      long long v51 = v69;
      HIDWORD(v49) = 0;
      HIDWORD(v50) = 0;
      HIDWORD(v51) = 0;
      *(void *)&long long v52 = 0;
      *((float *)&v52 + 2) = a4 * -0.5;
      HIDWORD(v52) = 1.0;
      long long v58 = v49;
      long long v59 = v50;
      long long v60 = v51;
      long long v61 = v52;
      uint64_t v53 = sub_1B63DD3C4(v39, (float *)&v58, v40, v41, v42, v43, v44, v45);
      v18[v38] = (const void *)v53;
      if (v46)
      {
        CFRelease(v46);
        uint64_t v53 = (uint64_t)v18[v38];
      }
      unsigned int v21 = v19 | 4;
      v18[v19 + 3] = (const void *)sub_1B6520ABC(v53, a6);
    }
  }
  CFArrayRef v54 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v18, v21, MEMORY[0x1E4F1D510]);
  uint64_t v20 = sub_1B63DC648(v54);
  CFRelease(v54);
  uint64_t v55 = 0;
  do
  {
    long long v56 = v18[v55];
    if (v56)
    {
      CFRelease(v56);
      v18[v55] = 0;
    }
    ++v55;
  }
  while (v21 != v55);
  free(v18);
  return v20;
}

uint64_t sub_1B65233C8(unsigned int a1, int a2, int a3, float a4, float a5, float a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  uint64_t v18 = 0;
  if (a4 >= 0.0 && a5 >= 0.0)
  {
    uint64_t v18 = 0;
    BOOL v19 = a5 == 0.0 && a4 == 0.0;
    if (!v19 && a6 > 0.0)
    {
      int v30 = a2;
      int v31 = a3;
      if (a4 <= 0.0) {
        uint64_t v20 = 0;
      }
      else {
        uint64_t v20 = sub_1B65229E8(a1, a2, a4, 0.0, a6 * 0.5, 1.0);
      }
      if (a5 <= 0.0) {
        uint64_t v21 = 0;
      }
      else {
        uint64_t v21 = sub_1B65229E8(a1, a2, a5, 0.0, a6 * -0.5, 1.0);
      }
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      values = (void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6520F68, a1, &v31, 1, v21 == 0, v20 == 0, &v30, 1, a4, a5, a6, 0.0, 0.0, 1.0);
      if (v20 && v21)
      {
        uint64_t v33 = v20;
        uint64_t v22 = 3;
        CFIndex v23 = 2;
      }
      else
      {
        CFIndex v23 = 1;
        uint64_t v24 = v20 | v21;
        if (v20) {
          uint64_t v21 = v20;
        }
        if (!v24) {
          goto LABEL_24;
        }
        uint64_t v22 = 2;
      }
      *(&values + v23) = (void *)v21;
      CFIndex v23 = v22;
LABEL_24:
      CFArrayRef v25 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, v23, MEMORY[0x1E4F1D510]);
      uint64_t v18 = sub_1B63DC648(v25);
      CFRelease(v25);
      uint64_t v26 = 0;
      uint64_t v27 = 8 * v23;
      do
      {
        __float2 v28 = *(void **)((char *)&values + v26);
        if (v28)
        {
          CFRelease(v28);
          *(void **)((char *)&values + v26) = 0;
        }
        v26 += 8;
      }
      while (v27 != v26);
    }
  }
  return v18;
}

uint64_t sub_1B65235F8(unsigned int a1, int a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v14, v15, v16, v17, v18, v19, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  uint64_t v20 = 0;
  if (a4 > a5) {
    a4 = a5;
  }
  if (a5 > 0.0 && a4 >= 0.0)
  {
    uint64_t v21 = (const void **)malloc_type_calloc(6uLL, 8uLL, 0x2004093837F09uLL);
    if (a6 <= 0.0)
    {
      uint64_t v22 = 0;
    }
    else
    {
      LODWORD(v58) = a2;
      LODWORD(v65) = a3;
      *uint64_t v21 = (const void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6520E6C, a1, (int *)&v65, 1, 0, 0, (int *)&v58, 1, a5, a6, 0.0, 0.0, 0.0, a7);
      v21[1] = (const void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6520E6C, a1, (int *)&v65, 1, 0, 0, (int *)&v58, 1, -a4, -a6, 0.0, 0.0, 0.0, a7);
      uint64_t v22 = 2;
    }
    CFIndex v23 = v22 | 1;
    v21[v22] = (const void *)sub_1B65229E8(a1, a2, a5, a4, a6 * 0.5, a7);
    if (a6 > 0.0)
    {
      uint64_t v24 = (const void *)sub_1B65229E8(a1, a2, a5, a4, a6 * -0.5, a7);
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      float v25 = a7 * 6.28318531;
      __float2 v32 = __sincosf_stret(v25);
      uint64_t v33 = 0;
      v34.i32[3] = 0;
      v34.i64[0] = LODWORD(v32.__cosval);
      v35.i64[0] = LODWORD(v32.__sinval);
      v35.i64[1] = LODWORD(v32.__cosval);
      long long v62 = xmmword_1B6E4F300;
      long long v63 = xmmword_1B6E4F320;
      long long v64 = xmmword_1B6E509F0;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      do
      {
        v34.f32[2] = -v32.__sinval;
        *(long long *)((char *)&v65 + v33) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(*(long long *)((char *)&v62 + v33))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v62 + v33), 1), v35, *(float32x4_t *)((char *)&v62 + v33), 2);
        v33 += 16;
      }
      while (v33 != 48);
      uint64_t v36 = 0;
      long long v62 = v65;
      long long v63 = v66;
      long long v64 = v67;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      do
      {
        *(long long *)((char *)&v65 + v36) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v62 + v36))), (float32x4_t)xmmword_1B6E50A20, *(float32x2_t *)((char *)&v62 + v36), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v62 + v36), 2);
        v36 += 16;
      }
      while (v36 != 48);
      long long v37 = v65;
      long long v38 = v66;
      long long v39 = v67;
      HIDWORD(v37) = 0;
      HIDWORD(v38) = 0;
      HIDWORD(v39) = 0;
      long long v58 = v37;
      long long v59 = v38;
      long long v60 = v39;
      long long v61 = xmmword_1B6E4F370;
      v21[v23] = (const void *)sub_1B63DD3C4((uint64_t)v24, (float *)&v58, *(void *)&v26, *(void *)&v27, *(void *)&v28, *(void *)&v29, *(void *)&v30, *(void *)&v31);
      if (v24) {
        CFRelease(v24);
      }
      if (a7 >= 1.0)
      {
        CFIndex v23 = v22 + 2;
      }
      else
      {
        uint64_t v40 = sub_1B6549D0C(a1, 1, a3, 0, a5 - a4, a6, 0.0);
        uint64_t v47 = 0;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v62 = xmmword_1B6E4F300;
        long long v63 = xmmword_1B6E4F320;
        long long v64 = xmmword_1B6E509F0;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        do
        {
          *(long long *)((char *)&v65 + v47) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E50250, COERCE_FLOAT(*(long long *)((char *)&v62 + v47))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v62 + v47), 1), (float32x4_t)xmmword_1B6E50260, *(float32x4_t *)((char *)&v62 + v47), 2);
          v47 += 16;
        }
        while (v47 != 48);
        uint64_t v48 = 0;
        long long v62 = v65;
        long long v63 = v66;
        long long v64 = v67;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        do
        {
          *(long long *)((char *)&v65 + v48) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v62 + v48))), (float32x4_t)xmmword_1B6E50A20, *(float32x2_t *)((char *)&v62 + v48), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v62 + v48), 2);
          v48 += 16;
        }
        while (v48 != 48);
        long long v49 = v65;
        long long v50 = v66;
        HIDWORD(v49) = 0;
        HIDWORD(v50) = 0;
        long long v51 = v67;
        HIDWORD(v51) = 0;
        *(void *)&long long v52 = 0;
        *((float *)&v52 + 2) = (float)(a4 + a5) * -0.5;
        HIDWORD(v52) = 1.0;
        long long v58 = v49;
        long long v59 = v50;
        long long v60 = v51;
        long long v61 = v52;
        uint64_t v53 = sub_1B63DD3C4(v40, (float *)&v58, v41, v42, v43, v44, v45, v46);
        v21[v22 + 2] = (const void *)v53;
        CFIndex v23 = v22 | 4;
        v21[v22 + 3] = (const void *)sub_1B6520ABC(v53, a7);
      }
    }
    CFArrayRef v54 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v21, v23, MEMORY[0x1E4F1D510]);
    uint64_t v20 = sub_1B63DC648(v54);
    CFRelease(v54);
    uint64_t v55 = 0;
    do
    {
      long long v56 = v21[v55];
      if (v56)
      {
        CFRelease(v56);
        v21[v55] = 0;
      }
      ++v55;
    }
    while (v23 != v55);
    free(v21);
  }
  return v20;
}

uint64_t sub_1B6523AC4(unsigned int a1, int a2, int a3, int a4, float a5, float a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  uint64_t result = 0;
  if (a5 > 0.0 && a6 > 0.0)
  {
    float v19 = a6 * 0.5;
    v21[0] = a4;
    v21[1] = a3;
    if ((float)(a6 * 0.5) > a5) {
      float v19 = a5;
    }
    void v21[2] = a4;
    int v20 = a2;
    return sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6521194, a1, v21, 3, 1, 1, &v20, 1, v19, a6, 0.0, 0.0, 0.0, 1.0);
  }
  return result;
}

uint64_t sub_1B6523BD4(unsigned int a1, int a2, int a3, float a4, float a5, float a6)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v12, v13, v14, v15, v16, v17, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  uint64_t v18 = 0;
  if (a4 > 0.0 && a5 > 0.0)
  {
    int v40 = a2;
    int v41 = a3;
    if (a6 == 1.0)
    {
      return sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B652107C, a1, &v41, 1, 0, 0, &v40, 1, a4, a5, 0.0, 0.0, 0.0, 1.0);
    }
    else
    {
      uint64_t v49 = 0;
      uint64_t v50 = 0;
      values = (void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B652107C, a1, &v41, 1, 0, 0, &v40, 1, a4, a5, 0.0, 0.0, 0.0, a6);
      uint64_t v19 = sub_1B65229E8(a1, a3, a5, 0.0, 0.0, 1.0);
      uint64_t v26 = 0;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v42 = xmmword_1B6E4F300;
      long long v43 = xmmword_1B6E4F320;
      long long v44 = xmmword_1B6E509F0;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      do
      {
        *(long long *)((char *)&v45 + v26) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E51F00, COERCE_FLOAT(*(long long *)((char *)&v42 + v26))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v42 + v26), 1), (float32x4_t)xmmword_1B6E51F10, *(float32x4_t *)((char *)&v42 + v26), 2);
        v26 += 16;
      }
      while (v26 != 48);
      uint64_t v27 = 0;
      long long v42 = v45;
      long long v43 = v46;
      long long v44 = v47;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      do
      {
        *(long long *)((char *)&v45 + v27) = (__int128)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E51F20, COERCE_FLOAT(*(long long *)((char *)&v42 + v27))), (float32x4_t)xmmword_1B6E51F30, *(float32x2_t *)((char *)&v42 + v27), 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v42 + v27), 2);
        v27 += 16;
      }
      while (v27 != 48);
      long long v28 = v45;
      long long v29 = v46;
      HIDWORD(v28) = 0;
      long long v30 = v47;
      HIDWORD(v29) = 0;
      HIDWORD(v30) = 0;
      *(void *)&long long v31 = 0;
      *((float *)&v31 + 2) = -a4;
      HIDWORD(v31) = 1.0;
      long long v36 = v28;
      long long v37 = v29;
      long long v38 = v30;
      long long v39 = v31;
      uint64_t v49 = sub_1B63DD3C4(v19, (float *)&v36, v20, v21, v22, v23, v24, v25);
      uint64_t v50 = sub_1B6520ABC(v49, a6);
      CFArrayRef v32 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 3, MEMORY[0x1E4F1D510]);
      uint64_t v18 = sub_1B63DC648(v32);
      CFRelease(v32);
      for (uint64_t i = 0; i != 24; i += 8)
      {
        float32x4_t v34 = *(void **)((char *)&values + i);
        if (v34)
        {
          CFRelease(v34);
          *(void **)((char *)&values + i) = 0;
        }
      }
    }
  }
  return v18;
}

uint64_t sub_1B6523ED8(unsigned int a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6, float a7, float a8, float a9, float a10)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v20, v21, v22, v23, v24, v25, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  if (a7 < 0.0 || a8 < 0.0) {
    return 0;
  }
  uint64_t v26 = 0;
  if (a9 >= 0.0 && a10 >= 0.0)
  {
    uint64_t v28 = 0;
    double v29 = a9;
    double v30 = a7 * 0.5;
    if (v30 >= a8 * 0.5) {
      double v30 = a8 * 0.5;
    }
    if (v30 >= v29 * 0.5) {
      double v30 = v29 * 0.5;
    }
    if (v30 <= a10)
    {
      float v31 = v30;
      a10 = v31;
    }
    if (a5 >= 0) {
      unint64_t v32 = a5;
    }
    else {
      unint64_t v32 = a5 + 1;
    }
    unint64_t v33 = v32 >> 1;
    if ((unint64_t)(a5 + 1) < 3) {
      LODWORD(v33) = 1;
    }
    v83[1] = v33;
    v83[2] = v33;
    v82[1] = v33;
    v82[2] = v33;
    *(_OWORD *)values = 0u;
    long long v79 = 0u;
    if (a10 == 0.0) {
      int v34 = 1;
    }
    else {
      int v34 = 3;
    }
    v83[0] = a3;
    do
    {
      if ((v28 & 0x7FFFFFFD) != 0) {
        int v35 = a4;
      }
      else {
        int v35 = a2;
      }
      v82[0] = v35;
      values[v28] = (void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B65216E0, a1, v83, v34, 0, 0, v82, v34, a7, a8, a9, a10, (float)(int)v28, 1.0);
      ++v28;
    }
    while (v28 != 4);
    v83[0] = a4;
    v82[0] = a2;
    uint64_t v80 = sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B65216E0, a1, v83, v34, 0, 0, v82, v34, a7, a8, a9, a10, 4.0, 1.0);
    uint64_t v81 = sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B65216E0, a1, v83, v34, 0, 0, v82, v34, a7, a8, a9, a10, 5.0, 1.0);
    CFArrayRef v36 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 6, MEMORY[0x1E4F1D510]);
    uint64_t v26 = sub_1B63DC648(v36);
    CFRelease(v36);
    if (a6)
    {
      uint64_t v75 = v26;
      CFArrayRef theArray = (const __CFArray *)sub_1B64AD3C4(v26, 0, v37, v38, v39, v40, v41, v42);
      long long v43 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      CFDictionaryRef Mutable = CFArrayCreateMutable(0, 6, MEMORY[0x1E4F1D510]);
      long long v45 = CFArrayCreateMutable(0, 6, v43);
      uint64_t v46 = 0;
      unint64_t v47 = 0;
      int v48 = 0;
      char v49 = 4;
      uint64_t v50 = 1;
      do
      {
        if (((1 << ((a6 >> (4 * v47)) & 0xF)) & v48) != 0)
        {
          ++v46;
        }
        else
        {
          int v76 = v48;
          CFArrayRemoveAllValues(Mutable);
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v47);
          CFArrayAppendValue(Mutable, ValueAtIndex);
          if (v47 <= 4)
          {
            char v52 = v49;
            CFIndex v53 = v50;
            do
            {
              if (((a6 >> (4 * v47)) & 0xF) == ((a6 >> v52) & 0xF))
              {
                CFArrayRef v54 = CFArrayGetValueAtIndex(theArray, v53);
                CFArrayAppendValue(Mutable, v54);
              }
              ++v53;
              v52 += 4;
            }
            while (v53 != 6);
          }
          if (CFArrayGetCount(Mutable) < 2)
          {
            long long v63 = CFArrayGetValueAtIndex(Mutable, 0);
            uint64_t v62 = (uint64_t)CFRetain(v63);
          }
          else
          {
            uint64_t v62 = sub_1B63D08E4(Mutable, v55, v56, v57, v58, v59, v60, v61);
          }
          long long v64 = (const void *)v62;
          if (v46 >= 1)
          {
            do
            {
              long long v65 = (const void *)sub_1B63D03C4();
              CFArrayAppendValue(v45, v65);
              --v46;
            }
            while (v46);
          }
          if (!v64)
          {
            CFRelease(v45);
            CFRelease(Mutable);
            uint64_t v26 = v75;
            goto LABEL_49;
          }
          int v48 = v76 | (1 << ((a6 >> (4 * v47)) & 0xF));
          CFArrayAppendValue(v45, v64);
          CFRelease(v64);
          uint64_t v46 = 0;
        }
        ++v50;
        v49 += 4;
      }
      while (v47++ < 5);
      CFRelease(Mutable);
      uint64_t v26 = v75;
      if (v45)
      {
        sub_1B64AD458(v75, v45, v67, v68, v69, v70, v71, v72);
        CFRelease(v45);
      }
    }
LABEL_49:
    for (uint64_t i = 0; i != 6; ++i)
    {
      int v74 = values[i];
      if (v74)
      {
        CFRelease(v74);
        values[i] = 0;
      }
    }
  }
  return v26;
}

uint64_t sub_1B6524370(unsigned int a1, uint64_t a2, int a3, uint64_t a4, float a5, float a6, float a7)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (!sub_1B63D0BFC(a1)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh type has to define a topology", v14, v15, v16, v17, v18, v19, (uint64_t)"CFXMeshElementTypeDefinesTopology(meshType)");
  }
  uint64_t v20 = 0;
  *(_OWORD *)values = 0u;
  long long v37 = 0u;
  do
  {
    LODWORD(v34[0]) = a3;
    if (v20) {
      int v21 = a4;
    }
    else {
      int v21 = a2;
    }
    int v35 = v21;
    values[v20] = (void *)sub_1B6521E90((void (*)(UInt8 *, uint64_t, uint64_t, uint64_t, float, float, float, float, float, float, float))sub_1B6521CF0, a1, (int *)v34, 1, 0, 1, &v35, 1, a5, a6, a7, (float)(int)v20, 0.0, 1.0);
    ++v20;
  }
  while (v20 != 4);
  uint64_t v22 = (const void *)sub_1B6549D0C(a1, a2, a4, 0, a5, a7, 0.0);
  v34[0] = xmmword_1B6E4F300;
  v34[1] = xmmword_1B6E51270;
  void v34[2] = xmmword_1B6E51280;
  v34[3] = xmmword_1B6E4F370;
  uint64_t v38 = sub_1B63DD3C4((uint64_t)v22, (float *)v34, v23, v24, v25, v26, v27, v28);
  if (v22) {
    CFRelease(v22);
  }
  CFArrayRef v29 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 5, MEMORY[0x1E4F1D510]);
  uint64_t v30 = sub_1B63DC648(v29);
  CFRelease(v29);
  for (uint64_t i = 0; i != 5; ++i)
  {
    unint64_t v32 = values[i];
    if (v32)
    {
      CFRelease(v32);
      values[i] = 0;
    }
  }
  return v30;
}

uint64_t sub_1B6524558(uint64_t result)
{
  if (*(void *)(result + 104))
  {
    uint64_t v1 = result;
    free(*(void **)(result + 96));
    *(void *)(v1 + 96) = malloc_type_malloc(4 * *(void *)(v1 + 104), 0x100004052888210uLL);
    uint64_t result = sub_1B63F4F54((void *)v1, v2, v3, v4, v5, v6, v7, v8);
    if (*(uint64_t *)(v1 + 104) >= 1)
    {
      uint64_t v9 = result;
      CFIndex v10 = 0;
      do
      {
        uint64_t result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 88), v10);
        if (result
          && (uint64_t v18 = result, result = sub_1B63F4F54((void *)result, v11, v12, v13, v14, v15, v16, v17), result == v9))
        {
          int v19 = *(_DWORD *)(v18 + 88);
        }
        else
        {
          int v19 = -1;
        }
        CFIndex v20 = *(void *)(v1 + 104);
        *(_DWORD *)(*(void *)(v1 + 96) + 4 * v10++) = v19;
      }
      while (v10 < v20);
    }
  }
  return result;
}

uint64_t sub_1B652460C()
{
  if (qword_1EB995680 != -1) {
    dispatch_once(&qword_1EB995680, &unk_1F0FB5BE8);
  }
  return qword_1EB995688;
}

double sub_1B6524650()
{
  if (!qword_1EB995688)
  {
    qword_1EB995688 = sub_1B63C8D10(&qword_1EB995688);
    double result = *(double *)&xmmword_1F0FB8AD0;
    unk_1EB984BB0 = xmmword_1F0FB8AD0;
    qword_1EB984B98 = (uint64_t)sub_1B6525FD0;
    unk_1EB984BC0 = *(_OWORD *)&off_1F0FB8AE0;
    qword_1EB984BD0 = qword_1F0FB8AF0;
    unk_1EB984BD8 = sub_1B652666C;
  }
  return result;
}

double sub_1B65246D0()
{
  if (qword_1EB995680 != -1) {
    dispatch_once(&qword_1EB995680, &unk_1F0FB5BE8);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995688, 0xB0uLL);
  *(unsigned char *)(v0 + 176) = 1;
  double result = 0.0;
  *(_OWORD *)(v0 + 144) = xmmword_1B6E4F370;
  *(_OWORD *)(v0 + 160) = xmmword_1B6E51230;
  return result;
}

uint64_t sub_1B6524738(void *a1)
{
  sub_1B65246D0();
  uint64_t v3 = v2;
  sub_1B652476C(v2, a1, v4, v5, v6, v7, v8, v9);
  return v3;
}

double sub_1B652476C(uint64_t a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)(a1 + 72);
  if (v9 != cf)
  {
    if (v9)
    {
      sub_1B63F4AAC(v9, *(void *)(a1 + 48), a3, a4, a5, a6, a7, a8);
      uint64_t v11 = *(const void **)(a1 + 72);
      if (v11) {
        CFRelease(v11);
      }
    }
    *(void *)(a1 + 72) = cf;
    if (cf)
    {
      CFRetain(cf);
      sub_1B63F4CCC((uint64_t *)cf, *(void *)(a1 + 48), v12, v13, v14, v15, v16, v17);
    }
    *(unsigned char *)(a1 + 176) = 1;
    double result = 0.0;
    *(_OWORD *)(a1 + 144) = xmmword_1B6E4F370;
    *(_OWORD *)(a1 + 160) = xmmword_1B6E51230;
  }
  return result;
}

CFTypeRef *sub_1B65247EC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  sub_1B65246D0();
  uint64_t v4 = (CFTypeRef *)v3;
  sub_1B652476C(v3, v2, v5, v6, v7, v8, v9, v10);
  sub_1B6524868((uint64_t)v4, *(void **)(a1 + 80), v11, v12, v13, v14, v15, v16);
  CFArrayRef Copy = CFArrayCreateCopy(0, *(CFArrayRef *)(a1 + 88));
  sub_1B65248F4((uint64_t)v4, Copy);
  CFRelease(Copy);
  sub_1B6583A28(a1, v4, v18, v19, v20, v21, v22, v23);
  return v4;
}

double sub_1B6524868(uint64_t a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = cf;
  if (!cf)
  {
    CFArrayRef v10 = *(const __CFArray **)(a1 + 88);
    if (v10) {
      uint64_t v8 = sub_1B64A3430(v10, 0, a3, a4, a5, a6, a7, a8);
    }
    else {
      uint64_t v8 = 0;
    }
  }
  uint64_t v11 = *(void **)(a1 + 80);
  if (v11 != v8)
  {
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 80) = 0;
    }
    if (v8) {
      CFTypeRef v12 = CFRetain(v8);
    }
    else {
      CFTypeRef v12 = 0;
    }
    *(void *)(a1 + 80) = v12;
  }
  *(unsigned char *)(a1 + 176) = 1;
  double result = 0.0;
  *(_OWORD *)(a1 + 144) = xmmword_1B6E4F370;
  *(_OWORD *)(a1 + 160) = xmmword_1B6E51230;
  return result;
}

void sub_1B65248F4(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 88);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf)
    {
      *(void *)(a1 + 88) = CFRetain(cf);
      CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
      *(void *)(a1 + 104) = Count;
      BOOL v6 = Count > 0;
      if (Count < 1)
      {
        BOOL v6 = 0;
      }
      else
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          sub_1B64A3908((uint64_t)ValueAtIndex, 1);
        }
      }
    }
    else
    {
      BOOL v6 = 0;
      CFIndex Count = 0;
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 104) = 0;
    }
    uint64_t v9 = *(void **)(a1 + 112);
    if (v9) {
      free(v9);
    }
    CFArrayRef v10 = *(void **)(a1 + 120);
    if (v10) {
      free(v10);
    }
    uint64_t v11 = *(void **)(a1 + 128);
    if (v11) {
      free(v11);
    }
    if (Count)
    {
      *(void *)(a1 + 112) = sub_1B63CA51C(Count << 6);
      *(void *)(a1 + 120) = sub_1B63CA51C(48 * Count);
      CFTypeRef v12 = sub_1B63CA51C(32 * Count);
    }
    else
    {
      CFTypeRef v12 = 0;
      *(void *)(a1 + 112) = 0;
      *(void *)(a1 + 120) = 0;
    }
    *(void *)(a1 + 128) = v12;
    if (v6)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      do
      {
        uint64_t v15 = (_OWORD *)(*(void *)(a1 + 112) + v13);
        *uint64_t v15 = xmmword_1B6E4F300;
        v15[1] = xmmword_1B6E4F320;
        void v15[2] = xmmword_1B6E4F2E0;
        v15[3] = xmmword_1B6E4F370;
        uint64_t v16 = (_OWORD *)(*(void *)(a1 + 128) + v14);
        *uint64_t v16 = xmmword_1B6E4F370;
        v16[1] = xmmword_1B6E51230;
        v14 += 32;
        v13 += 64;
        --Count;
      }
      while (Count);
    }
    *(unsigned char *)(a1 + 176) = 1;
    *(_OWORD *)(a1 + 144) = xmmword_1B6E4F370;
    *(_OWORD *)(a1 + 160) = xmmword_1B6E51230;
    free(*(void **)(a1 + 96));
    *(void *)(a1 + 96) = 0;
  }
}

void sub_1B6524A8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"skinner");
  }
  *(void *)(a1 + 64) = a2;
}

uint64_t sub_1B6524ADC(uint64_t a1, void *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  MutableCFArrayRef Copy = CFArrayCreateMutableCopy(0, Count, *(CFArrayRef *)(a1 + 88));
  int v22 = 0;
  uint64_t v6 = 0;
  if (sub_1B6524BA4(a1, MutableCopy, *(const void **)(a1 + 80), a2, &v22))
  {
    uint64_t v7 = v22;
    if (CFArrayGetCount(MutableCopy) == v7)
    {
      sub_1B65248F4(a1, MutableCopy);
      sub_1B6524868(a1, a2, v14, v15, v16, v17, v18, v19);
      uint64_t v6 = 1;
    }
    else
    {
      sub_1B63F2F54(0, @"Warning: CFXSkinnerTransposeSkeleton - unable to transpose every joints", v8, v9, v10, v11, v12, v13, v21);
      uint64_t v6 = 0;
    }
  }
  CFRelease(MutableCopy);
  return v6;
}

uint64_t sub_1B6524BA4(uint64_t a1, __CFArray *a2, const void *a3, const void *a4, _DWORD *a5)
{
  if (!a3) {
    return 0;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 88)) >= 1)
  {
    CFIndex Count = 0;
    do
    {
      if (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), Count) == a3)
      {
        CFArraySetValueAtIndex(a2, Count, a4);
        ++*a5;
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
      }
      ++Count;
    }
    while (Count < CFArrayGetCount(*(CFArrayRef *)(a1 + 88)));
  }
  free(*(void **)(a1 + 96));
  *(void *)(a1 + 96) = 0;
  BOOL v11 = sub_1B6477268((uint64_t)a3);
  BOOL v12 = sub_1B6477268((uint64_t)a4);
  BOOL v13 = v12;
  uint64_t result = v11 ^ v12 ^ 1u;
  if (v11 && v13)
  {
    unsigned int v15 = sub_1B64A180C((uint64_t)a3);
    if (v15 == sub_1B64A180C((uint64_t)a4))
    {
      uint64_t v16 = v15;
      if (v15)
      {
        uint64_t v17 = 0;
        uint64_t v18 = v16 - 1;
        do
        {
          uint64_t v19 = sub_1B64A1A44((uint64_t)a3, v17);
          uint64_t v20 = sub_1B64A1A44((uint64_t)a4, v17);
          uint64_t result = sub_1B6524BA4(a1, a2, v19, v20, a5);
          if (!result) {
            break;
          }
        }
        while (v18 != v17++);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFIndex sub_1B6524D18(uint64_t a1, uint64_t a2)
{
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  if (result)
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), 0);
    return ValueAtIndex != (const void *)a2 && !sub_1B64A33A4((uint64_t)ValueAtIndex, a2, v6, v7, v8, v9, v10, v11);
  }
  return result;
}

BOOL sub_1B6524D74(uint64_t a1, void *a2)
{
  uint64_t Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
  if (Count < 1)
  {
    BOOL v6 = 1;
LABEL_8:
    sub_1B65248F4(a1, Mutable);
    sub_1B6524868(a1, a2, v25, v26, v27, v28, v29, v30);
  }
  else
  {
    BOOL v6 = 0;
    CFIndex v7 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), v7);
      uint64_t v16 = sub_1B64A1954((uint64_t)ValueAtIndex, v9, v10, v11, v12, v13, v14, v15);
      if (!v16)
      {
        float v31 = @"Warning: Cannot update the joints using node names: unammed joint found";
        goto LABEL_11;
      }
      uint64_t v23 = v16;
      uint64_t v24 = (const void *)sub_1B64A293C((uint64_t)a2, v16, v17, v18, v19, v20, v21, v22);
      if (!v24) {
        break;
      }
      CFArrayAppendValue(Mutable, v24);
      BOOL v6 = ++v7 >= Count;
      if (Count == v7) {
        goto LABEL_8;
      }
    }
    uint64_t v33 = v23;
    float v31 = @"Warning: Cannot update the joints using node names: can't find node named %@";
LABEL_11:
    sub_1B63F2F54(0, (uint64_t)v31, v17, v18, v19, v20, v21, v22, v33);
  }
  CFRelease(Mutable);
  return v6;
}

BOOL sub_1B6524E80(uint64_t a1)
{
  return *(void *)(a1 + 104) == 1;
}

void sub_1B6524E90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void **)(a1 + 72);
  if (!v9) {
    return;
  }
  uint64_t v11 = sub_1B649F5F4(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v11)
  {
    CFTypeRef v19 = sub_1B63CE23C(v11, v12, v13, v14, v15, v16, v17, v18);
    uint64_t v26 = sub_1B64ACF7C((uint64_t)v19, 0, v20, v21, v22, v23, v24, v25);
    CFArrayRef v27 = *(const __CFArray **)(a1 + 88);
    if (v27) {
      CFIndex Count = CFArrayGetCount(v27);
    }
    else {
      CFIndex Count = 0;
    }
    uint64_t v31 = sub_1B6531674((uint64_t)v9);
    if (Count && Count == (int)v31)
    {
      uint64_t v110 = 0;
      uint64_t v111 = 0;
      uint64_t v109 = 0;
      MEMORY[0x1F4188790](v31, v32);
      uint64_t v33 = (float32x4_t *)(&v105 - 2 * Count);
      MEMORY[0x1F4188790](v34, v35);
      CFArrayRef v36 = v33;
      sub_1B65315EC(v9, &v111, &v110, &v109);
      if (Count >= 1)
      {
        memset_pattern16(&v105 - 2 * Count, &xmmword_1B6E51F40, 16 * Count);
        memset_pattern16(&v105 - 2 * Count, &xmmword_1B6E51F50, 16 * Count);
      }
      long long v37 = (float32x4_t *)sub_1B653166C((uint64_t)v9);
      uint64_t v45 = sub_1B6451F14((uint64_t)v9);
      uint64_t v105 = (uint64_t)&v105;
      if (Count == 1)
      {
        v108.i32[2] = 0;
        v108.i64[0] = 0;
        v107.i32[2] = 0;
        v107.i64[0] = 0;
        sub_1B64AB620((uint64_t)v19, &v108, &v107, v40, v41, v42, v43, v44);
        uint64_t v46 = 0;
        float32x4_t v47 = v108;
        float32x4_t v48 = v107;
        v47.i32[3] = 1.0;
        v48.i32[3] = 1.0;
        float32x4_t v49 = vaddq_f32(v47, v48);
        float32x4_t v50 = vsubq_f32(v48, v47);
        float32x4_t v51 = *(float32x4_t *)v45;
        float32x4_t v52 = *(float32x4_t *)(v45 + 16);
        float32x4_t v53 = *(float32x4_t *)(v45 + 32);
        float32x4_t v54 = *(float32x4_t *)(v45 + 48);
        float32x4_t v55 = v37[1];
        float32x4_t v56 = v37[2];
        float32x4_t v57 = v37[3];
        v112[0] = *v37;
        v112[1] = v55;
        v112[2] = v56;
        v112[3] = v57;
        float32x4_t v113 = 0u;
        float32x4_t v114 = 0u;
        float32x4_t v115 = 0u;
        float32x4_t v116 = 0u;
        do
        {
          *(float32x4_t *)((char *)&v113 + v46 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v51, COERCE_FLOAT(v112[v46])), v52, *(float32x2_t *)&v112[v46], 1), v53, (float32x4_t)v112[v46], 2), v54, (float32x4_t)v112[v46], 3);
          ++v46;
        }
        while (v46 != 4);
        v58.i64[0] = 0x3F0000003F000000;
        v58.i64[1] = 0x3F0000003F000000;
        float32x4_t v59 = vmulq_f32(v49, v58);
        int32x4_t v60 = (int32x4_t)vmulq_f32(v50, v58);
        float32x4_t v61 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v116, v115, v59, 2), v114, *(float32x2_t *)v59.f32, 1), v113, v59.f32[0]);
        v61.i32[3] = v59.i32[3];
        float32x4_t v62 = (float32x4_t)v60;
        v62.i32[1] = v60.i32[0];
        v62.i32[2] = v60.i32[0];
        float32x4_t v63 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v60.i8, 1), v60), vabsq_f32(v114)), v62, vabsq_f32(v113)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v60, v60), v60), vabsq_f32(v115));
        *uint64_t v33 = vsubq_f32(v61, v63);
        *uint64_t v33 = vaddq_f32(v63, v61);
      }
      else
      {
        uint64_t v106 = sub_1B641D478((uint64_t)v26, v38, v39, v40, v41, v42, v43, v44);
        int v71 = BYTE5(v64);
        if (BYTE5(v64))
        {
          uint64_t v72 = v64;
          if ((int)v64 - 1 < sub_1B641E308((uint64_t)v9))
          {
            uint64_t v82 = 0;
            do
            {
              *(double *)v79.i64 = sub_1B65D6198(BYTE4(v72), (const float *)(v106 + (v71 * v82)), v73, v74, v75, v76, v77, v78, v79, v80.f32[0], v81.f32[0]);
              float32x4_t v80 = *v37;
              float32x4_t v81 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v37[3], v37[2], v79, 2), v37[1], *(float32x2_t *)v79.f32, 1), *v37, v79.f32[0]);
              if (v111) {
                BOOL v83 = Count < 2;
              }
              else {
                BOOL v83 = 1;
              }
              if (v83)
              {
                float32x4_t v80 = *(float32x4_t *)(v45 + 16);
                float32x4_t v84 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v45 + 48), *(float32x4_t *)(v45 + 32), v81, 2), v80, *(float32x2_t *)v81.f32, 1), *(float32x4_t *)v45, v81.f32[0]);
                float32x4_t v85 = *v33;
                v84.i32[3] = 0;
                v85.i32[3] = 0;
                *uint64_t v33 = vminnmq_f32(v84, v85);
                float32x4_t v86 = *v33;
                v86.i32[3] = 0;
                float32x4_t v79 = vmaxnmq_f32(v84, v86);
                *uint64_t v33 = v79;
                ++v82;
              }
              else
              {
                uint64_t v87 = *(void *)(v111 + 8 * v82++);
                uint64_t v88 = *(void *)(v111 + 8 * v82);
                BOOL v83 = v88 <= v87;
                uint64_t v89 = v88 - v87;
                if (!v83)
                {
                  uint64_t v90 = v109;
                  float32x4_t v79 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 0);
                  float32x4_t v80 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1);
                  float32x4_t v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2);
                  uint64_t v91 = (float *)(v109 + 4 * v87);
                  uint64_t v92 = (__int16 *)(v110 + 2 * v87);
                  do
                  {
                    int v94 = *v92++;
                    unsigned __int16 v93 = v94;
                    if ((v94 & 0x80000000) == 0 && (!v90 || *v91 > 0.0) && Count > v93)
                    {
                      float32x4_t v95 = vmlaq_f32(vmlaq_f32(vmlaq_f32(*(float32x4_t *)(v45 + ((unint64_t)v93 << 6) + 48), *(float32x4_t *)(v45 + ((unint64_t)v93 << 6) + 32), v81), *(float32x4_t *)(v45 + ((unint64_t)v93 << 6) + 16), v80), *(float32x4_t *)(v45 + ((unint64_t)v93 << 6)), v79);
                      float32x4_t v96 = v33[v93];
                      v95.i32[3] = 0;
                      v96.i32[3] = 0;
                      v33[v93] = vminnmq_f32(v95, v96);
                      float32x4_t v97 = v33[v93];
                      v97.i32[3] = 0;
                      v33[v93] = vmaxnmq_f32(v95, v97);
                    }
                    ++v91;
                    --v89;
                  }
                  while (v89);
                }
              }
            }
            while (v82 != v72);
          }
        }
        else
        {
          sub_1B63F2F54(16, @"Error: _CFXSkinnerUpdateBoundingBox invalid mesh source", v65, v66, v67, v68, v69, v70, v105);
        }
      }
      if (Count >= 1)
      {
        uint64_t v98 = 0;
        v99.i64[0] = 0x3F0000003F000000;
        v99.i64[1] = 0x3F0000003F000000;
        do
        {
          uint64_t v100 = (float32x4_t *)(*(void *)(a1 + 128) + v98);
          float32x4_t v101 = *v33++;
          float32x4_t v102 = v101;
          float32x4_t v103 = *v36++;
          float32x4_t v104 = v103;
          v102.i32[3] = 1.0;
          v104.i32[3] = 1.0;
          *uint64_t v100 = vmulq_f32(vaddq_f32(v102, v104), v99);
          v100[1] = vmulq_f32(vsubq_f32(v104, v102), v99);
          v98 += 32;
          --Count;
        }
        while (Count);
      }
      *(unsigned char *)(a1 + 176) = 0;
      return;
    }
    if (byte_1E9DDB1F8) {
      return;
    }
    byte_1E9DDB1F8 = 1;
    uint64_t v29 = @"Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.";
    int v30 = 16;
  }
  else
  {
    uint64_t v29 = @"Warning: _CFXSkinnerUpdateBoundingBox - skinned node has no geometry";
    int v30 = 0;
  }

  sub_1B63F2F54(v30, (uint64_t)v29, v13, v14, v15, v16, v17, v18, a9);
}

double sub_1B6525380(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  v82.columns[2] = a7;
  v82.columns[3] = a8;
  v82.columns[0] = a5;
  v82.columns[1] = a6;
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = sub_1B65312B8(a2);
  simd_float4x4 v84 = __invert_f4(v82);
  v82.columns[2] = v84.columns[1];
  v82.columns[3] = v84.columns[0];
  v82.columns[0] = v84.columns[3];
  v82.columns[1] = v84.columns[2];
  uint64_t v19 = sub_1B63F4F08(a3, v12, v13, v14, v15, v16, v17, v18);
  if (v19) {
    uint64_t v27 = sub_1B64B29E0(v19, v20, v21, v22, v23, v24, v25, v26);
  }
  else {
    uint64_t v27 = 0;
  }
  uint64_t v28 = *(void **)(a1 + 80);
  if (v28) {
    uint64_t v29 = sub_1B63F4F54(v28, v20, v21, v22, v23, v24, v25, v26);
  }
  else {
    uint64_t v29 = 0;
  }
  uint64_t v31 = sub_1B63F4F54((void *)a1, v20, v21, v22, v23, v24, v25, v26);
  uint64_t v32 = *(void **)(a1 + 96);
  if (v29 == v31)
  {
    if (!v32) {
      uint64_t v32 = (void *)sub_1B6524558(a1);
    }
  }
  else
  {
    free(v32);
    *(void *)(a1 + 96) = 0;
  }
  MEMORY[0x1F4188790](v32, v30);
  if (a4 < 1)
  {
    char v76 = sub_1B649FA70(a3);
    float32x4_t v59 = (float32x4_t)v82.columns[2];
    float32x4_t v58 = (float32x4_t)v82.columns[3];
    float32x4_t v61 = (float32x4_t)v82.columns[0];
    float32x4_t v60 = (float32x4_t)v82.columns[1];
    if ((v76 & 1) == 0)
    {
      float32x4_t v64 = (float32x4_t)xmmword_1B6E51230;
      float32x4_t v63 = (float32x4_t)xmmword_1B6E4F370;
LABEL_28:
      float32x4_t v77 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v61, v60, v63, 2), v59, *(float32x2_t *)v63.f32, 1), v58, v63.f32[0]);
      v77.i32[3] = v63.i32[3];
      float32x4_t v78 = v64;
      v78.i32[1] = v64.i32[0];
      v78.i32[2] = v64.i32[0];
      *(float32x4_t *)(a1 + 144) = v77;
      *(float32x4_t *)(a1 + 160) = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v64.f32, 1), (int32x4_t)v64), vabsq_f32(v59)), v78, vabsq_f32(v58)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v64, (int32x4_t)v64), (int32x4_t)v64), vabsq_f32(v60));
    }
  }
  else
  {
    uint64_t v81 = v11;
    CFIndex v39 = 0;
    uint64_t v40 = (_OWORD *)MEMORY[0x1E4F149A0];
    uint64_t v41 = &v80 - 8 * a4;
    do
    {
      uint64_t v42 = *(void *)(a1 + 96);
      if (!v42 || (int v43 = *(_DWORD *)(v42 + 4 * v39), v43 == -1))
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), v39);
        if (ValueAtIndex)
        {
          sub_1B64A2828((uint64_t)ValueAtIndex, (uint64_t)v41, v49, v50, v51, v52, v53, v54);
        }
        else
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v49, v50, v51, v52, v53, v54, (uint64_t)"joint");
          long long v55 = v40[1];
          *(_OWORD *)uint64_t v41 = *v40;
          *((_OWORD *)v41 + 1) = v55;
          long long v56 = v40[3];
          *((_OWORD *)v41 + 2) = v40[2];
          *((_OWORD *)v41 + 3) = v56;
        }
      }
      else
      {
        uint64_t v44 = (long long *)sub_1B651004C(v27, v43, v33, v34, v35, v36, v37, v38);
        long long v45 = v44[3];
        long long v47 = *v44;
        long long v46 = v44[1];
        *((_OWORD *)v41 + 2) = v44[2];
        *((_OWORD *)v41 + 3) = v45;
        *(_OWORD *)uint64_t v41 = v47;
        *((_OWORD *)v41 + 1) = v46;
      }
      ++v39;
      v41 += 8;
    }
    while (a4 != v39);
    char v57 = sub_1B649FA70(a3);
    uint64_t v11 = v81;
    float32x4_t v59 = (float32x4_t)v82.columns[2];
    float32x4_t v58 = (float32x4_t)v82.columns[3];
    float32x4_t v61 = (float32x4_t)v82.columns[0];
    float32x4_t v60 = (float32x4_t)v82.columns[1];
    if ((v57 & 1) == 0)
    {
      float32x4_t v62 = (float32x4_t *)(&v80 - 8 * a4 + 4);
      float32x4_t v63 = (float32x4_t)xmmword_1B6E4F370;
      float32x4_t v64 = (float32x4_t)xmmword_1B6E51230;
      uint64_t v65 = (int32x2_t *)(*(void *)(a1 + 128) + 16);
      v66.i64[0] = 0x3F0000003F000000;
      v66.i64[1] = 0x3F0000003F000000;
      uint64_t v67 = a4;
      do
      {
        if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)v65->i8)) & 0x80000000) != 0)
        {
          float32x4_t v68 = v62[-2];
          float32x4_t v69 = v62[-1];
          float32x4_t v70 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v62[1], *v62, *(float32x4_t *)v65[-2].i8, 2), v69, (float32x2_t)v65[-2], 1), v68, COERCE_FLOAT(*(_OWORD *)v65[-2].i8));
          v70.i32[3] = HIDWORD(*(_OWORD *)v65[-2].i8);
          float32x4_t v71 = vabsq_f32(v68);
          float32x4_t v72 = *(float32x4_t *)v65->i8;
          v72.i32[1] = *(_OWORD *)v65->i8;
          v72.i32[2] = v72.i32[1];
          float32x4_t v73 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*v65, 1), *(int32x4_t *)v65->i8), vabsq_f32(v69)), v72, v71), (float32x4_t)vzip2q_s32(vtrn1q_s32(*(int32x4_t *)v65->i8, *(int32x4_t *)v65->i8), *(int32x4_t *)v65->i8), vabsq_f32(*v62));
          float32x4_t v74 = vminnmq_f32(vsubq_f32(v63, v64), vsubq_f32(v70, v73));
          float32x4_t v75 = vmaxnmq_f32(vaddq_f32(v63, v64), vaddq_f32(v73, v70));
          float32x4_t v63 = vmulq_f32(vaddq_f32(v74, v75), v66);
          float32x4_t v64 = vmulq_f32(vsubq_f32(v75, v74), v66);
        }
        v62 += 4;
        v65 += 4;
        --v67;
      }
      while (v67);
      goto LABEL_28;
    }
  }
  sub_1B6474B70((float32x4_t *)&v80 - 4 * a4, (uint64_t)(&v80 - 8 * a4), a4, v58, v59, v60, v61);
  sub_1B6474ADC(*(float32x4_t **)(a1 + 112), (float32x4_t *)&v80 - 4 * a4, v11, a4);
  *(void *)&double result = sub_1B6474C04(*(void *)(a1 + 120), (int32x4_t *)*(void *)(a1 + 112), a4).u64[0];
  return result;
}

void sub_1B65256D0(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(unsigned char *)(a1 + 176)) {
    sub_1B6524E90(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v38);
  }
  uint64_t v11 = *(void *)(a1 + 72);
  if (!v11) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  }
  int v12 = sub_1B6531674(v11);
  if (*(void *)(a1 + 88) && (uint64_t v20 = *(void *)(a1 + 104)) != 0 && (v21 = v12, v20 == v12))
  {
    uint64_t v22 = sub_1B649F5F4((uint64_t)a2, v13, v14, v15, v16, v17, v18, v19);
    if (v22) {
      sub_1B63CE23C(v22, v23, v24, v25, v26, v27, v28, v29);
    }
    uint64_t v30 = (simd_float4 *)sub_1B64A01D4((uint64_t)a2, v23, v24, v25, v26, v27, v28, v29);
    sub_1B6525380(a1, v11, (uint64_t)a2, v21, *v30, v30[1], v30[2], v30[3]);
    sub_1B649F73C(a2, v31, v32, v33, v34, v35, v36, v37);
  }
  else if ((byte_1E9DDB1F9 & 1) == 0)
  {
    byte_1E9DDB1F9 = 1;
    sub_1B63F2F54(16, @"Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.", v14, v15, v16, v17, v18, v19, a9);
  }
}

uint64_t sub_1B6525800(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = 3 * *(void *)(a1 + 104);
  }
  return *(void *)(a1 + 120);
}

float32x4_t sub_1B6525818(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 176)) {
    sub_1B6524E90(a1, a2, a3, a4, a5, a6, a7, a8, v83);
  }
  if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(a1 + 160))) & 0x80000000) != 0) {
    goto LABEL_20;
  }
  CFArrayRef v11 = *(const __CFArray **)(a1 + 88);
  if (v11)
  {
    CFIndex Count = CFArrayGetCount(v11);
    if (Count)
    {
      CFIndex v13 = Count;
      if (Count < 1)
      {
        float32x4_t v85 = (float32x4_t)xmmword_1B6E51230;
        float32x4_t v84 = (float32x4_t)xmmword_1B6E4F370;
      }
      else
      {
        uint64_t v14 = 0;
        CFIndex v15 = 0;
        float32x4_t v84 = (float32x4_t)xmmword_1B6E4F370;
        float32x4_t v85 = (float32x4_t)xmmword_1B6E51230;
        do
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), v15);
          uint64_t v24 = sub_1B63F4F54(ValueAtIndex, v17, v18, v19, v20, v21, v22, v23);
          if (v24)
          {
            uint64_t v32 = v24;
            sub_1B64B0C28(v24, v25, v26, v27, v28, v29, v30, v31);
            uint64_t v40 = sub_1B64A01D4((uint64_t)ValueAtIndex, v33, v34, v35, v36, v37, v38, v39);
            sub_1B64B0CB4(v32, v41, v42, v43, v44, v45, v46, v47);
          }
          else
          {
            uint64_t v40 = sub_1B64A01D4((uint64_t)ValueAtIndex, v25, v26, v27, v28, v29, v30, v31);
          }
          uint64_t v48 = *(void *)(a1 + 128);
          float32x4_t v49 = *(float32x4_t *)(v48 + v14 + 16);
          if ((vminvq_u32((uint32x4_t)vcgezq_f32(v49)) & 0x80000000) != 0)
          {
            float32x4_t v50 = *(float32x4_t *)(v40 + 16);
            float32x4_t v51 = *(float32x4_t *)(v40 + 32);
            float32x4_t v52 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v40 + 48), v51, *(float32x4_t *)(v48 + v14), 2), v50, *(float32x2_t *)(v48 + v14), 1), *(float32x4_t *)v40, COERCE_FLOAT(*(_OWORD *)(v48 + v14)));
            v52.i32[3] = HIDWORD(*(_OWORD *)(v48 + v14));
            float32x4_t v53 = *(float32x4_t *)(v48 + v14 + 16);
            v53.i32[1] = v53.i32[0];
            v53.i32[2] = *(_OWORD *)(v48 + v14 + 16);
            float32x4_t v54 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v49.f32, 1), (int32x4_t)v49), vabsq_f32(v50)), v53, vabsq_f32(*(float32x4_t *)v40)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v49, (int32x4_t)v49), (int32x4_t)v49), vabsq_f32(v51));
            float32x4_t v55 = vminnmq_f32(vsubq_f32(v84, v85), vsubq_f32(v52, v54));
            float32x4_t v56 = vmaxnmq_f32(vaddq_f32(v84, v85), vaddq_f32(v54, v52));
            v54.i64[0] = 0x3F0000003F000000;
            v54.i64[1] = 0x3F0000003F000000;
            float32x4_t v84 = vmulq_f32(vaddq_f32(v55, v56), v54);
            float32x4_t v85 = vmulq_f32(vsubq_f32(v56, v55), v54);
          }
          ++v15;
          v14 += 32;
        }
        while (v13 != v15);
      }
      *(double *)v76.i64 = sub_1B64A2220(a2, a2, a3, a4, a5, a6, a7, a8);
      float32x4_t v80 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v78, v77, v84, 2), v79, *(float32x2_t *)v84.f32, 1), v76, v84.f32[0]);
      v80.i32[3] = v84.i32[3];
      float32x4_t v81 = v85;
      v81.i32[1] = v85.i32[0];
      v81.i32[2] = v85.i32[0];
      *(float32x4_t *)(a1 + 144) = v80;
      *(float32x4_t *)(a1 + 160) = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v85.f32, 1), (int32x4_t)v85), vabsq_f32(v79)), v81, vabsq_f32(v76)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v85, (int32x4_t)v85), (int32x4_t)v85), vabsq_f32(v77));
LABEL_20:
      float32x4_t result = *(float32x4_t *)(a1 + 144);
      long long v82 = *(_OWORD *)(a1 + 160);
      *(float32x4_t *)a3 = result;
      *(_OWORD *)(a3 + 16) = v82;
      return result;
    }
  }
  uint64_t v57 = sub_1B649F5F4(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v57)
  {
    CFTypeRef v66 = sub_1B63CE23C(v57, v58, v59, v60, v61, v62, v63, v64);
    v87.i32[2] = 0;
    v87.i64[0] = 0;
    v86.i32[2] = 0;
    v86.i64[0] = 0;
    sub_1B64AB620((uint64_t)v66, &v87, &v86, v67, v68, v69, v70, v71);
    float32x4_t v73 = v86;
    float32x4_t v72 = v87;
    v72.i32[3] = 1.0;
    v73.i32[3] = 1.0;
    v74.i64[0] = 0x3F0000003F000000;
    v74.i64[1] = 0x3F0000003F000000;
    float32x4_t v75 = vmulq_f32(vaddq_f32(v72, v73), v74);
    float32x4_t result = vmulq_f32(vsubq_f32(v73, v72), v74);
    *(float32x4_t *)a3 = v75;
    *(float32x4_t *)(a3 + 16) = result;
  }
  return result;
}

uint64_t sub_1B6525AA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"skinner");
  }
  if (*(unsigned char *)(a1 + 176)) {
    sub_1B6524E90(a1, a2, a3, a4, a5, a6, a7, a8, v11);
  }
  return *(void *)(a1 + 128);
}

void sub_1B6525B0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (*(unsigned char *)(a1 + 176)) {
    sub_1B6524E90(a1, a3, a3, a4, a5, a6, a7, a8, v14[0]);
  }
  uint64_t v12 = *(void *)(a1 + 80);
  if (v12)
  {
    int v13 = sub_1B64A180C(v12);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 0x40000000;
    v14[2] = (uint64_t)sub_1B6525BD8;
    v14[3] = (uint64_t)&unk_1E6143B58;
    float v18 = a9;
    uint64_t v16 = v12;
    uint64_t v17 = a2;
    long long v15 = xmmword_1B6E4F3A0;
    BOOL v19 = v13 == 0;
    sub_1B64A18A4(v12, (uint64_t)v14);
  }
}

uint64_t sub_1B6525BD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 48) != a2)
  {
    *(double *)v10.i64 = sub_1B649FE9C(a2, a2, a3, a4, a5, a6, a7, a8);
    simd_float4 v31 = v11;
    simd_float4 v32 = v10;
    simd_float4 v29 = v13;
    simd_float4 v30 = v12;
    uint64_t v21 = sub_1B64A01D4(a2, v14, v15, v16, v17, v18, v19, v20);
    v35.columns[1] = v31;
    v35.columns[0] = v32;
    v35.columns[3] = v29;
    v35.columns[2] = v30;
    simd_float4x4 v24 = __invert_f4(v35);
    float32x4_t v34 = 0uLL;
    v24.columns[0] = (simd_float4)vmulq_f32((float32x4_t)v24.columns[3], (float32x4_t)v24.columns[3]);
    v24.columns[1] = (simd_float4)vaddq_f32((float32x4_t)v24.columns[0], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.columns[0].f32, 1));
    v24.columns[0] = (simd_float4)vdupq_laneq_s32((int32x4_t)v24.columns[0], 2);
    v24.columns[1].i32[0] = vaddq_f32((float32x4_t)v24.columns[0], (float32x4_t)v24.columns[1]).u32[0];
    v24.columns[0].f32[0] = sqrtf(v24.columns[1].f32[0]);
    if (v24.columns[0].f32[0] <= 0.0)
    {
      v24.columns[2] = (simd_float4)xmmword_1B6E4F320;
      v24.columns[1].i32[0] = *(_DWORD *)(a1 + 64);
      v24.columns[0].i32[0] = v24.columns[1].i32[0];
    }
    else
    {
      v24.columns[2].i32[0] = v24.columns[1].i32[0];
      *(float32x2_t *)v24.columns[1].f32 = vrsqrte_f32((float32x2_t)v24.columns[1].u32[0]);
      *(float32x2_t *)v24.columns[1].f32 = vmul_f32(*(float32x2_t *)v24.columns[1].f32, vrsqrts_f32((float32x2_t)v24.columns[2].u32[0], vmul_f32(*(float32x2_t *)v24.columns[1].f32, *(float32x2_t *)v24.columns[1].f32)));
      v24.columns[2] = (simd_float4)vmulq_n_f32((float32x4_t)v24.columns[3], vmul_f32(*(float32x2_t *)v24.columns[1].f32, vrsqrts_f32((float32x2_t)v24.columns[2].u32[0], vmul_f32(*(float32x2_t *)v24.columns[1].f32, *(float32x2_t *)v24.columns[1].f32))).f32[0]);
      v24.columns[1].i32[0] = *(_DWORD *)(a1 + 64);
    }
    float32x4_t v33 = (float32x4_t)v24.columns[2];
    uint64_t v26 = *(uint64_t **)(a1 + 56);
    uint64_t v27 = (float *)(a1 + 32);
    uint64_t v25 = v21;
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 68))
  {
    uint64_t v25 = sub_1B64A01D4(a2, a2, a3, a4, a5, a6, a7, a8);
    float32x4_t v34 = 0uLL;
    v24.columns[0].i32[1] = 1065353216;
    float32x4_t v33 = (float32x4_t)xmmword_1B6E4F320;
    v24.columns[0].i32[0] = *(_DWORD *)(a1 + 64);
    uint64_t v26 = *(uint64_t **)(a1 + 56);
    uint64_t v27 = (float *)(a1 + 32);
    v24.columns[1].i32[0] = v24.columns[0].i32[0];
LABEL_8:
    sub_1B642D2C4(v26, &v34, &v33, v25, v27, 1, v22, v23, *(double *)v24.columns[0].i64, v24.columns[1].f32[0]);
  }
  return 0;
}

void sub_1B6525D00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 176)) {
    sub_1B6524E90(a1, a3, a3, a4, a5, a6, a7, a8, v27);
  }
  long long v27 = xmmword_1B6E4F390;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  if (Count >= 1)
  {
    CFIndex v11 = Count;
    uint64_t v12 = 0;
    for (CFIndex i = 0; i != v11; ++i)
    {
      if ((vminvq_u32((uint32x4_t)vcgezq_f32(*(float32x4_t *)(*(void *)(a1 + 128) + v12 + 16))) & 0x80000000) != 0)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), i);
        uint64_t v22 = sub_1B64A01D4((uint64_t)ValueAtIndex, v15, v16, v17, v18, v19, v20, v21);
        sub_1B642B7D4(a2, (float32x4_t *)(*(void *)(a1 + 128) + v12), v22, (float *)&v27, v23, v24, v25, v26);
      }
      v12 += 32;
    }
  }
}

BOOL sub_1B6525DCC(int a1)
{
  return a1 == 0;
}

double sub_1B6525DD8(uint64_t a1)
{
  *(unsigned char *)(a1 + 176) = 1;
  double result = 0.0;
  *(_OWORD *)(a1 + 144) = xmmword_1B6E4F370;
  *(_OWORD *)(a1 + 160) = xmmword_1B6E51230;
  return result;
}

id sub_1B6525DFC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[9]) {
    sub_1B652476C((uint64_t)a1, 0, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v9 = (void *)a1[15];
  if (v9) {
    free(v9);
  }
  simd_float4 v10 = (const void *)a1[11];
  if (v10) {
    CFRelease(v10);
  }
  CFIndex v11 = (void *)a1[14];
  if (v11) {
    free(v11);
  }
  uint64_t v12 = (void *)a1[16];
  if (v12) {
    free(v12);
  }
  simd_float4 v13 = (void *)a1[12];
  if (v13) {
    free(v13);
  }
  uint64_t v14 = (const void *)a1[10];
  if (v14)
  {
    CFRelease(v14);
    a1[10] = 0;
  }

  return sub_1B658325C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
}

__CFString *sub_1B6525E94(void *a1)
{
  CFArrayRef v2 = (const __CFArray *)a1[11];
  if (v2) {
    CFIndex Count = CFArrayGetCount(v2);
  }
  else {
    CFIndex Count = 0;
  }
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CFXSkinner %p skeleton:%p jointCount:%d cpuReady:%d\n", a1, a1[10], Count);
  CFStringAppendFormat(Mutable, 0, @"  skin:%p\n", a1[9]);
  if ((uint64_t)a1[13] >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a1[16];
      if (!v7) {
        break;
      }
      uint64_t v8 = v7 + v5;
      CFStringAppendFormat(Mutable, 0, @"  JointBbox[%d] {%f,%f,%f} {%f,%f,%f}\n", v6++, *(float *)v8, *(float *)(v8 + 4), *(float *)(v8 + 8), COERCE_FLOAT(*(_OWORD *)(v8 + 16)), COERCE_FLOAT(HIDWORD(*(void *)(v8 + 16))), COERCE_FLOAT(*(void *)(v8 + 24)));
      v5 += 32;
    }
    while (v6 < a1[13]);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

__CFArray *sub_1B6525FD0(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFTypeRef v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v46 = 1;
  int valuePtr = 5;
  uint64_t v45 = sub_1B65836E8(a1, v6, v7, v8, v9, v10, v11, v12);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v5, @"name", @"attributes");
  CFDictionarySetValue(v5, @"type", v13);
  CFDictionarySetValue(v5, @"address", v15);
  CFDictionarySetValue(v5, @"semantic", v14);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v14);
  CFRelease(v5);
  CFRelease(v15);
  CFRelease(v13);
  uint64_t v16 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v46 = 2;
  int valuePtr = 5;
  uint64_t v45 = a1 + 72;
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v16, @"name", @"skin");
  CFDictionarySetValue(v16, @"type", v17);
  CFDictionarySetValue(v16, @"address", v19);
  CFDictionarySetValue(v16, @"semantic", v18);
  CFArrayAppendValue(Mutable, v16);
  CFRelease(v18);
  CFRelease(v16);
  CFRelease(v19);
  CFRelease(v17);
  uint64_t v20 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v46 = 2;
  int valuePtr = 5;
  uint64_t v45 = a1 + 80;
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v20, @"name", @"skeleton");
  CFDictionarySetValue(v20, @"type", v21);
  CFDictionarySetValue(v20, @"address", v23);
  CFDictionarySetValue(v20, @"semantic", v22);
  CFArrayAppendValue(Mutable, v20);
  CFRelease(v22);
  CFRelease(v20);
  CFRelease(v23);
  CFRelease(v21);
  uint64_t v24 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v46 = 2;
  int valuePtr = 5;
  uint64_t v45 = a1 + 88;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v24, @"name", @"joints");
  CFDictionarySetValue(v24, @"type", v25);
  CFDictionarySetValue(v24, @"address", v27);
  CFDictionarySetValue(v24, @"semantic", v26);
  CFArrayAppendValue(Mutable, v24);
  CFRelease(v26);
  CFRelease(v24);
  CFRelease(v27);
  CFRelease(v25);
  uint64_t v28 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v46 = 0;
  int valuePtr = 3;
  uint64_t v45 = a1 + 176;
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &v45);
  CFDictionarySetValue(v28, @"name", @"bboxDirty");
  CFDictionarySetValue(v28, @"type", v29);
  CFDictionarySetValue(v28, @"address", v31);
  CFDictionarySetValue(v28, @"semantic", v30);
  simd_float4 v32 = Mutable;
  CFArrayAppendValue(Mutable, v28);
  CFRelease(v30);
  CFRelease(v28);
  uint64_t v33 = a1;
  CFRelease(v31);
  CFRelease(v29);
  CFArrayRef v34 = *(const __CFArray **)(a1 + 88);
  if (v34)
  {
    CFIndex Count = CFArrayGetCount(v34);
    if (Count >= 1)
    {
      CFIndex v36 = Count;
      uint64_t v37 = 0;
      for (uint64_t i = 0; i != v36; ++i)
      {
        CFStringRef v39 = CFStringCreateWithFormat(0, 0, @"verticesJointsMatrices[%d]", i);
        uint64_t v40 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        int v46 = 0;
        int valuePtr = 10;
        uint64_t v45 = *(void *)(v33 + 112) + v37;
        CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
        CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v46);
        CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v45);
        CFDictionarySetValue(v40, @"name", v39);
        CFDictionarySetValue(v40, @"type", v41);
        CFDictionarySetValue(v40, @"address", v43);
        CFDictionarySetValue(v40, @"semantic", v42);
        CFArrayAppendValue(v32, v40);
        CFRelease(v42);
        CFRelease(v40);
        CFRelease(v43);
        CFRelease(v41);
        CFRelease(v39);
        v37 += 64;
      }
    }
  }
  return v32;
}

uint64_t sub_1B652661C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 72);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  }
  return result;
}

void sub_1B6526640(uint64_t a1)
{
  *(void *)(a1 + 96) = 0;
}

uint64_t sub_1B652666C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  uint64_t v12 = *(const void **)(a1 + 72);

  return sub_1B63F4FC8(v12, (uint64_t)a2);
}

uint64_t sub_1B65266C8(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5)
{
  uint64_t v9 = &unk_1E9DDB000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB208, memory_order_acquire) & 1) == 0)
  {
    uint64_t v19 = a5;
    int v18 = __cxa_guard_acquire(&qword_1E9DDB208);
    uint64_t v9 = &unk_1E9DDB000;
    a5 = v19;
    if (v18)
    {
      byte_1E9DDB200 = 1;
      __cxa_guard_release(&qword_1E9DDB208);
      uint64_t v9 = (unsigned char *)&unk_1E9DDB000;
      a5 = v19;
    }
  }
  if (v9[512]) {
    uint64_t v10 = 0x11A993FC41E72446;
  }
  else {
    uint64_t v10 = 0;
  }
  CFX::RG::Pass::Pass(a1, a2, a3, a5, 1, v10, 0);
  *(void *)a1 = &unk_1F0FB30D8;
  long long v11 = *a4;
  long long v12 = a4[1];
  long long v13 = a4[3];
  *(_OWORD *)(a1 + 400) = a4[2];
  *(_OWORD *)(a1 + 416) = v13;
  *(_OWORD *)(a1 + 368) = v11;
  *(_OWORD *)(a1 + 384) = v12;
  long long v14 = a4[4];
  long long v15 = a4[5];
  long long v16 = a4[7];
  *(_OWORD *)(a1 + 464) = a4[6];
  *(_OWORD *)(a1 + 480) = v16;
  *(_OWORD *)(a1 + 432) = v14;
  *(_OWORD *)(a1 + 448) = v15;
  sub_1B65A84D4(a1 + 496, a2, a3, *(void *)a4, a4 + 1);
  return a1;
}

void sub_1B65267E4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B65267F8(uint64_t a1)
{
  return a1 + 496;
}

void sub_1B6526800(__n128 *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (uint64_t)&a1[31];
  sub_1B65A8594(a1 + 31, a2, a3, a4);
  sub_1B65A88F8(v5, v6, v7, v8, v9, v10, v11, v12);
  sub_1B65A8D10(v5);
  sub_1B65A8D3C(v5, v13, v14, v15, v16, v17, v18, v19);
  if (a1[23].n128_u8[8])
  {
    sub_1B65A8D4C(v5, v20, v21, v22, v23, v24, v25, v26);
  }
}

void sub_1B652686C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = sub_1B6447B50(*(void *)(a1 + 368), (const char *)a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Perform culling", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/CullingPass.mm", 33, v6 | 0x300000000);
  sub_1B65A8F34((uint64_t *)(a1 + 496), *(const char **)a2, *(void *)(a2 + 8), v7);
  if (*(unsigned char *)(a1 + 376))
  {
    uint64_t v8 = sub_1B6451064(a1 + 496);
    uint64_t v9 = *(CFX::CrossFrameResourceManager **)(a2 + 32);
    __guard v10 = sub_1B65A837C();
    *(void *)(sub_1B652691C(v9, v10) + 16) = v8;
  }

  prof_endFlame();
}

void sub_1B652690C(_Unwind_Exception *a1)
{
}

uint64_t sub_1B652691C(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B65269A4(__n128 *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a3 == 1)
  {
    sub_1B652686C((uint64_t)a1, (uint64_t)a2, a3, a4);
  }
  else if (!a3)
  {
    sub_1B6526800(a1, a2, a3, a4);
  }
}

uint64_t sub_1B65269BC(uint64_t *a1, long long *a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return sub_1B65269E4(a1, a2, &v4);
}

uint64_t sub_1B65269E4(uint64_t *a1, long long *a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6526B18(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6526A3C(CFX::RG::Pass *a1)
{
  *(void *)a1 = &unk_1F0FB30D8;
  sub_1B65A8550((uint64_t)a1 + 496);

  CFX::RG::Pass::~Pass(a1);
}

void sub_1B6526A94(CFX::RG::Pass *a1)
{
  *(void *)a1 = &unk_1F0FB30D8;
  sub_1B65A8550((uint64_t)a1 + 496);
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6526B04()
{
}

uint64_t sub_1B6526B18(uint64_t a1, uint64_t a2, uint64_t *a3, long long *a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x2A0u, 0x10u);
  return sub_1B65266C8(v8, *a3, a3[1], a4, *a5);
}

void sub_1B6526D10(uint64_t a1)
{
  sub_1B65248F4(*(void *)(a1 + 32), 0);
  sub_1B6524868(*(void *)(a1 + 32), 0, v2, v3, v4, v5, v6, v7);
  uint64_t v8 = *(const void **)(a1 + 32);

  CFRelease(v8);
}

void *sub_1B6526EC0(void *a1, const char *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v3 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, a2, (uint64_t)&v14, (uint64_t)v18, 16);
  if (!v3) {
    return 0;
  }
  uint64_t v7 = v3;
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)v15;
  do
  {
    for (uint64_t i = 0; i != v7; ++i)
    {
      if (*(void *)v15 != v9) {
        objc_enumerationMutation(a1);
      }
      uint64_t v11 = *(void **)(*((void *)&v14 + 1) + 8 * i);
      if (v8)
      {
        while (!v11)
        {
LABEL_11:
          uint64_t v8 = objc_msgSend_parentNode(v8, v4, v5, v6);
          if (!v8) {
            return v8;
          }
        }
        uint64_t v12 = v11;
        while (v12 != v8)
        {
          uint64_t v12 = objc_msgSend_parentNode(v12, v4, v5, v6);
          if (!v12) {
            goto LABEL_11;
          }
        }
      }
      else
      {
        uint64_t v8 = *(void **)(*((void *)&v14 + 1) + 8 * i);
      }
    }
    uint64_t v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v4, (uint64_t)&v14, (uint64_t)v18, 16);
  }
  while (v7);
  return v8;
}

double sub_1B65270B4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = objc_msgSend_skinnerRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v13 = *(void **)(a1 + 40);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = objc_msgSend_nodeRef(v13, v5, v6, v7);
  char v18 = sub_1B6524D18(v12, v14);
  uint64_t v19 = *(void **)(a1 + 40);
  if (v18)
  {
    uint64_t v20 = objc_msgSend_nodeRef(v19, v15, v16, v17);
    if ((sub_1B6524ADC(v12, v20) & 1) == 0)
    {
      uint64_t v25 = objc_msgSend_nodeRef(*(void **)(a1 + 40), v21, v22, v23);
      if (!sub_1B6524D74(v12, v25)) {
        sub_1B63F2F54(0, @"Warning: Failed to transpose skeleton\nold skeleton: %@\nnew skeleton: %@", v26, v27, v28, v29, v30, v31, *(void *)(a1 + 48));
      }
    }
    return result;
  }
  if (!v19)
  {
    sub_1B65248F4(v12, 0);
LABEL_10:
    uint64_t v33 = v12;
    simd_float4 v32 = 0;
    goto LABEL_11;
  }
  simd_float4 v32 = objc_msgSend_nodeRef(v19, v15, v16, v17);
  uint64_t v33 = v12;
LABEL_11:

  return sub_1B6524868(v33, v32, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1B6529108(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

void sub_1B6529110(void *a1, int a2)
{
  if (*((unsigned __int8 *)a1 + 64) != a2)
  {
    *((unsigned char *)a1 + 64) = a2;
    sub_1B6529128(a1);
  }
}

void sub_1B6529128(void *a1)
{
  values = a1;
  CFDictionaryRef v1 = CFDictionaryCreate(0, (const void **)off_1E61417F0, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v9 = (const void *)sub_1B63F4F54(values, v2, v3, v4, v5, v6, v7, v8);
  sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v9, v1, 1u);
  CFRelease(v1);
}

uint64_t sub_1B65291AC()
{
  if (qword_1EB995320 != -1) {
    dispatch_once(&qword_1EB995320, &unk_1F0FB5C08);
  }
  return qword_1EB995328;
}

void sub_1B65291F0()
{
  if (!qword_1EB995328)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995328);
    qword_1EB995328 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"fStop", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"apertureBladeCount", 0x58u, 2, 0, 0, 0, v4, v5);
    sub_1B660E400(@"focalBlurSampleCount", 0x50u, 2, 0, 0, 0, v6, v7);
    sub_1B660E3EC();
  }
}

float sub_1B6529330(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 72);
}

void sub_1B652937C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 72) = a2;
}

uint64_t sub_1B65293D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(void *)(a1 + 80);
}

void sub_1B6529420(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(void *)(a1 + 80) = a2;
}

uint64_t sub_1B6529470(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(void *)(a1 + 88);
}

void sub_1B65294BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(void *)(a1 + 88) = a2;
}

uint64_t sub_1B652950C()
{
  if (qword_1EB995370 != -1) {
    dispatch_once(&qword_1EB995370, &unk_1F0FB6F08);
  }
  return qword_1EB995378;
}

double sub_1B6529550()
{
  if (!qword_1EB995378)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995378);
    qword_1EB995378 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"intensity", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB87B8;
    xmmword_1EB9741B0 = xmmword_1F0FB87B8;
  }
  return result;
}

void sub_1B6529644(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  float v11 = a1[18];
  if (v11 != a2)
  {
    a1[18] = a2;
    if (a2 == 0.0 || v11 == 0.0)
    {
      sub_1B6529128(a1);
    }
  }
}

uint64_t sub_1B65296E0()
{
  if (qword_1EB995350 != -1) {
    dispatch_once(&qword_1EB995350, &unk_1F0FB7088);
  }
  return qword_1EB995358;
}

double sub_1B6529724()
{
  if (!qword_1EB995358)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995358);
    qword_1EB995358 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"intensity", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"scale", 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"slice", 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"isColored", 0x54u, 3, 0, 0, 0, v8, v9);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB8798;
    xmmword_1EB974000 = xmmword_1F0FB8798;
  }
  return result;
}

float sub_1B6529878(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 76);
}

void sub_1B65298C4(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 76) = a2;
}

uint64_t sub_1B652991C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(unsigned __int8 *)(a1 + 84);
}

void sub_1B6529968(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(unsigned char *)(a1 + 84) = a2;
}

float sub_1B65299B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 80);
}

void sub_1B6529A04(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 80) = a2;
}

uint64_t sub_1B6529A5C()
{
  if (qword_1EB995340 != -1) {
    dispatch_once(&qword_1EB995340, &unk_1F0FB6188);
  }
  return qword_1EB995348;
}

double sub_1B6529AA0()
{
  if (!qword_1EB995348)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995348);
    qword_1EB995348 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"value", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"offset", 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"averageGray", 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"whitePoint", 0x54u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"adaptationBrighteningSpeedFactor", 0x58u, 1, 0, 0, 0, v10, v11);
    sub_1B660E400(@"adaptationDarkeningSpeedFactor", 0x5Cu, 1, 0, 0, 0, v12, v13);
    sub_1B660E400(@"adaptationMinimum", 0x60u, 1, 0, 0, 0, v14, v15);
    sub_1B660E400(@"adaptationMaximum", 0x64u, 1, 0, 0, 0, v16, v17);
    sub_1B660E400(@"wantsAdaptation", 0x68u, 3, 0, 0, 0, v18, v19);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB8788;
    xmmword_1EB973F28 = xmmword_1F0FB8788;
  }
  return result;
}

float sub_1B6529CA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 84);
}

void sub_1B6529CF4(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 84) = a2;
}

float sub_1B6529D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 88);
}

void sub_1B6529D98(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 88) = a2;
}

float sub_1B6529DF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 92);
}

void sub_1B6529E3C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 92) = a2;
}

float sub_1B6529E94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 96);
}

void sub_1B6529EE0(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 96) = a2;
}

float sub_1B6529F38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 100);
}

void sub_1B6529F84(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 100) = a2;
}

uint64_t sub_1B6529FDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(unsigned __int8 *)(a1 + 104);
}

void sub_1B652A028(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(unsigned char *)(a1 + 104) = a2;
}

uint64_t sub_1B652A078()
{
  if (qword_1EB995380 != -1) {
    dispatch_once(&qword_1EB995380, &unk_1F0FB6268);
  }
  return qword_1EB995388;
}

void sub_1B652A0BC()
{
  if (!qword_1EB995388)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995388);
    qword_1EB995388 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"toeStrength", 0xB4u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"toeLength", 0xB8u, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"shoulderStrength", 0xBCu, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"shoulderLength", 0xC0u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"shoulderAngle", 0xC4u, 1, 0, 0, 0, v10, v11);
    sub_1B660E400(@"gamma", 0xC8u, 1, 0, 0, 0, v12, v13);
    sub_1B660E3EC();
  }
}

uint64_t sub_1B652A278(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(unsigned __int8 *)(a1 + 176);
}

void sub_1B652A2C4(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(unsigned char *)(a1 + 176) = a2;
  *(unsigned char *)(a1 + 72) = 0;
}

float sub_1B652A318(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 180);
}

void sub_1B652A364(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 180) = a2;
  *(unsigned char *)(a1 + 72) = 0;
}

float sub_1B652A3C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 184);
}

void sub_1B652A40C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 184) = a2;
  *(unsigned char *)(a1 + 72) = 0;
}

float sub_1B652A468(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 188);
}

void sub_1B652A4B4(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 188) = a2;
  *(unsigned char *)(a1 + 72) = 0;
}

float sub_1B652A510(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 192);
}

void sub_1B652A55C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 192) = a2;
  *(unsigned char *)(a1 + 72) = 0;
}

float sub_1B652A5B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 196);
}

void sub_1B652A604(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 196) = a2;
  *(unsigned char *)(a1 + 72) = 0;
}

float sub_1B652A660(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 200);
}

void sub_1B652A6AC(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 200) = a2;
  *(unsigned char *)(a1 + 72) = 0;
}

void sub_1B652A708(uint64_t a1, float a2)
{
  if (*(unsigned char *)(a1 + 176) != 1 && !*(unsigned char *)(a1 + 176))
  {
    float v2 = *(float *)(a1 + 92) * a2;
    if (v2 >= *(float *)(a1 + 76))
    {
      unsigned int v3 = 2;
      if (v2 < *(float *)(a1 + 80)) {
        unsigned int v3 = 1;
      }
    }
    else
    {
      unsigned int v3 = 0;
    }
    uint64_t v4 = a1 + 24 * v3;
    float v6 = *(float *)(v4 + 104);
    uint64_t v5 = (float *)(v4 + 104);
    float v7 = (float)(v2 - v6) * v5[2];
    if (v7 > 0.0)
    {
      float v9 = v5[4];
      float v8 = v5[5];
      float v10 = logf(v7);
      expf(v9 + (float)(v8 * v10));
    }
  }
}

double sub_1B652A7EC@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 20) = 0;
  *(_OWORD *)a1 = xmmword_1B6E51FB0;
  *(_DWORD *)(a1 + 16) = 1065353216;
  double result = 0.0;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(void *)(a1 + 92) = 0;
  return result;
}

__n128 sub_1B652A820@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a2, a3, a4, a5, a6, a7, (uint64_t)"effect");
  }
  if (!*(unsigned char *)(a1 + 72))
  {
    *(unsigned char *)(a1 + 72) = 1;
    float v10 = fminf(fmaxf(*(float *)(a1 + 180), -1.0), 1.0);
    float v11 = powf(fminf(fmaxf(*(float *)(a1 + 184), 0.0), 1.0), 2.2);
    float v12 = fmaxf(*(float *)(a1 + 188), 0.0);
    float v13 = fmaxf(*(float *)(a1 + 196), 0.0);
    float v14 = fmaxf(*(float *)(a1 + 200), 0.1);
    float v15 = v11 * 0.5;
    float v16 = (float)(1.0 - v10) * (float)(v11 * 0.5);
    float v17 = (float)(1.0 - fminf(fmaxf(*(float *)(a1 + 192), 0.0), 1.0)) * (float)(1.0 - v16);
    float v59 = (float)(v11 * 0.5) + v17;
    float v18 = v16 + v17;
    float v19 = (float)(exp2f(v12) + (float)((float)(v11 * 0.5) + (float)(1.0 - v16))) + -1.0;
    float v20 = v12 * (float)(v13 * (float)(v19 + v19));
    float v55 = v12 * (float)(v13 * 0.5);
    float v21 = v15 * (float)(1.0 / v19);
    float v60 = v59 * (float)(1.0 / v19);
    float v22 = 1.0;
    if ((float)(v60 - v21) != 0.0) {
      float v22 = (float)(v18 - v16) / (float)(v60 - v21);
    }
    float v57 = 1.0 / v19;
    float v58 = (float)(1.0 / v19) * v20;
    float v23 = logf(v22);
    *(float *)(a1 + 128) = (float)-(float)(v16 + (float)((float)-v22 * v21)) / v22;
    *(void *)(a1 + 132) = 0x3F80000000000000;
    *(_DWORD *)(a1 + 140) = 1065353216;
    *(float *)(a1 + 144) = v14 * v23;
    *(float *)(a1 + 148) = v14;
    float v52 = v16 - (float)(v22 * v21);
    float v50 = v14 + -1.0;
    float v51 = v14 * v22;
    float v24 = (float)(v14 * v22) * powf(v52 + (float)(v22 * v21), v14 + -1.0);
    float v25 = fmaxf(powf(v16, v14), 0.00000011921);
    float v26 = fmaxf(powf(v18, v14), 0.00000011921);
    float v27 = powf(v55 + 1.0, v14) + -1.0;
    float v28 = (float)(v21 * v24) / v25;
    float v56 = v25;
    float v29 = logf(v25);
    float v30 = logf(v21);
    *(_OWORD *)(a1 + 104) = xmmword_1B6E4F360;
    *(float *)(a1 + 120) = v29 - (float)(v28 * v30);
    *(float *)(a1 + 124) = v28;
    float v53 = v27;
    float v54 = v26;
    float v31 = v27 + 1.0;
    float v32 = (float)(v27 + 1.0) - v26;
    float v33 = 0.0;
    float v34 = 0.0;
    float v35 = 0.0;
    float v36 = 0.0;
    if (v32 > 0.0)
    {
      float v37 = powf(v52 + (float)(v22 * v60), v50);
      float v36 = v58 + 1.0;
      float v38 = (float)(v58 + 1.0) - v60;
      float v35 = (float)(v38 * (float)(v51 * v37)) / v32;
      float v39 = logf(v32);
      float v34 = v39 - (float)(v35 * logf(v38));
      float v33 = -1.0;
    }
    *(float *)(a1 + 152) = v36;
    *(float *)(a1 + 156) = v31;
    *(float *)(a1 + 160) = v33;
    *(float *)(a1 + 164) = v33;
    *(float *)(a1 + 168) = v34;
    *(float *)(a1 + 172) = v35;
    float v40 = (1.0 - v36) * v33;
    float v41 = 0.0;
    if (v40 > 0.0)
    {
      float v42 = (1.0 - v36) * v33;
      float v43 = logf(v42);
      float v41 = expf(v34 + (float)(v35 * v43));
    }
    uint64_t v44 = 0;
    float v45 = 1.0 / (float)(v53 + (float)((float)(v41 * v33) + 1.0));
    do
    {
      uint64_t v46 = a1 + v44;
      *(float *)(v46 + 108) = v45 * *(float *)(a1 + v44 + 108);
      *(float *)(v46 + 116) = v45 * *(float *)(a1 + v44 + 116);
      v44 += 24;
    }
    while (v44 != 72);
    *(float *)(a1 + 76) = v21;
    *(float *)(a1 + 80) = v60;
    *(float *)(a1 + 84) = v56;
    *(float *)(a1 + 88) = v54;
    *(float *)(a1 + 92) = v57;
    *(float *)(a1 + 96) = v58;
    *(float *)(a1 + 100) = v58;
  }
  __n128 result = *(__n128 *)(a1 + 124);
  long long v48 = *(_OWORD *)(a1 + 156);
  *(_OWORD *)(a8 + 64) = *(_OWORD *)(a1 + 140);
  *(_OWORD *)(a8 + 80) = v48;
  *(_DWORD *)(a8 + 96) = *(_DWORD *)(a1 + 172);
  long long v49 = *(_OWORD *)(a1 + 92);
  *(_OWORD *)a8 = *(_OWORD *)(a1 + 76);
  *(_OWORD *)(a8 + 16) = v49;
  *(_OWORD *)(a8 + 32) = *(_OWORD *)(a1 + 108);
  *(__n128 *)(a8 + 48) = result;
  return result;
}

uint64_t sub_1B652AB90()
{
  if (qword_1EB9952E0 != -1) {
    dispatch_once(&qword_1EB9952E0, &unk_1F0FB6308);
  }
  return qword_1EB9952E8;
}

double sub_1B652ABD4()
{
  if (!qword_1EB9952E8)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB9952E8);
    qword_1EB9952E8 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"intensity", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"threshold", 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"thresholdSmoothness", 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"useHighQuality", 0x54u, 3, 0, 0, 0, v8, v9);
    sub_1B660E400(@"colorFilter", 0x60u, 8, 0, 0, 0, v10, v11);
    sub_1B660E400(@"contrast", 0x70u, 1, 0, 0, 0, v12, v13);
    sub_1B660E400(@"saturation", 0x74u, 1, 0, 0, 0, v14, v15);
    sub_1B660E400(@"iterationCount", 0x78u, 2, 0, 0, 0, v16, v17);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB8748;
    xmmword_1EB973A18 = xmmword_1F0FB8748;
  }
  return result;
}

__n128 sub_1B652ADCC(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return a1[6];
}

void sub_1B652AE18(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[6] = a2;
}

float sub_1B652AE6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 112);
}

void sub_1B652AEB8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 112) = a2;
}

float sub_1B652AF10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 116);
}

void sub_1B652AF5C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 116) = a2;
}

uint64_t sub_1B652AFB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(void *)(a1 + 120);
}

void sub_1B652B000(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  if (a1[15] != a2)
  {
    a1[15] = a2;
    sub_1B6529128(a1);
  }
}

uint64_t sub_1B652B080()
{
  if (qword_1EB995310 != -1) {
    dispatch_once(&qword_1EB995310, &unk_1F0FB63E8);
  }
  return qword_1EB995318;
}

void sub_1B652B0C4()
{
  if (!qword_1EB995318)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995318);
    qword_1EB995318 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"saturation", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"contrast", 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"whiteBalanceTemperature", 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"whiteBalanceTint", 0x54u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"liftColor", 0x60u, 8, 0, 0, 0, v10, v11);
    sub_1B660E400(@"liftOffset", 0x70u, 1, 0, 0, 0, v12, v13);
    sub_1B660E400(@"gammaColor", 0x80u, 8, 0, 0, 0, v14, v15);
    sub_1B660E400(@"gammaOffset", 0x90u, 1, 0, 0, 0, v16, v17);
    sub_1B660E400(@"gainColor", 0xA0u, 8, 0, 0, 0, v18, v19);
    sub_1B660E400(@"gainOffset", 0xB0u, 1, 0, 0, 0, v20, v21);
    sub_1B660E400(@"lookupTable", 0xB8u, 5, 1, 0, 0, v22, v23);
    sub_1B660E3EC();
  }
}

__n128 sub_1B652B314(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return a1[8];
}

void sub_1B652B360(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[8] = a2;
}

float sub_1B652B3B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 144);
}

void sub_1B652B400(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 144) = a2;
}

__n128 sub_1B652B458(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return a1[10];
}

void sub_1B652B4A4(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[10] = a2;
}

float sub_1B652B4F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(float *)(a1 + 176);
}

void sub_1B652B544(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 176) = a2;
}

uint64_t sub_1B652B59C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(void *)(a1 + 184);
}

void sub_1B652B5E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(void *)(a1 + 184) = a2;
}

uint64_t sub_1B652B638()
{
  if (qword_1EB995390 != -1) {
    dispatch_once(&qword_1EB995390, &unk_1F0FB6528);
  }
  return qword_1EB995398;
}

double sub_1B652B67C()
{
  if (!qword_1EB995398)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995398);
    qword_1EB995398 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"intensity", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"anamorphic", 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"softness", 0x50u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"radius", 0x54u, 1, 0, 0, 0, v8, v9);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB87C8;
    xmmword_1EB974438 = xmmword_1F0FB87C8;
  }
  return result;
}

uint64_t sub_1B652B7D4()
{
  if (qword_1EB995300 != -1) {
    dispatch_once(&qword_1EB995300, &unk_1F0FB65C8);
  }
  return qword_1EB995308;
}

double sub_1B652B818()
{
  if (!qword_1EB995308)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995308);
    qword_1EB995308 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"intensity", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"strength", 0x4Cu, 1, 0, 0, 0, v4, v5);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB8768;
    xmmword_1EB973BC8 = xmmword_1F0FB8768;
  }
  return result;
}

void sub_1B652B92C(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  float v11 = a1[19];
  if (v11 != a2)
  {
    a1[19] = a2;
    if (a2 == 0.0 || v11 == 0.0)
    {
      sub_1B6529128(a1);
    }
  }
}

uint64_t sub_1B652B9C8()
{
  if (qword_1EB995360 != -1) {
    dispatch_once(&qword_1EB995360, &unk_1F0FB6668);
  }
  return qword_1EB995368;
}

double sub_1B652BA0C()
{
  if (!qword_1EB995368)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995368);
    qword_1EB995368 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"radius", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"filterQuality", 0x4Cu, 15, 0, 0, 0, v4, v5);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB87A8;
    xmmword_1EB9740D8 = xmmword_1F0FB87A8;
  }
  return result;
}

void sub_1B652BB24(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  if (a1[18] != a2)
  {
    a1[18] = a2;
    sub_1B6529128(a1);
  }
}

uint64_t sub_1B652BBB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(unsigned __int8 *)(a1 + 76);
}

void sub_1B652BBFC(unsigned char *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  if (a1[76] != a2)
  {
    a1[76] = a2;
    sub_1B6529128(a1);
  }
}

uint64_t sub_1B652BC7C()
{
  if (qword_1EB9952F0 != -1) {
    dispatch_once(&qword_1EB9952F0, &unk_1F0FB67A8);
  }
  return qword_1EB9952F8;
}

double sub_1B652BCC0()
{
  if (!qword_1EB9952F8)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB9952F8);
    qword_1EB9952F8 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"sampleCount", 0x48u, 2, 0, 0, 0, v2, v3);
    sub_1B660E400(@"intensity", 0x50u, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"center", 0x58u, 7, 0, 0, 0, v6, v7);
    sub_1B660E400(@"fromZ", 0x60u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"fromAngle", 0x64u, 1, 0, 0, 0, v10, v11);
    sub_1B660E400(@"fromShift", 0x68u, 7, 0, 0, 0, v12, v13);
    sub_1B660E400(@"toZ", 0x70u, 1, 0, 0, 0, v14, v15);
    sub_1B660E400(@"toAngle", 0x74u, 1, 0, 0, 0, v16, v17);
    sub_1B660E400(@"toShift", 0x78u, 7, 0, 0, 0, v18, v19);
    sub_1B660E400(@"color1", 0x80u, 8, 0, 0, 0, v20, v21);
    sub_1B660E400(@"color2", 0x90u, 8, 0, 0, 0, v22, v23);
    sub_1B660E400(@"color3", 0xA0u, 8, 0, 0, 0, v24, v25);
    sub_1B660E400(@"maskCenter", 0xB0u, 7, 0, 0, 0, v26, v27);
    sub_1B660E400(@"maskRadius", 0xB8u, 1, 0, 0, 0, v28, v29);
    sub_1B660E400(@"maskEnabled", 0xBCu, 3, 0, 0, 0, v30, v31);
    sub_1B660E400(@"unMultBlending", 0xC0u, 1, 0, 0, 0, v32, v33);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB8758;
    xmmword_1EB973AF0 = xmmword_1F0FB8758;
  }
  return result;
}

uint64_t sub_1B652BFEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(void *)(a1 + 72);
}

void sub_1B652C038(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(void *)(a1 + 72) = a2;
}

void sub_1B652C088(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  float v11 = a1[20];
  if (v11 != a2)
  {
    a1[20] = a2;
    if (a2 == 0.0 || v11 == 0.0)
    {
      sub_1B6529128(a1);
    }
  }
}

double sub_1B652C124(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(double *)(a1 + 88);
}

void sub_1B652C170(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(double *)(a1 + 88) = a2;
}

double sub_1B652C1C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(double *)(a1 + 104);
}

void sub_1B652C214(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(double *)(a1 + 104) = a2;
}

double sub_1B652C26C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(double *)(a1 + 120);
}

void sub_1B652C2B8(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(double *)(a1 + 120) = a2;
}

__n128 sub_1B652C310(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return a1[9];
}

void sub_1B652C35C(__n128 *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = a2;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
    a2 = v10;
  }
  a1[9] = a2;
}

double sub_1B652C3B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(double *)(a1 + 176);
}

void sub_1B652C3FC(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(double *)(a1 + 176) = a2;
}

void sub_1B652C454(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 184) = a2;
}

uint64_t sub_1B652C4AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(unsigned __int8 *)(a1 + 188);
}

void sub_1B652C4F8(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(unsigned char *)(a1 + 188) = a2;
}

void sub_1B652C548(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(float *)(a1 + 192) = a2;
}

uint64_t sub_1B652C5A0()
{
  if (qword_1EB995330 != -1) {
    dispatch_once(&qword_1EB995330, &unk_1F0FB68E8);
  }
  return qword_1EB995338;
}

double sub_1B652C5E4()
{
  if (!qword_1EB995338)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB995338);
    qword_1EB995338 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"radius", 0x48u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"maskCenter", 0x50u, 7, 0, 0, 0, v4, v5);
    sub_1B660E400(@"maskRadius", 0x58u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"maskEnabled", 0x5Cu, 3, 0, 0, 0, v8, v9);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB8778;
    xmmword_1EB973E50 = xmmword_1F0FB8778;
  }
  return result;
}

double sub_1B652C744(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(double *)(a1 + 80);
}

void sub_1B652C790(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  *(double *)(a1 + 80) = a2;
}

uint64_t sub_1B652C7E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  return *(unsigned __int8 *)(a1 + 92);
}

void sub_1B652C834(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"self");
  }
  *(unsigned char *)(a1 + 92) = a2;
}

uint64_t sub_1B652C884()
{
  if (qword_1E9DDB218 != -1) {
    dispatch_once(&qword_1E9DDB218, &unk_1F0FB6A28);
  }
  return qword_1E9DDB210;
}

void sub_1B652C8C8()
{
  if (!qword_1E9DDB210)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1E9DDB210);
    qword_1E9DDB210 = (uint64_t)v0;
    CFDictionaryRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"radius", 0x4Cu, 1, 0, 0, 0, v2, v3);
    sub_1B660E3EC();
  }
}

void sub_1B652C9C0(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  if (a1[19] != a2)
  {
    a1[19] = a2;
    sub_1B6529128(a1);
  }
}

void sub_1B652CA4C(float *a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"self");
  }
  if (a1[20] != a2)
  {
    a1[20] = a2;
    sub_1B6529128(a1);
  }
}

CFStringRef sub_1B652CAE0(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect depthOfField:%p", a1);
}

CFStringRef sub_1B652CB20(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect depthOfField:%p", a1);
}

CFStringRef sub_1B652CB68(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect MotionBlur:%p", a1);
}

CFStringRef sub_1B652CBA8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect MotionBlur:%p", a1);
}

void sub_1B652CBE8(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B6529644(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

id sub_1B652CC10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(const void **)(a1 + 88);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 88) = 0;
  }

  return sub_1B658325C(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B652CC54(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Grain:%p", a1);
}

CFStringRef sub_1B652CC94(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Grain:%p", a1);
}

void sub_1B652CCD4(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B6529644(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652CD00(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Exposure:%p", a1);
}

CFStringRef sub_1B652CD40(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Exposure:%p", a1);
}

void sub_1B652CD80(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B6529644(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652CDAC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ToneMapping:%p", a1);
}

CFStringRef sub_1B652CDEC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ToneMapping:%p", a1);
}

CFStringRef sub_1B652CE34(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Bloom:%p", a1);
}

CFStringRef sub_1B652CE74(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Bloom:%p", a1);
}

void sub_1B652CEB4(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B6529644(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652CEE0(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ColorGrading:%p", a1);
}

CFStringRef sub_1B652CF20(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ColorGrading:%p", a1);
}

CFStringRef sub_1B652CF68(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Vignetting:%p", a1);
}

CFStringRef sub_1B652CFA8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect Vignetting:%p", a1);
}

void sub_1B652CFE8(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B6529644(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652D014(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ColorFringe:%p", a1);
}

CFStringRef sub_1B652D054(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ColorFringe:%p", a1);
}

void sub_1B652D094(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B6529644(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652D0C0(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect LensBlur:%p", a1);
}

CFStringRef sub_1B652D100(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect LensBlur:%p", a1);
}

void sub_1B652D140(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B652BB24(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652D16C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ChromaticTransform:%p", a1);
}

CFStringRef sub_1B652D1AC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect ChromaticTransform:%p", a1);
}

void sub_1B652D1EC(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 20 == __dst) {
    sub_1B652C088(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652D218(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect DoughnutBokeh:%p", a1);
}

CFStringRef sub_1B652D258(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect DoughnutBokeh:%p", a1);
}

void sub_1B652D298(float *a1, float *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 18 == __dst) {
    sub_1B6529644(a1, *__src, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

CFStringRef sub_1B652D2C4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect SSAO:%p", a1);
}

CFStringRef sub_1B652D304(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXCameraEffect SSAO:%p", a1);
}

uint64_t sub_1B652D5B4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_semantic(a2, (const char *)a2, a3, a4);
  uint64_t result = objc_msgSend_isEqualToString_(v6, v7, @"kGeometrySourceSemanticNormal", v8);
  if ((result & 1) == 0)
  {
    uint64_t v12 = *(void **)(a1 + 32);
    return objc_msgSend_addObject_(v12, v10, (uint64_t)a2, v11);
  }
  return result;
}

uint64_t sub_1B652E148(void *a1, void *a2, void *a3)
{
  uint64_t v3 = a1[1];
  uint64_t v4 = a1[2];
  float v5 = *(float *)(*a1 + v3 + v4 * *a2);
  float v6 = *(float *)(*a1 + v3 + v4 * *a3);
  if (v6 > v5) {
    unsigned int v7 = 1;
  }
  else {
    unsigned int v7 = -1;
  }
  if (v6 == v5) {
    return 0;
  }
  else {
    return v7;
  }
}

uint64_t sub_1B652E3A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F0FB4198;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(void *)(a1 + 688) = 0;
  *(void *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 736) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(unsigned char *)(a1 + 720) = 0;
  *(void *)(a1 + 16) = a2;
  uint64_t v9 = sub_1B644558C(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 24) = v9;
  uint64_t v17 = sub_1B64B28FC(v9, v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 32) = v17;
  *(_WORD *)(a1 + 48) = 15;
  sub_1B6624920(v17, 0xFu);
  return a1;
}

void sub_1B652E48C(_Unwind_Exception *a1)
{
  sub_1B644E78C(v4, 0);
  sub_1B6E306F8(v3, v2, v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B652E4B4(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB4198;
  sub_1B6624994(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 48));
  sub_1B644E78C((CFX::RG::Resource **)(a1 + 728), 0);
  for (uint64_t i = 712; i != 696; i -= 8)
  {
    uint64_t v3 = *(void **)(a1 + i);
    if (v3) {
  }
    }
  uint64_t v4 = *(void **)(a1 + 688);
  if (v4) {

  }
  return a1;
}

void sub_1B652E534(_Unwind_Exception *a1)
{
  sub_1B644E78C((CFX::RG::Resource **)(v1 + 728), 0);
  sub_1B6E3086C(v1 + 720, v1 + 704, v1);
  _Unwind_Resume(a1);
}

void sub_1B652E560(uint64_t a1)
{
  sub_1B652E4B4(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B652E598(uint64_t a1, CFX::RG::RenderGraphContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 16), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = objc_msgSend_resourceManager(v11, v12, v13, v14);
  uint64_t v23 = sub_1B644558C(*(void *)(a1 + 16), v16, v17, v18, v19, v20, v21, v22);
  uint64_t v31 = sub_1B6446564(*(uint64_t **)(a1 + 16), v24, v25, v26, v27, v28, v29, v30);
  if (v31 && sub_1B64A3B48((uint64_t)v31, v32, v33, v34, v35, v36, v37, v38))
  {
    BOOL v39 = sub_1B64B2810(v23, 0) != 0;
    BOOL v94 = v39;
    unsigned int v93 = sub_1B6626FAC(*(void *)(a1 + 32));
    BOOL v40 = sub_1B6626FBC(*(void *)(a1 + 32)) != 0;
    unsigned int v91 = *(_DWORD *)(a3 + 172);
    BOOL v92 = v40;
    unint64_t v41 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v93) ^ ((0x9DDFEA08EB382D69 * v93) >> 47));
    unint64_t v42 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ v40)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ v40)));
    unint64_t v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    unint64_t v44 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) ^ ((0x9DDFEA08EB382D69 * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) >> 47));
    unint64_t v45 = 0x9DDFEA08EB382D69
        * (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v91)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v91)));
    unint64_t v46 = 0x9DDFEA08EB382D69 * (v45 ^ (v45 >> 47));
    if (*(void *)(a1 + 680) != v46)
    {
      *(void *)(a1 + 680) = v46;
      sub_1B6626AF8(*(void *)(a1 + 32), *(void *)(a1 + 16));
      id v47 = objc_alloc_init(MEMORY[0x1E4F35228]);
      objc_msgSend_setConstantValue_type_withName_(v47, v48, (uint64_t)&v93, 33, @"LightCount");
      objc_msgSend_setConstantValue_type_withName_(v47, v49, (uint64_t)&v94, 53, @"has_IBL");
      objc_msgSend_setConstantValue_type_withName_(v47, v50, (uint64_t)&v92, 33, @"raytracing_use_function_constant");
      objc_msgSend_setConstantValue_type_withName_(v47, v51, (uint64_t)&v91, 33, @"quality_mode");
      uint64_t v52 = sub_1B6626EDC(*(void *)(a1 + 32));
      uint64_t v54 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_linkedFunctions_(v15, v53, @"vfx_rt_clearcoat_trace", (uint64_t)v47, v52);

      float v55 = *(void **)(a1 + 688);
      if (v55 != (void *)v54)
      {
        if (v55) {

        }
        *(void *)(a1 + 688) = v54;
      }
      *(_DWORD *)(a1 + 588) = 0;
      sub_1B6626E64(*(void *)(a1 + 32));
    }
    float v56 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, *(const CFX::RG::Resource **)(a3 + 248));
    uint64_t v60 = *v56;
    uint64_t v61 = v56[1];
    unint64_t v62 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v60) ^ ((0x9DDFEA08EB382D69 * v60) >> 47));
    unint64_t v63 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)));
    unint64_t v64 = 0x9DDFEA08EB382D69 * (v63 ^ (v63 >> 47));
    if (*(void *)(a1 + 696) != v64)
    {
      *(void *)(a1 + 696) = v64;
      unsigned int v65 = v60 >> 1;
      unsigned int v66 = v61 >> 1;
      unsigned int v67 = (v61 >> 1) * (v60 >> 1);
      uint64_t v68 = objc_msgSend_device(v11, v57, v58, v59);
      uint64_t v69 = 96 * v67;
      uint64_t v71 = objc_msgSend_newBufferWithLength_options_(v68, v70, v69, 32);
      float32x4_t v75 = *(void **)(a1 + 704);
      if (v75 != (void *)v71)
      {
        uint64_t v76 = v71;
        if (v75) {

        }
        *(void *)(a1 + 704) = v76;
      }
      float32x4_t v77 = objc_msgSend_device(v11, v72, v73, v74);
      uint64_t v79 = objc_msgSend_newBufferWithLength_options_(v77, v78, v69, 32);
      float32x4_t v80 = *(void **)(a1 + 712);
      if (v80 != (void *)v79)
      {
        uint64_t v81 = v79;
        if (v80) {

        }
        *(void *)(a1 + 712) = v81;
      }
      *(_DWORD *)(a1 + 588) = 0;
      long long v89 = 0u;
      long long v90 = 0u;
      long long v87 = 0u;
      long long v88 = 0u;
      long long v86 = 0u;
      if (v65 <= 1) {
        __int16 v82 = 1;
      }
      else {
        __int16 v82 = v65;
      }
      if (v66 <= 1) {
        __int16 v83 = 1;
      }
      else {
        __int16 v83 = v66;
      }
      RGTextureDescriptorMake2D(v82, v83, 25, (uint64_t)&v86);
      CFX::RG::RenderGraphContext::currentBuilder(a2);
      v85[2] = v88;
      v85[3] = v89;
      v85[4] = v90;
      v85[0] = v86;
      v85[1] = v87;
      float32x4_t v96 = "distanceTex";
      char v95 = 2;
      sub_1B6458BE8((uint64_t *)&v96, (uint64_t)v85, &v95);
      sub_1B644E78C((CFX::RG::Resource **)(a1 + 728), v84);
    }
    *(unsigned char *)(a1 + 720) ^= 1u;
  }
}

uint64_t *sub_1B652E900(uint64_t *a1, uint64_t a2, uint64_t a3, CFX::RG::RenderGraphContext *a4, uint64_t a5)
{
  uint64_t v8 = *(void *)a5;
  v33[0] = (uint64_t)"RTClearCoatTracePass";
  v33[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB228, memory_order_acquire) & 1) == 0)
  {
    uint64_t v32 = a3;
    uint64_t v30 = a2;
    int v31 = __cxa_guard_acquire(&qword_1E9DDB228);
    a2 = v30;
    a3 = v32;
    if (v31)
    {
      qword_1E9DDB220 = (uint64_t)sub_1B6530528("RT_CLEARCOAT_TRACE", 0x12u);
      __cxa_guard_release(&qword_1E9DDB228);
      a2 = v30;
      a3 = v32;
    }
  }
  sub_1B653860C((uint64_t)a1, a2, a3, v33, qword_1E9DDB220, 0);
  *a1 = (uint64_t)&unk_1F0FB41B8;
  a1[47] = a5;
  a1[48] = 0;
  a1[49] = 0;
  a1[50] = 0;
  uint64_t v16 = (void *)sub_1B6445900(a1[46], v9, v10, v11, v12, v13, v14, v15);
  a1[49] = (uint64_t)v16;
  a1[50] = objc_msgSend_resourceManager(v16, v17, v18, v19);
  uint64_t v20 = (CFX::CrossFrameResourceManager *)*((void *)a4 + 4);
  unint64_t v21 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v22 = CFX::CrossFrameResourceManager::get(v20, v21);
  a1[48] = v22;
  if (!v22)
  {
    CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    v33[0] = a1[46];
    sub_1B652EADC();
  }
  sub_1B652E598(v22, a4, a5, v23, v24, v25, v26, v27);
  uint64_t v28 = a1[48];
  *(void *)(a1[47] + 312) = v28 + 64;
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(v28 + 728));
  CFX::RG::Pass::writeTo(a1, *(CFX::RG::Resource **)(a1[48] + 728));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a1[47] + 264));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a5 + 248));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a5 + 176));
  return a1;
}

void sub_1B652EAC4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B652EADC()
{
}

void sub_1B652EB44(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A1C40D943C058);
  _Unwind_Resume(a1);
}

void sub_1B652EB6C(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)(a1 + 384) + 688))
  {
    uint64_t v10 = *a3;
    uint64_t v11 = sub_1B644558C(*(void *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    uint64_t v19 = sub_1B6446564(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      if (sub_1B64A3B48((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26))
      {
        uint64_t v34 = sub_1B6446564(*(uint64_t **)(a1 + 368), v27, v28, v29, v30, v31, v32, v33);
        sub_1B63E0460((uint64_t)v34, (uint64_t)v183, v35, v36, v37, v38, v39, v40);
        unint64_t v41 = (long long *)sub_1B6447988(*(void *)(a1 + 368), 1);
        long long v176 = v41[1];
        long long v177 = *v41;
        long long v174 = v41[3];
        long long v175 = v41[2];
        __n128 v182 = sub_1B64471F4(*(void *)(a1 + 368), 0, v42, v43, v44, v45, v46, v47);
        uint64_t v179 = sub_1B64B28FC(v11, v48, v49, v50, v51, v52, v53, v54);
        sub_1B6626AF8(v179, *(void *)(a1 + 368));
        id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 256));
        id v56 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 248));
        id v57 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 272));
        id v58 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 176));
        id v59 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 264));
        uint64_t v60 = *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 280);
        uint64_t v178 = v11;
        if (v60) {
          id v61 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v60);
        }
        else {
          id v61 = 0;
        }
        id v62 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 384) + 728));
        objc_msgSend_setTexture_atIndex_(v10, v63, (uint64_t)Texture, 0);
        objc_msgSend_setTexture_atIndex_(v10, v64, (uint64_t)v56, 1);
        objc_msgSend_setTexture_atIndex_(v10, v65, (uint64_t)v57, 2);
        objc_msgSend_setTexture_atIndex_(v10, v66, (uint64_t)v58, 3);
        objc_msgSend_setTexture_atIndex_(v10, v67, (uint64_t)v59, 4);
        objc_msgSend_setTexture_atIndex_(v10, v68, (uint64_t)v62, 7);
        objc_msgSend_setTexture_atIndex_(v10, v69, (uint64_t)v61, 10);
        uint64_t v70 = sub_1B64B2810(v178, 0);
        if (v70)
        {
          uint64_t v74 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 392), v71, v70, v73);
          if (v74) {
            objc_msgSend_setTexture_atIndex_(v10, v75, v74, 6);
          }
        }
        float32x2_t v180 = sub_1B6447FE4(**(float32x2_t ***)(a1 + 376), 0, v72, v73);
        uint64_t v76 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        v76[8] = v177;
        v76[9] = v176;
        v76[10] = v175;
        v76[11] = v174;
        __int16 v83 = sub_1B649CD50(v183, (uint64_t)&v182, v77, v78, v79, v80, v81, v82);
        uint64_t v84 = 0;
        long long v85 = *((_OWORD *)v83 + 1);
        long long v86 = *((_OWORD *)v83 + 2);
        long long v87 = *((_OWORD *)v83 + 3);
        long long v88 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        v88[20] = *(_OWORD *)v83;
        v88[21] = v85;
        v88[22] = v86;
        v88[23] = v87;
        long long v89 = *(float32x4_t **)(a1 + 384);
        float32x4_t v90 = v89[24];
        float32x4_t v91 = v89[25];
        float32x4_t v92 = v89[26];
        float32x4_t v93 = v89[27];
        float32x4_t v94 = v89[13];
        float32x4_t v95 = v89[14];
        float32x4_t v96 = v89[15];
        v184[0] = v89[12];
        v184[1] = v94;
        v184[2] = v95;
        v184[3] = v96;
        do
        {
          v185[v84] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v90, COERCE_FLOAT(*(_OWORD *)&v184[v84])), v91, *(float32x2_t *)v184[v84].f32, 1), v92, v184[v84], 2), v93, v184[v84], 3);
          ++v84;
        }
        while (v84 != 4);
        long long v97 = v185[1];
        long long v98 = v185[2];
        long long v99 = v185[3];
        uint64_t v100 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        *uint64_t v100 = v185[0];
        v100[1] = v97;
        v100[2] = v98;
        v100[3] = v99;
        *(simd_float4x4 *)(*(void *)(*(void *)(a1 + 376) + 312) + 192) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 384) + 192));
        *(simd_float4x4 *)(*(void *)(*(void *)(a1 + 376) + 312) + 384) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 384) + 64));
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 512) = (float)((float)(unint64_t)objc_msgSend_width(v56, v101, v102, v103)
                                                                               * v180.f32[0])
                                                                       * 0.5;
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 516) = vmuls_lane_f32((float)(unint64_t)objc_msgSend_height(v56, v104, v105, v106), v180, 1)* 0.5;
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 528) = *(_OWORD *)(*(void *)(a1 + 376) + 208);
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 544) = *(_OWORD *)(*(void *)(a1 + 376) + 224);
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 576) = *(_OWORD *)(*(void *)(a1 + 376) + 192);
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 560) = (float)*(int *)(*(void *)(a1 + 376) + 184);
        uint64_t v107 = sub_1B64B2810(v178, 0);
        if (v107) {
          float v115 = sub_1B64763AC(v107, (uint64_t)v108, v109, v110, v111, v112, v113, v114);
        }
        else {
          float v115 = 0.0;
        }
        uint64_t v116 = *(void *)(*(void *)(a1 + 376) + 312);
        *(float *)(v116 + 592) = v115;
        objc_msgSend_setBytes_length_atIndex_(v10, v108, v116, 608, 8);
        objc_msgSend_setTexture_atIndex_(v10, v117, *(void *)(*(void *)(a1 + 384) + 672), 9);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v118, *(void *)(*(void *)(a1 + 384) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 720) + 704), 0, 10);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v119, *(void *)(*(void *)(a1 + 384) + 8 * (*(unsigned char *)(*(void *)(a1 + 384) + 720) == 0) + 704), 0, 11);
        uint64_t v120 = sub_1B6626EB4(v179);
        objc_msgSend_useHeap_(v10, v121, v120, v122);
        uint64_t v123 = sub_1B6626EC4(v179);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v124, v123, 0, 0);
        uint64_t v125 = sub_1B6626EBC(v179);
        objc_msgSend_setAccelerationStructure_atBufferIndex_(v10, v126, v125, 1);
        if (sub_1B6626FAC(v179))
        {
          uint64_t v127 = sub_1B6626ECC(v179);
          objc_msgSend_setBuffer_offset_atIndex_(v10, v128, v127, 0, 2);
        }
        if (sub_1B6626FBC(v179))
        {
          uint64_t v135 = *(void *)(a1 + 384);
          uint64_t v136 = *(void *)(v135 + 688);
          if (!v136)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v129, v130, v131, v132, v133, v134, (uint64_t)"_ptr != NULL");
            uint64_t v136 = *(void *)(v135 + 688);
          }
          uint64_t v137 = (void *)sub_1B653EFB8(v136);
          int v138 = sub_1B6626EE4(v179, v137);
          objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v10, v139, (uint64_t)v138, 3);
        }
        else
        {
          int v138 = 0;
        }
        uint64_t v140 = sub_1B6626ED4(v179);
        unsigned int v144 = sub_1B6626FCC(v179, v141, v142, v143);
        objc_msgSend_useResources_count_usage_(v10, v145, v140, v144, 1);
        uint64_t v152 = *(void *)(a1 + 384);
        uint64_t v153 = *(void *)(v152 + 688);
        if (!v153)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v146, v147, v148, v149, v150, v151, (uint64_t)"_ptr != NULL");
          uint64_t v153 = *(void *)(v152 + 688);
        }
        uint64_t v154 = sub_1B653EFB8(v153);
        objc_msgSend_setComputePipelineState_(v10, v155, v154, v156);
        unint64_t v160 = (unint64_t)objc_msgSend_width(v56, v157, v158, v159) >> 1;
        unint64_t v170 = (unint64_t)objc_msgSend_height(v56, v161, v162, v163) >> 1;
        uint64_t v171 = *(void *)(a1 + 384);
        uint64_t v172 = *(void *)(v171 + 688);
        if (!v172)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v164, v165, v166, v167, v168, v169, (uint64_t)"_ptr != NULL");
          uint64_t v172 = *(void *)(v171 + 688);
        }
        uint64_t v173 = (void *)sub_1B653EFB8(v172);
        v181[0] = v160;
        v181[1] = v170;
        v181[2] = 1;
        RGMTLComputeCommandEncoderDispatchOnGrid2D(v10, v173, (uint64_t)v181, 1);

        ++*(_DWORD *)(*(void *)(a1 + 384) + 736);
        sub_1B6626E64(v179);
      }
    }
  }
}

uint64_t sub_1B652F16C(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  uint64_t v33 = "RTClearCoatSpatialReSTIRPass";
  uint64_t v34 = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB238, memory_order_acquire) & 1) == 0)
  {
    uint64_t v30 = a3;
    uint64_t v31 = a2;
    int v32 = __cxa_guard_acquire(&qword_1E9DDB238);
    a2 = v31;
    a3 = v30;
    if (v32)
    {
      qword_1E9DDB230 = (uint64_t)sub_1B6530528("RT_CLEARCOAT_SPATIAL_RESTIR", 0x1Bu);
      __cxa_guard_release(&qword_1E9DDB238);
      a2 = v31;
      a3 = v30;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)&v33, qword_1E9DDB230, 0);
  *(void *)a1 = &unk_1F0FB4AD0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(void *)(a1 + 416) = 0;
  uint64_t v9 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[31]);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  uint64_t v19 = (void *)sub_1B6445900(*(void *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  *(void *)(a1 + 408) = v19;
  *(void *)(a1 + 416) = objc_msgSend_resourceManager(v19, v20, v21, v22, v33, v34);
  unint64_t v23 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v24 = CFX::CrossFrameResourceManager::get(a4[4], v23);
  *(void *)(a1 + 384) = v24;
  if (!v24) {
    operator new();
  }
  unint64_t v25 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v26 = 0x9DDFEA08EB382D69
      * (v25 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v10)));
  unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  uint64_t v28 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v27 ^ ((0x9DDFEA08EB382D69 * (v27 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v27 ^ v11)))) ^ ((0x9DDFEA08EB382D69 * (v27 ^ ((0x9DDFEA08EB382D69 * (v27 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v27 ^ v11)))) >> 47)));
  *(void *)(a1 + 392) = v28;
  if (!v28) {
    operator new();
  }
  return a1;
}

void sub_1B652F4F8(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B652F520(uint64_t result, uint64_t a2, void **a3)
{
  uint64_t v3 = *(void *)(result + 384);
  if (*(void *)(v3 + 16) && *(void *)(v3 + 24))
  {
    uint64_t v5 = result;
    float v6 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(result + 376) + 312), 608, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v5 + 376) + 256));
    id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v5 + 376) + 248));
    id v9 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v5 + 400));
    objc_msgSend_setTexture_atIndex_(v6, v10, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v6, v11, (uint64_t)v8, 1);
    objc_msgSend_setTexture_atIndex_(v6, v12, (uint64_t)v9, 2);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v13, *(void *)(*(void *)(v5 + 376) + 296), 0, 0);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v14, *(void *)(*(void *)(v5 + 392) + 16), 0, 1);
    uint64_t v21 = *(void *)(v5 + 384);
    uint64_t v22 = *(void *)(v21 + 16);
    if (!v22)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
      uint64_t v22 = *(void *)(v21 + 16);
    }
    uint64_t v23 = sub_1B653EFB8(v22);
    objc_msgSend_setComputePipelineState_(v6, v24, v23, v25);
    unint64_t v29 = (unint64_t)objc_msgSend_width(v8, v26, v27, v28) >> 1;
    unint64_t v39 = (unint64_t)objc_msgSend_height(v8, v30, v31, v32) >> 1;
    uint64_t v40 = *(void *)(v5 + 384);
    uint64_t v41 = *(void *)(v40 + 16);
    if (!v41)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v33, v34, v35, v36, v37, v38, (uint64_t)"_ptr != NULL");
      uint64_t v41 = *(void *)(v40 + 16);
    }
    uint64_t v42 = (void *)sub_1B653EFB8(v41);
    v66[0] = v29;
    v66[1] = v39;
    UInt8 v66[2] = 1;
    RGMTLComputeCommandEncoderDispatchOnGrid2D(v6, v42, (uint64_t)v66, 1);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v43, *(void *)(*(void *)(v5 + 392) + 16), 0, 0);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v44, *(void *)(*(void *)(v5 + 392) + 24), 0, 1);
    uint64_t v51 = *(void *)(v5 + 384);
    uint64_t v52 = *(void *)(v51 + 24);
    if (!v52)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v45, v46, v47, v48, v49, v50, (uint64_t)"_ptr != NULL");
      uint64_t v52 = *(void *)(v51 + 24);
    }
    uint64_t v53 = sub_1B653EFB8(v52);
    objc_msgSend_setComputePipelineState_(v6, v54, v53, v55);
    uint64_t v62 = *(void *)(v5 + 384);
    uint64_t v63 = *(void *)(v62 + 24);
    if (!v63)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v56, v57, v58, v59, v60, v61, (uint64_t)"_ptr != NULL");
      uint64_t v63 = *(void *)(v62 + 24);
    }
    unint64_t v64 = (void *)sub_1B653EFB8(v63);
    v65[0] = v29;
    v65[1] = v39;
    v65[2] = 1;
    return RGMTLComputeCommandEncoderDispatchOnGrid2D(v6, v64, (uint64_t)v65, 1);
  }
  return result;
}

uint64_t sub_1B652F784(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  v48[0] = (uint64_t)"RTClearCoatUpscalePass";
  v48[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB248, memory_order_acquire) & 1) == 0)
  {
    uint64_t v45 = a3;
    uint64_t v43 = a2;
    int v44 = __cxa_guard_acquire(&qword_1E9DDB248);
    a2 = v43;
    a3 = v45;
    if (v44)
    {
      qword_1E9DDB240 = (uint64_t)sub_1B6530528("RT_CLEARCOAT_UPSCALE", 0x14u);
      __cxa_guard_release(&qword_1E9DDB248);
      a2 = v43;
      a3 = v45;
    }
  }
  sub_1B653860C(a1, a2, a3, v48, qword_1E9DDB240, 0);
  *(void *)a1 = &unk_1F0FB44E0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(void *)(a1 + 416) = 0;
  uint64_t v16 = (void *)sub_1B6445900(*(void *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
  *(void *)(a1 + 408) = v16;
  *(void *)(a1 + 416) = objc_msgSend_resourceManager(v16, v17, v18, v19);
  unint64_t v20 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v21 = CFX::CrossFrameResourceManager::get(a4[4], v20);
  *(void *)(a1 + 384) = v21;
  if (!v21)
  {
    *(void *)(a1 + 384) = sub_1B652F99C(a4[4], v20);
    unint64_t v29 = (void *)sub_1B6445900(*(void *)(a1 + 368), v22, v23, v24, v25, v26, v27, v28);
    uint64_t v33 = objc_msgSend_resourceManager(v29, v30, v31, v32);
    uint64_t v34 = *(void *)(a1 + 384);
    uint64_t v37 = objc_msgSend_newComputePipelineStateWithFunctionName_(v33, v35, @"vfx_rt_clearcoat_upscale", v36);
    uint64_t v38 = *(void **)(v34 + 16);
    if (v38 != (void *)v37)
    {
      if (v38) {

      }
      *(void *)(v34 + 16) = v37;
    }
  }
  unint64_t v39 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  uint64_t v40 = (CFX::RG::TextureDescriptorReference *)(a5 + 1);
  CFX::RG::TextureDescriptorReference::withPixelFormat(v40, MTLPixelFormatRGBA16Float, (uint64_t)v47);
  *(void *)(a1 + 392) = sub_1B63CFDE4(v39, (uint64_t)"ClearCoatUpscale", v47);
  uint64_t v41 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  CFX::RG::TextureDescriptorReference::withPixelFormat(v40, MTLPixelFormatR16Float, (uint64_t)v46);
  *(void *)(a1 + 400) = sub_1B63CFDE4(v41, (uint64_t)"ClearCoatUpscaleDistance", v46);
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 392));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 400));
  return a1;
}

void sub_1B652F97C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B652F99C(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B652FA28(uint64_t result, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(result + 384) + 16))
  {
    uint64_t v4 = result;
    uint64_t v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(result + 376) + 312), 608, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 256));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 248));
    objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
    objc_msgSend_setBuffer_offset_atIndex_(v5, v10, *(void *)(*(void *)(v4 + 376) + 304), 0, 0);
    id v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 392));
    objc_msgSend_setTexture_atIndex_(v5, v12, (uint64_t)v11, 10);
    id v13 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 400));
    objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)v13, 11);
    uint64_t v21 = *(void *)(v4 + 384);
    uint64_t v22 = *(void *)(v21 + 16);
    if (!v22)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
      uint64_t v22 = *(void *)(v21 + 16);
    }
    uint64_t v24 = sub_1B653EFB8(v22);
    return objc_msgSend_dispatch_onTexture2D_(v5, v23, v24, (uint64_t)v11);
  }
  return result;
}

uint64_t sub_1B652FB8C(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v9 = *a5;
  *(void *)&v35[0] = "RTClearCoatTemporalDenoisePass";
  *((void *)&v35[0] + 1) = v9;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB258, memory_order_acquire) & 1) == 0)
  {
    uint64_t v33 = a3;
    int v34 = __cxa_guard_acquire(&qword_1E9DDB258);
    a3 = v33;
    if (v34)
    {
      qword_1E9DDB250 = (uint64_t)sub_1B6530528("RT_CLEARCOAT_TEMPORAL_DENOISE", 0x1Du);
      __cxa_guard_release(&qword_1E9DDB258);
      a3 = v33;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)v35, qword_1E9DDB250, 0);
  *(void *)a1 = &unk_1F0FB4C60;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  uint64_t v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 416) = v17;
  *(void *)(a1 + 424) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  uint64_t v21 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[31]);
  unsigned int v22 = *v21;
  unsigned int v23 = v21[1];
  unint64_t v24 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v25 = CFX::CrossFrameResourceManager::get(a4[4], v24);
  *(void *)(a1 + 384) = v25;
  if (!v25) {
    operator new();
  }
  memset(v35, 0, sizeof(v35));
  if (v22 <= 1) {
    __int16 v26 = 1;
  }
  else {
    __int16 v26 = v22;
  }
  if (v23 <= 1) {
    __int16 v27 = 1;
  }
  else {
    __int16 v27 = v23;
  }
  RGTextureDescriptorMake2D(v26, v27, 115, (uint64_t)v35);
  unint64_t v28 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v29 = 0x9DDFEA08EB382D69
      * (v28 ^ ((0x9DDFEA08EB382D69 * (v28 ^ LOWORD(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ LOWORD(v35[0]))));
  unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47));
  uint64_t v31 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v30 ^ ((0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))))) ^ ((0x9DDFEA08EB382D69 * (v30 ^ ((0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))))) >> 47)));
  *(void *)(a1 + 392) = v31;
  if (!v31) {
    operator new();
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 376) + 264));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 392) + 8 * (*(unsigned char *)(*(void *)(a1 + 384) + 24) == 0) + 16));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 392) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 24) + 16));
  return a1;
}

void sub_1B652FF30(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1B652FF5C(uint64_t a1, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(a1 + 384) + 16))
  {
    uint64_t v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(a1 + 376) + 312), 608, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 408));
    id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 256));
    uint64_t v9 = *(void *)(a1 + 376);
    uint64_t v10 = *(const CFX::RG::Resource **)(v9 + 280);
    if (v10)
    {
      id v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v10);
      uint64_t v9 = *(void *)(a1 + 376);
    }
    else
    {
      id v11 = 0;
    }
    id v12 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 264));
    id v13 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 248));
    objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v15, (uint64_t)v8, 1);
    objc_msgSend_setTexture_atIndex_(v5, v16, (uint64_t)v11, 2);
    objc_msgSend_setTexture_atIndex_(v5, v17, (uint64_t)v12, 3);
    objc_msgSend_setTexture_atIndex_(v5, v18, (uint64_t)v13, 4);
    objc_msgSend_setTexture_atIndex_(v5, v19, (uint64_t)v7, 5);
    id v20 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 392)+ 8 * (*(unsigned char *)(*(void *)(a1 + 384) + 24) == 0)+ 16));
    id v21 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 392)+ 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 24)+ 16));
    objc_msgSend_setTexture_atIndex_(v5, v22, (uint64_t)v21, 10);
    objc_msgSend_setTexture_atIndex_(v5, v23, (uint64_t)v20, 11);
    uint64_t v30 = *(void *)(a1 + 384);
    uint64_t v31 = *(void *)(v30 + 16);
    if (!v31)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v24, v25, v26, v27, v28, v29, (uint64_t)"_ptr != NULL");
      uint64_t v31 = *(void *)(v30 + 16);
    }
    uint64_t v32 = sub_1B653EFB8(v31);
    objc_msgSend_dispatch_onTexture2D_(v5, v33, v32, (uint64_t)v21);
    int v34 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
    long long v35 = v34[13];
    v34[16] = v34[12];
    v34[17] = v35;
    long long v36 = v34[15];
    v34[18] = v34[14];
    v34[19] = v36;
    uint64_t v37 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
    long long v38 = v37[1];
    v37[4] = *v37;
    void v37[5] = v38;
    long long v39 = v37[3];
    v37[6] = v37[2];
    v37[7] = v39;
    uint64_t v40 = *(void *)(*(void *)(a1 + 376) + 312);
    long long v41 = *(_OWORD *)(v40 + 400);
    *(_OWORD *)(v40 + 448) = *(_OWORD *)(v40 + 384);
    *(_OWORD *)(v40 + 464) = v41;
    __n128 result = *(__n128 *)(v40 + 416);
    long long v43 = *(_OWORD *)(v40 + 432);
    *(__n128 *)(v40 + 480) = result;
    *(_OWORD *)(v40 + 496) = v43;
    uint64_t v44 = *(void *)(a1 + 384);
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 524);
    *(unsigned char *)(v44 + 24) ^= 1u;
  }
  return result;
}

CFX::RG::Pass *sub_1B65301B4(CFX::RG::RenderGraphContext *a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a1);
  uint64_t v5 = (CFX::RG::Pass *)sub_1B65302D8(v4, a1, (uint64_t)a2);
  a2[37] = *(void *)(*((void *)v5 + 48) + 8 * *(unsigned __int8 *)(*((void *)v5 + 48) + 720) + 704);
  float v6 = (uint64_t *)sub_1B6530330(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  id v7 = *(CFX::RG::Resource **)(*((void *)v5 + 48) + 728);
  v6[50] = (uint64_t)v7;
  CFX::RG::Pass::readFrom(v6, v7);
  CFX::RG::Pass::dependsOn(v6, v5);
  a2[38] = *(void *)(v6[49] + 24);
  id v8 = (uint64_t *)sub_1B6530388(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  uint64_t v9 = *(CFX::RG::Resource **)(*((void *)v5 + 48) + 728);
  v8[50] = (uint64_t)v9;
  CFX::RG::Pass::readFrom(v8, v9);
  CFX::RG::Pass::dependsOn(v8, (CFX::RG::Pass *)v6);
  uint64_t v10 = (uint64_t *)sub_1B65303E0(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  id v11 = (CFX::RG::Resource *)v8[49];
  v10[50] = (uint64_t)v11;
  CFX::RG::Pass::readFrom(v10, v11);
  id v12 = *(CFX::RG::Resource **)(*((void *)v5 + 48) + 728);
  v10[51] = (uint64_t)v12;
  CFX::RG::Pass::readFrom(v10, v12);
  CFX::RG::Pass::dependsOn(v10, (CFX::RG::Pass *)v8);
  a2[36] = *(void *)(v10[49] + 8 * *(unsigned __int8 *)(v10[48] + 24) + 16);
  return v5;
}

uint64_t sub_1B65302D8(uint64_t *a1, CFX::RG::RenderGraphContext *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = (uint64_t)sub_1B6530A0C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6530330(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6530A6C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6530388(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6530ACC(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B65303E0(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6530B2C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B653043C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6530478(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B65304B4(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B65304F0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B6530528(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      uint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      __n128 result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B6530614(void *a1)
{
  *a1 = &unk_1F0FB4A90;
  for (uint64_t i = 3; i != 1; --i)
  {
    uint64_t v3 = (void *)a1[i];
    if (v3) {
  }
    }
  return a1;
}

void sub_1B6530670(void *a1)
{
  *a1 = &unk_1F0FB4A90;
  uint64_t v2 = 3;
  while (1)
  {
    uint64_t v3 = (void *)a1[v2];
    if (v3) {

    }
    if (--v2 == 1)
    {
      JUMPOUT(0x1BA9B6D80);
    }
  }
}

void *sub_1B65306EC(void *a1)
{
  *a1 = &unk_1F0FB4AB0;
  for (uint64_t i = 3; i != 1; --i)
  {
    uint64_t v3 = (void *)a1[i];
    if (v3) {
  }
    }
  return a1;
}

void sub_1B6530748(void *a1)
{
  *a1 = &unk_1F0FB4AB0;
  uint64_t v2 = 3;
  while (1)
  {
    uint64_t v3 = (void *)a1[v2];
    if (v3) {

    }
    if (--v2 == 1)
    {
      JUMPOUT(0x1BA9B6D80);
    }
  }
}

void *sub_1B65307C4(void *a1)
{
  *a1 = &unk_1F0FB44C0;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6530810(void *a1)
{
  *a1 = &unk_1F0FB44C0;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B653087C(void *a1)
{
  *a1 = &unk_1F0FB4C20;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B65308C8(void *a1)
{
  *a1 = &unk_1F0FB4C20;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6530934(void *a1)
{
  *a1 = &unk_1F0FB4C40;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B6530990(void *a1)
{
  *a1 = &unk_1F0FB4C40;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t *sub_1B6530A0C(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::RG::RenderGraphContext *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  id v8 = (uint64_t *)sub_1B63C8330(v10, 0x198u, 8u);
  return sub_1B652E900(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6530A6C(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A8u, 8u);
  return sub_1B652F16C(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6530ACC(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A8u, 8u);
  return sub_1B652F784(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6530B2C(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B652FB8C(v8, *a3, a3[1], a4, a5);
}

void sub_1B6530B8C(__CFString *a1, const __CFString *a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
}

uint64_t sub_1B6530CAC()
{
  if (qword_1EB995670 != -1) {
    dispatch_once(&qword_1EB995670, &unk_1F0FB5C28);
  }
  return qword_1EB995678;
}

double sub_1B6530CF0()
{
  if (!qword_1EB995678)
  {
    qword_1EB995678 = sub_1B63C8D10(&qword_1EB995678);
    qword_1EB984AC0 = (uint64_t)sub_1B6531DF4;
    double result = *(double *)&xmmword_1F0FB8AA8;
    unk_1EB984AD8 = xmmword_1F0FB8AA8;
    unk_1EB984AE8 = unk_1F0FB8AB8;
    qword_1EB984AF8 = qword_1F0FB8AC8;
    unk_1EB984B00 = sub_1B6532898;
  }
  return result;
}

double sub_1B6530D70()
{
  if (qword_1EB995670 != -1) {
    dispatch_once(&qword_1EB995670, &unk_1F0FB5C28);
  }
  uint64_t v0 = (_OWORD *)sub_1B63C8D44(qword_1EB995678, 0xE0uLL);
  v0[7] = xmmword_1B6E4F300;
  v0[8] = xmmword_1B6E4F320;
  double result = 0.0;
  v0[9] = xmmword_1B6E4F2E0;
  v0[10] = xmmword_1B6E4F370;
  return result;
}

uint64_t sub_1B6530DE4(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  sub_1B6530D70();
  uint64_t v16 = v15;
  if (a4)
  {
    CFStringRef v17 = (const __CFString *)sub_1B6583470(a4, v8, v9, v10, v11, v12, v13, v14);
    sub_1B65834BC(v16, v17, v18, v19, v20, v21, v22, v23);
  }
  *(_WORD *)(v16 + 64) = a2;
  *(void *)(v16 + 80) = a1;
  size_t v24 = (uint64_t)a2 << 6;
  *(void *)(v16 + 88) = sub_1B63CA51C(v24);
  *(void *)(v16 + 96) = sub_1B63CA51C(v24);
  if (*(_WORD *)(v16 + 64) == 1)
  {
    *(void *)(v16 + 72) = 0;
    *(void *)(v16 + 184) = 0;
    *(void *)(v16 + 192) = 0;
    *(void *)(v16 + 176) = 0;
  }
  else
  {
    size_t v25 = 8 * a1 + 8;
    if (a3)
    {
      *(void *)(v16 + 72) = a3;
      *(void *)(v16 + 176) = sub_1B63CA51C(v25);
      *(void *)(v16 + 184) = sub_1B63CA51C(2 * a3);
      *(void *)(v16 + 192) = sub_1B63CA51C(4 * a3);
    }
    else
    {
      *(void *)(v16 + 72) = 0;
      *(void *)(v16 + 176) = sub_1B63CA51C(v25);
      *(void *)(v16 + 184) = sub_1B63CA51C(0);
      *(void *)(v16 + 192) = 0;
    }
  }
  return v16;
}

uint64_t sub_1B6530ED0(uint64_t a1, int a2)
{
  sub_1B6530D70();
  uint64_t v5 = v4;
  uint64_t v12 = sub_1B64ACF7C(a1, 1, v6, v7, v8, v9, v10, v11);
  uint64_t v20 = sub_1B641D8A0((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19);
  size_t v25 = sub_1B64AC5F8(a1, 5, 0, 1, v21, v22, v23, v24);
  if (v25)
  {
    uint64_t v33 = (unsigned __int8 *)sub_1B641D478((uint64_t)v25, v26, v27, v28, v29, v30, v31, v32);
    uint64_t v35 = v34;
    uint64_t v40 = sub_1B64AC5F8(a1, 6, 0, 1, v36, v37, v38, v39);
    uint64_t v48 = (uint64_t)v40;
    if (!v40)
    {
      *(_WORD *)(v5 + 200) = 1;
      uint64_t v61 = v20;
      goto LABEL_33;
    }
    uint64_t v49 = sub_1B641D478((uint64_t)v40, v41, v42, v43, v44, v45, v46, v47);
    unint64_t v57 = HIWORD(v50);
    if (BYTE6(v50) == 1 || BYTE6(v50) == 20)
    {
      if (v35)
      {
        unsigned int v58 = 0;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
        uint64_t v61 = 0;
        uint64_t v62 = v50 & 0xFF000000000000;
        unint64_t v63 = HIBYTE(v50);
        if (HIBYTE(v50) <= 1u) {
          uint64_t v64 = 1;
        }
        else {
          uint64_t v64 = HIBYTE(v50);
        }
        int v65 = BYTE5(v50);
        while (1)
        {
          unsigned int v66 = (float *)(v49 + v58);
          if (v62 == 0x1000000000000)
          {
            if (v63)
            {
              uint64_t v67 = 0;
              uint64_t v68 = v64;
              do
              {
                float v69 = *v66++;
                if (v69 > 0.0) {
                  ++v67;
                }
                --v68;
              }
              while (v68);
              goto LABEL_23;
            }
          }
          else if (v63)
          {
            uint64_t v67 = 0;
            uint64_t v70 = v64;
            do
            {
              int v71 = *(unsigned __int8 *)v66;
              unsigned int v66 = (float *)((char *)v66 + 1);
              if (v71) {
                ++v67;
              }
              --v70;
            }
            while (v70);
            goto LABEL_23;
          }
          uint64_t v67 = 0;
LABEL_23:
          if (v60 <= v67) {
            uint64_t v60 = v67;
          }
          v61 += v67;
          ++v59;
          v58 += v65;
          if (v59 == v35) {
            goto LABEL_30;
          }
        }
      }
      uint64_t v61 = 0;
      LOWORD(v60) = 0;
LABEL_30:
      *(_WORD *)(v5 + 200) = v60;
    }
    else
    {
      sub_1B63F2F54(16, @"Error: Unsupported skin weight format", v51, v52, v53, v54, v55, v56, v100);
      uint64_t v61 = 0;
    }
    if (v57 == 1 || v57 == 20)
    {
LABEL_33:
      *(void *)(v5 + 176) = sub_1B63CA51C(8 * v20 + 8);
      *(_WORD *)(v5 + 64) = a2;
      *(void *)(v5 + 72) = v61;
      *(void *)(v5 + 80) = v20;
      size_t v72 = (uint64_t)a2 << 6;
      *(void *)(v5 + 88) = sub_1B63CA51C(v72);
      *(void *)(v5 + 96) = sub_1B63CA51C(v72);
      *(void *)(v5 + 184) = sub_1B63CA51C(2 * v61);
      uint64_t v73 = sub_1B63CA51C(4 * v61);
      *(void *)(v5 + 192) = v73;
      if (v48)
      {
        uint64_t v81 = sub_1B641D478(v48, v74, v75, v76, v77, v78, v79, v80);
        uint64_t v84 = *(void *)(v5 + 176);
        if (v20 >= 1)
        {
          uint64_t v85 = 0;
          uint64_t v86 = 0;
          uint64_t v87 = v82 & 0xFF000000000000;
          uint64_t v88 = BYTE5(v82);
          uint64_t v89 = HIBYTE(v82);
          if (HIBYTE(v82) <= 1u) {
            uint64_t v89 = 1;
          }
          unint64_t v90 = HIBYTE(v82);
          do
          {
            *(void *)(v84 + 8 * v85) = v86;
            if (v87 == 0x1000000000000)
            {
              if (v90)
              {
                uint64_t v91 = 0;
                do
                {
                  LODWORD(v83) = *(_DWORD *)(v81 + 4 * v91);
                  if (*(float *)&v83 > 0.0)
                  {
                    uint64_t v92 = *(void *)(v5 + 192);
                    *(_WORD *)(*(void *)(v5 + 184) + 2 * v86) = v33[v91];
                    *(_DWORD *)(v92 + 4 * v86++) = LODWORD(v83);
                  }
                  ++v91;
                }
                while (v89 != v91);
              }
            }
            else if (v90)
            {
              float32x4_t v93 = (unsigned char *)v81;
              float32x4_t v94 = v33;
              uint64_t v95 = v89;
              do
              {
                if (*v93)
                {
                  uint64_t v96 = *(void *)(v5 + 192);
                  *(_WORD *)(*(void *)(v5 + 184) + 2 * v86) = *v94;
                  LOBYTE(v83) = *v93;
                  double v83 = (double)*(unint64_t *)&v83 / 255.0;
                  *(float *)&double v83 = v83;
                  *(_DWORD *)(v96 + 4 * v86++) = LODWORD(v83);
                }
                ++v94;
                ++v93;
                --v95;
              }
              while (v95);
            }
            ++v85;
            v33 += BYTE5(v35);
            v81 += v88;
          }
          while (v85 != v20);
          goto LABEL_58;
        }
      }
      else
      {
        uint64_t v84 = *(void *)(v5 + 176);
        if (v20 >= 1)
        {
          uint64_t v97 = 0;
          uint64_t v98 = *(void *)(v5 + 184);
          do
          {
            *(void *)(v84 + 8 * v97) = v97;
            *(_WORD *)(v98 + 2 * v97) = *v33;
            v73[v97] = 1065353216;
            v33 += BYTE5(v35);
            ++v97;
          }
          while (v20 != v97);
          uint64_t v86 = v20;
          goto LABEL_58;
        }
      }
      uint64_t v86 = 0;
LABEL_58:
      *(void *)(v84 + 8 * v20) = v86;
      return v5;
    }
  }
  return 0;
}

uint64_t sub_1B6531214(uint64_t result)
{
  if (*(void *)(result + 96) && *(__int16 *)(result + 64) >= 1)
  {
    uint64_t v1 = 0;
    do
    {
      uint64_t v2 = 0;
      uint64_t v3 = *(void *)(result + 96);
      uint64_t v4 = (float32x4_t *)(*(void *)(result + 88) + (v1 << 6));
      float32x4_t v5 = *v4;
      float32x4_t v6 = v4[1];
      float32x4_t v7 = v4[2];
      float32x4_t v8 = v4[3];
      long long v9 = *(_OWORD *)(result + 128);
      long long v10 = *(_OWORD *)(result + 144);
      long long v11 = *(_OWORD *)(result + 160);
      v16[0] = *(_OWORD *)(result + 112);
      v16[1] = v9;
      v16[2] = v10;
      v16[3] = v11;
      long long v17 = 0uLL;
      long long v18 = 0uLL;
      long long v19 = 0uLL;
      long long v20 = 0uLL;
      do
      {
        *(long long *)((char *)&v17 + v2 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5, COERCE_FLOAT(v16[v2])), v6, *(float32x2_t *)&v16[v2], 1), v7, (float32x4_t)v16[v2], 2), v8, (float32x4_t)v16[v2], 3);
        ++v2;
      }
      while (v2 != 4);
      uint64_t v12 = (_OWORD *)(v3 + (v1 << 6));
      long long v13 = v18;
      long long v14 = v19;
      long long v15 = v20;
      *uint64_t v12 = v17;
      v12[1] = v13;
      _OWORD v12[2] = v14;
      v12[3] = v15;
      ++v1;
    }
    while (v1 < *(__int16 *)(result + 64));
  }
  return result;
}

uint64_t sub_1B65312B8(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t sub_1B65312C0(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v10 = *(void **)(a1 + 88);
  if (!v10)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"skin->_inverseBindMatrices");
    long long v10 = *(void **)(a1 + 88);
  }
  memcpy(v10, __src, (uint64_t)*(__int16 *)(a1 + 64) << 6);

  return sub_1B6531214(a1);
}

void sub_1B6531338(size_t *a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  size_t v1 = a1[9];
  if (v1)
  {
    uint64_t v3 = a1[10];
    if (v1 != v3)
    {
      uint64_t v4 = (void *)a1[22];
      size_t v5 = a1[23];
      size_t v6 = a1[24];
      float32x4_t v7 = malloc_type_calloc(2uLL, v1, 0x850BEFBFuLL);
      float32x4_t v8 = (float *)malloc_type_calloc(4uLL, a1[9], 0x19764A4EuLL);
      v27[1] = v27;
      uint64_t v28 = a1;
      uint64_t v30 = v4;
      uint64_t v9 = *v4;
      MEMORY[0x1F4188790](v8, v10);
      uint64_t v12 = (char *)v27 - v11;
      if (v3 < 1)
      {
        int64_t v14 = 0;
      }
      else
      {
        uint64_t v13 = 0;
        int64_t v14 = 0;
        long long v15 = v30;
        uint64_t v29 = v3;
        do
        {
          uint64_t v16 = v15[++v13];
          if ((uint64_t)((unint64_t)(v16 - v9) << 48) >= 1)
          {
            uint64_t v31 = v15[v13];
            uint64_t v32 = v13;
            uint64_t v17 = 0;
            if ((__int16)(v16 - v9) <= 1) {
              uint64_t v18 = 1;
            }
            else {
              uint64_t v18 = (__int16)(v16 - v9);
            }
            do
            {
              uint64_t v19 = 0;
              if (v17)
              {
                while (*(float *)(v6 + 4 * (v17 + v9)) <= *(float *)(v6 + 4 * (*(void *)&v12[8 * v19] + v9)))
                {
                  if (v17 == ++v19)
                  {
                    uint64_t v19 = v17;
                    goto LABEL_16;
                  }
                }
              }
              if (v17 != v19) {
                memmove(&v12[8 * v19 + 8], &v12[8 * v19], 8 * (v17 - v19));
              }
LABEL_16:
              *(void *)&v12[8 * v19] = v17++;
            }
            while (v17 != v18);
            long long v20 = (uint64_t *)v12;
            uint64_t v3 = v29;
            long long v15 = v30;
            uint64_t v16 = v31;
            uint64_t v13 = v32;
            do
            {
              uint64_t v21 = *v20++;
              uint64_t v22 = v21 + v9;
              float v23 = *(float *)(v6 + 4 * (v21 + v9));
              if (v23 <= 0.00000011921) {
                break;
              }
              __int16 v24 = *(_WORD *)(v5 + 2 * v22);
              v8[v14] = v23;
              v7[v14++] = v24;
              --v18;
            }
            while (v18);
          }
          v15[v13] = v14;
          uint64_t v9 = v16;
        }
        while (v13 != v3);
      }
      size_t v25 = v28;
      if (v14 >= (uint64_t)v28[9])
      {
        free(v7);
        free(v8);
      }
      else
      {
        free((void *)v28[23]);
        free((void *)v25[24]);
        if (v14)
        {
          v25[23] = (size_t)malloc_type_realloc(v7, 2 * v14, 0x1000040BDFB0063uLL);
          uint64_t v26 = malloc_type_realloc(v8, 4 * v14, 0x100004052888210uLL);
        }
        else
        {
          free(v7);
          free(v8);
          uint64_t v26 = 0;
          v25[23] = 0;
        }
        v25[24] = (size_t)v26;
        v25[9] = v14;
      }
    }
  }
}

void *sub_1B65315EC(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = result[22];
  }
  if (a3) {
    *a3 = result[23];
  }
  if (a4) {
    *a4 = result[24];
  }
  return result;
}

uint64_t sub_1B6531614(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  }
  return *(void *)(a1 + 72);
}

uint64_t sub_1B6531660(uint64_t result, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  *(__n128 *)(result + 112) = a2;
  *(__n128 *)(result + 128) = a3;
  *(__n128 *)(result + 144) = a4;
  *(__n128 *)(result + 160) = a5;
  return sub_1B6531214(result);
}

uint64_t sub_1B653166C(uint64_t a1)
{
  return a1 + 112;
}

uint64_t sub_1B6531674(uint64_t a1)
{
  return *(__int16 *)(a1 + 64);
}

void sub_1B653167C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  }
  if (!*(void *)(a1 + 224))
  {
    uint64_t v9 = *(void *)(a1 + 80);
    uint64_t v10 = sub_1B647B3F8(0, 5, v9, 4, 15, a6, a7, a8);
    sub_1B641CF94(v10);
    if (*(__int16 *)(a1 + 200) <= 1)
    {
      uint64_t v33 = (char *)sub_1B641D478(v10, v11, v12, v13, v14, v15, v16, v17);
      uint64_t v34 = v38;
      uint64_t v18 = 0;
    }
    else
    {
      uint64_t v18 = sub_1B647B3F8(0, 6, v9, 4, 20, v15, v16, v17);
      sub_1B641CF94(v18);
      uint64_t v33 = (char *)sub_1B641D478(v10, v19, v20, v21, v22, v23, v24, v25);
      uint64_t v34 = v26;
      if (v18)
      {
        uint64_t v35 = (char *)sub_1B641D478(v18, v26, v27, v28, v29, v30, v31, v32);
        uint64_t v37 = v36;
LABEL_9:
        sub_1B6531784((void *)a1, v33, v34, v35, v37, v30, v31, v32, v39);
        *(void *)(a1 + 216) = v18;
        *(void *)(a1 + 224) = v10;
        return;
      }
    }
    uint64_t v35 = 0;
    uint64_t v37 = 0;
    goto LABEL_9;
  }
}

void sub_1B6531784(void *a1, char *__b, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v12 = __b;
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1[10];
  memset(__b, 255, (4 * v13));
  int v20 = BYTE5(a5);
  if (a4)
  {
    bzero(a4, v13 * BYTE5(a5));
    BOOL v21 = v13 == a5;
  }
  else
  {
    BOOL v21 = 1;
  }
  int v22 = !v21;
  if (v13 != a3 || v22 != 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. inconsistency in %s", v14, v15, v16, v17, v18, v19, (uint64_t)"count == dstJoints.count && (!dstWeights.ptr || (count == dstWeights.count))");
  }
  uint64_t v24 = a1;
  uint64_t v25 = a1[23];
  uint64_t v66 = a1[22];
  uint64_t v26 = a1[24];
  v70[0] = 0;
  v70[1] = 0;
  if (v13)
  {
    int v69 = 0;
    uint64_t v27 = 0;
    int v62 = 0;
    uint64_t v63 = v13;
    int v64 = BYTE5(a3);
    unsigned int v58 = v12;
    uint64_t v59 = a4;
    int v65 = v20;
    while (1)
    {
      uint64_t v28 = *(void *)(v66 + 8 * v27);
      if (v28 < 0
        || ((uint64_t v29 = v27 + 1, v30 = *(void *)(v66 + 8 * (v27 + 1)), v31 = v24[9], v28 <= v31)
          ? (BOOL v32 = v30 <= v31)
          : (BOOL v32 = 0),
            !v32))
      {
        if ((byte_1E9DDB260 & 1) == 0)
        {
          byte_1E9DDB260 = 1;
          sub_1B63F2F54(16, @"Error: invalid skin indices", v14, v15, v16, v17, v18, v19, a9);
        }
        return;
      }
      uint64_t v33 = (v64 * v27);
      uint64_t v67 = v30 - v28;
      uint64_t v68 = v29;
      uint64_t v34 = 0;
      if (v30 <= v28) {
        break;
      }
      uint64_t v35 = &a4[v69];
      uint64_t v61 = v33;
      uint64_t v36 = &v12[v33];
      float v37 = 0.0;
      int v38 = v62;
      do
      {
        int v39 = *(__int16 *)(v25 + 2 * v28);
        if (v39 <= 255)
        {
          float v40 = *(float *)(v26 + 4 * v28);
          if (v40 > 0.0039216)
          {
            if (v34 < 4)
            {
              v36[v34] = v39;
              v71[v34] = v40;
              float v37 = v37 + v40;
              ++v34;
            }
            else
            {
              if ((v38 & 1) == 0) {
                sub_1B63F2F54(0, @"Info: Too many influencing joints (%ld > %d) on the vertex #%u, will cap to %d and renormalize", v14, v15, v16, v17, v18, v19, v67);
              }
              uint64_t v41 = 0;
              float v42 = v71[0];
              for (uint64_t i = 1; i != 4; ++i)
              {
                if (v42 > v71[i])
                {
                  uint64_t v41 = i;
                  float v42 = v71[i];
                }
              }
              if (v40 > v42)
              {
                float v37 = v40 + (float)(v37 - v42);
                v71[v41] = v40;
                v36[v41] = v39;
              }
              int v38 = 1;
            }
          }
        }
        ++v28;
      }
      while (v28 != v30);
      int v62 = v38;
      if (v37 > 0.0 && v37 != 1.0 && v34 >= 1)
      {
        uint64_t v46 = v71;
        uint64_t v47 = v34;
        do
        {
          float *v46 = *v46 / v37;
          ++v46;
          --v47;
        }
        while (v47);
      }
      uint64_t v12 = v58;
      a4 = v59;
      uint64_t v48 = v68;
      if (v59 && v34 >= 1)
      {
        uint64_t v49 = 0;
        uint64_t v50 = 0;
        do
        {
          int v51 = (int)rintf(v71[v49] * 255.0);
          if (v51 >= 255) {
            int v51 = 255;
          }
          uint64_t v52 = v51 & ~(v51 >> 31);
          v35[v49] = v52;
          v50 += v52;
          ++v49;
        }
        while (v34 != v49);
        while (1)
        {
LABEL_61:
          if (v50 == 255) {
            break;
          }
          uint64_t v53 = v34;
          uint64_t v54 = v35;
          while (1)
          {
            int v55 = *v54;
            if (v50 > 254) {
              break;
            }
            if (v55 != 255)
            {
              char v56 = 1;
              uint64_t v57 = 1;
              goto LABEL_60;
            }
LABEL_57:
            ++v54;
            if (!--v53) {
              goto LABEL_61;
            }
          }
          if (!*v54) {
            goto LABEL_57;
          }
          uint64_t v57 = -1;
          char v56 = -1;
LABEL_60:
          char *v54 = v55 + v56;
          v50 += v57;
        }
      }
      if (v34 >= 1) {
        ++*((_DWORD *)v70 + v34 - 1);
      }
      uint64_t v24 = a1;
      uint64_t v33 = v61;
      if (v34 <= 3) {
        goto LABEL_67;
      }
LABEL_68:
      v69 += v65;
      uint64_t v27 = v48;
      if (v48 == v63) {
        return;
      }
    }
    uint64_t v48 = v29;
LABEL_67:
    bzero(&v12[v34 + v33], 4 - v34);
    bzero(&v71[v34], 16 - 4 * v34);
    goto LABEL_68;
  }
}

uint64_t sub_1B6531B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *(void *)(a1 + 224);
}

uint64_t sub_1B6531BC4(uint64_t a1)
{
  return *(__int16 *)(a1 + 200);
}

uint64_t sub_1B6531BCC(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 200) = a2;
  return result;
}

CFTypeRef sub_1B6531BD4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"skin");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 208);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 208) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 208) = result;
  }
  return result;
}

id sub_1B6531C54(void *a1)
{
  sub_1B6595A0C(@"kCFXNotificationSkinWillDie", a1, 0, 1u);
  uint64_t v9 = (void *)a1[11];
  if (v9) {
    free(v9);
  }
  uint64_t v10 = (void *)a1[12];
  if (v10) {
    free(v10);
  }
  uint64_t v11 = (void *)a1[24];
  if (v11) {
    free(v11);
  }
  uint64_t v12 = (void *)a1[22];
  if (v12) {
    free(v12);
  }
  uint64_t v13 = (void *)a1[23];
  if (v13) {
    free(v13);
  }
  if (a1[26]) {
    sub_1B6531BD4((uint64_t)a1, 0, v3, v4, v5, v6, v7, v8);
  }
  uint64_t v14 = (const void *)a1[28];
  if (v14)
  {
    CFRelease(v14);
    a1[28] = 0;
  }
  uint64_t v15 = (const void *)a1[27];
  if (v15)
  {
    CFRelease(v15);
    a1[27] = 0;
  }

  return sub_1B658325C((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
}

__CFString *sub_1B6531D18(__n128 *a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v10 = sub_1B6583470((uint64_t)a1, v3, v4, v5, v6, v7, v8, v9);
  CFStringAppendFormat(Mutable, 0, @"<CFXSkin %p name:%@ joint:%d weight:%d vertexCount:%d\n", a1, v10, a1[4].n128_i16[0], a1[4].n128_u64[1], a1[5].n128_u64[0]);
  CFStringAppendFormat(Mutable, 0, @"  maxInf:%d morpher:%p\n", a1[12].n128_i16[4], a1[13].n128_u64[0]);
  sub_1B6530B8C(Mutable, @"defaultShapeMatrix\n", a1[7], a1[8], a1[9], a1[10]);
  uint64_t v11 = (__n128 *)a1[5].n128_u64[1];
  if (v11) {
    sub_1B6530B8C(Mutable, @"inverseBindMatrix", *v11, v11[1], v11[2], v11[3]);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

__CFArray *sub_1B6531DF4(void *a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v64 = 0;
  int valuePtr = 13;
  uint64_t v63 = a1 + 8;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v4, @"name", @"jointsCount");
  CFDictionarySetValue(v4, @"type", v5);
  CFDictionarySetValue(v4, @"address", v7);
  CFDictionarySetValue(v4, @"semantic", v6);
  CFArrayAppendValue(Mutable, v4);
  CFRelease(v6);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v5);
  uint64_t v8 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v64 = 0;
  int valuePtr = 2;
  uint64_t v63 = a1 + 9;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v8, @"name", @"weightsCount");
  CFDictionarySetValue(v8, @"type", v9);
  CFDictionarySetValue(v8, @"address", v11);
  CFDictionarySetValue(v8, @"semantic", v10);
  CFArrayAppendValue(Mutable, v8);
  CFRelease(v10);
  CFRelease(v8);
  CFRelease(v11);
  CFRelease(v9);
  uint64_t v12 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v64 = 0;
  int valuePtr = 2;
  uint64_t v63 = a1 + 10;
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v12, @"name", @"vertexCount");
  uint64_t v16 = Mutable;
  CFDictionarySetValue(v12, @"type", v13);
  CFDictionarySetValue(v12, @"address", v15);
  CFDictionarySetValue(v12, @"semantic", v14);
  CFArrayAppendValue(Mutable, v12);
  CFRelease(v14);
  CFRelease(v12);
  CFRelease(v15);
  CFRelease(v13);
  uint64_t v60 = a1;
  if (a1[11])
  {
    uint64_t v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v64 = 0;
    int valuePtr = 10;
    uint64_t v63 = (void *)a1[11];
    CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
    CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v63);
    CFDictionarySetValue(v17, @"name", @"inverseBindMatrices");
    CFDictionarySetValue(v17, @"type", v18);
    CFDictionarySetValue(v17, @"address", v20);
    CFDictionarySetValue(v17, @"semantic", v19);
    CFArrayAppendValue(v16, v17);
    CFRelease(v19);
    CFRelease(v17);
    CFRelease(v20);
    CFRelease(v18);
  }
  BOOL v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  int v22 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v64 = 0;
  int valuePtr = 10;
  uint64_t v63 = a1 + 14;
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v22, @"name", @"defaultShapeMatrix");
  CFDictionarySetValue(v22, @"type", v23);
  CFDictionarySetValue(v22, @"address", v25);
  CFDictionarySetValue(v22, @"semantic", v24);
  CFArrayAppendValue(v16, v22);
  CFRelease(v24);
  CFRelease(v22);
  CFRelease(v25);
  CFRelease(v23);
  uint64_t v26 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v21);
  int v64 = 0;
  int valuePtr = 13;
  uint64_t v63 = a1 + 25;
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v26, @"name", @"maxInfluencesPerVertex");
  CFDictionarySetValue(v26, @"type", v27);
  CFDictionarySetValue(v26, @"address", v29);
  CFDictionarySetValue(v26, @"semantic", v28);
  CFArrayAppendValue(v16, v26);
  CFRelease(v28);
  CFRelease(v26);
  CFRelease(v29);
  CFRelease(v27);
  uint64_t v30 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v21);
  int v64 = 2;
  int valuePtr = 5;
  uint64_t v63 = a1 + 26;
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberLongType, &v63);
  CFDictionarySetValue(v30, @"name", @"influencingMorpher");
  CFDictionarySetValue(v30, @"type", v31);
  CFDictionarySetValue(v30, @"address", v33);
  CFDictionarySetValue(v30, @"semantic", v32);
  CFArrayRef theArray = v16;
  CFArrayAppendValue(v16, v30);
  CFRelease(v32);
  uint64_t v34 = v30;
  uint64_t v35 = a1;
  CFRelease(v34);
  CFRelease(v33);
  CFRelease(v31);
  if (a1[22])
  {
    uint64_t v36 = a1[10];
    if (v36 >= 1)
    {
      uint64_t v37 = 0;
      for (uint64_t i = 0; i != v36; ++i)
      {
        CFStringRef v39 = CFStringCreateWithFormat(0, 0, @"vertexWeightIndices[%d]", i);
        float v40 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        int v64 = 0;
        int valuePtr = 2;
        uint64_t v63 = (void *)(v35[22] + v37);
        CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
        CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
        CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v63);
        CFDictionarySetValue(v40, @"name", v39);
        CFDictionarySetValue(v40, @"type", v41);
        CFDictionarySetValue(v40, @"address", v43);
        CFDictionarySetValue(v40, @"semantic", v42);
        CFArrayAppendValue(theArray, v40);
        CFNumberRef v44 = v42;
        uint64_t v35 = v60;
        CFRelease(v44);
        CFRelease(v40);
        CFRelease(v43);
        CFRelease(v41);
        CFRelease(v39);
        v37 += 8;
      }
    }
  }
  if (v35[24])
  {
    uint64_t v45 = v35;
    if (v35[23])
    {
      if ((uint64_t)v35[9] >= 1)
      {
        uint64_t v46 = 0;
        uint64_t v47 = 0;
        uint64_t v48 = 0;
        uint64_t v61 = v35[9];
        do
        {
          CFStringRef v49 = CFStringCreateWithFormat(0, 0, @"vertexWeights[%d]", v48);
          uint64_t v50 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          int v64 = 0;
          int valuePtr = 1;
          uint64_t v63 = (void *)(v45[24] + v46);
          CFNumberRef v51 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
          CFNumberRef v52 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
          CFNumberRef v53 = CFNumberCreate(0, kCFNumberLongType, &v63);
          CFDictionarySetValue(v50, @"name", v49);
          CFDictionarySetValue(v50, @"type", v51);
          CFDictionarySetValue(v50, @"address", v53);
          CFDictionarySetValue(v50, @"semantic", v52);
          CFArrayAppendValue(theArray, v50);
          CFRelease(v52);
          CFRelease(v50);
          CFRelease(v53);
          CFRelease(v51);
          CFRelease(v49);
          CFStringRef v54 = CFStringCreateWithFormat(0, 0, @"jointsForVertexWeights[%d]", v48);
          int v55 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          int v64 = 0;
          int valuePtr = 13;
          uint64_t v63 = (void *)(v45[23] + v47);
          CFNumberRef v56 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
          CFNumberRef v57 = CFNumberCreate(0, kCFNumberSInt32Type, &v64);
          CFNumberRef v58 = CFNumberCreate(0, kCFNumberLongType, &v63);
          CFDictionarySetValue(v55, @"name", v54);
          CFDictionarySetValue(v55, @"type", v56);
          CFDictionarySetValue(v55, @"address", v58);
          CFDictionarySetValue(v55, @"semantic", v57);
          CFArrayAppendValue(theArray, v55);
          CFRelease(v57);
          CFRelease(v55);
          CFRelease(v58);
          CFRelease(v56);
          CFRelease(v54);
          ++v48;
          v47 += 2;
          v46 += 4;
        }
        while (v61 != v48);
      }
    }
  }
  return theArray;
}

uint64_t sub_1B6532898(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  uint64_t v12 = *(const void **)(a1 + 208);

  return sub_1B63F4FC8(v12, (uint64_t)a2);
}

uint64_t sub_1B6532A48(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  memset(&v9, 0, sizeof(v9));
  uint64_t v4 = (const char *)objc_msgSend_fileSystemRepresentation(a1, a2, a3, a4);
  if (!stat(v4, &v9) && (v9.st_mode & 0xF000) == 0x8000 && v9.st_size >= 1)
  {
    int v6 = open(v4, 0, 511);
    if ((v6 & 0x80000000) == 0)
    {
      unsigned int v7 = v6;
      if (!fstat(v6, &v9) && (v9.st_mode & 0xF000) == 0x8000 && v9.st_size >= 1) {
        return v7;
      }
      close(v7);
    }
  }
  return -1;
}

uLong sub_1B6533D10(const Bytef *a1, uInt a2)
{
  uLong v4 = crc32(0, 0, 0);
  return crc32(v4, a1, a2);
}

uint64_t sub_1B6533D50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const void *)sub_1B63CC238(@"CFXFXFloorPass.plist");
  uint64_t v10 = sub_1B65146D4(v3, a2, v4, v5, v6, v7, v8, v9);
  uint64_t v11 = sub_1B65153D0(v10, @"VFX_renderMirroredScene");
  sub_1B65F853C(v11, (uint64_t)sub_1B6533F94);
  sub_1B65F8544(v11, (uint64_t)sub_1B6533FA4);
  uint64_t v12 = sub_1B65153D0(v10, @"VFX_renderFloor");
  sub_1B6519B04(v12, (uint64_t)sub_1B6534020);
  uint64_t v20 = sub_1B649FCB4(a2, v13, v14, v15, v16, v17, v18, v19);
  uint64_t v27 = sub_1B6515448(v10, 0, v21, v22, v23, v24, v25, v26);
  uint64_t v35 = v27;
  if (!v20)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v29, v30, v31, v32, v33, v34, (uint64_t)"floor");
    if (v35) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (!v27)
  {
LABEL_6:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v29, v30, v31, v32, v33, v34, (uint64_t)"pass");
    goto LABEL_7;
  }
  double v36 = sub_1B6519930(v20, v28, v29, v30, v31, v32, v33, v34);
  *(double *)(v35 + 376) = v36;
  *(double *)(v35 + 384) = v36;
  int v44 = sub_1B6519A10(v20, v37, v38, v39, v40, v41, v42, v43);
  if (v44) {
    *(unsigned char *)(v35 + 176) = v44;
  }
LABEL_7:
  sub_1B65343F8(a2, v45, v29, v30, v31, v32, v33, v34);
  uint64_t v46 = sub_1B65153D0(v10, @"VFX_renderFloor");
  CFNumberRef v53 = sub_1B65F84B0(v46, @"u_floorReflectionColor", v47, v48, v49, v50, v51, v52);
  CFAllocatorRef v54 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v55 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"VFX-floor-color-%p", a2);
  CFStringRef v56 = (CFStringRef)v53[9];
  if (v56 != v55)
  {
    if (v56)
    {
      CFRelease(v56);
      v53[9] = 0;
    }
    if (v55) {
      CFTypeRef v57 = CFRetain(v55);
    }
    else {
      CFTypeRef v57 = 0;
    }
    v53[9] = v57;
  }
  CFRelease(v55);
  if (sub_1B6519838(v20, v58, v59, v60, v61, v62, v63, v64) != 0.0)
  {
    int v71 = sub_1B65F84B0(v46, @"u_floorReflectionDepth", v65, v66, v67, v68, v69, v70);
    CFStringRef v72 = CFStringCreateWithFormat(v54, 0, @"VFX-floor-depth-%p", a2);
    CFStringRef v73 = (CFStringRef)v71[9];
    if (v73 != v72)
    {
      if (v73)
      {
        CFRelease(v73);
        v71[9] = 0;
      }
      if (v72) {
        CFTypeRef v74 = CFRetain(v72);
      }
      else {
        CFTypeRef v74 = 0;
      }
      v71[9] = v74;
    }
    CFRelease(v72);
  }
  return v10;
}

CFTypeRef sub_1B6533F94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B65F6FAC(*(void *)a1, *(CFTypeRef *)(a1 + 16), a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B6533FA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = sub_1B649FCB4(a2, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v16 = result;
    float v24 = sub_1B65345C8(a2, result, v10, v11, v12, v13, v14, v15);
    float v25 = *(float *)(v16 + 236);
    *(float *)(v16 + 236) = v24;
    if (v25 == 1.0 && v24 != 1.0) {
      sub_1B65343F8(a2, v17, v18, v19, v20, v21, v22, v23);
    }
    return sub_1B65195F0(v16, v17, v18, v19, v20, v21, v22, v23) != 0.0;
  }
  return result;
}

void sub_1B6534020(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[2];
  if (v8)
  {
    uint64_t v10 = sub_1B649FCB4(a1[2], a2, a3, a4, a5, a6, a7, a8);
    if (v10)
    {
      uint64_t v18 = v10;
      uint64_t v19 = (__n128 *)sub_1B644558C(a1[3], v11, v12, v13, v14, v15, v16, v17);
      v156.i32[2] = 0;
      v156.i64[0] = 0;
      sub_1B64B2438(v19, (__n128 *)&v156, v20, v21, v22, v23, v24, v25);
      sub_1B6515A58(a1[1], @"u_floorNormal", &v156, v26, v27, v28, v29, v30);
      v36.n128_u32[0] = v156.u32[1];
      if (v156.f32[1] == 0.0 && (v36.n128_u32[0] = v156.u32[2], v156.f32[2] == 0.0))
      {
        v153.n128_u32[0] = 0;
        v153.n128_f32[1] = -v156.f32[0];
        v153.n128_u32[2] = 0;
        v153.n128_u32[3] = 1.0;
        __n128 v158 = v153;
      }
      else
      {
        v36.n128_u32[1] = 0;
        v36.n128_u32[2] = 0;
        v36.n128_u32[3] = 1.0;
        __n128 v158 = v36;
      }
      sub_1B6515A58(a1[1], @"u_floorTangent", &v158, v31, v32, v33, v34, v35);
      int v44 = sub_1B6446564((uint64_t *)a1[3], v37, v38, v39, v40, v41, v42, v43);
      if (v44)
      {
        uint64_t v52 = (uint64_t)v44;
        if (sub_1B63E0460((uint64_t)v44, (uint64_t)&v158, v45, v46, v47, v48, v49, v50))
        {
          float v54 = v158.n128_f32[2];
          if (v158.n128_f32[2] < 10000.0) {
            float v54 = 10000.0;
          }
          double v55 = v54;
          if (v158.n128_u8[0])
          {
            double v57 = sqrt(v160.f32[2] * v160.f32[2] + v55 * v55);
          }
          else
          {
            double v56 = cos(v160.f32[3] * 0.5 / 180.0 * 3.14159265);
            if (v56 <= 0.0) {
              sub_1B63F2F54(17, @"Assertion '%s' failed. Fov is larger that 180 degrees. this can't be", v53, v46, v47, v48, v49, v50, (uint64_t)"d > 0");
            }
            double v57 = (v55 + v55) / v56;
          }
          v157[0].n128_u32[2] = 0;
          v157[0].n128_u64[0] = 0;
          sub_1B64A1EC8(v52, v157, v53, v46, v47, v48, v49, v50);
          float32x4_t v51 = (float32x4_t)v157[0];
          float32_t v58 = v57;
          v51.f32[3] = v58;
        }
      }
      int32x2_t v59 = vdup_laneq_s32((int32x4_t)v51, 3);
      __n128 v158 = (__n128)vmlsq_f32(v51, v156, v51);
      v157[0].n128_u64[0] = (unint64_t)v59;
      float v60 = *(float *)(v18 + 228);
      if (v60 != 0.0)
      {
        v158.n128_u32[0] = 0;
        *(float *)v59.i32 = v60;
        v157[0].n128_u64[0] = (unint64_t)v59;
      }
      float v61 = *(float *)(v18 + 232);
      if (v61 != 0.0)
      {
        v158.n128_u32[2] = 0;
        v157[0].n128_f32[1] = v61;
      }
      sub_1B6515A58(a1[1], @"u_floorCenter", &v158, v46, v47, v48, v49, v50);
      sub_1B6515A58(a1[1], @"u_floorExtent", v157, v62, v63, v64, v65, v66);
      __n128 v154 = sub_1B64479C4((__n128 *)a1[3]);
      float v155 = sub_1B6447C30(a1[3]);
      unsigned int v67 = sub_1B63CBCB0(a1[3]);
      float32x4_t v75 = (float32x4_t)v154;
      if (v67 >= 2)
      {
        *(float *)v73.i32 = (float)v67;
        v74.f32[0] = (float)a1[9];
        int32x4_t v76 = (int32x4_t)vextq_s8((int8x16_t)v154, (int8x16_t)v154, 8uLL);
        *(int32x2_t *)v76.i8 = vdup_lane_s32((int32x2_t)vmul_f32(*(float32x2_t *)v76.i8, *(float32x2_t *)v73.i8), 0);
        *(float32x2_t *)v73.i8 = vdiv_f32(v74, *(float32x2_t *)v73.i8);
        v76.i32[0] = v73.i32[0];
        float32x4_t v75 = (float32x4_t)vtrn2q_s32(vrev64q_s32(vzip1q_s32(v76, v73)), (int32x4_t)v154);
      }
      int8x16_t v77 = (int8x16_t)vmulq_n_f32(v75, v155);
      __asm { FMOV            V2.2S, #1.0 }
      v77.u64[1] = (unint64_t)vdiv_f32(_D2, (float32x2_t)*(_OWORD *)&vextq_s8(v77, v77, 8uLL));
      __n128 v158 = (__n128)v77;
      sub_1B6515A58(a1[1], @"u_floor_viewport", &v158, v68, v69, v70, v71, v72);
      v158.n128_u32[0] = sub_1B65195F0(v18, v83, v84, v85, v86, v87, v88, v89);
      sub_1B6515A58(a1[1], @"u_floorReflectivity", &v158, v90, v91, v92, v93, v94);
      v158.n128_u32[0] = sub_1B6519740(v18, v95, v96, v97, v98, v99, v100, v101);
      sub_1B6515A58(a1[1], @"u_floorFalloffStart", &v158, v102, v103, v104, v105, v106);
      float v114 = sub_1B6519838(v18, v107, v108, v109, v110, v111, v112, v113);
      float v127 = v114 - sub_1B6519740(v18, v115, v116, v117, v118, v119, v120, v121);
      if (v127 <= 0.0) {
        float v127 = 1.0;
      }
      v158.n128_f32[0] = v127;
      sub_1B6515A58(a1[1], @"u_floorFalloff", &v158, v122, v123, v124, v125, v126);
      sub_1B63E08F4(v8, &v156, &v158, v128, v129, v130, v131, v132);
      sub_1B6515A58(a1[1], @"u_floorPlane", &v158, v133, v134, v135, v136, v137);
      uint64_t v138 = sub_1B6447988(a1[3], 1);
      int v139 = (float32x4_t *)sub_1B6447988(a1[3], 0);
      uint64_t v140 = 0;
      float32x4_t v141 = *v139;
      float32x4_t v142 = v139[1];
      float32x4_t v143 = v139[2];
      float32x4_t v144 = v139[3];
      __n128 v145 = *(__n128 *)(v138 + 16);
      __n128 v146 = *(__n128 *)(v138 + 32);
      __n128 v147 = *(__n128 *)(v138 + 48);
      v157[0] = *(__n128 *)v138;
      v157[1] = v145;
      v157[2] = v146;
      v157[3] = v147;
      do
      {
        *(float32x4_t *)((char *)&v158 + v140 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v141, COERCE_FLOAT(*(_OWORD *)&v157[v140])), v142, (float32x2_t)v157[v140].n128_u64[0], 1), v143, (float32x4_t)v157[v140], 2), v144, (float32x4_t)v157[v140], 3);
        ++v140;
      }
      while (v140 != 4);
      v162.columns[2] = v160;
      v162.columns[3] = v161;
      v162.columns[0] = (simd_float4)v158;
      v162.columns[1] = v159;
      simd_float4x4 v163 = __invert_f4(v162);
      __n128 v158 = (__n128)v163.columns[0];
      simd_float4 v159 = v163.columns[1];
      simd_float4 v160 = v163.columns[2];
      simd_float4 v161 = v163.columns[3];
      sub_1B6515A58(a1[1], @"u_floorMVP_i", &v158, v148, v149, v150, v151, v152);
    }
  }
}

void sub_1B65343F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B649FCB4(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    uint64_t v16 = (CFTypeRef *)v9;
    float v17 = sub_1B65345C8(a1, v9, v10, v11, v12, v13, v14, v15);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 4, MEMORY[0x1E4F1D510]);
    CFStringRef v19 = (const __CFString *)sub_1B6602C1C(@"FloorGeomImpl-metal.h");
    uint64_t v20 = (const void *)sub_1B6603A04(v19, 0, 0, 0, 0);
    CFArrayAppendValue(Mutable, v20);
    CFRelease(v20);
    if (sub_1B65195F0((uint64_t)v16, v21, v22, v23, v24, v25, v26, v27) > 0.0)
    {
      uint64_t v33 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (sub_1B6519838((uint64_t)v16, v34, v35, v36, v37, v38, v39, v40) != 0.0) {
        CFDictionaryAddValue(v33, @"USE_FALLOFF", &stru_1F0FCDBB0);
      }
      if (sub_1B6519740((uint64_t)v16, v41, v42, v43, v44, v45, v46, v47) != 0.0) {
        CFDictionaryAddValue(v33, @"USE_FALLOFF_START", &stru_1F0FCDBB0);
      }
      if (v17 < 1.0) {
        CFDictionaryAddValue(v33, @"USE_TRANSPARENCY", &stru_1F0FCDBB0);
      }
      CFStringRef v48 = (const __CFString *)sub_1B6602C1C(@"FloorImpl-metal.h");
      uint64_t v49 = (const void *)sub_1B6603A04(v48, 2, v33, 0, 0);
      CFArrayAppendValue(Mutable, v49);
      CFRelease(v49);
      CFRelease(v33);
    }
    sub_1B6583914(v16, @"kShaderModifiers", Mutable, v28, v29, v30, v31, v32);
    CFRelease(Mutable);
  }
}

float sub_1B65345C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mirrorNode");
  }
  float v17 = 1.0;
  if (sub_1B65195F0(a2, a2, a3, a4, a5, a6, a7, a8) != 0.0)
  {
    sub_1B64A2F68(a1, v10, v11, v12, v13, v14, v15, v16);
    float v17 = v18;
    CFArrayRef v25 = sub_1B63CCF34(a2, 0, v19, v20, v21, v22, v23, v24);
    if (v25) {
      sub_1B64AF43C((uint64_t)v25, v26, v27, v28, v29, v30, v31, v32);
    }
  }
  return v17;
}

uint64_t sub_1B6534654(uint64_t a1)
{
  return *(__int16 *)(a1 + 24);
}

uint64_t sub_1B653465C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 26);
}

void sub_1B6534664()
{
  if (!qword_1E9DDB268)
  {
    qword_1E9DDB268 = sub_1B63C8D10(&qword_1E9DDB268);
    qword_1EB975378 = (uint64_t)sub_1B6534DF4;
  }
}

uint64_t sub_1B65346BC()
{
  if (qword_1E9DDB270 != -1) {
    dispatch_once(&qword_1E9DDB270, &unk_1F0FB5C48);
  }
  CFTypeID v0 = qword_1E9DDB268;

  return sub_1B63C8D44(v0, 0x30uLL);
}

uint64_t sub_1B6534714(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = sub_1B65346BC();
  *(_WORD *)(v17 + 24) = a1;
  *(_WORD *)(v17 + 26) = a2;
  if (!a4) {
    a4 = sub_1B63CA534(a1, v10, v11, v12, v13, v14, v15, v16) * a2;
  }
  *(void *)(v17 + 32) = a3;
  *(void *)(v17 + 40) = a4;
  *(void *)(v17 + 48) = a5;
  *(void *)(v17 + 56) = 0;
  return v17;
}

uint64_t sub_1B6534780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B63CAA3C(*(__int16 *)(a1 + 24), *(unsigned __int16 *)(a1 + 26), a3, a4, a5, a6, a7, a8);
}

void *sub_1B6534790(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    return sub_1B6536A44((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B6534800(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

const UInt8 *sub_1B6534808(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[4] <= a2)
  {
    sub_1B63F2F54(16, @"Error: CFXSourceAccessorGetValuePtrAtIndex - index out of bounds : %d > %d", a3, a4, a5, a6, a7, a8, a2);
  }
  else
  {
    CFDataRef v10 = (const __CFData *)sub_1B6534790((uint64_t)a1, (const char *)a2, a3, a4, a5, a6, a7, a8);
    if (v10) {
      return &CFDataGetBytePtr(v10)[a1[6] + a1[5] * a2];
    }
    sub_1B63F2F54(16, @"Error: CFXSourceAccessorGetValuePtrAtIndex - no data", v11, v12, v13, v14, v15, v16, v18);
  }
  return 0;
}

__CFData *sub_1B6534884(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[4] <= a2)
  {
    sub_1B63F2F54(16, @"Error: CFXSourceAccessorGetMutableValuePtrAtIndex - index out of bounds : %d > %d", a3, a4, a5, a6, a7, a8, a2);
    return 0;
  }
  else
  {
    uint64_t result = (__CFData *)sub_1B6534790((uint64_t)a1, (const char *)a2, a3, a4, a5, a6, a7, a8);
    if (result) {
      return (__CFData *)&CFDataGetMutableBytePtr(result)[a1[6] + a1[5] * a2];
    }
  }
  return result;
}

uint64_t sub_1B65348F4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[4] <= a2)
  {
    sub_1B63F2F54(16, @"Error: CFXSourceAccessorGetVolatileValuePtrAtIndex - index out of bounds : %d > %d", a3, a4, a5, a6, a7, a8, a2);
  }
  else
  {
    uint64_t v8 = a1[2];
    if ((*(unsigned char *)(v8 + 88) & 4) != 0)
    {
      uint64_t v10 = *(void *)(v8 + 72);
      if (v10) {
        return v10 + a1[5] * a2;
      }
    }
    else
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. cannot access volatile data on non volatile source", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor->_source->_dataIsVolatile");
    }
  }
  return 0;
}

uint64_t sub_1B6534974(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t sub_1B653497C(uint64_t a1)
{
  uint64_t result = sub_1B6534714(*(__int16 *)(a1 + 24), *(unsigned __int16 *)(a1 + 26), *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48));
  *(void *)(result + 16) = *(void *)(a1 + 16);
  return result;
}

uint64_t sub_1B65349B8(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_1B65349C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned __int16 *)(a1 + 26);
  return sub_1B63CA534(*(__int16 *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8) * v8;
}

uint64_t sub_1B65349EC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

BOOL sub_1B65349F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(unsigned __int16 *)(a1 + 26);
  return v8 != *(void *)(a1 + 56) + sub_1B63CA534(*(__int16 *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8) * v9;
}

uint64_t sub_1B6534A3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned __int16 *)(a1 + 24) != *(unsigned __int16 *)(a2 + 24)) {
    return 0;
  }
  unsigned int v10 = *(unsigned __int16 *)(a1 + 26);
  unsigned int v11 = *(unsigned __int16 *)(a2 + 26);
  if (v10 > v11) {
    return 0;
  }
  size_t v12 = *(void *)(a2 + 40) * *(void *)(a1 + 32);
  if (!v12) {
    return 0;
  }
  CFDataRef v14 = (const __CFData *)sub_1B6534790(a2, (const char *)a2, a3, a4, a5, a6, a7, a8);
  if (v12 > CFDataGetLength(v14) - *(void *)(a2 + 40) * a3)
  {
    uint64_t v21 = @"Error: The destination does not have enough room to copy this data";
LABEL_16:
    sub_1B63F2F54(16, (uint64_t)v21, v15, v16, v17, v18, v19, v20, v51);
    return 0;
  }
  uint64_t v22 = sub_1B6534884((void *)a2, a3, v15, v16, v17, v18, v19, v20);
  if (!v22)
  {
    uint64_t v21 = @"Error: error in CFXSourceAccessorCopyDataToAccessor";
    goto LABEL_16;
  }
  uint64_t v24 = v22;
  uint64_t v25 = *(void *)(a1 + 40);
  uint64_t v26 = *(unsigned __int16 *)(a1 + 26);
  if (v25 == *(void *)(a1 + 56) + sub_1B63CA534(*(__int16 *)(a1 + 24), v23, v15, v16, v17, v18, v19, v20) * v26)
  {
    uint64_t v34 = *(void *)(a2 + 40);
    uint64_t v35 = *(unsigned __int16 *)(a2 + 26);
    uint64_t v36 = sub_1B63CA534(*(__int16 *)(a2 + 24), v27, v28, v29, v30, v31, v32, v33);
    if (v11 <= v10 && v34 == *(void *)(a2 + 56) + v36 * v35)
    {
      uint64_t v37 = sub_1B6534808((void *)a1, 0, v28, v29, v30, v31, v32, v33);
      memcpy(v24, v37, v12);
      return 1;
    }
  }
  uint64_t v38 = sub_1B6534808((void *)a1, 0, v28, v29, v30, v31, v32, v33);
  uint64_t v39 = *(unsigned __int16 *)(a1 + 26);
  uint64_t v47 = sub_1B63CA534(*(__int16 *)(a1 + 24), v40, v41, v42, v43, v44, v45, v46);
  if (*(uint64_t *)(a1 + 32) < 1) {
    return 1;
  }
  uint64_t v48 = 0;
  size_t v49 = v47 * v39;
  do
  {
    memcpy(v24, v38, v49);
    v38 += *(void *)(a1 + 40);
    uint64_t v24 = (__CFData *)((char *)v24 + *(void *)(a2 + 40));
    ++v48;
    uint64_t result = 1;
  }
  while (v48 < *(void *)(a1 + 32));
  return result;
}

uint64_t sub_1B6534BD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  return *(void *)(a1 + 48);
}

void sub_1B6534C1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  *(void *)(a1 + 48) = a2;
}

void sub_1B6534C6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  *(void *)(a1 + 40) = a2;
}

uint64_t sub_1B6534CBC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 56) = a2;
  return result;
}

uint64_t sub_1B6534CC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  return *(void *)(a1 + 32) * *(void *)(a1 + 40);
}

uint64_t sub_1B6534D14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  return sub_1B63CA534(*(__int16 *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8) * *(unsigned __int16 *)(a1 + 26);
}

CFStringRef sub_1B6534D74(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXSourceAccessor %lx>", a1);
}

CFStringRef sub_1B6534DB4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXSourceAccessor %lx>", a1);
}

__CFArray *sub_1B6534DF4(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v41 = 0;
  int valuePtr = 5;
  uint64_t v40 = *(void *)(a1 + 16) + 64;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v5, @"name", @"accessor");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v41 = 2;
  int valuePtr = 5;
  uint64_t v40 = *(void *)(a1 + 16) + 72;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v9, @"name", @"data");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = v4;
  CFDataRef v14 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 24;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v14, @"name", @"type");
  CFDictionarySetValue(v14, @"type", v15);
  CFDictionarySetValue(v14, @"address", v17);
  CFDictionarySetValue(v14, @"semantic", v16);
  CFArrayAppendValue(Mutable, v14);
  CFRelease(v16);
  CFRelease(v14);
  CFRelease(v17);
  CFRelease(v15);
  uint64_t v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v19 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v13);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 26;
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v19, @"name", @"componentsCountPerValue");
  CFDictionarySetValue(v19, @"type", v20);
  CFDictionarySetValue(v19, @"address", v22);
  CFDictionarySetValue(v19, @"semantic", v21);
  CFArrayAppendValue(Mutable, v19);
  CFRelease(v21);
  CFRelease(v19);
  CFRelease(v22);
  CFRelease(v20);
  uint64_t v23 = CFDictionaryCreateMutable(0, 4, v18, v13);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 32;
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v23, @"name", @"count");
  CFDictionarySetValue(v23, @"type", v24);
  CFDictionarySetValue(v23, @"address", v26);
  CFDictionarySetValue(v23, @"semantic", v25);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v25);
  CFRelease(v23);
  CFRelease(v26);
  CFRelease(v24);
  uint64_t v27 = CFDictionaryCreateMutable(0, 4, v18, v13);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 40;
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v27, @"name", @"stride");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  uint64_t v31 = CFDictionaryCreateMutable(0, 4, v18, v13);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 48;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v31, @"name", @"offset");
  CFDictionarySetValue(v31, @"type", v32);
  CFDictionarySetValue(v31, @"address", v34);
  CFDictionarySetValue(v31, @"semantic", v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  uint64_t v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 56;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v35, @"name", @"padding");
  CFDictionarySetValue(v35, @"type", v36);
  CFDictionarySetValue(v35, @"address", v38);
  CFDictionarySetValue(v35, @"semantic", v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  return Mutable;
}

uint64_t sub_1B6535608(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (!a1[12])
    {
      uint64_t v10 = sub_1B63F4F54(a1, a2, a3, a4, a5, a6, a7, a8);
      if (v10)
      {
        uint64_t v18 = sub_1B64B20C4(v10, v11, v12, v13, v14, v15, v16, v17);
        uint64_t v19 = (void *)sub_1B6355ECC(v18);
        uint64_t EntityObjectWithTag = objc_msgSend_fetchEntityObjectWithTag_(v19, v20, a1[8], v21);
        if (EntityObjectWithTag)
        {
          CFNumberRef v25 = (const void *)EntityObjectWithTag;
          CFNumberRef v26 = (const void *)a1[12];
          if (v26 != v25)
          {
            if (v26)
            {
              CFRelease(v26);
              a1[12] = 0;
            }
            a1[12] = CFRetain(v25);
          }
          objc_msgSend_addEntityObject_(v19, v23, (uint64_t)v25, v24);
        }
      }
    }
  }
  return a1[12];
}

uint64_t sub_1B653569C()
{
  if (qword_1EB995440 != -1) {
    dispatch_once(&qword_1EB995440, &unk_1F0FB5C68);
  }
  return qword_1EB995448;
}

double sub_1B65356E0()
{
  if (!qword_1EB995448)
  {
    qword_1EB995448 = sub_1B63C8D10(&qword_1EB995448);
    qword_1EB983AB8 = (uint64_t)sub_1B6535E8C;
    double result = *(double *)&xmmword_1F0FB87E8;
    xmmword_1EB983AA8 = xmmword_1F0FB87E8;
  }
  return result;
}

uint64_t sub_1B6535748(const void *a1)
{
  if (qword_1EB995440 != -1) {
    dispatch_once(&qword_1EB995440, &unk_1F0FB5C68);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1EB995448, 0x58uLL);
  uint64_t v3 = *(const void **)(v2 + 64);
  if (v3 != a1)
  {
    if (v3)
    {
      CFRelease(v3);
      *(void *)(v2 + 64) = 0;
    }
    if (a1) {
      CFTypeRef v4 = CFRetain(a1);
    }
    else {
      CFTypeRef v4 = 0;
    }
    *(void *)(v2 + 64) = v4;
  }
  return v2;
}

uint64_t sub_1B65357D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  }
  return *(void *)(a1 + 64);
}

uint64_t sub_1B6535824(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  }
  CFTypeRef v10 = *(CFTypeRef *)(a1 + 64);
  if (v10 != cf)
  {
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 64) = 0;
    }
    if (cf) {
      CFTypeRef v11 = CFRetain(cf);
    }
    else {
      CFTypeRef v11 = 0;
    }
    *(void *)(a1 + 64) = v11;
  }
  uint64_t v12 = *(void **)(a1 + 96);

  return objc_msgSend_setTag_(v12, (const char *)cf, (uint64_t)cf, a4);
}

uint64_t sub_1B65358B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 1:
      uint64_t result = 3;
      break;
    case 2:
    case 7:
      uint64_t result = 15;
      break;
    case 3:
    case 8:
      uint64_t result = 13;
      break;
    case 4:
    case 9:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      sub_1B63F2F54(0, @"Warning: binding type %d can't not be exposed", a3, a4, a5, a6, a7, a8, a1);
      uint64_t result = 0;
      break;
    case 5:
    case 6:
    case 10:
      uint64_t result = 2;
      break;
    case 11:
      uint64_t result = 6;
      break;
    case 12:
      uint64_t result = 1;
      break;
    case 13:
      uint64_t result = 7;
      break;
    case 14:
      uint64_t result = 8;
      break;
    case 15:
      uint64_t result = 9;
      break;
    case 16:
      uint64_t result = 11;
      break;
    case 17:
      uint64_t result = 10;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t sub_1B65359E0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B6535A3C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  CFDictionaryRef v10 = *(const __CFDictionary **)(a1 + 72);
  if (!v10) {
    return 0;
  }
  unint64_t Value = (void *)CFDictionaryGetValue(v10, a2);
  if (!Value) {
    return 0;
  }

  return objc_msgSend_type(Value, v12, v13, v14);
}

uint64_t sub_1B6535A3C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(result + 88))
  {
    uint64_t v8 = result;
    uint64_t result = sub_1B6535608((void *)result, 1, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      *(unsigned char *)(v8 + 88) = 1;
      uint64_t v12 = objc_msgSend_bindings((void *)result, v9, v10, v11);
      CFIndex v16 = objc_msgSend_count(v12, v13, v14, v15);
      *(void *)(v8 + 72) = CFDictionaryCreateMutable(0, v16, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFIndex v20 = objc_msgSend_count(v12, v17, v18, v19);
      *(void *)(v8 + 80) = CFArrayCreateMutable(0, v20, MEMORY[0x1E4F1D510]);
      long long v52 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v12, v21, (uint64_t)&v52, (uint64_t)v56, 16);
      if (result)
      {
        uint64_t v25 = result;
        uint64_t v26 = *(void *)v53;
        do
        {
          uint64_t v27 = 0;
          do
          {
            if (*(void *)v53 != v26) {
              objc_enumerationMutation(v12);
            }
            CFNumberRef v28 = *(void **)(*((void *)&v52 + 1) + 8 * v27);
            uint64_t v29 = objc_msgSend_type(v28, v22, v23, v24);
            uint64_t v37 = sub_1B65358B8(v29, v30, v31, v32, v33, v34, v35, v36);
            if (v37)
            {
              uint64_t v38 = v37;
              uint64_t v39 = objc_alloc_init(VFXBindingWrapper);
              objc_msgSend_setBinding_(v39, v40, (uint64_t)v28, v41);
              CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v8 + 80));
              objc_msgSend_setIndex_(v39, v43, Count, v44);
              objc_msgSend_setType_(v39, v45, v38, v46);
              CFArrayAppendValue(*(CFMutableArrayRef *)(v8 + 80), v39);
              uint64_t v47 = *(__CFDictionary **)(v8 + 72);
              uint64_t v51 = (const void *)objc_msgSend_bindingName(v28, v48, v49, v50);
              CFDictionaryAddValue(v47, v51, v39);
            }
            ++v27;
          }
          while (v25 != v27);
          uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v12, v22, (uint64_t)&v52, (uint64_t)v56, 16);
          uint64_t v25 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

CFDictionaryRef sub_1B6535C10(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  sub_1B6535A3C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 72);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, a2);
    if (result) {
      return (const __CFDictionary *)(a1 + (int)(16 * objc_msgSend_index(result, v12, v13, v14)) + v8);
    }
  }
  return result;
}

CFDictionaryRef sub_1B6535C68(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  }
  CFDictionaryRef result = (const __CFDictionary *)sub_1B6535A3C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (a3)
  {
    CFDictionaryRef result = *(const __CFDictionary **)(a1 + 72);
    if (result)
    {
      unint64_t Value = (void *)CFDictionaryGetValue(result, a2);
      CFIndex v16 = objc_msgSend_binding(Value, v13, v14, v15);
      uint64_t v17 = (void *)MEMORY[0x1E4F1C9B8];
      uint64_t v25 = sub_1B6562568(a3, v18, v19, v20, v21, v22, v23, v24);
      uint64_t v33 = sub_1B6562484(a3, v26, v27, v28, v29, v30, v31, v32);
      uint64_t v36 = objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(v17, v34, v25, v33, 0);
      return (const __CFDictionary *)objc_msgSend_setRawValue_(v16, v35, v36, v37);
    }
  }
  return result;
}

uint64_t sub_1B6535D40(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"handle");
  }
  uint64_t v10 = sub_1B6535608(a1, 1, a3, a4, a5, a6, a7, a8);

  return MEMORY[0x1F4181798](v10, sel_setIsEnabled_, a2, v11);
}

id sub_1B6535DB0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (const void *)a1[9];
  if (v9)
  {
    CFRelease(v9);
    a1[9] = 0;
  }
  uint64_t v10 = (const void *)a1[12];
  if (v10)
  {
    CFRelease(v10);
    a1[12] = 0;
  }
  uint64_t v11 = (const void *)a1[10];
  if (v11)
  {
    CFRelease(v11);
    a1[10] = 0;
  }
  uint64_t v12 = (const void *)a1[8];
  if (v12)
  {
    CFRelease(v12);
    a1[8] = 0;
  }

  return sub_1B658325C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B6535E24(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXCoreEntityHandle>");
}

CFStringRef sub_1B6535E58(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXCoreEntityHandle>");
}

__CFArray *sub_1B6535E8C(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v9 = 1;
  int valuePtr = 5;
  uint64_t v8 = *(void *)(a1 + 64);
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v9);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v8);
  CFDictionarySetValue(v3, @"name", @"tag");
  CFDictionarySetValue(v3, @"type", v4);
  CFDictionarySetValue(v3, @"address", v6);
  CFDictionarySetValue(v3, @"semantic", v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  return Mutable;
}

void sub_1B6535FD8(uint64_t a1, int a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10 = a2 - a1;
  if (a2 - (int)a1 >= 0) {
    int v11 = a2 - a1;
  }
  else {
    int v11 = a2 - a1 + 15;
  }
  if (v10 < -15 || CFArrayGetCount(*(CFArrayRef *)(a1 + 80)) < (v11 >> 4))
  {
    uint64_t v14 = @"Error: binding access(write) out of bounds";
LABEL_7:
    sub_1B63F2F54(16, (uint64_t)v14, (uint64_t)a3, a4, a5, a6, a7, a8, a9);
    return;
  }
  CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), (v11 >> 4));
  uint64_t v19 = objc_msgSend_binding(ValueAtIndex, v16, v17, v18);
  if (objc_msgSend_type(v19, v20, v21, v22) == 12)
  {
    uint64_t v26 = objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(MEMORY[0x1E4F1C9B8], v23, (uint64_t)a3, a4, 0);
    uint64_t v30 = objc_msgSend_binding(ValueAtIndex, v27, v28, v29);
    uint64_t v33 = v26;
  }
  else
  {
    signed int v34 = v10 - (v11 & 0xFFFFFFF0);
    uint64_t v35 = objc_msgSend_binding(ValueAtIndex, v23, v24, v25);
    uint64_t v39 = objc_msgSend_rawValue(v35, v36, v37, v38);
    if (a4 + 4 * v34 > objc_msgSend_length(v39, v40, v41, v42))
    {
      uint64_t v14 = @"Error: binding access(write) out of bounds (2)";
      goto LABEL_7;
    }
    uint64_t v44 = objc_msgSend_mutableCopy(v39, v43, (uint64_t)a3, a4);
    uint64_t v48 = objc_msgSend_mutableBytes(v44, v45, v46, v47);
    memcpy((void *)(v48 + 4 * v34), a3, a4);
    uint64_t v30 = objc_msgSend_binding(ValueAtIndex, v49, v50, v51);
    uint64_t v33 = (uint64_t)v44;
  }

  objc_msgSend_setRawValue_(v30, v31, v33, v32);
}

void sub_1B653612C(uint64_t a1, int a2, void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10 = a2 - a1;
  if (a2 - (int)a1 >= 0) {
    int v11 = a2 - a1;
  }
  else {
    int v11 = a2 - a1 + 15;
  }
  if (v10 < -15 || CFArrayGetCount(*(CFArrayRef *)(a1 + 80)) < (v11 >> 4))
  {
    uint64_t v14 = @"Error: binding access(read) out of bounds";
LABEL_7:
    sub_1B63F2F54(16, (uint64_t)v14, (uint64_t)a3, a4, a5, a6, a7, a8, a9);
    return;
  }
  unsigned int v15 = v10 - (v11 & 0xFFFFFFF0);
  CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), (v11 >> 4));
  uint64_t v20 = objc_msgSend_binding(ValueAtIndex, v17, v18, v19);
  uint64_t v24 = objc_msgSend_rawValue(v20, v21, v22, v23);
  if (v15 >= 0x10)
  {
    if (byte_1E9DDB278) {
      return;
    }
    byte_1E9DDB278 = 1;
    uint64_t v14 = @"Error: _CFXCoreEntityHandleGetValue - reading memory out of bounds";
    goto LABEL_7;
  }
  uint64_t v26 = (const void *)(objc_msgSend_bytes(v24, v25, (uint64_t)a3, a4) + 4 * v15);

  memcpy(a3, v26, a4);
}

id sub_1B653623C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 80) || (*(unsigned char *)(a1 + 88) & 4) == 0)
  {
    int v9 = *(const void **)(a1 + 72);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 72) = 0;
    }
  }
  int v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 64) = 0;
  }

  return sub_1B658325C(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B65362A4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXGenericSource %lx>", a1);
}

uint64_t sub_1B65362E4()
{
  if (qword_1EB9954A8 != -1) {
    dispatch_once(&qword_1EB9954A8, &unk_1F0FB5C88);
  }
  return qword_1EB9954B0;
}

double sub_1B6536328()
{
  if (!qword_1EB9954B0)
  {
    qword_1EB9954B0 = sub_1B63C8D10(&qword_1EB9954B0);
    qword_1EB983F30 = (uint64_t)sub_1B6536EC4;
    double result = *(double *)&xmmword_1F0FB8878;
    xmmword_1EB983EE0 = xmmword_1F0FB8878;
  }
  return result;
}

uint64_t sub_1B6536390()
{
  if (qword_1EB9954A8 != -1) {
    dispatch_once(&qword_1EB9954A8, &unk_1F0FB5C88);
  }
  CFTypeID v0 = qword_1EB9954B0;

  return sub_1B63C8D44(v0, 0x50uLL);
}

uint64_t sub_1B65363E8(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  uint64_t v15 = sub_1B6536390();
  if (!v15) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"genericSource");
  }
  sub_1B6536468(v15, a1, v9, v10, v11, v12, v13, v14);
  return v15;
}

CFTypeRef sub_1B6536468(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (cf)
  {
    if (a1) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
    if (a1) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
LABEL_3:
  *(void *)(a1 + 64) = cf;

  return CFRetain(cf);
}

uint64_t sub_1B65364F4(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"accessor");
  }
  uint64_t v17 = sub_1B65363E8(a1, a2, a3, a4, a5, a6, a7, a8);
  *(unsigned char *)(v17 + 88) |= 1u;
  if (v8)
  {
    CFIndex v18 = sub_1B6534CC4((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
    CFMutableArrayRef Mutable = CFDataCreateMutable(0, v18);
    CFIndex v27 = sub_1B6534CC4((uint64_t)a1, v20, v21, v22, v23, v24, v25, v26);
    CFDataSetLength(Mutable, v27);
    sub_1B65365A8(v17, Mutable, v28, v29, v30, v31, v32, v33);
    CFRelease(Mutable);
  }
  return v17;
}

CFTypeRef sub_1B65365A8(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  }
  if ((*(unsigned char *)(a1 + 88) & 4) != 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. cannot set data to volatile source", a3, a4, a5, a6, a7, a8, (uint64_t)"!genericSource->_dataIsVolatile");
  }
  if (*(void *)(a1 + 80)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. cannot set data to MTL buffer", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource->_mtlVertexFormat == 0");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 72);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 72) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 72) = result;
  }
  return result;
}

void sub_1B653666C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  }
  *(void *)(a1 + 72) = a2;
  *(void *)(a1 + 80) = a3;
}

void sub_1B65366C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B65349F4(*(void *)(a1 + 64), a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v17 = sub_1B65368E4(a1, v10, v11, v12, v13, v14, v15, v16);
    unsigned __int8 v19 = BYTE5(v18);
    uint64_t v20 = v18;
    uint64_t v21 = (const void *)sub_1B6534714(BYTE6(v18), HIBYTE(v18), v18, 0, 0);
    sub_1B6492CA0(a2, v21);
    sub_1B6534974((uint64_t)v21, a2);
    CFRelease(v21);
    if (!v17) {
      return;
    }
    size_t v29 = sub_1B6534D14(*(void *)(a1 + 64), v22, v23, v24, v25, v26, v27, v28);
    CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v29 * v20);
    CFDataSetLength(Mutable, v29 * v20);
    BytePtr = CFDataGetBytePtr(Mutable);
    if (v20)
    {
      uint64_t v38 = (UInt8 *)BytePtr;
      int v39 = 0;
      do
      {
        memcpy(v38, &v17[v39], v29);
        v39 += v19;
        v38 += v29;
        --v20;
      }
      while (v20);
    }
    sub_1B65365A8(a2, Mutable, v32, v33, v34, v35, v36, v37);
    uint64_t v40 = Mutable;
    goto LABEL_12;
  }
  uint64_t v41 = (const void *)sub_1B653497C(*(void *)(a1 + 64));
  sub_1B6492CA0(a2, v41);
  sub_1B6534974((uint64_t)v41, a2);
  CFRelease(v41);
  if (*(void *)(a1 + 80))
  {
    sub_1B63F2F54(0, @"Warning: Cannot duplicate a Metal Buffer source. Create an empty data instead.", v42, v43, v44, v45, v46, v47, v67);
    CFIndex capacity = 0;
    uint64_t v50 = (const void *)sub_1B63CC2D0(*(void **)(a1 + 72), (char *)&capacity, v48, v49);
    uint64_t v51 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], capacity);
    CFDataSetLength(v51, capacity);
    MutableBytePtr = CFDataGetMutableBytePtr(v51);
    memcpy(MutableBytePtr, v50, capacity);
    sub_1B65365A8(a2, v51, v53, v54, v55, v56, v57, v58);
    CFRelease(v51);
    return;
  }
  CFDataRef v59 = *(const __CFData **)(a1 + 72);
  if (v59)
  {
    MutableCFArrayRef Copy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v59);
    sub_1B65365A8(a2, MutableCopy, v61, v62, v63, v64, v65, v66);
    uint64_t v40 = MutableCopy;
LABEL_12:
    CFRelease(v40);
  }
}

const UInt8 *sub_1B65368E4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(void **)(a1 + 64);
  if (sub_1B6534790((uint64_t)v8, a2, a3, a4, a5, a6, a7, a8)) {
    uint64_t v15 = sub_1B6534808(v8, 0, v9, v10, v11, v12, v13, v14);
  }
  else {
    uint64_t v15 = 0;
  }
  sub_1B6534800((uint64_t)v8);
  sub_1B65349B8((uint64_t)v8);
  unsigned int v16 = sub_1B6534654((uint64_t)v8);
  int v17 = sub_1B653465C((uint64_t)v8);
  if (v16 != sub_1B63CA908(v16, v18, v19, v20, v21, v22, v23, v24)) {
    sub_1B63CA958(v16, v25, v26, v27, v28, v29, v30, v31);
  }
  sub_1B63CAA3C(v16, v17, v26, v27, v28, v29, v30, v31);
  return v15;
}

void sub_1B65369B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a2 + 88) |= 1u;
}

uint64_t sub_1B65369E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  }
  uint64_t v9 = sub_1B6536390();
  sub_1B65366C8(a1, v9, v10, v11, v12, v13, v14, v15);
  return v9;
}

void *sub_1B6536A44(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  }
  CFTypeRef result = *(void **)(a1 + 72);
  if (*(void *)(a1 + 80))
  {
    return (void *)sub_1B63CC310(result, a2, a3, a4);
  }
  return result;
}

void *sub_1B6536AB4(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  }
  CFTypeRef result = (void *)a1[9];
  if (a1[10])
  {
    return (void *)sub_1B63CC310(result, a2, a3, a4);
  }
  else if (!result)
  {
    CFTypeRef result = (void *)a1[8];
    if (result)
    {
      return sub_1B6534790((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
    }
  }
  return result;
}

uint64_t sub_1B6536B50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  }
  if (*(void *)(a1 + 80)) {
    return *(void *)(a1 + 72);
  }
  else {
    return 0;
  }
}

void sub_1B6536BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource");
  }
  if ((*(unsigned char *)(a1 + 88) & 4) == 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. cannot set volatile data to non volatile source", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource->_dataIsVolatile");
  }
  if (*(void *)(a1 + 80)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. cannot set volatile data to MTL buffer", a3, a4, a5, a6, a7, a8, (uint64_t)"genericSource->_mtlVertexFormat == 0");
  }
  *(void *)(a1 + 72) = a2;
}

uint64_t sub_1B6536C44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  }
  return *(void *)(a1 + 64);
}

uint64_t sub_1B6536C90(uint64_t a1)
{
  return *(unsigned char *)(a1 + 88) & 1;
}

uint64_t sub_1B6536C9C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 88) >> 2) & 1;
}

uint64_t sub_1B6536CA8(uint64_t result)
{
  *(unsigned char *)(result + 88) &= ~1u;
  return result;
}

uint64_t sub_1B6536CB8(uint64_t result)
{
  *(unsigned char *)(result + 88) |= 1u;
  return result;
}

BOOL sub_1B6536CC8(uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return !a1[10] && a1[9] && sub_1B6534790(a1[8], a2, a3, a4, a5, a6, a7, a8) == (void *)a1[9];
}

void sub_1B6536D14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  }
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a1 + 88) & 0xFD | (2 * (a2 != 0));
  if (a2)
  {
    CFDictionaryRef v10 = (const __CFDictionary *)sub_1B65624DC(5, a2, a3, a4, a5, a6, a7, a8);
    *(void *)sub_1B6562568((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17) = a2;
    sub_1B6583914((CFTypeRef *)a1, @"listener", v10, v18, v19, v20, v21, v22);
    if (v10)
    {
      CFRelease(v10);
    }
  }
  else
  {
    sub_1B6583914((CFTypeRef *)a1, @"listener", 0, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B6536E0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  }
  if ((*(unsigned char *)(a1 + 88) & 2) == 0) {
    return 0;
  }
  uint64_t result = (uint64_t)sub_1B6583734(a1, @"listener", a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t result = sub_1B6562568(result, v10, v11, v12, v13, v14, v15, v16);
    if (result) {
      return *(void *)result;
    }
  }
  return result;
}

CFStringRef sub_1B6536E84(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXGenericSource %lx>", a1);
}

uint64_t sub_1B6536EC4(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return a1;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B6536EFC(uint64_t a1, void *__s1, void *__s2, size_t __n)
{
  uint64_t result = memcmp(__s1, __s2, __n);
  if (result)
  {
    memcpy(__s1, __s2, __n);
    uint64_t result = sub_1B6536E0C(a1, v9, v10, v11, v12, v13, v14, v15);
    if (result)
    {
      return (uint64_t)sub_1B63F476C((CFTypeRef)result, a1, v16, v17, v18, v19, v20, v21);
    }
  }
  return result;
}

uint64_t sub_1B653776C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFNumberRef v5 = objc_msgSend_mainBundle(MEMORY[0x1E4F28B50], a2, a3, a4);
  uint64_t v7 = objc_msgSend_pathForResource_ofType_(v5, v6, @"default", @"metallib");
  int v8 = [VFXMTLLibrary alloc];
  uint64_t result = objc_msgSend_initWithPath_manager_(v8, v9, v7, *(void *)(a1 + 32));
  *(void *)(*(void *)(a1 + 32) + 24) = result;
  return result;
}

void sub_1B65378D0(uint64_t a1, uint64_t a2)
{
}

void sub_1B65378E0(uint64_t a1)
{
}

uint64_t sub_1B65378EC(uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v8 = objc_msgSend_objectForKey_(*(void **)(a1[4] + 72), a2, a1[5], a4);
  if (!v8)
  {
    uint64_t v9 = [VFXMTLLibrary alloc];
    int v8 = objc_msgSend_initWithPath_manager_(v9, v10, a1[5], a1[4]);
    objc_msgSend_setObject_forKey_(*(void **)(a1[4] + 72), v11, (uint64_t)v8, a1[5]);
  }
  uint64_t result = objc_msgSend_library(v8, v5, v6, v7);
  *(void *)(*(void *)(a1[6] + 8) + 40) = result;
  return result;
}

dispatch_queue_t sub_1B6538038()
{
  CFTypeID v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  CFAllocatorRef v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_USER_INITIATED, 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.vfx.shader-collection-queue", v1);
  qword_1E9DDB288 = (uint64_t)result;
  return result;
}

void sub_1B653807C(uint64_t a1, const char *a2)
{
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  void v10[2] = sub_1B653816C;
  v10[3] = &unk_1E6143DA8;
  long long v11 = *(_OWORD *)(a1 + 32);
  uint64_t v3 = objc_msgSend_generatorWithProfile_allowingHotReload_(VFXCommonProfileProgramGenerator, a2, 0, 0);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = sub_1B6538204;
  v9[3] = &unk_1E6143DD0;
  _OWORD v9[4] = *(void *)(a1 + 32);
  objc_msgSend_collectShaderForProgram_hashCode_newVertexFunctionName_newFragmentFunctionName_sourceCodeBlock_additionalFileBlock_(v3, v8, v6, v4, v5, v7, v10, v9);
  CFRelease(*(CFTypeRef *)(a1 + 64));
}

void sub_1B653816C(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v22 = *(void *)(a1 + 40);
  uint64_t v23 = 0;
  uint64_t v6 = objc_msgSend_stringWithFormat_(NSString, a2, @"commonProfile_%@.metal", a4, v22);
  uint64_t v9 = objc_msgSend_URLByAppendingPathComponent_(v5, v7, v6, v8);
  if (objc_msgSend_writeToURL_atomically_encoding_error_(a2, v10, v9, 1, 4, &v23)) {
    BOOL v14 = v23 == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14)
  {
    uint64_t v15 = objc_msgSend_localizedDescription(v23, v11, v12, v13);
    sub_1B63F2F54(16, @"Error: Failed to collect shader: %@", v16, v17, v18, v19, v20, v21, v15);
  }
}

void sub_1B6538204(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v46 = 0;
  uint64_t v6 = objc_msgSend_URLByAppendingPathComponent_(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v10 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v7, v8, v9);
  uint64_t v14 = objc_msgSend_path(v6, v11, v12, v13);
  if (objc_msgSend_fileExistsAtPath_(v10, v15, v14, v16))
  {
    uint64_t v20 = objc_msgSend_stringWithContentsOfURL_encoding_error_(NSString, v17, (uint64_t)v6, 4, 0);
    if ((objc_msgSend_isEqualToString_(v20, v21, (uint64_t)a2, v22) & 1) == 0) {
      sub_1B63F2F54(16, @"Error: Failed to collect shader: additional file \"%@\" is not always the same", v23, v24, v25, v26, v27, v28, a3);
    }
  }
  else
  {
    uint64_t v29 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v17, v18, v19);
    uint64_t PathComponent = objc_msgSend_URLByDeletingLastPathComponent(v6, v30, v31, v32);
    objc_msgSend_createDirectoryAtURL_withIntermediateDirectories_attributes_error_(v29, v34, PathComponent, 1, 0, 0);
    if (!objc_msgSend_writeToURL_atomically_encoding_error_(a2, v35, (uint64_t)v6, 1, 4, &v46) || v46)
    {
      uint64_t v45 = objc_msgSend_localizedDescription(v46, v36, v37, v38);
      sub_1B63F2F54(16, @"Error: Failed to collect shader: %@", v39, v40, v41, v42, v43, v44, v45);
    }
  }
}

void sub_1B6538318(uint64_t a1, const char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    long long v11 = *(void **)(a1 + 136);
    if (v11) {
      objc_msgSend_setObject_forKeyedSubscript_(v11, a2, (uint64_t)a3, *(void *)(a1 + 32));
    }
  }
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 88));
    if (!CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 40) + 80), *(const void **)(a1 + 48))) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 40) + 80), *(const void **)(a1 + 48), a2);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 40) + 88));
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 168);
    if (v12
      && (uint64_t v13 = (void (**)(void, void *, uint64_t))sub_1B6451124(v12, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0&& (v18 = *v13) != 0)
    {
      uint64_t v19 = sub_1B6451170(*(void *)(a1 + 168), (uint64_t)a2, (uint64_t)a3, a4, v14, v15, v16, v17);
      v18(0, a3, v19);
    }
    else
    {
      uint64_t v20 = objc_msgSend_description(a3, a2, (uint64_t)a3, a4);
      sub_1B63F2F54(16, @"Error: failed compiling shader:\n%@", v21, v22, v23, v24, v25, v26, v20);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  uint64_t v27 = sub_1B63F2EE0();
  os_signpost_id_t v28 = *(void *)(a1 + 176);
  if (v28 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v29 = v27;
    if (os_signpost_enabled(v27))
    {
      int v30 = *(_DWORD *)(a1 + 184);
      *(_DWORD *)buf = 67109120;
      int v32 = v30;
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v29, OS_SIGNPOST_INTERVAL_END, v28, "CompileShader", "programID=%d", buf, 8u);
    }
  }
}

void sub_1B65384AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  _OWORD v5[2] = sub_1B6538528;
  v5[3] = &unk_1E6143E48;
  long long v3 = *(_OWORD *)(a1 + 32);
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  _OWORD v5[4] = a2;
  v5[5] = a3;
  long long v6 = v3;
  dispatch_async(v4, v5);
}

void sub_1B6538528(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  CFAllocatorRef v2 = *(NSObject **)(*(void *)(a1 + 48) + 48);

  dispatch_group_leave(v2);
}

void sub_1B6538574(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1B65385F4;
  block[3] = &unk_1E6143E98;
  uint64_t v4 = *(void *)(a1 + 40);
  void block[5] = a3;
  void block[6] = v4;
  block[4] = a2;
  dispatch_async(v3, block);
}

uint64_t sub_1B65385F4(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

__n128 sub_1B653860C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = CFX::RG::Pass::Pass(a1, a2, a3, *a4, 4, a5, a6);
  *(void *)uint64_t v7 = &unk_1F0FB3088;
  __n128 result = *(__n128 *)a4;
  *(_OWORD *)(v7 + 360) = *(_OWORD *)a4;
  return result;
}

uint64_t sub_1B6538668(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  switch(a3)
  {
    case 2:
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result + 56))(result, a2, a4 + 8);
    case 1:
      return (*(uint64_t (**)(void))(*(void *)result + 48))();
    case 0:
      return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1B65386F4(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6538734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F0FB3738;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 16) = a2;
  uint64_t v9 = sub_1B644558C(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 24) = v9;
  uint64_t v17 = sub_1B64B28FC(v9, v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 32) = v17;
  *(_WORD *)(a1 + 48) = 15;
  sub_1B6624920(v17, 0xFu);
  return a1;
}

void sub_1B65387D8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(void **)(v1 + 432);
  if (v4) {

  }
  if (*v2) {
  _Unwind_Resume(exception_object);
  }
}

uint64_t sub_1B65387FC(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB3738;
  sub_1B6624994(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 48));
  CFAllocatorRef v2 = *(void **)(a1 + 432);
  if (v2) {

  }
  long long v3 = *(void **)(a1 + 424);
  if (v3) {

  }
  return a1;
}

void sub_1B6538860(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)(v1 + 432);
  if (v3) {

  }
  uint64_t v4 = *(void **)(v1 + 424);
  if (v4) {

  }
  _Unwind_Resume(exception_object);
}

void sub_1B6538888(uint64_t a1)
{
  sub_1B65387FC(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B65388C0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)sub_1B6445900(a1[2], a2, a3, a4, a5, a6, a7, a8);
  uint64_t v13 = objc_msgSend_resourceManager(v9, v10, v11, v12);
  uint64_t v21 = sub_1B644558C(a1[2], v14, v15, v16, v17, v18, v19, v20);
  uint64_t v29 = sub_1B6446564((uint64_t *)a1[2], v22, v23, v24, v25, v26, v27, v28);
  if (v29)
  {
    CFDictionaryRef v37 = sub_1B64A3B48((uint64_t)v29, v30, v31, v32, v33, v34, v35, v36);
    if (v37)
    {
      uint64_t v38 = (uint64_t)v37;
      __int16 v70 = 0;
      uint64_t v39 = sub_1B64B2810(v21, 0);
      uint64_t v47 = sub_1B64B27BC(v21, 0);
      if (v47) {
        HIBYTE(v70) = objc_msgSend_textureForMaterialProperty_(v9, v40, v47, v42) != 0;
      }
      if (v39) {
        LOBYTE(v70) = objc_msgSend_textureForMaterialProperty_(v9, v40, v39, v42) != 0;
      }
      unsigned int v48 = sub_1B649B4B8(v38, (uint64_t)v40, v41, v42, v43, v44, v45, v46);
      char v69 = v48;
      unsigned int v68 = sub_1B6626FAC(a1[4]);
      int v49 = sub_1B6626FBC(a1[4]);
      BOOL v67 = v49 != 0;
      unint64_t v50 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v47) ^ ((0x9DDFEA08EB382D69 * v47) >> 47));
      unint64_t v51 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                            * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47))) ^ v39)));
      unint64_t v52 = 0x9DDFEA08EB382D69 * (v51 ^ (v51 >> 47));
      unint64_t v53 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v68)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v68)))) ^ ((0x9DDFEA08EB382D69 * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v68)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v68)))) >> 47));
      unint64_t v54 = 0x9DDFEA08EB382D69
          * (v53 ^ ((0x9DDFEA08EB382D69 * (v53 ^ (v49 != 0))) >> 47) ^ (0x9DDFEA08EB382D69 * (v53 ^ (v49 != 0))));
      unint64_t v55 = 0x9DDFEA08EB382D69 * (v54 ^ (v54 >> 47));
      unint64_t v56 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v48)))) ^ ((0x9DDFEA08EB382D69 * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v48)))) >> 47));
      if (a1[52] != v56)
      {
        a1[52] = v56;
        sub_1B6626AF8(a1[4], a1[2]);
        id v57 = objc_alloc_init(MEMORY[0x1E4F35228]);
        objc_msgSend_setConstantValue_type_withName_(v57, v58, (uint64_t)&v70 + 1, 53, @"has_background");
        objc_msgSend_setConstantValue_type_withName_(v57, v59, (uint64_t)&v70, 53, @"has_IBL");
        objc_msgSend_setConstantValue_type_withName_(v57, v60, (uint64_t)&v69, 53, @"has_DOF");
        objc_msgSend_setConstantValue_type_withName_(v57, v61, (uint64_t)&v68, 33, @"LightCount");
        objc_msgSend_setConstantValue_type_withName_(v57, v62, (uint64_t)&v67, 33, @"raytracing_use_function_constant");
        uint64_t v63 = sub_1B6626EDC(a1[4]);
        uint64_t v65 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_linkedFunctions_(v13, v64, @"vfx_path_tracer", (uint64_t)v57, v63);

        uint64_t v66 = (void *)a1[53];
        if (v66 != (void *)v65)
        {
          if (v66) {

          }
          a1[53] = v65;
        }
        sub_1B6626E64(a1[4]);
      }
    }
  }
}

uint64_t sub_1B6538B44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFX::CrossFrameResourceManager **a5, uint64_t *a6)
{
  uint64_t v10 = *a6;
  v47[0] = (uint64_t)"PathTracerPass";
  v47[1] = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB2A0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v45 = a2;
    uint64_t v46 = a3;
    int v44 = __cxa_guard_acquire(&qword_1E9DDB2A0);
    a2 = v45;
    a3 = v46;
    if (v44)
    {
      byte_1E9DDB298 = 1;
      __cxa_guard_release(&qword_1E9DDB2A0);
      a2 = v45;
      a3 = v46;
    }
  }
  if (byte_1E9DDB298) {
    uint64_t v11 = 0x3A712055557F5840;
  }
  else {
    uint64_t v11 = 0;
  }
  sub_1B653860C(a1, a2, a3, v47, v11, 0);
  *(void *)a1 = &unk_1F0FB3778;
  *(_OWORD *)(a1 + 376) = *(_OWORD *)a6;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(void *)(a1 + 456) = 0;
  uint64_t v19 = (void *)sub_1B6445900(*(void *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  *(void *)(a1 + 448) = v19;
  *(void *)(a1 + 456) = objc_msgSend_resourceManager(v19, v20, v21, v22);
  uint64_t v23 = a5[4];
  unint64_t v24 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v25 = (uint64_t *)CFX::CrossFrameResourceManager::get(v23, v24);
  *(void *)(a1 + 392) = v25;
  if (!v25)
  {
    CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    v47[0] = *(void *)(a1 + 368);
    sub_1B6538F8C();
  }
  sub_1B65388C0(v25, v26, v27, v28, v29, v30, v31, v32);
  CFX::RG::RenderGraphBuilder::findPublishedResource(a4, *(void *)(a1 + 384));
  uint64_t v34 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a5, v33);
  uint64_t v35 = *v34;
  uint64_t v36 = v34[1];
  uint64_t v37 = *((void *)v34 + 2);
  unint64_t v38 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v39 = 0x9DDFEA08EB382D69
      * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v35)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v35)));
  unint64_t v40 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v39 ^ (v39 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v39 ^ (v39 >> 47))) ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v39 ^ (v39 >> 47))) ^ v36)));
  unint64_t v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
  uint64_t v42 = CFX::CrossFrameResourceManager::get(a5[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v41 ^ ((0x9DDFEA08EB382D69 * (v41 ^ v37)) >> 47) ^ (0x9DDFEA08EB382D69 * (v41 ^ v37)))) ^ ((0x9DDFEA08EB382D69 * (v41 ^ ((0x9DDFEA08EB382D69 * (v41 ^ v37)) >> 47) ^ (0x9DDFEA08EB382D69 * (v41 ^ v37)))) >> 47)));
  *(void *)(a1 + 400) = v42;
  if (!v42) {
    operator new();
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(v42 + 8 * (*(unsigned char *)(v42 + 32) == 0) + 16));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 400) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 400) + 32) + 16));
  return a1;
}

void sub_1B6538F5C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6538F8C()
{
}

void sub_1B6538FF4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A1C40A12BA9B8);
  _Unwind_Resume(a1);
}

void sub_1B653901C(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(*(void *)(a1 + 392) + 424)) {
    return;
  }
  uint64_t v10 = *a3;
  uint64_t v11 = sub_1B644558C(*(void *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = sub_1B6446564(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  if (!v19) {
    return;
  }
  CFDictionaryRef v27 = sub_1B64A3B48((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26);
  if (!v27) {
    return;
  }
  uint64_t v35 = (uint64_t)v27;
  uint64_t v36 = sub_1B6446564(*(uint64_t **)(a1 + 368), v28, v29, v30, v31, v32, v33, v34);
  sub_1B63E0460((uint64_t)v36, (uint64_t)v207, v37, v38, v39, v40, v41, v42);
  uint64_t v43 = (float32x4_t *)sub_1B6447988(*(void *)(a1 + 368), 1);
  float32x4_t v203 = v43[1];
  float32x4_t v204 = *v43;
  float32x4_t v202 = v43[2];
  float32x4_t v205 = v43[3];
  __n128 v206 = 0uLL;
  __n128 v206 = sub_1B64471F4(*(void *)(a1 + 368), 0, v44, v45, v46, v47, v48, v49);
  uint64_t v57 = sub_1B64B28FC(v11, v50, v51, v52, v53, v54, v55, v56);
  sub_1B6626AF8(v57, *(void *)(a1 + 368));
  uint64_t v58 = *(_OWORD **)(a1 + 392);
  v58[8] = v204;
  v58[9] = v203;
  v58[10] = v202;
  v58[11] = v205;
  *(simd_float4x4 *)(*(void *)(a1 + 392) + 192) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 392) + 128));
  uint64_t v65 = sub_1B649CD50(v207, (uint64_t)&v206, v59, v60, v61, v62, v63, v64);
  uint64_t v66 = 0;
  long long v67 = *((_OWORD *)v65 + 1);
  long long v68 = *((_OWORD *)v65 + 2);
  long long v69 = *((_OWORD *)v65 + 3);
  __int16 v70 = *(_OWORD **)(a1 + 392);
  v70[16] = *(_OWORD *)v65;
  v70[17] = v67;
  v70[18] = v68;
  v70[19] = v69;
  uint64_t v71 = *(float32x4_t **)(a1 + 392);
  float32x4_t v72 = v71[16];
  float32x4_t v73 = v71[17];
  float32x4_t v74 = v71[18];
  float32x4_t v75 = v71[19];
  float32x4_t v76 = v71[9];
  float32x4_t v77 = v71[10];
  float32x4_t v78 = v71[11];
  v208[0] = v71[8];
  v208[1] = v76;
  v208[2] = v77;
  v208[3] = v78;
  do
  {
    v209.columns[v66] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v72, COERCE_FLOAT(v208[v66])), v73, *(float32x2_t *)&v208[v66], 1), v74, (float32x4_t)v208[v66], 2), v75, (float32x4_t)v208[v66], 3);
    ++v66;
  }
  while (v66 != 4);
  *(simd_float4x4 *)(*(void *)(a1 + 392) + 320) = __invert_f4(v209);
  float v86 = sub_1B649C30C(v35, v79, v80, v81, v82, v83, v84, v85);
  float v94 = sub_1B649C59C(v35, v87, v88, v89, v90, v91, v92, v93) / 1000.0;
  uint64_t v102 = sub_1B649A680(v35, v95, v96, v97, v98, v99, v100, v101);
  if (v102) {
    int v110 = sub_1B6529470(v102, v103, v104, v105, v106, v107, v108, v109);
  }
  else {
    int v110 = 1;
  }
  float v111 = v94 * 1.5;
  uint64_t v112 = *(void *)(a1 + 392);
  BOOL v113 = v86 != *(float *)(v112 + 392) || v111 != *(float *)(v112 + 396) || v110 != *(_DWORD *)(v112 + 400);
  *(float *)(v112 + 392) = v86;
  *(float *)(v112 + 396) = v111;
  *(_DWORD *)(v112 + 400) = v110;
  uint64_t v114 = sub_1B64B2810(v11, 0);
  if (v114) {
    float v122 = sub_1B64763AC(v114, v115, v116, v117, v118, v119, v120, v121);
  }
  else {
    float v122 = 0.0;
  }
  uint64_t v123 = *(float32x4_t **)(a1 + 392);
  v123[25].f32[1] = v122;
  if (v113
    || (int16x4_t v124 = vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v205, v123[7]))), v124.i8[0] & 1 | v124.i8[2] & 1))
  {
    sub_1B644689C(*(void *)(a1 + 368), v115, v116, v117, v118, v119, v120, v121);
  }
  else
  {
    __int8 v189 = v124.i8[4];
    uint64_t v190 = sub_1B644689C(*(void *)(a1 + 368), v115, v116, v117, v118, v119, v120, v121);
    if ((v189 & 1) == 0)
    {
      unsigned int v191 = (void *)v190;
      if (!sub_1B6626E5C(v57)) {
        goto LABEL_21;
      }
      uint64_t v194 = objc_msgSend_world(v191, v125, v192, v193);
      uint64_t v198 = objc_msgSend_clock(v194, v195, v196, v197);
      if (objc_msgSend_isPaused(v198, v199, v200, v201)) {
        goto LABEL_21;
      }
    }
  }
  *(_DWORD *)(*(void *)(a1 + 392) + 384) = 0;
LABEL_21:
  objc_msgSend_setBytes_length_atIndex_(v10, v125, *(void *)(a1 + 392) + 128, 288, 8);
  for (uint64_t i = 0; i != 5; ++i)
  {
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 408 + 8 * i));
    objc_msgSend_setTexture_atIndex_(v10, v128, (uint64_t)Texture, i);
  }
  uint64_t v129 = sub_1B64B27BC(v11, 0);
  if (v129)
  {
    uint64_t v132 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 448), v130, v129, v131);
    if (v132) {
      objc_msgSend_setTexture_atIndex_(v10, v133, v132, 5);
    }
  }
  uint64_t v134 = sub_1B64B2810(v11, 0);
  if (v134)
  {
    uint64_t v137 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 448), v135, v134, v136);
    if (v137) {
      objc_msgSend_setTexture_atIndex_(v10, v138, v137, 6);
    }
  }
  id v139 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 400)+ 8 * *(unsigned __int8 *)(*(void *)(a1 + 400) + 32)+ 16));
  id v140 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 400)+ 8 * (*(unsigned char *)(*(void *)(a1 + 400) + 32) == 0)+ 16));
  objc_msgSend_setTexture_atIndex_(v10, v141, (uint64_t)v139, 10);
  objc_msgSend_setTexture_atIndex_(v10, v142, (uint64_t)v140, 11);
  uint64_t v143 = sub_1B6626EB4(v57);
  objc_msgSend_useHeap_(v10, v144, v143, v145);
  uint64_t v146 = sub_1B6626EC4(v57);
  objc_msgSend_setBuffer_offset_atIndex_(v10, v147, v146, 0, 0);
  uint64_t v148 = sub_1B6626EBC(v57);
  objc_msgSend_setAccelerationStructure_atBufferIndex_(v10, v149, v148, 1);
  if (sub_1B6626FAC(v57))
  {
    uint64_t v150 = sub_1B6626ECC(v57);
    objc_msgSend_setBuffer_offset_atIndex_(v10, v151, v150, 0, 2);
  }
  if (sub_1B6626FBC(v57))
  {
    uint64_t v158 = *(void *)(a1 + 392);
    uint64_t v159 = *(void *)(v158 + 424);
    if (!v159)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v152, v153, v154, v155, v156, v157, (uint64_t)"_ptr != NULL");
      uint64_t v159 = *(void *)(v158 + 424);
    }
    simd_float4 v160 = (void *)sub_1B653EFB8(v159);
    simd_float4 v161 = sub_1B6626EE4(v57, v160);
    objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v10, v162, (uint64_t)v161, 3);
  }
  else
  {
    simd_float4 v161 = 0;
  }
  uint64_t v163 = sub_1B6626ED4(v57);
  unsigned int v167 = sub_1B6626FCC(v57, v164, v165, v166);
  objc_msgSend_useResources_count_usage_(v10, v168, v163, v167, 1);
  uint64_t v175 = *(void *)(a1 + 392);
  uint64_t v176 = *(void *)(v175 + 424);
  if (!v176)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v169, v170, v171, v172, v173, v174, (uint64_t)"_ptr != NULL");
    uint64_t v176 = *(void *)(v175 + 424);
  }
  uint64_t v177 = sub_1B653EFB8(v176);
  objc_msgSend_dispatch_onTexture2D_(v10, v178, v177, (uint64_t)v139);

  uint64_t v179 = *(_OWORD **)(a1 + 392);
  long long v180 = v179[9];
  v179[4] = v179[8];
  v179[5] = v180;
  long long v181 = v179[11];
  v179[6] = v179[10];
  v179[7] = v181;
  *(int32x2_t *)(*(void *)(a1 + 392) + 384) = vadd_s32(*(int32x2_t *)(*(void *)(a1 + 392) + 384), (int32x2_t)0x100000001);
  sub_1B6626E64(v57);
  *(unsigned char *)(*(void *)(a1 + 400) + 32) ^= 1u;
  sub_1B64460E8(*(void *)(a1 + 368), v182, v183, v184, v185, v186, v187, v188);
}

uint64_t *sub_1B6539564(uint64_t *this, CFX::RG::Resource *a2, unsigned int a3)
{
  this[a3 + 51] = (uint64_t)a2;
  return CFX::RG::Pass::readFrom(this, a2);
}

uint64_t sub_1B6539570(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 400) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 400) + 32) + 16);
}

uint64_t sub_1B6539584(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  return sub_1B6539594(a1, (uint64_t)a1, a2, a3);
}

uint64_t sub_1B6539594(uint64_t *a1, uint64_t a2, CFX::CrossFrameResourceManager **a3, uint64_t *a4)
{
  uint64_t v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B6539704(v9[0], v7, v9, a2, a3, a4);
  sub_1B63C88CC(a1 + 18, v9);
  return v9[0];
}

void sub_1B65395F4(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B653962C(void *a1)
{
  *a1 = &unk_1F0FB3758;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B6539688(void *a1)
{
  *a1 = &unk_1F0FB3758;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6539704(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, CFX::CrossFrameResourceManager **a5, uint64_t *a6)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v10 = sub_1B63C8330(v12, 0x1D0u, 8u);
  return sub_1B6538B44(v10, *a3, a3[1], a4, a5, a6);
}

CFTypeRef sub_1B653976C(uint64_t a1)
{
  sub_1B65691B4();
  CFTypeRef result = *(CFTypeRef *)(a1 + 152);
  if (!result)
  {
    uint64_t v10 = (const void *)sub_1B63CCE68(a1, v2, v3, v4, v5, v6, v7, v8);
    uint64_t v11 = (uint64_t)v10;
    if (*(unsigned char *)(a1 + 128))
    {
      uint64_t v12 = sub_1B63F2EE0();
      os_signpost_id_t v13 = os_signpost_id_generate(v12);
      uint64_t v14 = sub_1B63F2EE0();
      if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v15 = v14;
        if (os_signpost_enabled(v14))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_1B6287000, v15, OS_SIGNPOST_INTERVAL_BEGIN, v13, "Subdivision", "", buf, 2u);
        }
      }
      sub_1B6569528(a1);
      sub_1B656A374((void *)(a1 + 128), v11, v16, v17, v18, v19, v20, v21);
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      *(_OWORD *)buf = 0u;
      sub_1B656AA44((uint64_t)buf, a1 + 128, v11, v22, v23, v24, v25, v26);
      sub_1B656A8AC(a1 + 128, v27, v28, v29, v30, v31, v32, v33);
    }
    CFTypeRef result = CFRetain(v10);
    *(void *)(a1 + 152) = result;
  }
  return result;
}

uint64_t sub_1B6539970(uint64_t a1)
{
  uint64_t v5 = (void **)(a1 + 216);
  sub_1B6539A3C(&v5);
  uint64_t v5 = (void **)(a1 + 192);
  sub_1B6539B14(&v5);
  uint64_t v5 = (void **)(a1 + 168);
  sub_1B6539B14(&v5);
  uint64_t v5 = (void **)(a1 + 144);
  sub_1B6539B14(&v5);
  uint64_t v5 = (void **)(a1 + 120);
  sub_1B6539B14(&v5);
  uint64_t v5 = (void **)(a1 + 96);
  sub_1B6539B14(&v5);
  uint64_t v5 = (void **)(a1 + 72);
  sub_1B6539B14(&v5);
  uint64_t v5 = (void **)(a1 + 48);
  sub_1B6539C00(&v5);
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1B6539A3C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 9;
        sub_1B6539AC0(v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1B6539AC0(void **a1)
{
  uint64_t v2 = a1 + 6;
  sub_1B6539B14(&v2);
  uint64_t v2 = a1 + 3;
  sub_1B6539B14(&v2);
  uint64_t v2 = a1;
  sub_1B6539B14(&v2);
}

void sub_1B6539B14(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 112;
        sub_1B6539B98(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1B6539B98(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
}

void sub_1B6539C00(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1B6539C54((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1B6539C54(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    uint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

unint64_t sub_1B6539CA4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v5 = objc_msgSend_allKeys(a1, a2, a3, a4);
  uint64_t v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v6, (uint64_t)&v29, (uint64_t)v34, 16);
  if (v7)
  {
    uint64_t v11 = v7;
    unint64_t v12 = 0;
    uint64_t v13 = *(void *)v30;
    do
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v30 != v13) {
          objc_enumerationMutation(v5);
        }
        v12 ^= (v12 << 6)
             + 2654435769u
             + (v12 >> 2)
             + objc_msgSend_hash(*(void **)(*((void *)&v29 + 1) + 8 * i), v8, v9, v10);
      }
      uint64_t v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v8, (uint64_t)&v29, (uint64_t)v34, 16);
    }
    while (v11);
  }
  else
  {
    unint64_t v12 = 0;
  }
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v15 = objc_msgSend_allValues(a1, v8, v9, v10, 0);
  uint64_t v17 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v16, (uint64_t)&v25, (uint64_t)v33, 16);
  if (v17)
  {
    uint64_t v21 = v17;
    uint64_t v22 = *(void *)v26;
    do
    {
      for (uint64_t j = 0; j != v21; ++j)
      {
        if (*(void *)v26 != v22) {
          objc_enumerationMutation(v15);
        }
        v12 ^= (v12 << 6)
             + 2654435769u
             + (v12 >> 2)
             + objc_msgSend_hash(*(void **)(*((void *)&v25 + 1) + 8 * j), v18, v19, v20);
      }
      uint64_t v21 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v18, (uint64_t)&v25, (uint64_t)v33, 16);
    }
    while (v21);
  }
  return v12;
}

uint64_t sub_1B6539E54(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  CC_SHA256_Init(&v3);
  sub_1B6604178(a1, (uint64_t)&v3);
  CC_SHA256_Final(md, &v3);
  return *(void *)md;
}

void sub_1B6539FF0(uint64_t a1)
{
}

uint64_t sub_1B6539FF8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = sub_1B64E3388(a1, 0, a3, a4, a5, a6, a7, a8);
  unint64_t v10 = HIDWORD(v9);
  uint64_t v14 = objc_msgSend_colorAttachments(a2, v11, v12, v13);
  uint64_t v17 = objc_msgSend_objectAtIndexedSubscript_(v14, v15, 0, v16);
  uint64_t v21 = objc_msgSend_pixelFormat(v17, v18, v19, v20);
  if ((_BYTE)v9) {
    BOOL v24 = v21 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (v24) {
    objc_msgSend_setBlendingEnabled_(v17, v22, 0, v23);
  }
  else {
    objc_msgSend_setBlendingEnabled_(v17, v22, 1, v23);
  }
  uint64_t v32 = sub_1B64D7A48(BYTE2(v9), v25, v26, v27, v28, v29, v30, v31);
  objc_msgSend_setSourceRGBBlendFactor_(v17, v33, v32, v34);
  uint64_t v42 = sub_1B64D7A48(BYTE3(v9), v35, v36, v37, v38, v39, v40, v41);
  objc_msgSend_setDestinationRGBBlendFactor_(v17, v43, v42, v44);
  uint64_t v52 = sub_1B64D7AA0(BYTE4(v9), v45, v46, v47, v48, v49, v50, v51);
  objc_msgSend_setRgbBlendOperation_(v17, v53, v52, v54);
  unint64_t v62 = HIBYTE(v9);
  unint64_t v63 = v9 >> 40;
  BOOL v64 = (v9 & 0xFF00) == 0;
  if ((v9 & 0xFF00) != 0)
  {
    unsigned __int8 v65 = BYTE6(v9);
  }
  else
  {
    LOBYTE(v63) = BYTE2(v9);
    unsigned __int8 v65 = BYTE3(v9);
  }
  if (v64) {
    unsigned __int8 v66 = v10;
  }
  else {
    unsigned __int8 v66 = v62;
  }
  uint64_t v67 = sub_1B64D7A48(v63, v55, v56, v57, v58, v59, v60, v61);
  objc_msgSend_setSourceAlphaBlendFactor_(v17, v68, v67, v69);
  uint64_t v77 = sub_1B64D7A48(v65, v70, v71, v72, v73, v74, v75, v76);
  objc_msgSend_setDestinationAlphaBlendFactor_(v17, v78, v77, v79);
  uint64_t v87 = sub_1B64D7AA0(v66, v80, v81, v82, v83, v84, v85, v86);

  return MEMORY[0x1F4181798](v17, sel_setAlphaBlendOperation_, v87, v88);
}

void *sub_1B653A10C(uint64_t a1, uint64_t a2)
{
  self;
  if (qword_1EB995F48 != -1) {
    dispatch_once(&qword_1EB995F48, &unk_1F0FB5CC8);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&dword_1EB9965C0);
  uint64_t v5 = objc_msgSend_objectForKey_((void *)qword_1EB9956F0, v3, a2, v4);
  if (!v5)
  {
    uint64_t v6 = [VFXMTLResourceManager alloc];
    uint64_t v5 = objc_msgSend_initWithDevice_(v6, v7, a2, v8);
    objc_msgSend_setObject_forKey_((void *)qword_1EB9956F0, v9, (uint64_t)v5, a2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_1EB9965C0);
  return v5;
}

uint64_t sub_1B653A1C0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  dword_1EB9965C0 = 0;
  qword_1EB9956F0 = (uint64_t)(id)objc_msgSend_weakToStrongObjectsMapTable(MEMORY[0x1E4F28E10], a2, a3, a4);
  objc_msgSend_allocateRegistry(VFXMTLShaderBindingsGenerator, v4, v5, v6);

  return MEMORY[0x1F4181798](VFXMTLRenderContext, sel_registerBindings, v7, v8);
}

uint64_t sub_1B653A26C(uint64_t *a1, int a2)
{
  if (a2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 258;
  }
  id v4 = objc_alloc(MEMORY[0x1E4F28E10]);
  uint64_t result = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v4, v5, v3, 0, 100);
  *a1 = result;
  return result;
}

uint64_t sub_1B653A6F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](a2, sel__rasterizerStateDidDie_, a4, a4);
}

uint64_t sub_1B653AD6C(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  objc_msgSend_removeObjectForKey_(a3, a2, *(void *)(a1 + 32), a4);
  uint64_t v8 = *(void *)(a1 + 32) | 1;

  return objc_msgSend_removeObjectForKey_(a3, v6, v8, v7);
}

uint64_t sub_1B653ADB8(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  objc_msgSend_removeObjectForKey_(a3, a2, *(void *)(a1 + 32), a4);
  uint64_t v8 = *(void *)(a1 + 32) | 1;

  return objc_msgSend_removeObjectForKey_(a3, v6, v8, v7);
}

void sub_1B653B318(void *value, uint64_t a2, void *a3)
{
  if (!*a3 || *(void *)(a2 + 24) == *a3)
  {
    uint64_t v5 = a3[1];
    if (!v5 || *(void *)(a2 + 16) == v5)
    {
      CFMutableArrayRef Mutable = (__CFArray *)a3[2];
      if (!Mutable)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
        a3[2] = Mutable;
      }
      CFArrayAppendValue(Mutable, value);
    }
  }
}

void sub_1B653B980(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    objc_msgSend_clearCompiledLibraries(*(void **)(a1 + 32), a2, a3, a4);
    uint64_t v5 = *(__CFDictionary **)(a1 + 48);
    CFDictionaryRemoveAllValues(v5);
  }
}

void *sub_1B653B9C4(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  id v4 = (os_unfair_lock_s *)(a1 + 256);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 256));
  uint64_t v7 = *(void **)(a1 + 248);
  if (!v7)
  {
    id v8 = objc_alloc(MEMORY[0x1E4F28E10]);
    uint64_t v7 = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v8, v9, 258, 0, 100);
    *(void *)(a1 + 248) = v7;
  }
  uint64_t v16 = objc_msgSend_objectForKey_(v7, v5, a2, v6);
  if (!v16)
  {
    uint64_t v172 = 0;
    uint64_t v173 = 0;
    int v175 = 0;
    uint64_t v174 = 0;
    sub_1B6451740(a2, v10, v11, v12, v13, v14, v15, (uint64_t)&v172);
    id v24 = objc_alloc_init(MEMORY[0x1E4F35218]);
    if ((_BYTE)v173)
    {
      uint64_t v25 = sub_1B64D7B50(BYTE2(v173), (uint64_t)v17, v18, v19, v20, v21, v22, v23);
      objc_msgSend_setDepthCompareFunction_(v24, v26, v25, v27);
    }
    else
    {
      objc_msgSend_setDepthCompareFunction_(v24, v17, 7, v19);
    }
    objc_msgSend_setDepthWriteEnabled_(v24, v28, BYTE1(v173), v29);
    if (BYTE3(v173))
    {
      uint64_t v37 = sub_1B64D7AF8(BYTE5(v173), (uint64_t)v30, v31, v32, v33, v34, v35, v36);
      uint64_t v41 = objc_msgSend_frontFaceStencil(v24, v38, v39, v40);
      objc_msgSend_setStencilCompareFunction_(v41, v42, v37, v43);
      uint64_t v51 = sub_1B64D7BA8(BYTE3(v174), v44, v45, v46, v47, v48, v49, v50);
      uint64_t v55 = objc_msgSend_frontFaceStencil(v24, v52, v53, v54);
      objc_msgSend_setStencilFailureOperation_(v55, v56, v51, v57);
      uint64_t v65 = sub_1B64D7BA8(BYTE2(v174), v58, v59, v60, v61, v62, v63, v64);
      uint64_t v69 = objc_msgSend_frontFaceStencil(v24, v66, v67, v68);
      objc_msgSend_setDepthFailureOperation_(v69, v70, v65, v71);
      uint64_t v79 = sub_1B64D7BA8(BYTE1(v174), v72, v73, v74, v75, v76, v77, v78);
      uint64_t v83 = objc_msgSend_frontFaceStencil(v24, v80, v81, v82);
      objc_msgSend_setDepthStencilPassOperation_(v83, v84, v79, v85);
      uint64_t v86 = BYTE6(v173);
      uint64_t v90 = objc_msgSend_frontFaceStencil(v24, v87, v88, v89);
      objc_msgSend_setReadMask_(v90, v91, v86, v92);
      uint64_t v93 = HIBYTE(v173);
      uint64_t v97 = objc_msgSend_frontFaceStencil(v24, v94, v95, v96);
      objc_msgSend_setWriteMask_(v97, v98, v93, v99);
      uint64_t v107 = sub_1B64D7AF8(BYTE4(v174), v100, v101, v102, v103, v104, v105, v106);
      float v111 = objc_msgSend_backFaceStencil(v24, v108, v109, v110);
      objc_msgSend_setStencilCompareFunction_(v111, v112, v107, v113);
      uint64_t v121 = sub_1B64D7BA8(BYTE2(v175), v114, v115, v116, v117, v118, v119, v120);
      uint64_t v125 = objc_msgSend_backFaceStencil(v24, v122, v123, v124);
      objc_msgSend_setStencilFailureOperation_(v125, v126, v121, v127);
      uint64_t v135 = sub_1B64D7BA8(BYTE1(v175), v128, v129, v130, v131, v132, v133, v134);
      id v139 = objc_msgSend_backFaceStencil(v24, v136, v137, v138);
      objc_msgSend_setDepthFailureOperation_(v139, v140, v135, v141);
      uint64_t v149 = sub_1B64D7BA8(v175, v142, v143, v144, v145, v146, v147, v148);
      uint64_t v153 = objc_msgSend_backFaceStencil(v24, v150, v151, v152);
      objc_msgSend_setDepthStencilPassOperation_(v153, v154, v149, v155);
      uint64_t v156 = BYTE5(v174);
      simd_float4 v160 = objc_msgSend_backFaceStencil(v24, v157, v158, v159);
      objc_msgSend_setReadMask_(v160, v161, v156, v162);
      uint64_t v163 = BYTE6(v174);
      unsigned int v167 = objc_msgSend_backFaceStencil(v24, v164, v165, v166);
      objc_msgSend_setWriteMask_(v167, v168, v163, v169);
    }
    uint64_t v16 = objc_msgSend_newDepthStencilStateWithDescriptor_(*(void **)(a1 + 8), v30, (uint64_t)v24, v32);

    objc_msgSend_setObject_forKey_(*(void **)(a1 + 248), v170, (uint64_t)v16, a2);
  }
  os_unfair_lock_unlock(v4);
  return v16;
}

void *sub_1B653BEF8(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  if (sub_1B647BC9C(a2)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. cannot use volatile meshSource", v4, v5, v6, v7, v8, v9, (uint64_t)"CFXMeshSourceIsVolatile(meshSource) != true");
  }
  uint64_t v10 = (void *)sub_1B641E304(a2);
  if (!v10)
  {
    CFDataRef v11 = (const __CFData *)sub_1B641D89C(a2);
    if (v11)
    {
      CFDataRef v12 = v11;
      CFIndex Length = CFDataGetLength(v11);
      if (Length)
      {
        uint64_t v14 = Length;
        BytePtr = CFDataGetBytePtr(v12);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 224));
        uint64_t v18 = *(void **)(a1 + 216);
        if (!v18)
        {
          id v19 = objc_alloc(MEMORY[0x1E4F28E10]);
          uint64_t v18 = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v19, v20, 258, 0, 100);
          *(void *)(a1 + 216) = v18;
        }
        uint64_t v10 = objc_msgSend_objectForKey_(v18, v16, (uint64_t)v12, v17);
        if (!v10)
        {
          uint64_t v10 = objc_msgSend_newBufferWithBytes_length_options_(*(void **)(a1 + 8), v21, (uint64_t)BytePtr, v14, 0);
          uint64_t v22 = *(void *)(a1 + 24);
          ++*(_DWORD *)(v22 + 228);
          *(_DWORD *)(v22 + 256) += v14;
          objc_msgSend_setObject_forKey_(*(void **)(a1 + 216), v23, (uint64_t)v10, (uint64_t)v12);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 224));
        return v10;
      }
    }
    return 0;
  }
  return v10;
}

VFXMTLMeshElement *sub_1B653C040(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = sub_1B63D19E8(a2);
  if (v4 == a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = sub_1B653C040(a1, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 240));
  uint64_t v8 = *(void **)(a1 + 232);
  if (!v8)
  {
    id v9 = objc_alloc(MEMORY[0x1E4F28E10]);
    uint64_t v8 = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v9, v10, 258, 0, 100);
    *(void *)(a1 + 232) = v8;
  }
  uint64_t v11 = objc_msgSend_objectForKey_(v8, v6, v4, v7);
  if (!v11)
  {
    id v19 = objc_alloc_init(VFXMTLMeshElement);
    sub_1B659C904(v19, a2, v28, v29, v30, v31, v32, v33);
    if (v4 == a2)
    {
      if (sub_1B63D0F30(a2))
      {
        uint64_t v45 = sub_1B63D0F30(a2);
        uint64_t v34 = (char *)objc_msgSend__bufferForMTLBuffer_((void *)a1, v46, v45, v47);
      }
      else
      {
        unsigned int v51 = 0;
        uint64_t v48 = sub_1B63D0F38(a2, &v51);
        if (!v48)
        {
LABEL_20:
          objc_msgSend_setObject_forKey_(*(void **)(a1 + 232), v49, (uint64_t)v19, a2);

          goto LABEL_21;
        }
        uint64_t v34 = (char *)objc_msgSend__bufferForData_bytesPerIndex_((void *)a1, v49, v48, v51);
      }
    }
    else
    {
      uint64_t v34 = (char *)sub_1B659CBE8(v5);
    }
    sub_1B659C870(v19, v34);
    goto LABEL_20;
  }
  id v19 = (VFXMTLMeshElement *)v11;
  if (v4 != a2)
  {
    uint64_t v20 = (char *)sub_1B659CBE8(v5);
    sub_1B659C870(v19, v20);
LABEL_13:
    uint64_t v35 = sub_1B63D0CA8(a2, v21, v22, v23, v24, v25, v26, v27);
    sub_1B659CBC4((uint64_t)v19, v35);
    unsigned int v43 = sub_1B63D19F8(a2, v36, v37, v38, v39, v40, v41, v42);
    sub_1B659CBDC((uint64_t)v19, v43);
    goto LABEL_14;
  }
  if (sub_1B63D1AB0(a2, v12, v13, v14, v15, v16, v17, v18)) {
    goto LABEL_13;
  }
LABEL_14:
  unsigned int v44 = sub_1B63D1A44(a2, v21, v22, v23, v24, v25, v26, v27);
  sub_1B659CBD0((uint64_t)v19, v44);
LABEL_21:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 240));
  return v19;
}

uint64_t sub_1B653C21C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v11 = 0;
  switch((int)a3)
  {
    case 0:
      break;
    case 1:
      char v11 = 1;
      break;
    case 2:
      char v11 = 3;
      break;
    case 3:
      if (a4 == -1)
      {
        char v11 = 6;
      }
      else
      {
        char v11 = a4 + 6;
        if ((a4 + 6) == 14) {
          goto LABEL_6;
        }
      }
      break;
    case 4:
      char v11 = 2;
      break;
    case 5:
      char v11 = 4;
      break;
    case 6:
      char v11 = 5;
      break;
    default:
LABEL_6:
      sub_1B63F2F54(17, @"Assertion '%s' failed. Semantic %d is not meant to be passed to shaders", a3, a4, a5, a6, a7, a8, (uint64_t)"attribute != kCFXVertexAttrib_None");
      char v11 = 14;
      break;
  }
  uint64_t v12 = sub_1B641E1A8(a2, a2, a3, a4, a5, a6, a7, a8);
  int v13 = sub_1B6534654(v12);
  int v14 = sub_1B653465C(v12);
  int v21 = sub_1B63CAA3C(v13, v14, v15, v16, v17, v18, v19, v20);
  uint64_t v29 = sub_1B641E308(a2);
  uint64_t v30 = a5 + 18;
  if (!v29) {
    uint64_t v29 = sub_1B64D8088(v21, (uint64_t)v22, v23, v24, v25, v26, v27, v28);
  }
  uint64_t v31 = objc_msgSend_attributes(a1, v22, v23, v24);
  uint64_t v34 = objc_msgSend_objectAtIndexedSubscript_(v31, v32, v11, v33);
  objc_msgSend_setFormat_(v34, v35, v29, v36);
  uint64_t v40 = objc_msgSend_attributes(a1, v37, v38, v39);
  unsigned int v43 = objc_msgSend_objectAtIndexedSubscript_(v40, v41, v11, v42);
  if (!objc_msgSend_format(v43, v44, v45, v46))
  {
    uint64_t v54 = sub_1B63CA8A4(v21, v47, v48, v49, v50, v51, v52, v53);
    sub_1B63F2F54(16, @"Error: format %@ not convertible to MTLVertexFormat", v55, v56, v57, v58, v59, v60, (uint64_t)v54);
  }
  uint64_t v61 = sub_1B6534BD0(v12, v47, v48, v49, v50, v51, v52, v53);
  uint64_t v65 = objc_msgSend_attributes(a1, v62, v63, v64);
  uint64_t v68 = objc_msgSend_objectAtIndexedSubscript_(v65, v66, v11, v67);
  objc_msgSend_setOffset_(v68, v69, v61, v70);
  uint64_t v74 = objc_msgSend_attributes(a1, v71, v72, v73);
  uint64_t v77 = objc_msgSend_objectAtIndexedSubscript_(v74, v75, v11, v76);
  objc_msgSend_setBufferIndex_(v77, v78, v30, v79);
  uint64_t v80 = sub_1B65349B8(v12);
  uint64_t v84 = objc_msgSend_layouts(a1, v81, v82, v83);
  uint64_t v87 = objc_msgSend_objectAtIndexedSubscript_(v84, v85, v30, v86);
  objc_msgSend_setStride_(v87, v88, v80, v89);
  unsigned int v97 = sub_1B647BCC0(a2, v90, v91, v92, v93, v94, v95, v96);
  if (v97)
  {
    uint64_t v101 = v97;
    uint64_t v102 = objc_msgSend_layouts(a1, v98, v99, v100);
    uint64_t v105 = objc_msgSend_objectAtIndexedSubscript_(v102, v103, v30, v104);
    objc_msgSend_setStepFunction_(v105, v106, 2, v107);
    float v111 = objc_msgSend_layouts(a1, v108, v109, v110);
    uint64_t v114 = objc_msgSend_objectAtIndexedSubscript_(v111, v112, v30, v113);
    return MEMORY[0x1F4181798](v114, sel_setStepRate_, v101, v115);
  }
  else
  {
    uint64_t v116 = objc_msgSend_layouts(a1, v98, v99, v100);
    uint64_t v119 = objc_msgSend_objectAtIndexedSubscript_(v116, v117, v30, v118);
    return objc_msgSend_setStepFunction_(v119, v120, 1, v121);
  }
}

void *sub_1B653C71C(uint64_t a1, uint64_t a2)
{
  uint64_t result = (void *)sub_1B641CF90(a2);
  if (result)
  {
    uint64_t result = (void *)sub_1B641E304(a2);
    if (!result)
    {
      CFDataRef v5 = (const __CFData *)sub_1B641D89C(a2);
      uint64_t v8 = objc_msgSend_objectForKey_(*(void **)(*(void *)(a1 + 32) + 216), v6, (uint64_t)v5, v7);
      id v9 = (void *)sub_1B659C6D8(*(void *)(a1 + 40));
      if (objc_msgSend_indexOfObject_(v9, v10, (uint64_t)v8, v11) == 0x7FFFFFFFFFFFFFFFLL) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. source should be present", v12, v13, v14, v15, v16, v17, (uint64_t)"[metalMesh.buffers indexOfObject:buf] != NSNotFound");
      }
      BytePtr = CFDataGetBytePtr(v5);
      CFIndex Length = CFDataGetLength(v5);
      if (Length != objc_msgSend_length(v8, v20, v21, v22))
      {
        objc_msgSend_length(v8, v23, v24, v25);
        sub_1B63F2F54(17, @"Assertion '%s' failed. size mismatch in mutable buffers %u!=%u", v26, v27, v28, v29, v30, v31, (uint64_t)"dataSize == buf.length");
      }
      uint64_t v32 = objc_msgSend_contents(v8, v23, v24, v25);
      return memcpy(v32, BytePtr, Length);
    }
  }
  return result;
}

VFXMTLMesh *sub_1B653C844(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v6 = (a3 == 0) | (unint64_t)a2;
  locunint64_t k = (os_unfair_lock_s *)(a1 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 208));
  id v9 = *(void **)(a1 + 200);
  if (!v9)
  {
    id v10 = objc_alloc(MEMORY[0x1E4F28E10]);
    id v9 = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v10, v11, 258, 0, 100);
    *(void *)(a1 + 200) = v9;
  }
  uint64_t v12 = objc_msgSend_objectForKey_(v9, v7, v6, v8);
  if (v12)
  {
    uint64_t v20 = (VFXMTLMesh *)v12;
    if (sub_1B64AD8C0(a2, v13, v14, v15, v16, v17, v18, v19)) {
      objc_msgSend___updateMutableMesh_withMetalMesh_((void *)a1, v21, a2, (uint64_t)v20);
    }
  }
  else
  {
    uint64_t v20 = objc_alloc_init(VFXMTLMesh);
    sub_1B6583470(a2, v22, v23, v24, v25, v26, v27, v28);
    uint64_t v32 = objc_msgSend_vertexDescriptor(MEMORY[0x1E4F35358], v29, v30, v31);
    uint64_t v33 = sub_1B64AD17C(a2);
    id v34 = objc_alloc(MEMORY[0x1E4F1CA48]);
    uint64_t v37 = (char *)objc_msgSend_initWithCapacity_(v34, v35, v33, v36);
    uint64_t v83 = 0;
    uint64_t v84 = &v83;
    uint64_t v85 = 0x2020000000;
    uint64_t v86 = 0;
    v80[0] = MEMORY[0x1E4F143A8];
    v80[1] = 3221225472;
    v80[2] = sub_1B653CB88;
    void v80[3] = &unk_1E6143F28;
    char v81 = a3;
    v80[7] = v32;
    v80[8] = &v83;
    BOOL v82 = a3 == 0;
    v80[4] = v20;
    v80[5] = a1;
    v80[6] = v37;
    sub_1B64AAFB4(a2, a3, (uint64_t)v80, v38, v39, v40, v41, v42);
    if (a3 == 1)
    {
      v79[0] = MEMORY[0x1E4F143A8];
      v79[1] = 3221225472;
      v79[2] = sub_1B653CCEC;
      void v79[3] = &unk_1E6143F50;
      v79[5] = v37;
      v79[6] = &v83;
      v79[4] = v32;
      sub_1B64AAFB4(a2, 1, (uint64_t)v79, v43, v44, v45, v46, v47);
    }
    sub_1B659C270((uint64_t)v20, v32);
    sub_1B659C6E4(v20, v37);
    sub_1B659C75C((uint64_t)v20, v84[3]);

    uint64_t v55 = (uint64_t)sub_1B64ABD08(a2, v48, v49, v50, v51, v52, v53, v54);
    id v56 = objc_alloc(MEMORY[0x1E4F1CA48]);
    uint64_t v64 = objc_msgSend_initWithCapacity_(v56, v57, v55, v58);
    if (v55 >= 1)
    {
      for (CFIndex i = 0; i != v55; ++i)
      {
        unsigned __int8 v66 = sub_1B64ABD78(a2, i, a3, v59, v60, v61, v62, v63);
        uint64_t v69 = (uint64_t)v66;
        if (v66)
        {
          unsigned int v70 = sub_1B63D0C08((uint64_t)v66, v67, v68, v59, v60, v61, v62, v63);
          if (sub_1B64D7C58(v70))
          {
            uint64_t v72 = sub_1B653C040(a1, v69);
            objc_msgSend_addObject_(v64, v73, (uint64_t)v72, v74);
          }
          else if (a3)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Only original data kind can have non 'GPU' primitive type", v71, v59, v60, v61, v62, v63, (uint64_t)"dataKind == kCFXMeshDataKindOriginal");
          }
        }
      }
    }
    sub_1B659C704(v20, (char *)v64);

    objc_msgSend_setObject_forKey_(*(void **)(a1 + 200), v75, (uint64_t)v20, v6);
    _Block_object_dispose(&v83, 8);
  }
  uint64_t v76 = v20;
  os_unfair_lock_unlock(lock);
  return v20;
}

void sub_1B653CB60(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B653CB88(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != 7)
  {
    uint64_t v7 = result;
    uint64_t result = sub_1B64A6B40(*(void *)(result + 32));
    if (!result)
    {
      uint64_t v15 = sub_1B641D8A0(a2, v8, v9, v10, v11, v12, v13, v14);
      uint64_t result = sub_1B659C780(*(void *)(v7 + 32), v15);
    }
    if ((a3 == 3 || a4 <= 0) && (a3 != 3 || a4 <= 7))
    {
      if (*(unsigned char *)(v7 + 72) == 1 && (uint64_t result = sub_1B647BC9C(a2), result))
      {
        uint64_t v23 = sub_1B641E1A8(a2, v16, v17, v18, v19, v20, v21, v22);
        sub_1B6534C1C(v23, *(void *)(*(void *)(*(void *)(v7 + 64) + 8) + 24), v24, v25, v26, v27, v28, v29);
        uint64_t result = sub_1B65349B8(v23);
        *(void *)(*(void *)(*(void *)(v7 + 64) + 8) + 24) += result;
      }
      else if (!a3 || !*(unsigned char *)(v7 + 73))
      {
        uint64_t result = (uint64_t)sub_1B653BEF8(*(void *)(v7 + 40), a2);
        if (result)
        {
          uint64_t v32 = result;
          uint64_t v39 = objc_msgSend_indexOfObject_(*(void **)(v7 + 48), v30, result, v31);
          if (v39 == 0x7FFFFFFFFFFFFFFFLL)
          {
            uint64_t v39 = objc_msgSend_count(*(void **)(v7 + 48), v33, v34, v35);
            objc_msgSend_addObject_(*(void **)(v7 + 48), v40, v32, v41);
          }
          uint64_t v42 = *(void **)(v7 + 56);
          return sub_1B653C21C(v42, a2, a3, a4, v39, v36, v37, v38);
        }
      }
    }
  }
  return result;
}

uint64_t sub_1B653CCEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_1B647BC9C(a2);
  if (result)
  {
    uint64_t v16 = sub_1B641E1A8(a2, v9, v10, v11, v12, v13, v14, v15);
    sub_1B6534C6C(v16, *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), v17, v18, v19, v20, v21, v22);
    uint64_t v23 = *(void **)(a1 + 32);
    uint64_t v27 = objc_msgSend_count(*(void **)(a1 + 40), v24, v25, v26);
    return sub_1B653C21C(v23, a2, a3, a4, v27, v28, v29, v30);
  }
  return result;
}

void sub_1B653D04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B653D064(uint64_t a1, uint64_t a2)
{
}

void sub_1B653D074(uint64_t a1)
{
}

uint64_t sub_1B653D080(uint64_t result, void *a2, void *a3, unsigned char *a4)
{
  if (*(void **)(result + 32) != a3)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1B65D7D20((uint64_t)VFXMTLSkinDeformer, *(void **)(result + 56), a2);
    if (result)
    {
      uint64_t result = objc_msgSend_objectForKey_(a3, v7, *(void *)(v6 + 40), v8);
      *(void *)(*(void *)(*(void *)(v6 + 48) + 8) + 40) = result;
      if (*(void *)(*(void *)(*(void *)(v6 + 48) + 8) + 40)) {
        *a4 = 1;
      }
    }
  }
  return result;
}

void sub_1B653D2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B653D304(uint64_t result, uint64_t a2, void *a3, unsigned char *a4)
{
  if (*(void **)(result + 32) != a3)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1B65944C4();
    if (result)
    {
      uint64_t result = objc_msgSend_objectForKey_(a3, v7, *(void *)(v6 + 40), v8);
      *(void *)(*(void *)(*(void *)(v6 + 48) + 8) + 40) = result;
      if (*(void *)(*(void *)(*(void *)(v6 + 48) + 8) + 40)) {
        *a4 = 1;
      }
    }
  }
  return result;
}

void *sub_1B653D388(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 368);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 368));
  uint64_t v7 = *(void **)(a1 + 360);
  if (!v7)
  {
    id v8 = objc_alloc(MEMORY[0x1E4F28E10]);
    uint64_t v7 = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v8, v9, 258, 0, 100);
    *(void *)(a1 + 360) = v7;
  }
  uint64_t v10 = objc_msgSend_objectForKey_(v7, v5, a2, v6);
  if (!v10)
  {
    uint64_t v11 = [VFXMTLTessellator alloc];
    uint64_t v10 = objc_msgSend_initWithGeometry_resourceManager_(v11, v12, a2, a1);
    objc_msgSend_setObject_forKey_(*(void **)(a1 + 360), v13, (uint64_t)v10, a2);
  }
  os_unfair_lock_unlock(v4);
  return v10;
}

VFXMetalWireframeResource *sub_1B653D440(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v13 = sub_1B6446190(a3, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
    uint64_t v14 = sub_1B63F6BFC(v13, (char *)a2, 0, a5);
    if (v14)
    {
      uint64_t v15 = v14;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
      uint64_t v18 = *(void **)(a1 + 376);
      if (!v18)
      {
        id v19 = objc_alloc(MEMORY[0x1E4F28E10]);
        uint64_t v18 = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v19, v20, 258, 0, 100);
        *(void *)(a1 + 376) = v18;
      }
      uint64_t v21 = (VFXMetalWireframeResource *)objc_msgSend_objectForKey_(v18, v16, v15, v17);
      if (v21) {
        goto LABEL_28;
      }
      uint64_t v22 = (void *)sub_1B63F1678(a2);
      uint64_t v23 = (__n128 *)sub_1B63F16EC(a2);
      uint64_t v24 = sub_1B63F1730(a2);
      if (v24)
      {
        uint64_t v25 = v24;
        uint64_t v41 = sub_1B63F1750(a2);
        uint64_t v26 = sub_1B63F1710(a2);
        uint64_t v40 = v23;
        uint64_t v27 = (const void *)sub_1B64AF050(v26);
        unsigned int v28 = sub_1B6447B70(a3);
        uint64_t v30 = (const char *)sub_1B659DD34(v22, v23, v25, (uint64_t)v41, 0, (uint64_t)v27, ((unint64_t)a4[24] << 16) | ((unint64_t)((8 * (a4[27] & 3)) & 0x9F | (*(unsigned __int16 *)(a2 + 80) >> 11) & 7 | (32 * (a4[28] & 3u))) << 24) | v28, v29);
        uint64_t v31 = (const void *)sub_1B6447624(a3, v30);
        uint64_t v21 = objc_alloc_init(VFXMetalWireframeResource);
        material = v21->material;
        if (material != v27)
        {
          if (material)
          {
            CFRelease(material);
            v21->material = 0;
          }
          if (v27) {
            uint64_t v34 = (void *)CFRetain(v27);
          }
          else {
            uint64_t v34 = 0;
          }
          v21->material = v34;
        }
        program = v21->program;
        if (program != v31)
        {
          if (program)
          {
            CFRelease(program);
            v21->program = 0;
          }
          if (v31) {
            uint64_t v36 = (void *)CFRetain(v31);
          }
          else {
            uint64_t v36 = 0;
          }
          v21->program = v36;
        }
        uint64_t programHashCode = (uint64_t)v21->programHashCode;
        if ((const char *)programHashCode != v30)
        {
          sub_1B659EC24(programHashCode);
          if (v30) {
            uint64_t v38 = (void *)CFRetain(v30);
          }
          else {
            uint64_t v38 = 0;
          }
          v21->uint64_t programHashCode = v38;
        }
        objc_msgSend_setObject_forKey_(*(void **)(a1 + 376), v32, (uint64_t)v21, v15, v40);

        CFRelease(v27);
        sub_1B659EC24((uint64_t)v30);
LABEL_28:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 384));
        return v21;
      }
    }
  }
  return 0;
}

uint64_t sub_1B653D684(uint64_t result, const char *a2, uint64_t a3)
{
  if (result)
  {
    int v3 = (int)a2;
    uint64_t v4 = result;
    uint64_t result = objc_msgSend_newBufferWithLength_options_(*(void **)(result + 8), a2, (uint64_t)a2, a3);
    uint64_t v5 = *(void *)(v4 + 24);
    ++*(_DWORD *)(v5 + 240);
    *(_DWORD *)(v5 + 264) += v3;
  }
  return result;
}

uint64_t sub_1B653D6DC(uint64_t result, const char *a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    int v4 = a3;
    uint64_t v5 = result;
    uint64_t result = objc_msgSend_newBufferWithBytes_length_options_(*(void **)(result + 8), a2, (uint64_t)a2, a3, a4);
    uint64_t v6 = *(void *)(v5 + 24);
    ++*(_DWORD *)(v6 + 228);
    *(_DWORD *)(v6 + 256) += v4;
  }
  return result;
}

uint64_t sub_1B653D738(uint64_t a1, const char *a2, uint64_t a3, void *a4)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = objc_msgSend_newBufferWithLength_options_(*(void **)(a1 + 8), a2, a3, 32);
  uint64_t v10 = objc_msgSend_newBufferWithBytes_length_options_(*(void **)(a1 + 8), v9, (uint64_t)a2, a3, 0);
  objc_msgSend_copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size_(a4, v11, (uint64_t)v10, 0, v8, 0, a3);

  uint64_t v12 = *(void *)(a1 + 24);
  ++*(_DWORD *)(v12 + 228);
  *(_DWORD *)(v12 + 256) += a3;
  return v8;
}

uint64_t sub_1B653D7E8(uint64_t result, const char *a2, uint64_t a3)
{
  if (result)
  {
    int v3 = (int)a2;
    uint64_t v4 = result;
    uint64_t result = objc_msgSend_newBufferWithLength_options_(*(void **)(result + 8), a2, (uint64_t)a2, a3);
    uint64_t v5 = *(void *)(v4 + 24);
    ++*(_DWORD *)(v5 + 228);
    *(_DWORD *)(v5 + 256) += v3;
  }
  return result;
}

VFXMTLShadable *sub_1B653D840(uint64_t a1, void *a2, void *a3, VFXMTLRenderPipeline *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v569 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  if (a2)
  {
    if (a4) {
      goto LABEL_4;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"material");
    if (a4) {
      goto LABEL_4;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"pipeline");
LABEL_4:
  unsigned int v12 = sub_1B6584FA4(a2);
  if (a3) {
    unsigned int v13 = sub_1B6584FA4(a3);
  }
  else {
    unsigned int v13 = 0;
  }
  locunint64_t k = (os_unfair_lock_s *)(a1 + 416);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 416));
  if (!*(void *)(a1 + 408))
  {
    id v16 = objc_alloc(MEMORY[0x1E4F28E10]);
    *(void *)(a1 + 408) = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v16, v17, 0, 0, 100);
  }
  *(void *)(*(void *)(a1 + 424) + 8) = a2;
  *(void *)(*(void *)(a1 + 424) + 16) = a3;
  *(void *)(*(void *)(a1 + 424) + 24) = a4;
  uint64_t v18 = objc_msgSend_objectForKey_(*(void **)(a1 + 408), v14, *(void *)(a1 + 424), v15);
  uint64_t v26 = v18;
  if (!v18
    || v12 != objc_msgSend_materialModificationCount(v18, v19, v20, v21)
    || v13 != objc_msgSend_geometryModificationCount(v26, v19, v20, v21))
  {
    v544 = v26;
    uint64_t v552 = a1;
    uint64_t v553 = (uint64_t)a3;
    v541 = (void *)sub_1B6445900(a5, (uint64_t)v19, v20, v21, v22, v23, v24, v25);
    uint64_t v542 = objc_msgSend_frameConstantBufferPool(v541, v27, v28, v29);
    uint64_t v30 = objc_alloc_init(VFXMTLShadable);
    objc_msgSend_setMaterialModificationCount_(v30, v31, v12, v32);
    v550 = v30;
    objc_msgSend_setGeometryModificationCount_(v30, v33, v13, v34);
    uint64_t v551 = (uint64_t)a2;
    uint64_t v42 = (float *)sub_1B64AF488((uint64_t)a2, v35, v36, v37, v38, v39, v40, v41);
    long long v563 = 0u;
    long long v564 = 0u;
    long long v565 = 0u;
    long long v566 = 0u;
    v539 = a4;
    obuint64_t j = (id)objc_msgSend_shadableBufferBindings(a4, v43, v44, v45);
    uint64_t v556 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v46, (uint64_t)&v563, (uint64_t)v568, 16);
    if (!v556) {
      goto LABEL_101;
    }
    uint64_t v555 = *(void *)v564;
    while (1)
    {
      for (uint64_t i = 0; i != v556; ++i)
      {
        if (*(void *)v564 != v555) {
          objc_enumerationMutation(obj);
        }
        uint64_t v51 = *(void *)(*((void *)&v563 + 1) + 8 * i);
        if (objc_msgSend_needsRenderResource((void *)v51, v47, v48, v49))
        {
          uint64_t v52 = objc_msgSend_name((void *)v51, v47, v48, v49);
          uint64_t v56 = objc_msgSend_type((void *)v51, v53, v54, v55);
          switch(v56)
          {
            case 0:
              unint64_t v548 = v548 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(v51 + 9);
              uint64_t v63 = objc_msgSend_bufferAtIndices_(v544, v47, v548, v49);
              if (v42
                && objc_msgSend_isEqualToString_(v52, v61, @"vfx_commonprofile", v62))
              {
                DWORD2(__src[12]) = sub_1B6476060((uint64_t)v42, 1, v64, v65, v66, v67, v68, v69);
                HIDWORD(__src[12]) = sub_1B6476060((uint64_t)v42, 2, v70, v71, v72, v73, v74, v75);
                DWORD1(__src[15]) = sub_1B6476060((uint64_t)v42, 11, v76, v77, v78, v79, v80, v81);
                DWORD2(__src[15]) = sub_1B6476060((uint64_t)v42, 12, v82, v83, v84, v85, v86, v87);
                HIDWORD(__src[15]) = sub_1B6476060((uint64_t)v42, 13, v88, v89, v90, v91, v92, v93);
                LODWORD(__src[16]) = sub_1B6476060((uint64_t)v42, 14, v94, v95, v96, v97, v98, v99);
                DWORD1(__src[16]) = sub_1B6476060((uint64_t)v42, 15, v100, v101, v102, v103, v104, v105);
                LODWORD(__src[13]) = sub_1B6476060((uint64_t)v42, 6, v106, v107, v108, v109, v110, v111);
                LODWORD(__src[14]) = sub_1B6476060((uint64_t)v42, 3, v112, v113, v114, v115, v116, v117);
                DWORD1(__src[14]) = sub_1B6476060((uint64_t)v42, 5, v118, v119, v120, v121, v122, v123);
                DWORD2(__src[14]) = sub_1B6476060((uint64_t)v42, 4, v124, v125, v126, v127, v128, v129);
                HIDWORD(__src[14]) = sub_1B6476060((uint64_t)v42, 9, v130, v131, v132, v133, v134, v135);
                LODWORD(__src[15]) = sub_1B6476060((uint64_t)v42, 10, v136, v137, v138, v139, v140, v141);
                DWORD2(__src[16]) = sub_1B6476060((uint64_t)v42, 16, v142, v143, v144, v145, v146, v147);
                *(void *)&__src[0] = sub_1B6475EA8((uint64_t)v42, 1, v148, v149, v150, v151, v152, v153);
                *((void *)&__src[0] + 1) = v154;
                *(void *)&__src[1] = sub_1B6475EA8((uint64_t)v42, 2, v155, v156, v157, v158, v159, v160);
                *((void *)&__src[1] + 1) = v161;
                LODWORD(__src[8]) = sub_1B64760CC((uint64_t)v42, 11, v162, v163, v164, v165, v166, v167);
                DWORD1(__src[8]) = sub_1B64760CC((uint64_t)v42, 12, v168, v169, v170, v171, v172, v173);
                LODWORD(__src[10]) = sub_1B64760CC((uint64_t)v42, 14, v174, v175, v176, v177, v178, v179);
                *(void *)&__src[11] = sub_1B6475EA8((uint64_t)v42, 15, v180, v181, v182, v183, v184, v185);
                *((void *)&__src[11] + 1) = v186;
                *(void *)&__src[5] = sub_1B6475EA8((uint64_t)v42, 3, v187, v188, v189, v190, v191, v192);
                *((void *)&__src[5] + 1) = v193;
                *(void *)&__src[6] = sub_1B6475EA8((uint64_t)v42, 5, v194, v195, v196, v197, v198, v199);
                *((void *)&__src[6] + 1) = v200;
                *(void *)&__src[7] = sub_1B6475EA8((uint64_t)v42, 4, v201, v202, v203, v204, v205, v206);
                *((void *)&__src[7] + 1) = v207;
                LODWORD(__src[12]) = sub_1B64760CC((uint64_t)v42, 9, v208, v209, v210, v211, v212, v213);
                DWORD1(__src[12]) = sub_1B64760CC((uint64_t)v42, 10, v214, v215, v216, v217, v218, v219);
                if (sub_1B6476C80((uint64_t)v42, v220, v221, v222, v223, v224, v225, v226))
                {
                  *(void *)&__src[2] = sub_1B6475EA8((uint64_t)v42, 7, v227, v228, v229, v230, v231, v232);
                  *((void *)&__src[2] + 1) = v233;
                  DWORD1(__src[13]) = sub_1B6476060((uint64_t)v42, 7, v234, v235, v236, v237, v238, v239);
                }
                *(void *)&__src[4] = sub_1B6475EA8((uint64_t)v42, 8, v227, v228, v229, v230, v231, v232);
                *((void *)&__src[4] + 1) = v240;
                HIDWORD(__src[13]) = sub_1B6476060((uint64_t)v42, 8, v241, v242, v243, v244, v245, v246);
                *(void *)&__src[3] = sub_1B6475EA8((uint64_t)v42, 0, v247, v248, v249, v250, v251, v252);
                *((void *)&__src[3] + 1) = v253;
                DWORD2(__src[13]) = sub_1B6476060((uint64_t)v42, 0, v254, v255, v256, v257, v258, v259);
                *((float *)&__src[16] + 3) = sub_1B64758EC(v42, 17, v260, v261, v262, v263, v264, v265) * 128.0;
                LODWORD(__src[17]) = sub_1B6476C88((uint64_t)v42);
                DWORD1(__src[17]) = sub_1B64AF648(v551, v266, v267, v268, v269, v270, v271, v272);
                float v279 = sub_1B64758EC(v42, 18, v273, v274, v275, v276, v277, v278);
                float v291 = sub_1B64758EC(v42, 19, v280, v281, v282, v283, v284, v285);
                uint64_t v292 = 0;
                *(float *)&long long v293 = (float)((float)(1.0 - v279) * (float)(1.0 - v279))
                                / (float)((float)(v279 + 1.0) * (float)(v279 + 1.0));
                *((float *)&v293 + 1) = 1.0 - *(float *)&v293;
                *((float *)&v293 + 2) = v291;
                __src[18] = v293;
                memset(v567, 0, 256);
                uint64_t v558 = 0;
                v559 = &v558;
                uint64_t v560 = 0x2020000000;
                uint64_t v561 = 0;
                do
                {
                  uint64_t v294 = sub_1B6475290((uint64_t)v42, (char)v292, 0, v286, v287, v288, v289, v290);
                  uint64_t v297 = v294;
                  if (v294 && sub_1B6475F88(v294, v295, v296, v286, v287, v288, v289, v290) && sub_1B6477268(v297))
                  {
                    uint64_t v299 = sub_1B647721C(v297, v298, v296, v286, v287, v288, v289, v290);
                    uint64_t v300 = v559[3];
                    v559[3] = v300 + 1;
                    v567[v300] = v299;
                  }
                  ++v292;
                }
                while (v292 != 17);
                v557[0] = MEMORY[0x1E4F143A8];
                v557[1] = 3221225472;
                v557[2] = sub_1B653E7AC;
                v557[3] = &unk_1E6143FA0;
                v557[5] = v567;
                v557[4] = &v558;
                sub_1B6584E1C(v551, (const char *)v557, v296, v286, v287, v288, v289, v290);
                if (v553) {
                  sub_1B6584E1C(v553, (const char *)v557, v302, v303, v304, v305, v306, v307);
                }
                if (v559[3] < 1)
                {
                  if (objc_msgSend_argumentEncoder((void *)v51, v301, v302, v303))
                  {
                    uint64_t v308 = objc_alloc_init(VFXMTLBuffer);
                    v469 = objc_msgSend_argumentEncoder((void *)v51, v466, v467, v468);
                    uint64_t v473 = objc_msgSend_encodedLength(v469, v470, v471, v472);
                    v475 = objc_msgSend_newBufferWithLength_options_(*(void **)(v552 + 8), v474, v473, 0);
                    objc_msgSend_setBuffer_(v308, v476, (uint64_t)v475, v477);

                    v481 = objc_msgSend_argumentEncoder((void *)v51, v478, v479, v480);
                    uint64_t v485 = objc_msgSend_buffer(v308, v482, v483, v484);
                    uint64_t v489 = objc_msgSend_offset(v308, v486, v487, v488);
                    objc_msgSend_setArgumentBuffer_offset_(v481, v490, v485, v489);
                    char v498 = sub_1B6489B18();
                    if (v498)
                    {
                      char v499 = 0;
                      uint64_t v500 = 27;
                      do
                      {
                        uint64_t v501 = sub_1B6475290((uint64_t)v42, v499, 0, v493, v494, v495, v496, v497);
                        if (v501)
                        {
                          uint64_t isDynamic = objc_msgSend_renderResourceForMaterialProperty_withEngineContext_didFallbackToDefaultTexture_isDynamic_((void *)v552, v491, v501, a5, 0, 0);
                          uint64_t v510 = sub_1B64765F4(v501, v503, v504, v505, v506, v507, v508, v509);
                          if (isDynamic)
                          {
                            uint64_t v511 = v510;
                            v512 = objc_msgSend_argumentEncoder((void *)v51, v491, v492, v493);
                            objc_msgSend_setTexture_atIndex_(v512, v513, isDynamic, v500 - 1);
                            v517 = objc_msgSend_usedResources((void *)v51, v514, v515, v516);
                            objc_msgSend_addObject_(v517, v518, isDynamic, v519);
                            if (!v511) {
                              uint64_t v511 = sub_1B643DF24();
                            }
                            v520 = sub_1B653E820(v552, v511);
                            v524 = objc_msgSend_argumentEncoder((void *)v51, v521, v522, v523);
                            objc_msgSend_setSamplerState_atIndex_(v524, v525, (uint64_t)v520, v500);
                          }
                        }
                        v500 += 2;
                        ++v499;
                      }
                      while (v499 != v498);
                    }
                    v526 = objc_msgSend_argumentEncoder((void *)v51, v491, v492, v493);
                    v529 = objc_msgSend_constantDataAtIndex_(v526, v527, 0, v528);
                    memcpy(v529, __src, 0x130uLL);
                  }
                  else
                  {
                    uint64_t v530 = sub_1B6445900(a5, v459, v460, v461, v462, v463, v464, v465);
                    uint64_t v308 = (VFXMTLBuffer *)objc_msgSend_newSubBufferWithBytes_length_renderContext_(*(void **)(v552 + 64), v531, (uint64_t)__src, 304, v530);
                  }
                  uint64_t v532 = *(void *)(v552 + 24);
                  ++*(_DWORD *)(v532 + 240);
                  *(_DWORD *)(v532 + 264) += 304;
                }
                else
                {
                  uint64_t v308 = objc_alloc_init(VFXMTLBuffer);
                  uint64_t v309 = v559[3] << 6;
                  int v310 = v309 + 304;
                  uint64_t v312 = objc_msgSend_newBufferWithLength_options_(*(void **)(v552 + 8), v311, v309 + 304, 0);
                  uint64_t v313 = *(void *)(v552 + 24);
                  ++*(_DWORD *)(v313 + 240);
                  *(_DWORD *)(v313 + 264) += v310;
                  uint64_t v317 = (_OWORD *)objc_msgSend_contents(v312, v314, v315, v316);
                  memcpy(v317, __src, 0x130uLL);
                  v325 = v559;
                  if (v559[3] >= 1)
                  {
                    uint64_t v326 = 0;
                    v327 = v317 + 19;
                    do
                    {
                      uint64_t v328 = (long long *)v567[v326];
                      if (!v328)
                      {
                        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v319, v320, v321, v322, v323, v324, (uint64_t)"textureMatrix");
                        v325 = v559;
                      }
                      long long v329 = *v328;
                      long long v330 = v328[1];
                      long long v331 = v328[3];
                      v327[2] = v328[2];
                      v327[3] = v331;
                      _OWORD *v327 = v329;
                      v327[1] = v330;
                      v327 += 4;
                      ++v326;
                    }
                    while (v326 < v325[3]);
                  }
                  objc_msgSend_setBuffer_(v308, v318, (uint64_t)v312, v320);
                }
                _Block_object_dispose(&v558, 8);
              }
              else
              {
                uint64_t v308 = objc_alloc_init(VFXMTLBuffer);
                int v357 = (void *)sub_1B6584D68(v551, v52, v344, v345, v346, v347, v348, v349);
                BOOL v358 = v553 == 0;
                if (v357) {
                  BOOL v358 = 1;
                }
                if (!v358) {
                  int v357 = (void *)sub_1B6584D68(v553, v52, v351, v352, v353, v354, v355, v356);
                }
                if (!v357 && (byte_1E9DDB2A8 & 1) == 0)
                {
                  byte_1E9DDB2A8 = 1;
                  uint64_t v359 = objc_msgSend_name((void *)v51, v350, v351, v352);
                  sub_1B63F2F54(16, @"Error: missing value for attachment \"%@\" [vertex: %d fragment: %d]", v360, v361, v362, v363, v364, v365, v359);
                }
                v366 = objc_msgSend_binding((void *)v51, v350, v351, v352);
                unint64_t v370 = objc_msgSend_bufferDataSize(v366, v367, v368, v369);
                if (objc_opt_respondsToSelector() & 1) != 0 && (objc_opt_respondsToSelector())
                {
                  if (objc_msgSend_length(v357, v371, v372, v373) >= v370)
                  {
                    objc_msgSend_setBuffer_(v308, v374, (uint64_t)v357, v376);
                  }
                  else
                  {
                    if ((byte_1E9DDB2A9 & 1) == 0)
                    {
                      byte_1E9DDB2A9 = 1;
                      uint64_t v377 = *(char *)(v51 + 9);
                      objc_msgSend_length(v357, v374, v375, v376);
                      sub_1B63F2F54(16, @"Error: incorrect buffer size  for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d", v378, v379, v380, v381, v382, v383, v377);
                    }
                    unsigned int v384 = objc_msgSend_newBufferWithLength_options_(*(void **)(v552 + 8), v374, v370, 0);
                    objc_msgSend_setBuffer_(v308, v385, (uint64_t)v384, v386);

                    objc_msgSend_setOffset_(v308, v387, 0, v388);
                  }
                }
                else
                {
                  objc_opt_class();
                  char isKindOfClass = objc_opt_isKindOfClass();
                  if (isKindOfClass)
                  {
                    unint64_t v428 = objc_msgSend_length(v357, v424, v425, v426);
                    if (v428 > v370) {
                      unint64_t v370 = v428;
                    }
                  }
                  v429 = objc_msgSend_buffer(v63, v424, v425, v426);
                  if (objc_msgSend_length(v429, v430, v431, v432) == v370)
                  {
                    uint64_t v436 = objc_msgSend_buffer(v63, v433, v434, v435);
                    objc_msgSend_setBuffer_(v308, v437, v436, v438);
                    memset(__src, 0, 24);
                    sub_1B649F150(v542, v370, __src);
                    sub_1B653E9C8((void *)v51, (uint64_t)v52, *(void **)&__src[0], v553, v370, v551, v357, isKindOfClass & 1);
                    v442 = *(void **)objc_msgSend_resourceBlitEncoder(v541, v439, v440, v441);
                    uint64_t v443 = *((void *)&__src[0] + 1);
                    uint64_t v444 = *(void *)&__src[1];
                    uint64_t v448 = objc_msgSend_buffer(v308, v445, v446, v447);
                    objc_msgSend_copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size_(v442, v449, v443, v444, v448, 0, v370);
                  }
                  else
                  {
                    v450 = objc_msgSend_newBufferWithLength_options_(*(void **)(v552 + 8), v433, v370, 0);
                    objc_msgSend_setBuffer_(v308, v451, (uint64_t)v450, v452);

                    objc_msgSend_setOffset_(v308, v453, 0, v454);
                    v458 = objc_msgSend_contents(v308, v455, v456, v457);
                    sub_1B653E9C8((void *)v51, (uint64_t)v52, v458, v553, v370, v551, v357, isKindOfClass & 1);
                  }
                }
              }
              uint64_t v533 = objc_msgSend_type((void *)v51, v389, v390, v391);
              unint64_t v546 = v546 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(v51 + 9);
              objc_msgSend_setResource_ofType_atIndices_(v550, v534, (uint64_t)v308, v533);

              continue;
            case 1:
              continue;
            case 2:
              uint64_t v339 = sub_1B6584D68(v551, v52, v48, v49, v57, v58, v59, v60);
              BOOL v340 = v553 == 0;
              if (v339) {
                BOOL v340 = 1;
              }
              if (!v340) {
                uint64_t v339 = sub_1B6584D68(v553, v52, v333, v334, v335, v336, v337, v338);
              }
              LOBYTE(__src[0]) = 0;
              LOBYTE(v567[0]) = 0;
              if (v339 && (CFTypeID v341 = CFGetTypeID(v339), v341 == sub_1B6477C48()))
              {
                uint64_t v342 = objc_msgSend_renderResourceForMaterialProperty_withEngineContext_didFallbackToDefaultTexture_isDynamic_((void *)v552, v332, (uint64_t)v339, a5, __src, v567);
                char v545 = 0;
                uint64_t v343 = (uint64_t)v339;
                if (v342)
                {
                  uint64_t v343 = (uint64_t)v339;
LABEL_70:
                  uint64_t v413 = objc_msgSend_type((void *)v51, v332, v333, v334);
                  unint64_t v547 = v547 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(v51 + 9);
                  objc_msgSend_setResource_ofType_atIndices_(v550, v414, v342, v413);
                  if (LOBYTE(__src[0]) | LOBYTE(v567[0])) {
                    objc_msgSend_setMaterialModificationCount_(v550, v47, -1, v49);
                  }
                  uint64_t v419 = *(unsigned __int8 *)(v51 + 11);
                  uint64_t v420 = *(unsigned __int8 *)(v51 + 12);
                  if (v420 != 255 || v419 != 255)
                  {
                    if ((v545 & 1) != 0
                      || (uint64_t v421 = sub_1B64765F4(v343, (uint64_t)v47, v48, v49, v415, v416, v417, v418)) == 0)
                    {
                      uint64_t v421 = sub_1B643DF24();
                    }
                    v422 = sub_1B653E820(v552, v421);
                    unint64_t v543 = v543 & 0xFFFFFFFFFFFF0000 | v419 | (v420 << 8);
                    objc_msgSend_setResource_ofType_atIndices_(v550, v423, (uint64_t)v422, 3);
                  }
                  continue;
                }
              }
              else
              {
                if ((byte_1E9DDB2AA & 1) == 0)
                {
                  byte_1E9DDB2AA = 1;
                  sub_1B63F2F54(16, @"Warning: Missing texture value for %@", v333, v334, v335, v336, v337, v338, (uint64_t)v52);
                }
                uint64_t v343 = 0;
                char v545 = 1;
              }
              LOBYTE(__src[0]) = 1;
              uint64_t v392 = objc_msgSend_binding((void *)v51, v332, v333, v334);
              uint64_t v396 = objc_msgSend_textureType(v392, v393, v394, v395);
              uint64_t v342 = objc_msgSend_defaultTextureForTextureType_((void *)v552, v397, v396, v398);
              v406 = (void *)sub_1B6445900(a5, v399, v400, v401, v402, v403, v404, v405);
              v410 = objc_msgSend_resourceManagerMonitor(v406, v407, v408, v409);
              if (v410)
              {
                uint64_t v538 = v51;
                uint64_t v411 = objc_msgSend_stringWithFormat_(NSString, v332, @"Unable to find texture for binding %@ (\"%@\") and effect materialProperty %@ derived from value %@ (geometry=%@, material=%@)", v334);
                objc_msgSend_renderContext_didFallbackToDefaultTextureForSource_message_(v410, v412, (uint64_t)v406, v51, v411);
              }
              goto LABEL_70;
            case 3:
              sub_1B63F2F54(16, @"Unreachable code: Sampler are not yet implemented as separate bindings", v48, v49, v57, v58, v59, v60, v538);
              continue;
            default:
              if ((unint64_t)(v56 - 16) >= 2) {
                sub_1B63F2F54(16, @"Unreachable code: binding type not supported", v48, v49, v57, v58, v59, v60, v538);
              }
              continue;
          }
        }
      }
      uint64_t v556 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v47, (uint64_t)&v563, (uint64_t)v568, 16);
      if (!v556)
      {
LABEL_101:
        v535 = objc_alloc_init(VFXMTLShadableKey);
        v535->_material = (__CFXMaterial *)v551;
        v535->_geometry = (__CFXGeometry *)v553;
        v535->_pipeline = v539;
        objc_msgSend_setObject_forKey_(*(void **)(v552 + 408), v536, (uint64_t)v550, (uint64_t)v535);

        os_unfair_lock_unlock(lock);
        return v550;
      }
    }
  }
  os_unfair_lock_unlock(lock);
  return (VFXMTLShadable *)v26;
}

void sub_1B653E744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

uint64_t sub_1B653E7AC(uint64_t a1, int a2, CFTypeRef cf)
{
  CFTypeID v5 = CFGetTypeID(cf);
  uint64_t result = sub_1B6477C48();
  if (cf && v5 == result)
  {
    uint64_t result = sub_1B6477268((uint64_t)cf);
    if (result)
    {
      uint64_t result = sub_1B647721C((uint64_t)cf, v7, v8, v9, v10, v11, v12, v13);
      uint64_t v14 = *(void *)(a1 + 40);
      uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v16 = *(void *)(v15 + 24);
      *(void *)(v15 + 24) = v16 + 1;
      *(void *)(v14 + 8 * v16) = result;
    }
  }
  return result;
}

void *sub_1B653E820(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = a2;
  if (!a2) {
    uint64_t v2 = sub_1B643DF24();
  }
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  CFTypeID v5 = *(void **)(a1 + 152);
  if (!v5)
  {
    id v6 = objc_alloc(MEMORY[0x1E4F28E10]);
    CFTypeID v5 = objc_msgSend_initWithKeyOptions_valueOptions_capacity_(v6, v7, 258, 0, 100);
    *(void *)(a1 + 152) = v5;
  }
  uint64_t v8 = sub_1B643D7FC(v2);
  uint64_t v11 = objc_msgSend_objectForKey_(v5, v9, v8, v10);
  if (!v11)
  {
    id v12 = objc_alloc_init(MEMORY[0x1E4F35300]);
    int v20 = sub_1B643DDF4(v2, v13, v14, v15, v16, v17, v18, v19);
    uint64_t v28 = sub_1B64D7890(v20, v21, v22, v23, v24, v25, v26, v27);
    objc_msgSend_setMinFilter_(v12, v29, v28, v30);
    int v38 = sub_1B643DE40(v2, v31, v32, v33, v34, v35, v36, v37);
    uint64_t v46 = sub_1B64D7890(v38, v39, v40, v41, v42, v43, v44, v45);
    objc_msgSend_setMagFilter_(v12, v47, v46, v48);
    int v56 = sub_1B643DE8C(v2, v49, v50, v51, v52, v53, v54, v55);
    uint64_t v64 = sub_1B64D78E8(v56, v57, v58, v59, v60, v61, v62, v63);
    objc_msgSend_setMipFilter_(v12, v65, v64, v66);
    int v74 = sub_1B643DD10(v2, v67, v68, v69, v70, v71, v72, v73);
    uint64_t v82 = sub_1B64D7838(v74, v75, v76, v77, v78, v79, v80, v81);
    objc_msgSend_setSAddressMode_(v12, v83, v82, v84);
    int v92 = sub_1B643DD5C(v2, v85, v86, v87, v88, v89, v90, v91);
    uint64_t v100 = sub_1B64D7838(v92, v93, v94, v95, v96, v97, v98, v99);
    objc_msgSend_setTAddressMode_(v12, v101, v100, v102);
    int v110 = sub_1B643DDA8(v2, v103, v104, v105, v106, v107, v108, v109);
    uint64_t v118 = sub_1B64D7838(v110, v111, v112, v113, v114, v115, v116, v117);
    objc_msgSend_setRAddressMode_(v12, v119, v118, v120);
    float v130 = sub_1B643DED8(v2, v121, v122, v123, v124, v125, v126, v127);
    if (v130 < 1.0) {
      float v130 = 1.0;
    }
    objc_msgSend_setMaxAnisotropy_(v12, v128, (unint64_t)fminf(v130, 16.0), v129);
    uint64_t v11 = objc_msgSend_newSamplerStateWithDescriptor_(*(void **)(a1 + 8), v131, (uint64_t)v12, v132);

    uint64_t v133 = *(void **)(a1 + 152);
    uint64_t v134 = sub_1B643D7FC(v2);
    objc_msgSend_setObject_forKey_(v133, v135, (uint64_t)v11, v134);
  }
  os_unfair_lock_unlock(v4);
  return v11;
}

uint64_t sub_1B653E9C8(void *a1, uint64_t a2, void *a3, uint64_t a4, size_t a5, uint64_t a6, void *cf, int a8)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFTypeID v15 = CFGetTypeID(cf);
    if (v15 == sub_1B6562334())
    {
      uint64_t v19 = objc_msgSend_binding(a1, v16, v17, v18);
      uint64_t v23 = objc_msgSend_bufferDataType(v19, v20, v21, v22);
      if ((sub_1B64D87B8((uint64_t)cf, v23, (uint64_t)a3, v24, v25, v26, v27, v28) & 1) == 0) {
        sub_1B63F2F54(16, @"Error: Argument '%@' : failed to write value to Metal buffer (%@)", v30, v31, v32, v33, v34, v35, a2);
      }
    }
    else if (a8)
    {
      uint64_t v36 = (const void *)objc_msgSend_bytes(cf, v16, v17, v18);
      if (objc_msgSend_length(cf, v37, v38, v39) == a5) {
        memcpy(a3, v36, a5);
      }
      else {
        sub_1B63F2F54(16, @"Error: Argument '%@' : mismatch between the NSData and the buffer size %ld != %ld", v40, v41, v42, v43, v44, v45, a2);
      }
    }
    else
    {
      CFTypeID v46 = CFGetTypeID(cf);
      CFStringRef v114 = CFCopyTypeIDDescription(v46);
      sub_1B63F2F54(16, @"Error: Argument '%@' : only NSData and NSValue are supported for shadable value storage (found '%@'). Please make sure that your custom shader modifier uniform types match the custom properties of the shadable object", v47, v48, v49, v50, v51, v52, a2);
      CFRelease(v114);
    }
  }
  else
  {
    bzero(a3, a5);
  }
  uint64_t v53 = objc_msgSend_binding(a1, v29, v30, v31);
  uint64_t result = objc_msgSend_bufferDataType(v53, v54, v55, v56);
  if (result == 1)
  {
    uint64_t v61 = objc_msgSend_binding(a1, v58, v59, v60);
    uint64_t v65 = objc_msgSend_name(v61, v62, v63, v64);
    uint64_t v68 = objc_msgSend_stringByAppendingString_(v65, v66, @".", v67);
    uint64_t v72 = objc_msgSend_binding(a1, v69, v70, v71);
    uint64_t v76 = objc_msgSend_bufferStructType(v72, v73, v74, v75);
    uint64_t v80 = objc_msgSend_members(v76, v77, v78, v79);
    long long v117 = 0u;
    long long v118 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v80, v81, (uint64_t)&v117, (uint64_t)v121, 16);
    if (result)
    {
      uint64_t v85 = result;
      uint64_t v86 = *(void *)v118;
      if (a4) {
        BOOL v87 = cf == 0;
      }
      else {
        BOOL v87 = 0;
      }
      int v88 = v87;
      do
      {
        uint64_t v89 = 0;
        do
        {
          if (*(void *)v118 != v86) {
            objc_enumerationMutation(v80);
          }
          uint64_t v90 = *(void **)(*((void *)&v117 + 1) + 8 * v89);
          uint64_t v91 = objc_msgSend_name(v90, v82, v83, v84);
          uint64_t v94 = (const void *)objc_msgSend_stringByAppendingString_(v68, v92, v91, v93);
          uint64_t v101 = sub_1B6584D68(a6, v94, v95, v96, v97, v98, v99, v100);
          if (v88) {
            uint64_t v101 = sub_1B6584D68(a4, v94, v83, v84, v102, v103, v104, v105);
          }
          uint64_t v106 = (uint64_t)v101;
          if (v101)
          {
            CFTypeID v107 = CFGetTypeID(v101);
            if (v107 == sub_1B6562334()) {
              sub_1B64D9188(v106, v90, (uint64_t)a3, v109);
            }
            else {
              sub_1B63F2F54(17, @"Assertion '%s' failed. only CFXValue are supported for partial struct storage", v108, v109, v110, v111, v112, v113, (uint64_t)"0");
            }
          }
          ++v89;
        }
        while (v85 != v89);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v80, v82, (uint64_t)&v117, (uint64_t)v121, 16);
        uint64_t v85 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t sub_1B653EC80(uint64_t result, char *a2, void *a3, void *a4)
{
  if (result)
  {
    unint64_t v7 = objc_msgSend_threadExecutionWidth(a4, a2, (uint64_t)a3, (uint64_t)a4);
    unint64_t v11 = objc_msgSend_width(a2, v8, v9, v10);
    if (v7 >= v11) {
      unint64_t v15 = v11;
    }
    else {
      unint64_t v15 = v7;
    }
    unint64_t v16 = objc_msgSend_height(a2, v12, v13, v14);
    if (v7 >= v16) {
      unint64_t v7 = v16;
    }
    unint64_t v20 = objc_msgSend_maxTotalThreadsPerThreadgroup(a4, v17, v18, v19);
    do
    {
      unint64_t v24 = v7;
      unint64_t v25 = v7 * v15;
      v7 >>= 1;
    }
    while (v25 > v20);
    v31[0] = (v15 + objc_msgSend_width(a2, v21, v22, v23) - 1) / v15;
    v31[1] = (v24 + objc_msgSend_height(a2, v26, v27, v28) - 1) / v24;
    v31[2] = 1;
    v30[0] = v15;
    v30[1] = v24;
    v30[2] = 1;
    return objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(a3, v29, (uint64_t)v31, (uint64_t)v30);
  }
  return result;
}

uint64_t sub_1B653ED5C(uint64_t result, char *a2, void *a3, void *a4)
{
  if (result)
  {
    unint64_t v7 = objc_msgSend_threadExecutionWidth(a4, a2, (uint64_t)a3, (uint64_t)a4);
    unint64_t v11 = objc_msgSend_width(a2, v8, v9, v10);
    if (v7 >= v11) {
      unint64_t v7 = v11;
    }
    unint64_t v15 = objc_msgSend_maxTotalThreadsPerThreadgroup(a4, v12, v13, v14);
    unint64_t v19 = v7;
    do
    {
      unint64_t v20 = v19;
      unint64_t v21 = v19 * v7;
      v19 >>= 1;
    }
    while (v21 > v15);
    v27[0] = (v7 + objc_msgSend_width(a2, v16, v17, v18) - 1) / v7;
    v27[1] = (v20 + objc_msgSend_height(a2, v22, v23, v24) - 1) / v20;
    void v27[2] = 6;
    v26[0] = v7;
    v26[1] = v20;
    v26[2] = 1;
    return objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(a3, v25, (uint64_t)v27, (uint64_t)v26);
  }
  return result;
}

uint64_t sub_1B653EE30(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t sub_1B653EE3C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_1B653EEDC;
    block[3] = &unk_1E61422C0;
    block[4] = result;
    if (qword_1E9DDB2B0 != -1) {
      dispatch_once(&qword_1E9DDB2B0, block);
    }
    return *(void *)(v1 + 488);
  }
  return result;
}

void sub_1B653EEDC(uint64_t a1)
{
  id v8 = objc_alloc_init(MEMORY[0x1E4F35218]);
  objc_msgSend_setDepthCompareFunction_(v8, v2, 7, v3);
  objc_msgSend_setDepthWriteEnabled_(v8, v4, 0, v5);
  *(void *)(*(void *)(a1 + 32) + 488) = objc_msgSend_newDepthStencilStateWithDescriptor_(*(void **)(*(void *)(a1 + 32) + 8), v6, (uint64_t)v8, v7);
}

uint64_t sub_1B653EFA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B64A8F60(a3);
}

uint64_t sub_1B653EFAC(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t sub_1B653EFB8(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t sub_1B653EFC4(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t sub_1B653F124(uint64_t result)
{
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  return result;
}

uint64_t sub_1B653F524(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_didFinishPlayback(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    uint64_t v9 = *(uint64_t (**)(void))(objc_msgSend_didFinishPlayback(*(void **)(a1 + 32), v6, v7, v8) + 16);
    return v9();
  }
  return result;
}

uint64_t sub_1B653F57C(uint64_t a1)
{
  dispatch_async(MEMORY[0x1E4F14428], *(dispatch_block_t *)(a1 + 48));
  objc_msgSend_setCompleted_(*(void **)(a1 + 32), v2, 1, v3);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  uint64_t v7[2] = sub_1B653F630;
  v7[3] = &unk_1E6143008;
  uint64_t v9 = *(void *)(a1 + 56);
  int8x16_t v4 = *(int8x16_t *)(a1 + 32);
  int8x16_t v8 = vextq_s8(v4, v4, 8uLL);
  return objc_msgSend_postCommandWithContext_object_applyBlock_(VFXTransaction, v5, 0, v4.i64[0], v7);
}

uint64_t sub_1B653F630(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9)
  {
    sub_1B64A429C(v9, *(const void **)(a1 + 32), 1, a4, a5, a6, a7, a8);
    uint64_t v10 = *(const void **)(a1 + 48);
    if (v10) {
      CFRelease(v10);
    }
  }
  unint64_t v11 = *(unsigned char **)(a1 + 40);
  if (v11[50])
  {
    return MEMORY[0x1F4181798](v11, sel_recycle, a3, a4);
  }
  else
  {
    return objc_msgSend_reset(v11, a2, a3, a4);
  }
}

uint64_t sub_1B653F6A8(int8x16_t *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (objc_msgSend_loops(*(void **)(a1[2].i64[0] + 24), a2, a3, a4) && (uint64_t v6 = a1[3].i64[1]) != 0)
  {
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    void v10[2] = sub_1B653F780;
    v10[3] = &unk_1E6143008;
    uint64_t v12 = v6;
    int8x16_t v7 = a1[2];
    int8x16_t v11 = vextq_s8(v7, v7, 8uLL);
    return objc_msgSend_postCommandWithContext_object_applyBlock_(VFXTransaction, v5, 0, v7.i64[0], v10);
  }
  else
  {
    uint64_t v9 = *(uint64_t (**)(void))(a1[3].i64[0] + 16);
    return v9();
  }
}

void sub_1B653F780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9)
  {
    sub_1B64A429C(v9, *(const void **)(a1 + 32), 1, a4, a5, a6, a7, a8);
    uint64_t v10 = *(const void **)(a1 + 48);
    if (v10) {
      CFRelease(v10);
    }
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1B653F824;
  block[3] = &unk_1E61422C0;
  block[4] = *(void *)(a1 + 40);
  dispatch_async(MEMORY[0x1E4F14428], block);
}

uint64_t sub_1B653F824(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_play(*(void **)(a1 + 32), a2, a3, a4);
}

uint64_t sub_1B653F82C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_willStartPlayback(*(void **)(a1 + 32), a2, a3, a4);
  if (result)
  {
    uint64_t v9 = *(uint64_t (**)(void))(objc_msgSend_willStartPlayback(*(void **)(a1 + 32), v6, v7, v8) + 16);
    return v9();
  }
  return result;
}

void sub_1B653F8F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1B653FCFC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int8x16_t v4 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], a2, a3, a4);
  qword_1E9DDB2C0 = (uint64_t)v4;

  return v4;
}

uint64_t sub_1B65403BC(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B65403EC()
{
  if (qword_1E9DDB2D8 != -1) {
    dispatch_once_f(&qword_1E9DDB2D8, &qword_1E9DDB2D0, (dispatch_function_t)sub_1B65403BC);
  }
  uint64_t v6 = sub_1B63C8D44(qword_1E9DDB2D0, 0x20uLL);
  if (!v6) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v0, v1, v2, v3, v4, v5, (uint64_t)"resourceCache");
  }
  uint64_t v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  *(void *)(v6 + 16) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(v6 + 24) = CFDictionaryCreateMutable(0, 0, 0, 0);
  *(void *)(v6 + 32) = CFDictionaryCreateMutable(0, 0, v7, v8);
  *(_DWORD *)(v6 + 40) = 0;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, (const void *)v6, (CFNotificationCallback)sub_1B654053C, @"kCFXNotificationImageWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  uint64_t v10 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(v10, (const void *)v6, (CFNotificationCallback)sub_1B654053C, @"kCFXNotificationImageProxyWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  return v6;
}

void sub_1B654053C(int a1, uint64_t a2, int a3, CFNumberRef number)
{
  int valuePtr = 0;
  CFNumberGetValue(number, kCFNumberLongType, &valuePtr);
  sub_1B6540C2C(a2, valuePtr, v5, v6, v7, v8, v9, v10);
}

uint64_t sub_1B6540584()
{
  if (qword_1E9DDB2E0 != -1) {
    dispatch_once(&qword_1E9DDB2E0, &unk_1F0FB5D08);
  }
  return qword_1E9DDB2E8;
}

uint64_t sub_1B65405C8()
{
  uint64_t result = sub_1B65403EC();
  qword_1E9DDB2E8 = result;
  return result;
}

const void *sub_1B65405E8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
    if (a2) {
      goto LABEL_3;
    }
LABEL_15:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_15;
  }
LABEL_3:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  uint64_t v10 = (void *)sub_1B65407BC(a2);
  unint64_t Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v10);
  unint64_t v15 = (const void *)objc_msgSend_copyWeakRef(Value, v12, v13, v14);
  if (v15)
  {
    CFTypeID v16 = CFGetTypeID(v10);
    if (v16 == CFURLGetTypeID() || (CFTypeID v17 = CFGetTypeID(v10), v17 == CFStringGetTypeID()))
    {
      BOOL v18 = VFXHasSpecialResourceBundle();
      double v19 = sub_1B64BB524(v10);
      if (v19 == 0.0 && VFXHasSpecialResourceBundle())
      {
        objc_opt_class();
        uint64_t isKindOfClass = objc_opt_isKindOfClass();
        uint64_t v24 = (uint64_t)v10;
        if (isKindOfClass)
        {
          uint64_t isKindOfClass = objc_msgSend_path(v10, v21, v22, v23);
          uint64_t v24 = isKindOfClass;
        }
        unint64_t v25 = (void *)VFXGetResourceBundle(isKindOfClass, v21, v22, v23);
        uint64_t v29 = objc_msgSend_bundlePath(v25, v26, v27, v28);
        uint64_t v32 = objc_msgSend_stringByAppendingPathComponent_(v29, v30, v24, v31);
        double v19 = sub_1B64BB524(v32);
      }
      if (v19 == 0.0)
      {
        if (!v18) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
      double valuePtr = 0.0;
      CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v10);
      if (v33)
      {
        CFNumberGetValue(v33, kCFNumberDoubleType, &valuePtr);
        double v34 = valuePtr;
      }
      else
      {
        double v34 = 0.0;
      }
      if (v34 != v19)
      {
LABEL_20:
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v10);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), v15);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v10);
        CFRelease(v15);
        unint64_t v15 = 0;
      }
    }
  }
LABEL_21:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  return v15;
}

uint64_t sub_1B65407BC(void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  uint64_t v6 = (uint64_t)a1;
  if (v2 == CFURLGetTypeID())
  {
    uint64_t v6 = (uint64_t)a1;
    if (objc_msgSend_isFileURL(a1, v3, v4, v5))
    {
      uint64_t v6 = (uint64_t)a1;
      if (!objc_msgSend_query(a1, v7, v8, v9)) {
        uint64_t v6 = objc_msgSend_relativePath(a1, v10, v11, v12);
      }
    }
  }
  if (v2 != CFStringGetTypeID()) {
    return v6;
  }

  return objc_msgSend_stringByStandardizingPath(a1, v13, v14, v15);
}

CFTypeRef sub_1B654085C(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)sub_1B65407BC(a2);
  CFTypeRef result = sub_1B65405E8(a1, v3, v4, v5, v6, v7, v8, v9);
  if (result)
  {
    return CFAutorelease(result);
  }
  return result;
}

const void *sub_1B65408B0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"resource");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  unint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  return Value;
}

void sub_1B6540954(uint64_t a1, void *cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (cf) {
      goto LABEL_3;
    }
LABEL_14:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a3) {
      goto LABEL_4;
    }
LABEL_15:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"resource");
    goto LABEL_4;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
  if (!cf) {
    goto LABEL_14;
  }
LABEL_3:
  if (!a3) {
    goto LABEL_15;
  }
LABEL_4:
  double valuePtr = 0.0;
  CFTypeID v11 = CFGetTypeID(cf);
  if (v11 == CFURLGetTypeID() || (CFTypeID v12 = CFGetTypeID(cf), v13 = 0.0, v12 == CFStringGetTypeID()))
  {
    double v13 = sub_1B64BB524(cf);
    double valuePtr = v13;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  uint64_t v14 = (void *)sub_1B65407BC(cf);
  CFTypeID v15 = CFGetTypeID(v14);
  if (v15 == CFStringGetTypeID()) {
    uint64_t v14 = objc_msgSend_copy(v14, v16, v17, v18);
  }
  else {
    CFRetain(v14);
  }
  unint64_t Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v14);
  if (Value)
  {
    uint64_t v23 = objc_msgSend_copyWeakRef(Value, v20, v21, v22);
    if (v23)
    {
      uint64_t v24 = (const void *)v23;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v14);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), v24);
      CFRelease(v24);
    }
    else
    {
      uint64_t v31 = 0;
      uint64_t v32 = &v31;
      uint64_t v33 = 0x2020000000;
      uint64_t v34 = 0;
      CFDictionaryRef v25 = *(const __CFDictionary **)(a1 + 24);
      v30[0] = MEMORY[0x1E4F143A8];
      v30[1] = 3221225472;
      v30[2] = sub_1B6540C0C;
      void v30[3] = &unk_1E6144038;
      v30[4] = &v31;
      v30[5] = v14;
      sub_1B63CCA7C(v25, (uint64_t)v30);
      if (v32[3])
      {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), v14);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)v32[3]);
      }
      _Block_object_dispose(&v31, 8);
    }
  }
  uint64_t v26 = objc_alloc_init(VFXWeakPointer);
  objc_msgSend_setWeakRef_(v26, v27, (uint64_t)a3, v28);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v14, v26);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a3, v14);

  CFRelease(v14);
  if (v13 != 0.0)
  {
    CFNumberRef v29 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v14, v29);
    CFRelease(v29);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
}

void sub_1B6540BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6540C0C(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(result + 40) == a3) {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  }
  return result;
}

void sub_1B6540C2C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"cache");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"resource");
LABEL_3:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  unint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), Value);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), a2);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
}

void sub_1B6540CF4(void *a1)
{
  if ((void *)qword_1E9DDB2E8 == a1) {
    qword_1E9DDB2E8 = 0;
  }
  CFTypeID v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(LocalCenter, a1, @"kCFXNotificationImageProxyWillDie", 0);
  uint64_t v6 = CFNotificationCenterGetLocalCenter();

  CFNotificationCenterRemoveObserver(v6, a1, @"kCFXNotificationImageWillDie", 0);
}

CFStringRef sub_1B6540D9C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXResourceCache 0x%lx>", a1);
}

CFStringRef sub_1B6540DDC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXResourceCache 0x%lx>", a1);
}

uint64_t sub_1B6540E1C()
{
  if (qword_1EB9952B8 != -1) {
    dispatch_once(&qword_1EB9952B8, &unk_1F0FB5D28);
  }
  return qword_1EB9952C0;
}

void sub_1B6540E60()
{
  if (!qword_1EB9952C0) {
    qword_1EB9952C0 = sub_1B63C8D10(&qword_1EB9952C0);
  }
}

uint64_t sub_1B6540EA4()
{
  if (qword_1EB9952B8 != -1) {
    dispatch_once(&qword_1EB9952B8, &unk_1F0FB5D28);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB9952C0, 0xA0uLL);
  sub_1B6492BF4(v0);
  *(void *)(v0 + 168) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  return v0;
}

void sub_1B6540F24(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  }
  uint64_t v10 = *(__CFArray **)(a1 + 168);

  CFArrayAppendValue(v10, value);
}

void sub_1B6540F88(uint64_t a1, CFArrayRef theArray, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (theArray) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"group");
    if (theArray) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animations");
LABEL_3:
  uint64_t v10 = *(__CFArray **)(a1 + 168);
  v11.length = CFArrayGetCount(theArray);
  v11.location = 0;

  CFArrayAppendArray(v10, theArray, v11);
}

CFIndex sub_1B6541028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  }
  CFArrayRef v9 = *(const __CFArray **)(a1 + 168);

  return CFArrayGetCount(v9);
}

const void *sub_1B6541084(uint64_t a1, CFIndex idx, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  }
  CFArrayRef v10 = *(const __CFArray **)(a1 + 168);

  return CFArrayGetValueAtIndex(v10, idx);
}

uint64_t sub_1B65410E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  }
  return *(void *)(a1 + 168);
}

void sub_1B6541134(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"AnimationGroup");
  }
  CFArrayRef v9 = *(__CFArray **)(a1 + 168);

  CFArrayRemoveAllValues(v9);
}

void sub_1B6541190(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dest");
LABEL_3:
  sub_1B6541134(a2, a2, a3, a4, a5, a6, a7, a8);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"AnimationGroup");
  }
  CFArrayRef v16 = *(const __CFArray **)(a1 + 168);
  uint64_t Count = CFArrayGetCount(v16);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v16, i);
      uint64_t v27 = (const void *)sub_1B6494038(ValueAtIndex);
      CFArrayAppendValue(Mutable, v27);
      CFRelease(v27);
    }
  }
  sub_1B6540F88(a2, Mutable, v18, v19, v20, v21, v22, v23);
  CFRelease(Mutable);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v28, v29, v30, v31, v32, v33, (uint64_t)"group");
  }
  __int16 v34 = *(_WORD *)(a1 + 84);
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v28, v29, v30, v31, v32, v33, (uint64_t)"group");
  }
  *(_WORD *)(a2 + 84) = *(_WORD *)(a2 + 84) & 0xFF7F | v34 & 0x80;
}

id sub_1B654131C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v9 = (const void *)a1[21];
  if (v9)
  {
    CFRelease(v9);
    a1[21] = 0;
  }

  return sub_1B6492B90(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B6541360(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationGroup %p animations:%@>", a1, a1[21]);
}

CFStringRef sub_1B65413A4(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationGroup %p animations:%@>", a1, a1[21]);
}

float32x4_t sub_1B6541854(uint64_t a1, uint64_t a2, uint64_t a3, simd_float4x4 a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  simd_float4x4 v23 = __invert_f4(a4);
  float32x4_t v11 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a6, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a6.f32, 1), (float32x4_t)v23.columns[0], a6.f32[0]);
  float32x4_t v12 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a8, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a8.f32, 1), (float32x4_t)v23.columns[0], a8.f32[0]);
  float32x4_t v21 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a5, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a5.f32, 1), (float32x4_t)v23.columns[0], a5.f32[0]);
  v23.columns[0] = (simd_float4)vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[2], a7, 2), (float32x4_t)v23.columns[1], *(float32x2_t *)a7.f32, 1), (float32x4_t)v23.columns[0], a7.f32[0]), v11);
  v23.columns[2] = (simd_float4)vsubq_f32(v12, v11);
  v23.columns[3] = (simd_float4)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23.columns[0], (int32x4_t)v23.columns[0]), (int8x16_t)v23.columns[0], 0xCuLL), vnegq_f32((float32x4_t)v23.columns[2])), (float32x4_t)v23.columns[0], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23.columns[2], (int32x4_t)v23.columns[2]), (int8x16_t)v23.columns[2], 0xCuLL));
  v23.columns[1] = (simd_float4)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23.columns[3], (int32x4_t)v23.columns[3]), (int8x16_t)v23.columns[3], 0xCuLL);
  int32x4_t v13 = (int32x4_t)vmulq_f32((float32x4_t)v23.columns[0], (float32x4_t)v23.columns[0]);
  v13.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1))).u32[0];
  *(float32x2_t *)v12.f32 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  *(float32x2_t *)v12.f32 = vmul_f32(*(float32x2_t *)v12.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)v12.f32)));
  v23.columns[0] = (simd_float4)vmulq_n_f32((float32x4_t)v23.columns[0], vmul_f32(*(float32x2_t *)v12.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)v12.f32))).f32[0]);
  v23.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v23.columns[3], (float32x4_t)v23.columns[3]);
  v23.columns[3].i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.columns[3].f32, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v23.columns[3], 2), *(float32x2_t *)v23.columns[3].f32)).u32[0];
  *(float32x2_t *)v13.i8 = vrsqrte_f32((float32x2_t)v23.columns[3].u32[0]);
  *(float32x2_t *)v13.i8 = vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8)));
  v23.columns[1] = (simd_float4)vmulq_n_f32((float32x4_t)v23.columns[1], vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8))).f32[0]);
  v23.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v23.columns[2], (float32x4_t)v23.columns[2]);
  v23.columns[3].i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v23.columns[3], 2), vadd_f32(*(float32x2_t *)v23.columns[3].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.columns[3].f32, 1))).u32[0];
  *(float32x2_t *)v13.i8 = vrsqrte_f32((float32x2_t)v23.columns[3].u32[0]);
  *(float32x2_t *)v13.i8 = vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8)));
  v23.columns[2] = (simd_float4)vmulq_n_f32((float32x4_t)v23.columns[2], vmul_f32(*(float32x2_t *)v13.i8, vrsqrts_f32((float32x2_t)v23.columns[3].u32[0], vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8))).f32[0]);
  uint64_t v14 = a2 + 36 * a1;
  v23.columns[3] = v23.columns[0];
  v23.columns[3].i32[3] = v23.columns[1].i32[0];
  *(simd_float4 *)uint64_t v14 = v23.columns[3];
  *(int8x16_t *)(v14 + 16) = vextq_s8(vextq_s8((int8x16_t)v23.columns[1], (int8x16_t)v23.columns[1], 0xCuLL), (int8x16_t)v23.columns[2], 8uLL);
  *(_DWORD *)(v14 + 32) = v23.columns[2].i32[2];
  simd_float3x3 v22 = __invert_f3(*(simd_float3x3 *)v23.columns[0].f32);
  float32x4_t result = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v22.columns[0], v21.f32[0]), (float32x4_t)v22.columns[1], *(float32x2_t *)v21.f32, 1), (float32x4_t)v22.columns[2], v21, 2);
  uint64_t v16 = a3 + 12 * a1;
  *(void *)uint64_t v16 = result.i64[0];
  *(_DWORD *)(v16 + 8) = result.i32[2];
  return result;
}

void sub_1B6541A00(uint64_t a1, size_t count, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,size_t *a24)
{
  int v25 = count;
  uint64_t v26 = a1;
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  uint64_t v122 = count;
  if (a13 == a14)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = sub_1B65420A4;
    block[3] = &unk_1E6144078;
    block[4] = a7;
    void block[5] = a4;
    void block[6] = a6;
    void block[7] = a8;
    block[8] = a15;
    block[9] = a16;
    block[10] = a17;
    block[11] = a22;
    block[12] = a21;
    block[13] = a18;
    block[14] = a19;
    block[15] = a20;
    dispatch_apply(count, 0, block);
  }
  else
  {
    v138.i64[0] = 0;
    v138.i64[1] = (uint64_t)&v138;
    v139.i64[0] = 0x2020000000;
    v139.i32[2] = 0;
    uint64_t v27 = malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
    CFArrayRef v35 = sub_1B64ABD08(a3, v28, v29, v30, v31, v32, v33, v34);
    uint64_t v41 = (char *)v35 - 1;
    if ((uint64_t)v35 >= 1)
    {
      CFIndex v42 = 0;
      do
      {
        uint64_t v43 = sub_1B64ABD78(a3, v42, 0, v36, v37, v38, v39, v40);
        sub_1B63D11F0((uint64_t)v43, a13, v44, v45, v46, v47, v48, v49, (uint64_t)v142);
        sub_1B63D11F0((uint64_t)v43, a14, v50, v51, v52, v53, v54, v55, (uint64_t)&v143 + 8);
        v135[0] = MEMORY[0x1E4F143A8];
        v135[1] = 3221225472;
        v135[2] = sub_1B65424C8;
        v135[3] = &unk_1E61440A0;
        v135[6] = a7;
        v135[7] = a4;
        v135[8] = a6;
        v135[9] = a8;
        v135[10] = a15;
        v135[11] = a16;
        v135[12] = a17;
        v135[13] = a22;
        v135[14] = a21;
        v135[15] = a18;
        v135[16] = a19;
        v135[17] = a20;
        v135[4] = &v138;
        v135[5] = v27;
        int v136 = v25;
        sub_1B63D1C5C(v142[0].i64, 2, (uint64_t)v135, v56, v57, v58, v59, v60);
        if (*(_DWORD *)(v138.i64[1] + 24) == v25) {
          break;
        }
      }
      while (v41 != (char *)v42++);
    }
    free(v27);
    _Block_object_dispose(&v138, 8);
    uint64_t v26 = a1;
  }
  if (v26 == 1)
  {
    size_t v62 = 16 * (3 * v25);
  }
  else if (v26)
  {
    size_t v62 = 0;
  }
  else
  {
    size_t v62 = 4 * (3 * v25);
  }
  size_t v117 = v62;
  uint64_t v69 = malloc_type_malloc(v62, 0xA21770E6uLL);
  if (v25)
  {
    uint64_t v70 = 0;
    while (1)
    {
      if (a18)
      {
        uint64_t v71 = *(unsigned __int8 *)(a18 + (3 * v70));
        uint64_t v72 = *(unsigned __int8 *)(a18 + (3 * v70 + 1));
        uint64_t v73 = *(unsigned __int8 *)(a18 + (3 * v70 + 2));
      }
      else if (a19)
      {
        uint64_t v71 = *(unsigned __int16 *)(a19 + 2 * (3 * v70));
        uint64_t v72 = *(unsigned __int16 *)(a19 + 2 * (3 * v70 + 1));
        uint64_t v73 = *(unsigned __int16 *)(a19 + 2 * (3 * v70 + 2));
      }
      else if (a20)
      {
        uint64_t v71 = *(unsigned int *)(a20 + 4 * (3 * v70));
        uint64_t v72 = *(unsigned int *)(a20 + 4 * (3 * v70 + 1));
        uint64_t v73 = *(unsigned int *)(a20 + 4 * (3 * v70 + 2));
      }
      else
      {
        uint64_t v73 = 0;
        uint64_t v72 = 0;
        uint64_t v71 = 0;
      }
      uint64_t v74 = (2 * v70);
      if (a22)
      {
        uint64_t v75 = (unsigned __int16 *)(a22 + 2 * v74);
        v76.i32[0] = *v75;
        v76.i32[1] = v75[1];
        float32x2_t v77 = vdiv_f32(vcvt_f32_u32(v76), (float32x2_t)vdup_n_s32(0x477FFF00u));
      }
      else
      {
        float32x2_t v77 = *(float32x2_t *)(a21 + 4 * v74);
      }
      *(float32x2_t *)v132.f32 = v77;
      *(double *)v78.i64 = sub_1B641E208(a6, v71, v63, v64, v65, v66, v67, v68);
      float32x4_t v129 = v78;
      *(double *)v85.i64 = sub_1B641E208(a6, v72, v79, v80, v81, v82, v83, v84);
      float32x4_t v127 = v85;
      *(double *)v92.i64 = sub_1B641E208(a6, v73, v86, v87, v88, v89, v90, v91);
      float32x4_t v133 = vmlaq_n_f32(vmlaq_n_f32(vmulq_lane_f32(v127, *(float32x2_t *)v132.f32, 1), v129, v132.f32[0]), v92, (float)(1.0 - v132.f32[0]) - v132.f32[1]);
      float32x4_t v93 = vsubq_f32(v127, v129);
      float32x4_t v94 = vsubq_f32(v92, v129);
      float32x4_t v95 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), (int8x16_t)v93, 0xCuLL), vnegq_f32(v94)), v93, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v94, (int32x4_t)v94), (int8x16_t)v94, 0xCuLL));
      int32x4_t v96 = (int32x4_t)vmulq_f32(v93, v93);
      float32x4_t v97 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), (int8x16_t)v95, 0xCuLL);
      v96.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v96, 2), vadd_f32(*(float32x2_t *)v96.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v96.i8, 1))).u32[0];
      float32x2_t v98 = vrsqrte_f32((float32x2_t)v96.u32[0]);
      float32x2_t v99 = vmul_f32(v98, vrsqrts_f32((float32x2_t)v96.u32[0], vmul_f32(v98, v98)));
      float32x4_t v100 = vmulq_n_f32(v93, vmul_f32(v99, vrsqrts_f32((float32x2_t)v96.u32[0], vmul_f32(v99, v99))).f32[0]);
      int32x4_t v101 = (int32x4_t)vmulq_f32(v95, v95);
      v101.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v101.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v101, 2), *(float32x2_t *)v101.i8)).u32[0];
      *(float32x2_t *)v95.f32 = vrsqrte_f32((float32x2_t)v101.u32[0]);
      *(float32x2_t *)v95.f32 = vmul_f32(*(float32x2_t *)v95.f32, vrsqrts_f32((float32x2_t)v101.u32[0], vmul_f32(*(float32x2_t *)v95.f32, *(float32x2_t *)v95.f32)));
      float32x4_t v128 = vmulq_n_f32(v97, vmul_f32(*(float32x2_t *)v95.f32, vrsqrts_f32((float32x2_t)v101.u32[0], vmul_f32(*(float32x2_t *)v95.f32, *(float32x2_t *)v95.f32))).f32[0]);
      simd_float3 v130 = (simd_float3)v100;
      int32x4_t v102 = (int32x4_t)vmulq_f32(v94, v94);
      v102.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v102, 2), vadd_f32(*(float32x2_t *)v102.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v102.i8, 1))).u32[0];
      *(float32x2_t *)v97.f32 = vrsqrte_f32((float32x2_t)v102.u32[0]);
      *(float32x2_t *)v97.f32 = vmul_f32(*(float32x2_t *)v97.f32, vrsqrts_f32((float32x2_t)v102.u32[0], vmul_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)v97.f32)));
      float32x4_t v125 = vmulq_n_f32(v94, vmul_f32(*(float32x2_t *)v97.f32, vrsqrts_f32((float32x2_t)v102.u32[0], vmul_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)v97.f32))).f32[0]);
      if (a1 == 1) {
        break;
      }
      if (!a1)
      {
        *(double *)v103.i64 = sub_1B641E208(a5, v70, v63, v64, v65, v66, v67, v68);
        float32x4_t v134 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a12, a11, v103, 2), a10, *(float32x2_t *)v103.f32, 1), a9, v103.f32[0]), v133);
        v145.columns[1] = (simd_float3)v128;
        v145.columns[0] = v130;
        v145.columns[2] = (simd_float3)v125;
        simd_float3x3 v146 = __invert_f3(v145);
        v146.columns[0] = (simd_float3)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v146.columns[0], v134.f32[0]), (float32x4_t)v146.columns[1], *(float32x2_t *)v134.f32, 1), (float32x4_t)v146.columns[2], v134, 2);
        v69[(3 * v70)] = v146.columns[0].i32[0];
        v69[(3 * v70 + 1)] = v146.columns[0].i32[1];
        __int32 v104 = v146.columns[0].i32[2];
        int v105 = 3 * v70 + 2;
LABEL_32:
        v69[v105] = v104;
      }
      if (++v70 == v122) {
        goto LABEL_34;
      }
    }
    v147.columns[1] = (simd_float4)v128;
    v147.columns[0] = (simd_float4)v100;
    v147.columns[0].i32[3] = 0;
    v147.columns[1].i32[3] = 0;
    v147.columns[2] = (simd_float4)v125;
    v147.columns[2].i32[3] = 0;
    __asm { FMOV            V3.4S, #1.0 }
    v147.columns[3].i64[0] = v133.i64[0];
    v147.columns[3].i32[2] = v133.i32[2];
    simd_float4x4 v148 = __invert_f4(v147);
    unint64_t v109 = 0;
    float32x4_t v138 = a9;
    float32x4_t v139 = a10;
    float32x4_t v140 = a11;
    float32x4_t v141 = a12;
    do
    {
      v142[v109 / 4] = (int8x16_t)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v148.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v138 + v109 * 4))), (float32x4_t)v148.columns[1], *(float32x2_t *)&v138.f32[v109], 1), (float32x4_t)v148.columns[2], *(float32x4_t *)((char *)&v138 + v109 * 4), 2), (float32x4_t)v148.columns[3], *(float32x4_t *)((char *)&v138 + v109 * 4), 3);
      v109 += 4;
    }
    while (v109 != 16);
    int8x16_t v110 = v142[0];
    int8x16_t v111 = v142[1];
    int v112 = 12 * v70;
    int8x16_t v113 = v142[2];
    long long v114 = v143;
    v69[v112] = v142[0].i32[0];
    v69[(12 * v70) | 1] = v111.i32[0];
    v69[(12 * v70) | 2] = v113.i32[0];
    v69[(12 * v70) | 3] = v114;
    *(int32x2_t *)&v69[v112 + 4] = vzip2_s32(*(int32x2_t *)v110.i8, *(int32x2_t *)v111.i8);
    *(int32x2_t *)&v69[v112 + 6] = vzip2_s32(*(int32x2_t *)v113.i8, *(int32x2_t *)&v114);
    *(int32x2_t *)&v69[v112 + 8] = vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v110, v110, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v111, v111, 8uLL));
    v69[v112 + 10] = v113.i32[2];
    __int32 v104 = DWORD2(v114);
    int v105 = 12 * v70 + 11;
    goto LABEL_32;
  }
LABEL_34:
  *a23 = v69;
  *a24 = v117;
}

void sub_1B6542078(_Unwind_Exception *a1)
{
}

void sub_1B65420A4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  DWORD2(v22) = 0;
  *(void *)&long long v22 = 0;
  DWORD2(v21) = 0;
  *(void *)&long long v21 = 0;
  DWORD2(v20) = 0;
  *(void *)&long long v20 = 0;
  double v10 = sub_1B641E284(a1[4], a2, a3, a4, a5, a6, a7, a8);
  sub_1B6542200(a1[5], a1[7], a1[8], a1[9], &v21, &v20, &v22, v11, v10);
  uint64_t v12 = a1[11];
  if (a1[10]) {
    int32x4_t v13 = &v21;
  }
  else {
    int32x4_t v13 = &v20;
  }
  long long v14 = *v13;
  if (v12)
  {
    *(_WORD *)(v12 + 4 * a2) = (int)(float)(65535.0 * *(float *)&v14);
    *(_WORD *)(v12 + ((4 * a2) | 2)) = (int)vmuls_lane_f32(65535.0, *(float32x2_t *)&v14, 1);
  }
  else
  {
    *(void *)(a1[12] + 8 * a2) = v14;
  }
  uint64_t v15 = a1[13];
  if (v15)
  {
    *(unsigned char *)(v15 + 3 * a2) = v22;
    *(unsigned char *)(3 * a2 + a1[13] + 1) = BYTE4(v22);
    *(unsigned char *)(3 * a2 + a1[13] + 2) = BYTE8(v22);
  }
  else
  {
    uint64_t v16 = a1[14];
    if (v16)
    {
      uint64_t v17 = (_WORD *)(v16 + 6 * a2);
      *uint64_t v17 = v22;
      v17[1] = WORD2(v22);
      float32x4_t v17[2] = WORD4(v22);
    }
    else
    {
      uint64_t v18 = a1[15];
      if (v18)
      {
        uint64_t v19 = v18 + 12 * a2;
        *(void *)uint64_t v19 = v22;
        *(_DWORD *)(v19 + _Block_object_dispose(&STACK[0x200], 8) = DWORD2(v22);
      }
    }
  }
}

void sub_1B6542200(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, _OWORD *a6, _OWORD *a7, uint64_t a8, double a9)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v46 = 0;
  uint64_t v47 = &v46;
  uint64_t v48 = 0x2020000000;
  char v49 = 0;
  v44[0] = 0;
  v44[1] = v44;
  v44[2] = 0x2020000000;
  int v45 = 2139095039;
  uint64_t v62 = 0;
  uint64_t v63 = &v62;
  int v66 = 0;
  uint64_t v64 = 0x3020000000;
  uint64_t v65 = 0;
  uint64_t v57 = 0;
  uint64_t v58 = &v57;
  int v61 = 0;
  uint64_t v59 = 0x3020000000;
  uint64_t v60 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = &v52;
  uint64_t v54 = 0x3020000000;
  uint64_t v56 = 0;
  int v55 = 0;
  CFArrayRef v20 = sub_1B64ABD08(a1, a2, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  if ((uint64_t)v20 >= 1)
  {
    CFIndex v21 = 0;
    do
    {
      if (*((unsigned char *)v47 + 24)) {
        break;
      }
      long long v22 = sub_1B64ABD78(a1, v21, 0, v15, v16, v17, v18, v19);
      sub_1B63D11F0((uint64_t)v22, a3, v23, v24, v25, v26, v27, v28, (uint64_t)v50);
      sub_1B63D11F0((uint64_t)v22, a4, v29, v30, v31, v32, v33, v34, (uint64_t)&v51);
      v43[0] = MEMORY[0x1E4F143A8];
      v43[1] = 3221225472;
      v43[2] = sub_1B65433A4;
      v43[3] = &unk_1E6144110;
      *(double *)&v43[10] = a9;
      v43[11] = a5;
      v43[12] = a6;
      v43[13] = a7;
      v43[4] = &v46;
      v43[5] = v44;
      v43[6] = &v57;
      v43[7] = &v62;
      v43[8] = &v52;
      v43[9] = a2;
      sub_1B63D1C5C(v50, 2, (uint64_t)v43, v35, v36, v37, v38, v39);
      ++v21;
    }
    while (v20 != (const __CFArray *)v21);
  }
  uint64_t v40 = v47;
  if (!*((unsigned char *)v47 + 24))
  {
    *a5 = *((_OWORD *)v58 + 2);
    *a6 = *((_OWORD *)v63 + 2);
    *a7 = *((_OWORD *)v53 + 2);
    *((unsigned char *)v40 + 24) = 1;
  }
  _Block_object_dispose(&v52, 8);
  _Block_object_dispose(&v57, 8);
  _Block_object_dispose(&v62, 8);
  _Block_object_dispose(v44, 8);
  _Block_object_dispose(&v46, 8);
}

void sub_1B6542478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose((const void *)(v29 - 256), 8);
  _Block_object_dispose((const void *)(v29 - 208), 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_1B65424C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 2 * a4;
    while (1)
    {
      uint64_t v13 = *(unsigned int *)(a3 + 4 * v11);
      uint64_t v14 = *(void *)(a1 + 40);
      if (!*(_DWORD *)(v14 + 4 * v13))
      {
        uint64_t v15 = *(unsigned int *)(a3 + 4 * (v11 + 1));
        *(_DWORD *)(v14 + 4 * v13) = 1;
        DWORD2(v27) = 0;
        *(void *)&long long v27 = 0;
        DWORD2(v26) = 0;
        *(void *)&long long v26 = 0;
        DWORD2(v25) = 0;
        *(void *)&long long v25 = 0;
        double v16 = sub_1B641E284(*(void *)(a1 + 48), v15, a3, a4, (uint64_t)a5, a6, a7, a8);
        sub_1B6542200(*(void *)(a1 + 56), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), &v26, &v25, &v27, v17, v16);
        uint64_t v18 = *(void *)(a1 + 104);
        uint64_t v19 = *(void *)(a1 + 96) ? &v26 : &v25;
        long long v20 = *v19;
        if (v18)
        {
          *(_WORD *)(v18 + 2 * (2 * v13)) = (int)(float)(65535.0 * *(float *)&v20);
          *(_WORD *)(v18 + 2 * ((2 * v13) | 1u)) = (int)vmuls_lane_f32(65535.0, *(float32x2_t *)&v20, 1);
        }
        else
        {
          *(void *)(*(void *)(a1 + 112) + 4 * (2 * v13)) = v20;
        }
        uint64_t v21 = *(void *)(a1 + 120);
        if (v21)
        {
          uint64_t v22 = (3 * v13);
          *(unsigned char *)(v21 + v22) = v27;
          *(unsigned char *)(*(void *)(a1 + 120) + (v22 + 1)) = BYTE4(v27);
          *(unsigned char *)(*(void *)(a1 + 120) + (v22 + 2)) = BYTE8(v27);
        }
        else
        {
          uint64_t v23 = *(void *)(a1 + 128);
          if (v23)
          {
            *(_WORD *)(v23 + 2 * (3 * v13)) = v27;
            *(_WORD *)(v23 + 2 * (3 * v13 + 1)) = WORD2(v27);
            *(_WORD *)(v23 + 2 * (3 * v13 + 2)) = WORD4(v27);
          }
          else
          {
            uint64_t v24 = *(void *)(a1 + 136);
            if (v24)
            {
              *(_DWORD *)(v24 + 4 * (3 * v13)) = v27;
              *(_DWORD *)(v24 + 4 * (3 * v13 + 1)) = DWORD1(v27);
              *(_DWORD *)(v24 + 4 * (3 * v13 + 2)) = DWORD2(v27);
            }
          }
        }
        if (++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == *(_DWORD *)(a1 + 144)) {
          break;
        }
      }
      v11 += 2;
      if (v12 == v11) {
        return;
      }
    }
    *a5 = 1;
  }
}

void sub_1B65426C8(uint64_t a1, size_t iterations, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, __n128 a10, __n128 a11, __n128 a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void **a22,void **a23,size_t *a24,void **a25,void *a26,size_t *a27)
{
  unsigned int v27 = iterations;
  uint64_t v30 = a20;
  uint64_t v29 = a21;
  uint64_t v31 = a18;
  uint64_t v32 = a19;
  uint64_t v34 = a16;
  uint64_t v33 = a17;
  if (a1 == 1)
  {
    size_t v36 = 4 * (9 * iterations);
    *a24 = v36;
    uint64_t v44 = a7;
    uint64_t v45 = a8;
    uint64_t v42 = a4;
    uint64_t v43 = a6;
    __n128 v40 = a11;
    __n128 v41 = a12;
    __n128 v38 = a9;
    __n128 v39 = a10;
    *a22 = malloc_type_malloc(v36, 0x5A49ABFAuLL);
    *a23 = malloc_type_malloc(*a24, 0x90028C1uLL);
    size_t v37 = 12 * v27;
    *a27 = v37;
    *a25 = malloc_type_malloc(v37, 0x5933B5D5uLL);
    uint64_t v35 = malloc_type_malloc(*a27, 0xE4F664EAuLL);
    uint64_t v34 = a16;
    uint64_t v33 = a17;
    uint64_t v32 = a19;
    uint64_t v30 = a20;
    uint64_t v29 = a21;
    uint64_t v31 = a18;
    a9 = v38;
    a10 = v39;
    a11 = v40;
    a12 = v41;
    a4 = v42;
    a6 = v43;
    a7 = v44;
    a8 = v45;
    goto LABEL_5;
  }
  if (!a1)
  {
    uint64_t v35 = 0;
    *a24 = 0;
    *a22 = 0;
    *a23 = 0;
    *a27 = 0;
    *a25 = 0;
LABEL_5:
    *a26 = v35;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1B6542874;
  block[3] = &unk_1E61440E8;
  __n128 v47 = a9;
  __n128 v48 = a10;
  __n128 v49 = a11;
  __n128 v50 = a12;
  uint64_t v51 = a6;
  uint64_t v52 = a4;
  uint64_t v53 = a13;
  uint64_t v54 = a7;
  uint64_t v55 = a8;
  uint64_t v56 = a15;
  uint64_t v57 = v29;
  uint64_t v58 = v30;
  uint64_t v59 = v32;
  uint64_t v60 = v34;
  uint64_t v61 = v33;
  uint64_t v62 = v31;
  uint64_t v63 = a1;
  uint64_t v64 = a22;
  uint64_t v65 = a25;
  int v66 = a23;
  uint64_t v67 = a26;
  dispatch_apply(v27, 0, block);
}

void sub_1B6542874(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  *(double *)v9.i64 = sub_1B641E208(*(void *)(a1 + 96), a2, a3, a4, a5, a6, a7, a8);
  float32x4_t v103 = v9;
  float32x4_t v99 = *(float32x4_t *)(a1 + 48);
  float32x4_t v101 = *(float32x4_t *)(a1 + 32);
  float32x4_t v97 = *(float32x4_t *)(a1 + 64);
  float32x4_t v105 = *(float32x4_t *)(a1 + 80);
  uint64_t v126 = 0;
  float32x4_t v127 = &v126;
  uint64_t v128 = 0x2020000000;
  char v129 = 0;
  uint64_t v151 = 0;
  uint64_t v152 = &v151;
  uint64_t v153 = 0x3020000000;
  int v155 = 0;
  uint64_t v154 = 0;
  uint64_t v148 = 0;
  v149[0] = &v148;
  int v150 = 0;
  v149[1] = 0x3020000000;
  v149[3] = 0;
  uint64_t v145 = 0;
  v146[0] = &v145;
  int v147 = 0;
  v146[1] = 0x3020000000;
  v146[3] = 0;
  v124[0] = 0;
  v124[1] = v124;
  v124[2] = 0x2020000000;
  int v125 = 2139095039;
  uint64_t v140 = 0;
  float32x4_t v141 = &v140;
  int v144 = 0;
  uint64_t v142 = 0x3020000000;
  uint64_t v143 = 0;
  uint64_t v135 = 0;
  int v136 = &v135;
  int v139 = 0;
  uint64_t v137 = 0x3020000000;
  uint64_t v138 = 0;
  uint64_t v130 = 0;
  uint64_t v131 = &v130;
  uint64_t v132 = 0x3020000000;
  int v134 = 0;
  uint64_t v133 = 0;
  CFArrayRef v23 = sub_1B64ABD08(*(void *)(a1 + 104), v10, v11, v12, v13, v14, v15, v16);
  float32x4_t v106 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v105, v97, v103, 2), v99, *(float32x2_t *)v103.f32, 1), v101, v103.f32[0]);
  if ((uint64_t)v23 >= 1)
  {
    for (CFIndex i = 0; (const __CFArray *)i != v23; ++i)
    {
      if (*((unsigned char *)v127 + 24)) {
        break;
      }
      long long v25 = sub_1B64ABD78(*(void *)(a1 + 104), i, 0, v18, v19, v20, v21, v22);
      uint64_t v123 = 0;
      long long v121 = 0u;
      long long v122 = 0u;
      long long v120 = 0u;
      sub_1B63D11F0((uint64_t)v25, *(void *)(a1 + 112), v26, v27, v28, v29, v30, v31, (uint64_t)&v120);
      v118[0] = v120;
      v118[1] = v121;
      v118[2] = v122;
      uint64_t v119 = v123;
      v107[0] = MEMORY[0x1E4F143A8];
      v107[1] = 3221225472;
      v107[2] = sub_1B6542F28;
      v107[3] = &unk_1E61440C8;
      long long v117 = *(_OWORD *)(a1 + 120);
      float32x4_t v108 = v106;
      unint64_t v109 = &v126;
      int8x16_t v110 = &v148;
      int8x16_t v111 = &v145;
      int v112 = &v151;
      int8x16_t v113 = v124;
      long long v114 = &v140;
      uint64_t v115 = &v135;
      uint64_t v116 = &v130;
      sub_1B63D1BEC((uint64_t *)v118, (uint64_t)v107, v32, v33, v34, v35, v36, v37);
    }
  }
  __n128 v38 = v127;
  if (!*((unsigned char *)v127 + 24))
  {
    *(_OWORD *)(v149[0] + 32) = *((_OWORD *)v136 + 2);
    *(_OWORD *)(v146[0] + 32) = *((_OWORD *)v141 + 2);
    *((_OWORD *)v152 + 2) = *((_OWORD *)v131 + 2);
    *((unsigned char *)v38 + 24) = 1;
  }
  if (*(void *)(a1 + 136)) {
    __n128 v39 = v149;
  }
  else {
    __n128 v39 = v146;
  }
  long long v104 = *(_OWORD *)(*v39 + 32);
  v40.n128_f64[0] = sub_1B641E208(*(void *)(a1 + 120), *((unsigned int *)v152 + 8), v17, v18, v19, v20, v21, v22);
  __n128 v102 = v40;
  v47.n128_f64[0] = sub_1B641E208(*(void *)(a1 + 120), *((unsigned int *)v152 + 9), v41, v42, v43, v44, v45, v46);
  __n128 v100 = v47;
  v54.n128_f64[0] = sub_1B641E208(*(void *)(a1 + 120), *((unsigned int *)v152 + 10), v48, v49, v50, v51, v52, v53);
  __n128 v98 = v54;
  v61.n128_f64[0] = sub_1B641E208(*(void *)(a1 + 128), *((unsigned int *)v152 + 8), v55, v56, v57, v58, v59, v60);
  __n128 v96 = v61;
  v68.n128_f64[0] = sub_1B641E208(*(void *)(a1 + 128), *((unsigned int *)v152 + 9), v62, v63, v64, v65, v66, v67);
  __n128 v95 = v68;
  *(double *)v75.i64 = sub_1B641E208(*(void *)(a1 + 128), *((unsigned int *)v152 + 10), v69, v70, v71, v72, v73, v74);
  float v76 = (float)(1.0 - *(float *)&v104) - *((float *)&v104 + 1);
  __n128 v93 = (__n128)v75;
  float32x4_t v77 = v106;
  float32x4_t v78 = vsubq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v100, *(float32x2_t *)&v104, 1), (float32x4_t)v102, *(float *)&v104), (float32x4_t)v98, v76), v106);
  float32x4_t v79 = vsubq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_lane_f32((float32x4_t)v95, *(float32x2_t *)&v104, 1), (float32x4_t)v96, *(float *)&v104), v75, v76), v106);
  float32x4_t v80 = vmulq_f32(v78, v78);
  float v81 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 2), vaddq_f32(v80, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v80.f32, 1))).f32[0]);
  float32x4_t v82 = vmulq_f32(v79, v79);
  float32x4_t v83 = vmulq_f32(v78, v79);
  float v84 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v82, 2), vaddq_f32(v82, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v82.f32, 1))).f32[0]);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2), vaddq_f32(v83, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.f32, 1))).f32[0] >= 0.0)
  {
    if (v81 >= v84)
    {
      float v85 = v84 / (float)(v84 + sub_1B65432EC(v106, v102, v100, v98, v79));
    }
    else
    {
      float v86 = sub_1B65432EC(v106, v96, v95, v93, v78);
      float v85 = v86 / (float)(v81 + v86);
    }
    float32x4_t v77 = v106;
  }
  else
  {
    float v85 = v84 / (float)(v81 + v84);
  }
  *(float *)(*(void *)(a1 + 144) + 4 * a2) = v85;
  uint64_t v87 = *(void *)(a1 + 152);
  if (v87)
  {
    *(_WORD *)(v87 + 4 * a2) = (int)(float)(*(float *)&v104 * 65535.0);
    *(_WORD *)(v87 + ((4 * a2) | 2)) = (int)(float)(*((float *)&v104 + 1) * 65535.0);
  }
  else
  {
    *(void *)(*(void *)(a1 + 160) + 8 * a2) = v104;
  }
  uint64_t v88 = *(void *)(a1 + 168);
  if (v88)
  {
    *(unsigned char *)(v88 + 3 * a2) = *((_OWORD *)v152 + 2);
    *(unsigned char *)(3 * a2 + *(void *)(a1 + 168) + 1) = *((unsigned char *)v152 + 36);
    *(unsigned char *)(3 * a2 + *(void *)(a1 + 168) + 2) = *((unsigned char *)v152 + 40);
  }
  else
  {
    uint64_t v89 = *(void *)(a1 + 176);
    if (v89)
    {
      uint64_t v90 = (_WORD *)(v89 + 6 * a2);
      *uint64_t v90 = *((_OWORD *)v152 + 2);
      v90[1] = *((_WORD *)v152 + 18);
      v90[2] = *((_WORD *)v152 + 20);
    }
    else
    {
      uint64_t v91 = *(void *)(a1 + 184);
      if (v91)
      {
        float32x4_t v92 = (_DWORD *)(v91 + 12 * a2);
        _DWORD *v92 = *((_DWORD *)v152 + 8);
        v92[1] = *((_DWORD *)v152 + 9);
        v92[2] = *((_DWORD *)v152 + 10);
      }
    }
  }
  if (*(void *)(a1 + 192) == 1)
  {
    sub_1B6541854(a2, **(void **)(a1 + 200), **(void **)(a1 + 208), *(simd_float4x4 *)(a1 + 32), v77, (float32x4_t)v102, (float32x4_t)v100, (float32x4_t)v98);
    sub_1B6541854(a2, **(void **)(a1 + 216), **(void **)(a1 + 224), *(simd_float4x4 *)(a1 + 32), v106, (float32x4_t)v96, (float32x4_t)v95, (float32x4_t)v93);
  }
  _Block_object_dispose(&v130, 8);
  _Block_object_dispose(&v135, 8);
  _Block_object_dispose(&v140, 8);
  _Block_object_dispose(v124, 8);
  _Block_object_dispose(&v145, 8);
  _Block_object_dispose(&v148, 8);
  _Block_object_dispose(&v151, 8);
  _Block_object_dispose(&v126, 8);
}

void sub_1B6542E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a69, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  _Block_object_dispose(&STACK[0x240], 8);
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose(&STACK[0x270], 8);
  _Block_object_dispose((const void *)(v69 - 224), 8);
  _Block_object_dispose((const void *)(v69 - 176), 8);
  _Block_object_dispose(&a65, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1B6542F28(float32x4_t *a1, uint64_t a2, unsigned int *a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *a3;
  uint64_t v9 = a3[1];
  uint64_t v11 = a3[2];
  uint64_t v12 = a3[3];
  *(double *)v13.i64 = sub_1B641E208(a1[7].i64[0], v10, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8);
  float32x4_t v99 = v13;
  *(double *)v20.i64 = sub_1B641E208(a1[7].i64[0], v9, v14, v15, v16, v17, v18, v19);
  float32x4_t v98 = v20;
  *(double *)v27.i64 = sub_1B641E208(a1[7].i64[0], v11, v21, v22, v23, v24, v25, v26);
  float32x4_t v97 = v27;
  *(double *)v34.i64 = sub_1B641E208(a1[7].i64[0], v12, v28, v29, v30, v31, v32, v33);
  float32x4_t v91 = v34;
  *(double *)v41.i64 = sub_1B641E208(a1[7].i64[1], v10, v35, v36, v37, v38, v39, v40);
  float32x4_t v107 = v41;
  *(double *)v48.i64 = sub_1B641E208(a1[7].i64[1], v9, v42, v43, v44, v45, v46, v47);
  float32x4_t v105 = v48;
  *(double *)v55.i64 = sub_1B641E208(a1[7].i64[1], v11, v49, v50, v51, v52, v53, v54);
  float32x4_t v103 = v55;
  *(double *)v62.i64 = sub_1B641E208(a1[7].i64[1], v12, v56, v57, v58, v59, v60, v61);
  unint64_t v63 = 0;
  float32x4_t v96 = vsubq_f32(v107, v99);
  float32x4_t v64 = vsubq_f32(v105, v98);
  float32x4_t v95 = v64;
  uint64_t v65 = v10;
  v64.i32[0] = v10;
  float32x4_t v66 = v64;
  uint64_t v93 = v9;
  v66.i32[1] = v9;
  float32x4_t v94 = vsubq_f32(v103, v97);
  float32x4_t v67 = v66;
  v67.i32[2] = v11;
  v66.i32[2] = v12;
  float32x4_t v87 = v66;
  float32x4_t v88 = v67;
  float32x4_t v90 = vsubq_f32(v62, v91);
  unsigned int v92 = v11;
  v64.i32[1] = v11;
  unsigned int v89 = v12;
  v64.i32[2] = v12;
  float32x4_t v86 = v64;
  while (1)
  {
    float v68 = (double)v63 * 0.025;
    float32x4_t v69 = a1[2];
    float v101 = v68;
    uint64_t v70 = (float32x4_t *)(*(void *)(a1[3].i64[1] + 8) + 32);
    uint64_t v71 = (float32x4_t *)(*(void *)(a1[4].i64[0] + 8) + 32);
    uint64_t v72 = (float32x4_t *)(*(void *)(a1[4].i64[1] + 8) + 32);
    uint64_t v73 = *(void *)(a1[5].i64[0] + 8);
    uint64_t v74 = *(float32x4_t **)(a1[5].i64[1] + 8);
    float32x4_t v75 = *(float32x4_t **)(a1[6].i64[0] + 8);
    float v76 = *(float32x4_t **)(a1[6].i64[1] + 8);
    v111[0] = 0.0;
    v110.i32[2] = 0;
    v110.i64[0] = 0;
    v109.i32[2] = 0;
    v109.i64[0] = 0;
    float32x4_t v104 = vmlaq_n_f32(v98, v95, v68);
    float32x4_t v106 = vmlaq_n_f32(v99, v96, v68);
    float32x4_t v100 = vmlaq_n_f32(v97, v94, v68);
    float32x4_t v108 = v69;
    if (sub_1B6543928(v111, &v109, &v110, v106, v104, v100, v69))
    {
      char v77 = 1;
      BOOL result = v65;
      unsigned int v80 = v92;
      unsigned int v79 = v93;
      goto LABEL_18;
    }
    float v81 = v74 + 2;
    float32x4_t v82 = v75 + 2;
    float32x4_t v83 = v76 + 2;
    if (v111[0] < *(float *)(v73 + 24))
    {
      *(float *)(v73 + 24) = v111[0];
      *float32x4_t v82 = v109;
      *float v81 = v110;
      *float32x4_t v83 = v88;
    }
    float32x4_t v102 = vmlaq_n_f32(v91, v90, v101);
    if (sub_1B6543928(v111, &v109, &v110, v106, v104, v102, v108))
    {
      char v77 = 1;
      BOOL result = v65;
      unsigned int v79 = v93;
      goto LABEL_17;
    }
    if (v111[0] < *(float *)(v73 + 24))
    {
      *(float *)(v73 + 24) = v111[0];
      *float32x4_t v82 = v109;
      *float v81 = v110;
      *float32x4_t v83 = v87;
    }
    if (sub_1B6543928(v111, &v109, &v110, v106, v100, v102, v108))
    {
      char v77 = 1;
      BOOL result = v65;
LABEL_16:
      unsigned int v79 = v92;
LABEL_17:
      unsigned int v80 = v89;
LABEL_18:
      *uint64_t v70 = v109;
      v84.i32[3] = v110.i32[3];
      *uint64_t v71 = v110;
      v84.i64[0] = __PAIR64__(v79, result);
      v84.i32[2] = v80;
      *uint64_t v72 = v84;
      goto LABEL_19;
    }
    if (v111[0] < *(float *)(v73 + 24))
    {
      *(float *)(v73 + 24) = v111[0];
      *float32x4_t v82 = v109;
      *float v81 = v110;
      *float32x4_t v83 = v86;
    }
    BOOL result = sub_1B6543928(v111, &v109, &v110, v104, v100, v102, v108);
    if (result)
    {
      char v77 = 1;
      BOOL result = v93;
      goto LABEL_16;
    }
    char v77 = 0;
    if (v111[0] < *(float *)(v73 + 24))
    {
      uint64_t v70 = v82;
      *(float *)(v73 + 24) = v111[0];
      uint64_t v71 = v81;
      BOOL result = v93;
      unsigned int v79 = v92;
      unsigned int v80 = v89;
      uint64_t v72 = v83;
      goto LABEL_18;
    }
LABEL_19:
    *(unsigned char *)(*(void *)(a1[3].i64[0] + 8) + 24) = v77;
    if (*(unsigned char *)(*(void *)(a1[3].i64[0] + 8) + 24)) {
      break;
    }
    if (++v63 == 41) {
      return result;
    }
  }
  *a5 = 1;
  return result;
}

float sub_1B65432EC(float32x4_t a1, __n128 a2, __n128 a3, __n128 a4, float32x4_t a5)
{
  v17[0] = a2;
  v17[1] = a3;
  float32x4_t v17[2] = a4;
  sub_1B63F3754((uint64_t)v16, (uint64_t)v17);
  int32x4_t v5 = (int32x4_t)vmulq_f32(a5, a5);
  v5.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1))).u32[0];
  float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  v15[0] = a1;
  v15[1] = vmulq_n_f32(a5, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]);
  v14.i32[2] = 0;
  v14.i64[0] = 0;
  int v8 = sub_1B63F184C((uint64_t)v15, v16, &v14);
  float result = 0.0;
  if (v8)
  {
    float32x4_t v10 = vsubq_f32(v14, a1);
    float32x4_t v11 = vmulq_f32(v10, v10);
    return sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  }
  return result;
}

uint64_t sub_1B65433A4(void *a1, uint64_t a2, unsigned int *a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *a3;
  unsigned int v12 = a3[2];
  uint64_t v11 = a3[3];
  __int32 v14 = a3[4];
  uint64_t v13 = a3[5];
  __int32 v16 = a3[6];
  uint64_t v15 = a3[7];
  double v17 = sub_1B641E284(a1[9], a3[1], (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8);
  double v24 = sub_1B641E284(a1[9], v11, v18, v19, v20, v21, v22, v23);
  double v31 = sub_1B641E284(a1[9], v13, v25, v26, v27, v28, v29, v30);
  double v38 = sub_1B641E284(a1[9], v15, v32, v33, v34, v35, v36, v37);
  v76.i32[2] = 0;
  v76.i64[0] = 0;
  v75.i32[2] = 0;
  v75.i64[0] = 0;
  float32x2_t v39 = (float32x2_t)a1[10];
  uint64_t result = sub_1B6543748(&v75, &v76, *(float32x2_t *)&v17, *(float32x2_t *)&v24, *(float32x2_t *)&v31, v39, v40, v41, v42, v43);
  if (result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    *(void *)&long long v49 = __PAIR64__(v12, v10);
    DWORD2(v49) = v14;
LABEL_17:
    *(_OWORD *)a1[13] = v49;
    *a5 = 1;
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
    return result;
  }
  float32x4_t v50 = v76;
  float32x2_t v51 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v24, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v17, v76.f32[0]), *(float32x2_t *)&v31, v76, 2), v39);
  float v52 = vaddv_f32(vmul_f32(v51, v51));
  uint64_t v53 = *(void *)(a1[5] + 8);
  if (v52 < *(float *)(v53 + 24))
  {
    *(float *)(v53 + 24) = v52;
    *(float32x4_t *)(*(void *)(a1[6] + 8) + 32) = v75;
    *(float32x4_t *)(*(void *)(a1[7] + 8) + 32) = v50;
    v50.i64[0] = __PAIR64__(v12, v10);
    v50.i32[2] = v14;
    *(float32x4_t *)(*(void *)(a1[8] + 8) + 32) = v50;
    float32x2_t v39 = (float32x2_t)a1[10];
  }
  uint64_t result = sub_1B6543748(&v75, &v76, *(float32x2_t *)&v17, *(float32x2_t *)&v24, *(float32x2_t *)&v38, v39, v45, v46, v47, v48);
  if (result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    *(void *)&long long v49 = __PAIR64__(v12, v10);
LABEL_16:
    DWORD2(v49) = v16;
    goto LABEL_17;
  }
  float32x4_t v58 = v76;
  float32x2_t v59 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v24, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v17, v76.f32[0]), *(float32x2_t *)&v38, v76, 2), v39);
  float v60 = vaddv_f32(vmul_f32(v59, v59));
  uint64_t v61 = *(void *)(a1[5] + 8);
  if (v60 < *(float *)(v61 + 24))
  {
    *(float *)(v61 + 24) = v60;
    *(float32x4_t *)(*(void *)(a1[6] + 8) + 32) = v75;
    *(float32x4_t *)(*(void *)(a1[7] + 8) + 32) = v58;
    v58.i64[0] = __PAIR64__(v12, v10);
    v58.i32[2] = v16;
    *(float32x4_t *)(*(void *)(a1[8] + 8) + 32) = v58;
    float32x2_t v39 = (float32x2_t)a1[10];
  }
  uint64_t result = sub_1B6543748(&v75, &v76, *(float32x2_t *)&v17, *(float32x2_t *)&v31, *(float32x2_t *)&v38, v39, v54, v55, v56, v57);
  if (result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    LODWORD(v49) = v10;
LABEL_15:
    DWORD1(v49) = v14;
    goto LABEL_16;
  }
  float32x4_t v66 = v76;
  float32x2_t v67 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v31, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v17, v76.f32[0]), *(float32x2_t *)&v38, v76, 2), v39);
  float v68 = vaddv_f32(vmul_f32(v67, v67));
  uint64_t v69 = *(void *)(a1[5] + 8);
  if (v68 < *(float *)(v69 + 24))
  {
    *(float *)(v69 + 24) = v68;
    *(float32x4_t *)(*(void *)(a1[6] + 8) + 32) = v75;
    *(float32x4_t *)(*(void *)(a1[7] + 8) + 32) = v66;
    v66.i64[0] = __PAIR64__(v14, v10);
    v66.i32[2] = v16;
    *(float32x4_t *)(*(void *)(a1[8] + 8) + 32) = v66;
    float32x2_t v39 = (float32x2_t)a1[10];
  }
  uint64_t result = sub_1B6543748(&v75, &v76, *(float32x2_t *)&v24, *(float32x2_t *)&v31, *(float32x2_t *)&v38, v39, v62, v63, v64, v65);
  if (result)
  {
    *(float32x4_t *)a1[11] = v75;
    HIDWORD(v49) = v76.i32[3];
    *(float32x4_t *)a1[12] = v76;
    LODWORD(v49) = v12;
    goto LABEL_15;
  }
  float32x4_t v70 = v76;
  float32x2_t v71 = vsub_f32(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v31, *(float32x2_t *)v76.f32, 1), *(float32x2_t *)&v24, v76.f32[0]), *(float32x2_t *)&v38, v76, 2), v39);
  float v72 = vaddv_f32(vmul_f32(v71, v71));
  uint64_t v73 = *(void *)(a1[5] + 8);
  if (v72 < *(float *)(v73 + 24))
  {
    *(float *)(v73 + 24) = v72;
    HIDWORD(v74) = v75.i32[3];
    *(float32x4_t *)(*(void *)(a1[6] + 8) + 32) = v75;
    *(void *)&long long v74 = __PAIR64__(v14, v12);
    *(float32x4_t *)(*(void *)(a1[7] + 8) + 32) = v70;
    DWORD2(v74) = v16;
    *(_OWORD *)(*(void *)(a1[8] + 8) + 32) = v74;
  }
  return result;
}

uint64_t sub_1B6543748(float32x4_t *a1, float32x4_t *a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x2_t a6, double a7, double a8, double a9, int8x16_t _Q7)
{
  float32x2_t v11 = vsub_f32(a4, a3);
  float32x2_t v12 = vsub_f32(a5, a3);
  float32x2_t v13 = vsub_f32(a6, a3);
  float32x2_t v14 = vmul_f32(v11, v11);
  float32x2_t v15 = vadd_f32(v14, (float32x2_t)vdup_lane_s32((int32x2_t)v14, 1));
  *(float32x2_t *)_Q7.i8 = vmul_f32(v11, v12);
  int32x2_t v16 = (int32x2_t)vmul_f32(v12, v12);
  int32x2_t v17 = (int32x2_t)vmul_f32(v11, v13);
  int32x2_t v18 = (int32x2_t)vmul_f32(v12, v13);
  _D6 = vadd_f32((float32x2_t)vzip1_s32(v17, *(int32x2_t *)_Q7.i8), (float32x2_t)vzip2_s32(v17, *(int32x2_t *)_Q7.i8));
  _D5 = vadd_f32((float32x2_t)vzip1_s32(v18, v16), (float32x2_t)vzip2_s32(v18, v16));
  int32x2_t v21 = (int32x2_t)vmla_n_f32(vmul_n_f32(_D6, -_D6.f32[1]), _D5, v15.f32[0]);
  float32x2_t v22 = (float32x2_t)vdup_lane_s32(v21, 0);
  __asm { FMLA            S7, S6, V5.S[1] }
  v22.i32[0] = _Q7.i32[0];
  *(float32x2_t *)_Q7.i8 = vdiv_f32(v22, (float32x2_t)vdup_lane_s32(v21, 1));
  *(float *)v10.i32 = (float)(1.0 - *(float *)_Q7.i32) - *(float *)&_Q7.i32[1];
  float32x4_t v27 = (float32x4_t)vextq_s8(vextq_s8(v10, v10, 4uLL), _Q7, 0xCuLL);
  float32x4_t v28 = v27;
  v28.i32[3] = v27.i32[2];
  __asm { FMOV            V20.4S, #1.0 }
  uint32x4_t v30 = (uint32x4_t)vceqq_f32(vminq_f32(vmaxq_f32(v28, (float32x4_t)0), _Q20), v27);
  v30.i32[3] = v30.i32[2];
  unsigned int v31 = vminvq_u32(v30);
  if ((v31 & 0x80000000) != 0)
  {
    *a1 = v28;
    goto LABEL_29;
  }
  if (*(float *)v10.i32 < 0.0)
  {
    if (*(float *)_Q7.i32 < 0.0)
    {
      *a1 = v28;
      float32x4_t v28 = (float32x4_t)xmmword_1B6E4F2E0;
LABEL_29:
      *a2 = v28;
      return v31 >> 31;
    }
    if (*(float *)&_Q7.i32[1] < 0.0)
    {
      *a1 = v28;
      float32x4_t v28 = (float32x4_t)xmmword_1B6E4F320;
      goto LABEL_29;
    }
    float32x2_t v34 = vsub_f32(a5, a4);
    int32x2_t v35 = (int32x2_t)vmul_f32(v34, vsub_f32(a6, a4));
    int32x2_t v36 = (int32x2_t)vmul_f32(v34, v34);
    float32x2_t v37 = vadd_f32((float32x2_t)vzip1_s32(v35, v36), (float32x2_t)vzip2_s32(v35, v36));
    float v33 = vdiv_f32(v37, (float32x2_t)vdup_lane_s32((int32x2_t)v37, 1)).f32[0];
    if (v33 >= 1.0) {
      float v33 = 1.0;
    }
    if (v33 <= 0.0) {
      float v33 = 0.0;
    }
    *a1 = v28;
    v28.i32[0] = 0;
    v28.i32[3] = 0;
    v28.f32[1] = 1.0 - v33;
LABEL_28:
    v28.f32[2] = v33;
    goto LABEL_29;
  }
  if (*(float *)_Q7.i32 < 0.0 && *(float *)&_Q7.i32[1] < 0.0)
  {
    *a1 = v28;
    float32x4_t v28 = (float32x4_t)xmmword_1B6E4F300;
    goto LABEL_29;
  }
  if (*(float *)&_Q7.i32[1] < 0.0)
  {
    float v32 = vdiv_f32(_D6, v15).f32[0];
    if (v32 >= 1.0) {
      float v32 = 1.0;
    }
    if (v32 <= 0.0) {
      float v32 = 0.0;
    }
    *a1 = v28;
    v28.i64[1] = 0;
    v28.f32[0] = 1.0 - v32;
    v28.f32[1] = v32;
    goto LABEL_29;
  }
  if (*(float *)_Q7.i32 < 0.0)
  {
    float v33 = _D5.f32[0] / _D5.f32[1];
    if ((float)(_D5.f32[0] / _D5.f32[1]) >= 1.0) {
      float v33 = 1.0;
    }
    if (v33 <= 0.0) {
      float v33 = 0.0;
    }
    *a1 = v28;
    v28.i32[1] = 0;
    v28.i32[3] = 0;
    v28.f32[0] = 1.0 - v33;
    goto LABEL_28;
  }
  return v31 >> 31;
}

BOOL sub_1B6543928(_DWORD *a1, float32x4_t *a2, float32x4_t *a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7)
{
  float32x4_t v10 = vsubq_f32(a5, a4);
  float32x4_t v11 = vsubq_f32(a6, a4);
  float32x4_t v13 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL);
  int8x16_t v14 = (int8x16_t)vmlaq_f32(vmulq_f32(v13, vnegq_f32(v11)), v10, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL));
  float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), v14, 0xCuLL);
  float32x4_t v16 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), vnegq_f32(v10)), v15, v13);
  float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), (int8x16_t)v16, 0xCuLL);
  int32x4_t v18 = (int32x4_t)vmulq_f32(v10, v10);
  v18.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v18, 2), vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v18.i8, 1))).u32[0];
  float32x2_t v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
  float32x2_t v20 = vmul_f32(v19, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)));
  float32x4_t v21 = vmulq_n_f32(v10, vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0]);
  int32x4_t v22 = (int32x4_t)vmulq_f32(v16, v16);
  v22.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v22.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v22, 2), *(float32x2_t *)v22.i8)).u32[0];
  float32x2_t v23 = vrsqrte_f32((float32x2_t)v22.u32[0]);
  float32x2_t v24 = vmul_f32(v23, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v23, v23)));
  float32x4_t v25 = vmulq_n_f32(v17, vmul_f32(v24, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v24, v24))).f32[0]);
  float32x4_t v26 = vmulq_f32(a7, v21);
  float32x4_t v27 = vmulq_f32(a7, v25);
  float32x4_t v28 = vmlaq_n_f32(vmulq_n_f32(v25, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]), v21, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]);
  int32x4_t v29 = (int32x4_t)vmulq_f32(v10, v21);
  int32x4_t v30 = (int32x4_t)vmulq_f32(v10, v25);
  *(int32x2_t *)v30.i8 = vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v29, 2), vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v30, 2), vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v30.i8, 1))));
  int32x4_t v31 = (int32x4_t)vmulq_f32(v11, v21);
  int32x4_t v32 = (int32x4_t)vmulq_f32(v11, v25);
  float32x4_t v33 = vsubq_f32(v28, a4);
  int32x4_t v34 = (int32x4_t)vmulq_f32(v21, v33);
  int8x16_t v35 = (int8x16_t)vdupq_laneq_s32(v34, 2);
  *(int32x2_t *)v21.f32 = vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v31, 2), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v32, 2), vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1))));
  int32x4_t v36 = (int32x4_t)vmulq_f32(v25, v33);
  v46.i32[2] = 0;
  v46.i64[0] = 0;
  v45.i32[2] = 0;
  v45.i64[0] = 0;
  sub_1B6543748(&v46, &v45, 0, *(float32x2_t *)v30.i8, *(float32x2_t *)v21.f32, (float32x2_t)vzip1_s32((int32x2_t)vadd_f32(*(float32x2_t *)v35.i8, vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v34.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v36, 2), vadd_f32(*(float32x2_t *)v36.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v36.i8, 1)))), 0.0, *(double *)v33.i64, *(double *)v34.i64, v35);
  float32x4_t v37 = v45;
  float32x4_t v38 = vsubq_f32(a7, vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a5, *(float32x2_t *)v45.f32, 1), a4, v45.f32[0]), a6, v45, 2));
  float32x4_t v39 = vmulq_f32(v38, v38);
  v39.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0];
  *a1 = v39.i32[0];
  *a2 = v46;
  *a3 = v37;
  return v39.f32[0] == 0.0;
}

void sub_1B6543BB8(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6544084(uint64_t result, uint64_t a2, float a3)
{
  *(void *)uint64_t result = &unk_1F0FB0F90;
  *(float *)(result + 64) = a3;
  *(void *)(result + 72) = a2;
  return result;
}

__n128 *sub_1B65440AC(__n128 *result, __n128 a2)
{
  result[3] = a2;
  return result;
}

float32x4_t sub_1B65440B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B64A01D4(*(void *)(a1 + 72), a2, a3, a4, a5, a6, a7, a8);
  v11.i32[3] = 0;
  v11.i32[0] = HIDWORD(*(void *)v10);
  v12.i32[0] = *(void *)(v10 + 8);
  float32x4_t v13 = *(float32x4_t *)(v10 + 48);
  v14.i32[0] = *(_OWORD *)v10;
  v14.i32[1] = *(_OWORD *)(v10 + 16);
  v14.i64[1] = *(_OWORD *)(v10 + 32);
  v11.i32[1] = HIDWORD(*(void *)(v10 + 16));
  v11.i32[2] = HIDWORD(*(void *)(v10 + 32));
  v12.i32[1] = *(void *)(v10 + 24);
  v12.i64[1] = *(void *)(v10 + 40);
  v13.i32[3] = 0;
  int8x16_t v15 = (int8x16_t)vmulq_f32(*(float32x4_t *)v10, *(float32x4_t *)v10);
  _Q2 = vmulq_f32(*(float32x4_t *)(v10 + 16), *(float32x4_t *)(v10 + 16));
  float32x4_t v17 = vmulq_f32(*(float32x4_t *)(v10 + 32), *(float32x4_t *)(v10 + 32));
  float32x2_t v18 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)_Q2.f32), (float32x2_t)vzip2_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)_Q2.f32));
  int8x16_t v19 = vextq_s8(v15, v15, 8uLL);
  *(float32x2_t *)v19.i8 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v19.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)_Q2, (int8x16_t)_Q2, 8uLL)), v18));
  __asm { FMOV            V2.2S, #1.0 }
  *(float32x2_t *)_Q2.f32 = vdiv_f32(*(float32x2_t *)_Q2.f32, *(float32x2_t *)v19.i8);
  v19.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0]);
  *(int8x16_t *)(a1 + 16) = v19;
  _Q2.f32[2] = 1.0 / *(float *)&v19.i32[2];
  _Q2.i32[3] = 0;
  float32x4_t v24 = vmulq_f32(v12, _Q2);
  float32x4_t v25 = vmulq_f32(v11, _Q2);
  float32x4_t v26 = vmulq_f32(v14, _Q2);
  float32x4_t v27 = *(float32x4_t *)(a1 + 48);
  int8x16_t v28 = (int8x16_t)vmulq_f32(v27, v24);
  v27.i32[3] = 0;
  int8x16_t v29 = (int8x16_t)vmulq_f32(v27, v26);
  float32x4_t v30 = vmulq_f32(v27, v25);
  v28.i32[3] = 0;
  *(float32x2_t *)v30.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v29.i8, *(float32x2_t *)v30.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL)));
  *(float32x2_t *)&v30.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), 0);
  float32x4_t v31 = vaddq_f32(v13, v30);
  v30.i32[0] = *(_DWORD *)(a1 + 64);
  *(float32x4_t *)a2 = v26;
  *(float32x4_t *)(a2 + 16) = v25;
  float32x4_t result = vmulq_n_f32(v31, v30.f32[0]);
  *(float32x4_t *)(a2 + 32) = v24;
  *(float32x4_t *)(a2 + 4_Block_object_dispose(&STACK[0x200], 8) = result;
  return result;
}

uint64_t sub_1B65441DC(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v9 = *(float32x4_t *)(a2 + 16);
  float32x4_t v10 = *(float32x4_t *)(a2 + 32);
  float32x4_t v11 = a1[3];
  int8x16_t v12 = (int8x16_t)vmulq_f32(v10, v11);
  v11.i32[3] = 0;
  int8x16_t v13 = (int8x16_t)vmulq_f32(*(float32x4_t *)a2, v11);
  float32x4_t v14 = vmulq_f32(v9, v11);
  v12.i32[3] = 0;
  *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v14.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL)));
  *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)), 0);
  float32x4_t v15 = (float32x4_t)vtrn1q_s32(*(int32x4_t *)a2, (int32x4_t)v9);
  v16.i64[0] = vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL).u64[0];
  v15.i64[1] = v10.u32[0];
  *(int32x2_t *)v17.f32 = vzip2_s32(*(int32x2_t *)a2, *(int32x2_t *)v9.f32);
  *(int32x2_t *)&v17.u32[2] = vzip2_s32(*(int32x2_t *)v10.f32, 0);
  v16.i64[1] = vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL).u32[0];
  float32x4_t v18 = vsubq_f32(vmulq_n_f32(*(float32x4_t *)(a2 + 48), 1.0 / a1[4].f32[0]), v14);
  v18.i32[3] = 1.0;
  float32x4_t v19 = a1[1];
  float32x4_t v42 = vmulq_lane_f32(v17, *(float32x2_t *)v19.f32, 1);
  float32x4_t v43 = vmulq_n_f32(v15, v19.f32[0]);
  float32x4_t v46 = v43;
  float32x4_t v47 = v42;
  float32x4_t v44 = vmulq_laneq_f32(v16, v19, 2);
  float32x4_t v45 = v18;
  float32x4_t v48 = v44;
  float32x4_t v49 = v18;
  uint64_t v20 = sub_1B64A1E7C(a1[4].i64[1], a2, a3, a4, a5, a6, a7, a8);
  if (v20)
  {
    uint64_t v28 = v20;
    if (sub_1B64A1E7C(v20, v21, v22, v23, v24, v25, v26, v27))
    {
      *(double *)v36.i64 = sub_1B64A2220(v28, v29, v30, v31, v32, v33, v34, v35);
      uint64_t v40 = 0;
      v50[0] = v43;
      v50[1] = v42;
      v50[2] = v44;
      v50[3] = v45;
      do
      {
        v51[v40] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v36, COERCE_FLOAT(v50[v40])), v37, *(float32x2_t *)&v50[v40], 1), v38, (float32x4_t)v50[v40], 2), v39, (float32x4_t)v50[v40], 3);
        ++v40;
      }
      while (v40 != 4);
      float32x4_t v46 = (float32x4_t)v51[0];
      float32x4_t v47 = (float32x4_t)v51[1];
      float32x4_t v48 = (float32x4_t)v51[2];
      float32x4_t v49 = (float32x4_t)v51[3];
    }
  }
  return sub_1B64A2614(a1[4].i64[1], (uint64_t)&v46);
}

uint64_t sub_1B6544604(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  unsigned int v3 = *(_DWORD *)(result + 232) & 0xFFFFFFFC;
  if (a2 == 2)
  {
    unsigned int v4 = v3 | 2;
    float32x4_t result = sub_1B6DD24CC(result, 4);
  }
  else if (a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 232) & 0xFFFFFFFC;
  }
  else
  {
    unsigned int v4 = v3 | 1;
  }
  uint64_t v5 = *(void *)(v2 + 208);
  if (v5)
  {
    int v6 = *(_DWORD *)(v5 + 8);
    if (v6 == 21) {
      int v7 = v4 | 8;
    }
    else {
      int v7 = v4;
    }
    if (v6 == 22) {
      v4 |= 8u;
    }
    else {
      unsigned int v4 = v7;
    }
  }
  *(_DWORD *)(v2 + 232) = v4;
  return result;
}

uint64_t sub_1B6544678(uint64_t result)
{
  if (*(float *)(result + 288) > 0.0)
  {
    uint64_t v1 = result;
    float32x4_t result = *(void *)(result + 208);
    int v4 = 0;
    if (result)
    {
      float32x4_t result = (*(uint64_t (**)(uint64_t, uint64_t *, int *))(*(void *)result + 24))(result, &v3, &v4);
      int v2 = v4;
    }
    else
    {
      int v2 = 0;
    }
    *(_DWORD *)(v1 + 284) = v2;
  }
  return result;
}

uint64_t sub_1B65446F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    if (*(float *)a2 != 0.0 || *(float *)(a2 + 4) != 0.0 || *(float *)(a2 + 8) != 0.0)
    {
      uint64_t v5 = sub_1B6544850();
      v6.i64[0] = 0x8000000080000000;
      v6.i64[1] = 0x8000000080000000;
      int8x16_t v8 = veorq_s8(*(int8x16_t *)a2, v6);
      sub_1B6548938((uint64_t)v9, (float32x4_t *)v5);
      v9[3] = (__n128)v8;
      if (*(_DWORD *)(v2 + 8) == 31 && *(void *)(v2 + 16) == 2880154539)
      {
        sub_1B6DE4C40(v2, 0, v9, 1);
        return v2;
      }
      uint64_t v4 = sub_1B6E073B8(128, 16);
      sub_1B6DE495C(v4, 1);
      *(void *)(v4 + 16) = 2880154539;
      sub_1B6DE49E8(v4, v9, (_DWORD *)v2, 0);
      return v4;
    }
    if (*(_DWORD *)(a1 + 8) == 31 && *(void *)(a1 + 16) == 2880154539)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 64);
      (*(void (**)(uint64_t))(*(void *)a1 + 8))(a1);
      return v4;
    }
  }
  return v2;
}

void sub_1B654483C(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

long long *sub_1B6544850()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DCAC60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DCAC60))
  {
    xmmword_1E9DCAC50 = xmmword_1B6E4F370;
    __cxa_guard_release(&qword_1E9DCAC60);
  }
  return &xmmword_1E9DCAC50;
}

void sub_1B65448AC(float32x4_t *a1, uint64_t a2, long long *a3, long long *a4, float a5)
{
  long long v10 = *a4;
  int8x16_t v8 = (_DWORD *)sub_1B65446F4(a2, (uint64_t)&v10);
  (*(void (**)(float32x4_t *, _DWORD *))(a1->i64[0] + 24))(a1, v8);
  sub_1B6544678((uint64_t)a1);
  v9.n128_f32[0] = a5;
  sub_1B6544970(a1, v8, a3, v9);
  if (v8)
  {
    if ((v8[2] - 21) <= 1) {
      a1[14].i32[2] |= 8u;
    }
  }
}

void sub_1B6544970(float32x4_t *a1, _DWORD *a2, long long *a3, __n128 a4)
{
  float v4 = a4.n128_f32[0];
  long long v11 = 0uLL;
  if (a3)
  {
    long long v6 = *a3;
    HIDWORD(v6) = 0;
    long long v11 = v6;
  }
  else if (a2 && (a1[14].i8[8] & 1) == 0)
  {
    unsigned int v7 = a2[2];
    BOOL v8 = v7 > 0x1C;
    int v9 = (1 << v7) & 0x10608000;
    if (v8 || v9 == 0) {
      (*(void (**)(_DWORD *, long long *, __n128))(*(void *)a2 + 64))(a2, &v11, a4);
    }
  }
  sub_1B6E06750((uint64_t)a1, (float32x2_t *)&v11, v4);
  sub_1B6E067DC(a1);
}

uint64_t sub_1B6544B24(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 240);
  if (result)
  {
    sub_1B6DD24E4(result, 1);
    sub_1B6544604(*(void *)(*(void *)(a1 + 32) + 240), *(void *)(a1 + 40));
    uint64_t v3 = *(void *)(a1 + 32);
    if (*(unsigned char *)(v3 + 232)) {
      int v4 = 1;
    }
    else {
      int v4 = 4;
    }
    sub_1B6DD24CC(*(void *)(v3 + 240), v4);
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 240);
    return sub_1B6DD24EC(v5, 0);
  }
  return result;
}

void sub_1B6544CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B6544CCC(uint64_t a1, __n128 a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v3 + 240);
  if (v4)
  {
    if (*(unsigned char *)(v3 + 172)) {
      uint64_t v5 = (long long *)(*(void *)(*(void *)(a1 + 40) + 8) + 32);
    }
    else {
      uint64_t v5 = 0;
    }
    a2.n128_u32[0] = *(_DWORD *)(a1 + 48);
    sub_1B6544970((float32x4_t *)v4, *(_DWORD **)(v4 + 208), v5, a2);
  }
}

void sub_1B6544E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B6544E18(uint64_t a1, __n128 a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v3 + 240);
  if (v4)
  {
    if (*(unsigned char *)(v3 + 172)) {
      uint64_t v5 = (long long *)(*(void *)(*(void *)(a1 + 40) + 8) + 32);
    }
    else {
      uint64_t v5 = 0;
    }
    a2.n128_u32[0] = *(_DWORD *)(v3 + 16);
    sub_1B6544970((float32x4_t *)v4, *(_DWORD **)(v4 + 208), v5, a2);
  }
}

void sub_1B6544F2C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 64) + 240);
  if (v1)
  {
    uint64_t v3 = *(_OWORD **)(v1 + 536);
    if (v3)
    {
      v3[3] = *(_OWORD *)(a1 + 32);
      uint64_t v4 = *(void *)(*(void *)(a1 + 64) + 240);
      *(void *)(v4 + 536) = v3;
      (*(void (**)(_OWORD *, uint64_t))(*(void *)v3 + 16))(v3, v4 + 16);
      uint64_t v5 = *(float32x4_t **)(*(void *)(a1 + 64) + 240);
      uint64_t v6 = v5[13].i64[0];
      float v7 = *(float *)(a1 + 72);
      if (*(unsigned char *)(a1 + 76)) {
        BOOL v8 = (long long *)(a1 + 48);
      }
      else {
        BOOL v8 = 0;
      }
      unsigned int v9 = *(_DWORD *)(a1 + 40);
      *(void *)&long long v10 = *(void *)(a1 + 32);
      *((void *)&v10 + 1) = v9;
      sub_1B65448AC(v5, v6, v8, &v10, v7);
    }
  }
}

void sub_1B65450E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B65450F8(uint64_t a1, __n128 a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v3 + 240);
  if (v4)
  {
    if (*(unsigned char *)(v3 + 172)) {
      uint64_t v5 = (long long *)(*(void *)(*(void *)(a1 + 40) + 8) + 32);
    }
    else {
      uint64_t v5 = 0;
    }
    a2.n128_u32[0] = *(_DWORD *)(v3 + 16);
    sub_1B6544970((float32x4_t *)v4, *(_DWORD **)(v4 + 208), v5, a2);
  }
}

float sub_1B65451EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v1)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v1 + 532) = result;
  }
  return result;
}

uint64_t sub_1B6545248(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_nodeWithNodeRef_(VFXNode, a2, a1, a4);
  uint64_t v8 = objc_msgSend_physicsBody(v4, v5, v6, v7);

  return MEMORY[0x1F4181798](v8, sel_isResting, v9, v10);
}

BOOL sub_1B6545280(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_nodeWithNodeRef_(VFXNode, a2, a1, a4);
  uint64_t v8 = objc_msgSend_physicsBody(v4, v5, v6, v7);
  return objc_msgSend_type(v8, v9, v10, v11) == 1;
}

uint64_t sub_1B6545364(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 240);
  if (result)
  {
    sub_1B6DD24EC(result, 0);
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 240);
    if (*(unsigned char *)(a1 + 40)) {
      int v4 = 1;
    }
    else {
      int v4 = 4;
    }
    return sub_1B6DD24CC(v3, v4);
  }
  return result;
}

float sub_1B6545474(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v1)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v1 + 252) = result;
  }
  return result;
}

float sub_1B654553C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v1)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v1 + 256) = result;
  }
  return result;
}

float sub_1B6545604(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v1)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v1 + 260) = result;
  }
  return result;
}

float32x2_t sub_1B65456CC(uint64_t a1, float32x2_t result)
{
  if (*(void *)(*(void *)(a1 + 32) + 240))
  {
    result.i32[0] = *(_DWORD *)(a1 + 40);
    return (float32x2_t)sub_1B6E06730(*(int8x8_t **)(*(void *)(a1 + 32) + 240), result, result.f32[0]);
  }
  return result;
}

float32x2_t sub_1B654579C(uint64_t a1, float32x2_t result)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 240))
  {
    result.i32[0] = *(_DWORD *)(v2 + 64);
    return (float32x2_t)sub_1B6E06730(*(int8x8_t **)(v2 + 240), result, *(float32_t *)(a1 + 40));
  }
  return result;
}

double sub_1B6545870(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v1)
  {
    double result = *(double *)(a1 + 40);
    *(double *)(v1 + 524) = result;
  }
  return result;
}

double sub_1B6545940(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v1)
  {
    double result = *(double *)(a1 + 40);
    *(double *)(v1 + 524) = result;
  }
  return result;
}

void sub_1B6545BFC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6545C14(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)(result + 64) + 240))
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void **)(result + 72);
    if (v9)
    {
      uint64_t v10 = objc_msgSend__shapeHandle_(v9, a2, *(void *)(*(void *)(*(void *)(v8 + 80) + 8) + 24), a4);
      objc_msgSend__setBtShape_(*(void **)(v8 + 64), v11, v10, v12);
    }
    int8x16_t v13 = *(const void **)(*(void *)(*(void *)(v8 + 80) + 8) + 24);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(*(void *)(*(void *)(v8 + 80) + 8) + 24) = 0;
    }
    uint64_t v14 = *(void *)(v8 + 64);
    float32x4_t v15 = *(void **)(v14 + 248);
    if (v15)
    {
      float32x4_t v16 = *(float32x4_t **)(v14 + 240);
      uint64_t v17 = objc_msgSend_btShape(v15, a2, a3, a4);
      float v18 = *(float *)(v8 + 88);
      if (*(unsigned char *)(v8 + 92)) {
        float32x4_t v19 = (long long *)(v8 + 32);
      }
      else {
        float32x4_t v19 = 0;
      }
      long long v32 = *(_OWORD *)(v8 + 48);
      sub_1B65448AC(v16, v17, v19, &v32, v18);
    }
    else
    {
      sub_1B63F2F54(16, @"Error: unable to update the physics shape of %@", a3, a4, a5, a6, a7, a8, *(void *)(v8 + 64));
    }
    uint64_t v23 = *(void **)(v8 + 72);
    objc_msgSend_worldTransform(*(void **)(*(void *)(v8 + 64) + 8), v20, v21, v22);
    float32x4_t v28 = vmulq_f32(v27, v27);
    *(float *)&double v31 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]);
    float32x4_t v30 = vmulq_f32(v29, v29);
    HIDWORD(v31) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]);
    return objc_msgSend__setNodeScale_(v23, v24, v25, v26, v31);
  }
  return result;
}

__n128 sub_1B6545D64(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void sub_1B6545E58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 176))(a1, a2, a4, a3, a5);
    sub_1B6DD24EC(a2, 0);
  }
  else
  {
    sub_1B63F2F54(0, @"Warning: cannot change collision bit masks without physics world", a3, a4, a5, a6, a7, a8, a9);
  }
}

void sub_1B6545FF8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 200);
    if (v10)
    {
      if (*(void *)(v10 + 8) != *(void *)(a1 + 48))
      {
        uint64_t v12 = objc_msgSend__handle(*(void **)(a1 + 40), a2, a3, a4);
        uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 240);
        uint64_t v18 = *(void *)(a1 + 48);
        uint64_t v17 = *(void *)(a1 + 56);
        uint64_t v19 = *(void *)(a1 + 64);
        sub_1B6545E58(v12, v16, v17, v18, v19, v13, v14, v15, a9);
      }
    }
  }
}

void sub_1B654614C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 200);
    if (v10)
    {
      if (*(void *)(v10 + 16) != *(void *)(a1 + 48))
      {
        uint64_t v12 = objc_msgSend__handle(*(void **)(a1 + 40), a2, a3, a4);
        uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 240);
        uint64_t v17 = *(void *)(a1 + 48);
        uint64_t v18 = *(void *)(a1 + 56);
        uint64_t v19 = *(void *)(a1 + 64);
        sub_1B6545E58(v12, v16, v17, v18, v19, v13, v14, v15, a9);
      }
    }
  }
}

void sub_1B654629C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 200);
    if (v10)
    {
      if (*(void *)(v10 + 24) != *(void *)(a1 + 48))
      {
        uint64_t v12 = objc_msgSend__handle(*(void **)(a1 + 40), a2, a3, a4);
        uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 240);
        uint64_t v17 = *(void *)(a1 + 56);
        uint64_t v18 = *(void *)(a1 + 64);
        uint64_t v19 = *(void *)(a1 + 48);
        sub_1B6545E58(v12, v16, v17, v18, v19, v13, v14, v15, a9);
      }
    }
  }
}

uint64_t sub_1B65463BC(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 32) + 240);
  if (v1)
  {
    *(_DWORD *)(v1 + 28_Block_object_dispose(&STACK[0x200], 8) = *(_DWORD *)(result + 40);
    return sub_1B6544678(*(void *)(*(void *)(result + 32) + 240));
  }
  return result;
}

__n128 sub_1B654648C(__n128 *a1)
{
  uint64_t v2 = *(void *)(a1[3].n128_u64[0] + 240);
  if (v2)
  {
    sub_1B6DD24EC(v2, 0);
    __n128 result = a1[2];
    result.n128_u32[3] = 0;
    *(__n128 *)(*(void *)(a1[3].n128_u64[0] + 240) + 352) = result;
  }
  return result;
}

double sub_1B65465EC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v4)
  {
    int v6 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)(v4 + 576) = *(unsigned char *)(a1 + 48) == 0;
    if (v6)
    {
      objc_msgSend_gravity(*(void **)(a1 + 40), a2, a3, a4);
      float32x4_t v15 = v7;
      objc_msgSend_scale(*(void **)(a1 + 40), v8, v9, v10);
      uint64_t v11 = *(float32x4_t **)(*(void *)(a1 + 32) + 240);
      float32x4_t v13 = vmulq_n_f32(v15, 1.0 / v12);
      v13.i32[3] = 0;
      float32x4_t v16 = v13;
    }
    else
    {
      uint64_t v11 = *(float32x4_t **)(*(void *)(a1 + 32) + 240);
      float32x4_t v16 = 0uLL;
    }
    *(void *)&double result = sub_1B6E06940(v11, &v16).n128_u64[0];
  }
  return result;
}

float32x4_t sub_1B6546734(float32x4_t *a1)
{
  uint64_t v1 = *(__n128 **)(a1[3].i64[0] + 240);
  if (v1)
  {
    float32x4_t result = vmulq_laneq_f32(a1[2], a1[2], 3);
    result.i32[3] = 0;
    v1[23] = (__n128)result;
  }
  return result;
}

float32x4_t sub_1B654686C(__n128 *a1)
{
  uint64_t v1 = *(float32x4_t **)(a1[3].n128_u64[0] + 240);
  if (v1)
  {
    float32x4_t result = (float32x4_t)a1[2];
    float32x4_t v2 = vmulq_n_f32(result, v1[24].f32[0]);
    result.i32[3] = 0;
    v1[25] = result;
    v2.i32[3] = 0;
    v1[40] = v2;
  }
  return result;
}

__n128 sub_1B6546944(__n128 *a1)
{
  uint64_t v1 = *(__n128 **)(a1[3].n128_u64[0] + 240);
  if (v1)
  {
    __n128 result = a1[2];
    result.n128_u32[3] = 0;
    v1[39] = result;
  }
  return result;
}

float32x4_t sub_1B6546A18(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *(void *)(a1[3].i64[0] + 240);
  if (v10)
  {
    sub_1B6DD24EC(v10, 0);
    uint64_t v11 = *(float32x4_t **)(a1[3].i64[0] + 240);
    float32x4_t v12 = a1[2];
    v12.i32[3] = 0;
    float32x4_t v13 = vmulq_f32(v11[25], v12);
    if (a1[3].i8[8])
    {
      float32x4_t v14 = vmulq_n_f32(v13, v11[24].f32[0]);
      v14.i32[3] = 0;
      float32x4_t result = vaddq_f32(v11[22], v14);
      v11[22] = result;
    }
    else
    {
      float32x4_t result = vaddq_f32(v11[29], v13);
      v11[29] = result;
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: cannot apply force on a body that is not attached to a VFXNode", a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

float32x4_t sub_1B6546B70(int8x8_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *(void *)(*(void *)&a1[8] + 240);
  if (v10)
  {
    sub_1B6DD24EC(v10, 0);
    uint64_t v11 = *(float32x4_t **)(*(void *)&a1[8] + 240);
    if (a1[9].i8[0])
    {
      unsigned __int32 v12 = a1[5].u32[0];
      *(int8x8_t *)v25.f32 = a1[4];
      v25.i64[1] = v12;
      __int32 v13 = a1[7].i32[0];
      int8x8_t v22 = a1[6];
      __int32 v23 = v13;
      int v24 = 0;
      result.i64[0] = sub_1B6546C78(v11, &v25, &v22).u64[0];
    }
    else
    {
      float32x4_t v15 = *(float32x4_t *)a1[4].i8;
      float32x4_t v16 = *(float32x4_t *)a1[6].i8;
      v15.i32[3] = 0;
      *(int8x8_t *)v17.f32 = vext_s8(*(int8x8_t *)v16.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL), 4uLL);
      *(int8x8_t *)&v17.u32[2] = a1[6];
      v16.i32[3] = 0;
      float32x4_t v18 = vmulq_f32(v15, v11[25]);
      v19.i64[0] = vextq_s8((int8x16_t)v18, (int8x16_t)v18, 4uLL).u64[0];
      v19.i64[1] = v18.i64[0];
      int8x16_t v20 = (int8x16_t)vsubq_f32(vmulq_f32(v16, v19), vmulq_f32(v18, v17));
      v17.i64[0] = vextq_s8(v20, v20, 4uLL).u64[0];
      v17.i64[1] = v20.u32[0];
      float32x4_t result = vaddq_f32(v11[29], v18);
      float32x4_t v21 = vaddq_f32(v11[30], vmulq_f32(v11[39], v17));
      v11[29] = result;
      v11[30] = v21;
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: cannot apply force on a body that is not attached to a VFXNode", a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

float32x4_t sub_1B6546C78(float32x4_t *a1, float32x4_t *a2, int8x8_t *a3)
{
  result.i32[0] = a1[24].i32[0];
  if (result.f32[0] != 0.0)
  {
    float32x4_t v4 = a1[25];
    float32x4_t v5 = vmulq_n_f32(vmulq_f32(*a2, v4), result.f32[0]);
    v5.i32[3] = 0;
    float32x4_t v6 = a1[21];
    a1[22] = vaddq_f32(a1[22], v5);
    float32x4_t v7 = vmulq_f32(v4, *a2);
    *(int8x8_t *)v8.f32 = vext_s8(*a3, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a3->i8, *(int8x16_t *)a3->i8, 8uLL), 4uLL);
    *(int8x8_t *)&v8.u32[2] = *a3;
    v9.i64[0] = vextq_s8((int8x16_t)v7, (int8x16_t)v7, 4uLL).u64[0];
    v9.i64[1] = v7.i64[0];
    int8x16_t v10 = (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)a3->i8, v9), vmulq_f32(v7, v8));
    v4.i64[0] = vextq_s8(v10, v10, 4uLL).u64[0];
    v4.i64[1] = v10.i64[0];
    float32x4_t v11 = v4;
    v11.i32[3] = 0;
    int8x16_t v12 = (int8x16_t)vmulq_f32(v6, v4);
    int8x16_t v13 = (int8x16_t)vmulq_f32(a1[19], v11);
    float32x4_t v14 = vmulq_f32(a1[20], v11);
    v12.i32[3] = 0;
    *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v14.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL)));
    *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)), 0);
    float32x4_t result = vaddq_f32(a1[23], vmulq_f32(a1[39], v14));
    a1[23] = result;
  }
  return result;
}

float32x4_t sub_1B6546DE8(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *(void *)(a1[3].i64[0] + 240);
  if (v10)
  {
    sub_1B6DD24EC(v10, 0);
    float32x4_t v11 = vmulq_laneq_f32(a1[2], a1[2], 3);
    v11.i32[3] = 0;
    int8x16_t v12 = *(float32x4_t **)(a1[3].i64[0] + 240);
    if (a1[3].i8[8])
    {
      float32x4_t v13 = vmulq_f32(v12[19], v11);
      int8x16_t v14 = (int8x16_t)vmulq_f32(v12[20], v11);
      int8x16_t v15 = (int8x16_t)vmulq_f32(v12[21], v11);
      v15.i32[3] = 0;
      *(float32x2_t *)v13.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v13.f32, *(float32x2_t *)v14.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)));
      *(float32x2_t *)&v13.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)), 0);
      float32x4_t result = vaddq_f32(v12[23], vmulq_f32(v13, v12[39]));
      v12[23] = result;
    }
    else
    {
      float32x4_t result = vaddq_f32(v12[30], vmulq_f32(v12[39], v11));
      v12[30] = result;
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: cannot apply force on a body that is not attached to a VFXNode", a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

void sub_1B6546F74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 240);
  if (v9)
  {
    *(_OWORD *)(v9 + 464) = 0u;
    *(_OWORD *)(v9 + 480) = 0u;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 240) + 352) = 0u;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 240) + 36_Block_object_dispose(&STACK[0x200], 8) = 0u;
  }
  else
  {
    sub_1B63F2F54(16, @"Error: cannot clear forces on a body that is not attached to a VFXNode", a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B6547058(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 240);
  if (result)
  {
    if (*(unsigned char *)(a1 + 40)) {
      return sub_1B6DD24CC(result, 3);
    }
    else {
      return sub_1B6DD24EC(result, 0);
    }
  }
  return result;
}

uint64_t sub_1B6547138(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 96), sel_moveToTransform_, a3, a4);
}

uint64_t sub_1B654720C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 96), sel_moveToTransform_, a3, a4);
}

void sub_1B6547A98(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6547B70(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(*(void **)(a1 + 32), a2, a3, a4);
  sub_1B64A474C(v5, 0, v6, v7, v8, v9, v10, v11);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 48);
  uint64_t v14 = *(void *)(a1 + 56);

  return MEMORY[0x1F4181798](v12, sel_removePhysicsBody_handle_, v13, v14);
}

uint64_t sub_1B6547D54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_world(*(void **)(a1 + 64), a2, a3, a4);
  uint64_t v9 = objc_msgSend_physicsWorld(v5, v6, v7, v8);
  sub_1B64A474C(*(void *)(a1 + 80), *(const __CFDictionary **)(a1 + 72), v10, v11, v12, v13, v14, v15);
  uint64_t v18 = *(void *)(a1 + 88);
  if (v18 && !*(void *)(v18 + 208))
  {
    float32x4_t v19 = objc_msgSend__shapeHandle_(*(void **)(*(void *)(a1 + 72) + 48), v16, *(void *)(a1 + 80), v17);
    objc_msgSend__setBtShape_(*(void **)(a1 + 72), v20, (uint64_t)v19, v21);
    uint64_t v25 = objc_msgSend_btShape(v19, v22, v23, v24);
    uint64_t v26 = *(float32x4_t **)(a1 + 88);
    float v27 = *(float *)(a1 + 120);
    if (*(unsigned char *)(a1 + 124)) {
      float32x4_t v28 = (long long *)(a1 + 32);
    }
    else {
      float32x4_t v28 = 0;
    }
    long long v46 = *(_OWORD *)(a1 + 48);
    sub_1B65448AC(v26, v25, v28, &v46, v27);
    float32x4_t v29 = *(void **)(*(void *)(a1 + 72) + 48);
    objc_msgSend_worldTransform(*(void **)(a1 + 64), v30, v31, v32);
    float32x4_t v34 = vmulq_f32(v33, v33);
    float32x4_t v36 = vmulq_f32(v35, v35);
    v34.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0]);
    v34.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]);
    objc_msgSend__setNodeScale_(v29, v37, v38, v39, *(double *)v34.i64);
  }
  uint64_t v40 = *(void *)(a1 + 72);
  uint64_t v41 = *(void *)(a1 + 80);
  uint64_t v42 = *(void *)(a1 + 96);
  uint64_t v43 = *(void *)(a1 + 104);
  uint64_t v44 = *(void *)(a1 + 112);

  return objc_msgSend_addPhysicsBody_nodeRef_colGroup_colMask_colTest_(v9, v16, v40, v41, v42, v43, v44);
}

float sub_1B6548938(uint64_t a1, float32x4_t *a2)
{
  float32x4_t v2 = vmulq_f32(*a2, *a2);
  v2.i64[0] = vpaddq_f32(v2, v2).u64[0];
  v2.f32[0] = 2.0 / vpadd_f32(*(float32x2_t *)v2.f32, *(float32x2_t *)v2.f32).f32[0];
  float v3 = v2.f32[0] * COERCE_FLOAT(*a2);
  float v4 = vmuls_lane_f32(v2.f32[0], *(float32x2_t *)a2->f32, 1);
  v2.f32[0] = vmuls_lane_f32(v2.f32[0], *a2, 2);
  float v5 = vmuls_lane_f32(v3, *a2, 3);
  float v6 = vmuls_lane_f32(v4, *a2, 3);
  float v7 = vmuls_lane_f32(v2.f32[0], *a2, 3);
  float v8 = v3 * COERCE_FLOAT(*a2);
  float v9 = v4 * COERCE_FLOAT(*a2);
  float v10 = v2.f32[0] * COERCE_FLOAT(*a2);
  float v11 = vmuls_lane_f32(v4, *(float32x2_t *)a2->f32, 1);
  float v12 = vmuls_lane_f32(v2.f32[0], *(float32x2_t *)a2->f32, 1);
  float v13 = vmuls_lane_f32(v2.f32[0], *a2, 2);
  *(float *)a1 = 1.0 - (float)(v11 + v13);
  *(float *)(a1 + 4) = v9 - v7;
  *(float *)(a1 + _Block_object_dispose(&STACK[0x200], 8) = v10 + v6;
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)(a1 + 16) = v9 + v7;
  *(float *)(a1 + 20) = 1.0 - (float)(v8 + v13);
  *(float *)(a1 + 24) = v12 - v5;
  *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(float *)(a1 + 32) = v10 - v6;
  *(float *)(a1 + 36) = v12 + v5;
  float result = 1.0 - (float)(v8 + v11);
  *(float *)(a1 + 40) = result;
  *(_DWORD *)(a1 + 44) = 0;
  return result;
}

uint64_t sub_1B65489DC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9)
{
  uint64_t v164 = *MEMORY[0x1E4F143B8];
  double v14 = a7;
  double v15 = fabsf(a5) * 0.5;
  double v16 = fabsf(a6);
  if (v15 >= v16 * 0.5)
  {
    if (v16 * 0.5 <= v14) {
      double v14 = v16 * 0.5;
    }
  }
  else if (v15 <= v14)
  {
    double v14 = v15;
  }
  float v17 = v14;
  if (a4 <= 1) {
    uint64_t v18 = 1;
  }
  else {
    uint64_t v18 = a4;
  }
  if (a2 <= 1) {
    uint64_t v19 = 1;
  }
  else {
    uint64_t v19 = a2;
  }
  if (a3 <= 1) {
    uint64_t v20 = 1;
  }
  else {
    uint64_t v20 = a3;
  }
  uint64_t v21 = (void *)sub_1B65494B8(0, v19, v20, v18, a5, a6, v17, a8, a9);
  values = v21;
  CFTypeRef v162 = (CFTypeRef)sub_1B65494B8(1, v19, v20, v18, a5, a6, v17, a8, a9);
  CFTypeRef v163 = (CFTypeRef)sub_1B65494B8(3, v19, v20, v18, a5, a6, v17, a8, a9);
  int8x8_t v22 = (void *)sub_1B63D0314();
  uint64_t v160 = v22;
  sub_1B63D04D0((uint64_t)v22, a1, v23, v24, v25, v26, v27, v28);
  if (a1 != 3)
  {
    uint64_t v36 = v19 + 1;
    uint64_t v37 = (v20 + 1) * (v19 + 1);
    uint64_t v38 = v18 + v19 + v37;
    uint64_t v39 = v18 + v20 + v38;
    uint64_t v40 = v20 * (v19 + 1);
    if (a1 == 2)
    {
      uint64_t v125 = v18 + v19 + v37;
      uint64_t v127 = (v20 + 1) * (v19 + 1);
      uint64_t v129 = v40 + v19;
      uint64_t v131 = v18 + v20 + v38;
      uint64_t v133 = v18 + v19 + v39;
      uint64_t v135 = v20 * (v19 + 1);
      if (v17 > 0.0) {
        uint64_t v42 = 8 * v18 + 4 * (v20 + 1 + v36) + v20 + v19 + 2 * v20 * v19 - 8;
      }
      else {
        uint64_t v42 = v20 + v19 + 2 * v20 * v19;
      }
      uint64_t v69 = 2 * v42;
      char v70 = 1;
      if (v42 >= 0x8000) {
        char v70 = 2;
      }
      CFIndex v46 = v69 << v70;
      float32x2_t v71 = (UInt8 *)malloc_type_malloc(v69 << v70, 0x62DAF02uLL);
      float32x4_t v48 = v71;
      if (v42 >= 0x8000) {
        char v44 = 4;
      }
      else {
        char v44 = 2;
      }
      int v72 = 0;
      uint64_t v73 = 0;
      if (v42 < 0x8000)
      {
        uint64_t v156 = 0;
        uint64_t v157 = &v156;
        uint64_t v158 = 0x2000000000;
        uint64_t v159 = v71;
        long long v74 = v71;
        do
        {
          uint64_t v75 = 0;
          ++v73;
          do
          {
            *(_WORD *)long long v74 = v72 + v75;
            __int16 v76 = v19 + v72 + v75;
            uint64_t v77 = v75 + 1;
            __int16 v78 = v72 + v75 + 1;
            *(_WORD *)(v157[3] + 2) = v78;
            *(_WORD *)(v157[3] + 4) = v78;
            *(_WORD *)(v157[3] + 6) = v76 + 2;
            long long v74 = (UInt8 *)(v157[3] + 8);
            v157[3] = (uint64_t)v74;
            uint64_t v75 = v77;
          }
          while (v19 != v77);
          LOWORD(v72) = v72 + v36;
        }
        while (v73 != v20);
        uint64_t v79 = 0;
        uint64_t v80 = v20;
        do
        {
          *(_WORD *)long long v74 = v79;
          v79 += v36;
          *(_WORD *)(v157[3] + 2) = v79;
          long long v74 = (UInt8 *)(v157[3] + 4);
          v157[3] = (uint64_t)v74;
          --v80;
        }
        while (v80);
        uint64_t v81 = v20 * (v19 + 1);
        uint64_t v82 = v19;
        do
        {
          *(_WORD *)long long v74 = v81;
          *(_WORD *)(v157[3] + 2) = v81 + 1;
          long long v74 = (UInt8 *)(v157[3] + 4);
          v157[3] = (uint64_t)v74;
          ++v81;
          --v82;
        }
        while (v82);
        if (v17 > 0.0)
        {
          v141[0] = MEMORY[0x1E4F143A8];
          v141[1] = 0x40000000;
          uint64_t v142 = sub_1B6549B28;
          uint64_t v143 = &unk_1E6144278;
          int v144 = &v156;
          uint64_t v145 = v18;
          sub_1B6549B28((uint64_t)v141, 0, v127, v19, 1);
          v142((uint64_t)v141, v19, v125, v20, v19 + 1);
          v142((uint64_t)v141, v129, v131, v19, -1);
          v142((uint64_t)v141, v135, v133, v20, ~v19);
          *(_WORD *)(v157[3] - 2) = v127;
        }
      }
      else
      {
        uint64_t v156 = 0;
        uint64_t v157 = &v156;
        uint64_t v158 = 0x2000000000;
        uint64_t v159 = v71;
        float32x4_t v84 = v71;
        do
        {
          uint64_t v85 = 0;
          ++v73;
          do
          {
            *(_DWORD *)float32x4_t v84 = v72 + v85;
            int v86 = v19 + v72 + v85;
            uint64_t v87 = v85 + 1;
            int v88 = v72 + v85 + 1;
            *(_DWORD *)(v157[3] + 4) = v88;
            *(_DWORD *)(v157[3] + _Block_object_dispose(&STACK[0x200], 8) = v88;
            *(_DWORD *)(v157[3] + 12) = v86 + 2;
            float32x4_t v84 = (UInt8 *)(v157[3] + 16);
            v157[3] = (uint64_t)v84;
            uint64_t v85 = v87;
          }
          while (v19 != v87);
          v72 += v19 + 1;
        }
        while (v73 != v20);
        int v89 = 0;
        uint64_t v90 = v20;
        do
        {
          *(_DWORD *)float32x4_t v84 = v89;
          v89 += v19 + 1;
          *(_DWORD *)(v157[3] + 4) = v89;
          float32x4_t v84 = (UInt8 *)(v157[3] + 8);
          v157[3] = (uint64_t)v84;
          --v90;
        }
        while (v90);
        int v91 = v20 + v20 * v19;
        uint64_t v92 = v19;
        do
        {
          *(_DWORD *)float32x4_t v84 = v91++;
          *(_DWORD *)(v157[3] + 4) = v91;
          float32x4_t v84 = (UInt8 *)(v157[3] + 8);
          v157[3] = (uint64_t)v84;
          --v92;
        }
        while (v92);
        if (v17 > 0.0)
        {
          v136[0] = MEMORY[0x1E4F143A8];
          v136[1] = 0x40000000;
          uint64_t v137 = sub_1B6549C1C;
          uint64_t v138 = &unk_1E61442A0;
          int v139 = &v156;
          uint64_t v140 = v18;
          sub_1B6549C1C((uint64_t)v136, 0, v127, v19, 1);
          v137((uint64_t)v136, v19, v125, v20, v19 + 1);
          v137((uint64_t)v136, v129, v131, v19, -1);
          v137((uint64_t)v136, v135, v133, v20, ~v19);
          *(_DWORD *)(v157[3] - 4) = v127;
        }
      }
      goto LABEL_82;
    }
    if (a1)
    {
      float32x4_t v48 = 0;
      LODWORD(v42) = 0;
      CFIndex v46 = 0;
      char v44 = 0;
      goto LABEL_83;
    }
    uint64_t v124 = v18 + v19 + v37;
    uint64_t v126 = (v20 + 1) * (v19 + 1);
    uint64_t v128 = v40 + v19;
    uint64_t v130 = v18 + v20 + v38;
    uint64_t v132 = v18 + v19 + v39;
    uint64_t v134 = v20 * (v19 + 1);
    uint64_t v41 = 4 * (v18 + v19 + v20);
    if (v17 <= 0.0) {
      uint64_t v41 = 0;
    }
    uint64_t v123 = v20 * v19;
    uint64_t v42 = v41 + 2 * v20 * v19;
    uint64_t v43 = 3 * v42;
    if (v42 >= 21846) {
      char v44 = 4;
    }
    else {
      char v44 = 2;
    }
    char v45 = 1;
    if (v42 >= 21846) {
      char v45 = 2;
    }
    CFIndex v46 = v43 << v45;
    float32x4_t v47 = (UInt8 *)malloc_type_malloc(v43 << v45, 0xDD91F8A0uLL);
    float32x4_t v48 = v47;
    if (v42 > 21845)
    {
      uint64_t v93 = 0;
      uint64_t v94 = 0;
      uint64_t v156 = 0;
      uint64_t v157 = &v156;
      uint64_t v158 = 0x2000000000;
      uint64_t v159 = v47;
      float32x4_t v95 = v47;
      do
      {
        uint64_t v96 = 0;
        ++v94;
        uint64_t v97 = v93;
        do
        {
          *(_DWORD *)float32x4_t v95 = v97;
          ++v96;
          uint64_t v98 = v97 + 1;
          *(_DWORD *)(v157[3] + 4) = v97 + 1;
          int v99 = v19 + v97;
          int v100 = v19 + v97 + 2;
          *(_DWORD *)(v157[3] + _Block_object_dispose(&STACK[0x200], 8) = v100;
          *(_DWORD *)(v157[3] + 12) = v97;
          float v101 = v157;
          float32x4_t v102 = (_DWORD *)v157[3];
          v102[4] = v100;
          v102[5] = v99 + 1;
          float32x4_t v95 = (UInt8 *)(v102 + 6);
          v101[3] = (uint64_t)(v102 + 6);
          uint64_t v97 = v98;
        }
        while (v19 != v96);
        v93 += (v19 + 1);
      }
      while (v94 != v20);
      if (v17 <= 0.0) {
        goto LABEL_82;
      }
      v146[0] = MEMORY[0x1E4F143A8];
      v146[1] = 0x40000000;
      char v122 = v44;
      int v147 = sub_1B6549A18;
      uint64_t v148 = &unk_1E6144250;
      uint64_t v149 = &v156;
      uint64_t v150 = v18;
      sub_1B6549A18((uint64_t)v146, 0, v126, v19, 1);
      *(_DWORD *)&v48[24 * v123 + 4] = sub_1B641D8A0((uint64_t)v21, v103, v104, v105, v106, v107, v108, v109) - 1;
      v147((uint64_t)v146, v19, v124, v20, v19 + 1);
      v147((uint64_t)v146, v128, v130, v19, -1);
      v147((uint64_t)v146, v134, v132, v20, ~v19);
    }
    else
    {
      __int16 v49 = 0;
      uint64_t v50 = 0;
      uint64_t v156 = 0;
      uint64_t v157 = &v156;
      uint64_t v158 = 0x2000000000;
      uint64_t v159 = v47;
      float32x2_t v51 = v47;
      do
      {
        uint64_t v52 = 0;
        ++v50;
        __int16 v53 = v19 + v49;
        do
        {
          __int16 v54 = v49 + v52;
          *(_WORD *)float32x2_t v51 = v49 + v52;
          *(_WORD *)(v157[3] + 2) = v49 + v52 + 1;
          __int16 v55 = v53 + v52;
          uint64_t v56 = v52 + 1;
          __int16 v57 = v53 + v52 + 2;
          *(_WORD *)(v157[3] + 4) = v57;
          *(_WORD *)(v157[3] + 6) = v54;
          *(_WORD *)(v157[3] + _Block_object_dispose(&STACK[0x200], 8) = v57;
          *(_WORD *)(v157[3] + 10) = v55 + 1;
          float32x2_t v51 = (UInt8 *)(v157[3] + 12);
          v157[3] = (uint64_t)v51;
          uint64_t v52 = v56;
        }
        while (v19 != v56);
        v49 += v36;
      }
      while (v50 != v20);
      if (v17 <= 0.0) {
        goto LABEL_82;
      }
      v151[0] = MEMORY[0x1E4F143A8];
      v151[1] = 0x40000000;
      char v122 = v44;
      uint64_t v152 = sub_1B6549918;
      uint64_t v153 = &unk_1E6144228;
      uint64_t v154 = &v156;
      uint64_t v155 = v18;
      sub_1B6549918((uint64_t)v151, 0, v126, v19, 1);
      *(_WORD *)&v48[12 * v123 + 2] = sub_1B641D8A0((uint64_t)v21, v58, v59, v60, v61, v62, v63, v64) - 1;
      v152((uint64_t)v151, v19, v124, v20, v19 + 1);
      v152((uint64_t)v151, v128, v130, v19, -1);
      v152((uint64_t)v151, v134, v132, v20, ~v19);
    }
    char v44 = v122;
LABEL_82:
    _Block_object_dispose(&v156, 8);
    goto LABEL_83;
  }
  uint64_t v65 = sub_1B641D8A0((uint64_t)v21, v29, v30, v31, v32, v33, v34, v35);
  uint64_t v42 = v65;
  char v66 = 1;
  if (v65 >= 0x10000) {
    char v66 = 2;
  }
  CFIndex v46 = v65 << v66;
  float32x2_t v67 = (UInt8 *)malloc_type_malloc(v65 << v66, 0x95274BC2uLL);
  float32x4_t v48 = v67;
  if (v42 >= 0x10000) {
    char v44 = 4;
  }
  else {
    char v44 = 2;
  }
  if (v42 < 0x10000)
  {
    if (v42 < 1)
    {
      char v44 = 2;
    }
    else
    {
      for (uint64_t i = 0; i != v42; ++i)
        *(_WORD *)&v67[2 * i] = i;
    }
  }
  else
  {
    for (uint64_t j = 0; j != v42; ++j)
      *(_DWORD *)&v67[4 * j] = j;
  }
LABEL_83:
  CFAllocatorRef v110 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v111 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v48, v46);
  sub_1B63D0E24((uint64_t)v22, v42, v111, v44);
  CFRelease(v111);
  free(v48);
  BYTE2(v156) = 0;
  LOWORD(v156) = 0;
  int v112 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef v113 = CFArrayCreate(v110, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
  CFArrayRef v114 = CFArrayCreate(v110, (const void **)&v160, 1, v112);
  uint64_t v120 = sub_1B63DC55C(v113, v114, (uint64_t)&v156, v115, v116, v117, v118, v119);
  CFRelease(v114);
  CFRelease(v113);
  if (values)
  {
    CFRelease(values);
    values = 0;
  }
  if (v162)
  {
    CFRelease(v162);
    CFTypeRef v162 = 0;
  }
  if (v163)
  {
    CFRelease(v163);
    CFTypeRef v163 = 0;
  }
  if (v160) {
    CFRelease(v160);
  }
  return v120;
}

uint64_t sub_1B65494B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v65 = 0;
  char v66 = &v65;
  uint64_t v67 = 0x2000000000;
  int v68 = 0;
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (a1 == 3) {
    uint64_t v18 = 2;
  }
  else {
    uint64_t v18 = 3;
  }
  float v19 = a5 + (float)(a7 * -2.0);
  float v37 = a6 + (float)(a7 * -2.0);
  if ((a3 & 0x8000000000000000) == 0)
  {
    uint64_t v20 = 0;
    float v21 = (float)a2;
    while (a2 < 0)
    {
LABEL_16:
      if (++v20 > a3) {
        goto LABEL_17;
      }
    }
    uint64_t v22 = 0;
    float v23 = (float)(v37 * (float)(int)v20) / (float)a3;
    *(float *)&unsigned int v24 = 1.0 - (float)((float)(v23 + a7) / a6);
    *(float *)&unsigned int v25 = a9 + v37 * -0.5 + v23;
    uint64_t v38 = v25;
    uint64_t v39 = v24;
    while (1)
    {
      if (a1 == 3)
      {
        *(float *)bytes = (float)((float)((float)(v19 * (float)(int)v22) / v21) + a7) / a5;
        uint64_t v27 = v39;
        goto LABEL_14;
      }
      if (a1 == 1) {
        break;
      }
      if (!a1)
      {
        float v26 = a8 + v19 * -0.5 + (float)((float)(v19 * (float)(int)v22) / v21);
        *(float *)bytes = v26;
        uint64_t v27 = v38;
LABEL_14:
        uint64_t v70 = v27;
      }
      ++*((_DWORD *)v66 + 6);
      CFDataAppendBytes(Mutable, bytes, (4 * v18));
      if (++v22 > a2) {
        goto LABEL_16;
      }
    }
    *(float *)bytes = 0.0;
    uint64_t v27 = 0x3F80000000000000;
    goto LABEL_14;
  }
LABEL_17:
  if (a7 > 0.0)
  {
    v51[0] = MEMORY[0x1E4F143A8];
    v51[1] = 0x40000000;
    uint64_t v52 = sub_1B6549D18;
    __int16 v53 = &unk_1E61442C8;
    char v64 = a1;
    float v57 = a8;
    float v58 = a7;
    float v28 = 1.57079633 / (double)a4;
    float v59 = v28;
    float v60 = a9;
    float v61 = a5;
    float v62 = a6;
    __int16 v54 = &v65;
    uint64_t v55 = a4;
    uint64_t v56 = Mutable;
    int v63 = v18;
    v40[0] = MEMORY[0x1E4F143A8];
    v40[1] = 0x40000000;
    uint64_t v41 = sub_1B6549EC4;
    uint64_t v42 = &unk_1E61442F0;
    char v50 = a1;
    float v45 = a8;
    float v46 = a9;
    float v47 = a5;
    float v48 = a6;
    uint64_t v43 = &v65;
    char v44 = Mutable;
    int v49 = v18;
    sub_1B6549D18((uint64_t)v51, -3.14159265, v19 * -0.5, v37 * -0.5);
    ((void (*)(void *, float, float, float, double))sub_1B6549EC4)(v40, v19 * -0.5, a6 * -0.5, v19, 0.0);
    v52((uint64_t)v51, -1.57079633, v19 * 0.5, v37 * -0.5);
    ((void (*)(void *, float, float, double, float))v41)(v40, a5 * 0.5, v37 * -0.5, 0.0, v37);
    v52((uint64_t)v51, 0.0, v19 * 0.5, v37 * 0.5);
    v41((uint64_t)v40, v19 * 0.5, a6 * 0.5, -v19, 0.0, (float)a2);
    v52((uint64_t)v51, 1.57079633, v19 * -0.5, v37 * 0.5);
    v41((uint64_t)v40, a5 * -0.5, v37 * 0.5, 0.0, -v37, (float)a3);
  }
  CFDataRef Copy = CFDataCreateCopy(v16, Mutable);
  uint64_t v33 = sub_1B641CF98(Copy, a1, *((int *)v66 + 6), v18, 1, v30, v31, v32);
  CFRelease(Mutable);
  CFRelease(Copy);
  _Block_object_dispose(&v65, 8);
  return v33;
}

uint64_t sub_1B6549918(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(result + 40);
  if (v5 >= 1)
  {
    uint64_t v6 = a3;
    uint64_t v7 = *(void *)(result + 40);
    do
    {
      **(_WORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 2) = v6 - 1;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v6;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 6;
      ++v6;
      --v7;
    }
    while (v7);
  }
  if (a4 >= 1)
  {
    uint64_t v8 = v5 + a3;
    do
    {
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 10) = a2;
      **(_WORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 2) = v8 - 1;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 6) = v8;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v8;
      a2 += a5;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + _Block_object_dispose(&STACK[0x200], 8) = a2;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 12;
      ++v8;
      --a4;
    }
    while (a4);
  }
  return result;
}

uint64_t sub_1B6549A18(uint64_t result, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = *(void *)(result + 40);
  if (v5 >= 1)
  {
    int v6 = a3;
    uint64_t v7 = *(void *)(result + 40);
    do
    {
      **(_DWORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v6 - 1;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + _Block_object_dispose(&STACK[0x200], 8) = v6;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 12;
      ++v6;
      --v7;
    }
    while (v7);
  }
  if (a4 >= 1)
  {
    int v8 = 0;
    int v9 = v5 + a3;
    do
    {
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 20) = a2 + v8;
      **(_DWORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2 + v8;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v9 - 1;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 12) = v9;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + _Block_object_dispose(&STACK[0x200], 8) = v9;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 16) = a5 + a2 + v8;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 24;
      v8 += a5;
      ++v9;
      --a4;
    }
    while (a4);
  }
  return result;
}

uint64_t sub_1B6549B28(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(result + 40);
  if (v5 >= 2)
  {
    uint64_t v6 = v5 - 1;
    uint64_t v7 = a3;
    do
    {
      **(_WORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v7;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 2) = v7;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 6) = v7 + 1;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 8;
      ++v7;
      --v6;
    }
    while (v6);
  }
  if ((a4 & 0x8000000000000000) == 0)
  {
    __int16 v8 = v5 + a3;
    uint64_t v9 = -1;
    do
    {
      **(_WORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v8 + v9;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 2) = v8 + v9;
      *(_WORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 6) = v8 + v9 + 1;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 8;
      ++v9;
      a2 += a5;
    }
    while (a4 != v9);
  }
  return result;
}

uint64_t sub_1B6549C1C(uint64_t result, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = *(void *)(result + 40);
  if (v5 >= 2)
  {
    uint64_t v6 = v5 - 1;
    int v7 = a3;
    do
    {
      **(_DWORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + _Block_object_dispose(&STACK[0x200], 8) = v7;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v7++;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 12) = v7;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 16;
      --v6;
    }
    while (v6);
  }
  if ((a4 & 0x8000000000000000) == 0)
  {
    int v8 = v5 + a3;
    uint64_t v9 = a4 + 1;
    int v10 = v8 - 1;
    do
    {
      **(_DWORD **)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + _Block_object_dispose(&STACK[0x200], 8) = v10;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 4) = v10;
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) + 12) = v8;
      *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) += 16;
      ++v10;
      a2 += a5;
      ++v8;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t sub_1B6549D0C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7)
{
  return sub_1B65489DC(a1, a2, a3, a4, a5, a6, a7, 0.0, 0.0);
}

void sub_1B6549D18(uint64_t a1, double a2, float a3, float a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(uint64_t *)(a1 + 40) >= 2)
  {
    double v8 = a3;
    double v9 = a4;
    uint64_t v10 = 1;
    while (1)
    {
      int v11 = *(char *)(a1 + 84);
      if (v11 == 3) {
        break;
      }
      if (v11 == 1)
      {
        *(_DWORD *)bytes = 0;
        uint64_t v17 = 0x3F80000000000000;
        goto LABEL_10;
      }
      if (!*(unsigned char *)(a1 + 84))
      {
        double v12 = (float)(*(float *)(a1 + 56) + a3);
        double v13 = *(float *)(a1 + 60);
        __double2 v14 = __sincos_stret((float)(*(float *)(a1 + 64) * (float)(int)v10) + a2);
        float v15 = v12 + v13 * v14.__cosval;
        *(float *)bytes = v15;
        double v16 = (float)(*(float *)(a1 + 68) + a4) + v13 * v14.__sinval;
        goto LABEL_9;
      }
LABEL_11:
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 48), bytes, 4 * *(int *)(a1 + 80));
      if (*(void *)(a1 + 40) <= ++v10) {
        return;
      }
    }
    double v18 = *(float *)(a1 + 60);
    __double2 v19 = __sincos_stret((float)(*(float *)(a1 + 64) * (float)(int)v10) + a2);
    float v20 = *(float *)(a1 + 76);
    float v21 = (v8 + v18 * v19.__cosval) / *(float *)(a1 + 72) + 0.5;
    *(float *)bytes = v21;
    double v16 = 1.0 - (v9 + v18 * v19.__sinval) / v20 + -0.5;
LABEL_9:
    *(float *)&unsigned int v22 = v16;
    uint64_t v17 = v22;
LABEL_10:
    uint64_t v24 = v17;
    goto LABEL_11;
  }
}

void sub_1B6549EC4(uint64_t a1, float a2, float a3, float a4, float a5, float a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  float v6 = a6 + 1.0;
  if ((float)(a6 + 1.0) > 0.0)
  {
    float v13 = 0.0;
    int v14 = 1;
    while (1)
    {
      int v15 = *(char *)(a1 + 68);
      if (v15 == 3) {
        break;
      }
      if (v15 == 1)
      {
        *(float *)bytes = 0.0;
        uint64_t v19 = 0x3F80000000000000;
        goto LABEL_10;
      }
      if (!*(unsigned char *)(a1 + 68))
      {
        float v16 = *(float *)(a1 + 52);
        *(float *)bytes = (float)((float)(v13 * a4) / a6) + (float)(*(float *)(a1 + 48) + a2);
        float v17 = v16 + a3;
        float v18 = (float)(v13 * a5) / a6;
        goto LABEL_9;
      }
LABEL_11:
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 40), bytes, 4 * *(int *)(a1 + 64));
      float v13 = (float)v14++;
      if (v6 <= v13) {
        return;
      }
    }
    float v20 = *(float *)(a1 + 60);
    *(float *)bytes = (float)((float)((float)((float)(v13 * a4) / a6) + a2) / *(float *)(a1 + 56)) + 0.5;
    float v18 = 1.0 - (float)((float)((float)((float)(v13 * a5) / a6) + a3) / v20);
    float v17 = -0.5;
LABEL_9:
    HIDWORD(v19) = 0;
    *(float *)&uint64_t v19 = v18 + v17;
LABEL_10:
    uint64_t v22 = v19;
    goto LABEL_11;
  }
}

void sub_1B654B07C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a1 + 40);
  if (v4 > 8) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = dword_1B6E520B8[v4];
  }
  uint64_t v6 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B6558DB4(v6, v5, v7, v8, v9, v10, v11, v12);
}

void sub_1B654B2B0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655D3A8(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654B438(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655D02C(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654B5C0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655D184(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654B748(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655D800(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654B8D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655CED4(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654BA60(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655D69C(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654BBE8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655DAB0(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654BD70(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655D958(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654BEEC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655D8D8(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654C068(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655D480(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654C1E4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655D104(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654C360(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655D25C(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654C4DC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655CFAC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654C658(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655CFAC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654C7D4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655DA30(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654C950(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655D54C(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654CACC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(unsigned int *)(a1 + 40);

  sub_1B655D61C(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654CC54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B655D774(v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1B654CDC8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(char *)(a1 + 40);

  sub_1B655D328(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B654D064(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v4 = *(_DWORD *)(a1 + 40);
  if (v4 == 2)
  {
    uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
    uint64_t v12 = 1;
LABEL_6:
    sub_1B655CDAC(v5, v12, v6, v7, v8, v9, v10, v11);
    return;
  }
  if (v4 != 1)
  {
    if (v4) {
      return;
    }
    uint64_t v5 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
    uint64_t v12 = 0;
    goto LABEL_6;
  }
  uint64_t v13 = objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B655CE70(v13, 1, v14, v15, v16, v17, v18, v19);
}

void sub_1B654DBCC()
{
  if (!qword_1E9DDB300) {
    qword_1E9DDB300 = sub_1B63C8D10(&qword_1E9DDB300);
  }
}

uint64_t sub_1B654DC10()
{
  if (qword_1E9DDB308 != -1) {
    dispatch_once(&qword_1E9DDB308, &unk_1F0FB5D48);
  }
  CFTypeID v0 = qword_1E9DDB300;

  return sub_1B63C8D44(v0, 0x40uLL);
}

uint64_t sub_1B654DC68()
{
  if (qword_1EB9952A8 != -1) {
    dispatch_once(&qword_1EB9952A8, &unk_1F0FB6648);
  }
  return qword_1EB9952B0;
}

void sub_1B654DCAC()
{
  if (!qword_1EB9952B0) {
    qword_1EB9952B0 = sub_1B63C8D10(&qword_1EB9952B0);
  }
}

uint64_t sub_1B654DCF0()
{
  if (qword_1EB9952A8 != -1) {
    dispatch_once(&qword_1EB9952A8, &unk_1F0FB6648);
  }
  CFTypeID v0 = qword_1EB9952B0;

  return sub_1B63C8D44(v0, 0xA0uLL);
}

uint64_t sub_1B654DD48(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1B6437DF4();
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(__int16 *)(*(void *)(a1 + 32) + 2 * a2);
  char v7 = sub_1B6432924(*(double (**)(float32x4_t *, float32x4_t *, double, uint64_t, uint64_t, uint64_t, int, float32x4_t *))(*(void *)(a1 + 48) + 8 * a2));
  uint64_t v11 = (const void *)sub_1B642525C(v5, v6, v7, 0, 0);
  uint64_t v12 = *(char **)(a1 + 64);
  if (a2 >= 1)
  {
    uint64_t v13 = *(char **)(a1 + 40);
    uint64_t v14 = a2;
    do
    {
      char v15 = *v13++;
      v12 += (v15 + 15) & 0xF0;
      --v14;
    }
    while (v14);
  }
  if (*(_DWORD *)(a1 + 16))
  {
    unint64_t v16 = 0;
    do
    {
      sub_1B6425394((uint64_t)v11, v16, v12, 0, 0, v8, v9, v10, *(float *)(*(void *)(a1 + 56) + 4 * v16), 0.0, 0.0, 0.0);
      v12 += *(unsigned int *)(a1 + 24);
      ++v16;
    }
    while (v16 < *(unsigned int *)(a1 + 16));
  }
  sub_1B6492CA0(v4, *(CFTypeRef *)(*(void *)(a1 + 72) + 8 * a2));
  sub_1B6437E54(v4, (uint64_t)v11, v17, v18, v19, v20, v21, v22);
  CFRelease(v11);
  return v4;
}

uint64_t sub_1B654DE60(uint64_t a1)
{
  uint64_t v2 = sub_1B6540EA4();
  sub_1B6493EA0(a1, v2, v3, v4, v5, v6, v7, v8);
  id v16 = sub_1B6583590(a1, v9, v10, v11, v12, v13, v14, v15);
  sub_1B65835F8(v2, v16, v17, v18, v19, v20, v21, v22);
  float v30 = sub_1B6492D84(a1, v23, v24, v25, v26, v27, v28, v29);
  uint64_t v31 = *(unsigned int *)(*(void *)(a1 + 168) + 20);
  if (v31)
  {
    float v32 = v30;
    for (uint64_t i = 0; i != v31; ++i)
    {
      uint64_t v34 = (void *)sub_1B654DD48(*(void *)(a1 + 168), i);
      sub_1B6492D2C((uint64_t)v34, v32, v35, v36, v37, v38, v39, v40, v41);
      sub_1B6540F24(v2, v34, v42, v43, v44, v45, v46, v47);
      CFRelease(v34);
    }
  }
  return v2;
}

uint64_t sub_1B654DF18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v114 = 0;
  if (!sub_1B654E498(a1, &v114, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  unsigned int v16 = sub_1B654E604(a1, v9, v10, v11, v12, v13, v14, v15);
  if (!v114 && v16 < 3) {
    return 0;
  }
  unsigned int v18 = v16;
  if (qword_1EB9952A8 != -1) {
    dispatch_once(&qword_1EB9952A8, &unk_1F0FB6648);
  }
  uint64_t v19 = sub_1B63C8D44(qword_1EB9952B0, 0xA0uLL);
  id v27 = sub_1B6583590(a1, v20, v21, v22, v23, v24, v25, v26);
  sub_1B65835F8(v19, v27, v28, v29, v30, v31, v32, v33);
  *(void *)(v19 + 16_Block_object_dispose(&STACK[0x200], 8) = sub_1B654DC10();
  sub_1B6492BF4(v19);
  uint64_t v111 = v19;
  uint64_t v34 = *(void *)(v19 + 168);
  *(_DWORD *)(v34 + 20) = v18;
  *(void *)(v34 + 32) = malloc_type_malloc(2 * v18, 0x1000040BDFB0063uLL);
  *(void *)(v34 + 40) = malloc_type_malloc(v18, 0x100004077774924uLL);
  *(void *)(v34 + 4_Block_object_dispose(&STACK[0x200], 8) = malloc_type_malloc(8 * v18, 0x80040B8603338uLL);
  *(void *)(v34 + 72) = malloc_type_malloc(8 * v18, 0x6004044C4A2DFuLL);
  uint64_t v35 = (uint64_t *)malloc_type_malloc(8 * *(unsigned int *)(v34 + 20), 0x2004093837F09uLL);
  uint64_t v113 = 0;
  sub_1B654E690(a1, (uint64_t)v35, &v113, v36, v37, v38, v39, v40);
  if (v18)
  {
    uint64_t v41 = 0;
    for (uint64_t i = 0; i != v18; v41 += (*(unsigned char *)(*(void *)(v34 + 40) + i++) + 15) & 0xF0)
    {
      uint64_t v43 = v35[i];
      *(void *)(*(void *)(v34 + 72) + 8 * i) = sub_1B6492CF4(v43);
      CFRetain(*(CFTypeRef *)(*(void *)(v34 + 72) + 8 * i));
      uint64_t v44 = *(void *)(v43 + 168);
      uint64_t v45 = *(void *)(v34 + 40);
      *(_WORD *)(*(void *)(v34 + 32) + 2 * i) = *(_WORD *)(v44 + 28);
      *(unsigned char *)(v45 + i) = *(unsigned char *)(v44 + 30);
      *(void *)(*(void *)(v34 + 48) + 8 * i) = sub_1B643079C(*(__int16 *)(*(void *)(v43 + 168) + 28), *(char *)(*(void *)(v43 + 168) + 99), 1, 0);
    }
    *(_DWORD *)(v34 + 24) = v41;
    __int16 v53 = malloc_type_malloc(v18, 0x100004077774924uLL);
    uint64_t v54 = 0;
    while (1)
    {
      uint64_t v55 = sub_1B6437F0C(v35[v54], v46, v47, v48, v49, v50, v51, v52);
      if (!v55) {
        break;
      }
      uint64_t v56 = v55;
      if (sub_1B64263A4(v55))
      {
        BOOL v57 = 1;
      }
      else
      {
        if (!sub_1B64263E8(v56)) {
          break;
        }
        BOOL v57 = sub_1B6425CD0(v56, v46, v47, v48, v49, v50, v51, v52) != 0;
      }
LABEL_19:
      v53[v54++] = v57;
      if (v18 == v54) {
        goto LABEL_23;
      }
    }
    BOOL v57 = 0;
    goto LABEL_19;
  }
  *(_DWORD *)(v34 + 24) = 0;
  __int16 v53 = malloc_type_malloc(0, 0x100004077774924uLL);
  uint64_t v41 = 0;
LABEL_23:
  uint64_t v112 = a1;
  float v66 = sub_1B6492D84(a1, v46, v47, v48, v49, v50, v51, v52);
  double v67 = v66;
  if (v66 < 0.0) {
    goto LABEL_38;
  }
  unsigned int v68 = 0;
  double v69 = 0.0;
  do
  {
    double v70 = v66;
    if (v18)
    {
      uint64_t v71 = v18;
      int v72 = v35;
      double v70 = v66;
      do
      {
        double v73 = v69 + 0.0416666667;
        if (!v53) {
          sub_1B654E774(*v72, v69, v67, v59, v60, v61, v62, v63, v64, v65);
        }
        if (v73 < v70) {
          double v70 = v73;
        }
        ++v72;
        --v71;
      }
      while (v71);
    }
    if (v70 >= v69 + 0.00833333333) {
      double v69 = v70;
    }
    else {
      double v69 = v69 + 0.00833333333;
    }
    ++v68;
  }
  while (v69 <= v67);
  if (v68)
  {
    char v74 = 0;
  }
  else
  {
LABEL_38:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v60, v61, v62, v63, v64, v65, (uint64_t)"keyCount");
    unsigned int v68 = 0;
    char v74 = 1;
  }
  *(_DWORD *)(v34 + 16) = v68;
  uint64_t v75 = v68;
  *(void *)(v34 + 56) = malloc_type_malloc(4 * v68, 0x100004052888210uLL);
  if (v66 >= 0.0)
  {
    char v110 = v74;
    uint64_t v83 = 0;
    double v84 = 0.0;
    do
    {
      double v85 = v66;
      if (v18)
      {
        uint64_t v86 = v18;
        uint64_t v87 = v35;
        double v85 = v66;
        do
        {
          double v88 = v84 + 0.0416666667;
          if (!v53) {
            sub_1B654E774(*v87, v84, v67, v76, v77, v78, v79, v80, v81, v82);
          }
          if (v88 < v85) {
            double v85 = v88;
          }
          ++v87;
          --v86;
        }
        while (v86);
      }
      if (v85 < v84 + 0.00833333333) {
        double v85 = v84 + 0.00833333333;
      }
      float v89 = v84;
      *(float *)(*(void *)(v34 + 56) + 4 * v83++) = v89;
      double v84 = v85;
    }
    while (v85 <= v67);
    char v74 = v110;
  }
  else
  {
    LODWORD(v83) = 0;
  }
  if (v83 != v75) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. bad count", v77, v78, v79, v80, v81, v82, (uint64_t)"keyIndex == (int)keyCount");
  }
  uint64_t v90 = v41 * v75;
  int v91 = (char *)malloc_type_malloc(v41 * v75, 0x5B32AAF7uLL);
  uint64_t v98 = (uint64_t)v91;
  *(void *)(v34 + 64) = v91;
  if (v74)
  {
    int v99 = v91;
  }
  else
  {
    uint64_t v100 = 0;
    do
    {
      if (v18)
      {
        uint64_t v101 = 0;
        double v102 = *(float *)(*(void *)(v34 + 56) + 4 * v100);
        do
        {
          sub_1B6425560(*(void *)(v35[v101] + 168), 0, 0, v98, v94, v95, v96, v97, v102);
          v98 += (*(unsigned char *)(*(void *)(v34 + 40) + v101++) + 15) & 0xF0;
        }
        while (v18 != v101);
      }
      ++v100;
    }
    while (v100 != v75);
    int v99 = *(char **)(v34 + 64);
  }
  if ((char *)v98 != &v99[v90]) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationClusterCreateWithAnimationGroup out of bounds", v92, v93, v94, v95, v96, v97, (uint64_t)"valueWrt == kf->_values + (totalValueSize * keyCount)");
  }
  free(v35);
  uint64_t v58 = v111;
  *(float *)(v111 + 72) = v66;
  sub_1B6493EA0(v112, v111, v103, v104, v105, v106, v107, v108);
  return v58;
}

BOOL sub_1B654E498(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a1 + 84) & 6) != 0) {
    return 0;
  }
  CFIndex v10 = sub_1B6541028(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B6492D84(a1, v11, v12, v13, v14, v15, v16, v17) == 0.0) {
    return 0;
  }
  if (v10 < 1) {
    return 1;
  }
  uint64_t v26 = sub_1B6541084(a1, 0, v18, v19, v20, v21, v22, v23);
  if ((v26[42] & 6) != 0)
  {
    return 0;
  }
  else
  {
    uint64_t v34 = v26;
    BOOL v24 = 0;
    CFIndex v35 = 1;
    while (sub_1B64396D4((uint64_t)v34, v27, v28, v29, v30, v31, v32, v33) == 0.0
         && sub_1B64933C0((uint64_t)v34, v36, v37, v38, v39, v40, v41, v42) == 0.0
         && sub_1B6492D84((uint64_t)v34, v43, v44, v45, v46, v47, v48, v49) != 0.0)
    {
      if (sub_1B6492CFC(v34))
      {
        if ((sub_1B654E498(v34, a2) & 1) == 0) {
          return v24;
        }
      }
      else
      {
        CFTypeID v56 = CFGetTypeID(v34);
        if (v56 != sub_1B6437D6C()) {
          return v24;
        }
        uint64_t v64 = sub_1B6437F0C((uint64_t)v34, v57, v58, v59, v60, v61, v62, v63);
        if (sub_1B6425C1C(v64, v65, v66, v67, v68, v69, v70, v71)) {
          return v24;
        }
        if (sub_1B64263E8(v64) && sub_1B6425CD0(v64, v72, v50, v51, v52, v53, v54, v55)) {
          *a2 = 1;
        }
      }
      BOOL v24 = v35 >= v10;
      if (v10 != v35)
      {
        uint64_t v34 = sub_1B6541084(a1, v35++, v50, v51, v52, v53, v54, v55);
        if ((v34[42] & 6) == 0) {
          continue;
        }
      }
      return v24;
    }
  }
  return v24;
}

uint64_t sub_1B654E604(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v9 = sub_1B6541028(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v9 < 1) {
    return 0;
  }
  CFIndex v16 = v9;
  CFIndex v17 = 0;
  LODWORD(v1_Block_object_dispose(&STACK[0x200], 8) = 0;
  do
  {
    uint64_t v19 = sub_1B6541084(a1, v17, v10, v11, v12, v13, v14, v15);
    if (sub_1B6492CFC(v19)) {
      int v20 = sub_1B654E604(v19);
    }
    else {
      int v20 = 1;
    }
    uint64_t v18 = (v20 + v18);
    ++v17;
  }
  while (v16 != v17);
  return v18;
}

void sub_1B654E690(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v11 = sub_1B6541028(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (v11 >= 1)
  {
    CFIndex v18 = v11;
    for (CFIndex i = 0; i != v18; ++i)
    {
      int v20 = sub_1B6541084(a1, i, v12, v13, v14, v15, v16, v17);
      if (sub_1B6492CFC(v20))
      {
        sub_1B654E690(v20, a2, a3);
      }
      else
      {
        CFTypeID v21 = CFGetTypeID(v20);
        if (v21 != sub_1B6437D6C()) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected animation class", v12, v13, v14, v15, v16, v17, (uint64_t)"CFGetTypeID(animation) == CFXKeyframedAnimationGetTypeID()");
        }
        uint64_t v22 = *a3;
        *(void *)(a2 + 8 * *a3) = v20;
        *a3 = v22 + 1;
      }
    }
  }
}

void sub_1B654E774(uint64_t a1, double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10 = *(void *)(a1 + 168);
  double v11 = a2 / a3 * *(double *)(v10 + 16);
  float v12 = v11 + 0.00001;
  float v21 = v12;
  unsigned int v13 = sub_1B642511C(*(float **)(v10 + 40), *(_DWORD *)(v10 + 24), &v21, 0, a7, a8, a9, a10);
  if (v13 < *(_DWORD *)(v10 + 24) - 1)
  {
    float v20 = v11;
    if (*(float *)(*(void *)(v10 + 40) + 4 * (v13 + 1)) < v20) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. _getNextKeyTime twice the same keytime?", v14, v15, v16, v17, v18, v19, (uint64_t)"kf->_keytimes[index+1] >= (float)time");
    }
  }
}

CFTypeRef sub_1B654E844(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dest");
LABEL_3:
  CFTypeRef result = *(CFTypeRef *)(a1 + 168);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(void *)(a2 + 16_Block_object_dispose(&STACK[0x200], 8) = result;
  return result;
}

__CFArray *sub_1B654E8C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 168);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(v1 + 20);
  if (!v2) {
    return 0;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, *(unsigned int *)(v1 + 20), MEMORY[0x1E4F1D510]);
  uint64_t v5 = 0;
  uint64_t v6 = 8 * v2;
  do
  {
    CFArrayRef v7 = sub_1B63CC828(*(const __CFArray **)(*(void *)(*(void *)(a1 + 168) + 72) + v5));
    if (v7)
    {
      CFArrayRef v8 = v7;
      CFArrayAppendValue(Mutable, v7);
      CFRelease(v8);
    }
    v5 += 8;
  }
  while (v6 != v5);
  return Mutable;
}

void sub_1B654E970(uint64_t a1)
{
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 64));
  unint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(const void **)(*(void *)(a1 + 72) + 8 * i);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(*(void *)(a1 + 72) + 8 * i) = 0;
        unint64_t v2 = *(unsigned int *)(a1 + 20);
      }
    }
  }
  uint64_t v5 = *(void **)(a1 + 72);

  free(v5);
}

CFStringRef sub_1B654EA00(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationClusterKeyframes %p>", a1);
}

CFStringRef sub_1B654EA40(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationClusterKeyframes %p>", a1);
}

void sub_1B654EA84(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B6492B90(a1, a2, a3, a4, a5, a6, a7, a8);
  CFIndex v9 = (const void *)a1[21];
  if (v9)
  {
    CFRelease(v9);
    a1[21] = 0;
  }
}

CFStringRef sub_1B654EAB8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationCluster %p>", a1);
}

CFStringRef sub_1B654EAF8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationCluster %p>", a1);
}

void sub_1B654ED10(uint64_t a1)
{
  Weaunint64_t k = objc_loadWeak((id *)(a1 + 32));

  sub_1B654ED3C((uint64_t)Weak, v2, v3, v4);
}

void sub_1B654ED3C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (a1
    && (objc_msgSend_isPaused((void *)a1, a2, a3, a4) & 1) == 0
    && (objc_msgSend__isInvalidated((void *)a1, v5, v6, v7) & 1) == 0)
  {
    if ((int)atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 1u) < 4)
    {
      CFArrayRef v8 = (void *)MEMORY[0x1BA9B76E0]();
      if ((objc_msgSend_isPaused((void *)a1, v9, v10, v11) & 1) == 0 && !*(unsigned char *)(a1 + 57))
      {
        double v12 = COERCE_DOUBLE(atomic_load((unint64_t *)(a1 + 16)));
        (*(void (**)(double))(*(void *)(a1 + 32) + 16))(v12);
      }
      atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 0xFFFFFFFF);
    }
    else
    {
      atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 0xFFFFFFFF);
    }
  }
}

void sub_1B654EF28(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B654F058(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__isInvalidated(*(void **)(a1 + 32), a2, a3, a4);
  if ((result & 1) == 0)
  {
    CFArrayRef v8 = *(void **)(a1 + 32);
    return objc_msgSend_setPaused_(v8, v6, 0, v7);
  }
  return result;
}

void sub_1B654F1F0(uint64_t a1, double a2)
{
  if (a1)
  {
    id v4 = (id)a1;
    objc_msgSend_lock(*(void **)(a1 + 80), v5, v6, v7);
    CFArrayRef v8 = sub_1B63F2EE0();
    if (os_signpost_enabled(v8))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "DisplayLink", "", buf, 2u);
    }
    if ((objc_msgSend_isPaused((void *)a1, v9, v10, v11) & 1) == 0
      && (objc_msgSend__isInvalidated((void *)a1, v12, v13, v14) & 1) == 0)
    {
      if ((int)atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 1u) < 4)
      {
        uint64_t v15 = (void *)MEMORY[0x1BA9B76E0]();
        uint64_t v16 = *(NSObject **)(a1 + 48);
        v17[0] = MEMORY[0x1E4F143A8];
        v17[1] = 3221225472;
        float32x4_t v17[2] = sub_1B654F330;
        _OWORD v17[3] = &unk_1E6143468;
        v17[4] = a1;
        *(double *)&v17[5] = a2;
        dispatch_sync(v16, v17);
      }
      else
      {
        atomic_fetch_add((atomic_uint *volatile)(a1 + 88), 0xFFFFFFFF);
      }
    }
    objc_msgSend_unlock(*(void **)(a1 + 80), v12, v13, v14);
  }
}

uint64_t sub_1B654F330(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_isPaused(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v6 = *(void *)(a1 + 32);
  if ((result & 1) == 0 && !*(unsigned char *)(v6 + 57))
  {
    uint64_t result = (*(uint64_t (**)(double))(*(void *)(v6 + 32) + 16))(*(double *)(a1 + 40));
    uint64_t v6 = *(void *)(a1 + 32);
  }
  atomic_fetch_add((atomic_uint *volatile)(v6 + 88), 0xFFFFFFFF);
  return result;
}

void *sub_1B654F444(int *a1, uint64_t a2, uint64_t a3)
{
  double v5 = 0.0;
  double v6 = 1.17549435e-38;
  double v7 = 3.40282347e38;
  for (uint64_t i = 88; i != 208; i += 2)
  {
    double v9 = *(double *)&a1[i];
    if (v7 >= v9) {
      double v7 = *(double *)&a1[i];
    }
    if (v6 < v9) {
      double v6 = *(double *)&a1[i];
    }
    double v5 = v5 + v9;
  }
  *((double *)a1 + 42) = v7;
  *((double *)a1 + 43) = v6;
  *((double *)a1 + 41) = v5 / 60.0;
  unsigned int v50 = a1[2];
  unsigned int v51 = a1[1];
  unsigned int v10 = a1[4];
  int v52 = a1[3];
  unsigned int v53 = *a1;
  unsigned int v11 = a1[6];
  unsigned int v12 = a1[7];
  unsigned int v13 = a1[9];
  unsigned int v14 = a1[10];
  unsigned int v15 = a1[11];
  unsigned int v16 = a1[12];
  unsigned int v46 = a1[5];
  unsigned int v47 = a1[13];
  unsigned int v48 = a1[14];
  int v49 = a1[8];
  long long v17 = *(_OWORD *)(a1 + 15);
  long long v18 = *(_OWORD *)(a1 + 19);
  int v65 = a1[23];
  long long v63 = v17;
  long long v64 = v18;
  float64x2_t v43 = *((float64x2_t *)a1 + 7);
  float64x2_t v44 = *((float64x2_t *)a1 + 6);
  float64x2_t v45 = *((float64x2_t *)a1 + 9);
  float64x2_t v40 = *((float64x2_t *)a1 + 10);
  float64x2_t v41 = *((float64x2_t *)a1 + 11);
  float64x2_t v42 = *((float64x2_t *)a1 + 8);
  double v19 = *((double *)a1 + 24);
  long long v20 = *(_OWORD *)(a1 + 50);
  long long v21 = *(_OWORD *)(a1 + 54);
  long long v22 = *(_OWORD *)(a1 + 62);
  long long v57 = *(_OWORD *)(a1 + 58);
  long long v58 = v22;
  long long v55 = v20;
  long long v56 = v21;
  long long v23 = *(_OWORD *)(a1 + 66);
  long long v24 = *(_OWORD *)(a1 + 70);
  long long v25 = *(_OWORD *)(a1 + 74);
  uint64_t v62 = *((void *)a1 + 39);
  long long v60 = v24;
  long long v61 = v25;
  long long v59 = v23;
  uint64_t result = memcpy(__dst, a1 + 80, sizeof(__dst));
  if (v10 <= 1) {
    unsigned int v27 = 1;
  }
  else {
    unsigned int v27 = v10;
  }
  if (a2)
  {
    uint64_t v62 = *(void *)(a2 + 312);
    long long v28 = *(_OWORD *)(a2 + 232);
    long long v56 = *(_OWORD *)(a2 + 216);
    long long v57 = v28;
    long long v29 = *(_OWORD *)(a2 + 264);
    long long v30 = *(_OWORD *)(a2 + 280);
    long long v58 = *(_OWORD *)(a2 + 248);
    long long v59 = v29;
    long long v31 = *(_OWORD *)(a2 + 296);
    long long v60 = v30;
    long long v61 = v31;
  }
  if (a3)
  {
    float64x2_t v32 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v27), 0);
    long long v33 = v63;
    *(_OWORD *)(a3 + 76) = v64;
    *(_DWORD *)a3 = v53 / v27;
    *(_DWORD *)(a3 + 4) = v51 / v27;
    *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x200], 8) = v50 / v27;
    *(_DWORD *)(a3 + 12) = v52;
    *(_DWORD *)(a3 + 16) = v10;
    *(_DWORD *)(a3 + 20) = v46 / v27;
    *(_DWORD *)(a3 + 24) = v11 / v27;
    *(_DWORD *)(a3 + 2_Block_object_dispose(&STACK[0x200], 8) = v12 / v27;
    *(_DWORD *)(a3 + 32) = v49;
    *(_DWORD *)(a3 + 36) = v13 / v27;
    *(_DWORD *)(a3 + 40) = v14 / v27;
    *(_DWORD *)(a3 + 44) = v15 / v27;
    *(_DWORD *)(a3 + 4_Block_object_dispose(&STACK[0x200], 8) = v16 / v27;
    *(_DWORD *)(a3 + 52) = v47 / v27;
    *(_DWORD *)(a3 + 56) = v48 / v27;
    *(_DWORD *)(a3 + 92) = v65;
    *(_OWORD *)(a3 + 60) = v33;
    *(float64x2_t *)(a3 + 96) = vdivq_f64(v44, v32);
    *(float64x2_t *)(a3 + 112) = vdivq_f64(v43, v32);
    *(float64x2_t *)(a3 + 12_Block_object_dispose(&STACK[0x200], 8) = vdivq_f64(v42, v32);
    *(float64x2_t *)(a3 + 144) = vdivq_f64(v45, v32);
    *(float64x2_t *)(a3 + 160) = vdivq_f64(v40, v32);
    *(float64x2_t *)(a3 + 176) = vdivq_f64(v41, v32);
    *(double *)(a3 + 192) = v19 / (double)v27;
    long long v34 = v55;
    long long v35 = v56;
    long long v36 = v57;
    *(_OWORD *)(a3 + 24_Block_object_dispose(&STACK[0x200], 8) = v58;
    *(_OWORD *)(a3 + 232) = v36;
    *(_OWORD *)(a3 + 216) = v35;
    *(_OWORD *)(a3 + 200) = v34;
    long long v37 = v59;
    long long v38 = v60;
    long long v39 = v61;
    *(void *)(a3 + 312) = v62;
    *(_OWORD *)(a3 + 280) = v38;
    *(_OWORD *)(a3 + 296) = v39;
    *(_OWORD *)(a3 + 264) = v37;
    return memcpy((void *)(a3 + 320), __dst, 0x218uLL);
  }
  return result;
}

void sub_1B654F6EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"stats");
  }
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(&STACK[0x200], 8) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x200], 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(CFTimeInterval *)(a1 + 840) = CACurrentMediaTime();
}

CFTimeInterval sub_1B654F75C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"stats");
  }
  CFTimeInterval result = CACurrentMediaTime();
  CFTimeInterval v10 = result - *(double *)(a1 + 848);
  *(CFTimeInterval *)(a1 + 96) = result - *(double *)(a1 + 840);
  *(CFTimeInterval *)(a1 + 84_Block_object_dispose(&STACK[0x200], 8) = result;
  uint64_t v11 = *(unsigned int *)(a1 + 832);
  *(CFTimeInterval *)(a1 + 8 * v11 + 352) = v10;
  *(_DWORD *)(a1 + 832) = ((int)v11 + 1) % 0x3Cu;
  ++*(_DWORD *)(a1 + 16);
  return result;
}

uint64_t sub_1B654F7F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v77 = a2;
  *((void *)&v77 + 1) = a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB520, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB520))
  {
    byte_1E9DDB518 = 1;
    __cxa_guard_release(&qword_1E9DDB520);
  }
  if (byte_1E9DDB518) {
    uint64_t v12 = 0x39077B4FC07D180;
  }
  else {
    uint64_t v12 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, a5, v12, a6);
  *(void *)a1 = &unk_1F0FB3EC0;
  uint64_t v72 = (uint64_t *)(a1 + 384);
  *(_OWORD *)(a1 + 384) = v77;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 40_Block_object_dispose(&STACK[0x200], 8) = a1 + 416;
  *(void *)(a1 + 424) = 0;
  uint64_t v76 = *(void *)(a1 + 368);
  uint64_t v20 = sub_1B644558C(v76, v13, v14, v15, v16, v17, v18, v19);
  uint64_t v28 = sub_1B64B28B0(v20, v21, v22, v23, v24, v25, v26, v27);
  uint64_t v71 = sub_1B63C4650(v28);
  unsigned int v29 = sub_1B63C465C(v28);
  unsigned int v30 = sub_1B63C3AD8(v28);
  double v73 = sub_1B63C3AC8(v28);
  unsigned int v31 = *(_DWORD *)(a1 + 404);
  if (v30 > v31) {
    sub_1B63C8928((uint64_t)v72, v30 - v31, 1);
  }
  if (v29)
  {
    uint64_t v32 = 0;
    uint64_t v69 = v29;
    uint64_t v70 = v28;
    do
    {
      long long v33 = *(const void **)(v71 + 8 * v32);
      if (sub_1B63C4590(v28, v33))
      {
        CFDictionaryRef v41 = sub_1B649F640((uint64_t)v33, v34, v35, v36, v37, v38, v39, v40);
        int v49 = (float32x2_t *)sub_1B6498928((uint64_t)v41, v42, v43, v44, v45, v46, v47, v48);
        unsigned int v57 = sub_1B6498974((uint64_t)v41, v50, v51, v52, v53, v54, v55, v56);
        if (v57)
        {
          uint64_t v58 = v57;
          do
          {
            *(float32x2_t *)&long long v59 = vmul_f32(*(float32x2_t *)&v73, *v49);
            *((float32x2_t *)&v59 + 1) = vmul_f32(*(float32x2_t *)&v73, (float32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v49->f32, *(int8x16_t *)v49->f32, 8uLL));
            long long v79 = (unint64_t)v33;
            *(void *)&long long v80 = 0;
            long long v81 = v59;
            LOBYTE(v82) = 1;
            long long v83 = xmmword_1B6E4FC80;
            char v84 = *(unsigned char *)(a1 + 376);
            char v85 = 2;
            uint64_t v86 = 3;
            int v87 = 1;
            __int16 v88 = 1;
            uint64_t v60 = sub_1B63F9384(v77, *((uint64_t *)&v77 + 1), (uint64_t *)&v77, &v76, &v79);
            uint64_t v75 = 0;
            long long v61 = v77;
            *(void *)&long long v79 = 0;
            WORD4(v79) = 0;
            BYTE10(v79) = *(unsigned char *)(a1 + 377);
            *(void *)&long long v80 = 8;
            WORD4(v80) = 0;
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB520, memory_order_acquire) & 1) == 0)
            {
              long long v68 = v61;
              int v65 = __cxa_guard_acquire(&qword_1E9DDB520);
              long long v61 = v68;
              if (v65)
              {
                byte_1E9DDB518 = 1;
                __cxa_guard_release(&qword_1E9DDB520);
                long long v61 = v68;
              }
            }
            uint64_t v62 = 0x39077B4FC07D180;
            if (!byte_1E9DDB518) {
              uint64_t v62 = 0;
            }
            *(void *)&long long v81 = v62;
            long long v78 = v61;
            uint64_t v63 = sub_1B63C8330(&v78, 0x40u, 8u);
            sub_1B6460520(v63, v76, (uint64_t)&v79, v60);
            uint64_t v75 = v64;
            sub_1B63C88CC(v72, &v75);
            v49 += 2;
            --v58;
          }
          while (v58);
        }
      }
      ++v32;
      uint64_t v28 = v70;
    }
    while (v32 != v69);
  }
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v79 = 0u;
  RGTextureDescriptorMakeDefault((uint64_t)&v79);
  LOWORD(v79) = (int)*(float *)&v73;
  WORD1(v79) = (int)*((float *)&v73 + 1);
  long long v80 = xmmword_1B6E52140;
  v74[2] = v81;
  v74[3] = v82;
  v74[4] = v83;
  v74[0] = v79;
  v74[1] = xmmword_1B6E52140;
  uint64_t v66 = sub_1B63C7D8C(a4, (uint64_t)"SHADOW_MAP_ATLAS", (uint64_t)v74);
  *(void *)(a1 + 424) = v66;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v66, 0x200000002, -1);
  return a1;
}

void sub_1B654FBBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  sub_1B65504F0(a18);
  CFX::RG::Pass::~Pass(v18);
  _Unwind_Resume(a1);
}

void sub_1B654FC0C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = sub_1B6447B50(*(void *)(a1 + 368), a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Shadow", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm", 93, v6 | 0x300000000);
  uint64_t v14 = sub_1B644558C(*(void *)(a1 + 368), v7, v8, v9, v10, v11, v12, v13);
  uint64_t v22 = sub_1B64B28B0(v14, v15, v16, v17, v18, v19, v20, v21);
  sub_1B63C4580(v22, *(void *)(a1 + 424));
  uint64_t v122 = sub_1B63C4650(v22);
  uint64_t v119 = a2;
  unsigned int v30 = sub_1B63C465C(v22);
  uint64_t v31 = *(unsigned int *)(a1 + 400);
  if (v31)
  {
    uint64_t v32 = *(uint64_t **)(a1 + 408);
    uint64_t v33 = 8 * v31;
    do
    {
      uint64_t v34 = (__n128 *)sub_1B643D7FC(*v32);
      sub_1B65A8594(v34, v35, v36, v37);
      sub_1B65A88F8((uint64_t)v34, v38, v39, v40, v41, v42, v43, v44);
      ++v32;
      v33 -= 8;
    }
    while (v33);
  }
  uint64_t v120 = v14;
  if (v30)
  {
    uint64_t v45 = 0;
    unsigned int v46 = 0;
    uint64_t v121 = v30;
    long long v118 = xmmword_1B6E4F370;
    do
    {
      CFDictionaryRef v47 = sub_1B649F640(*(void *)(v122 + 8 * v45), v23, v24, v25, v26, v27, v28, v29);
      unsigned int v123 = sub_1B6498974((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54);
      uint64_t v55 = sub_1B643D7FC(*(void *)(*(void *)(a1 + 408) + 8 * v46));
      int v63 = sub_1B6496680((uint64_t)v47, v56, v57, v58, v59, v60, v61, v62);
      uint64_t v64 = (_OWORD *)sub_1B6451064(v55);
      int v65 = (void *)sub_1B6450668(v55);
      if (v63 == 1) {
        uint64_t v67 = 0;
      }
      else {
        uint64_t v67 = (uint64_t)(v64 + 449);
      }
      sub_1B63C41A0(v22, v65, v67, (uint64_t)(v64 + 577), 0, 0, 0, v66, v118);
      if (sub_1B6496680((uint64_t)v47, v68, v69, v70, v71, v72, v73, v74) == 2) {
        sub_1B65119E8(v120, v47, (uint64_t)(v64 + 449), (uint64_t)(v64 + 577), v78, v79, v80, v81);
      }
      if (v63 == 1 && v123)
      {
        uint64_t v82 = 0;
        float32x4_t v126 = *((float32x4_t *)v64 + 450);
        float32x4_t v127 = *((float32x4_t *)v64 + 449);
        float32x4_t v124 = *((float32x4_t *)v64 + 452);
        float32x4_t v125 = *((float32x4_t *)v64 + 451);
        do
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)qword_1E9DDB320, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(qword_1E9DDB320))
          {
            xmmword_1E9DDB310 = xmmword_1B6E4F300;
            __cxa_guard_release(qword_1E9DDB320);
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)qword_1E9DDB340, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(qword_1E9DDB340))
          {
            xmmword_1E9DDB330 = xmmword_1B6E4F320;
            __cxa_guard_release(qword_1E9DDB340);
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)qword_1E9DDB360, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(qword_1E9DDB360))
          {
            xmmword_1E9DDB350 = xmmword_1B6E4F2E0;
            __cxa_guard_release(qword_1E9DDB360);
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)qword_1E9DDB380, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(qword_1E9DDB380))
          {
            xmmword_1E9DDB370 = v118;
            __cxa_guard_release(qword_1E9DDB380);
          }
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB510, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1E9DDB510))
          {
            xmmword_1E9DDB390[0] = xmmword_1E9DDB350;
            unk_1E9DDB3A0 = xmmword_1E9DDB330;
            xmmword_1E9DDB3B0 = (__int128)vnegq_f32((float32x4_t)xmmword_1E9DDB310);
            unk_1E9DDB3C0 = xmmword_1E9DDB370;
            xmmword_1E9DDB3D0 = (__int128)vnegq_f32((float32x4_t)xmmword_1E9DDB350);
            unk_1E9DDB3E0 = xmmword_1E9DDB330;
            xmmword_1E9DDB3F0 = xmmword_1E9DDB310;
            unk_1E9DDB400 = xmmword_1E9DDB370;
            xmmword_1E9DDB410 = xmmword_1E9DDB310;
            unk_1E9DDB420 = xmmword_1E9DDB350;
            xmmword_1E9DDB430 = (__int128)vnegq_f32((float32x4_t)xmmword_1E9DDB330);
            unk_1E9DDB440 = xmmword_1E9DDB370;
            xmmword_1E9DDB450 = xmmword_1E9DDB310;
            unk_1E9DDB460 = xmmword_1E9DDB3D0;
            xmmword_1E9DDB470 = xmmword_1E9DDB330;
            unk_1E9DDB480 = xmmword_1E9DDB370;
            xmmword_1E9DDB490 = xmmword_1E9DDB3B0;
            unk_1E9DDB4A0 = xmmword_1E9DDB330;
            xmmword_1E9DDB4B0 = xmmword_1E9DDB3D0;
            unk_1E9DDB4C0 = xmmword_1E9DDB370;
            xmmword_1E9DDB4D0 = xmmword_1E9DDB310;
            unk_1E9DDB4E0 = xmmword_1E9DDB330;
            xmmword_1E9DDB4F0 = xmmword_1E9DDB350;
            unk_1E9DDB500 = xmmword_1E9DDB370;
            __cxa_guard_release(&qword_1E9DDB510);
          }
          uint64_t v83 = sub_1B643D7FC(*(void *)(*(void *)(a1 + 408) + 8 * v46));
          char v84 = (_OWORD *)sub_1B6451064(v83);
          uint64_t v85 = 0;
          long long v86 = v64[577];
          long long v87 = v64[578];
          long long v88 = v64[579];
          v84[580] = v64[580];
          v84[579] = v88;
          v84[578] = v87;
          v84[577] = v86;
          uint64_t v89 = &xmmword_1E9DDB390[4 * v82];
          long long v90 = v89[1];
          long long v91 = v89[2];
          long long v92 = v89[3];
          v128[0] = *v89;
          v128[1] = v90;
          v128[2] = v91;
          void v128[3] = v92;
          do
          {
            v129[v85] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v127, COERCE_FLOAT(v128[v85])), v126, *(float32x2_t *)&v128[v85], 1), v125, (float32x4_t)v128[v85], 2), v124, (float32x4_t)v128[v85], 3);
            ++v85;
          }
          while (v85 != 4);
          long long v93 = v129[1];
          long long v94 = v129[2];
          long long v95 = v129[3];
          v84[449] = v129[0];
          v84[450] = v93;
          v84[451] = v94;
          v84[452] = v95;
          ++v82;
          ++v46;
        }
        while (v82 != v123);
      }
      if (sub_1B6496680((uint64_t)v47, v75, v76, v77, v78, v79, v80, v81) == 2)
      {
        ++v46;
        if (v123 >= 2)
        {
          uint64_t v96 = v64 + 453;
          uint64_t v97 = v123 - 1;
          do
          {
            uint64_t v98 = sub_1B643D7FC(*(void *)(*(void *)(a1 + 408) + 8 * v46));
            int v99 = (_OWORD *)sub_1B6451064(v98);
            long long v100 = v96[128];
            long long v101 = v96[129];
            long long v102 = v96[130];
            v99[580] = v96[131];
            v99[579] = v102;
            v99[578] = v101;
            v99[577] = v100;
            long long v103 = *v96;
            long long v104 = v96[1];
            long long v105 = v96[2];
            v99[452] = v96[3];
            v99[451] = v105;
            v99[450] = v104;
            v99[449] = v103;
            ++v46;
            v96 += 4;
            --v97;
          }
          while (v97);
        }
      }
      ++v45;
    }
    while (v45 != v121);
  }
  uint64_t v106 = *(unsigned int *)(a1 + 400);
  if (v106)
  {
    uint64_t v107 = *(uint64_t **)(a1 + 408);
    uint64_t v108 = 8 * v106;
    do
    {
      uint64_t v109 = (uint64_t *)sub_1B643D7FC(*v107);
      sub_1B65A8D10((uint64_t)v109);
      sub_1B65A8D3C((uint64_t)v109, v110, v111, v112, v113, v114, v115, v116);
      sub_1B65A8F34(v109, *(const char **)v119, *((void *)v119 + 1), v117);
      ++v107;
      v108 -= 8;
    }
    while (v108);
  }

  prof_endFlame();
}

void sub_1B6550120(_Unwind_Exception *a1)
{
}

void sub_1B6550160(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = sub_1B6447B50(*(void *)(a1 + 368), a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Shadow", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm", 185, v6 | 0x300000000);
  uint64_t v9 = *(unsigned int *)(a1 + 400);
  if (v9)
  {
    uint64_t v10 = *(uint64_t **)(a1 + 408);
    uint64_t v11 = 8 * v9;
    do
    {
      sub_1B6460548(*v10++, a2, v7, v8);
      v11 -= 8;
    }
    while (v11);
  }

  prof_endFlame();
}

void sub_1B65501EC(_Unwind_Exception *a1)
{
}

void sub_1B65501FC(unint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = a1;
  unsigned int v7 = sub_1B6447B50(*(void *)(a1 + 368), a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Shadow", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/ShadowMapAtlasPass.mm", 193, v7 | 0x300000000);
  uint64_t v8 = *(unsigned int *)(v6 + 400);
  if (v8)
  {
    uint64_t v9 = *(uint64_t **)(v6 + 408);
    uint64_t v10 = 8 * v8;
    do
    {
      uint64_t v11 = *v9;
      uint64_t v12 = sub_1B6460540(*v9);
      CFDictionaryRef v20 = sub_1B649F640(v12, v13, v14, v15, v16, v17, v18, v19);
      int v35 = sub_1B6498A28((uint64_t)v20, v21, v22, v23, v24, v25, v26, v27);
      float v36 = 2.0;
      if (v35)
      {
        objc_msgSend_setCullMode_(*(void **)a3, v28, 1, v30);
        float v36 = 0.0;
        objc_msgSend_setLockCullMode_(*(void **)a3, v37, 1, v38);
      }
      double v39 = sub_1B6495FE4((uint64_t)v20, (uint64_t)v28, v29, v30, v31, v32, v33, v34);
      *(float *)&double v39 = v39;
      *(float *)&double v39 = *(float *)&v39 * -10.0;
      *(float *)&double v40 = -v36;
      objc_msgSend_setDepthBias_slopeScale_clamp_(*(void **)a3, v41, v42, v43, v39, v40, 0.0);
      uint64_t v47 = *(void *)(a3 + 16);
      long long v46 = *(_OWORD *)a3;
      unint64_t v6 = v6 & 0xFFFFFFFFFFFF0000 | BYTE1(v47) | ((unint64_t)BYTE1(v47) << 8);
      sub_1B6460C38(v11, a2, (uint64_t)&v46, v6);
      if (v35) {
        objc_msgSend_setLockCullMode_(*(void **)a3, v44, 0, v45);
      }
      ++v9;
      v10 -= 8;
    }
    while (v10);
  }
  prof_endFlame();
}

void sub_1B655033C(_Unwind_Exception *a1)
{
}

uint64_t sub_1B655035C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = a1;
  uint64_t v10 = sub_1B644558C(a3, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B64B28B0(v10, v11, v12, v13, v14, v15, v16, v17);
  if (!sub_1B63C465C(v18)) {
    return 0;
  }
  v21[0] = (uint64_t)"Shadow map atlas";
  v21[1] = a3;
  __int16 v22 = 0;
  int v20 = 0;
  return sub_1B65503D0(a1, &v23, v21, &v20);
}

uint64_t sub_1B65503D0(uint64_t *a1, uint64_t **a2, uint64_t *a3, int *a4)
{
  uint64_t v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B655053C(v9[0], v7, v9, a2, a3, a4);
  sub_1B63C88CC(a1 + 18, v9);
  return v9[0];
}

void sub_1B655042C(CFX::RG::Pass *a1)
{
  *(void *)a1 = &unk_1F0FB3EC0;
  sub_1B65504F0((uint64_t)a1 + 384);

  CFX::RG::Pass::~Pass(a1);
}

void sub_1B6550484(CFX::RG::Pass *a1)
{
  *(void *)a1 = &unk_1F0FB3EC0;
  sub_1B65504F0((uint64_t)a1 + 384);
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B65504F0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20))
  {
    uint64_t v4 = *(void *)(a1 + 24);
    CFAllocatorRef v2 = *(void **)(a1 + 8);
    if (v2) {
      sub_1B63C89D4(v2, &v4);
    }
  }
  return a1;
}

uint64_t sub_1B655053C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t **a4, uint64_t *a5, int *a6)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v10 = sub_1B63C8330(v12, 0x1B0u, 8u);
  return sub_1B654F7F8(v10, *a3, a3[1], *a4, a5, *a6);
}

uint64_t sub_1B65505A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8 = &qword_1E9DDB000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB530, memory_order_acquire) & 1) == 0)
  {
    uint64_t v12 = a2;
    uint64_t v13 = a3;
    int v11 = __cxa_guard_acquire(&qword_1E9DDB530);
    uint64_t v8 = &qword_1E9DDB000;
    a2 = v12;
    a3 = v13;
    if (v11)
    {
      qword_1E9DDB528 = (uint64_t)sub_1B6551EAC("DOF_DOWNSAMPLE_COLOR_COC_PASS", 0x1Du);
      __cxa_guard_release(&qword_1E9DDB530);
      uint64_t v8 = &qword_1E9DDB000;
      a2 = v12;
      a3 = v13;
    }
  }
  sub_1B653860C(a1, a2, a3, a5, v8[165], 0);
  *(void *)a1 = &unk_1F0FB4630;
  memcpy((void *)(a1 + 376), a5 + 2, 0x150uLL);
  *(void *)(a1 + 720) = 0;
  *(void *)(a1 + 736) = 0;
  *(void *)(a1 + 72_Block_object_dispose(&STACK[0x200], 8) = 0;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 384), MTLPixelFormatRGBA16Float, (uint64_t)v14);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v14, 1.0 / (float)*(unsigned int *)(a1 + 704), v15);
  uint64_t v9 = sub_1B63CFDE4(a4, (uint64_t)"DOF_DOWNSAMPLE_COLOR_COC", v15);
  *(void *)(a1 + 736) = v9;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v9);
  return a1;
}

void sub_1B65506DC(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B65506F4(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned int *)(a1 + 704));
  uint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  uint64_t v7 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
  *(void *)(a1 + 712) = v7;
  if (!v7)
  {
    *(void *)(a1 + 712) = sub_1B6550814(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
    uint64_t v15 = (void *)sub_1B6445900(*(void *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    uint64_t v19 = objc_msgSend_resourceManager(v15, v16, v17, v18);
    id v26 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v26, v20, a1 + 704, 29, @"dof_downsample_rate");
    uint64_t v21 = *(void *)(a1 + 712);
    uint64_t v23 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v19, v22, @"dof_downsample_color_coc", (uint64_t)v26);
    uint64_t v24 = *(void **)(v21 + 16);
    if (v24 != (void *)v23)
    {
      uint64_t v25 = v23;
      if (v24) {

      }
      *(void *)(v21 + 16) = v25;
    }
  }
}

uint64_t sub_1B6550814(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void *sub_1B655089C(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *a3;
  CFTimeInterval result = *(void **)(a1 + 376);
  if (result || (CFTimeInterval result = (void *)sub_1B6446564(*(uint64_t **)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0)
  {
    CFTimeInterval result = sub_1B64A3B48((uint64_t)result, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (result)
    {
      uint64_t v12 = (uint64_t)result;
      id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 720));
      id v14 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 728));
      id v15 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 736));
      objc_msgSend_setTexture_atIndex_(v10, v16, (uint64_t)Texture, 0);
      objc_msgSend_setTexture_atIndex_(v10, v17, (uint64_t)v14, 1);
      objc_msgSend_setTexture_atIndex_(v10, v18, (uint64_t)v15, 2);
      long long v96 = xmmword_1B6E4F490;
      float v26 = sub_1B649C080(v12, v19, v20, v21, v22, v23, v24, v25) / 1000.0;
      double v27 = v26 + 0.01;
      float v42 = sub_1B649C30C(v12, v28, v29, v30, v31, v32, v33, v34);
      if (v27 >= v42) {
        float v43 = v27;
      }
      else {
        float v43 = v42;
      }
      float v44 = sub_1B649C59C(v12, v35, v36, v37, v38, v39, v40, v41) / 1000.0;
      float v52 = sub_1B649C638(v12, v45, v46, v47, v48, v49, v50, v51) / 1000.0;
      uint64_t v60 = sub_1B649D3DC(v12, v53, v54, v55, v56, v57, v58, v59);
      unint64_t v64 = objc_msgSend_width(v15, v61, v62, v63);
      unint64_t v68 = objc_msgSend_height(v15, v65, v66, v67);
      if (sub_1B649C80C((unsigned __int8 *)v60, (float)(v64 / v68), v69, v70, v71, v72, v73, v74, v75)) {
        uint64_t v79 = objc_msgSend_width(v15, v76, v77, v78);
      }
      else {
        uint64_t v79 = objc_msgSend_height(v15, v76, v77, v78);
      }
      float v81 = (float)(v26 * (float)(v44 * (float)((float)(unint64_t)v79 / v52))) / (float)(v43 - v26);
      float v82 = *(float *)(v60 + 8);
      *(float *)&uint64_t v83 = (float)((float)(v82 - *(float *)(v60 + 4)) * (float)-(float)(v81 * v43))
                     / (float)(v82 * *(float *)(v60 + 4));
      float v84 = (1.0 - (float)(v43 / v82)) * v81;
      *((float *)&v83 + 1) = v84;
      uint64_t v95 = v83;
      objc_msgSend_setBytes_length_atIndex_(v10, v80, (uint64_t)&v95, 32, 0);
      uint64_t v91 = *(void *)(a1 + 712);
      uint64_t v92 = *(void *)(v91 + 16);
      if (!v92)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v85, v86, v87, v88, v89, v90, (uint64_t)"_ptr != NULL");
        uint64_t v92 = *(void *)(v91 + 16);
      }
      uint64_t v93 = sub_1B653EFB8(v92);
      return objc_msgSend_dispatch_onTexture2D_(v10, v94, v93, (uint64_t)v15);
    }
  }
  return result;
}

uint64_t sub_1B6550ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &qword_1E9DDB000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB540, memory_order_acquire) & 1) == 0)
  {
    uint64_t v20 = a2;
    uint64_t v21 = a3;
    int v19 = __cxa_guard_acquire(&qword_1E9DDB540);
    uint64_t v8 = &qword_1E9DDB000;
    a2 = v20;
    a3 = v21;
    if (v19)
    {
      qword_1E9DDB538 = (uint64_t)sub_1B6551EAC("DOF_DOWNSAMPLE_SORT_COC_PASS", 0x1Cu);
      __cxa_guard_release(&qword_1E9DDB540);
      uint64_t v8 = &qword_1E9DDB000;
      a2 = v20;
      a3 = v21;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v8[167], 0);
  *(void *)a1 = &unk_1F0FB45C0;
  long long v9 = *(_OWORD *)(a5 + 16);
  long long v10 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 40_Block_object_dispose(&STACK[0x200], 8) = v10;
  *(_OWORD *)(a1 + 376) = v9;
  long long v11 = *(_OWORD *)(a5 + 64);
  long long v12 = *(_OWORD *)(a5 + 80);
  long long v13 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v13;
  *(_OWORD *)(a1 + 424) = v11;
  *(_OWORD *)(a1 + 440) = v12;
  long long v14 = *(_OWORD *)(a5 + 128);
  long long v15 = *(_OWORD *)(a5 + 144);
  long long v16 = *(_OWORD *)(a5 + 160);
  *(void *)(a1 + 536) = *(void *)(a5 + 176);
  *(_OWORD *)(a1 + 504) = v15;
  *(_OWORD *)(a1 + 520) = v16;
  *(_OWORD *)(a1 + 48_Block_object_dispose(&STACK[0x200], 8) = v14;
  *(_OWORD *)(a1 + 552) = 0u;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 376), MTLPixelFormatRG16Float, (uint64_t)v22);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v22, 1.0 / (float)(4 * *(_DWORD *)(a1 + 536)), v23);
  uint64_t v17 = sub_1B63CFDE4(a4, (uint64_t)"DOF_COC_DOWNSAMPLE", v23);
  *(void *)(a1 + 560) = v17;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v17);
  return a1;
}

void sub_1B6550C20(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6550C38(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
  a1[68] = v5;
  if (!v5)
  {
    a1[68] = sub_1B6550CC8(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
    long long v13 = (void *)sub_1B6445900(a1[46], v6, v7, v8, v9, v10, v11, v12);
    uint64_t v17 = objc_msgSend_resourceManager(v13, v14, v15, v16);
    uint64_t v18 = a1[68];
    uint64_t v21 = objc_msgSend_newComputePipelineStateWithFunctionName_(v17, v19, @"dof_coc_downsample_sort", v20);
    uint64_t v22 = *(void **)(v18 + 16);
    if (v22 != (void *)v21)
    {
      uint64_t v23 = v21;
      if (v22) {

      }
      *(void *)(v18 + 16) = v23;
    }
  }
}

uint64_t sub_1B6550CC8(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B6550D50(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v5 = *a3;
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 552));
  id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
  uint64_t v16 = *(void *)(a1 + 544);
  uint64_t v17 = *(void *)(v16 + 16);
  if (!v17)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v10, v11, v12, v13, v14, v15, (uint64_t)"_ptr != NULL");
    uint64_t v17 = *(void *)(v16 + 16);
  }
  uint64_t v19 = sub_1B653EFB8(v17);

  return objc_msgSend_dispatch_onTexture2D_(v5, v18, v19, (uint64_t)v7);
}

uint64_t sub_1B6550E14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9 = &qword_1E9DDB000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB550, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = a2;
    int v23 = __cxa_guard_acquire(&qword_1E9DDB550);
    uint64_t v9 = &qword_1E9DDB000;
    a2 = v24;
    if (v23)
    {
      byte_1E9DDB548 = 1;
      __cxa_guard_release(&qword_1E9DDB550);
      uint64_t v9 = &qword_1E9DDB000;
      a2 = v24;
    }
  }
  if (*((unsigned char *)v9 + 1352)) {
    uint64_t v10 = 0xD94882481E2E3EC6;
  }
  else {
    uint64_t v10 = 0;
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v10, 0);
  *(void *)a1 = &unk_1F0FB36E8;
  long long v11 = *(_OWORD *)(a5 + 16);
  long long v12 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 40_Block_object_dispose(&STACK[0x200], 8) = v12;
  *(_OWORD *)(a1 + 376) = v11;
  long long v13 = *(_OWORD *)(a5 + 64);
  long long v14 = *(_OWORD *)(a5 + 80);
  long long v15 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v15;
  *(_OWORD *)(a1 + 424) = v13;
  *(_OWORD *)(a1 + 440) = v14;
  long long v16 = *(_OWORD *)(a5 + 128);
  long long v17 = *(_OWORD *)(a5 + 144);
  long long v18 = *(_OWORD *)(a5 + 160);
  *(void *)(a1 + 536) = *(void *)(a5 + 176);
  *(_OWORD *)(a1 + 504) = v17;
  *(_OWORD *)(a1 + 520) = v18;
  *(_OWORD *)(a1 + 48_Block_object_dispose(&STACK[0x200], 8) = v16;
  *(_OWORD *)(a1 + 552) = 0u;
  v25[0] = *(_OWORD *)(a1 + 8);
  uint64_t v19 = (char *)sub_1B63C8330(v25, 0x16u, 1u);
  strlcpy(v19, "DOF_COC_BLUR_OUTPUT_", 0x15uLL);
  if (*(unsigned char *)(a1 + 540)) {
    char v20 = 89;
  }
  else {
    char v20 = 88;
  }
  v19[20] = v20;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 376), MTLPixelFormatRG16Float, (uint64_t)v25);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v25, 1.0 / (float)(4 * *(_DWORD *)(a1 + 536)), v26);
  uint64_t v21 = sub_1B63CFDE4(a4, (uint64_t)v19, v26);
  *(void *)(a1 + 560) = v21;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v21);
  return a1;
}

void sub_1B6550FD4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6550FF0(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned __int8 *)(a1 + 540));
  uint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  uint64_t v7 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
  *(void *)(a1 + 544) = v7;
  if (!v7)
  {
    *(void *)(a1 + 544) = sub_1B6551110(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
    long long v15 = (void *)sub_1B6445900(*(void *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    uint64_t v19 = objc_msgSend_resourceManager(v15, v16, v17, v18);
    id v26 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v26, v20, a1 + 540, 53, @"dof_blur_vertical");
    uint64_t v21 = *(void *)(a1 + 544);
    uint64_t v23 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v19, v22, @"dof_coc_blur", (uint64_t)v26);
    uint64_t v24 = *(void **)(v21 + 16);
    if (v24 != (void *)v23)
    {
      uint64_t v25 = v23;
      if (v24) {

      }
      *(void *)(v21 + 16) = v25;
    }
  }
}

uint64_t sub_1B6551110(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B6551198(uint64_t a1, uint64_t a2, void **a3)
{
  unint64_t v5 = *a3;
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 552));
  id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
  uint64_t v16 = *(void *)(a1 + 544);
  uint64_t v17 = *(void *)(v16 + 16);
  if (!v17)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v10, v11, v12, v13, v14, v15, (uint64_t)"_ptr != NULL");
    uint64_t v17 = *(void *)(v16 + 16);
  }
  uint64_t v19 = sub_1B653EFB8(v17);

  return objc_msgSend_dispatch_onTexture2D_(v5, v18, v19, (uint64_t)v7);
}

uint64_t sub_1B655125C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &qword_1E9DDB000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB560, memory_order_acquire) & 1) == 0)
  {
    uint64_t v20 = a2;
    uint64_t v21 = a3;
    int v19 = __cxa_guard_acquire(&qword_1E9DDB560);
    uint64_t v8 = &qword_1E9DDB000;
    a2 = v20;
    a3 = v21;
    if (v19)
    {
      qword_1E9DDB558 = (uint64_t)sub_1B6551EAC("DOF_FINAL_PASS", 0xEu);
      __cxa_guard_release(&qword_1E9DDB560);
      uint64_t v8 = &qword_1E9DDB000;
      a2 = v20;
      a3 = v21;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v8[171], 0);
  *(void *)a1 = &unk_1F0FB32F0;
  long long v9 = *(_OWORD *)(a5 + 16);
  long long v10 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 40_Block_object_dispose(&STACK[0x200], 8) = v10;
  *(_OWORD *)(a1 + 376) = v9;
  long long v11 = *(_OWORD *)(a5 + 64);
  long long v12 = *(_OWORD *)(a5 + 80);
  long long v13 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v13;
  *(_OWORD *)(a1 + 424) = v11;
  *(_OWORD *)(a1 + 440) = v12;
  long long v14 = *(_OWORD *)(a5 + 128);
  long long v15 = *(_OWORD *)(a5 + 144);
  long long v16 = *(_OWORD *)(a5 + 176);
  *(_OWORD *)(a1 + 520) = *(_OWORD *)(a5 + 160);
  *(_OWORD *)(a1 + 536) = v16;
  *(_OWORD *)(a1 + 48_Block_object_dispose(&STACK[0x200], 8) = v14;
  *(_OWORD *)(a1 + 504) = v15;
  *(void *)(a1 + 576) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 376), MTLPixelFormatRGBA16Float, (uint64_t)v22);
  CFX::RG::TextureDescriptorReference::applyingSizeFactor((CFX::RG::TextureDescriptorReference *)v22, 1.0 / (float)*(unsigned int *)(a1 + 536), v23);
  uint64_t v17 = sub_1B63CFDE4(a4, (uint64_t)"DOF_FINAL", v23);
  *(void *)(a1 + 576) = v17;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v17);
  return a1;
}

void sub_1B65513B4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B65513CC(uint64_t *a1, uint64_t a2)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v12 = sub_1B65293D4(a1[68], v5, v6, v7, v8, v9, v10, v11);
  uint64_t v20 = sub_1B65293D4(a1[68], v13, v14, v15, v16, v17, v18, v19);
  int v21 = v20;
  unint64_t v22 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v12 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ v4)));
  unint64_t v23 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
  uint64_t v24 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v23 ^ ((0x9DDFEA08EB382D69 * (v23 ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * (v23 ^ v20)))) ^ ((0x9DDFEA08EB382D69 * (v23 ^ ((0x9DDFEA08EB382D69 * (v23 ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * (v23 ^ v20)))) >> 47));
  uint64_t v25 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v24);
  a1[69] = v25;
  if (!v25)
  {
    a1[69] = sub_1B6551624(*(CFX::CrossFrameResourceManager **)(a2 + 32), v24);
    uint64_t v33 = (void *)sub_1B6445900(a1[46], v26, v27, v28, v29, v30, v31, v32);
    uint64_t v37 = objc_msgSend_resourceManager(v33, v34, v35, v36);
    uint64_t v38 = a1[69];
    float v42 = objc_msgSend_device(v33, v39, v40, v41);
    uint64_t v44 = objc_msgSend_newBufferWithLength_options_(v42, v43, 512, 32);
    uint64_t v47 = *(void **)(v38 + 24);
    if (v47 != (void *)v44)
    {
      uint64_t v48 = v44;
      if (v47) {

      }
      *(void *)(v38 + 24) = v48;
    }
    float v49 = fmin((double)(unint64_t)v12, 64.0);
    uint64_t v50 = sqrtf(v49);
    uint64_t v51 = objc_msgSend_newComputePipelineStateWithFunctionName_(v37, v45, @"dof_compute_kernel_parallel", v46);
    uint64_t v52 = a1[69];
    *(_DWORD *)(v52 + 32) = v50;
    *(_DWORD *)(v52 + 36) = v21;
    v86[0] = v21;
    v86[1] = v50;
    uint64_t v56 = objc_msgSend_currentCommandBuffer(v33, v53, v54, v55);
    uint64_t v60 = objc_msgSend_computeCommandEncoder(v56, v57, v58, v59);
    uint64_t v61 = sub_1B653EFB8((uint64_t)v51);
    objc_msgSend_setComputePipelineState_(v60, v62, v61, v63);
    uint64_t v70 = a1[69];
    uint64_t v71 = *(void *)(v70 + 24);
    if (!v71)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", 0, v65, v66, v67, v68, v69, (uint64_t)"_ptr != NULL");
      uint64_t v71 = *(void *)(v70 + 24);
    }
    objc_msgSend_setBuffer_offset_atIndex_(v60, v64, v71, 0, 0);
    objc_msgSend_setBytes_length_atIndex_(v60, v72, (uint64_t)v86, 16, 1);
    int64x2_t v84 = vdupq_n_s64(1uLL);
    uint64_t v85 = 1;
    v83[0] = v50;
    v83[1] = v50;
    v83[2] = 1;
    objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v60, v73, (uint64_t)&v84, (uint64_t)v83);
    objc_msgSend_endEncoding(v60, v74, v75, v76);

    uint64_t v77 = a1[69];
    uint64_t v80 = objc_msgSend_newComputePipelineStateWithFunctionName_(v37, v78, @"dof_blur2", v79);
    float v81 = *(void **)(v77 + 16);
    if (v81 != (void *)v80)
    {
      uint64_t v82 = v80;
      if (v81) {

      }
      *(void *)(v77 + 16) = v82;
    }
  }
}

uint64_t sub_1B6551624(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B65516B8(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a3;
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568));
  id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 576));
  objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v10, (uint64_t)v7, 1);
  objc_msgSend_setTexture_atIndex_(v5, v11, (uint64_t)v8, 2);
  v32[0] = *(_DWORD *)(*(void *)(a1 + 552) + 32) * *(_DWORD *)(*(void *)(a1 + 552) + 32);
  objc_msgSend_setBytes_length_atIndex_(v5, v12, (uint64_t)v32, 16, 0);
  uint64_t v19 = *(void *)(a1 + 552);
  uint64_t v20 = *(void *)(v19 + 24);
  if (!v20)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", 0, v14, v15, v16, v17, v18, (uint64_t)"_ptr != NULL");
    uint64_t v20 = *(void *)(v19 + 24);
  }
  objc_msgSend_setBuffer_offset_atIndex_(v5, v13, v20, 0, 1);
  uint64_t v27 = *(void *)(a1 + 552);
  uint64_t v28 = *(void *)(v27 + 16);
  if (!v28)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v21, v22, v23, v24, v25, v26, (uint64_t)"_ptr != NULL");
    uint64_t v28 = *(void *)(v27 + 16);
  }
  uint64_t v29 = sub_1B653EFB8(v28);
  return objc_msgSend_dispatch_onTexture2D_(v5, v30, v29, (uint64_t)v8);
}

uint64_t *sub_1B6551824(uint64_t *a1, uint64_t a2, CFX::RG::Resource *a3, CFX::RG::Resource *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(a2 + 32)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"scopeParameters.dofEffect");
  }
  uint64_t v12 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)(a2 + 8));
  long long v13 = v12[1];
  v133[0] = *v12;
  v133[1] = v13;
  long long v14 = v12[5];
  long long v16 = v12[2];
  long long v15 = v12[3];
  v133[4] = v12[4];
  v133[5] = v14;
  v133[2] = v16;
  v133[3] = v15;
  long long v17 = v12[9];
  long long v19 = v12[6];
  long long v18 = v12[7];
  v133[8] = v12[8];
  v133[9] = v17;
  v133[6] = v19;
  v133[7] = v18;
  CFX::RG::TextureDescriptorReference::withSampleCount(v133, 1, (uint64_t)&v123);
  uint64_t v20 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)(a2 + 16));
  long long v21 = v20[1];
  v122[0] = *v20;
  v122[1] = v21;
  long long v22 = v20[5];
  long long v24 = v20[2];
  long long v23 = v20[3];
  v122[4] = v20[4];
  v122[5] = v22;
  v122[2] = v24;
  v122[3] = v23;
  long long v25 = v20[9];
  long long v27 = v20[6];
  long long v26 = v20[7];
  v122[8] = v20[8];
  v122[9] = v25;
  v122[6] = v27;
  v122[7] = v26;
  CFX::RG::TextureDescriptorReference::withSampleCount(v122, 1, (uint64_t)v121);
  long long v106 = v129;
  long long v107 = v130;
  long long v108 = v131;
  long long v109 = v132;
  long long v102 = v125;
  long long v103 = v126;
  long long v104 = v127;
  long long v105 = v128;
  long long v100 = v123;
  long long v101 = v124;
  long long v116 = v121[6];
  long long v117 = v121[7];
  long long v118 = v121[8];
  long long v119 = v121[9];
  long long v115 = v121[5];
  long long v112 = v121[2];
  long long v113 = v121[3];
  long long v114 = v121[4];
  long long v110 = v121[0];
  uint64_t v28 = *(void *)a2;
  v99[0] = (uint64_t)"DOF downsample color CoC";
  v99[1] = v28;
  v99[2] = *(void *)(a2 + 24);
  long long v111 = v121[1];
  int v120 = 4;
  uint64_t v29 = (uint64_t *)sub_1B6551C5C(a1, a1, v99);
  uint64_t v31 = (CFX::RG::Resource *)CFX::RG::copyIfNeeded((CFX::RG *)a1, *(CFX::RG::RenderGraphBuilder **)(a2 + 8), a3, (CFX::RG::Pass *)&v123, 0, v30);
  v29[90] = (uint64_t)v31;
  CFX::RG::Pass::readFrom(v29, v31);
  if (a3) {
    CFX::RG::Pass::dependsOn(v29, a3);
  }
  uint64_t v33 = (CFX::RG::Resource *)CFX::RG::copyIfNeeded((CFX::RG *)a1, *(CFX::RG::RenderGraphBuilder **)(a2 + 16), a4, (CFX::RG::Pass *)v121, 0, v32);
  v29[91] = (uint64_t)v33;
  CFX::RG::Pass::readFrom(v29, v33);
  if (a4) {
    CFX::RG::Pass::dependsOn(v29, a4);
  }
  uint64_t v34 = *(void *)a2;
  v87[0] = "DOF downsample CoC";
  v87[1] = v34;
  long long v94 = v129;
  long long v95 = v130;
  long long v96 = v131;
  long long v97 = v132;
  long long v90 = v125;
  long long v91 = v126;
  long long v92 = v127;
  long long v93 = v128;
  long long v88 = v123;
  long long v89 = v124;
  int v98 = 4;
  uint64_t v35 = (uint64_t *)sub_1B6551CB4(a1, a1, (uint64_t)v87);
  uint64_t v36 = (CFX::RG::Resource *)v29[92];
  v35[69] = (uint64_t)v36;
  CFX::RG::Pass::readFrom(v35, v36);
  uint64_t v37 = *(void *)a2;
  v74[0] = "DOF blur CoC X";
  v74[1] = v37;
  long long v81 = v129;
  long long v82 = v130;
  long long v83 = v131;
  long long v84 = v132;
  long long v77 = v125;
  long long v78 = v126;
  long long v79 = v127;
  long long v80 = v128;
  long long v75 = v123;
  long long v76 = v124;
  int v85 = 4;
  char v86 = 0;
  uint64_t v38 = (uint64_t *)sub_1B6551D0C(a1, a1, (uint64_t)v74);
  uint64_t v39 = (CFX::RG::Resource *)v35[70];
  v38[69] = (uint64_t)v39;
  CFX::RG::Pass::readFrom(v38, v39);
  uint64_t v40 = *(void *)a2;
  v61[0] = "DOF blur CoC Y";
  v61[1] = v40;
  long long v68 = v129;
  long long v69 = v130;
  long long v70 = v131;
  long long v71 = v132;
  long long v64 = v125;
  long long v65 = v126;
  long long v66 = v127;
  long long v67 = v128;
  long long v62 = v123;
  long long v63 = v124;
  int v72 = 4;
  char v73 = 1;
  uint64_t v41 = (uint64_t *)sub_1B6551D0C(a1, a1, (uint64_t)v61);
  float v42 = (CFX::RG::Resource *)v38[70];
  v41[69] = (uint64_t)v42;
  CFX::RG::Pass::readFrom(v41, v42);
  uint64_t v43 = *(void *)a2;
  v48[0] = "DOF final";
  v48[1] = v43;
  long long v55 = v129;
  long long v56 = v130;
  long long v57 = v131;
  long long v58 = v132;
  long long v51 = v125;
  long long v52 = v126;
  long long v53 = v127;
  long long v54 = v128;
  long long v49 = v123;
  long long v50 = v124;
  int v59 = 4;
  uint64_t v60 = *(void *)(a2 + 32);
  uint64_t v44 = (uint64_t *)sub_1B6551D64(a1, a1, (uint64_t)v48);
  uint64_t v45 = (CFX::RG::Resource *)v29[92];
  v44[70] = (uint64_t)v45;
  CFX::RG::Pass::readFrom(v44, v45);
  uint64_t v46 = (CFX::RG::Resource *)v41[70];
  v44[71] = (uint64_t)v46;
  CFX::RG::Pass::readFrom(v44, v46);
  return v44;
}

uint64_t sub_1B6551C5C(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6552290(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6551CB4(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B65522F0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6551D0C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6552350(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6551D64(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B65523B0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6551DC0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6551DFC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6551E38(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6551E74(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B6551EAC(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      unint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      CFTimeInterval result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B6551F98(void *a1)
{
  *a1 = &unk_1F0FB4610;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6551FE4(void *a1)
{
  *a1 = &unk_1F0FB4610;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6552050(void *a1)
{
  *a1 = &unk_1F0FB45A0;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B655209C(void *a1)
{
  *a1 = &unk_1F0FB45A0;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6552108(void *a1)
{
  *a1 = &unk_1F0FB36C8;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6552154(void *a1)
{
  *a1 = &unk_1F0FB36C8;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B65521C0(void *a1)
{
  *a1 = &unk_1F0FB32D0;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  return a1;
}

void sub_1B6552218(void *a1)
{
  *a1 = &unk_1F0FB32D0;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6552290(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x2E8u, 8u);
  return sub_1B65505A4(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B65522F0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x238u, 8u);
  return sub_1B6550ABC(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6552350(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x238u, 8u);
  return sub_1B6550E14(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B65523B0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x248u, 8u);
  return sub_1B655125C(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6552410(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = (void *)result;
  int v2 = *(_DWORD *)(result + 8);
  if (v2 == 21)
  {
    uint64_t v7 = *(void *)(result + 80);
    if (!v7) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (v2 != 22)
  {
    if (v2 == 31)
    {
      uint64_t v3 = *(unsigned int *)(result + 28);
      if ((int)v3 >= 1)
      {
        uint64_t v4 = 0;
        uint64_t v5 = 96 * v3;
        do
        {
          uint64_t v6 = v1[5] + v4;
          if (*(unsigned char *)(v6 + 88)) {
            sub_1B6552410(*(void *)(v6 + 64));
          }
          v4 += 96;
        }
        while (v5 != v4);
      }
    }
    goto LABEL_16;
  }
  uint64_t v7 = *(void *)(*(void *)(result + 48) + 80);
  if (v7) {
LABEL_15:
  }
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
LABEL_16:
  uint64_t v8 = *(uint64_t (**)(void *))(*v1 + 8);

  return v8(v1);
}

uint64_t sub_1B6552868(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  return objc_msgSend_cleanCollisionCache(a3, a2, (uint64_t)a3, a4);
}

id sub_1B6552AD0(void *a1, uint64_t a2)
{
  uint64_t v4 = [VFXBtShapeWrapper alloc];
  uint64_t v5 = sub_1B6554050(a1, a2);
  uint64_t v8 = objc_msgSend_initWithShape_(v4, v6, v5, v7);

  return v8;
}

id sub_1B6552B34(void *a1, uint64_t a2, int a3)
{
  if (!a3) {
    goto LABEL_5;
  }
  uint64_t v41 = 0;
  float v42 = &v41;
  uint64_t v43 = 0x2020000000;
  int v44 = 0;
  v40[0] = MEMORY[0x1E4F143A8];
  v40[1] = 3221225472;
  void v40[2] = sub_1B6553ECC;
  float32x4_t v40[3] = &unk_1E61443C8;
  v40[4] = &v41;
  sub_1B64A18A4((uint64_t)a1, (uint64_t)v40);
  int v5 = *((_DWORD *)v42 + 6);
  _Block_object_dispose(&v41, 8);
  if (v5 < 2)
  {
LABEL_5:
    long long v22 = [VFXBtShapeWrapper alloc];
    uint64_t v23 = sub_1B6553C9C(a1, a2);
    long long v21 = objc_msgSend_initWithShape_(v22, v24, v23, v25);
    return v21;
  }
  uint64_t v6 = (_DWORD *)sub_1B6E073B8(128, 16);
  sub_1B6DE495C(v6, 1);
  *(double *)&long long v14 = sub_1B64A2220((uint64_t)a1, v7, v8, v9, v10, v11, v12, v13);
  v33[0] = MEMORY[0x1E4F143A8];
  v33[1] = 3221225472;
  uint64_t v33[2] = (uint64_t)sub_1B6553F24;
  v33[3] = (uint64_t)&unk_1E61443E8;
  long long v34 = v14;
  long long v35 = v15;
  long long v36 = v16;
  long long v37 = v17;
  uint64_t v38 = a2;
  uint64_t v39 = v6;
  sub_1B64A18A4((uint64_t)a1, (uint64_t)v33);
  if (v6[7])
  {
    sub_1B6DE53D8((uint64_t)v6);
    long long v18 = [VFXBtShapeWrapper alloc];
    long long v21 = objc_msgSend_initWithShape_(v18, v19, (uint64_t)v6, v20);
    return v21;
  }
  (*(void (**)(_DWORD *))(*(void *)v6 + 8))(v6);
  sub_1B63F2F54(16, @"Error: Compound shapes cannot be created without shapes", v27, v28, v29, v30, v31, v32, v33[0]);
  return 0;
}

void sub_1B6552D00(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

id sub_1B6552D28(void *a1, uint64_t a2)
{
  uint64_t v4 = (_DWORD *)sub_1B6E073B8(128, 16);
  sub_1B6DE495C(v4, 0);
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  float32x4_t v17[2] = (uint64_t)sub_1B6553BA8;
  _OWORD v17[3] = (uint64_t)&unk_1E61443A0;
  v17[4] = a2;
  v17[5] = (uint64_t)v4;
  objc_msgSend_enumerateObjectsUsingBlock_(a1, v5, (uint64_t)v17, v6);
  if (v4[7])
  {
    sub_1B6DE53D8((uint64_t)v4);
    uint64_t v7 = [VFXBtShapeWrapper alloc];
    return (id)objc_msgSend_initWithShape_(v7, v8, (uint64_t)v4, v9);
  }
  else
  {
    (*(void (**)(_DWORD *))(*(void *)v4 + 8))(v4);
    sub_1B63F2F54(16, @"Error: Compound shapes cannot be created without shapes", v11, v12, v13, v14, v15, v16, v17[0]);
    return 0;
  }
}

void sub_1B6552E30(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B655331C(uint64_t a1, const UInt8 **a2, _DWORD *a3, int *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B63D0C08(a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8))
  {
    sub_1B63F2F54(0, @"Info: Non triangle list element type not yet supported in physics shape generation", v13, v14, v15, v16, v17, v18, v38);
  }
  else
  {
    int v39 = 0;
    uint64_t v20 = sub_1B63D0F38(a1, &v39);
    if (v20)
    {
      CFDataRef v28 = (const __CFData *)v20;
      int v29 = sub_1B63D0CA8(a1, v21, v22, v23, v24, v25, v26, v27);
      *a2 = CFDataGetBytePtr(v28);
      int v36 = v39;
      *a3 = 3 * v39;
      *a4 = v29 / 3;
      switch(v36)
      {
        case 1:
          int v37 = 5;
          break;
        case 4:
          int v37 = 2;
          break;
        case 2:
          int v37 = 3;
          break;
        default:
          sub_1B63F2F54(17, @"Assertion '%s' failed. Unsupported indices stride", v30, v31, v32, v33, v34, v35, (uint64_t)"0");
          return 0;
      }
      *a5 = v37;
      return 1;
    }
  }
  return 0;
}

uint64_t sub_1B655342C(uint64_t a1)
{
  uint64_t v2 = sub_1B6E073B8(112, 16);
  *(_OWORD *)(v2 + 16) = xmmword_1B6E4F540;
  *(void *)uint64_t v2 = &unk_1F0FB23F0;
  int v3 = 1;
  *(unsigned char *)(v2 + 56) = 1;
  *(void *)(v2 + 4_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v2 + 40) = 0;
  uint64_t v48 = v2;
  *(_DWORD *)(v2 + 72) = 0;
  uint64_t v8 = sub_1B64AC5F8(a1, 0, 0, 1, v4, v5, v6, v7);
  uint64_t v16 = sub_1B641E1A8((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15);
  int v17 = sub_1B65349B8(v16);
  int v25 = sub_1B641D8A0((uint64_t)v8, v18, v19, v20, v21, v22, v23, v24);
  CFDataRef v26 = (const __CFData *)sub_1B641D89C(v8);
  BytePtr = CFDataGetBytePtr(v26);
  if (sub_1B6534654(v16) != 6)
  {
    sub_1B6534654(v16);
    int v3 = 0;
  }
  CFArrayRef v35 = sub_1B64ABD08(a1, v28, v29, v30, v31, v32, v33, v34);
  if ((uint64_t)v35 >= 1)
  {
    CFArrayRef v41 = v35;
    for (CFIndex i = 0; (const __CFArray *)i != v41; ++i)
    {
      uint64_t v43 = sub_1B64ABD78(a1, i, 1, v36, v37, v38, v39, v40);
      long long v53 = BytePtr;
      int v54 = v17;
      int v55 = 2;
      int v56 = v3;
      v52[1] = v25;
      int v49 = 0;
      if (sub_1B655331C((uint64_t)v43, &v51, v52, &v50, &v49, v44, v45, v46)) {
        sub_1B65535A4(v48, (uint64_t)&v50, v49);
      }
    }
  }
  return v48;
}

__n128 sub_1B65535A4(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = *(_DWORD *)(a1 + 36);
  if (v6 == *(_DWORD *)(a1 + 40))
  {
    int v7 = v6 ? 2 * v6 : 1;
    if (v6 < v7)
    {
      if (v7)
      {
        uint64_t v8 = sub_1B6E073B8(48 * v7, 16);
        int v6 = *(_DWORD *)(a1 + 36);
      }
      else
      {
        uint64_t v8 = 0;
      }
      if (v6 >= 1)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 48 * v6;
        do
        {
          uint64_t v11 = (_OWORD *)(v8 + v9);
          uint64_t v12 = (long long *)(*(void *)(a1 + 48) + v9);
          long long v13 = *v12;
          long long v14 = v12[2];
          v11[1] = v12[1];
          uint64_t v11[2] = v14;
          *uint64_t v11 = v13;
          v9 += 48;
        }
        while (v10 != v9);
      }
      uint64_t v15 = *(void *)(a1 + 48);
      if (v15 && *(unsigned char *)(a1 + 56)) {
        sub_1B6E073C4(v15);
      }
      *(unsigned char *)(a1 + 56) = 1;
      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x200], 8) = v8;
      *(_DWORD *)(a1 + 40) = v7;
      int v6 = *(_DWORD *)(a1 + 36);
    }
  }
  uint64_t v16 = *(void *)(a1 + 48) + 48 * v6;
  __n128 result = *(__n128 *)a2;
  long long v18 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v16 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v16 + 32) = v18;
  *(__n128 *)uint64_t v16 = result;
  LODWORD(v16) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = v16 + 1;
  *(_DWORD *)(*(void *)(a1 + 48) + 48 * (int)v16 + 36) = a3;
  return result;
}

uint64_t sub_1B65536B8(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == sub_1B64AB0F8())
  {
    return sub_1B655342C((uint64_t)a1);
  }
  else
  {
    if (v2 != sub_1B64A06D4()) {
      return 0;
    }
    uint64_t v4 = sub_1B6E073B8(96, 16);
    sub_1B6554D14(v4, (uint64_t)a1, v5, v6, v7, v8, v9, v10);
    return v4;
  }
}

void sub_1B655373C(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6553750(void *a1)
{
  uint64_t v2 = sub_1B65536B8(a1);
  if (!v2) {
    return v2;
  }
  CFArrayRef v41 = (id *)a1;
  int v3 = 0;
  int v4 = 0;
  uint64_t v5 = 0;
  for (int i = 0; ; ++i)
  {
    uint64_t v7 = v5;
    int v8 = v4;
    if (i >= (*(int (**)(uint64_t))(*(void *)v2 + 56))(v2)) {
      break;
    }
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    int v45 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    int v42 = 0;
    (*(void (**)(uint64_t, uint64_t *, char *, uint64_t *, int *, uint64_t *, char *, uint64_t *, int *, int))(*(void *)v2 + 32))(v2, &v47, (char *)&v46 + 4, &v46, &v45, &v44, (char *)&v43 + 4, &v43, &v42, i);
    v4 += HIDWORD(v46);
    if ((v46 & 0x8000000000000000) == 0 && HIDWORD(v46) && v3 < v4)
    {
      if (v4) {
        uint64_t v5 = sub_1B6E073B8(16 * v4, 16);
      }
      else {
        uint64_t v5 = 0;
      }
      if (v8 >= 1)
      {
        uint64_t v15 = v8;
        uint64_t v16 = (_OWORD *)v5;
        int v17 = (long long *)v7;
        do
        {
          long long v18 = *v17++;
          *v16++ = v18;
          --v15;
        }
        while (v15);
LABEL_16:
        sub_1B6E073C4(v7);
        int v3 = v4;
        goto LABEL_17;
      }
      if (v7) {
        goto LABEL_16;
      }
      int v3 = v4;
    }
LABEL_17:
    if (v46)
    {
      if ((byte_1E9DDB568 & 1) == 0)
      {
        byte_1E9DDB568 = 1;
        sub_1B63F2F54(16, @"Error: vertex format not supported for physics shape creation (%d)", v9, v10, v11, v12, v13, v14, v46);
      }
    }
    else
    {
      uint64_t v19 = HIDWORD(v46);
      if (SHIDWORD(v46) >= 1)
      {
        uint64_t v20 = v45;
        uint64_t v21 = (_OWORD *)(v5 + 16 * v8);
        uint64_t v22 = (_DWORD *)(v47 + 8);
        do
        {
          *(void *)&long long v23 = *((void *)v22 - 1);
          DWORD2(v23) = *v22;
          uint64_t v22 = (_DWORD *)((char *)v22 + v20);
          *((void *)&v23 + 1) = DWORD2(v23);
          *v21++ = v23;
          --v19;
        }
        while (v19);
      }
    }
  }
  uint64_t v24 = sub_1B6E073B8(128, 16);
  sub_1B6DE8408(v24, v2, 1);
  uint64_t v25 = sub_1B6E073B8(80, 16);
  double v26 = sub_1B6DEC8B0(v25, v24);
  (*(void (**)(uint64_t, double))(*(void *)v24 + 96))(v24, v26);
  sub_1B6DEC960(v25);
  (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  uint64_t v27 = *(void *)(v25 + 16);
  uint64_t v28 = sub_1B6DECF8C(v25);
  uint64_t v29 = *(void *)(v25 + 48);
  unint64_t v30 = sub_1B6DECF74(v25);
  if (v28 && v27)
  {
    unint64_t v31 = v30;
    uint64_t v2 = sub_1B6E073B8(192, 16);
    sub_1B6DE5EC4(v2, v27, v28, 16, v29, v31);
  }
  else
  {
    uint64_t v32 = sub_1B6583674(v41);
    sub_1B63F2F54(0, @"Warning: Cannot create convex hull for entity %@", v33, v34, v35, v36, v37, v38, (uint64_t)v32);
    uint64_t v2 = 0;
  }
  uint64_t v39 = sub_1B6DEC95C(v25);
  sub_1B6E073C4(v39);
  if (v7) {
    sub_1B6E073C4(v7);
  }
  return v2;
}

void sub_1B6553A84(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v2);
  if (v1) {
    sub_1B6E073C4(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1B6553AF0(const void *a1)
{
  if (sub_1B65536B8(a1))
  {
    sub_1B6E073B8(112, 16);
    sub_1B6DE2C98();
    operator new();
  }
  return 0;
}

void sub_1B6553B70(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;
  MEMORY[0x1BA9B6D80](v2, 0x10B1C403C62072ELL);
  _Unwind_Resume(a1);
}

double sub_1B6553BA8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend__shapeHandle_(a2, (const char *)a2, 0, a4);
  if (v6)
  {
    uint64_t v10 = (_DWORD *)v6;
    uint64_t v11 = objc_msgSend_objectAtIndex_(*(void **)(a1 + 32), v7, a3, v8);
    if (v11 && (uint64_t v12 = (void *)v11, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      objc_msgSend_VFXMatrix4Value(v12, v13, v14, v15);
      *(void *)&long long v18 = __PAIR64__(v17, v16);
      *(void *)&long long v21 = __PAIR64__(v20, v19);
      DWORD1(v23) = v22;
      *((void *)&v23 + 1) = v24;
      *((void *)&v18 + 1) = v25;
      *((void *)&v21 + 1) = v26;
      HIDWORD(v27) = 0;
      long long v28 = v23;
      long long v29 = v18;
      long long v30 = v21;
      long long v31 = v27;
    }
    else
    {
      long long v28 = xmmword_1B6E4F300;
      long long v29 = xmmword_1B6E4F320;
      long long v30 = xmmword_1B6E4F2E0;
      long long v31 = 0uLL;
    }
    *(void *)&double result = sub_1B6DE49E8(*(void *)(a1 + 40), (__n128 *)&v28, v10, 0).n128_u64[0];
  }
  return result;
}

uint64_t sub_1B6553C9C(void *cf, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  switch(a2)
  {
    case 3:
      return 0;
    case 2:
      return sub_1B6553AF0(cf);
    case 1:
      v19.i32[2] = 0;
      v19.i64[0] = 0;
      v18.i32[2] = 0;
      v18.i64[0] = 0;
      CFTypeID v3 = CFGetTypeID(cf);
      if (v3 == sub_1B64AB0F8()) {
        sub_1B64AB620((uint64_t)cf, &v19, &v18, v4, v5, v6, v7, v8);
      }
      else {
        sub_1B63F493C(cf, 1, (uint64_t)&v19, (uint64_t)&v18, v5, v6, v7, v8);
      }
      int8x16_t v11 = (int8x16_t)vrev64q_s32(v19);
      int8x16_t v12 = vextq_s8(v18, (int8x16_t)v19, 4uLL);
      int8x16_t v13 = vextq_s8(v12, v12, 8uLL);
      v13.i32[0] = v19.i32[2];
      *(void *)&long long v14 = v18.i64[0];
      *((void *)&v14 + 1) = __PAIR64__(v18.u32[0], v19.u32[2]);
      int32x4_t v15 = v19;
      v15.i32[3] = v19.i32[0];
      int8x16_t v16 = vextq_s8((int8x16_t)v19, v11, 4uLL);
      int32x4_t v17 = vzip1q_s32((int32x4_t)v11, (int32x4_t)v18);
      v17.i32[1] = v18.i32[2];
      v21[0] = v15;
      v21[1] = v17;
      uint64_t v21[2] = v13;
      __int32 v22 = v18.i32[0];
      v16.i32[2] = v18.i32[0];
      int8x16_t v23 = v16;
      __int32 v24 = v18.i32[2];
      long long v25 = v14;
      int8x8_t v26 = vext_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), 4uLL);
      v20[6] = xmmword_1B6E521E0;
      v20[7] = unk_1B6E521F0;
      v20[8] = xmmword_1B6E52200;
      v20[2] = xmmword_1B6E521A0;
      v20[3] = unk_1B6E521B0;
      v20[4] = xmmword_1B6E521C0;
      void v20[5] = unk_1B6E521D0;
      v20[0] = xmmword_1B6E52180;
      v20[1] = unk_1B6E52190;
      uint64_t v9 = sub_1B6E073B8(192, 16);
      sub_1B6DE5EC4(v9, v21, 8, 12, v20, 12);
      return v9;
    default:
      return sub_1B6553750(cf);
  }
}

void sub_1B6553EB0(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6553ECC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B649F5F4(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
  int v11 = *(_DWORD *)(v10 + 24);
  if (v9) {
    ++v11;
  }
  *(_DWORD *)(v10 + 24) = v11;
  return 2 * (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) > 1);
}

uint64_t sub_1B6553F24(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B649F5F4(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v11 = sub_1B6554050(v10, a1[6].i64[0]);
    if (v11)
    {
      int32x4_t v19 = (_DWORD *)v11;
      float32x4_t v30 = a1[2];
      float32x4_t v31 = a1[3];
      float32x4_t v28 = a1[5];
      float32x4_t v29 = a1[4];
      unsigned int v20 = (_OWORD *)sub_1B64A01D4(a2, v12, v13, v14, v15, v16, v17, v18);
      uint64_t v21 = 0;
      long long v22 = v20[1];
      long long v23 = v20[2];
      long long v24 = v20[3];
      v32[0] = *v20;
      v32[1] = v22;
      v32[2] = v23;
      v32[3] = v24;
      do
      {
        *(float32x4_t *)((char *)&v33 + v21 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v30, COERCE_FLOAT(v32[v21])), v31, *(float32x2_t *)&v32[v21], 1), v29, (float32x4_t)v32[v21], 2), v28, (float32x4_t)v32[v21], 3);
        ++v21;
      }
      while (v21 != 4);
      int8x16_t v25 = v33;
      int8x16_t v26 = v34;
      *(int32x2_t *)v33.i8 = vzip1_s32(*(int32x2_t *)v33.i8, *(int32x2_t *)v34.i8);
      v33.i64[1] = v35.u32[0];
      *(int32x2_t *)v34.i8 = vzip2_s32(*(int32x2_t *)v25.i8, *(int32x2_t *)v34.i8);
      v34.i64[1] = v35.u32[1];
      int32x2_t v35 = vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
      uint64_t v36 = v36;
      HIDWORD(v37) = 0;
      sub_1B6DE49E8(a1[6].i64[1], (__n128 *)&v33, v19, 1);
    }
  }
  return 0;
}

uint64_t sub_1B6554050(void *a1, uint64_t a2)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = CFGetTypeID(a1);
  if (a2 != 1 && v4 == sub_1B6559034())
  {
    memset(&__s1, 0, 48);
    sub_1B6558FD8((uint64_t)a1, v5, v6, v7, v8, v9, v10, (uint64_t)&__s1);
    if (!memcmp(&__s1, &xmmword_1F0FB86B0, 0x30uLL))
    {
      double v32 = sub_1B65593E4((uint64_t)a1, 0);
      float v33 = *(float *)&v32;
      double v34 = sub_1B65593E4((uint64_t)a1, 1);
      float v35 = *(float *)&v34;
      double v36 = sub_1B65593E4((uint64_t)a1, 2);
      float v37 = *(float *)&v36;
      uint64_t v15 = sub_1B6E073B8(80, 16);
      *(float *)&long long v82 = v33 * 0.5;
      *((float *)&v82 + 1) = v35 * 0.5;
      *((float *)&v82 + 2) = v37 * 0.5;
      HIDWORD(v82) = 0;
      sub_1B6DE2188(v15, &v82);
      return v15;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB9418, 0x30uLL))
    {
      double v38 = sub_1B65593E4((uint64_t)a1, 0);
      float v39 = *(float *)&v38;
      double v40 = sub_1B65593E4((uint64_t)a1, 1);
      unsigned __int32 v41 = LODWORD(v40);
      double v42 = sub_1B65593E4((uint64_t)a1, 2);
      LODWORD(v82) = 0;
      DWORD1(v82) = v41;
      *((void *)&v82 + 1) = 0;
      float v83 = v39 * -0.5;
      int v84 = 0;
      float v85 = *(float *)&v42 * -0.5;
      int v86 = 0;
      float v87 = v39 * -0.5;
      int v88 = 0;
      float v89 = *(float *)&v42 * 0.5;
      int v90 = 0;
      float v91 = v39 * 0.5;
      int v92 = 0;
      float v93 = *(float *)&v42 * -0.5;
      int v94 = 0;
      float v95 = v39 * 0.5;
      int v96 = 0;
      float v97 = *(float *)&v42 * 0.5;
      int v98 = 0;
      uint64_t v15 = sub_1B6E073B8(192, 16);
      sub_1B6DE5EC4(v15, &v82, 5, 16, 0, 0);
      return v15;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB8D58, 0x30uLL)) {
      goto LABEL_26;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB8BA8, 0x30uLL))
    {
      double v53 = sub_1B65593E4((uint64_t)a1, 5);
      if (*(float *)&v53 != 0.0 && (byte_1E9DDB569 & 1) == 0)
      {
        byte_1E9DDB569 = 1;
        sub_1B63F2F54(16, @"Warning: VFXPhysicsShape does not support a VFXCone with TopRadius != 0.0", v47, v48, v49, v50, v51, v52, v76);
      }
      double v54 = sub_1B65593E4((uint64_t)a1, 4);
      float v55 = *(float *)&v54;
      double v56 = sub_1B65593E4((uint64_t)a1, 1);
      float v57 = *(float *)&v56;
      uint64_t v15 = sub_1B6E073B8(96, 16);
      sub_1B6DE5808(v15, v55, v57);
      return v15;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB9928, 0x30uLL))
    {
LABEL_26:
      double v43 = sub_1B65593E4((uint64_t)a1, 4);
      unsigned __int32 v44 = LODWORD(v43);
      double v45 = sub_1B65593E4((uint64_t)a1, 1);
      float v46 = *(float *)&v45;
      uint64_t v15 = sub_1B6E073B8(80, 16);
      LODWORD(v82) = v44;
      *((float *)&v82 + 1) = v46 * 0.5;
      *((void *)&v82 + 1) = v44;
      sub_1B6DE8960(v15, &v82);
      return v15;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB8B78, 0x30uLL))
    {
      double v58 = sub_1B65593E4((uint64_t)a1, 4);
      float v59 = *(float *)&v58;
      double v60 = sub_1B65593E4((uint64_t)a1, 1);
      float v61 = *(float *)&v60;
      uint64_t v15 = sub_1B6E073B8(80, 16);
      sub_1B6DE3A40(v15, v59, v61 + (float)(v59 * -2.0));
      return v15;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB9838, 0x30uLL))
    {
      LODWORD(v7_Block_object_dispose(&STACK[0x200], 8) = COERCE_UNSIGNED_INT64(sub_1B65593E4((uint64_t)a1, 4));
      double v62 = sub_1B65593E4((uint64_t)a1, 7);
      uint64_t v63 = 0;
      int32x2_t v64 = vdup_lane_s32(*(int32x2_t *)&v62, 0);
      int32x2_t v65 = (int32x2_t)0x100000000;
      long long v66 = (float *)&v82;
      float64x2_t v77 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
      uint64_t v67 = 0;
      do
      {
        float64x2_t v68 = vmulq_f64(vcvtq_f64_f32(vmul_f32(vcvt_f32_s32(v65), (float32x2_t)0x3E0000003E000000)), v77);
        *(float32x2_t *)&v68.f64[0] = vcvt_f32_f64(vaddq_f64(v68, v68));
        float v79 = *(float *)v68.f64;
        __float2 v69 = __sincosf_stret(*((float *)v68.f64 + 1));
        __float2 v70 = __sincosf_stret(v79);
        float32x2_t v71 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v69.__sinval), LODWORD(v70.__sinval)), v78);
        float32x2_t v72 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v69.__cosval), LODWORD(v70.__cosval)), v78);
        uint64_t v73 = 0;
        vst4_f32(v66, *(float32x2x4_t *)(&v67 - 1));
        v66 += 8;
        *(int32x2_t *)&v81[v63] = v64;
        int32x2_t v65 = vadd_s32(v65, (int32x2_t)0x200000002);
        v63 += 8;
      }
      while (v63 != 32);
      uint64_t v15 = sub_1B6E073B8(192, 16);
      sub_1B6DE93A0(v15, &v82, v81, 8);
      return v15;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB96E8, 0x30uLL))
    {
      double v74 = sub_1B65593E4((uint64_t)a1, 4);
      int v75 = LODWORD(v74);
      uint64_t v15 = sub_1B6E073B8(80, 16);
      sub_1B6DE65E4(v15);
      *(void *)uint64_t v15 = &unk_1F0FB07C0;
      *(_DWORD *)(v15 + _Block_object_dispose(&STACK[0x200], 8) = 8;
      *(_DWORD *)(v15 + 4_Block_object_dispose(&STACK[0x200], 8) = v75;
      *(_DWORD *)(v15 + 64) = v75;
      return v15;
    }
    if (!memcmp(&__s1, &xmmword_1F0FB9388, 0x30uLL))
    {
      double v11 = sub_1B65593E4((uint64_t)a1, 0);
      float v12 = *(float *)&v11;
      double v13 = sub_1B65593E4((uint64_t)a1, 1);
      float v14 = *(float *)&v13;
      uint64_t v15 = sub_1B6E073B8(224, 16);
      *(float *)&long long v82 = v12 * 0.5;
      *((float *)&v82 + 1) = v14 * 0.5;
      *((void *)&v82 + 1) = 0;
      sub_1B6555810(v15, (float32x2_t *)&v82);
      return v15;
    }
    return 0;
  }
  if (v4 == sub_1B651930C())
  {
    long long v23 = (__n128 *)sub_1B63F4F54(a1, v16, v17, v18, v19, v20, v21, v22);
    DWORD2(v82) = 0;
    *(void *)&long long v82 = 0;
    if (v23) {
      sub_1B64B2438(v23, (__n128 *)&v82, v24, v25, v26, v27, v28, v29);
    }
    else {
      long long v82 = xmmword_1B6E4F320;
    }
    uint64_t v15 = sub_1B6E073B8(112, 16);
    __s1.i64[0] = v82;
    __s1.i64[1] = DWORD2(v82);
    sub_1B6DED28C(v15, &__s1, 0.0);
    return v15;
  }
  float32x4_t v30 = (void *)sub_1B63CCE68((uint64_t)a1, v16, v17, v18, v19, v20, v21, v22);
  if (!v30) {
    return 0;
  }

  return sub_1B6553C9C(v30, a2);
}

void sub_1B65546BC(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

void sub_1B655483C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6554854(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = NSString;
  uint64_t v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v8 = *(unsigned int *)(v7 + 24);
  *(_DWORD *)(v7 + 24) = v8 + 1;
  uint64_t v9 = (const char *)objc_msgSend_stringWithFormat_(v5, a2, @"transform%d", a4, v8);
  objc_msgSend_VFXMatrix4Value(a2, v10, v11, v12);

  return sub_1B64FA3B8(v6, v9, v13, v14, v15, v16);
}

uint64_t sub_1B6554D14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_OWORD *)(a1 + 16) = xmmword_1B6E4F540;
  *(void *)a1 = &unk_1F0FB1C10;
  *(unsigned char *)(a1 + 56) = 1;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(void *)(a1 + 36) = 0;
  *(unsigned char *)(a1 + 8_Block_object_dispose(&STACK[0x200], 8) = 1;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 6_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(double *)&long long v10 = sub_1B64A2220(a2, a2, a3, a4, a5, a6, a7, a8);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  _OWORD v15[2] = sub_1B6554E20;
  v15[3] = &unk_1E6144408;
  uint64_t v20 = a1;
  long long v16 = v10;
  long long v17 = v11;
  long long v18 = v12;
  long long v19 = v13;
  sub_1B64A18A4(a2, (uint64_t)v15);
  return a1;
}

void sub_1B6554DF8(_Unwind_Exception *a1)
{
  sub_1B6441B40(v1 + 64);
  sub_1B6441B40(v1 + 32);
  nullsub_1(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6554E20(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a1[6].i64[0];
  uint64_t v11 = sub_1B649F5F4(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v11)
  {
    uint64_t v19 = sub_1B63CCE68(v11, v12, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      uint64_t v27 = (const void *)v19;
      float32x4_t v95 = a1[2];
      float32x4_t v97 = a1[3];
      float32x4_t v91 = a1[5];
      float32x4_t v93 = a1[4];
      uint64_t v28 = (_OWORD *)sub_1B64A01D4(a2, v20, v21, v22, v23, v24, v25, v26);
      uint64_t v33 = 0;
      long long v34 = v28[1];
      long long v35 = v28[2];
      long long v36 = v28[3];
      v99[0] = *v28;
      v99[1] = v34;
      v99[2] = v35;
      uint64_t v99[3] = v36;
      do
      {
        v100[v33] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v95, COERCE_FLOAT(v99[v33])), v97, *(float32x2_t *)&v99[v33], 1), v93, (float32x4_t)v99[v33], 2), v91, (float32x4_t)v99[v33], 3);
        ++v33;
      }
      while (v33 != 4);
      float32x4_t v96 = (float32x4_t)v100[1];
      float32x4_t v98 = (float32x4_t)v100[0];
      float32x4_t v92 = (float32x4_t)v100[3];
      float32x4_t v94 = (float32x4_t)v100[2];
      float v37 = sub_1B64AC5F8((uint64_t)v27, 0, 0, 1, v29, v30, v31, v32);
      if (v37)
      {
        uint64_t v45 = (uint64_t)v37;
        uint64_t v46 = sub_1B641E1A8((uint64_t)v37, v38, v39, v40, v41, v42, v43, v44);
        uint64_t v47 = sub_1B65349B8(v46);
        uint64_t v55 = sub_1B641D8A0(v45, v48, v49, v50, v51, v52, v53, v54);
        CFDataRef v56 = (const __CFData *)sub_1B641D89C(v45);
        BytePtr = CFDataGetBytePtr(v56);
        int v58 = *(_DWORD *)(v10 + 68);
        int v59 = v58 + v55;
        if ((int)v55 >= 1 && *(_DWORD *)(v10 + 72) < v59)
        {
          if (v59) {
            uint64_t v60 = sub_1B6E073B8(16 * v59, 16);
          }
          else {
            uint64_t v60 = 0;
          }
          if (*(int *)(v10 + 68) >= 1)
          {
            uint64_t v61 = 0;
            uint64_t v62 = 16 * *(unsigned int *)(v10 + 68);
            do
            {
              *(_OWORD *)(v60 + v61) = *(_OWORD *)(*(void *)(v10 + 80) + v61);
              v61 += 16;
            }
            while (v62 != v61);
          }
          uint64_t v63 = *(void *)(v10 + 80);
          if (v63 && *(unsigned char *)(v10 + 88)) {
            sub_1B6E073C4(v63);
          }
          *(unsigned char *)(v10 + 8_Block_object_dispose(&STACK[0x200], 8) = 1;
          *(void *)(v10 + 80) = v60;
          *(_DWORD *)(v10 + 72) = v59;
        }
        *(_DWORD *)(v10 + 6_Block_object_dispose(&STACK[0x200], 8) = v59;
        int v64 = sub_1B6534654(v46);
        if (v64 == 6 || (unsigned __int16)v64 == 1)
        {
          if (v55 >= 1)
          {
            int v73 = v58;
            uint64_t v74 = v55;
            do
            {
              if (v64 == 1)
              {
                v72.i64[0] = *(void *)BytePtr;
                v72.i32[2] = *((_DWORD *)BytePtr + 2);
              }
              else
              {
                float32x4_t v72 = *(float32x4_t *)BytePtr;
                *(float32x2_t *)v72.f32 = vcvt_f32_f64(*(float64x2_t *)BytePtr);
                float32_t v75 = *((double *)BytePtr + 2);
                v72.f32[2] = v75;
              }
              float32x4_t v76 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v92, v94, v72, 2), v96, *(float32x2_t *)v72.f32, 1), v98, v72.f32[0]);
              v76.i32[3] = 0;
              *(float32x4_t *)(*(void *)(v10 + 80) + 16 * v73++) = v76;
              BytePtr += v47;
              --v74;
            }
            while (v74);
          }
        }
        else
        {
          sub_1B63F2F54(0, @"Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)", v66, v67, v68, v69, v70, v71, v64);
        }
        CFArrayRef v77 = sub_1B64ABD08((uint64_t)v27, v65, v66, v67, v68, v69, v70, v71);
        if ((uint64_t)v77 >= 1)
        {
          CFArrayRef v78 = v77;
          for (CFArrayRef i = 0; i != v78; CFArrayRef i = (const __CFArray *)((char *)i + 1))
          {
            CFRetain(v27);
            int v80 = *(_DWORD *)(v10 + 36);
            if (v80 == *(_DWORD *)(v10 + 40))
            {
              int v81 = v80 ? 2 * v80 : 1;
              if (v80 < v81)
              {
                if (v81)
                {
                  uint64_t v82 = sub_1B6E073B8(32 * v81, 16);
                  int v80 = *(_DWORD *)(v10 + 36);
                }
                else
                {
                  uint64_t v82 = 0;
                }
                if (v80 >= 1)
                {
                  uint64_t v83 = 0;
                  uint64_t v84 = 32 * v80;
                  do
                  {
                    float v85 = (_OWORD *)(v82 + v83);
                    int v86 = (_OWORD *)(*(void *)(v10 + 48) + v83);
                    long long v87 = v86[1];
                    *float v85 = *v86;
                    v85[1] = v87;
                    v83 += 32;
                  }
                  while (v84 != v83);
                }
                uint64_t v88 = *(void *)(v10 + 48);
                if (v88 && *(unsigned char *)(v10 + 56)) {
                  sub_1B6E073C4(v88);
                }
                *(unsigned char *)(v10 + 56) = 1;
                *(void *)(v10 + 4_Block_object_dispose(&STACK[0x200], 8) = v82;
                *(_DWORD *)(v10 + 40) = v81;
                int v80 = *(_DWORD *)(v10 + 36);
              }
            }
            uint64_t v89 = *(void *)(v10 + 48) + 32 * v80;
            *(void *)uint64_t v89 = v27;
            *(void *)(v89 + _Block_object_dispose(&STACK[0x200], 8) = i;
            *(_DWORD *)(v89 + 16) = v58;
            *(_DWORD *)(v89 + 20) = v55;
            ++*(_DWORD *)(v10 + 36);
          }
        }
      }
    }
  }
  return 0;
}

void sub_1B6555174(uint64_t a1)
{
  sub_1B6555280(a1);

  sub_1B6E073C4(v1);
}

void sub_1B655519C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const void *sub_1B65551AC(uint64_t a1, void *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, const UInt8 **a6, _DWORD *a7, int *a8, int *a9, int a10)
{
  uint64_t v13 = *(void *)(a1 + 48) + 32 * a10;
  *a3 = *(_DWORD *)(v13 + 20);
  *a2 = *(void *)(a1 + 80) + 16 * *(int *)(v13 + 16);
  *a4 = 0;
  *a5 = 16;
  double result = sub_1B64ABD78(*(void *)v13, *(void *)(v13 + 8), 1, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8);
  if (result)
  {
    return (const void *)sub_1B655331C((uint64_t)result, a6, a7, a8, a9, v15, v16, v17);
  }
  return result;
}

uint64_t sub_1B6555258(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1B6555268()
{
  return 0;
}

uint64_t sub_1B6555278()
{
  return 32;
}

double sub_1B6555280(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB1C10;
  int v2 = *(_DWORD *)(a1 + 36);
  if (v2 >= 1)
  {
    uint64_t v3 = 0;
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v5 = *(const void **)(*(void *)(a1 + 48) + v3);
      if (v5)
      {
        CFRelease(v5);
        int v2 = *(_DWORD *)(a1 + 36);
      }
      v3 += 32;
    }
  }
  sub_1B6441B40(a1 + 64);
  sub_1B6441B40(a1 + 32);

  return nullsub_1(a1);
}

void sub_1B6555324(_Unwind_Exception *a1)
{
  sub_1B6441B40(v1 + 64);
  sub_1B6441B40(v1 + 32);
  nullsub_1(v1);
  _Unwind_Resume(a1);
}

double sub_1B655534C(uint64_t a1)
{
  *(unsigned char *)(a1 + 32) = 1;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 12) = 0;
  *(unsigned char *)(a1 + 64) = 1;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 44) = 0;
  *(unsigned char *)(a1 + 96) = 1;
  *(void *)(a1 + 8_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(void *)(a1 + 76) = 0;
  *(unsigned char *)(a1 + 12_Block_object_dispose(&STACK[0x200], 8) = 1;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 10_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(void *)a1 = &unk_1F0FB13A8;
  *(_OWORD *)(a1 + 136) = xmmword_1B6E52160;
  double result = 5.15555163e-67;
  *(void *)(a1 + 152) = 0x322BCC7640C90FDBLL;
  return result;
}

void sub_1B65553C0(uint64_t a1)
{
  sub_1B65557C8(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B65553F8()
{
  return 72;
}

const char *sub_1B6555400(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 4_Block_object_dispose(&STACK[0x200], 8) = *(_DWORD *)(a1 + 156);
  int v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 56) = v6;
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 24));
    *(void *)a2 = v7;
    if (v7)
    {
      uint64_t v8 = *(unsigned int *)(a2 + 56);
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 4, v8);
      uint64_t v10 = *(void *)(a1 + 24);
      if ((int)v8 >= 1)
      {
        uint64_t v11 = *(_DWORD **)(v9 + 8);
        uint64_t v12 = *(int **)(a1 + 24);
        do
        {
          int v13 = *v12++;
          *v11++ = v13;
          --v8;
        }
        while (v8);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v9, "int", 1497453121, v10);
    }
  }
  else
  {
    *(void *)a2 = 0;
  }
  int v14 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a2 + 52) = v14;
  if (v14)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 56));
    *(void *)(a2 + _Block_object_dispose(&STACK[0x200], 8) = v15;
    if (v15)
    {
      uint64_t v16 = *(unsigned int *)(a2 + 52);
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 4, v16);
      uint64_t v18 = *(void *)(a1 + 56);
      if ((int)v16 >= 1)
      {
        uint64_t v19 = *(_DWORD **)(v17 + 8);
        uint64_t v20 = *(int **)(a1 + 56);
        do
        {
          int v21 = *v20++;
          *v19++ = v21;
          --v16;
        }
        while (v16);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v17, "int", 1497453121, v18);
    }
  }
  else
  {
    *(void *)(a2 + _Block_object_dispose(&STACK[0x200], 8) = 0;
  }
  int v22 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)(a2 + 60) = v22;
  if (v22)
  {
    uint64_t v23 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 88));
    *(void *)(a2 + 16) = v23;
    if (v23)
    {
      uint64_t v24 = *(unsigned int *)(a2 + 60);
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 16, v24);
      uint64_t v26 = *(void *)(a1 + 88);
      if ((int)v24 >= 1)
      {
        uint64_t v27 = *(void *)(v25 + 8);
        uint64_t v28 = *(int **)(a1 + 88);
        do
        {
          *(void *)(v27 + 4) = *(void *)(v28 + 1);
          *(_DWORD *)(v27 + 12) = v28[3];
          int v29 = *v28;
          v28 += 4;
          *(_DWORD *)uint64_t v27 = v29;
          v27 += 16;
          --v24;
        }
        while (v24);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v25, "btTriangleInfoData", 1497453121, v26);
    }
  }
  else
  {
    *(void *)(a2 + 16) = 0;
  }
  int v30 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(a2 + 64) = v30;
  if (v30)
  {
    uint64_t v31 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 56))(a3, *(void *)(a1 + 120));
    *(void *)(a2 + 24) = v31;
    if (v31)
    {
      uint64_t v32 = *(unsigned int *)(a2 + 60);
      uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 4, v32);
      uint64_t v34 = *(void *)(a1 + 120);
      if ((int)v32 >= 1)
      {
        long long v35 = *(_DWORD **)(v33 + 8);
        long long v36 = *(int **)(a1 + 120);
        do
        {
          int v37 = *v36++;
          *v35++ = v37;
          --v32;
        }
        while (v32);
      }
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(void *)a3 + 40))(a3, v33, "int", 1497453121, v34);
    }
  }
  else
  {
    *(void *)(a2 + 24) = 0;
  }
  return "btTriangleInfoMapData";
}

uint64_t sub_1B65557C8(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  sub_1B6441B40(a1 + 104);
  sub_1B6441B40(a1 + 72);
  sub_1B6441B40(a1 + 40);
  sub_1B6441B40(v2);
  return a1;
}

uint64_t sub_1B6555810(uint64_t a1, float32x2_t *a2)
{
  sub_1B6DEA398(a1);
  *(void *)uint64_t v4 = &unk_1F0FB05E0;
  *(void *)(v4 + 80) = 0;
  *(void *)(v4 + 8_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(float32x2_t *)(v4 + 96) = vneg_f32(*a2);
  *(void *)(v4 + 104) = 0;
  float v5 = -a2->f32[1];
  *(_DWORD *)(v4 + 112) = a2->i32[0];
  *(float *)(v4 + 116) = v5;
  *(void *)(v4 + 120) = 0;
  *(_DWORD *)(v4 + 12_Block_object_dispose(&STACK[0x200], 8) = a2->i32[0];
  *(_DWORD *)(v4 + 132) = a2->i32[1];
  *(void *)(v4 + 136) = 0;
  *(float *)(v4 + 144) = -a2->f32[0];
  *(_DWORD *)(v4 + 14_Block_object_dispose(&STACK[0x200], 8) = a2->i32[1];
  *(_OWORD *)(v4 + 152) = xmmword_1B6E50860;
  *(void *)(v4 + 16_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(_DWORD *)(v4 + 176) = 1065353216;
  *(void *)(v4 + 18_Block_object_dispose(&STACK[0x200], 8) = 0;
  *(void *)(v4 + 180) = 0;
  *(_OWORD *)(v4 + 196) = xmmword_1B6E52170;
  *(void *)(v4 + 212) = 0;
  *(_DWORD *)(v4 + 220) = 0;
  if (a2->f32[0] <= a2->f32[1]) {
    float v6 = a2->f32[0];
  }
  else {
    float v6 = a2->f32[1];
  }
  float v7 = off_1F0FB0640(v4);
  v8.n128_f32[0] = v6 * 0.1;
  if ((float)(v6 * 0.1) < v7) {
    (*(void (**)(uint64_t, float))(*(void *)a1 + 88))(a1, v8.n128_f32[0]);
  }
  *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x200], 8) = 17;
  v14.i64[0] = (*(double (**)(uint64_t, __n128))(*(void *)a1 + 96))(a1, v8);
  __int32 v13 = COERCE_UNSIGNED_INT64((*(double (**)(uint64_t))(*(void *)a1 + 96))(a1));
  float v9 = (*(float (**)(uint64_t))(*(void *)a1 + 96))(a1);
  float32x4_t v10 = v14;
  v10.i32[1] = v13;
  v10.f32[2] = v9;
  float32x4_t v11 = vsubq_f32(vmulq_f32(*(float32x4_t *)a2->f32, *(float32x4_t *)(a1 + 32)), v10);
  v11.i32[3] = 0;
  *(float32x4_t *)(a1 + 4_Block_object_dispose(&STACK[0x200], 8) = v11;
  return a1;
}

void sub_1B65559F8(_Unwind_Exception *a1)
{
  sub_1B6DEA3D0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6555A18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v53 = a2;
  *((void *)&v53 + 1) = a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB598, memory_order_acquire) & 1) == 0)
  {
    uint64_t v43 = a2;
    int v42 = __cxa_guard_acquire(&qword_1E9DDB598);
    a2 = v43;
    if (v42)
    {
      qword_1E9DDB590 = (uint64_t)sub_1B6555F90("MIRROR_PASS", 0xBu);
      __cxa_guard_release(&qword_1E9DDB598);
      a2 = v43;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, qword_1E9DDB590, a6);
  *(void *)a1 = &unk_1F0FB2FE8;
  *(void *)(a1 + 392) = 0;
  long long v11 = *(_OWORD *)(a5 + 24);
  long long v12 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 416) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 432) = v12;
  *(_OWORD *)(a1 + 400) = v11;
  long long v13 = *(_OWORD *)(a5 + 72);
  long long v14 = *(_OWORD *)(a5 + 88);
  long long v15 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 496) = v15;
  *(_OWORD *)(a1 + 44_Block_object_dispose(&STACK[0x200], 8) = v13;
  *(_OWORD *)(a1 + 464) = v14;
  long long v16 = *(_OWORD *)(a5 + 136);
  long long v17 = *(_OWORD *)(a5 + 152);
  long long v18 = *(_OWORD *)(a5 + 168);
  *(void *)(a1 + 560) = *(void *)(a5 + 184);
  *(_OWORD *)(a1 + 52_Block_object_dispose(&STACK[0x200], 8) = v17;
  *(_OWORD *)(a1 + 544) = v18;
  *(_OWORD *)(a1 + 512) = v16;
  *(_OWORD *)(a1 + 56_Block_object_dispose(&STACK[0x200], 8) = 0u;
  uint64_t v26 = sub_1B649FCB4(*(void *)(a1 + 400), v19, v20, v21, v22, v23, v24, v25);
  v45[0] = *(void *)(a1 + 368);
  char v56 = 0;
  char v57 = 0;
  uint64_t v55 = 0;
  long long v54 = 0uLL;
  uint64_t v58 = sub_1B6519AFC(v26);
  uint64_t v59 = 0;
  char v60 = *(unsigned char *)(a1 + 376);
  char v61 = sub_1B6447BF0(*(void *)(a1 + 368));
  uint64_t v62 = 2;
  int v63 = 1;
  __int16 v64 = 1;
  *(void *)(a1 + 384) = sub_1B63F9384(v53, *((uint64_t *)&v53 + 1), (uint64_t *)&v53, v45, &v54);
  uint64_t v47 = 0;
  __int16 v48 = 0;
  char v49 = 0;
  uint64_t v50 = 3;
  __int16 v51 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB598, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB598))
  {
    qword_1E9DDB590 = (uint64_t)sub_1B6555F90("MIRROR_PASS", 0xBu);
    __cxa_guard_release(&qword_1E9DDB598);
  }
  uint64_t v52 = qword_1E9DDB590;
  uint64_t v27 = *(void *)(a1 + 368);
  long long v54 = v53;
  uint64_t v28 = sub_1B63C8330(&v54, 0x40u, 8u);
  __n128 v29 = sub_1B6460520(v28, v27, (uint64_t)&v47, *(void *)(a1 + 384));
  *(void *)(a1 + 392) = v30;
  uint64_t v31 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 32))(a1, v29);
  *(_OWORD *)uint64_t v31 = 0u;
  *(_OWORD *)(v31 + 16) = 0u;
  *(unsigned char *)(v31 + 269) = 1;
  CFX::RG::TextureDescriptorReference::withSampleCount((_OWORD *)(a1 + 408), *(unsigned __int8 *)(v26 + 224), (uint64_t)v45);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v45, MTLPixelFormatRGBA16Float, (uint64_t)&v54);
  CFX::RG::TextureDescriptorReference::withSizeFactor(&v54, *(float *)(v26 + 220), v46);
  uint64_t v32 = sub_1B63CFDE4(a4, (uint64_t)"COLOR_MIRROR_MAP", v46);
  *(void *)(a1 + 56_Block_object_dispose(&STACK[0x200], 8) = v32;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v32, 0x100000002, 0);
  CFX::RG::TextureDescriptorReference::withSampleCount((_OWORD *)(a1 + 408), *(unsigned __int8 *)(v26 + 224), (uint64_t)v45);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v45, MTLPixelFormatDepth32Float, (uint64_t)&v54);
  CFX::RG::TextureDescriptorReference::withSizeFactor(&v54, *(float *)(v26 + 220), v44);
  uint64_t v33 = sub_1B63CFDE4(a4, (uint64_t)"DEPTH_MIRROR_MAP", v44);
  CFX::RG::Pass::renderTo(a1, (uint64_t)v33, 0x200000002, -1);
  if (sub_1B6519838(v26, v34, v35, v36, v37, v38, v39, v40) != 0.0) {
    *(void *)(a1 + 576) = v33;
  }
  return a1;
}

void sub_1B6555D90(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6555DBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB578, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB578))
  {
    qword_1E9DDB570 = (uint64_t)sub_1B6555F90("VFX-Floor-color", 0xFu);
    __cxa_guard_release(&qword_1E9DDB578);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDB588, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDB588))
  {
    qword_1E9DDB580 = (uint64_t)sub_1B6555F90("VFX-Floor-depth", 0xFu);
    __cxa_guard_release(&qword_1E9DDB588);
  }
  uint64_t v10 = *(void *)(a1 + 400);
  unint64_t v11 = 0x9DDFEA08EB382D69
      * (qword_1E9DDB570 ^ ((0x9DDFEA08EB382D69 * (qword_1E9DDB570 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                     * (qword_1E9DDB570 ^ v10)));
  unint64_t v12 = v11 ^ (v11 >> 47);
  uint64_t v13 = qword_1E9DDB580;
  uint64_t v14 = sub_1B649FCB4(v10, a2, a3, a4, a5, a6, a7, a8);
  __n128 v24 = sub_1B64471F4(*(void *)(a1 + 368), 0, v15, v16, v17, v18, v19, v20);
  *(float32x2_t *)&v24.n128_i8[8] = vmul_n_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL), *(float *)(v14 + 220));
  uint64_t v25 = *(__n128 **)(a1 + 384);
  if (!v25[5].n128_u8[0]) {
    v25[5].n128_u8[0] = 1;
  }
  v25[4] = v24;
  sub_1B65A8594(*(__n128 **)(a1 + 384), v21, v22, v23);
  sub_1B65A88F8(*(void *)(a1 + 384), v26, v27, v28, v29, v30, v31, v32);
  sub_1B65A8D2C(*(void *)(a1 + 384), *(void *)(a1 + 400), v33, v34, v35, v36, v37, v38);
  sub_1B65A8D10(*(void *)(a1 + 384));
  sub_1B65A8D34(*(void *)(a1 + 384), *(void *)(a1 + 400), v39, v40, v41, v42, v43, v44);
  sub_1B65A8D3C(*(void *)(a1 + 384), v45, v46, v47, v48, v49, v50, v51);
  CFX::GPUResourceManager::registerNamedFrameResource(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568), -348639895 * v12);
  long long v53 = *(const CFX::RG::Resource **)(a1 + 576);
  if (v53) {
    CFX::GPUResourceManager::registerNamedFrameResource(*(CFX::GPUResourceManager **)(a2 + 24), v53, -348639895* ((-348639895* (v13 ^ (((0x9DDFEA08EB382D69 * (v13 ^ v10)) >> 32) >> 15) ^ (-348639895 * (v13 ^ v10)))) ^ (((0x9DDFEA08EB382D69 * (v13 ^ ((0x9DDFEA08EB382D69 * (v13 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69 * (v13 ^ v10)))) >> 32) >> 15)));
  }
  long long v54 = *(uint64_t **)(a1 + 384);
  uint64_t v55 = *(const char **)a2;
  uint64_t v56 = *(void *)(a2 + 8);

  sub_1B65A8F34(v54, v55, v56, v52);
}

unsigned __int8 *sub_1B6555F90(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      uint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      double result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void sub_1B655607C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B6556084(uint64_t a1, const char *a2, uint64_t a3)
{
}

uint64_t sub_1B6556090(uint64_t *a1, uint64_t **a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B6556294(v9[0], v7, v9, a2, a3, a4);
  sub_1B63C88CC(a1 + 18, v9);
  return v9[0];
}

uint64_t sub_1B65560EC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t *a9@<X8>)
{
  uint64_t v22 = a3;
  uint64_t v23 = a1;
  *a9 = a2;
  a9[1] = 0;
  a9[2] = (uint64_t)(a9 + 3);
  uint64_t v11 = sub_1B644558C(a3, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v19 = sub_1B64B1FBC(v11, v12, v13, v14, v15, v16, v17, v18);
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3321888768;
  uint64_t v21[2] = sub_1B655618C;
  _OWORD v21[3] = &unk_1F0FB5470;
  v21[4] = &v23;
  v21[5] = &v22;
  v21[6] = a4;
  v21[7] = a9;
  return sub_1B64A19B0(v19, (uint64_t)v21);
}

uint64_t sub_1B655618C(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 221) & 0x10) != 0)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    uint64_t v4 = **(uint64_t ***)(a1 + 32);
    v7[0] = "Mirror map";
    v7[1] = *v3;
    __int16 v8 = 0;
    uint64_t v9 = a2;
    CFX::RG::TextureDescriptorReference::withSampleCount(*(_OWORD **)(a1 + 48), 1, (uint64_t)&v10);
    unint64_t v5 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v9) ^ ((0x9DDFEA08EB382D69 * v9) >> 47));
    unint64_t v11 = 0x9DDFEA08EB382D69 * (v5 ^ (v5 >> 47));
    uint64_t v12 = v4;
    v7[0] = sub_1B6556090(v4, &v12, (uint64_t)v7, (uint64_t *)&v11);
    sub_1B64EA528(*(_DWORD **)(a1 + 56), v7);
  }
  return 0;
}

__n128 sub_1B6556248(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 32);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x200], 8) = v3;
  return result;
}

void sub_1B655625C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6556294(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t **a4, uint64_t a5, uint64_t *a6)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v10 = sub_1B63C8330(v12, 0x248u, 8u);
  return sub_1B6555A18(v10, *a3, a3[1], *a4, a5, *a6);
}

void sub_1B6556450(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B65565B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_1B6556B90(void **a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t result = objc_msgSend_mipmapLevelCount(a2, (const char *)a2, a3, a4);
  if (result >= 2)
  {
    if ((unint64_t)objc_msgSend_width(a2, v7, v8, v9) > 1
      || (unint64_t)objc_msgSend_height(a2, v10, v11, v12) > 1
      || (unint64_t result = objc_msgSend_depth(a2, v10, v13, v12), result >= 2))
    {
      uint64_t v14 = *a1;
      return objc_msgSend_generateMipmapsForTexture_(v14, v10, (uint64_t)a2, v12);
    }
  }
  return result;
}

uint64_t sub_1B6556E5C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1B65573B4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B6557540(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B655780C(uint64_t a1)
{
}

uint64_t sub_1B655828C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_setNeedsDisplay(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B6558430(uint64_t a1)
{
  id v2 = *(id *)(a1 + 32);
  objc_msgSend__drawAtTime_(*(void **)(a1 + 32), v3, v4, v5, *(double *)(a1 + 40));
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = sub_1B65584C8;
  block[3] = &unk_1E61422C0;
  void block[4] = *(void *)(a1 + 32);
  dispatch_async(MEMORY[0x1E4F14428], block);
}

void sub_1B65584C8(uint64_t a1)
{
}

void sub_1B6558A64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = *(void (**)(void))(a1 + 328);
  if (v9) {
    v9();
  }
  else {
    sub_1B63F2F54(16, @"Unreachable code: NOT IMPLEMENTED YET", a3, a4, a5, a6, 0, a8, a9);
  }
}

void sub_1B6558A80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v52[11] = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 64))
  {
    uint64_t v9 = *(uint64_t (**)(uint64_t))(a1 + 288);
    if (v9)
    {
      if (v9 == sub_1B6558CEC)
      {
        uint64_t v10 = (uint64_t)sub_1B63CCEC4(a1, a2, a3, a4, a5, a6, a7, a8);
        int v17 = 0;
        if (v10 <= 8)
        {
          uint64_t v18 = v10;
          if (v10)
          {
            if (v10 >= 1)
            {
              uint64_t v19 = 0;
              do
              {
                CFArrayRef v20 = sub_1B63CCF34(a1, v19, v11, v12, v13, v14, v15, v16);
                if (v19)
                {
                  CFArrayRef v21 = v20;
                  uint64_t v22 = 0;
                  while (sub_1B63CCF34(a1, v22, v11, v12, v13, v14, v15, v16) != v21)
                  {
                    if (v19 == ++v22)
                    {
                      uint64_t v22 = v19;
                      break;
                    }
                  }
                }
                else
                {
                  uint64_t v22 = 0;
                }
                v52[v19++] = v22 + 1;
              }
              while (v19 != v18);
            }
            uint64_t v23 = 0;
            uint64_t v24 = 0;
            int v17 = 0;
            do
            {
              v17 |= v52[v24 % v18] << v23;
              ++v24;
              v23 += 4;
            }
            while (v24 != 8);
          }
        }
        *(_DWORD *)(a1 + 284) = v17;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&unk_1E9DDB5A0);
      sub_1B655DB3C();
      if (*(void *)(a1 + 336)) {
        sub_1B655DBB8(a1);
      }
      CFIndex v25 = (*(uint64_t (**)(uint64_t, void *))(a1 + 320))(a1, v52);
      CFDataRef v26 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v52, v25);
      unint64_t Value = CFDictionaryGetValue((CFDictionaryRef)qword_1E9DDB5A8, v26);
      if (Value)
      {
        uint64_t v28 = Value;
        sub_1B655CB04(v26);
      }
      else
      {
        uint64_t v36 = (*(uint64_t (**)(uint64_t))(a1 + 288))(a1 + 208);
        if (!v36)
        {
          sub_1B63CDBD0(a1, 0, v37, v38, v39, v40, v41, v42);
LABEL_34:
          CFRelease(v26);
          os_unfair_lock_unlock((os_unfair_lock_t)&unk_1E9DDB5A0);
          return;
        }
        uint64_t v28 = (const void *)v36;
        CFDictionarySetValue((CFMutableDictionaryRef)qword_1E9DDB5B0, v26, (const void *)1);
        CFDictionarySetValue((CFMutableDictionaryRef)qword_1E9DDB5A8, v26, v28);
        CFRelease(v28);
      }
      CFDataRef v43 = *(CFDataRef *)(a1 + 336);
      if (v43 != v26)
      {
        if (v43)
        {
          CFRelease(v43);
          *(void *)(a1 + 336) = 0;
        }
        if (v26) {
          CFTypeRef v44 = CFRetain(v26);
        }
        else {
          CFTypeRef v44 = 0;
        }
        *(void *)(a1 + 336) = v44;
      }
      uint64_t v45 = (const void *)sub_1B64AB2A8((uint64_t)v28, v29, v30, v31, v32, v33, v34, v35);
      sub_1B63CDBD0(a1, (uint64_t)v45, v46, v47, v48, v49, v50, v51);
      if (v45) {
        CFRelease(v45);
      }
      goto LABEL_34;
    }
  }
}

uint64_t sub_1B6558CEC(uint64_t a1)
{
  return sub_1B6523ED8(*(char *)(a1 + 68), *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48), *(int *)(a1 + 52), *(_DWORD *)(a1 + 76), *(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 16));
}

void sub_1B6558D10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(uint64_t (**)(uint64_t))(a1 + 288) == sub_1B6558CEC)
  {
    sub_1B6558D54(a1, a2, a3, a4, a5, a6, a7, a8);
    *(_DWORD *)(a1 + 284) = -1;
  }
}

void sub_1B6558D54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 64))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1E9DDB5A0);
    sub_1B655DBB8(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1E9DDB5A0);
  }

  sub_1B63CDBD0(a1, 0, a3, a4, a5, a6, a7, a8);
}

void sub_1B6558DB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch((int)a2)
  {
    case 0:
      uint64_t v8 = &xmmword_1F0FB9388;
      goto LABEL_11;
    case 1:
      uint64_t v8 = &xmmword_1F0FB86B0;
      goto LABEL_11;
    case 2:
      uint64_t v8 = &xmmword_1F0FB9418;
      goto LABEL_11;
    case 3:
      uint64_t v8 = &xmmword_1F0FB96E8;
      goto LABEL_11;
    case 4:
      uint64_t v8 = &xmmword_1F0FB8D58;
      goto LABEL_11;
    case 5:
      uint64_t v8 = &xmmword_1F0FB8BA8;
      goto LABEL_11;
    case 6:
      uint64_t v8 = &xmmword_1F0FB9928;
      goto LABEL_11;
    case 7:
      uint64_t v8 = &xmmword_1F0FB8B78;
      goto LABEL_11;
    case 8:
      uint64_t v8 = &xmmword_1F0FB9838;
LABEL_11:
      long long v9 = v8[1];
      *(_OWORD *)(a1 + 28_Block_object_dispose(&STACK[0x200], 8) = *v8;
      *(_OWORD *)(a1 + 304) = v9;
      *(_OWORD *)(a1 + 320) = v8[2];
      break;
    default:
      break;
  }
  sub_1B6558D54(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B6558E80(_OWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  long long v9 = a1[19];
  __s1[0] = a1[18];
  __s1[1] = v9;
  __s1[2] = a1[20];
  if (!memcmp(__s1, &xmmword_1F0FB86B0, 0x30uLL)) {
    return 1;
  }
  if (!memcmp(__s1, &xmmword_1F0FB9418, 0x30uLL)) {
    return 2;
  }
  if (!memcmp(__s1, &xmmword_1F0FB8D58, 0x30uLL)) {
    return 4;
  }
  if (!memcmp(__s1, &xmmword_1F0FB8BA8, 0x30uLL)) {
    return 5;
  }
  if (!memcmp(__s1, &xmmword_1F0FB9928, 0x30uLL)) {
    return 6;
  }
  if (!memcmp(__s1, &xmmword_1F0FB8B78, 0x30uLL)) {
    return 7;
  }
  if (!memcmp(__s1, &xmmword_1F0FB9838, 0x30uLL)) {
    return 8;
  }
  if (!memcmp(__s1, &xmmword_1F0FB96E8, 0x30uLL)) {
    return 3;
  }
  return 0;
}

__n128 sub_1B6558FD8@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a2, a3, a4, a5, a6, a7, (uint64_t)"geometry");
  }
  long long v10 = *(_OWORD *)(a1 + 304);
  *(_OWORD *)a8 = *(_OWORD *)(a1 + 288);
  *(_OWORD *)(a8 + 16) = v10;
  __n128 result = *(__n128 *)(a1 + 320);
  *(__n128 *)(a8 + 32) = result;
  return result;
}

uint64_t sub_1B6559034()
{
  if (qword_1EB9955B0 != -1) {
    dispatch_once(&qword_1EB9955B0, &unk_1F0FB5D88);
  }
  return qword_1EB9955B8;
}

double sub_1B6559078()
{
  if (!qword_1EB9955B8)
  {
    CFTypeID v0 = (void *)sub_1B63C8D10(&qword_1EB9955B8);
    qword_1EB9955B8 = (uint64_t)v0;
    uint64_t v1 = (const void *)sub_1B63CD970();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"width", 0xD0u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"height", 0xD4u, 1, 0, 0, 0, v4, v5);
    sub_1B660E400(@"length", 0xD8u, 1, 0, 0, 0, v6, v7);
    sub_1B660E400(@"chamferRadius", 0xE0u, 1, 0, 0, 0, v8, v9);
    sub_1B660E400(@"topRadius", 0xE4u, 1, 0, 0, 0, v10, v11);
    sub_1B660E400(@"radius", 0xDCu, 1, 0, 0, 0, v12, v13);
    sub_1B660E400(@"innerRadius", 0xE8u, 1, 0, 0, 0, v14, v15);
    sub_1B660E400(@"pipeRadius", 0xECu, 1, 0, 0, 0, v16, v17);
    sub_1B660E400(@"chamferSegmentCount", 0x104u, 2, 0, 0, 0, v18, v19);
    sub_1B660E400(@"heightSegmentCount", 0xFCu, 2, 0, 0, 0, v20, v21);
    sub_1B660E400(@"lengthSegmentCount", 0x100u, 2, 0, 0, 0, v22, v23);
    sub_1B660E400(@"widthSegmentCount", 0xF8u, 2, 0, 0, 0, v24, v25);
    sub_1B660E400(@"capSegmentCount", 0x110u, 1, 0, 0, 0, v26, v27);
    sub_1B660E400(@"radialSegmentCount", 0x108u, 2, 0, 0, 0, v28, v29);
    sub_1B660E400(@"cornerSegmentCount", 0x104u, 2, 0, 0, 0, v30, v31);
    sub_1B660E400(@"segmentCount", 0xF4u, 2, 0, 0, 0, v32, v33);
    sub_1B660E400(@"radialSpan", 0xF0u, 1, 0, 0, 0, v34, v35);
    sub_1B660E400(@"pipeSegmentCount", 0x10Cu, 2, 0, 0, 0, v36, v37);
    sub_1B660E3EC();
    unk_1EB9849F0 = xmmword_1F0FB8A28;
    xmmword_1EB9849D8 = xmmword_1F0FB8A18;
    double result = *(double *)&xmmword_1F0FB8A38;
    unk_1EB984A00 = xmmword_1F0FB8A38;
    unk_1EB984A10 = unk_1F0FB8A48;
    qword_1EB984A20 = qword_1F0FB8A58;
    qword_1EB984A30 = (uint64_t)sub_1B655E004;
  }
  return result;
}

float32x2_t sub_1B655936C(float32x2_t *a1, float32x2_t *a2, float32x2_t result, float32_t a4)
{
  if (a1) {
    BOOL v4 = a2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    result.f32[1] = a4;
    a1[1].i32[0] = 0;
    *a1 = vmul_f32(result, (float32x2_t)0xBF000000BF000000);
    double result = vmul_f32(result, (float32x2_t)0x3F0000003F000000);
    a2[1].i32[0] = 0;
    *a2 = result;
  }
  return result;
}

float32x2_t sub_1B65593A8(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3)
{
  if (a2) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    float32x2_t v4 = a1[26];
    a2[1].i32[0] = 0;
    *a2 = vmul_f32(v4, (float32x2_t)0xBF000000BF000000);
    float32x2_t result = vmul_f32(v4, (float32x2_t)0x3F0000003F000000);
    a3[1].i32[0] = 0;
    *a3 = result;
  }
  return result;
}

double sub_1B65593E4(uint64_t a1, int a2)
{
  uint64_t v2 = (_DWORD *)sub_1B655CB84(a1, a2);
  if (!v2) {
    return 0.0;
  }
  LODWORD(result) = *v2;
  return result;
}

BOOL sub_1B655940C(_OWORD *a1, float a2, float a3)
{
  if (a1)
  {
    float v3 = sqrtf((float)(a3 * a3) + (float)(a2 * a2)) * 0.5;
    *(void *)&long long v4 = 0;
    DWORD2(v4) = 0;
    *((float *)&v4 + 3) = v3;
    *a1 = v4;
  }
  return a1 != 0;
}

BOOL sub_1B655943C(uint64_t a1, _OWORD *a2)
{
  if (a2)
  {
    *(void *)&long long v2 = 0;
    DWORD2(v2) = 0;
    *((float *)&v2 + 3) = sqrtf((float)(*(float *)(a1 + 212) * *(float *)(a1 + 212))+ (float)(*(float *)(a1 + 208) * *(float *)(a1 + 208)))* 0.5;
    *a2 = v2;
  }
  return a2 != 0;
}

uint64_t sub_1B6559470(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 296);

  return v11(a1, a2, a3);
}

uint64_t sub_1B65594E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 304);

  return v10(a1, a2);
}

void sub_1B6559550(float32x2_t *a1, uint64_t a2, unsigned int *a3, __n128 *a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, __n128 a14, uint64_t a15)
{
  if (a6 >= 2)
  {
    if (a6 == 2) {
      sub_1B63CEAAC(a1, a2, a3, (uint64_t)a4, a5, 2, a7, a8, a15);
    }
  }
  else
  {
    float32x2_t v15 = a1[26];
    float v16 = a1[28].f32[0];
    float32x2_t v17 = vmul_f32(v15, (float32x2_t)0x3F0000003F000000);
    if (v16 <= 0.0)
    {
      if (a2 >= 1)
      {
        float32x2_t v32 = vneg_f32(v17);
        float64x2_t v33 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
        uint64_t v34 = (_OWORD *)a5;
        do
        {
          int v35 = 214013 * *a3 + 2531011;
          *a3 = 214013 * v35 + 2531011;
          v36.i32[0] = v35;
          v36.i32[1] = 214013 * v35 + 2531011;
          uint32x2_t v37 = vshr_n_u32(v36, 0x10uLL);
          v38.i64[0] = v37.u32[0];
          v38.i64[1] = v37.u32[1];
          a14.n128_u64[0] = (unint64_t)vmla_f32(v32, v15, vcvt_f32_f64(vmulq_f64(vcvtq_f64_u64(v38), v33)));
          a14.n128_u32[2] = 0;
          *a4 = a14;
          if (a5) {
            *uint64_t v34 = xmmword_1B6E4F2E0;
          }
          ++v34;
          ++a4;
          --a2;
        }
        while (a2);
      }
    }
    else
    {
      if (v17.f32[0] >= v17.f32[1]) {
        float v18 = v17.f32[1];
      }
      else {
        float v18 = v17.f32[0];
      }
      if (v16 >= v18) {
        float v19 = v18;
      }
      else {
        float v19 = a1[28].f32[0];
      }
      if (a2 >= 1)
      {
        uint64_t v20 = 0;
        float v21 = -v17.f32[0];
        v17.f32[0] = v19 - v17.f32[0];
        do
        {
          unsigned int v22 = *a3;
          do
          {
            unsigned int v23 = 214013 * v22 + 2531011;
            float v24 = (double)HIWORD(v23) * 0.0000152590219;
            float v25 = v21 + (float)(v24 * v15.f32[0]);
            unsigned int v22 = 214013 * v23 + 2531011;
            float v26 = (double)HIWORD(v22) * 0.0000152590219;
            float v27 = (float)(v26 * v15.f32[1]) - v17.f32[1];
            float v28 = v17.f32[0] + fabsf(v25);
            if (v28 <= 0.0) {
              break;
            }
            float v29 = (float)(v19 - v17.f32[1]) + fabsf(v27);
            float v30 = (float)(v29 * v29) + (float)(v28 * v28);
          }
          while (v29 > 0.0 && v30 > (float)(v19 * v19));
          *a3 = v22;
          a4[v20] = (__n128)__PAIR64__(LODWORD(v27), LODWORD(v25));
          if (a5) {
            *(_OWORD *)(a5 + 16 * v20) = xmmword_1B6E4F2E0;
          }
          ++v20;
        }
        while (v20 != a2);
      }
    }
  }
}

float sub_1B65596EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  }
  return *(float *)(a1 + 224);
}

uint64_t sub_1B6559738(uint64_t a1)
{
  return sub_1B6549D0C(*(char *)(a1 + 68), *(int *)(a1 + 40), *(int *)(a1 + 44), *(int *)(a1 + 52), *(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 16));
}

void sub_1B6559754(_DWORD *a1)
{
  sub_1B655CC4C((uint64_t)a1, 0, 1.0);
  sub_1B655CC4C((uint64_t)a1, 1, 1.0);
  sub_1B655CC4C((uint64_t)a1, 3, 0.0);
  if (a1[62] != 1)
  {
    sub_1B6558D54((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[62] = 1;
  }
  if (a1[63] != 1)
  {
    sub_1B6558D54((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[63] = 1;
  }
  if (a1[65] != 10)
  {
    sub_1B6558D54((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    a1[65] = 10;
  }
}

uint64_t sub_1B65597F4(_DWORD *a1, _DWORD *a2)
{
  *a2 = 0;
  a2[1] = a1[69];
  a2[2] = a1[52];
  a2[3] = a1[53];
  a2[4] = a1[56];
  a2[5] = a1[62];
  a2[6] = a1[63];
  a2[7] = a1[65];
  a2[8] = a1[71];
  return 36;
}

float32x2_t sub_1B6559840(float32x2_t *a1, float32x2_t *a2, float32x2_t result, float32_t a4, float a5)
{
  if (a1) {
    BOOL v5 = a2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    result.f32[1] = a4;
    a1[1].f32[0] = a5 * -0.5;
    *a1 = vmul_f32(result, (float32x2_t)0xBF000000BF000000);
    double result = vmul_f32(result, (float32x2_t)0x3F0000003F000000);
    a2[1].f32[0] = a5 * 0.5;
    *a2 = result;
  }
  return result;
}

float32_t sub_1B655988C(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3)
{
  if (a2) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    float v4 = a1[27].f32[0];
    float32x2_t v5 = a1[26];
    a2[1].f32[0] = v4 * -0.5;
    *a2 = vmul_f32(v5, (float32x2_t)0xBF000000BF000000);
    float32_t result = v4 * 0.5;
    a3[1].f32[0] = result;
    *a3 = vmul_f32(v5, (float32x2_t)0x3F0000003F000000);
  }
  return result;
}

BOOL sub_1B65598DC(_OWORD *a1, float a2, float a3, float a4)
{
  if (a1)
  {
    float v4 = sqrtf((float)((float)(a3 * a3) + (float)(a2 * a2)) + (float)(a4 * a4)) * 0.5;
    *(void *)&long long v5 = 0;
    DWORD2(v5) = 0;
    *((float *)&v5 + 3) = v4;
    *a1 = v5;
  }
  return a1 != 0;
}

BOOL sub_1B6559910(float *a1, _OWORD *a2)
{
  if (a2)
  {
    *(void *)&long long v2 = 0;
    DWORD2(v2) = 0;
    *((float *)&v2 + 3) = sqrtf((float)((float)(a1[53] * a1[53]) + (float)(a1[52] * a1[52])) + (float)(a1[54] * a1[54]))
                        * 0.5;
    *a2 = v2;
  }
  return a2 != 0;
}

void sub_1B655994C(float *cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, float32x4_t a13, double a14, float32x4_t a15, uint64_t a16)
{
  int v17 = a6;
  float v19 = (_OWORD *)a4;
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"parametricGeometry");
  }
  float v23 = cf[54];
  float32x2_t v24 = *(float32x2_t *)(cf + 52);
  *(float32x2_t *)a15.f32 = vmul_f32(v24, (float32x2_t)0x3F0000003F000000);
  float v25 = v23 * 0.5;
  if (a15.f32[0] >= a15.f32[1]) {
    float v26 = a15.f32[1];
  }
  else {
    float v26 = a15.f32[0];
  }
  if (v26 >= v25) {
    float v26 = v23 * 0.5;
  }
  if (cf[56] >= v26) {
    *(float *)&a11 = v26;
  }
  else {
    *(float *)&a11 = cf[56];
  }
  if (v17 == 2)
  {
    sub_1B63CEAAC(cf, a2, a3, (uint64_t)v19, a5, 2, a7, a8, a16);
  }
  else
  {
    float32x4_t v27 = a15;
    v27.f32[2] = v23 * 0.5;
    float v28 = *(float *)&a11 * *(float *)&a11;
    float32x4_t v29 = vsubq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0));
    if (v17 == 1)
    {
      if (*(float *)&a11 <= 0.0)
      {
        if (a2 >= 1)
        {
          float32x2_t v94 = vneg_f32(*(float32x2_t *)a15.f32);
          float v95 = -v25;
          float64x2_t v96 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
          float32x4_t v97 = (float32x4_t *)a5;
          do
          {
            int v98 = 214013 * *a3 + 2531011;
            v99.i32[0] = v98;
            v99.i32[1] = 214013 * v98 + 2531011;
            uint32x2_t v100 = vshr_n_u32(v99, 0x10uLL);
            v101.i64[0] = v100.u32[0];
            v101.i64[1] = v100.u32[1];
            float32x4_t v104 = (float32x4_t)vmulq_f64(vcvtq_f64_u64(v101), v96);
            *(float32x2_t *)v104.f32 = vmla_f32(v94, v24, vcvt_f32_f64((float64x2_t)v104));
            unsigned int v102 = 214013 * (214013 * v98 + 2531011) + 2531011;
            *a3 = v102;
            float v103 = (double)HIWORD(v102) * 0.0000152590219;
            v104.f32[2] = v95 + (float)(v103 * v23);
            _OWORD *v19 = v104;
            if (a5)
            {
              int32x4_t v105 = (int32x4_t)vmulq_f32(v104, v104);
              v105.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v105, 2), vadd_f32(*(float32x2_t *)v105.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v105.i8, 1))).u32[0];
              float32x2_t v106 = vrsqrte_f32((float32x2_t)v105.u32[0]);
              float32x2_t v107 = vmul_f32(v106, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v106, v106)));
              float32x4_t *v97 = vmulq_n_f32(v104, vmul_f32(v107, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v107, v107))).f32[0]);
            }
            ++v97;
            ++v19;
            --a2;
          }
          while (a2);
        }
      }
      else if (a2 >= 1)
      {
        uint64_t v77 = 0;
        float32x2_t v78 = vneg_f32(*(float32x2_t *)a15.f32);
        float64x2_t v79 = (float64x2_t)vdupq_n_s64(0x3EF0001000100010uLL);
        do
        {
          unsigned int v80 = *a3;
          do
          {
            int v81 = 214013 * v80 + 2531011;
            v82.i32[0] = v81;
            v82.i32[1] = 214013 * v81 + 2531011;
            uint32x2_t v83 = vshr_n_u32(v82, 0x10uLL);
            v84.i64[0] = v83.u32[0];
            v84.i64[1] = v83.u32[1];
            float32x4_t v86 = (float32x4_t)vmulq_f64(vcvtq_f64_u64(v84), v79);
            unsigned int v80 = 214013 * (214013 * v81 + 2531011) + 2531011;
            *(float32x2_t *)v86.f32 = vmla_f32(v78, v24, vcvt_f32_f64((float64x2_t)v86));
            float v85 = (double)HIWORD(v80) * 0.0000152590219;
            v86.f32[2] = (float)(v85 * v23) - v25;
            float32x4_t v87 = vsubq_f32(vabsq_f32(v86), v29);
            float v88 = v87.f32[1];
            int v89 = v87.f32[1] > 0.0;
            if (v87.f32[0] > 0.0) {
              ++v89;
            }
            if (v87.f32[2] > 0.0) {
              ++v89;
            }
            if (v89 == 2)
            {
              if (v87.f32[0] <= v87.f32[1]) {
                v87.f32[0] = v87.f32[1];
              }
              if (v87.f32[1] <= v87.f32[2]) {
                float v88 = v87.f32[2];
              }
              float v90 = (float)(v88 * v88) + (float)(v87.f32[0] * v87.f32[0]);
            }
            else
            {
              if (v89 != 3) {
                break;
              }
              float v90 = (float)((float)(v87.f32[1] * v87.f32[1]) + (float)(v87.f32[0] * v87.f32[0]))
                  + (float)(v87.f32[2] * v87.f32[2]);
            }
          }
          while (v90 > v28);
          *a3 = v80;
          v19[v77] = v86;
          if (a5)
          {
            int32x4_t v91 = (int32x4_t)vmulq_f32(v86, v86);
            v91.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v91, 2), vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v91.i8, 1))).u32[0];
            float32x2_t v92 = vrsqrte_f32((float32x2_t)v91.u32[0]);
            float32x2_t v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v92, v92)));
            *(float32x4_t *)(a5 + 16 * v77) = vmulq_n_f32(v86, vmul_f32(v93, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v93, v93))).f32[0]);
          }
          ++v77;
        }
        while (v77 != a2);
      }
    }
    else if (!v17 && a2 >= 1)
    {
      a13.f32[0] = a15.f32[1] * v25;
      float32x4_t v30 = a13;
      v30.f32[1] = a15.f32[0] * v25;
      v30.f32[2] = a15.f32[0] * a15.f32[1];
      float32x4_t v31 = vmulq_n_f32(v30, 1.0/ (float)((float)(a15.f32[0] * a15.f32[1]) + (float)((float)(a15.f32[1] * v25) + (float)(a15.f32[0] * v25))));
      float v32 = v31.f32[0] + v31.f32[0];
      float v33 = (float)(v31.f32[0] + v31.f32[0]) + v31.f32[1] * 2.0;
      v34.i64[0] = 0x8000000080000000;
      v34.i64[1] = 0x8000000080000000;
      int v35 = (float32x4_t *)a5;
      do
      {
        unsigned int v36 = 214013 * *a3 + 2531011;
        float v37 = (double)HIWORD(v36) * 0.0000152590219;
        float v38 = v37 * 2.0 + -1.0;
        unsigned int v39 = 214013 * v36 + 2531011;
        float v40 = (double)HIWORD(v39) * 0.0000152590219;
        float v41 = v40 * 2.0 + -1.0;
        unsigned int v42 = 214013 * v39 + 2531011;
        *a3 = v42;
        float v43 = (double)HIWORD(v42) * 0.0000152590219;
        float v44 = v43 + v43;
        BOOL v45 = v31.f32[2] == 1.0;
        if ((float)(v44 - v33) < v31.f32[2]) {
          BOOL v45 = 1;
        }
        BOOL v46 = v31.f32[1] == 1.0;
        if ((float)(v44 - v32) < v31.f32[1]) {
          BOOL v46 = 1;
        }
        if (v44 < v33) {
          BOOL v45 = v46;
        }
        char v47 = -1;
        if (v44 < v33) {
          unsigned int v48 = 1;
        }
        else {
          unsigned int v48 = 2;
        }
        BOOL v49 = v31.f32[0] == 1.0;
        if (v44 < v31.f32[0]) {
          BOOL v49 = 1;
        }
        if (v44 < v32) {
          char v47 = 2;
        }
        else {
          BOOL v49 = v45;
        }
        if (v44 < v32) {
          uint64_t v50 = 0;
        }
        else {
          uint64_t v50 = v48;
        }
        if (v50 == 2) {
          char v51 = 0;
        }
        else {
          char v51 = v50 + 1;
        }
        char v52 = v50 + v47;
        float32x4_t v113 = v27;
        float v53 = *(float *)((unint64_t)&v113 | (4 * v50));
        if (!v49) {
          float v53 = -v53;
        }
        float32x4_t v114 = 0uLL;
        *(float *)((unint64_t)&v114 & 0xFFFFFFFFFFFFFFF3 | (4 * (v50 & 3))) = v53;
        float v54 = *(float *)((unint64_t)&v113 & 0xFFFFFFFFFFFFFFF3 | (4 * (v51 & 3))) * v38;
        float32x4_t v115 = v114;
        *(float *)((unint64_t)&v115 & 0xFFFFFFFFFFFFFFF3 | (4 * (v51 & 3))) = v54;
        float v55 = *(float *)((unint64_t)&v113 & 0xFFFFFFFFFFFFFFF3 | (4 * (v52 & 3))) * v41;
        int8x16_t v116 = (int8x16_t)v115;
        *(float *)((unint64_t)&v116 & 0xFFFFFFFFFFFFFFF3 | (4 * (v52 & 3))) = v55;
        int8x16_t v56 = v116;
        float32x4_t v57 = (float32x4_t)v116;
        v57.i32[3] = HIDWORD(v16);
        if (*(float *)&a11 <= 0.0) {
          goto LABEL_62;
        }
        float32x4_t v58 = vsubq_f32(vabsq_f32((float32x4_t)v116), v29);
        int v59 = v58.f32[1] > 0.0;
        if (v58.f32[0] > 0.0) {
          ++v59;
        }
        if (v58.f32[2] > 0.0) {
          ++v59;
        }
        if (v59 == 3)
        {
          float32x4_t v71 = vmulq_f32(v58, v58);
          float v72 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 2), vaddq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 1))).f32[0];
          if (v72 > v28)
          {
            float32x4_t v73 = vmlaq_n_f32(v29, v58, *(float *)&a11 / sqrtf(v72));
            *(int8x8_t *)v57.f32 = vbsl_s8((int8x8_t)0x8000000080000000, *(int8x8_t *)v73.f32, *(int8x8_t *)v116.i8);
            v58.i32[0] = v73.i32[2];
            v56.i32[0] = v116.i32[2];
            v57.i32[2] = vbslq_s8(v34, (int8x16_t)v58, v56).u32[0];
LABEL_61:
            v57.i32[3] = HIDWORD(v16);
          }
        }
        else if (v59 == 2)
        {
          unsigned int v60 = 2 * (v58.f32[0] > 0.0);
          if (v58.f32[1] <= 0.0) {
            int v61 = 1;
          }
          else {
            int v61 = 2;
          }
          if (v50) {
            int v61 = 0;
          }
          if (v50 != 1) {
            unsigned int v60 = v61;
          }
          if (v50 == 2) {
            uint64_t v62 = v58.f32[1] <= 0.0;
          }
          else {
            uint64_t v62 = v60;
          }
          if (v62 == 2) {
            char v63 = 0;
          }
          else {
            char v63 = v62 + 1;
          }
          float32x4_t v108 = v58;
          *(_DWORD *)((unint64_t)&v108 | (4 * v62)) = 0;
          float32x4_t v64 = v108;
          float32x4_t v65 = vmulq_f32(v64, v64);
          int v66 = v62 + 2 + ((int)v62 + 2) / 3u;
          v65.f32[0] = *(float *)&a11
                     / sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 2), vaddq_f32(v65, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65.f32, 1))).f32[0]);
          uint64_t v67 = (__int32 *)((unint64_t)&v111 & 0xFFFFFFFFFFFFFFF3 | (4 * (v63 & 3)));
          float32x4_t v109 = v29;
          float v68 = *(float *)((unint64_t)&v109 & 0xFFFFFFFFFFFFFFF3 | (4 * (v63 & 3)));
          float32x4_t v110 = v108;
          v64.f32[0] = v68
                     + (float)(*(float *)((unint64_t)&v110 & 0xFFFFFFFFFFFFFFF3 | (4 * (v63 & 3)))
                             * v65.f32[0]);
          int8x16_t v111 = v56;
          v56.i32[0] = *v67;
          *uint64_t v67 = vbslq_s8(v34, (int8x16_t)v64, v56).u32[0];
          int8x16_t v69 = v111;
          uint64_t v70 = (__int32 *)((unint64_t)&v112 & 0xFFFFFFFFFFFFFFF3 | (4 * (v66 & 3)));
          v64.f32[0] = *(float *)((unint64_t)&v109 & 0xFFFFFFFFFFFFFFF3 | (4 * (v66 & 3)))
                     + (float)(*(float *)((unint64_t)&v110 & 0xFFFFFFFFFFFFFFF3 | (4 * (v66 & 3)))
                             * v65.f32[0]);
          float32x4_t v112 = (float32x4_t)v111;
          v69.i32[0] = *v70;
          *uint64_t v70 = vbslq_s8(v34, (int8x16_t)v64, v69).u32[0];
          float32x4_t v57 = v112;
          goto LABEL_61;
        }
LABEL_62:
        _OWORD *v19 = v57;
        if (a5)
        {
          int32x4_t v74 = (int32x4_t)vmulq_f32(v57, v57);
          v74.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v74, 2), vadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v74.i8, 1))).u32[0];
          float32x2_t v75 = vrsqrte_f32((float32x2_t)v74.u32[0]);
          float32x2_t v76 = vmul_f32(v75, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v75, v75)));
          *int v35 = vmulq_n_f32(v57, vmul_f32(v76, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v76, v76))).f32[0]);
        }
        ++v35;
        ++v19;
        HIDWORD(v16) = v57.i32[3];
        --a2;
      }
      while (a2);
    }
  }
}