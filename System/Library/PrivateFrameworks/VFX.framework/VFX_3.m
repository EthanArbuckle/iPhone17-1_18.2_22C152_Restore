double sub_1B640EB30(uint64_t a1, float32x4_t a2)
{
  int8x16_t v6;
  int32x2_t v7;
  unsigned int v8;
  int v9;
  int v10;
  int v12;
  double result;

  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  v7 = vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1));
  v8 = *(unsigned __int16 *)(*(void *)(a1 + 64) + v7.i32[0]);
  v9 = (v8 >> 10) & 0x1F;
  if (v9 == 31) {
    v10 = 2139095040;
  }
  else {
    v10 = (v8 >> 10) & 0x1F;
  }
  if (v9) {
    _ZF = v9 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    v12 = v10;
  }
  else {
    v12 = (v9 << 23) + 939524096;
  }
  v7.i32[0] = v12 | (v8 << 16) & 0x80000000 | (v8 >> 7) & 7 | (8 * (v8 & 0x3FF)) & 0x1FFF | ((v8 & 0x3FF) << 13);
  *(void *)&result = vdupq_lane_s32(v7, 0).u64[0];
  return result;
}

double sub_1B640EBC8(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v8).u64[0];
  return result;
}

double sub_1B640EC18(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  v7.i64[0] = *(void *)(*(void *)(a1 + 64)
                        + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  v8.i64[0] = 0x8000000080000000;
  v8.i64[1] = 0x8000000080000000;
  int32x4_t v9 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v7.i8), v8);
  int8x16_t v10 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v7.i8, 0xDuLL);
  int32x4_t v11 = (int32x4_t)vorrq_s8(vandq_s8(v10, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v9, vandq_s8(v10, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v9.i64[0] = 0x3800000038000000;
  v9.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v11, v9).u64[0];
  return result;
}

__n128 sub_1B640EC9C(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  return *(__n128 *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
}

double sub_1B640ECE8(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1));
  v7.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v7.i32[0]);
  *(float *)v7.i32 = (float)v7.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v7.i8, 0).u64[0];
  return result;
}

double sub_1B640ED48(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  *(int32x2_t *)_Q1.f32 = vdup_lane_s32(*(int32x2_t *)v7.i8, 1);
  v7.i32[0] = vadd_s32(*(int32x2_t *)v7.i8, *(int32x2_t *)_Q1.f32).u32[0];
  v7.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v7.i32[0]);
  _Q1.f32[0] = (float)v7.u32[0] * 0.0039216;
  int32x4_t v8 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.f32, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v8.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v8), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), _Q1.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), _Q1.f32[0]), _Q1.f32[0] * _Q1.f32[0]), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), _Q1.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          _Q1.f32[0]),
                                        _Q1.f32[0] * _Q1.f32[0]),
                                      (float)(_Q1.f32[0] * _Q1.f32[0]) * (float)(_Q1.f32[0] * _Q1.f32[0])),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), _Q1.f32[0])).u64[0];
  return result;
}

double sub_1B640EE5C(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x4_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  _Q1.i64[0] = 0xFF000000FFLL;
  _Q1.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)_Q1)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B640EED4(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x4_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  _Q1.i64[0] = 0xFF000000FFLL;
  _Q1.i64[1] = 0xFF000000FFLL;
  float32x4_t v10 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)_Q1));
  float32x4_t v11 = vmulq_f32(v10, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v12 = vmulq_f32(v11, v11);
  int32x4_t v13 = vcgeq_f32(v11, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v13.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v13), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v10), v12, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v10)), vmulq_f32(v12, v12), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v10), v12,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v10))), (int8x16_t)vmulq_f32(v10, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B640EFF0(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x4_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  _Q1.i64[0] = 0xFF000000FFLL;
  _Q1.i64[1] = 0xFF000000FFLL;
  int8x16_t v10 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)_Q1)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v10, v10, 0xCuLL).u64[0];
  return result;
}

double sub_1B640F070(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x4_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  _Q1.i64[0] = 0xFF000000FFLL;
  _Q1.i64[1] = 0xFF000000FFLL;
  float32x4_t v10 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)_Q1));
  float32x4_t v11 = vmulq_f32(v10, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v12 = vmulq_f32(v11, v11);
  int8x16_t v13 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v10), v12, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v10)), vmulq_f32(v12, v12), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v10), v12, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v10)));
  int32x4_t v14 = vcgeq_f32(v11, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v14.i32[3] = 0;
  int32x4_t v15 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v14), v13, (int8x16_t)vmulq_f32(v10, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v15.i32[3] = v11.i32[3];
  int8x16_t v16 = (int8x16_t)vrev64q_s32(v15);
  *(void *)&double result = vextq_s8(v16, v16, 0xCuLL).u64[0];
  return result;
}

double sub_1B640F194(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  int32x2_t v3 = vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1));
  unsigned int v4 = *(unsigned __int16 *)(*(void *)(a1 + 64) + v3.i32[0]);
  int v5 = (v4 >> 10) & 0x1F;
  if (v5 == 31) {
    int v6 = 2139095040;
  }
  else {
    int v6 = (v4 >> 10) & 0x1F;
  }
  if (v5) {
    BOOL v7 = v5 == 31;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    int v8 = v6;
  }
  else {
    int v8 = (v5 << 23) + 939524096;
  }
  v3.i32[0] = v8 | (v4 << 16) & 0x80000000 | (v4 >> 7) & 7 | (8 * (v4 & 0x3FF)) & 0x1FFF | ((v4 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(v3, 0).u64[0];
  return result;
}

double sub_1B640F230(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v3).u64[0];
  return result;
}

double sub_1B640F284(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  v2.i64[0] = *(void *)(*(void *)(a1 + 64)
                        + vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).i32[0]);
  v3.i64[0] = 0x8000000080000000;
  v3.i64[1] = 0x8000000080000000;
  int32x4_t v4 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v2.i8), v3);
  int8x16_t v5 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v2.i8, 0xDuLL);
  int32x4_t v6 = (int32x4_t)vorrq_s8(vandq_s8(v5, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v4, vandq_s8(v5, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v4.i64[0] = 0x3800000038000000;
  v4.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v6, v4).u64[0];
  return result;
}

__n128 sub_1B640F30C(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  return *(__n128 *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).i32[0]);
}

double sub_1B640F35C(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1));
  v2.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v2.i32[0]);
  *(float *)v2.i32 = (float)v2.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v2.i8, 0).u64[0];
  return result;
}

double sub_1B640F3C0(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  int32x2_t v3 = vdup_lane_s32(*(int32x2_t *)v2.i8, 1);
  v2.i32[0] = vadd_s32(*(int32x2_t *)v2.i8, v3).u32[0];
  v2.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v2.i32[0]);
  *(float *)v3.i32 = (float)v2.u32[0] * 0.0039216;
  int32x4_t v4 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v4.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v4), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v3.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v3.i32), *(float *)v3.i32 * *(float *)v3.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v3.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v3.i32),
                                        *(float *)v3.i32 * *(float *)v3.i32),
                                      (float)(*(float *)v3.i32 * *(float *)v3.i32)
                                    * (float)(*(float *)v3.i32 * *(float *)v3.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v3.i32)).u64[0];
  return result;
}

double sub_1B640F4D8(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B640F554(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int32x4_t v9 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v9.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6))), (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B640F674(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  int8x16_t v6 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v6, v6, 0xCuLL).u64[0];
  return result;
}

double sub_1B640F6F8(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  int8x16_t v2 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(a2, vrndmq_f32(a2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v2.i8 = vadd_s32(*(int32x2_t *)v2.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v2.i8, vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6)));
  int32x4_t v10 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v10.i32[3] = 0;
  int32x4_t v11 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v10), v9, (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v11.i32[3] = v7.i32[3];
  int8x16_t v12 = (int8x16_t)vrev64q_s32(v11);
  *(void *)&double result = vextq_s8(v12, v12, 0xCuLL).u64[0];
  return result;
}

double sub_1B640F820(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x2_t v7 = vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1));
  unsigned int v8 = *(unsigned __int16 *)(*(void *)(a1 + 64) + v7.i32[0]);
  int v9 = (v8 >> 10) & 0x1F;
  if (v9 == 31) {
    int v10 = 2139095040;
  }
  else {
    int v10 = (v8 >> 10) & 0x1F;
  }
  if (v9) {
    BOOL v11 = v9 == 31;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    int v12 = v10;
  }
  else {
    int v12 = (v9 << 23) + 939524096;
  }
  v7.i32[0] = v12 | (v8 << 16) & 0x80000000 | (v8 >> 7) & 7 | (8 * (v8 & 0x3FF)) & 0x1FFF | ((v8 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(v7, 0).u64[0];
  return result;
}

double sub_1B640F8D0(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x2_t v7 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v7).u64[0];
  return result;
}

double sub_1B640F938(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  v6.i64[0] = *(void *)(*(void *)(a1 + 64)
                        + vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).i32[0]);
  v4.i64[0] = 0x8000000080000000;
  v4.i64[1] = 0x8000000080000000;
  int32x4_t v7 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v6.i8), (int8x16_t)v4);
  int8x16_t v8 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v6.i8, 0xDuLL);
  int32x4_t v9 = (int32x4_t)vorrq_s8(vandq_s8(v8, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v7, vandq_s8(v8, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v7.i64[0] = 0x3800000038000000;
  v7.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v9, v7).u64[0];
  return result;
}

__n128 sub_1B640F9D4(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  return *(__n128 *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).i32[0]);
}

double sub_1B640FA38(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1));
  v6.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v6.i32[0]);
  *(float *)v6.i32 = (float)v6.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v6.i8, 0).u64[0];
  return result;
}

double sub_1B640FAB0(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  *(int32x2_t *)v2.f32 = vdup_lane_s32(*(int32x2_t *)v6.i8, 1);
  v6.i32[0] = vadd_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v2.f32).u32[0];
  v6.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v6.i32[0]);
  v2.f32[0] = (float)v6.u32[0] * 0.0039216;
  int32x4_t v7 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v7.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v7), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v2.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v2.f32[0]), v2.f32[0] * v2.f32[0]), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v2.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          v2.f32[0]),
                                        v2.f32[0] * v2.f32[0]),
                                      (float)(v2.f32[0] * v2.f32[0]) * (float)(v2.f32[0] * v2.f32[0])),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), v2.f32[0])).u64[0];
  return result;
}

double sub_1B640FBDC(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x4_t v7 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).i32[0]);
  uint32x4_t v8 = (uint32x4_t)vld1q_dup_f32(v7);
  v2.i64[0] = 0xFF000000FFLL;
  v2.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v8, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v2)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B640FC6C(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x4_t v7 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).i32[0]);
  uint32x4_t v8 = (uint32x4_t)vld1q_dup_f32(v7);
  v2.i64[0] = 0xFF000000FFLL;
  v2.i64[1] = 0xFF000000FFLL;
  float32x4_t v9 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v8, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v2));
  float32x4_t v10 = vmulq_f32(v9, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v11 = vmulq_f32(v10, v10);
  int32x4_t v12 = vcgeq_f32(v10, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v12.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v12), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v9), v11, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v9)), vmulq_f32(v11, v11), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v9), v11,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v9))), (int8x16_t)vmulq_f32(v9, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B640FDA0(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x4_t v7 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).i32[0]);
  uint32x4_t v8 = (uint32x4_t)vld1q_dup_f32(v7);
  v2.i64[0] = 0xFF000000FFLL;
  v2.i64[1] = 0xFF000000FFLL;
  int8x16_t v9 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v8, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v2)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v9, v9, 0xCuLL).u64[0];
  return result;
}

double sub_1B640FE38(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  float32x4_t v4 = vmlaq_f32(v3, v3, a2);
  float32x4_t v5 = vabdq_f32(v2, vminnmq_f32(vsubq_f32(v4, vrndmq_f32(v4)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v5, v5))), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x4_t v7 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).i32[0]);
  uint32x4_t v8 = (uint32x4_t)vld1q_dup_f32(v7);
  v2.i64[0] = 0xFF000000FFLL;
  v2.i64[1] = 0xFF000000FFLL;
  float32x4_t v9 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v8, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v2));
  float32x4_t v10 = vmulq_f32(v9, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v11 = vmulq_f32(v10, v10);
  int8x16_t v12 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v9), v11, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v9)), vmulq_f32(v11, v11), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v9), v11, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v9)));
  int32x4_t v13 = vcgeq_f32(v10, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v13.i32[3] = 0;
  int32x4_t v14 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v13), v12, (int8x16_t)vmulq_f32(v9, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v14.i32[3] = v10.i32[3];
  int8x16_t v15 = (int8x16_t)vrev64q_s32(v14);
  *(void *)&double result = vextq_s8(v15, v15, 0xCuLL).u64[0];
  return result;
}

double sub_1B640FF74(uint64_t a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float32x4_t a9)
{
  float32x4_t v10 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v10.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v10, _Q1), (int8x16_t)vcltzq_f32(v10))) & 0x80000000) != 0) {
    return 0.0;
  }
  int32x4_t v15 = *(int32x4_t *)(a1 + 16);
  float32x4_t v16 = vmulq_f32(*(float32x4_t *)a1, v10);
  float32x4_t v17 = (float32x4_t)vminq_s32(vcvtq_s32_f32(v16), v15);
  float32x4_t v18 = *(float32x4_t *)(a1 + 32);
  float32x4_t v21 = (float32x4_t)vmulq_s32((int32x4_t)v18, (int32x4_t)v17);
  float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL);
  *(int32x2_t *)v21.f32 = vadd_s32(*(int32x2_t *)v21.f32, *(int32x2_t *)v19.f32);
  *(int32x2_t *)v19.f32 = vdup_lane_s32(*(int32x2_t *)v21.f32, 1);
  uint64_t v20 = *(void *)(a1 + 64);
  *(int32x2_t *)v21.f32 = vadd_s32(*(int32x2_t *)v21.f32, *(int32x2_t *)v19.f32);
  float32x4_t v22 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_s32(v15, (int32x4_t)v17));
  uint64_t v23 = v21.i32[0] + (uint64_t)v22.i32[0];
  uint64_t v24 = v21.i32[0] + (uint64_t)v22.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)v22.i32[0];
  v26 = (unsigned __int16 *)(v20 + v21.i32[0]);
  unsigned int v27 = *v26;
  int v28 = (v27 >> 10) & 0x1F;
  if (v28 == 31) {
    int v29 = 2139095040;
  }
  else {
    int v29 = (v27 >> 10) & 0x1F;
  }
  if (v28) {
    _ZF = v28 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    int v31 = v29;
  }
  else {
    int v31 = (v28 << 23) + 939524096;
  }
  v21.i32[0] = v31 | (v27 << 16) & 0x80000000 | (v27 >> 7) & 7 | (8 * (v27 & 0x3FF)) & 0x1FFF | ((v27 & 0x3FF) << 13);
  v32 = (unsigned __int16 *)(v20 + v23);
  unsigned int v33 = *v32;
  int v34 = (v33 >> 10) & 0x1F;
  if (v34 == 31) {
    int v35 = 2139095040;
  }
  else {
    int v35 = (v33 >> 10) & 0x1F;
  }
  if (v34) {
    BOOL v36 = v34 == 31;
  }
  else {
    BOOL v36 = 1;
  }
  if (v36) {
    int v37 = v35;
  }
  else {
    int v37 = (v34 << 23) + 939524096;
  }
  v22.i32[0] = v37 | (v33 << 16) & 0x80000000 | (v33 >> 7) & 7 | (8 * (v33 & 0x3FF)) & 0x1FFF | ((v33 & 0x3FF) << 13);
  v38 = (unsigned __int16 *)(v20 + v24);
  unsigned int v39 = *v38;
  int v40 = (v39 >> 10) & 0x1F;
  if (v40 == 31) {
    int v41 = 2139095040;
  }
  else {
    int v41 = (v39 >> 10) & 0x1F;
  }
  if (v40) {
    BOOL v42 = v40 == 31;
  }
  else {
    BOOL v42 = 1;
  }
  if (v42) {
    int v43 = v41;
  }
  else {
    int v43 = (v40 << 23) + 939524096;
  }
  v17.i32[0] = v43 | (v39 << 16) & 0x80000000 | (v39 >> 7) & 7 | (8 * (v39 & 0x3FF)) & 0x1FFF | ((v39 & 0x3FF) << 13);
  v44 = (unsigned __int16 *)(v20 + v25);
  unsigned int v45 = *v44;
  int v46 = (v45 >> 10) & 0x1F;
  if (v46 == 31) {
    int v47 = 2139095040;
  }
  else {
    int v47 = (v45 >> 10) & 0x1F;
  }
  if (v46) {
    BOOL v48 = v46 == 31;
  }
  else {
    BOOL v48 = 1;
  }
  if (v48) {
    int v49 = v47;
  }
  else {
    int v49 = (v46 << 23) + 939524096;
  }
  v18.i32[0] = v49 | (v45 << 16) & 0x80000000 | (v45 >> 7) & 7 | (8 * (v45 & 0x3FF)) & 0x1FFF | ((v45 & 0x3FF) << 13);
  unsigned int v50 = *(unsigned __int16 *)((char *)v26 + v22.i32[2]);
  int v51 = (v50 >> 10) & 0x1F;
  if (v51 == 31) {
    int v52 = 2139095040;
  }
  else {
    int v52 = (v50 >> 10) & 0x1F;
  }
  if (v51) {
    BOOL v53 = v51 == 31;
  }
  else {
    BOOL v53 = 1;
  }
  if (v53) {
    int v54 = v52;
  }
  else {
    int v54 = (v51 << 23) + 939524096;
  }
  v19.i32[0] = v54 | (v50 << 16) & 0x80000000 | (v50 >> 7) & 7 | (8 * (v50 & 0x3FF)) & 0x1FFF | ((v50 & 0x3FF) << 13);
  unsigned int v55 = *(unsigned __int16 *)((char *)v32 + v22.i32[2]);
  int v56 = (v55 >> 10) & 0x1F;
  if (v56 == 31) {
    int v57 = 2139095040;
  }
  else {
    int v57 = (v55 >> 10) & 0x1F;
  }
  if (v56) {
    BOOL v58 = v56 == 31;
  }
  else {
    BOOL v58 = 1;
  }
  if (v58) {
    int v59 = v57;
  }
  else {
    int v59 = (v56 << 23) + 939524096;
  }
  a8.i32[0] = v59 | (v55 << 16) & 0x80000000 | (v55 >> 7) & 7 | (8 * (v55 & 0x3FF)) & 0x1FFF | ((v55 & 0x3FF) << 13);
  unsigned int v60 = *(unsigned __int16 *)((char *)v38 + v22.i32[2]);
  int v61 = (v60 >> 10) & 0x1F;
  if (v61 == 31) {
    int v62 = 2139095040;
  }
  else {
    int v62 = (v60 >> 10) & 0x1F;
  }
  if (v61) {
    BOOL v63 = v61 == 31;
  }
  else {
    BOOL v63 = 1;
  }
  if (v63) {
    int v64 = v62;
  }
  else {
    int v64 = (v61 << 23) + 939524096;
  }
  a9.i32[0] = v64 | (v60 << 16) & 0x80000000 | (v60 >> 7) & 7 | (8 * (v60 & 0x3FF)) & 0x1FFF | ((v60 & 0x3FF) << 13);
  unsigned int v65 = *(unsigned __int16 *)((char *)v44 + v22.i32[2]);
  int v66 = (v65 >> 10) & 0x1F;
  if (v66 == 31) {
    int v67 = 2139095040;
  }
  else {
    int v67 = (v65 >> 10) & 0x1F;
  }
  if (v66) {
    BOOL v68 = v66 == 31;
  }
  else {
    BOOL v68 = 1;
  }
  if (!v68) {
    int v67 = (v66 << 23) + 939524096;
  }
  v9.i32[0] = v67 | (v65 << 16) & 0x80000000 | (v65 >> 7) & 7 | (8 * (v65 & 0x3FF)) & 0x1FFF | ((v65 & 0x3FF) << 13);
  float32x4_t v69 = vsubq_f32(v16, vrndq_f32(v16));
  float32x4_t v70 = vmlaq_f32(v21, v69, vsubq_f32(v22, v21));
  float32x4_t v71 = vmlaq_f32(v19, v69, vsubq_f32(a8, v19));
  float32x4_t v72 = vsubq_f32(v9, a9);
  float32x4_t v73 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1);
  float32x4_t v74 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v70.f32, 0), v73, vmlaq_f32(vsubq_f32(v17, v70), v69, vsubq_f32(v18, v17)).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v74, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 0), v74), v73, vmlaq_f32(vsubq_f32(a9, v71), v69, v72).f32[0]), v69, 2).u64[0];
  return result;
}

double sub_1B6410288(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float32x4_t a9)
{
  float32x4_t v9 = vsubq_f32(a2, a1[5]);
  v9.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v9, _Q1), (int8x16_t)vcltzq_f32(v9))) & 0x80000000) != 0) {
    return 0.0;
  }
  float32x4_t v15 = a1[1];
  float32x4_t v16 = vmulq_f32(*a1, v9);
  int32x4_t v17 = vminq_s32(vcvtq_s32_f32(v16), (int32x4_t)v15);
  float32x4_t v18 = a1[2];
  float32x4_t v19 = (float32x4_t)vmulq_s32((int32x4_t)v18, v17);
  float32x4_t v20 = (float32x4_t)vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL);
  *(int32x2_t *)v19.f32 = vadd_s32(*(int32x2_t *)v19.f32, *(int32x2_t *)v20.f32);
  *(int32x2_t *)v20.f32 = vdup_lane_s32(*(int32x2_t *)v19.f32, 1);
  uint64_t v21 = a1[4].i64[0];
  *(int32x2_t *)v19.f32 = vadd_s32(*(int32x2_t *)v19.f32, *(int32x2_t *)v20.f32);
  float32x4_t v22 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_s32((int32x4_t)v15, v17));
  uint64_t v23 = v19.i32[0] + (uint64_t)v22.i32[0];
  uint64_t v24 = v19.i32[0] + (uint64_t)v22.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)v22.i32[0];
  v26 = (__int32 *)(v21 + v19.i32[0]);
  v22.i32[0] = *v26;
  unsigned int v27 = (float *)(v21 + v23);
  int v28 = (__int32 *)(v21 + v24);
  v18.i32[0] = *v28;
  int v29 = (float *)(v21 + v25);
  v20.i32[0] = *(__int32 *)((char *)v26 + v22.i32[2]);
  a8.f32[0] = *(float *)((char *)v27 + v22.i32[2]);
  a9.i32[0] = *(__int32 *)((char *)v28 + v22.i32[2]);
  float v30 = *(float *)((char *)v29 + v22.i32[2]);
  float32x4_t v31 = vsubq_f32(v16, vrndq_f32(v16));
  v16.f32[0] = *v27 - *(float *)v26;
  float32x4_t v32 = vmlaq_f32(v22, v31, v16);
  v15.f32[0] = a8.f32[0] - v20.f32[0];
  float32x4_t v33 = vmlaq_f32(v20, v31, v15);
  v19.f32[0] = *v29 - *(float *)v28;
  a8.f32[0] = v30 - a9.f32[0];
  float32x4_t v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1);
  float32x4_t v35 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0), v34, vmlaq_f32(vsubq_f32(v18, v32), v31, v19).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v35, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0), v35), v34, vmlaq_f32(vsubq_f32(a9, v33), v31, a8).f32[0]), v31, 2).u64[0];
  return result;
}

double sub_1B6410390(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v2, _Q1), (int8x16_t)vcltzq_f32(v2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, v2);
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int32x4_t v12 = vmulq_s32(v11, v10);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v12, (int8x16_t)v12, 8uLL));
  uint64_t v13 = *(void *)(a1 + 64);
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v11, (int8x16_t)vcgtq_s32(v8, v10));
  __int32 v15 = v14.i32[2];
  uint64_t v16 = v12.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v17 = v12.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v14.i32[0];
  int8x16_t v19 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v20 = (int8x16_t)vdupq_n_s32(0xF800000u);
  uint64_t v21 = (uint16x4_t *)(v13 + v12.i32[0]);
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  int8x16_t v23 = (int8x16_t)vshll_n_u16(*v21, 0xDuLL);
  v12.i64[0] = 0x3800000038000000;
  v12.i64[1] = 0x3800000038000000;
  float32x4_t v24 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v23, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v21), v22), vandq_s8(v23, v19))), v12);
  uint64_t v25 = (uint16x4_t *)(v13 + v16);
  int8x16_t v26 = (int8x16_t)vshll_n_u16(*v25, 0xDuLL);
  float32x4_t v27 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v26, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v25), v22), vandq_s8(v26, v19))), v12);
  int v28 = (uint16x4_t *)(v13 + v17);
  int8x16_t v29 = (int8x16_t)vshll_n_u16(*v28, 0xDuLL);
  float32x4_t v30 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v29, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v28), v22), vandq_s8(v29, v19))), v12);
  float32x4_t v31 = (uint16x4_t *)(v13 + v18);
  int8x16_t v32 = (int8x16_t)vshll_n_u16(*v31, 0xDuLL);
  float32x4_t v33 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v32, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v31), v22), vandq_s8(v32, v19))), v12);
  int16x4_t v34 = *(int16x4_t *)((char *)v21 + v15);
  int8x16_t v35 = vandq_s8((int8x16_t)vmovl_s16(v34), v22);
  int8x16_t v36 = (int8x16_t)vshll_n_u16((uint16x4_t)v34, 0xDuLL);
  float32x4_t v37 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v36, v20), vorrq_s8(v35, vandq_s8(v36, v19))), v12);
  *(uint16x4_t *)v35.i8 = *(uint16x4_t *)((char *)v25 + v15);
  int8x16_t v38 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v35.i8), v22);
  int8x16_t v39 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v35.i8, 0xDuLL);
  float32x4_t v40 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v39, v20), vorrq_s8(v38, vandq_s8(v39, v19))), v12);
  *(uint16x4_t *)v38.i8 = *(uint16x4_t *)((char *)v28 + v15);
  int8x16_t v41 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v38.i8), v22);
  int8x16_t v42 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v38.i8, 0xDuLL);
  float32x4_t v43 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v42, v20), vorrq_s8(v41, vandq_s8(v42, v19))), v12);
  *(uint16x4_t *)v41.i8 = *(uint16x4_t *)((char *)v31 + v15);
  int8x16_t v44 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v41.i8), v22);
  int8x16_t v45 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v41.i8, 0xDuLL);
  float32x4_t v46 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v47 = vmlaq_n_f32(v24, vsubq_f32(v27, v24), v46.f32[0]);
  float32x4_t v48 = vmlaq_n_f32(v37, vsubq_f32(v40, v37), v46.f32[0]);
  float32x4_t v49 = vmlaq_lane_f32(v47, vmlaq_n_f32(vsubq_f32(v30, v47), vsubq_f32(v33, v30), v46.f32[0]), *(float32x2_t *)v46.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v49, vmlaq_lane_f32(vsubq_f32(v48, v49), vmlaq_n_f32(vsubq_f32(v43, v48), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v45, v20), vorrq_s8(v44, vandq_s8(v45, v19))), v12), v43), v46.f32[0]), *(float32x2_t *)v46.f32, 1), v46, 2).u64[0];
  return result;
}

double sub_1B64105A4(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v2, _Q1), (int8x16_t)vcltzq_f32(v2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, v2);
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v10);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  uint64_t v13 = *(void *)(a1 + 64);
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v11, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v12.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v16 = (int)v15 + (uint64_t)v14.i32[0];
  uint64_t v17 = (float32x4_t *)(v13 + v12.i32[0]);
  uint64_t v18 = (float32x4_t *)(v13 + v12.i32[0] + (uint64_t)v14.i32[0]);
  int8x16_t v19 = (float32x4_t *)(v13 + v15);
  int8x16_t v20 = (float32x4_t *)(v13 + v16);
  float32x4_t v21 = *(float32x4_t *)((char *)v17 + v14.i32[2]);
  float32x4_t v22 = *(float32x4_t *)((char *)v18 + v14.i32[2]);
  float32x4_t v23 = *(float32x4_t *)((char *)v19 + v14.i32[2]);
  float32x4_t v24 = *(float32x4_t *)((char *)v20 + v14.i32[2]);
  float32x4_t v25 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v26 = vmlaq_n_f32(*v17, vsubq_f32(*v18, *v17), v25.f32[0]);
  float32x4_t v27 = vmlaq_n_f32(v21, vsubq_f32(v22, v21), v25.f32[0]);
  float32x4_t v28 = vmlaq_lane_f32(v26, vmlaq_n_f32(vsubq_f32(*v19, v26), vsubq_f32(*v20, *v19), v25.f32[0]), *(float32x2_t *)v25.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v28, vmlaq_lane_f32(vsubq_f32(v27, v28), vmlaq_n_f32(vsubq_f32(v23, v27), vsubq_f32(v24, v23), v25.f32[0]), *(float32x2_t *)v25.f32, 1), v25, 2).u64[0];
  return result;
}

double sub_1B64106A0(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float a9)
{
  float32x4_t v11 = vsubq_f32(a2, a1[5]);
  v11.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v11, _Q1), (int8x16_t)vcltzq_f32(v11))) & 0x80000000) != 0) {
    return 0.0;
  }
  float32x4_t v17 = a1[1];
  float32x4_t v18 = vmulq_f32(*a1, v11);
  int32x4_t v19 = vminq_s32(vcvtq_s32_f32(v18), (int32x4_t)v17);
  uint64_t v20 = a1[4].i64[0];
  float32x4_t v21 = a1[2];
  float32x4_t v22 = (float32x4_t)vmulq_s32((int32x4_t)v21, v19);
  float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  *(int32x2_t *)v23.f32 = vdup_lane_s32(*(int32x2_t *)v22.f32, 1);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_s32((int32x4_t)v17, v19));
  uint64_t v25 = v22.i32[0] + (uint64_t)v24.i32[1];
  uint64_t v26 = (int)v25 + (uint64_t)v24.i32[0];
  float32x4_t v27 = (__int8 *)(v20 + v22.i32[0]);
  v17.i8[0] = *v27;
  v17.f32[0] = (float)v17.u32[0] * 0.0039216;
  float32x4_t v28 = (__int8 *)(v20 + v22.i32[0] + (uint64_t)v24.i32[0]);
  v21.i8[0] = *v28;
  int8x16_t v29 = (__int8 *)(v20 + v25);
  v22.i8[0] = *v29;
  v22.f32[0] = (float)v22.u32[0] * 0.0039216;
  float32x4_t v30 = (__int8 *)(v20 + v26);
  v23.i8[0] = *v30;
  a8.i8[0] = v27[v24.i32[2]];
  a8.f32[0] = (float)a8.u32[0] * 0.0039216;
  LOBYTE(a9) = v28[v24.i32[2]];
  v9.i8[0] = v29[v24.i32[2]];
  LOBYTE(v10) = v30[v24.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  float32x4_t v31 = vsubq_f32(v18, vrndq_f32(v18));
  v18.f32[0] = -(float)(v17.f32[0] - (float)((float)v21.u32[0] * 0.0039216));
  float32x4_t v32 = vmlaq_f32(v17, v31, v18);
  v21.f32[0] = -(float)(a8.f32[0] - (float)((float)LODWORD(a9) * 0.0039216));
  float32x4_t v33 = vmlaq_f32(a8, v31, v21);
  v23.f32[0] = -(float)(v22.f32[0] - (float)((float)v23.u32[0] * 0.0039216));
  v24.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1);
  float32x4_t v35 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0), v34, vmlaq_f32(vsubq_f32(v22, v32), v31, v23).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v35, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0), v35), v34, vmlaq_f32(vsubq_f32(v9, v33), v31, v24).f32[0]), v31, 2).u64[0];
  return result;
}

double sub_1B64107E0(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float32x4_t a9)
{
  float32x4_t v11 = vsubq_f32(a2, a1[5]);
  v11.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v11, _Q1), (int8x16_t)vcltzq_f32(v11))) & 0x80000000) != 0) {
    return 0.0;
  }
  float32x4_t v17 = a1[1];
  float32x4_t v18 = vmulq_f32(*a1, v11);
  int32x4_t v19 = vminq_s32(vcvtq_s32_f32(v18), (int32x4_t)v17);
  uint64_t v20 = a1[4].i64[0];
  float32x4_t v21 = a1[2];
  float32x4_t v22 = (float32x4_t)vmulq_s32((int32x4_t)v21, v19);
  float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  *(int32x2_t *)v23.f32 = vdup_lane_s32(*(int32x2_t *)v22.f32, 1);
  float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_s32((int32x4_t)v17, v19));
  *(int32x2_t *)v17.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  uint64_t v25 = v17.i32[0] + (uint64_t)v24.i32[0];
  uint64_t v26 = v17.i32[0] + (uint64_t)v24.i32[1];
  uint64_t v27 = (int)v26 + (uint64_t)v24.i32[0];
  float32x4_t v28 = (__int8 *)(v20 + v17.i32[0]);
  v24.i8[0] = *v28;
  v24.f32[0] = (float)v24.u32[0];
  v17.f32[0] = v24.f32[0] * 0.0039216;
  int8x16_t v29 = (__int8 *)(v20 + v25);
  v24.i8[0] = *v29;
  float32x4_t v30 = (__int8 *)(v20 + v26);
  v22.i8[0] = *v30;
  v22.f32[0] = (float)v22.u32[0] * 0.0039216;
  float32x4_t v31 = (__int8 *)(v20 + v27);
  v23.i8[0] = *v31;
  a8.i8[0] = v28[v24.i32[2]];
  a9.i8[0] = v29[v24.i32[2]];
  a8.f32[0] = (float)a8.u32[0] * 0.0039216;
  v9.i8[0] = v30[v24.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  LOBYTE(v10) = v31[v24.i32[2]];
  float32x4_t v32 = vsubq_f32(v18, vrndq_f32(v18));
  v24.f32[0] = -(float)(v17.f32[0] - (float)((float)v24.u32[0] * 0.0039216));
  float32x4_t v33 = vmlaq_f32(v17, v32, v24);
  v23.f32[0] = -(float)(v22.f32[0] - (float)((float)v23.u32[0] * 0.0039216));
  a9.f32[0] = -(float)(a8.f32[0] - (float)((float)a9.u32[0] * 0.0039216));
  float32x4_t v34 = vmlaq_f32(a8, v32, a9);
  v21.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v35 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1);
  float32x4_t v36 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0), v35, vmlaq_f32(vsubq_f32(v22, v33), v32, v23).f32[0]);
  float32x4_t v37 = vmlaq_laneq_f32(v36, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 0), v36), v35, vmlaq_f32(vsubq_f32(v9, v34), v32, v21).f32[0]), v32, 2);
  float32x4_t v38 = vmulq_f32(v37, v37);
  int32x4_t v39 = vcgeq_f32(v37, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v39.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v39), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v37), v38, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v37)), vmulq_f32(v38, v38), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v37), v38,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v37))), (int8x16_t)vmulq_f32(v37, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B64109D4(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v2, _Q1), (int8x16_t)vcltzq_f32(v2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, v2);
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  uint64_t v11 = *(void *)(a1 + 64);
  int32x4_t v12 = *(int32x4_t *)(a1 + 32);
  int8x16_t v13 = (int8x16_t)vmulq_s32(v12, v10);
  *(int32x2_t *)v13.i8 = vadd_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  v13.i32[0] = vadd_s32(*(int32x2_t *)v13.i8, vdup_lane_s32(*(int32x2_t *)v13.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  uint64_t v16 = v13.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v17 = v13.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v14.i32[0];
  int32x4_t v19 = (const float *)(v11 + v13.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  v12.i64[0] = 0xFF000000FFLL;
  v12.i64[1] = 0xFF000000FFLL;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v24 = (const float *)(v11 + v16);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v25 = (const float *)((char *)v24 + v15);
  uint64_t v27 = (const float *)(v11 + v17);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v28 = (const float *)((char *)v27 + v15);
  float32x4_t v30 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v31 = (const float *)(v11 + v18);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x4_t v32 = (const float *)((char *)v31 + v15);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v20);
  float32x4_t v35 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v36 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v32);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v40 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v41 = vmlaq_n_f32(v23, vmlaq_f32(vnegq_f32(v23), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v35, vmlaq_f32(vnegq_f32(v35), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v36, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v30, v41), vmlaq_f32(vnegq_f32(v30), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v39, v42), vmlaq_f32(vnegq_f32(v39), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2).u64[0];
  return result;
}

double sub_1B6410B68(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v2, _Q1), (int8x16_t)vcltzq_f32(v2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, v2);
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v10);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  uint64_t v13 = *(void *)(a1 + 64);
  int8x16_t v14 = vandq_s8((int8x16_t)v11, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  uint64_t v16 = v12.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v17 = v12.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v14.i32[0];
  int32x4_t v19 = (const float *)(v13 + v12.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v23 = (const float *)(v13 + v16);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v23);
  float32x4_t v24 = (const float *)((char *)v23 + v15);
  float32x4_t v26 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v22);
  uint64_t v27 = (const float *)(v13 + v17);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v28 = (const float *)((char *)v27 + v15);
  float32x4_t v30 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v22);
  float32x4_t v31 = (const float *)(v13 + v18);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x4_t v32 = (const float *)((char *)v31 + v15);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v20);
  float32x4_t v35 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v22);
  uint32x4_t v36 = (uint32x4_t)vld1q_dup_f32(v24);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v38 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v22);
  uint32x4_t v39 = (uint32x4_t)vld1q_dup_f32(v32);
  float32x4_t v40 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v41 = vmlaq_n_f32(v26, vmlaq_f32(vnegq_f32(v26), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v35, vmlaq_f32(vnegq_f32(v35), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v36, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v30, v41), vmlaq_f32(vnegq_f32(v30), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  float32x4_t v44 = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v38, v42), vmlaq_f32(vnegq_f32(v38), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v39, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2);
  float32x4_t v45 = vmulq_f32(v44, v44);
  int32x4_t v46 = vcgeq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v46.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v46), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v44), v45, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v44)), vmulq_f32(v45, v45), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v44), v45,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v44))), (int8x16_t)vmulq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6410DB0(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v2, _Q1), (int8x16_t)vcltzq_f32(v2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, v2);
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v10);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  uint64_t v13 = *(void *)(a1 + 64);
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v11, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  __int32 v16 = v14.i32[0];
  uint64_t v17 = v12.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v18 = v12.i32[0] + (uint64_t)v14.i32[1];
  int32x4_t v19 = (const float *)(v13 + v12.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  uint64_t v22 = (int)v18 + (uint64_t)v16;
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint32x4_t v25 = (const float *)(v13 + v17);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x4_t v26 = (const float *)((char *)v25 + v15);
  float32x4_t v28 = (const float *)(v13 + v18);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v29 = (const float *)((char *)v28 + v15);
  float32x4_t v31 = (const float *)(v13 + v22);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x4_t v32 = (const float *)((char *)v31 + v15);
  float32x4_t v34 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v20);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v26);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint32x4_t v40 = (uint32x4_t)vld1q_dup_f32(v32);
  float32x4_t v41 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v42 = vmlaq_n_f32(v24, vmlaq_f32(vnegq_f32(v24), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]);
  float32x4_t v43 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]);
  float32x4_t v44 = vmlaq_lane_f32(v42, vmlaq_n_f32(vsubq_f32(v34, v42), vmlaq_f32(vnegq_f32(v34), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]), *(float32x2_t *)v41.f32, 1);
  int8x16_t v45 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_laneq_f32(v44, vmlaq_lane_f32(vsubq_f32(v43, v44), vmlaq_n_f32(vsubq_f32(v39, v43), vmlaq_f32(vnegq_f32(v39), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v40, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]), *(float32x2_t *)v41.f32, 1), v41, 2));
  *(void *)&double result = vextq_s8(v45, v45, 0xCuLL).u64[0];
  return result;
}

double sub_1B6410F4C(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(v2, _Q1), (int8x16_t)vcltzq_f32(v2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, v2);
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  uint64_t v11 = *(void *)(a1 + 64);
  int32x4_t v12 = *(int32x4_t *)(a1 + 32);
  int8x16_t v13 = (int8x16_t)vmulq_s32(v12, v10);
  *(int32x2_t *)v13.i8 = vadd_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  v13.i32[0] = vadd_s32(*(int32x2_t *)v13.i8, vdup_lane_s32(*(int32x2_t *)v13.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  uint64_t v16 = v13.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v17 = v13.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v14.i32[0];
  int32x4_t v19 = (const float *)(v11 + v13.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  v12.i64[0] = 0xFF000000FFLL;
  v12.i64[1] = 0xFF000000FFLL;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v24 = (const float *)(v11 + v16);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint32x4_t v25 = (const float *)((char *)v24 + v15);
  uint32x4_t v27 = (const float *)(v11 + v17);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v28 = (const float *)((char *)v27 + v15);
  uint32x4_t v30 = (const float *)(v11 + v18);
  uint32x4_t v32 = (uint32x4_t)vld1q_dup_f32(v30);
  float32x4_t v31 = (const float *)((char *)v30 + v15);
  float32x4_t v33 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v20);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v38 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v39 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x4_t v40 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v41 = vmlaq_n_f32(v23, vmlaq_f32(vnegq_f32(v23), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v33, v41), vmlaq_f32(vnegq_f32(v33), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v32, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  float32x4_t v44 = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v38, v42), vmlaq_f32(vnegq_f32(v38), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v39, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2);
  float32x4_t v45 = vmulq_f32(v44, v44);
  int32x4_t v46 = vcgeq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v46.i32[3] = 0;
  int32x4_t v47 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v46), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v44), v45, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v44)), vmulq_f32(v45, v45), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v44), v45,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v44))), (int8x16_t)vmulq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v47.i32[3] = v44.i32[3];
  int8x16_t v48 = (int8x16_t)vrev64q_s32(v47);
  *(void *)&double result = vextq_s8(v48, v48, 0xCuLL).u64[0];
  return result;
}

double sub_1B641119C(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float32x4_t a9)
{
  float32x4_t v9 = vsubq_f32(a2, a1[5]);
  v9.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v14 = a1[1];
  float32x4_t v15 = vmulq_f32(*a1, vminnmq_f32(vmaxnmq_f32(v9, (float32x4_t)0), _Q1));
  int32x4_t v16 = vminq_s32(vcvtq_s32_f32(v15), (int32x4_t)v14);
  uint64_t v17 = a1[4].i64[0];
  float32x4_t v18 = a1[2];
  float32x4_t v20 = (float32x4_t)vmulq_s32((int32x4_t)v18, v16);
  float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL);
  *(int32x2_t *)v20.f32 = vadd_s32(*(int32x2_t *)v20.f32, *(int32x2_t *)v19.f32);
  *(int32x2_t *)v19.f32 = vdup_lane_s32(*(int32x2_t *)v20.f32, 1);
  *(int32x2_t *)v20.f32 = vadd_s32(*(int32x2_t *)v20.f32, *(int32x2_t *)v19.f32);
  float32x4_t v21 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_s32((int32x4_t)v14, v16));
  uint64_t v22 = v20.i32[0] + (uint64_t)v21.i32[0];
  uint64_t v23 = v20.i32[0] + (uint64_t)v21.i32[1];
  uint64_t v24 = (int)v23 + (uint64_t)v21.i32[0];
  uint32x4_t v25 = (unsigned __int16 *)(v17 + v20.i32[0]);
  unsigned int v26 = *v25;
  int v27 = (v26 >> 10) & 0x1F;
  if (v27 == 31) {
    int v28 = 2139095040;
  }
  else {
    int v28 = (v26 >> 10) & 0x1F;
  }
  if (v27) {
    _ZF = v27 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    int v30 = v28;
  }
  else {
    int v30 = (v27 << 23) + 939524096;
  }
  uint64_t v31 = v17 + v22;
  unsigned int v32 = *(unsigned __int16 *)(v17 + v22);
  int v33 = (v32 >> 10) & 0x1F;
  if (v33 == 31) {
    int v34 = 2139095040;
  }
  else {
    int v34 = (v32 >> 10) & 0x1F;
  }
  if (v33) {
    BOOL v35 = v33 == 31;
  }
  else {
    BOOL v35 = 1;
  }
  if (v35) {
    int v36 = v34;
  }
  else {
    int v36 = (v33 << 23) + 939524096;
  }
  uint64_t v37 = v17 + v23;
  unsigned int v38 = *(unsigned __int16 *)(v17 + v23);
  int v39 = (v38 >> 10) & 0x1F;
  if (v39 == 31) {
    int v40 = 2139095040;
  }
  else {
    int v40 = (v38 >> 10) & 0x1F;
  }
  if (v39) {
    BOOL v41 = v39 == 31;
  }
  else {
    BOOL v41 = 1;
  }
  if (v41) {
    int v42 = v40;
  }
  else {
    int v42 = (v39 << 23) + 939524096;
  }
  float32x4_t v43 = (unsigned __int16 *)(v17 + v24);
  unsigned int v44 = *v43;
  int v45 = (v44 >> 10) & 0x1F;
  if (v45 == 31) {
    int v46 = 2139095040;
  }
  else {
    int v46 = (v44 >> 10) & 0x1F;
  }
  if (v45) {
    BOOL v47 = v45 == 31;
  }
  else {
    BOOL v47 = 1;
  }
  if (v47) {
    int v48 = v46;
  }
  else {
    int v48 = (v45 << 23) + 939524096;
  }
  unsigned int v49 = *(unsigned __int16 *)((char *)v25 + v21.i32[2]);
  int v50 = (v49 >> 10) & 0x1F;
  if (v50 == 31) {
    int v51 = 2139095040;
  }
  else {
    int v51 = (v49 >> 10) & 0x1F;
  }
  if (v50) {
    BOOL v52 = v50 == 31;
  }
  else {
    BOOL v52 = 1;
  }
  if (!v52) {
    int v51 = (v50 << 23) + 939524096;
  }
  unsigned int v53 = *(unsigned __int16 *)(v31 + v21.i32[2]);
  int v54 = (v53 >> 10) & 0x1F;
  if (v54 == 31) {
    int v55 = 2139095040;
  }
  else {
    int v55 = (v53 >> 10) & 0x1F;
  }
  if (v54) {
    BOOL v56 = v54 == 31;
  }
  else {
    BOOL v56 = 1;
  }
  if (!v56) {
    int v55 = (v54 << 23) + 939524096;
  }
  unsigned int v57 = *(unsigned __int16 *)(v37 + v21.i32[2]);
  int v58 = (v57 >> 10) & 0x1F;
  if (v58 == 31) {
    int v59 = 2139095040;
  }
  else {
    int v59 = (v57 >> 10) & 0x1F;
  }
  if (v58) {
    BOOL v60 = v58 == 31;
  }
  else {
    BOOL v60 = 1;
  }
  if (!v60) {
    int v59 = (v58 << 23) + 939524096;
  }
  unsigned int v61 = *(unsigned __int16 *)((char *)v43 + v21.i32[2]);
  int v62 = (v61 >> 10) & 0x1F;
  if (v62 == 31) {
    int v63 = 2139095040;
  }
  else {
    int v63 = (v61 >> 10) & 0x1F;
  }
  if (v62) {
    BOOL v64 = v62 == 31;
  }
  else {
    BOOL v64 = 1;
  }
  if (v64) {
    int v65 = v63;
  }
  else {
    int v65 = (v62 << 23) + 939524096;
  }
  v21.i32[0] = v59 | (v57 << 16) & 0x80000000 | (v57 >> 7) & 7 | (8 * (v57 & 0x3FF)) & 0x1FFF | ((v57 & 0x3FF) << 13);
  v14.i32[0] = v55 | (v53 << 16) & 0x80000000 | (v53 >> 7) & 7 | (8 * (v53 & 0x3FF)) & 0x1FFF | ((v53 & 0x3FF) << 13);
  v18.i32[0] = v51 | (v49 << 16) & 0x80000000 | (v49 >> 7) & 7 | (8 * (v49 & 0x3FF)) & 0x1FFF | ((v49 & 0x3FF) << 13);
  v20.i32[0] = v48 | (v44 << 16) & 0x80000000 | (v44 >> 7) & 7 | (8 * (v44 & 0x3FF)) & 0x1FFF | ((v44 & 0x3FF) << 13);
  v19.i32[0] = v42 | (v38 << 16) & 0x80000000 | (v38 >> 7) & 7 | (8 * (v38 & 0x3FF)) & 0x1FFF | ((v38 & 0x3FF) << 13);
  a8.i32[0] = v36 | (v32 << 16) & 0x80000000 | (v32 >> 7) & 7 | (8 * (v32 & 0x3FF)) & 0x1FFF | ((v32 & 0x3FF) << 13);
  a9.i32[0] = v30 | (v26 << 16) & 0x80000000 | (v26 >> 7) & 7 | (8 * (v26 & 0x3FF)) & 0x1FFF | ((v26 & 0x3FF) << 13);
  float32x4_t v66 = vsubq_f32(v15, vrndq_f32(v15));
  float32x4_t v67 = vmlaq_f32(a9, v66, vsubq_f32(a8, a9));
  a8.i32[0] = v65 | (v61 << 16) & 0x80000000 | (v61 >> 7) & 7 | (8 * (v61 & 0x3FF)) & 0x1FFF | ((v61 & 0x3FF) << 13);
  float32x4_t v68 = vmlaq_f32(v18, v66, vsubq_f32(v14, v18));
  float32x4_t v69 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v66.f32, 1);
  float32x4_t v70 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v67.f32, 0), v69, vmlaq_f32(vsubq_f32(v19, v67), v66, vsubq_f32(v20, v19)).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v70, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), v70), v69, vmlaq_f32(vsubq_f32(v21, v68), v66, vsubq_f32(a8, v21)).f32[0]), v66, 2).u64[0];
  return result;
}

double sub_1B64114A4(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float32x4_t a9)
{
  float32x4_t v9 = vsubq_f32(a2, a1[5]);
  v9.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v15 = a1[1];
  float32x4_t v16 = vmulq_f32(*a1, vminnmq_f32(vmaxnmq_f32(v9, (float32x4_t)0), _Q1));
  int32x4_t v17 = vminq_s32(vcvtq_s32_f32(v16), (int32x4_t)v15);
  uint64_t v18 = a1[4].i64[0];
  float32x4_t v19 = a1[2];
  float32x4_t v20 = (float32x4_t)vmulq_s32((int32x4_t)v19, v17);
  float32x4_t v21 = (float32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL);
  *(int32x2_t *)v20.f32 = vadd_s32(*(int32x2_t *)v20.f32, *(int32x2_t *)v21.f32);
  *(int32x2_t *)v21.f32 = vdup_lane_s32(*(int32x2_t *)v20.f32, 1);
  float32x4_t v22 = (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_s32((int32x4_t)v15, v17));
  *(int32x2_t *)v15.f32 = vadd_s32(*(int32x2_t *)v20.f32, *(int32x2_t *)v21.f32);
  uint64_t v23 = v15.i32[0] + (uint64_t)v22.i32[0];
  uint64_t v24 = v15.i32[0] + (uint64_t)v22.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)v22.i32[0];
  unsigned int v26 = (__int32 *)(v18 + v15.i32[0]);
  v22.i32[0] = *v26;
  int v27 = (float *)(v18 + v23);
  int v28 = (__int32 *)(v18 + v24);
  v19.i32[0] = *v28;
  uint32x4_t v29 = (float *)(v18 + v25);
  v20.i32[0] = *(__int32 *)((char *)v26 + v22.i32[2]);
  v21.f32[0] = *(float *)((char *)v27 + v22.i32[2]);
  a8.i32[0] = *(__int32 *)((char *)v28 + v22.i32[2]);
  a9.f32[0] = *(float *)((char *)v29 + v22.i32[2]);
  float32x4_t v30 = vsubq_f32(v16, vrndq_f32(v16));
  v16.f32[0] = *v27 - *(float *)v26;
  float32x4_t v31 = vmlaq_f32(v22, v30, v16);
  v15.f32[0] = *v29 - *(float *)v28;
  v21.f32[0] = v21.f32[0] - v20.f32[0];
  float32x4_t v32 = vmlaq_f32(v20, v30, v21);
  a9.f32[0] = a9.f32[0] - a8.f32[0];
  float32x4_t v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1);
  float32x4_t v34 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 0), v33, vmlaq_f32(vsubq_f32(v19, v31), v30, v15).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v34, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0), v34), v33, vmlaq_f32(vsubq_f32(a8, v32), v30, a9).f32[0]), v30, 2).u64[0];
  return result;
}

double sub_1B6411598(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q1));
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  uint64_t v11 = *(void *)(a1 + 64);
  int32x4_t v12 = *(int32x4_t *)(a1 + 32);
  int8x16_t v13 = (int8x16_t)vmulq_s32(v12, v10);
  *(int32x2_t *)v13.i8 = vadd_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  int8x16_t v14 = vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_s32(v8, v10));
  __int32 v15 = v14.i32[2];
  v8.i32[0] = vadd_s32(*(int32x2_t *)v13.i8, vdup_lane_s32(*(int32x2_t *)v13.i8, 1)).u32[0];
  uint64_t v16 = v8.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v17 = v8.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v14.i32[0];
  int8x16_t v19 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v20 = (int8x16_t)vdupq_n_s32(0xF800000u);
  float32x4_t v21 = (uint16x4_t *)(v11 + v8.i32[0]);
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  int8x16_t v23 = (int8x16_t)vshll_n_u16(*v21, 0xDuLL);
  v8.i64[0] = 0x3800000038000000;
  v8.i64[1] = 0x3800000038000000;
  float32x4_t v24 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v23, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v21), v22), vandq_s8(v23, v19))), v8);
  uint64_t v25 = (uint16x4_t *)(v11 + v16);
  int8x16_t v26 = (int8x16_t)vshll_n_u16(*v25, 0xDuLL);
  float32x4_t v27 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v26, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v25), v22), vandq_s8(v26, v19))), v8);
  int v28 = (uint16x4_t *)(v11 + v17);
  int8x16_t v29 = (int8x16_t)vshll_n_u16(*v28, 0xDuLL);
  float32x4_t v30 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v29, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v28), v22), vandq_s8(v29, v19))), v8);
  float32x4_t v31 = (uint16x4_t *)(v11 + v18);
  int8x16_t v32 = (int8x16_t)vshll_n_u16(*v31, 0xDuLL);
  float32x4_t v33 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v32, v20), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v31), v22), vandq_s8(v32, v19))), v8);
  int16x4_t v34 = *(int16x4_t *)((char *)v21 + v15);
  int8x16_t v35 = vandq_s8((int8x16_t)vmovl_s16(v34), v22);
  int8x16_t v36 = (int8x16_t)vshll_n_u16((uint16x4_t)v34, 0xDuLL);
  float32x4_t v37 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v36, v20), vorrq_s8(v35, vandq_s8(v36, v19))), v8);
  *(uint16x4_t *)v35.i8 = *(uint16x4_t *)((char *)v25 + v15);
  int8x16_t v38 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v35.i8), v22);
  int8x16_t v39 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v35.i8, 0xDuLL);
  int32x4_t v40 = (int32x4_t)vorrq_s8(vandq_s8(v39, v20), vorrq_s8(v38, vandq_s8(v39, v19)));
  *(uint16x4_t *)v38.i8 = *(uint16x4_t *)((char *)v28 + v15);
  int8x16_t v41 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v38.i8), v22);
  int8x16_t v42 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v38.i8, 0xDuLL);
  float32x4_t v43 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v42, v20), vorrq_s8(v41, vandq_s8(v42, v19))), v8);
  *(uint16x4_t *)v41.i8 = *(uint16x4_t *)((char *)v31 + v15);
  int8x16_t v44 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v41.i8), v22);
  int8x16_t v45 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v41.i8, 0xDuLL);
  float32x4_t v46 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v47 = vmlaq_n_f32(v24, vsubq_f32(v27, v24), v46.f32[0]);
  float32x4_t v48 = vmlaq_n_f32(v37, vsubq_f32((float32x4_t)vaddq_s32(v40, v8), v37), v46.f32[0]);
  float32x4_t v49 = vmlaq_lane_f32(v47, vmlaq_n_f32(vsubq_f32(v30, v47), vsubq_f32(v33, v30), v46.f32[0]), *(float32x2_t *)v46.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v49, vmlaq_lane_f32(vsubq_f32(v48, v49), vmlaq_n_f32(vsubq_f32(v43, v48), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v45, v20), vorrq_s8(v44, vandq_s8(v45, v19))), v8), v43), v46.f32[0]), *(float32x2_t *)v46.f32, 1), v46, 2).u64[0];
  return result;
}

double sub_1B6411798(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q1));
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  uint64_t v11 = *(void *)(a1 + 64);
  int32x4_t v12 = *(int32x4_t *)(a1 + 32);
  int8x16_t v13 = (int8x16_t)vmulq_s32(v12, v10);
  *(int32x2_t *)v13.i8 = vadd_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  int8x16_t v14 = vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_s32(v8, v10));
  __int32 v15 = v14.i32[2];
  v8.i32[0] = vadd_s32(*(int32x2_t *)v13.i8, vdup_lane_s32(*(int32x2_t *)v13.i8, 1)).u32[0];
  uint64_t v16 = v8.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v17 = (int)v16 + (uint64_t)v14.i32[0];
  uint64_t v18 = (float32x4_t *)(v11 + v8.i32[0]);
  int8x16_t v19 = (float32x4_t *)(v11 + v8.i32[0] + (uint64_t)v14.i32[0]);
  int8x16_t v20 = (float32x4_t *)(v11 + v16);
  float32x4_t v21 = (float32x4_t *)(v11 + v17);
  float32x4_t v22 = *(float32x4_t *)((char *)v18 + v14.i32[2]);
  float32x4_t v23 = *(float32x4_t *)((char *)v20 + v14.i32[2]);
  float32x4_t v24 = *(float32x4_t *)((char *)v21 + v14.i32[2]);
  float32x4_t v25 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v26 = vmlaq_n_f32(*v18, vsubq_f32(*v19, *v18), v25.f32[0]);
  float32x4_t v27 = vmlaq_n_f32(v22, vsubq_f32(*(float32x4_t *)((char *)v19 + v15), v22), v25.f32[0]);
  float32x4_t v28 = vmlaq_lane_f32(v26, vmlaq_n_f32(vsubq_f32(*v20, v26), vsubq_f32(*v21, *v20), v25.f32[0]), *(float32x2_t *)v25.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v28, vmlaq_lane_f32(vsubq_f32(v27, v28), vmlaq_n_f32(vsubq_f32(v23, v27), vsubq_f32(v24, v23), v25.f32[0]), *(float32x2_t *)v25.f32, 1), v25, 2).u64[0];
  return result;
}

double sub_1B6411880(uint64_t a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float32x4_t a9)
{
  float32x4_t v11 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v11.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v17 = *(float32x4_t *)(a1 + 16);
  float32x4_t v18 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q1));
  int32x4_t v19 = vminq_s32(vcvtq_s32_f32(v18), (int32x4_t)v17);
  uint64_t v20 = *(void *)(a1 + 64);
  int32x4_t v21 = *(int32x4_t *)(a1 + 32);
  float32x4_t v22 = (float32x4_t)vmulq_s32(v21, v19);
  float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  *(int32x2_t *)v23.f32 = vdup_lane_s32(*(int32x2_t *)v22.f32, 1);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_s32((int32x4_t)v17, v19));
  uint64_t v25 = v22.i32[0] + (uint64_t)v24.i32[1];
  uint64_t v26 = (int)v25 + (uint64_t)v24.i32[0];
  float32x4_t v27 = (__int8 *)(v20 + v22.i32[0]);
  v17.i8[0] = *v27;
  v17.f32[0] = (float)v17.u32[0] * 0.0039216;
  float32x4_t v28 = (__int8 *)(v20 + v22.i32[0] + (uint64_t)v24.i32[0]);
  v21.i8[0] = *v28;
  int8x16_t v29 = (__int8 *)(v20 + v25);
  v22.i8[0] = *v29;
  v22.f32[0] = (float)v22.u32[0] * 0.0039216;
  float32x4_t v30 = (__int8 *)(v20 + v26);
  v23.i8[0] = *v30;
  a8.i8[0] = v27[v24.i32[2]];
  a8.f32[0] = (float)a8.u32[0] * 0.0039216;
  a9.i8[0] = v28[v24.i32[2]];
  v9.i8[0] = v29[v24.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  LOBYTE(v10) = v30[v24.i32[2]];
  float32x4_t v31 = vsubq_f32(v18, vrndq_f32(v18));
  v18.f32[0] = -(float)(v17.f32[0] - (float)((float)v21.u32[0] * 0.0039216));
  float32x4_t v32 = vmlaq_f32(v17, v31, v18);
  v23.f32[0] = -(float)(v22.f32[0] - (float)((float)v23.u32[0] * 0.0039216));
  a9.f32[0] = -(float)(a8.f32[0] - (float)((float)a9.u32[0] * 0.0039216));
  float32x4_t v33 = vmlaq_f32(a8, v31, a9);
  v24.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1);
  float32x4_t v35 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0), v34, vmlaq_f32(vsubq_f32(v22, v32), v31, v23).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v35, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0), v35), v34, vmlaq_f32(vsubq_f32(v9, v33), v31, v24).f32[0]), v31, 2).u64[0];
  return result;
}

double sub_1B64119AC(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8, float32x4_t a9)
{
  float32x4_t v11 = vsubq_f32(a2, a1[5]);
  v11.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v17 = a1[1];
  float32x4_t v18 = vmulq_f32(*a1, vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q1));
  int32x4_t v19 = vminq_s32(vcvtq_s32_f32(v18), (int32x4_t)v17);
  uint64_t v20 = a1[4].i64[0];
  float32x4_t v21 = a1[2];
  float32x4_t v22 = (float32x4_t)vmulq_s32((int32x4_t)v21, v19);
  float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  *(int32x2_t *)v23.f32 = vdup_lane_s32(*(int32x2_t *)v22.f32, 1);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  float32x4_t v24 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_s32((int32x4_t)v17, v19));
  uint64_t v25 = v22.i32[0] + (uint64_t)v24.i32[0];
  uint64_t v26 = v22.i32[0] + (uint64_t)v24.i32[1];
  uint64_t v27 = (int)v26 + (uint64_t)v24.i32[0];
  float32x4_t v28 = (__int8 *)(v20 + v22.i32[0]);
  v24.i8[0] = *v28;
  v24.f32[0] = (float)v24.u32[0];
  v21.f32[0] = v24.f32[0] * 0.0039216;
  int8x16_t v29 = (__int8 *)(v20 + v25);
  v24.i8[0] = *v29;
  float32x4_t v30 = (__int8 *)(v20 + v26);
  v22.i8[0] = *v30;
  v22.f32[0] = (float)v22.u32[0] * 0.0039216;
  float32x4_t v31 = (__int8 *)(v20 + v27);
  v23.i8[0] = *v31;
  a8.i8[0] = v28[v24.i32[2]];
  a8.f32[0] = (float)a8.u32[0] * 0.0039216;
  a9.i8[0] = v29[v24.i32[2]];
  v9.i8[0] = v30[v24.i32[2]];
  LOBYTE(v10) = v31[v24.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  float32x4_t v32 = vsubq_f32(v18, vrndq_f32(v18));
  v24.f32[0] = -(float)(v21.f32[0] - (float)((float)v24.u32[0] * 0.0039216));
  float32x4_t v33 = vmlaq_f32(v21, v32, v24);
  a9.f32[0] = -(float)(a8.f32[0] - (float)((float)a9.u32[0] * 0.0039216));
  float32x4_t v34 = vmlaq_f32(a8, v32, a9);
  v23.f32[0] = -(float)(v22.f32[0] - (float)((float)v23.u32[0] * 0.0039216));
  v17.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v35 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1);
  float32x4_t v36 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0), v35, vmlaq_f32(vsubq_f32(v22, v33), v32, v23).f32[0]);
  float32x4_t v37 = vmlaq_laneq_f32(v36, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 0), v36), v35, vmlaq_f32(vsubq_f32(v9, v34), v32, v17).f32[0]), v32, 2);
  float32x4_t v38 = vmulq_f32(v37, v37);
  int32x4_t v39 = vcgeq_f32(v37, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v39.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v39), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v37), v38, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v37)), vmulq_f32(v38, v38), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v37), v38,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v37))), (int8x16_t)vmulq_f32(v37, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6411B8C(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q1));
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  uint64_t v11 = *(void *)(a1 + 64);
  int32x4_t v12 = *(int32x4_t *)(a1 + 32);
  int8x16_t v13 = (int8x16_t)vmulq_s32(v12, v10);
  *(int32x2_t *)v13.i8 = vadd_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  v13.i32[0] = vadd_s32(*(int32x2_t *)v13.i8, vdup_lane_s32(*(int32x2_t *)v13.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  uint64_t v16 = v13.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v17 = v13.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v14.i32[0];
  int32x4_t v19 = (const float *)(v11 + v13.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  v12.i64[0] = 0xFF000000FFLL;
  v12.i64[1] = 0xFF000000FFLL;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v24 = (const float *)(v11 + v16);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v25 = (const float *)((char *)v24 + v15);
  uint64_t v27 = (const float *)(v11 + v17);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v28 = (const float *)((char *)v27 + v15);
  float32x4_t v30 = (const float *)(v11 + v18);
  uint32x4_t v32 = (uint32x4_t)vld1q_dup_f32(v30);
  float32x4_t v31 = (const float *)((char *)v30 + v15);
  float32x4_t v33 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v20);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v38 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v39 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x4_t v40 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v41 = vmlaq_n_f32(v23, vmlaq_f32(vnegq_f32(v23), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v33, v41), vmlaq_f32(vnegq_f32(v33), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v32, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v38, v42), vmlaq_f32(vnegq_f32(v38), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v39, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2).u64[0];
  return result;
}

double sub_1B6411D0C(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q1));
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  uint64_t v11 = *(void *)(a1 + 64);
  int32x4_t v12 = *(int32x4_t *)(a1 + 32);
  int8x16_t v13 = (int8x16_t)vmulq_s32(v12, v10);
  *(int32x2_t *)v13.i8 = vadd_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  v13.i32[0] = vadd_s32(*(int32x2_t *)v13.i8, vdup_lane_s32(*(int32x2_t *)v13.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  uint64_t v16 = v13.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v17 = v13.i32[0] + (uint64_t)v14.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v14.i32[0];
  int32x4_t v19 = (const float *)(v11 + v13.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  v12.i64[0] = 0xFF000000FFLL;
  v12.i64[1] = 0xFF000000FFLL;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v24 = (const float *)(v11 + v16);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v25 = (const float *)((char *)v24 + v15);
  uint64_t v27 = (const float *)(v11 + v17);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v28 = (const float *)((char *)v27 + v15);
  float32x4_t v30 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v31 = (const float *)(v11 + v18);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v31);
  uint32x4_t v32 = (const float *)((char *)v31 + v15);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v20);
  float32x4_t v35 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  uint32x4_t v36 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v32);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v22);
  float32x4_t v40 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v41 = vmlaq_n_f32(v23, vmlaq_f32(vnegq_f32(v23), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v35, vmlaq_f32(vnegq_f32(v35), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v36, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v30, v41), vmlaq_f32(vnegq_f32(v30), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  float32x4_t v44 = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v39, v42), vmlaq_f32(vnegq_f32(v39), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2);
  float32x4_t v45 = vmulq_f32(v44, v44);
  int32x4_t v46 = vcgeq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v46.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v46), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v44), v45, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v44)), vmulq_f32(v45, v45), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v44), v45,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v44))), (int8x16_t)vmulq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6411F40(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q1));
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  uint64_t v11 = *(void *)(a1 + 64);
  int32x4_t v12 = *(int32x4_t *)(a1 + 32);
  int8x16_t v13 = (int8x16_t)vmulq_s32(v12, v10);
  *(int32x2_t *)v13.i8 = vadd_s32(*(int32x2_t *)v13.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  v13.i32[0] = vadd_s32(*(int32x2_t *)v13.i8, vdup_lane_s32(*(int32x2_t *)v13.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v12, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  __int32 v16 = v14.i32[0];
  uint64_t v17 = v13.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v18 = v13.i32[0] + (uint64_t)v14.i32[1];
  int32x4_t v19 = (const float *)(v11 + v13.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  uint64_t v22 = (int)v18 + (uint64_t)v16;
  v12.i64[0] = 0xFF000000FFLL;
  v12.i64[1] = 0xFF000000FFLL;
  float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v23);
  uint64_t v25 = (const float *)(v11 + v17);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v26 = (const float *)((char *)v25 + v15);
  float32x4_t v28 = (const float *)(v11 + v18);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v29 = (const float *)((char *)v28 + v15);
  float32x4_t v31 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v23);
  uint32x4_t v32 = (const float *)(v11 + v22);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v32);
  uint32x4_t v33 = (const float *)((char *)v32 + v15);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v20);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v23);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v26);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12)), v23);
  uint32x4_t v40 = (uint32x4_t)vld1q_dup_f32(v33);
  float32x4_t v41 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v42 = vmlaq_n_f32(v24, vmlaq_f32(vnegq_f32(v24), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v41.f32[0]);
  float32x4_t v43 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v41.f32[0]);
  float32x4_t v44 = vmlaq_lane_f32(v42, vmlaq_n_f32(vsubq_f32(v31, v42), vmlaq_f32(vnegq_f32(v31), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v41.f32[0]), *(float32x2_t *)v41.f32, 1);
  int8x16_t v45 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_laneq_f32(v44, vmlaq_lane_f32(vsubq_f32(v43, v44), vmlaq_n_f32(vsubq_f32(v39, v43), vmlaq_f32(vnegq_f32(v39), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v40, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v12))), v41.f32[0]), *(float32x2_t *)v41.f32, 1), v41, 2));
  *(void *)&double result = vextq_s8(v45, v45, 0xCuLL).u64[0];
  return result;
}

double sub_1B64120C8(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  int32x4_t v8 = *(int32x4_t *)(a1 + 16);
  float32x4_t v9 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q1));
  int32x4_t v10 = vminq_s32(vcvtq_s32_f32(v9), v8);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v10);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  uint64_t v13 = *(void *)(a1 + 64);
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  int8x16_t v14 = vandq_s8((int8x16_t)v11, (int8x16_t)vcgtq_s32(v8, v10));
  uint64_t v15 = v14.i32[2];
  __int32 v16 = v14.i32[0];
  uint64_t v17 = v12.i32[0] + (uint64_t)v14.i32[0];
  uint64_t v18 = v12.i32[0] + (uint64_t)v14.i32[1];
  int32x4_t v19 = (const float *)(v13 + v12.i32[0]);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v19);
  uint64_t v20 = (const float *)((char *)v19 + v15);
  uint64_t v22 = (int)v18 + (uint64_t)v16;
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint64_t v25 = (const float *)(v13 + v17);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v26 = (const float *)((char *)v25 + v15);
  float32x4_t v28 = (const float *)(v13 + v18);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v29 = (const float *)((char *)v28 + v15);
  float32x4_t v31 = (const float *)(v13 + v22);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v31);
  uint32x4_t v32 = (const float *)((char *)v31 + v15);
  float32x4_t v34 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v20);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v26);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11)), v23);
  uint32x4_t v40 = (uint32x4_t)vld1q_dup_f32(v32);
  float32x4_t v41 = vsubq_f32(v9, vrndq_f32(v9));
  float32x4_t v42 = vmlaq_n_f32(v24, vmlaq_f32(vnegq_f32(v24), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]);
  float32x4_t v43 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]);
  float32x4_t v44 = vmlaq_lane_f32(v42, vmlaq_n_f32(vsubq_f32(v34, v42), vmlaq_f32(vnegq_f32(v34), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]), *(float32x2_t *)v41.f32, 1);
  float32x4_t v45 = vmlaq_laneq_f32(v44, vmlaq_lane_f32(vsubq_f32(v43, v44), vmlaq_n_f32(vsubq_f32(v39, v43), vmlaq_f32(vnegq_f32(v39), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v40, (uint32x4_t)xmmword_1B6E50360), (int8x16_t)v11))), v41.f32[0]), *(float32x2_t *)v41.f32, 1), v41, 2);
  float32x4_t v46 = vmulq_f32(v45, v45);
  int32x4_t v47 = vcgeq_f32(v45, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v47.i32[3] = 0;
  int32x4_t v48 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v47), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v45), v46, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v45)), vmulq_f32(v46, v46), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v45), v46,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v45))), (int8x16_t)vmulq_f32(v45, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v48.i32[3] = v45.i32[3];
  int8x16_t v49 = (int8x16_t)vrev64q_s32(v48);
  *(void *)&double result = vextq_s8(v49, v49, 0xCuLL).u64[0];
  return result;
}

double sub_1B6412304(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v9 = vsubq_f32(a2, a1[5]);
  v9.i32[3] = 0;
  float32x4_t v10 = a1[1];
  float32x4_t v11 = vmulq_f32(*a1, vminnmq_f32(vsubq_f32(v9, vrndmq_f32(v9)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v12 = vminq_s32(vcvtq_s32_f32(v11), (int32x4_t)v10);
  uint64_t v13 = a1[4].i64[0];
  float32x4_t v15 = a1[2];
  float32x4_t v14 = a1[3];
  float32x4_t v17 = (float32x4_t)vmulq_s32((int32x4_t)v15, v12);
  float32x4_t v16 = (float32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL);
  *(int32x2_t *)v17.f32 = vadd_s32(*(int32x2_t *)v17.f32, *(int32x2_t *)v16.f32);
  *(int32x2_t *)v16.f32 = vdup_lane_s32(*(int32x2_t *)v17.f32, 1);
  *(int32x2_t *)v17.f32 = vadd_s32(*(int32x2_t *)v17.f32, *(int32x2_t *)v16.f32);
  float32x4_t v18 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v10, v12), (int8x16_t)v15, (int8x16_t)v14);
  uint64_t v19 = v17.i32[0] + (uint64_t)v18.i32[0];
  uint64_t v20 = v17.i32[0] + (uint64_t)v18.i32[1];
  uint64_t v21 = (int)v20 + (uint64_t)v18.i32[0];
  uint64_t v22 = (unsigned __int16 *)(v13 + v17.i32[0]);
  unsigned int v23 = *v22;
  int v24 = (v23 >> 10) & 0x1F;
  if (v24 == 31) {
    int v25 = 2139095040;
  }
  else {
    int v25 = (v23 >> 10) & 0x1F;
  }
  if (v24) {
    BOOL v26 = v24 == 31;
  }
  else {
    BOOL v26 = 1;
  }
  if (v26) {
    int v27 = v25;
  }
  else {
    int v27 = (v24 << 23) + 939524096;
  }
  uint64_t v28 = v13 + v19;
  unsigned int v29 = *(unsigned __int16 *)(v13 + v19);
  int v30 = (v29 >> 10) & 0x1F;
  if (v30 == 31) {
    int v31 = 2139095040;
  }
  else {
    int v31 = (v29 >> 10) & 0x1F;
  }
  if (v30) {
    BOOL v32 = v30 == 31;
  }
  else {
    BOOL v32 = 1;
  }
  if (v32) {
    int v33 = v31;
  }
  else {
    int v33 = (v30 << 23) + 939524096;
  }
  uint64_t v34 = v13 + v20;
  unsigned int v35 = *(unsigned __int16 *)(v13 + v20);
  int v36 = (v35 >> 10) & 0x1F;
  if (v36 == 31) {
    int v37 = 2139095040;
  }
  else {
    int v37 = (v35 >> 10) & 0x1F;
  }
  if (v36) {
    BOOL v38 = v36 == 31;
  }
  else {
    BOOL v38 = 1;
  }
  if (v38) {
    int v39 = v37;
  }
  else {
    int v39 = (v36 << 23) + 939524096;
  }
  uint32x4_t v40 = (unsigned __int16 *)(v13 + v21);
  unsigned int v41 = *v40;
  int v42 = (v41 >> 10) & 0x1F;
  if (v42 == 31) {
    int v43 = 2139095040;
  }
  else {
    int v43 = (v41 >> 10) & 0x1F;
  }
  if (v42) {
    BOOL v44 = v42 == 31;
  }
  else {
    BOOL v44 = 1;
  }
  if (v44) {
    int v45 = v43;
  }
  else {
    int v45 = (v42 << 23) + 939524096;
  }
  unsigned int v46 = *(unsigned __int16 *)((char *)v22 + v18.i32[2]);
  int v47 = (v46 >> 10) & 0x1F;
  if (v47 == 31) {
    int v48 = 2139095040;
  }
  else {
    int v48 = (v46 >> 10) & 0x1F;
  }
  if (v47) {
    BOOL v49 = v47 == 31;
  }
  else {
    BOOL v49 = 1;
  }
  if (!v49) {
    int v48 = (v47 << 23) + 939524096;
  }
  unsigned int v50 = *(unsigned __int16 *)(v28 + v18.i32[2]);
  int v51 = (v50 >> 10) & 0x1F;
  if (v51 == 31) {
    int v52 = 2139095040;
  }
  else {
    int v52 = (v50 >> 10) & 0x1F;
  }
  if (v51) {
    BOOL v53 = v51 == 31;
  }
  else {
    BOOL v53 = 1;
  }
  if (!v53) {
    int v52 = (v51 << 23) + 939524096;
  }
  unsigned int v54 = *(unsigned __int16 *)(v34 + v18.i32[2]);
  int v55 = (v54 >> 10) & 0x1F;
  if (v55 == 31) {
    int v56 = 2139095040;
  }
  else {
    int v56 = (v54 >> 10) & 0x1F;
  }
  if (v55) {
    BOOL v57 = v55 == 31;
  }
  else {
    BOOL v57 = 1;
  }
  if (!v57) {
    int v56 = (v55 << 23) + 939524096;
  }
  unsigned int v58 = *(unsigned __int16 *)((char *)v40 + v18.i32[2]);
  int v59 = (v58 >> 10) & 0x1F;
  if (v59 == 31) {
    int v60 = 2139095040;
  }
  else {
    int v60 = (v58 >> 10) & 0x1F;
  }
  if (v59) {
    BOOL v61 = v59 == 31;
  }
  else {
    BOOL v61 = 1;
  }
  if (v61) {
    int v62 = v60;
  }
  else {
    int v62 = (v59 << 23) + 939524096;
  }
  v18.i32[0] = v56 | (v54 << 16) & 0x80000000 | (v54 >> 7) & 7 | (8 * (v54 & 0x3FF)) & 0x1FFF | ((v54 & 0x3FF) << 13);
  v10.i32[0] = v52 | (v50 << 16) & 0x80000000 | (v50 >> 7) & 7 | (8 * (v50 & 0x3FF)) & 0x1FFF | ((v50 & 0x3FF) << 13);
  v14.i32[0] = v48 | (v46 << 16) & 0x80000000 | (v46 >> 7) & 7 | (8 * (v46 & 0x3FF)) & 0x1FFF | ((v46 & 0x3FF) << 13);
  v15.i32[0] = v45 | (v41 << 16) & 0x80000000 | (v41 >> 7) & 7 | (8 * (v41 & 0x3FF)) & 0x1FFF | ((v41 & 0x3FF) << 13);
  v17.i32[0] = v39 | (v35 << 16) & 0x80000000 | (v35 >> 7) & 7 | (8 * (v35 & 0x3FF)) & 0x1FFF | ((v35 & 0x3FF) << 13);
  v16.i32[0] = v33 | (v29 << 16) & 0x80000000 | (v29 >> 7) & 7 | (8 * (v29 & 0x3FF)) & 0x1FFF | ((v29 & 0x3FF) << 13);
  a9.i32[0] = v27 | (v23 << 16) & 0x80000000 | (v23 >> 7) & 7 | (8 * (v23 & 0x3FF)) & 0x1FFF | ((v23 & 0x3FF) << 13);
  float32x4_t v63 = vsubq_f32(v11, vrndq_f32(v11));
  float32x4_t v64 = vmlaq_f32(a9, v63, vsubq_f32(v16, a9));
  v16.i32[0] = v62 | (v58 << 16) & 0x80000000 | (v58 >> 7) & 7 | (8 * (v58 & 0x3FF)) & 0x1FFF | ((v58 & 0x3FF) << 13);
  float32x4_t v65 = vmlaq_f32(v14, v63, vsubq_f32(v10, v14));
  float32x4_t v66 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1);
  float32x4_t v67 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v64.f32, 0), v66, vmlaq_f32(vsubq_f32(v17, v64), v63, vsubq_f32(v15, v17)).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v67, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65.f32, 0), v67), v66, vmlaq_f32(vsubq_f32(v18, v65), v63, vsubq_f32(v16, v18)).f32[0]), v63, 2).u64[0];
  return result;
}

double sub_1B6412610(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v9 = vsubq_f32(a2, a1[5]);
  v9.i32[3] = 0;
  float32x4_t v10 = a1[1];
  float32x4_t v11 = vmulq_f32(*a1, vminnmq_f32(vsubq_f32(v9, vrndmq_f32(v9)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v12 = vminq_s32(vcvtq_s32_f32(v11), (int32x4_t)v10);
  uint64_t v13 = a1[4].i64[0];
  float32x4_t v15 = a1[2];
  float32x4_t v14 = a1[3];
  float32x4_t v16 = (float32x4_t)vmulq_s32((int32x4_t)v15, v12);
  float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL);
  *(int32x2_t *)v16.f32 = vadd_s32(*(int32x2_t *)v16.f32, *(int32x2_t *)v17.f32);
  *(int32x2_t *)v17.f32 = vdup_lane_s32(*(int32x2_t *)v16.f32, 1);
  float32x4_t v18 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v10, v12), (int8x16_t)v15, (int8x16_t)v14);
  *(int32x2_t *)v10.f32 = vadd_s32(*(int32x2_t *)v16.f32, *(int32x2_t *)v17.f32);
  uint64_t v19 = v10.i32[0] + (uint64_t)v18.i32[0];
  uint64_t v20 = v10.i32[0] + (uint64_t)v18.i32[1];
  uint64_t v21 = (int)v20 + (uint64_t)v18.i32[0];
  uint64_t v22 = (__int32 *)(v13 + v10.i32[0]);
  v18.i32[0] = *v22;
  unsigned int v23 = (float *)(v13 + v19);
  int v24 = (__int32 *)(v13 + v20);
  v14.i32[0] = *v24;
  int v25 = (float *)(v13 + v21);
  v15.i32[0] = *(__int32 *)((char *)v22 + v18.i32[2]);
  v16.f32[0] = *(float *)((char *)v23 + v18.i32[2]);
  v17.i32[0] = *(__int32 *)((char *)v24 + v18.i32[2]);
  a9.f32[0] = *(float *)((char *)v25 + v18.i32[2]);
  float32x4_t v26 = vsubq_f32(v11, vrndq_f32(v11));
  v11.f32[0] = *v23 - *(float *)v22;
  float32x4_t v27 = vmlaq_f32(v18, v26, v11);
  v10.f32[0] = *v25 - *(float *)v24;
  v16.f32[0] = v16.f32[0] - v15.f32[0];
  float32x4_t v28 = vmlaq_f32(v15, v26, v16);
  a9.f32[0] = a9.f32[0] - v17.f32[0];
  float32x4_t v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1);
  float32x4_t v30 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 0), v29, vmlaq_f32(vsubq_f32(v14, v27), v26, v10).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v30, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), v30), v29, vmlaq_f32(vsubq_f32(v17, v28), v26, a9).f32[0]), v26, 2).u64[0];
  return result;
}

double sub_1B6412708(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  int32x4_t v3 = *(int32x4_t *)(a1 + 16);
  float32x4_t v4 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(v2, vrndmq_f32(v2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v5 = vminq_s32(vcvtq_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 64);
  int32x4_t v7 = *(int32x4_t *)(a1 + 32);
  int8x16_t v8 = (int8x16_t)vmulq_s32(v7, v5);
  *(int32x2_t *)v8.i8 = vadd_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  int8x16_t v9 = vbslq_s8((int8x16_t)vcgtq_s32(v3, v5), (int8x16_t)v7, *(int8x16_t *)(a1 + 48));
  __int32 v10 = v9.i32[2];
  v3.i32[0] = vadd_s32(*(int32x2_t *)v8.i8, vdup_lane_s32(*(int32x2_t *)v8.i8, 1)).u32[0];
  uint64_t v11 = v3.i32[0] + (uint64_t)v9.i32[0];
  uint64_t v12 = v3.i32[0] + (uint64_t)v9.i32[1];
  uint64_t v13 = (int)v12 + (uint64_t)v9.i32[0];
  int8x16_t v14 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v15 = (int8x16_t)vdupq_n_s32(0xF800000u);
  float32x4_t v16 = (uint16x4_t *)(v6 + v3.i32[0]);
  v8.i64[0] = 0x8000000080000000;
  v8.i64[1] = 0x8000000080000000;
  int8x16_t v17 = (int8x16_t)vshll_n_u16(*v16, 0xDuLL);
  v3.i64[0] = 0x3800000038000000;
  v3.i64[1] = 0x3800000038000000;
  float32x4_t v18 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v17, v15), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v16), v8), vandq_s8(v17, v14))), v3);
  uint64_t v19 = (uint16x4_t *)(v6 + v11);
  int8x16_t v20 = (int8x16_t)vshll_n_u16(*v19, 0xDuLL);
  float32x4_t v21 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v20, v15), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v19), v8), vandq_s8(v20, v14))), v3);
  uint64_t v22 = (uint16x4_t *)(v6 + v12);
  int8x16_t v23 = (int8x16_t)vshll_n_u16(*v22, 0xDuLL);
  float32x4_t v24 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v23, v15), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v22), v8), vandq_s8(v23, v14))), v3);
  int v25 = (uint16x4_t *)(v6 + v13);
  int8x16_t v26 = (int8x16_t)vshll_n_u16(*v25, 0xDuLL);
  float32x4_t v27 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v26, v15), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v25), v8), vandq_s8(v26, v14))), v3);
  int16x4_t v28 = *(int16x4_t *)((char *)v16 + v10);
  int8x16_t v29 = vandq_s8((int8x16_t)vmovl_s16(v28), v8);
  int8x16_t v30 = (int8x16_t)vshll_n_u16((uint16x4_t)v28, 0xDuLL);
  float32x4_t v31 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v30, v15), vorrq_s8(v29, vandq_s8(v30, v14))), v3);
  *(uint16x4_t *)v29.i8 = *(uint16x4_t *)((char *)v19 + v10);
  int8x16_t v32 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v29.i8), v8);
  int8x16_t v33 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v29.i8, 0xDuLL);
  int32x4_t v34 = (int32x4_t)vorrq_s8(vandq_s8(v33, v15), vorrq_s8(v32, vandq_s8(v33, v14)));
  *(uint16x4_t *)v32.i8 = *(uint16x4_t *)((char *)v22 + v10);
  int8x16_t v35 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v32.i8), v8);
  int8x16_t v36 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v32.i8, 0xDuLL);
  float32x4_t v37 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v36, v15), vorrq_s8(v35, vandq_s8(v36, v14))), v3);
  *(uint16x4_t *)v35.i8 = *(uint16x4_t *)((char *)v25 + v10);
  int8x16_t v38 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v35.i8), v8);
  int8x16_t v39 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v35.i8, 0xDuLL);
  float32x4_t v40 = vsubq_f32(v4, vrndq_f32(v4));
  float32x4_t v41 = vmlaq_n_f32(v18, vsubq_f32(v21, v18), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v31, vsubq_f32((float32x4_t)vaddq_s32(v34, v3), v31), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v24, v41), vsubq_f32(v27, v24), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v37, v42), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v39, v15), vorrq_s8(v38, vandq_s8(v39, v14))), v3), v37), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2).u64[0];
  return result;
}

double sub_1B641290C(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  int32x4_t v3 = *(int32x4_t *)(a1 + 16);
  float32x4_t v4 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(v2, vrndmq_f32(v2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v5 = vminq_s32(vcvtq_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 64);
  int32x4_t v7 = *(int32x4_t *)(a1 + 32);
  int8x16_t v8 = (int8x16_t)vmulq_s32(v7, v5);
  *(int32x2_t *)v8.i8 = vadd_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  int8x16_t v9 = vbslq_s8((int8x16_t)vcgtq_s32(v3, v5), (int8x16_t)v7, *(int8x16_t *)(a1 + 48));
  __int32 v10 = v9.i32[2];
  v3.i32[0] = vadd_s32(*(int32x2_t *)v8.i8, vdup_lane_s32(*(int32x2_t *)v8.i8, 1)).u32[0];
  uint64_t v11 = v3.i32[0] + (uint64_t)v9.i32[1];
  uint64_t v12 = (int)v11 + (uint64_t)v9.i32[0];
  uint64_t v13 = (float32x4_t *)(v6 + v3.i32[0]);
  int8x16_t v14 = (float32x4_t *)(v6 + v3.i32[0] + (uint64_t)v9.i32[0]);
  int8x16_t v15 = (float32x4_t *)(v6 + v11);
  float32x4_t v16 = (float32x4_t *)(v6 + v12);
  float32x4_t v17 = *(float32x4_t *)((char *)v13 + v9.i32[2]);
  float32x4_t v18 = *(float32x4_t *)((char *)v15 + v9.i32[2]);
  float32x4_t v19 = *(float32x4_t *)((char *)v16 + v9.i32[2]);
  float32x4_t v20 = vsubq_f32(v4, vrndq_f32(v4));
  float32x4_t v21 = vmlaq_n_f32(*v13, vsubq_f32(*v14, *v13), v20.f32[0]);
  float32x4_t v22 = vmlaq_n_f32(v17, vsubq_f32(*(float32x4_t *)((char *)v14 + v10), v17), v20.f32[0]);
  float32x4_t v23 = vmlaq_lane_f32(v21, vmlaq_n_f32(vsubq_f32(*v15, v21), vsubq_f32(*v16, *v15), v20.f32[0]), *(float32x2_t *)v20.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v23, vmlaq_lane_f32(vsubq_f32(v22, v23), vmlaq_n_f32(vsubq_f32(v18, v22), vsubq_f32(v19, v18), v20.f32[0]), *(float32x2_t *)v20.f32, 1), v20, 2).u64[0];
  return result;
}

double sub_1B64129F8(uint64_t a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v11 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v11.i32[3] = 0;
  float32x4_t v12 = *(float32x4_t *)(a1 + 16);
  float32x4_t v13 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(v11, vrndmq_f32(v11)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v14 = vminq_s32(vcvtq_s32_f32(v13), (int32x4_t)v12);
  uint64_t v15 = *(void *)(a1 + 64);
  float32x4_t v17 = *(float32x4_t *)(a1 + 32);
  int8x16_t v16 = *(int8x16_t *)(a1 + 48);
  float32x4_t v18 = (float32x4_t)vmulq_s32((int32x4_t)v17, v14);
  float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL);
  *(int32x2_t *)v18.f32 = vadd_s32(*(int32x2_t *)v18.f32, *(int32x2_t *)v19.f32);
  *(int32x2_t *)v19.f32 = vdup_lane_s32(*(int32x2_t *)v18.f32, 1);
  *(int32x2_t *)v18.f32 = vadd_s32(*(int32x2_t *)v18.f32, *(int32x2_t *)v19.f32);
  float32x4_t v20 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v12, v14), (int8x16_t)v17, v16);
  uint64_t v21 = v18.i32[0] + (uint64_t)v20.i32[1];
  uint64_t v22 = (int)v21 + (uint64_t)v20.i32[0];
  float32x4_t v23 = (__int8 *)(v15 + v18.i32[0]);
  v12.i8[0] = *v23;
  v12.f32[0] = (float)v12.u32[0] * 0.0039216;
  float32x4_t v24 = (__int8 *)(v15 + v18.i32[0] + (uint64_t)v20.i32[0]);
  v16.i8[0] = *v24;
  int v25 = (__int8 *)(v15 + v21);
  v17.i8[0] = *v25;
  v17.f32[0] = (float)v17.u32[0] * 0.0039216;
  int8x16_t v26 = (__int8 *)(v15 + v22);
  v18.i8[0] = *v26;
  v19.i8[0] = v23[v20.i32[2]];
  v19.f32[0] = (float)v19.u32[0] * 0.0039216;
  a9.i8[0] = v24[v20.i32[2]];
  v9.i8[0] = v25[v20.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  LOBYTE(v10) = v26[v20.i32[2]];
  float32x4_t v27 = vsubq_f32(v13, vrndq_f32(v13));
  v13.f32[0] = -(float)(v12.f32[0] - (float)((float)v16.u32[0] * 0.0039216));
  float32x4_t v28 = vmlaq_f32(v12, v27, v13);
  v18.f32[0] = -(float)(v17.f32[0] - (float)((float)v18.u32[0] * 0.0039216));
  a9.f32[0] = -(float)(v19.f32[0] - (float)((float)a9.u32[0] * 0.0039216));
  float32x4_t v29 = vmlaq_f32(v19, v27, a9);
  v20.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v30 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1);
  float32x4_t v31 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), v30, vmlaq_f32(vsubq_f32(v17, v28), v27, v18).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v31, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), v31), v30, vmlaq_f32(vsubq_f32(v9, v29), v27, v20).f32[0]), v27, 2).u64[0];
  return result;
}

double sub_1B6412B28(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v11 = vsubq_f32(a2, a1[5]);
  v11.i32[3] = 0;
  float32x4_t v12 = a1[1];
  float32x4_t v13 = vmulq_f32(*a1, vminnmq_f32(vsubq_f32(v11, vrndmq_f32(v11)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v14 = vminq_s32(vcvtq_s32_f32(v13), (int32x4_t)v12);
  uint64_t v15 = a1[4].i64[0];
  float32x4_t v17 = a1[2];
  float32x4_t v16 = a1[3];
  float32x4_t v18 = (float32x4_t)vmulq_s32((int32x4_t)v17, v14);
  float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL);
  *(int32x2_t *)v18.f32 = vadd_s32(*(int32x2_t *)v18.f32, *(int32x2_t *)v19.f32);
  *(int32x2_t *)v19.f32 = vdup_lane_s32(*(int32x2_t *)v18.f32, 1);
  *(int32x2_t *)v18.f32 = vadd_s32(*(int32x2_t *)v18.f32, *(int32x2_t *)v19.f32);
  float32x4_t v20 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v12, v14), (int8x16_t)v17, (int8x16_t)v16);
  uint64_t v21 = v18.i32[0] + (uint64_t)v20.i32[0];
  uint64_t v22 = v18.i32[0] + (uint64_t)v20.i32[1];
  uint64_t v23 = (int)v22 + (uint64_t)v20.i32[0];
  float32x4_t v24 = (__int8 *)(v15 + v18.i32[0]);
  v20.i8[0] = *v24;
  v20.f32[0] = (float)v20.u32[0];
  v16.f32[0] = v20.f32[0] * 0.0039216;
  int v25 = (__int8 *)(v15 + v21);
  v20.i8[0] = *v25;
  int8x16_t v26 = (__int8 *)(v15 + v22);
  v17.i8[0] = *v26;
  v17.f32[0] = (float)v17.u32[0] * 0.0039216;
  float32x4_t v27 = (__int8 *)(v15 + v23);
  v18.i8[0] = *v27;
  v19.i8[0] = v24[v20.i32[2]];
  v19.f32[0] = (float)v19.u32[0] * 0.0039216;
  a9.i8[0] = v25[v20.i32[2]];
  v9.i8[0] = v26[v20.i32[2]];
  LOBYTE(v10) = v27[v20.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  float32x4_t v28 = vsubq_f32(v13, vrndq_f32(v13));
  v20.f32[0] = -(float)(v16.f32[0] - (float)((float)v20.u32[0] * 0.0039216));
  float32x4_t v29 = vmlaq_f32(v16, v28, v20);
  a9.f32[0] = -(float)(v19.f32[0] - (float)((float)a9.u32[0] * 0.0039216));
  float32x4_t v30 = vmlaq_f32(v19, v28, a9);
  v18.f32[0] = -(float)(v17.f32[0] - (float)((float)v18.u32[0] * 0.0039216));
  v12.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1);
  float32x4_t v32 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0), v31, vmlaq_f32(vsubq_f32(v17, v29), v28, v18).f32[0]);
  float32x4_t v33 = vmlaq_laneq_f32(v32, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), v32), v31, vmlaq_f32(vsubq_f32(v9, v30), v28, v12).f32[0]), v28, 2);
  float32x4_t v34 = vmulq_f32(v33, v33);
  int32x4_t v35 = vcgeq_f32(v33, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v35.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v35), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v33), v34, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v33)), vmulq_f32(v34, v34), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v33), v34,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v33))), (int8x16_t)vmulq_f32(v33, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6412D0C(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  int32x4_t v3 = *(int32x4_t *)(a1 + 16);
  float32x4_t v4 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(v2, vrndmq_f32(v2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v5 = vminq_s32(vcvtq_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 64);
  int32x4_t v7 = *(int32x4_t *)(a1 + 32);
  int8x16_t v8 = (int8x16_t)vmulq_s32(v7, v5);
  *(int32x2_t *)v8.i8 = vadd_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  v8.i32[0] = vadd_s32(*(int32x2_t *)v8.i8, vdup_lane_s32(*(int32x2_t *)v8.i8, 1)).u32[0];
  int8x16_t v9 = vbslq_s8((int8x16_t)vcgtq_s32(v3, v5), (int8x16_t)v7, *(int8x16_t *)(a1 + 48));
  uint64_t v10 = v9.i32[2];
  uint64_t v11 = v8.i32[0] + (uint64_t)v9.i32[0];
  uint64_t v12 = v8.i32[0] + (uint64_t)v9.i32[1];
  uint64_t v13 = (int)v12 + (uint64_t)v9.i32[0];
  int32x4_t v14 = (const float *)(v6 + v8.i32[0]);
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v14);
  uint64_t v15 = (const float *)((char *)v14 + v10);
  v17.i64[0] = 0xFF000000FFLL;
  v17.i64[1] = 0xFF000000FFLL;
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v19 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  float32x4_t v20 = (const float *)(v6 + v11);
  uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v20);
  uint64_t v21 = (const float *)((char *)v20 + v10);
  uint64_t v23 = (const float *)(v6 + v12);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v23);
  float32x4_t v24 = (const float *)((char *)v23 + v10);
  int8x16_t v26 = (const float *)(v6 + v13);
  uint32x4_t v28 = (uint32x4_t)vld1q_dup_f32(v26);
  float32x4_t v27 = (const float *)((char *)v26 + v10);
  float32x4_t v29 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v15);
  uint32x4_t v31 = (uint32x4_t)vld1q_dup_f32(v21);
  float32x4_t v32 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v24);
  float32x4_t v34 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v36 = vsubq_f32(v4, vrndq_f32(v4));
  float32x4_t v37 = vmlaq_n_f32(v19, vmlaq_f32(vnegq_f32(v19), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]);
  float32x4_t v38 = vmlaq_n_f32(v32, vmlaq_f32(vnegq_f32(v32), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v31, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]);
  float32x4_t v39 = vmlaq_lane_f32(v37, vmlaq_n_f32(vsubq_f32(v29, v37), vmlaq_f32(vnegq_f32(v29), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v28, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]), *(float32x2_t *)v36.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v39, vmlaq_lane_f32(vsubq_f32(v38, v39), vmlaq_n_f32(vsubq_f32(v34, v38), vmlaq_f32(vnegq_f32(v34), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]), *(float32x2_t *)v36.f32, 1), v36, 2).u64[0];
  return result;
}

double sub_1B6412E90(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  int32x4_t v3 = *(int32x4_t *)(a1 + 16);
  float32x4_t v4 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(v2, vrndmq_f32(v2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v5 = vminq_s32(vcvtq_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 64);
  int32x4_t v7 = *(int32x4_t *)(a1 + 32);
  int8x16_t v8 = (int8x16_t)vmulq_s32(v7, v5);
  *(int32x2_t *)v8.i8 = vadd_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  v8.i32[0] = vadd_s32(*(int32x2_t *)v8.i8, vdup_lane_s32(*(int32x2_t *)v8.i8, 1)).u32[0];
  int8x16_t v9 = vbslq_s8((int8x16_t)vcgtq_s32(v3, v5), (int8x16_t)v7, *(int8x16_t *)(a1 + 48));
  uint64_t v10 = v9.i32[2];
  uint64_t v11 = v8.i32[0] + (uint64_t)v9.i32[0];
  uint64_t v12 = v8.i32[0] + (uint64_t)v9.i32[1];
  uint64_t v13 = (int)v12 + (uint64_t)v9.i32[0];
  int32x4_t v14 = (const float *)(v6 + v8.i32[0]);
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v14);
  uint64_t v15 = (const float *)((char *)v14 + v10);
  v17.i64[0] = 0xFF000000FFLL;
  v17.i64[1] = 0xFF000000FFLL;
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v19 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  float32x4_t v20 = (const float *)(v6 + v11);
  uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v20);
  uint64_t v21 = (const float *)((char *)v20 + v10);
  uint64_t v23 = (const float *)(v6 + v12);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v23);
  float32x4_t v24 = (const float *)((char *)v23 + v10);
  float32x4_t v26 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  float32x4_t v27 = (const float *)(v6 + v13);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  uint32x4_t v28 = (const float *)((char *)v27 + v10);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v15);
  float32x4_t v31 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  uint32x4_t v32 = (uint32x4_t)vld1q_dup_f32(v21);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v24);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v35 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  float32x4_t v36 = vsubq_f32(v4, vrndq_f32(v4));
  float32x4_t v37 = vmlaq_n_f32(v19, vmlaq_f32(vnegq_f32(v19), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]);
  float32x4_t v38 = vmlaq_n_f32(v31, vmlaq_f32(vnegq_f32(v31), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v32, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]);
  float32x4_t v39 = vmlaq_lane_f32(v37, vmlaq_n_f32(vsubq_f32(v26, v37), vmlaq_f32(vnegq_f32(v26), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]), *(float32x2_t *)v36.f32, 1);
  float32x4_t v40 = vmlaq_laneq_f32(v39, vmlaq_lane_f32(vsubq_f32(v38, v39), vmlaq_n_f32(vsubq_f32(v35, v38), vmlaq_f32(vnegq_f32(v35), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), v17))), v36.f32[0]), *(float32x2_t *)v36.f32, 1), v36, 2);
  float32x4_t v41 = vmulq_f32(v40, v40);
  int32x4_t v42 = vcgeq_f32(v40, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v42.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v42), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v40), v41, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v40)), vmulq_f32(v41, v41), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v40), v41,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v40))), (int8x16_t)vmulq_f32(v40, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B64130C8(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  int32x4_t v3 = *(int32x4_t *)(a1 + 16);
  float32x4_t v4 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(v2, vrndmq_f32(v2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v5 = vminq_s32(vcvtq_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 64);
  int32x4_t v7 = *(int32x4_t *)(a1 + 32);
  int8x16_t v8 = (int8x16_t)vmulq_s32(v7, v5);
  *(int32x2_t *)v8.i8 = vadd_s32(*(int32x2_t *)v8.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  v8.i32[0] = vadd_s32(*(int32x2_t *)v8.i8, vdup_lane_s32(*(int32x2_t *)v8.i8, 1)).u32[0];
  int8x16_t v9 = vbslq_s8((int8x16_t)vcgtq_s32(v3, v5), (int8x16_t)v7, *(int8x16_t *)(a1 + 48));
  uint64_t v10 = v9.i32[2];
  __int32 v11 = v9.i32[0];
  uint64_t v12 = v8.i32[0] + (uint64_t)v9.i32[0];
  uint64_t v13 = v8.i32[0] + (uint64_t)v9.i32[1];
  int32x4_t v14 = (const float *)(v6 + v8.i32[0]);
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v14);
  uint64_t v15 = (const float *)((char *)v14 + v10);
  uint64_t v17 = (int)v13 + (uint64_t)v11;
  v18.i64[0] = 0xFF000000FFLL;
  v18.i64[1] = 0xFF000000FFLL;
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v20 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint64_t v21 = (const float *)(v6 + v12);
  uint32x4_t v23 = (uint32x4_t)vld1q_dup_f32(v21);
  uint32x4_t v22 = (const float *)((char *)v21 + v10);
  float32x4_t v24 = (const float *)(v6 + v13);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint32x4_t v25 = (const float *)((char *)v24 + v10);
  float32x4_t v27 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint32x4_t v28 = (const float *)(v6 + v17);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v29 = (const float *)((char *)v28 + v10);
  uint32x4_t v31 = (uint32x4_t)vld1q_dup_f32(v15);
  float32x4_t v32 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v31, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v22);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x4_t v35 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint32x4_t v36 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x4_t v37 = vsubq_f32(v4, vrndq_f32(v4));
  float32x4_t v38 = vmlaq_n_f32(v20, vmlaq_f32(vnegq_f32(v20), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v23, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]);
  float32x4_t v39 = vmlaq_n_f32(v32, vmlaq_f32(vnegq_f32(v32), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]);
  float32x4_t v40 = vmlaq_lane_f32(v38, vmlaq_n_f32(vsubq_f32(v27, v38), vmlaq_f32(vnegq_f32(v27), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]), *(float32x2_t *)v37.f32, 1);
  int8x16_t v41 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_laneq_f32(v40, vmlaq_lane_f32(vsubq_f32(v39, v40), vmlaq_n_f32(vsubq_f32(v35, v39), vmlaq_f32(vnegq_f32(v35), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v36, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]), *(float32x2_t *)v37.f32, 1), v37, 2));
  *(void *)&double result = vextq_s8(v41, v41, 0xCuLL).u64[0];
  return result;
}

double sub_1B6413254(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  int32x4_t v3 = *(int32x4_t *)(a1 + 16);
  float32x4_t v4 = vmulq_f32(*(float32x4_t *)a1, vminnmq_f32(vsubq_f32(v2, vrndmq_f32(v2)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v5 = vminq_s32(vcvtq_s32_f32(v4), v3);
  int32x4_t v6 = *(int32x4_t *)(a1 + 32);
  int8x16_t v7 = (int8x16_t)vmulq_s32(v6, v5);
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  uint64_t v8 = *(void *)(a1 + 64);
  v7.i32[0] = vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).u32[0];
  int8x16_t v9 = vbslq_s8((int8x16_t)vcgtq_s32(v3, v5), (int8x16_t)v6, *(int8x16_t *)(a1 + 48));
  uint64_t v10 = v9.i32[2];
  __int32 v11 = v9.i32[0];
  uint64_t v12 = v7.i32[0] + (uint64_t)v9.i32[0];
  uint64_t v13 = v7.i32[0] + (uint64_t)v9.i32[1];
  int32x4_t v14 = (const float *)(v8 + v7.i32[0]);
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v14);
  uint64_t v15 = (const float *)((char *)v14 + v10);
  uint64_t v17 = (int)v13 + (uint64_t)v11;
  v18.i64[0] = 0xFF000000FFLL;
  v18.i64[1] = 0xFF000000FFLL;
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v20 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint64_t v21 = (const float *)(v8 + v12);
  uint32x4_t v23 = (uint32x4_t)vld1q_dup_f32(v21);
  uint32x4_t v22 = (const float *)((char *)v21 + v10);
  float32x4_t v24 = (const float *)(v8 + v13);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint32x4_t v25 = (const float *)((char *)v24 + v10);
  float32x4_t v27 = (const float *)(v8 + v17);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  uint32x4_t v28 = (const float *)((char *)v27 + v10);
  float32x4_t v30 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint32x4_t v31 = (uint32x4_t)vld1q_dup_f32(v15);
  float32x4_t v32 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v31, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v22);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x4_t v35 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint32x4_t v36 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v37 = vsubq_f32(v4, vrndq_f32(v4));
  float32x4_t v38 = vmlaq_n_f32(v20, vmlaq_f32(vnegq_f32(v20), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v23, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]);
  float32x4_t v39 = vmlaq_n_f32(v32, vmlaq_f32(vnegq_f32(v32), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]);
  float32x4_t v40 = vmlaq_lane_f32(v38, vmlaq_n_f32(vsubq_f32(v30, v38), vmlaq_f32(vnegq_f32(v30), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]), *(float32x2_t *)v37.f32, 1);
  float32x4_t v41 = vmlaq_laneq_f32(v40, vmlaq_lane_f32(vsubq_f32(v39, v40), vmlaq_n_f32(vsubq_f32(v35, v39), vmlaq_f32(vnegq_f32(v35), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v36, (uint32x4_t)xmmword_1B6E50360), v18))), v37.f32[0]), *(float32x2_t *)v37.f32, 1), v37, 2);
  float32x4_t v42 = vmulq_f32(v41, v41);
  int32x4_t v43 = vcgeq_f32(v41, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v43.i32[3] = 0;
  int32x4_t v44 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v43), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v41), v42, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v41)), vmulq_f32(v42, v42), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v41), v42,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v41))), (int8x16_t)vmulq_f32(v41, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v44.i32[3] = v41.i32[3];
  int8x16_t v45 = (int8x16_t)vrev64q_s32(v44);
  *(void *)&double result = vextq_s8(v45, v45, 0xCuLL).u64[0];
  return result;
}

double sub_1B6413494(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v9 = vsubq_f32(a2, a1[5]);
  v9.i32[3] = 0;
  v10.i64[0] = 0x3F0000003F000000;
  v10.i64[1] = 0x3F0000003F000000;
  v11.i64[0] = 0x3F0000003F000000;
  v11.i64[1] = 0x3F0000003F000000;
  float32x4_t v12 = vmlaq_f32(v11, v11, v9);
  float32x4_t v13 = vabdq_f32(v10, vminnmq_f32(vsubq_f32(v12, vrndmq_f32(v12)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  float32x4_t v14 = a1[1];
  float32x4_t v15 = vmulq_f32(*a1, vaddq_f32(v13, v13));
  int32x4_t v16 = vminq_s32(vcvtq_s32_f32(v15), (int32x4_t)v14);
  uint64_t v17 = a1[4].i64[0];
  float32x4_t v19 = a1[2];
  float32x4_t v18 = a1[3];
  float32x4_t v21 = (float32x4_t)vmulq_s32((int32x4_t)v19, v16);
  float32x4_t v20 = (float32x4_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL);
  *(int32x2_t *)v21.f32 = vadd_s32(*(int32x2_t *)v21.f32, *(int32x2_t *)v20.f32);
  *(int32x2_t *)v20.f32 = vdup_lane_s32(*(int32x2_t *)v21.f32, 1);
  *(int32x2_t *)v21.f32 = vadd_s32(*(int32x2_t *)v21.f32, *(int32x2_t *)v20.f32);
  float32x4_t v22 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v14, v16), (int8x16_t)v19, (int8x16_t)v18);
  uint64_t v23 = v21.i32[0] + (uint64_t)v22.i32[0];
  uint64_t v24 = v21.i32[0] + (uint64_t)v22.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)v22.i32[0];
  uint32x4_t v26 = (unsigned __int16 *)(v17 + v21.i32[0]);
  unsigned int v27 = *v26;
  int v28 = (v27 >> 10) & 0x1F;
  if (v28 == 31) {
    int v29 = 2139095040;
  }
  else {
    int v29 = (v27 >> 10) & 0x1F;
  }
  if (v28) {
    BOOL v30 = v28 == 31;
  }
  else {
    BOOL v30 = 1;
  }
  if (v30) {
    int v31 = v29;
  }
  else {
    int v31 = (v28 << 23) + 939524096;
  }
  uint64_t v32 = v17 + v23;
  unsigned int v33 = *(unsigned __int16 *)(v17 + v23);
  int v34 = (v33 >> 10) & 0x1F;
  if (v34 == 31) {
    int v35 = 2139095040;
  }
  else {
    int v35 = (v33 >> 10) & 0x1F;
  }
  if (v34) {
    BOOL v36 = v34 == 31;
  }
  else {
    BOOL v36 = 1;
  }
  if (v36) {
    int v37 = v35;
  }
  else {
    int v37 = (v34 << 23) + 939524096;
  }
  uint64_t v38 = v17 + v24;
  unsigned int v39 = *(unsigned __int16 *)(v17 + v24);
  int v40 = (v39 >> 10) & 0x1F;
  if (v40 == 31) {
    int v41 = 2139095040;
  }
  else {
    int v41 = (v39 >> 10) & 0x1F;
  }
  if (v40) {
    BOOL v42 = v40 == 31;
  }
  else {
    BOOL v42 = 1;
  }
  if (v42) {
    int v43 = v41;
  }
  else {
    int v43 = (v40 << 23) + 939524096;
  }
  int32x4_t v44 = (unsigned __int16 *)(v17 + v25);
  unsigned int v45 = *v44;
  int v46 = (v45 >> 10) & 0x1F;
  if (v46 == 31) {
    int v47 = 2139095040;
  }
  else {
    int v47 = (v45 >> 10) & 0x1F;
  }
  if (v46) {
    BOOL v48 = v46 == 31;
  }
  else {
    BOOL v48 = 1;
  }
  if (v48) {
    int v49 = v47;
  }
  else {
    int v49 = (v46 << 23) + 939524096;
  }
  unsigned int v50 = *(unsigned __int16 *)((char *)v26 + v22.i32[2]);
  int v51 = (v50 >> 10) & 0x1F;
  if (v51 == 31) {
    int v52 = 2139095040;
  }
  else {
    int v52 = (v50 >> 10) & 0x1F;
  }
  if (v51) {
    BOOL v53 = v51 == 31;
  }
  else {
    BOOL v53 = 1;
  }
  if (!v53) {
    int v52 = (v51 << 23) + 939524096;
  }
  unsigned int v54 = *(unsigned __int16 *)(v32 + v22.i32[2]);
  int v55 = (v54 >> 10) & 0x1F;
  if (v55 == 31) {
    int v56 = 2139095040;
  }
  else {
    int v56 = (v54 >> 10) & 0x1F;
  }
  if (v55) {
    BOOL v57 = v55 == 31;
  }
  else {
    BOOL v57 = 1;
  }
  if (!v57) {
    int v56 = (v55 << 23) + 939524096;
  }
  unsigned int v58 = *(unsigned __int16 *)(v38 + v22.i32[2]);
  int v59 = (v58 >> 10) & 0x1F;
  if (v59 == 31) {
    int v60 = 2139095040;
  }
  else {
    int v60 = (v58 >> 10) & 0x1F;
  }
  if (v59) {
    BOOL v61 = v59 == 31;
  }
  else {
    BOOL v61 = 1;
  }
  if (!v61) {
    int v60 = (v59 << 23) + 939524096;
  }
  unsigned int v62 = *(unsigned __int16 *)((char *)v44 + v22.i32[2]);
  int v63 = (v62 >> 10) & 0x1F;
  if (v63 == 31) {
    int v64 = 2139095040;
  }
  else {
    int v64 = (v62 >> 10) & 0x1F;
  }
  if (v63) {
    BOOL v65 = v63 == 31;
  }
  else {
    BOOL v65 = 1;
  }
  if (v65) {
    int v66 = v64;
  }
  else {
    int v66 = (v63 << 23) + 939524096;
  }
  v22.i32[0] = v60 | (v58 << 16) & 0x80000000 | (v58 >> 7) & 7 | (8 * (v58 & 0x3FF)) & 0x1FFF | ((v58 & 0x3FF) << 13);
  v14.i32[0] = v56 | (v54 << 16) & 0x80000000 | (v54 >> 7) & 7 | (8 * (v54 & 0x3FF)) & 0x1FFF | ((v54 & 0x3FF) << 13);
  v18.i32[0] = v52 | (v50 << 16) & 0x80000000 | (v50 >> 7) & 7 | (8 * (v50 & 0x3FF)) & 0x1FFF | ((v50 & 0x3FF) << 13);
  v19.i32[0] = v49 | (v45 << 16) & 0x80000000 | (v45 >> 7) & 7 | (8 * (v45 & 0x3FF)) & 0x1FFF | ((v45 & 0x3FF) << 13);
  v21.i32[0] = v43 | (v39 << 16) & 0x80000000 | (v39 >> 7) & 7 | (8 * (v39 & 0x3FF)) & 0x1FFF | ((v39 & 0x3FF) << 13);
  v20.i32[0] = v37 | (v33 << 16) & 0x80000000 | (v33 >> 7) & 7 | (8 * (v33 & 0x3FF)) & 0x1FFF | ((v33 & 0x3FF) << 13);
  a9.i32[0] = v31 | (v27 << 16) & 0x80000000 | (v27 >> 7) & 7 | (8 * (v27 & 0x3FF)) & 0x1FFF | ((v27 & 0x3FF) << 13);
  float32x4_t v67 = vsubq_f32(v15, vrndq_f32(v15));
  float32x4_t v68 = vmlaq_f32(a9, v67, vsubq_f32(v20, a9));
  v20.i32[0] = v66 | (v62 << 16) & 0x80000000 | (v62 >> 7) & 7 | (8 * (v62 & 0x3FF)) & 0x1FFF | ((v62 & 0x3FF) << 13);
  float32x4_t v69 = vmlaq_f32(v18, v67, vsubq_f32(v14, v18));
  float32x4_t v70 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v67.f32, 1);
  float32x4_t v71 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0), v70, vmlaq_f32(vsubq_f32(v21, v68), v67, vsubq_f32(v19, v21)).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v71, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 0), v71), v70, vmlaq_f32(vsubq_f32(v22, v69), v67, vsubq_f32(v20, v22)).f32[0]), v67, 2).u64[0];
  return result;
}

double sub_1B64137B4(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v9 = vsubq_f32(a2, a1[5]);
  v9.i32[3] = 0;
  v10.i64[0] = 0x3F0000003F000000;
  v10.i64[1] = 0x3F0000003F000000;
  v11.i64[0] = 0x3F0000003F000000;
  v11.i64[1] = 0x3F0000003F000000;
  float32x4_t v12 = vmlaq_f32(v11, v11, v9);
  float32x4_t v13 = vabdq_f32(v10, vminnmq_f32(vsubq_f32(v12, vrndmq_f32(v12)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  float32x4_t v14 = a1[1];
  float32x4_t v15 = vmulq_f32(*a1, vaddq_f32(v13, v13));
  int32x4_t v16 = vminq_s32(vcvtq_s32_f32(v15), (int32x4_t)v14);
  uint64_t v17 = a1[4].i64[0];
  float32x4_t v19 = a1[2];
  float32x4_t v18 = a1[3];
  float32x4_t v20 = (float32x4_t)vmulq_s32((int32x4_t)v19, v16);
  float32x4_t v21 = (float32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL);
  *(int32x2_t *)v20.f32 = vadd_s32(*(int32x2_t *)v20.f32, *(int32x2_t *)v21.f32);
  *(int32x2_t *)v21.f32 = vdup_lane_s32(*(int32x2_t *)v20.f32, 1);
  float32x4_t v22 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v14, v16), (int8x16_t)v19, (int8x16_t)v18);
  *(int32x2_t *)v14.f32 = vadd_s32(*(int32x2_t *)v20.f32, *(int32x2_t *)v21.f32);
  uint64_t v23 = v14.i32[0] + (uint64_t)v22.i32[0];
  uint64_t v24 = v14.i32[0] + (uint64_t)v22.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)v22.i32[0];
  uint32x4_t v26 = (__int32 *)(v17 + v14.i32[0]);
  v22.i32[0] = *v26;
  unsigned int v27 = (float *)(v17 + v23);
  int v28 = (__int32 *)(v17 + v24);
  v18.i32[0] = *v28;
  int v29 = (float *)(v17 + v25);
  v19.i32[0] = *(__int32 *)((char *)v26 + v22.i32[2]);
  v20.f32[0] = *(float *)((char *)v27 + v22.i32[2]);
  v21.i32[0] = *(__int32 *)((char *)v28 + v22.i32[2]);
  a9.f32[0] = *(float *)((char *)v29 + v22.i32[2]);
  float32x4_t v30 = vsubq_f32(v15, vrndq_f32(v15));
  v15.f32[0] = *v27 - *(float *)v26;
  float32x4_t v31 = vmlaq_f32(v22, v30, v15);
  v14.f32[0] = *v29 - *(float *)v28;
  v20.f32[0] = v20.f32[0] - v19.f32[0];
  float32x4_t v32 = vmlaq_f32(v19, v30, v20);
  a9.f32[0] = a9.f32[0] - v21.f32[0];
  float32x4_t v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1);
  float32x4_t v34 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 0), v33, vmlaq_f32(vsubq_f32(v18, v31), v30, v14).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v34, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0), v34), v33, vmlaq_f32(vsubq_f32(v21, v32), v30, a9).f32[0]), v30, 2).u64[0];
  return result;
}

double sub_1B64138C0(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmlaq_f32(v4, v4, v2);
  float32x4_t v6 = vabdq_f32(v3, vminnmq_f32(vsubq_f32(v5, vrndmq_f32(v5)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v7 = *(int32x4_t *)(a1 + 16);
  float32x4_t v8 = vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v6, v6));
  int32x4_t v9 = vminq_s32(vcvtq_s32_f32(v8), v7);
  uint64_t v10 = *(void *)(a1 + 64);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v9);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  int8x16_t v13 = vbslq_s8((int8x16_t)vcgtq_s32(v7, v9), (int8x16_t)v11, *(int8x16_t *)(a1 + 48));
  __int32 v14 = v13.i32[2];
  v7.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  uint64_t v15 = v7.i32[0] + (uint64_t)v13.i32[0];
  uint64_t v16 = v7.i32[0] + (uint64_t)v13.i32[1];
  uint64_t v17 = (int)v16 + (uint64_t)v13.i32[0];
  int8x16_t v18 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v19 = (int8x16_t)vdupq_n_s32(0xF800000u);
  float32x4_t v20 = (uint16x4_t *)(v10 + v7.i32[0]);
  v12.i64[0] = 0x8000000080000000;
  v12.i64[1] = 0x8000000080000000;
  int8x16_t v21 = (int8x16_t)vshll_n_u16(*v20, 0xDuLL);
  v7.i64[0] = 0x3800000038000000;
  v7.i64[1] = 0x3800000038000000;
  float32x4_t v22 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v21, v19), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v20), v12), vandq_s8(v21, v18))), v7);
  uint64_t v23 = (uint16x4_t *)(v10 + v15);
  int8x16_t v24 = (int8x16_t)vshll_n_u16(*v23, 0xDuLL);
  float32x4_t v25 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v24, v19), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v23), v12), vandq_s8(v24, v18))), v7);
  uint32x4_t v26 = (uint16x4_t *)(v10 + v16);
  int8x16_t v27 = (int8x16_t)vshll_n_u16(*v26, 0xDuLL);
  float32x4_t v28 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v27, v19), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v26), v12), vandq_s8(v27, v18))), v7);
  int v29 = (uint16x4_t *)(v10 + v17);
  int8x16_t v30 = (int8x16_t)vshll_n_u16(*v29, 0xDuLL);
  float32x4_t v31 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v30, v19), vorrq_s8(vandq_s8((int8x16_t)vmovl_s16((int16x4_t)*v29), v12), vandq_s8(v30, v18))), v7);
  int16x4_t v32 = *(int16x4_t *)((char *)v20 + v14);
  int8x16_t v33 = vandq_s8((int8x16_t)vmovl_s16(v32), v12);
  int8x16_t v34 = (int8x16_t)vshll_n_u16((uint16x4_t)v32, 0xDuLL);
  float32x4_t v35 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v34, v19), vorrq_s8(v33, vandq_s8(v34, v18))), v7);
  *(uint16x4_t *)v33.i8 = *(uint16x4_t *)((char *)v23 + v14);
  int8x16_t v36 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v33.i8), v12);
  int8x16_t v37 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v33.i8, 0xDuLL);
  int32x4_t v38 = (int32x4_t)vorrq_s8(vandq_s8(v37, v19), vorrq_s8(v36, vandq_s8(v37, v18)));
  *(uint16x4_t *)v36.i8 = *(uint16x4_t *)((char *)v26 + v14);
  int8x16_t v39 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v36.i8), v12);
  int8x16_t v40 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v36.i8, 0xDuLL);
  float32x4_t v41 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v40, v19), vorrq_s8(v39, vandq_s8(v40, v18))), v7);
  *(uint16x4_t *)v39.i8 = *(uint16x4_t *)((char *)v29 + v14);
  int8x16_t v42 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v39.i8), v12);
  int8x16_t v43 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v39.i8, 0xDuLL);
  float32x4_t v44 = vsubq_f32(v8, vrndq_f32(v8));
  float32x4_t v45 = vmlaq_n_f32(v22, vsubq_f32(v25, v22), v44.f32[0]);
  float32x4_t v46 = vmlaq_n_f32(v35, vsubq_f32((float32x4_t)vaddq_s32(v38, v7), v35), v44.f32[0]);
  float32x4_t v47 = vmlaq_lane_f32(v45, vmlaq_n_f32(vsubq_f32(v28, v45), vsubq_f32(v31, v28), v44.f32[0]), *(float32x2_t *)v44.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v47, vmlaq_lane_f32(vsubq_f32(v46, v47), vmlaq_n_f32(vsubq_f32(v41, v46), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v43, v19), vorrq_s8(v42, vandq_s8(v43, v18))), v7), v41), v44.f32[0]), *(float32x2_t *)v44.f32, 1), v44, 2).u64[0];
  return result;
}

double sub_1B6413AD8(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmlaq_f32(v4, v4, v2);
  float32x4_t v6 = vabdq_f32(v3, vminnmq_f32(vsubq_f32(v5, vrndmq_f32(v5)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v7 = *(int32x4_t *)(a1 + 16);
  float32x4_t v8 = vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v6, v6));
  int32x4_t v9 = vminq_s32(vcvtq_s32_f32(v8), v7);
  uint64_t v10 = *(void *)(a1 + 64);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v9);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  int8x16_t v13 = vbslq_s8((int8x16_t)vcgtq_s32(v7, v9), (int8x16_t)v11, *(int8x16_t *)(a1 + 48));
  __int32 v14 = v13.i32[2];
  v7.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  uint64_t v15 = v7.i32[0] + (uint64_t)v13.i32[1];
  uint64_t v16 = (int)v15 + (uint64_t)v13.i32[0];
  uint64_t v17 = (float32x4_t *)(v10 + v7.i32[0]);
  int8x16_t v18 = (float32x4_t *)(v10 + v7.i32[0] + (uint64_t)v13.i32[0]);
  int8x16_t v19 = (float32x4_t *)(v10 + v15);
  float32x4_t v20 = (float32x4_t *)(v10 + v16);
  float32x4_t v21 = *(float32x4_t *)((char *)v17 + v13.i32[2]);
  float32x4_t v22 = *(float32x4_t *)((char *)v19 + v13.i32[2]);
  float32x4_t v23 = *(float32x4_t *)((char *)v20 + v13.i32[2]);
  float32x4_t v24 = vsubq_f32(v8, vrndq_f32(v8));
  float32x4_t v25 = vmlaq_n_f32(*v17, vsubq_f32(*v18, *v17), v24.f32[0]);
  float32x4_t v26 = vmlaq_n_f32(v21, vsubq_f32(*(float32x4_t *)((char *)v18 + v14), v21), v24.f32[0]);
  float32x4_t v27 = vmlaq_lane_f32(v25, vmlaq_n_f32(vsubq_f32(*v19, v25), vsubq_f32(*v20, *v19), v24.f32[0]), *(float32x2_t *)v24.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v27, vmlaq_lane_f32(vsubq_f32(v26, v27), vmlaq_n_f32(vsubq_f32(v22, v26), vsubq_f32(v23, v22), v24.f32[0]), *(float32x2_t *)v24.f32, 1), v24, 2).u64[0];
  return result;
}

double sub_1B6413BD8(uint64_t a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v11 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v11.i32[3] = 0;
  v12.i64[0] = 0x3F0000003F000000;
  v12.i64[1] = 0x3F0000003F000000;
  v13.i64[0] = 0x3F0000003F000000;
  v13.i64[1] = 0x3F0000003F000000;
  float32x4_t v14 = vmlaq_f32(v13, v13, v11);
  float32x4_t v15 = vabdq_f32(v12, vminnmq_f32(vsubq_f32(v14, vrndmq_f32(v14)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  float32x4_t v16 = *(float32x4_t *)(a1 + 16);
  float32x4_t v17 = vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v15, v15));
  int32x4_t v18 = vminq_s32(vcvtq_s32_f32(v17), (int32x4_t)v16);
  uint64_t v19 = *(void *)(a1 + 64);
  float32x4_t v21 = *(float32x4_t *)(a1 + 32);
  int8x16_t v20 = *(int8x16_t *)(a1 + 48);
  float32x4_t v22 = (float32x4_t)vmulq_s32((int32x4_t)v21, v18);
  float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  *(int32x2_t *)v23.f32 = vdup_lane_s32(*(int32x2_t *)v22.f32, 1);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  float32x4_t v24 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v16, v18), (int8x16_t)v21, v20);
  uint64_t v25 = v22.i32[0] + (uint64_t)v24.i32[1];
  uint64_t v26 = (int)v25 + (uint64_t)v24.i32[0];
  float32x4_t v27 = (__int8 *)(v19 + v22.i32[0]);
  v16.i8[0] = *v27;
  v16.f32[0] = (float)v16.u32[0] * 0.0039216;
  float32x4_t v28 = (__int8 *)(v19 + v22.i32[0] + (uint64_t)v24.i32[0]);
  v20.i8[0] = *v28;
  int v29 = (__int8 *)(v19 + v25);
  v21.i8[0] = *v29;
  v21.f32[0] = (float)v21.u32[0] * 0.0039216;
  int8x16_t v30 = (__int8 *)(v19 + v26);
  v22.i8[0] = *v30;
  v23.i8[0] = v27[v24.i32[2]];
  v23.f32[0] = (float)v23.u32[0] * 0.0039216;
  a9.i8[0] = v28[v24.i32[2]];
  v9.i8[0] = v29[v24.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  LOBYTE(v10) = v30[v24.i32[2]];
  float32x4_t v31 = vsubq_f32(v17, vrndq_f32(v17));
  v17.f32[0] = -(float)(v16.f32[0] - (float)((float)v20.u32[0] * 0.0039216));
  float32x4_t v32 = vmlaq_f32(v16, v31, v17);
  v22.f32[0] = -(float)(v21.f32[0] - (float)((float)v22.u32[0] * 0.0039216));
  a9.f32[0] = -(float)(v23.f32[0] - (float)((float)a9.u32[0] * 0.0039216));
  float32x4_t v33 = vmlaq_f32(v23, v31, a9);
  v24.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1);
  float32x4_t v35 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0), v34, vmlaq_f32(vsubq_f32(v21, v32), v31, v22).f32[0]);
  *(void *)&double result = vmlaq_laneq_f32(v35, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0), v35), v34, vmlaq_f32(vsubq_f32(v9, v33), v31, v24).f32[0]), v31, 2).u64[0];
  return result;
}

double sub_1B6413D1C(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float32x4_t a9)
{
  float32x4_t v11 = vsubq_f32(a2, a1[5]);
  v11.i32[3] = 0;
  v12.i64[0] = 0x3F0000003F000000;
  v12.i64[1] = 0x3F0000003F000000;
  v13.i64[0] = 0x3F0000003F000000;
  v13.i64[1] = 0x3F0000003F000000;
  float32x4_t v14 = vmlaq_f32(v13, v13, v11);
  float32x4_t v15 = vabdq_f32(v12, vminnmq_f32(vsubq_f32(v14, vrndmq_f32(v14)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  float32x4_t v16 = a1[1];
  float32x4_t v17 = vmulq_f32(*a1, vaddq_f32(v15, v15));
  int32x4_t v18 = vminq_s32(vcvtq_s32_f32(v17), (int32x4_t)v16);
  uint64_t v19 = a1[4].i64[0];
  float32x4_t v21 = a1[2];
  float32x4_t v20 = a1[3];
  float32x4_t v22 = (float32x4_t)vmulq_s32((int32x4_t)v21, v18);
  float32x4_t v23 = (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  *(int32x2_t *)v23.f32 = vdup_lane_s32(*(int32x2_t *)v22.f32, 1);
  *(int32x2_t *)v22.f32 = vadd_s32(*(int32x2_t *)v22.f32, *(int32x2_t *)v23.f32);
  float32x4_t v24 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_s32((int32x4_t)v16, v18), (int8x16_t)v21, (int8x16_t)v20);
  uint64_t v25 = v22.i32[0] + (uint64_t)v24.i32[0];
  uint64_t v26 = v22.i32[0] + (uint64_t)v24.i32[1];
  uint64_t v27 = (int)v26 + (uint64_t)v24.i32[0];
  float32x4_t v28 = (__int8 *)(v19 + v22.i32[0]);
  v24.i8[0] = *v28;
  v24.f32[0] = (float)v24.u32[0];
  v20.f32[0] = v24.f32[0] * 0.0039216;
  int v29 = (__int8 *)(v19 + v25);
  v24.i8[0] = *v29;
  int8x16_t v30 = (__int8 *)(v19 + v26);
  v21.i8[0] = *v30;
  v21.f32[0] = (float)v21.u32[0] * 0.0039216;
  float32x4_t v31 = (__int8 *)(v19 + v27);
  v22.i8[0] = *v31;
  v23.i8[0] = v28[v24.i32[2]];
  v23.f32[0] = (float)v23.u32[0] * 0.0039216;
  a9.i8[0] = v29[v24.i32[2]];
  v9.i8[0] = v30[v24.i32[2]];
  LOBYTE(v10) = v31[v24.i32[2]];
  v9.f32[0] = (float)v9.u32[0] * 0.0039216;
  float32x4_t v32 = vsubq_f32(v17, vrndq_f32(v17));
  v24.f32[0] = -(float)(v20.f32[0] - (float)((float)v24.u32[0] * 0.0039216));
  float32x4_t v33 = vmlaq_f32(v20, v32, v24);
  a9.f32[0] = -(float)(v23.f32[0] - (float)((float)a9.u32[0] * 0.0039216));
  float32x4_t v34 = vmlaq_f32(v23, v32, a9);
  v22.f32[0] = -(float)(v21.f32[0] - (float)((float)v22.u32[0] * 0.0039216));
  v16.f32[0] = -(float)(v9.f32[0] - (float)((float)v10 * 0.0039216));
  float32x4_t v35 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1);
  float32x4_t v36 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 0), v35, vmlaq_f32(vsubq_f32(v21, v33), v32, v22).f32[0]);
  float32x4_t v37 = vmlaq_laneq_f32(v36, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 0), v36), v35, vmlaq_f32(vsubq_f32(v9, v34), v32, v16).f32[0]), v32, 2);
  float32x4_t v38 = vmulq_f32(v37, v37);
  int32x4_t v39 = vcgeq_f32(v37, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v39.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v39), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v37), v38, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v37)), vmulq_f32(v38, v38), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v37), v38,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v37))), (int8x16_t)vmulq_f32(v37, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6413F14(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmlaq_f32(v4, v4, v2);
  float32x4_t v6 = vabdq_f32(v3, vminnmq_f32(vsubq_f32(v5, vrndmq_f32(v5)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v7 = *(int32x4_t *)(a1 + 16);
  float32x4_t v8 = vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v6, v6));
  int32x4_t v9 = vminq_s32(vcvtq_s32_f32(v8), v7);
  uint64_t v10 = *(void *)(a1 + 64);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v9);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  int8x16_t v13 = vbslq_s8((int8x16_t)vcgtq_s32(v7, v9), (int8x16_t)v11, *(int8x16_t *)(a1 + 48));
  uint64_t v14 = v13.i32[2];
  uint64_t v15 = v12.i32[0] + (uint64_t)v13.i32[0];
  uint64_t v16 = v12.i32[0] + (uint64_t)v13.i32[1];
  uint64_t v17 = (int)v16 + (uint64_t)v13.i32[0];
  int32x4_t v18 = (const float *)(v10 + v12.i32[0]);
  uint32x4_t v20 = (uint32x4_t)vld1q_dup_f32(v18);
  uint64_t v19 = (const float *)((char *)v18 + v14);
  v21.i64[0] = 0xFF000000FFLL;
  v21.i64[1] = 0xFF000000FFLL;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v20, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  float32x4_t v24 = (const float *)(v10 + v15);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v25 = (const float *)((char *)v24 + v14);
  uint64_t v27 = (const float *)(v10 + v16);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v28 = (const float *)((char *)v27 + v14);
  int8x16_t v30 = (const float *)(v10 + v17);
  uint32x4_t v32 = (uint32x4_t)vld1q_dup_f32(v30);
  float32x4_t v31 = (const float *)((char *)v30 + v14);
  float32x4_t v33 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v19);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v38 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  uint32x4_t v39 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x4_t v40 = vsubq_f32(v8, vrndq_f32(v8));
  float32x4_t v41 = vmlaq_n_f32(v23, vmlaq_f32(vnegq_f32(v23), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v33, v41), vmlaq_f32(vnegq_f32(v33), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v32, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  *(void *)&double result = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v38, v42), vmlaq_f32(vnegq_f32(v38), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v39, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2).u64[0];
  return result;
}

double sub_1B64140AC(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmlaq_f32(v4, v4, v2);
  float32x4_t v6 = vabdq_f32(v3, vminnmq_f32(vsubq_f32(v5, vrndmq_f32(v5)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v7 = *(int32x4_t *)(a1 + 16);
  float32x4_t v8 = vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v6, v6));
  int32x4_t v9 = vminq_s32(vcvtq_s32_f32(v8), v7);
  uint64_t v10 = *(void *)(a1 + 64);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v9);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  int8x16_t v13 = vbslq_s8((int8x16_t)vcgtq_s32(v7, v9), (int8x16_t)v11, *(int8x16_t *)(a1 + 48));
  uint64_t v14 = v13.i32[2];
  uint64_t v15 = v12.i32[0] + (uint64_t)v13.i32[0];
  uint64_t v16 = v12.i32[0] + (uint64_t)v13.i32[1];
  uint64_t v17 = (int)v16 + (uint64_t)v13.i32[0];
  int32x4_t v18 = (const float *)(v10 + v12.i32[0]);
  uint32x4_t v20 = (uint32x4_t)vld1q_dup_f32(v18);
  uint64_t v19 = (const float *)((char *)v18 + v14);
  v21.i64[0] = 0xFF000000FFLL;
  v21.i64[1] = 0xFF000000FFLL;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v20, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  float32x4_t v24 = (const float *)(v10 + v15);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v25 = (const float *)((char *)v24 + v14);
  uint64_t v27 = (const float *)(v10 + v16);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v28 = (const float *)((char *)v27 + v14);
  float32x4_t v30 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  float32x4_t v31 = (const float *)(v10 + v17);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v31);
  uint32x4_t v32 = (const float *)((char *)v31 + v14);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v19);
  float32x4_t v35 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  uint32x4_t v36 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v32);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), v21)), v22);
  float32x4_t v40 = vsubq_f32(v8, vrndq_f32(v8));
  float32x4_t v41 = vmlaq_n_f32(v23, vmlaq_f32(vnegq_f32(v23), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]);
  float32x4_t v42 = vmlaq_n_f32(v35, vmlaq_f32(vnegq_f32(v35), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v36, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]);
  float32x4_t v43 = vmlaq_lane_f32(v41, vmlaq_n_f32(vsubq_f32(v30, v41), vmlaq_f32(vnegq_f32(v30), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]), *(float32x2_t *)v40.f32, 1);
  float32x4_t v44 = vmlaq_laneq_f32(v43, vmlaq_lane_f32(vsubq_f32(v42, v43), vmlaq_n_f32(vsubq_f32(v39, v42), vmlaq_f32(vnegq_f32(v39), v22, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), v21))), v40.f32[0]), *(float32x2_t *)v40.f32, 1), v40, 2);
  float32x4_t v45 = vmulq_f32(v44, v44);
  int32x4_t v46 = vcgeq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v46.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v46), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v44), v45, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v44)), vmulq_f32(v45, v45), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v44), v45,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v44))), (int8x16_t)vmulq_f32(v44, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B64142F8(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmlaq_f32(v4, v4, v2);
  float32x4_t v6 = vabdq_f32(v3, vminnmq_f32(vsubq_f32(v5, vrndmq_f32(v5)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v7 = *(int32x4_t *)(a1 + 16);
  float32x4_t v8 = vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v6, v6));
  int32x4_t v9 = vminq_s32(vcvtq_s32_f32(v8), v7);
  uint64_t v10 = *(void *)(a1 + 64);
  int32x4_t v11 = *(int32x4_t *)(a1 + 32);
  int8x16_t v12 = (int8x16_t)vmulq_s32(v11, v9);
  *(int32x2_t *)v12.i8 = vadd_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  v12.i32[0] = vadd_s32(*(int32x2_t *)v12.i8, vdup_lane_s32(*(int32x2_t *)v12.i8, 1)).u32[0];
  int8x16_t v13 = vbslq_s8((int8x16_t)vcgtq_s32(v7, v9), (int8x16_t)v11, *(int8x16_t *)(a1 + 48));
  uint64_t v14 = v13.i32[2];
  __int32 v15 = v13.i32[0];
  uint64_t v16 = v12.i32[0] + (uint64_t)v13.i32[0];
  uint64_t v17 = v12.i32[0] + (uint64_t)v13.i32[1];
  int32x4_t v18 = (const float *)(v10 + v12.i32[0]);
  uint32x4_t v20 = (uint32x4_t)vld1q_dup_f32(v18);
  uint64_t v19 = (const float *)((char *)v18 + v14);
  uint64_t v21 = (int)v17 + (uint64_t)v15;
  v22.i64[0] = 0xFF000000FFLL;
  v22.i64[1] = 0xFF000000FFLL;
  float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v20, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint64_t v25 = (const float *)(v10 + v16);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v26 = (const float *)((char *)v25 + v14);
  float32x4_t v28 = (const float *)(v10 + v17);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v29 = (const float *)((char *)v28 + v14);
  float32x4_t v31 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint32x4_t v32 = (const float *)(v10 + v21);
  uint32x4_t v34 = (uint32x4_t)vld1q_dup_f32(v32);
  uint32x4_t v33 = (const float *)((char *)v32 + v14);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v19);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v26);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint32x4_t v40 = (uint32x4_t)vld1q_dup_f32(v33);
  float32x4_t v41 = vsubq_f32(v8, vrndq_f32(v8));
  float32x4_t v42 = vmlaq_n_f32(v24, vmlaq_f32(vnegq_f32(v24), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]);
  float32x4_t v43 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]);
  float32x4_t v44 = vmlaq_lane_f32(v42, vmlaq_n_f32(vsubq_f32(v31, v42), vmlaq_f32(vnegq_f32(v31), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v34, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]), *(float32x2_t *)v41.f32, 1);
  int8x16_t v45 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_laneq_f32(v44, vmlaq_lane_f32(vsubq_f32(v43, v44), vmlaq_n_f32(vsubq_f32(v39, v43), vmlaq_f32(vnegq_f32(v39), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v40, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]), *(float32x2_t *)v41.f32, 1), v41, 2));
  *(void *)&double result = vextq_s8(v45, v45, 0xCuLL).u64[0];
  return result;
}

double sub_1B6414498(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(a2, *(float32x4_t *)(a1 + 80));
  v2.i32[3] = 0;
  v3.i64[0] = 0x3F0000003F000000;
  v3.i64[1] = 0x3F0000003F000000;
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vmlaq_f32(v4, v4, v2);
  float32x4_t v6 = vabdq_f32(v3, vminnmq_f32(vsubq_f32(v5, vrndmq_f32(v5)), (float32x4_t)vdupq_n_s32(0x3F7FFFFFu)));
  int32x4_t v7 = *(int32x4_t *)(a1 + 16);
  float32x4_t v8 = vmulq_f32(*(float32x4_t *)a1, vaddq_f32(v6, v6));
  int32x4_t v9 = vminq_s32(vcvtq_s32_f32(v8), v7);
  int32x4_t v10 = *(int32x4_t *)(a1 + 32);
  int8x16_t v11 = (int8x16_t)vmulq_s32(v10, v9);
  *(int32x2_t *)v11.i8 = vadd_s32(*(int32x2_t *)v11.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL));
  uint64_t v12 = *(void *)(a1 + 64);
  v11.i32[0] = vadd_s32(*(int32x2_t *)v11.i8, vdup_lane_s32(*(int32x2_t *)v11.i8, 1)).u32[0];
  int8x16_t v13 = vbslq_s8((int8x16_t)vcgtq_s32(v7, v9), (int8x16_t)v10, *(int8x16_t *)(a1 + 48));
  uint64_t v14 = v13.i32[2];
  __int32 v15 = v13.i32[0];
  uint64_t v16 = v11.i32[0] + (uint64_t)v13.i32[0];
  uint64_t v17 = v11.i32[0] + (uint64_t)v13.i32[1];
  int32x4_t v18 = (const float *)(v12 + v11.i32[0]);
  uint32x4_t v20 = (uint32x4_t)vld1q_dup_f32(v18);
  uint64_t v19 = (const float *)((char *)v18 + v14);
  uint64_t v21 = (int)v17 + (uint64_t)v15;
  v22.i64[0] = 0xFF000000FFLL;
  v22.i64[1] = 0xFF000000FFLL;
  float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v20, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint64_t v25 = (const float *)(v12 + v16);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v26 = (const float *)((char *)v25 + v14);
  float32x4_t v28 = (const float *)(v12 + v17);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v28);
  uint32x4_t v29 = (const float *)((char *)v28 + v14);
  float32x4_t v31 = (const float *)(v12 + v21);
  uint32x4_t v33 = (uint32x4_t)vld1q_dup_f32(v31);
  uint32x4_t v32 = (const float *)((char *)v31 + v14);
  float32x4_t v34 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint32x4_t v35 = (uint32x4_t)vld1q_dup_f32(v19);
  float32x4_t v36 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v35, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint32x4_t v37 = (uint32x4_t)vld1q_dup_f32(v26);
  uint32x4_t v38 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x4_t v39 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_1B6E50360), v22)), v23);
  uint32x4_t v40 = (uint32x4_t)vld1q_dup_f32(v32);
  float32x4_t v41 = vsubq_f32(v8, vrndq_f32(v8));
  float32x4_t v42 = vmlaq_n_f32(v24, vmlaq_f32(vnegq_f32(v24), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]);
  float32x4_t v43 = vmlaq_n_f32(v36, vmlaq_f32(vnegq_f32(v36), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v37, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]);
  float32x4_t v44 = vmlaq_lane_f32(v42, vmlaq_n_f32(vsubq_f32(v34, v42), vmlaq_f32(vnegq_f32(v34), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v33, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]), *(float32x2_t *)v41.f32, 1);
  float32x4_t v45 = vmlaq_laneq_f32(v44, vmlaq_lane_f32(vsubq_f32(v43, v44), vmlaq_n_f32(vsubq_f32(v39, v43), vmlaq_f32(vnegq_f32(v39), v23, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v40, (uint32x4_t)xmmword_1B6E50360), v22))), v41.f32[0]), *(float32x2_t *)v41.f32, 1), v41, 2);
  float32x4_t v46 = vmulq_f32(v45, v45);
  int32x4_t v47 = vcgeq_f32(v45, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v47.i32[3] = 0;
  int32x4_t v48 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v47), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v45), v46, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v45)), vmulq_f32(v46, v46), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v45), v46,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v45))), (int8x16_t)vmulq_f32(v45, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v48.i32[3] = v45.i32[3];
  int8x16_t v49 = (int8x16_t)vrev64q_s32(v48);
  *(void *)&double result = vextq_s8(v49, v49, 0xCuLL).u64[0];
  return result;
}

float32x4_t vfx_sampler3d_make@<Q0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>, int32x4_t a6@<Q0>)
{
  uint64_t v6 = a2 - 1;
  if (v6 > 9) {
    unsigned int v7 = 2;
  }
  else {
    unsigned int v7 = dword_1B6E503B0[v6];
  }
  int32x4_t v8 = a6;
  v8.i32[3] = 0;
  float32x4_t v9 = vcvtq_f32_s32(v8);
  v10.i64[0] = -1;
  v10.i64[1] = -1;
  *(float32x4_t *)a5 = v9;
  *(int32x4_t *)(a5 + 16) = vaddq_s32(v8, v10);
  int32x4_t v11 = vdupq_n_s32(v7);
  v10.i32[0] = 1;
  v10.i32[1] = a6.i32[0];
  v10.i64[1] = (a6.i32[0] * a6.i32[1]);
  unsigned __int32 v12 = a6.i32[0] - a6.i32[0] * a6.i32[1];
  unsigned __int32 v13 = a6.i32[0] * a6.i32[1] - a6.i32[0] * a6.i32[1] * a6.i32[2];
  v14.i32[0] = 1 - a6.i32[0];
  v14.i32[1] = v12;
  v14.i64[1] = v13;
  uint64_t v15 = (uint64_t)*(&off_1F0FBA388 + 40 * a4 + 10 * a3 + a2);
  *(int32x4_t *)(a5 + 32) = vmulq_s32(v11, v10);
  *(int32x4_t *)(a5 + 48) = vmulq_s32(v11, v14);
  *(void *)(a5 + 64) = a1;
  *(void *)(a5 + 72) = v15;
  v14.i64[0] = 0x3F0000003F000000;
  v14.i64[1] = 0x3F0000003F000000;
  float32x4_t result = vdivq_f32((float32x4_t)v14, v9);
  *(float32x4_t *)(a5 + 80) = result;
  return result;
}

double sub_1B64147AC(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v6 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int32x2_t v8 = vadd_s32(v7, vdup_lane_s32(v7, 1));
  unsigned int v9 = *(unsigned __int16 *)(*(void *)(a1 + 32) + v8.i32[0]);
  int v10 = (v9 >> 10) & 0x1F;
  if (v10 == 31) {
    int v11 = 2139095040;
  }
  else {
    int v11 = (v9 >> 10) & 0x1F;
  }
  if (v10) {
    _ZF = v10 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    int v13 = v11;
  }
  else {
    int v13 = (v10 << 23) + 939524096;
  }
  v8.i32[0] = v13 | (v9 << 16) & 0x80000000 | (v9 >> 7) & 7 | (8 * (v9 & 0x3FF)) & 0x1FFF | ((v9 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(v8, 0).u64[0];
  return result;
}

double sub_1B641484C(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  unsigned int v9 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v8, vdup_lane_s32(v8, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v9).u64[0];
  return result;
}

double sub_1B64148A4(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int16x4_t v9 = *(int16x4_t *)(*(void *)(a1 + 32) + vadd_s32(v8, vdup_lane_s32(v8, 1)).i32[0]);
  v10.i64[0] = 0x8000000080000000;
  v10.i64[1] = 0x8000000080000000;
  int32x4_t v11 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v9), v10);
  int8x16_t v12 = (int8x16_t)vshll_n_u16((uint16x4_t)v9, 0xDuLL);
  int32x4_t v13 = (int32x4_t)vorrq_s8(vandq_s8(v12, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v11, vandq_s8(v12, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v11.i64[0] = 0x3800000038000000;
  v11.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v13, v11).u64[0];
  return result;
}

double sub_1B6414930(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0)
  {
    *(void *)&long long v9 = 0;
  }
  else
  {
    int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
    long long v9 = *(_OWORD *)(*(void *)(a1 + 32) + vadd_s32(v8, vdup_lane_s32(v8, 1)).i32[0]);
  }
  return *(double *)&v9;
}

double sub_1B6414984(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int32x2_t v9 = vadd_s32(v8, vdup_lane_s32(v8, 1));
  v9.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v9.i32[0]);
  *(float *)v9.i32 = (float)v9.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(v9, 0).u64[0];
  return result;
}

double sub_1B64149EC(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int32x2_t v9 = vdup_lane_s32(v8, 1);
  v8.i32[0] = vadd_s32(v8, v9).u32[0];
  v8.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v8.i32[0]);
  *(float *)v9.i32 = (float)v8.u32[0] * 0.0039216;
  int32x4_t v10 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v9, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v10.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v10), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v9.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v9.i32), *(float *)v9.i32 * *(float *)v9.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v9.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v9.i32),
                                        *(float *)v9.i32 * *(float *)v9.i32),
                                      (float)(*(float *)v9.i32 * *(float *)v9.i32)
                                    * (float)(*(float *)v9.i32 * *(float *)v9.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v9.i32)).u64[0];
  return result;
}

double sub_1B6414B08(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int32x2_t v9 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v8, vdup_lane_s32(v8, 1)).i32[0]);
  uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_1B6E50360), v11)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B6414B88(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int32x2_t v9 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v8, vdup_lane_s32(v8, 1)).i32[0]);
  uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v12 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_1B6E50360), v11));
  float32x4_t v13 = vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v14 = vmulq_f32(v13, v13);
  float32x4_t v15 = vmulq_f32(v14, v14);
  float32x4_t v16 = vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v12), v14, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v12));
  float32x4_t v17 = vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v12), v14, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v12));
  int32x4_t v18 = vcgeq_f32(v13, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v18.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v18), (int8x16_t)vmlaq_f32(v17, v15, v16), (int8x16_t)vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B6414CAC(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int32x2_t v9 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v8, vdup_lane_s32(v8, 1)).i32[0]);
  uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  int8x16_t v12 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_1B6E50360), v11)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v12, v12, 0xCuLL).u64[0];
  return result;
}

double sub_1B6414D34(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v7 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(a2, _D1), (int8x8_t)vcltz_f32(a2));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v8 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, a2)), *(int32x2_t *)(a1 + 8)));
  int32x2_t v9 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v8, vdup_lane_s32(v8, 1)).i32[0]);
  uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v12 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_1B6E50360), v11));
  float32x4_t v13 = vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v14 = vmulq_f32(v13, v13);
  int8x16_t v15 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v12), v14, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v12)), vmulq_f32(v14, v14), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v12), v14, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v12)));
  int32x4_t v16 = vcgeq_f32(v13, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v16.i32[3] = 0;
  int32x4_t v17 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v16), v15, (int8x16_t)vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v17.i32[3] = v13.i32[3];
  int8x16_t v18 = (int8x16_t)vrev64q_s32(v17);
  *(void *)&double result = vextq_s8(v18, v18, 0xCuLL).u64[0];
  return result;
}

double sub_1B6414E60(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v6 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v7 = vadd_s32(v6, vdup_lane_s32(v6, 1));
  unsigned int v8 = *(unsigned __int16 *)(*(void *)(a1 + 32) + v7.i32[0]);
  int v9 = (v8 >> 10) & 0x1F;
  if (v9 == 31) {
    int v10 = 2139095040;
  }
  else {
    int v10 = (v8 >> 10) & 0x1F;
  }
  if (v9) {
    _ZF = v9 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    int v12 = v10;
  }
  else {
    int v12 = (v9 << 23) + 939524096;
  }
  v7.i32[0] = v12 | (v8 << 16) & 0x80000000 | (v8 >> 7) & 7 | (8 * (v8 & 0x3FF)) & 0x1FFF | ((v8 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(v7, 0).u64[0];
  return result;
}

double sub_1B6414EEC(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  unsigned int v8 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v7, vdup_lane_s32(v7, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v8).u64[0];
  return result;
}

double sub_1B6414F30(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int16x4_t v8 = *(int16x4_t *)(*(void *)(a1 + 32) + vadd_s32(v7, vdup_lane_s32(v7, 1)).i32[0]);
  v9.i64[0] = 0x8000000080000000;
  v9.i64[1] = 0x8000000080000000;
  int32x4_t v10 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v8), v9);
  int8x16_t v11 = (int8x16_t)vshll_n_u16((uint16x4_t)v8, 0xDuLL);
  int32x4_t v12 = (int32x4_t)vorrq_s8(vandq_s8(v11, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v10, vandq_s8(v11, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v10.i64[0] = 0x3800000038000000;
  v10.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v12, v10).u64[0];
  return result;
}

__n128 sub_1B6414FA8(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  return *(__n128 *)(*(void *)(a1 + 32) + vadd_s32(v7, vdup_lane_s32(v7, 1)).i32[0]);
}

double sub_1B6414FE8(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v8 = vadd_s32(v7, vdup_lane_s32(v7, 1));
  v8.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v8.i32[0]);
  *(float *)v8.i32 = (float)v8.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(v8, 0).u64[0];
  return result;
}

double sub_1B641503C(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v8 = vdup_lane_s32(v7, 1);
  v7.i32[0] = vadd_s32(v7, v8).u32[0];
  v7.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v7.i32[0]);
  *(float *)v8.i32 = (float)v7.u32[0] * 0.0039216;
  int32x4_t v9 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v8, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v9.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v8.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v8.i32), *(float *)v8.i32 * *(float *)v8.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v8.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v8.i32),
                                        *(float *)v8.i32 * *(float *)v8.i32),
                                      (float)(*(float *)v8.i32 * *(float *)v8.i32)
                                    * (float)(*(float *)v8.i32 * *(float *)v8.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v8.i32)).u64[0];
  return result;
}

double sub_1B6415144(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v7, vdup_lane_s32(v7, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B64151B0(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v7, vdup_lane_s32(v7, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10));
  float32x4_t v12 = vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v13 = vmulq_f32(v12, v12);
  int32x4_t v14 = vcgeq_f32(v12, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v14.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v14), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v11), v13, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v11)), vmulq_f32(v13, v13), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v11), v13,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v11))), (int8x16_t)vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B64152C0(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v7, vdup_lane_s32(v7, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  int8x16_t v11 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v11, v11, 0xCuLL).u64[0];
  return result;
}

double sub_1B6415334(uint64_t a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vmaxnm_f32(a2, 0), _D1))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v7, vdup_lane_s32(v7, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10));
  float32x4_t v12 = vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v13 = vmulq_f32(v12, v12);
  int8x16_t v14 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v11), v13, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v11)), vmulq_f32(v13, v13), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v11), v13, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v11)));
  int32x4_t v15 = vcgeq_f32(v12, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v15.i32[3] = 0;
  int32x4_t v16 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v15), v14, (int8x16_t)vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v16.i32[3] = v12.i32[3];
  int8x16_t v17 = (int8x16_t)vrev64q_s32(v16);
  *(void *)&double result = vextq_s8(v17, v17, 0xCuLL).u64[0];
  return result;
}

double sub_1B641544C(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = vadd_s32(v2, vdup_lane_s32(v2, 1));
  unsigned int v4 = *(unsigned __int16 *)(*(void *)(a1 + 32) + v3.i32[0]);
  int v5 = (v4 >> 10) & 0x1F;
  if (v5 == 31) {
    int v6 = 2139095040;
  }
  else {
    int v6 = (v4 >> 10) & 0x1F;
  }
  if (v5) {
    BOOL v7 = v5 == 31;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    int v8 = v6;
  }
  else {
    int v8 = (v5 << 23) + 939524096;
  }
  v3.i32[0] = v8 | (v4 << 16) & 0x80000000 | (v4 >> 7) & 7 | (8 * (v4 & 0x3FF)) & 0x1FFF | ((v4 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(v3, 0).u64[0];
  return result;
}

double sub_1B64154DC(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v2, vdup_lane_s32(v2, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v3).u64[0];
  return result;
}

double sub_1B6415524(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int16x4_t v3 = *(int16x4_t *)(*(void *)(a1 + 32) + vadd_s32(v2, vdup_lane_s32(v2, 1)).i32[0]);
  v4.i64[0] = 0x8000000080000000;
  v4.i64[1] = 0x8000000080000000;
  int32x4_t v5 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v3), v4);
  int8x16_t v6 = (int8x16_t)vshll_n_u16((uint16x4_t)v3, 0xDuLL);
  int32x4_t v7 = (int32x4_t)vorrq_s8(vandq_s8(v6, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v5, vandq_s8(v6, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v5.i64[0] = 0x3800000038000000;
  v5.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v7, v5).u64[0];
  return result;
}

__n128 sub_1B64155A0(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  return *(__n128 *)(*(void *)(a1 + 32) + vadd_s32(v2, vdup_lane_s32(v2, 1)).i32[0]);
}

double sub_1B64155E4(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = vadd_s32(v2, vdup_lane_s32(v2, 1));
  v3.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v3.i32[0]);
  *(float *)v3.i32 = (float)v3.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(v3, 0).u64[0];
  return result;
}

double sub_1B641563C(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = vdup_lane_s32(v2, 1);
  v2.i32[0] = vadd_s32(v2, v3).u32[0];
  v2.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v2.i32[0]);
  *(float *)v3.i32 = (float)v2.u32[0] * 0.0039216;
  int32x4_t v4 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v4.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v4), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v3.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v3.i32), *(float *)v3.i32 * *(float *)v3.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v3.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v3.i32),
                                        *(float *)v3.i32 * *(float *)v3.i32),
                                      (float)(*(float *)v3.i32 * *(float *)v3.i32)
                                    * (float)(*(float *)v3.i32 * *(float *)v3.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v3.i32)).u64[0];
  return result;
}

double sub_1B6415748(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v2, vdup_lane_s32(v2, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B64157B8(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v2, vdup_lane_s32(v2, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int32x4_t v9 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v9.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6))), (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B64158CC(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v2, vdup_lane_s32(v2, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  int8x16_t v6 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v6, v6, 0xCuLL).u64[0];
  return result;
}

double sub_1B6415944(uint64_t a1, float32x2_t a2)
{
  int32x2_t v2 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(a2, vrndm_f32(a2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v3 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v2, vdup_lane_s32(v2, 1)).i32[0]);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6)));
  int32x4_t v10 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v10.i32[3] = 0;
  int32x4_t v11 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v10), v9, (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v11.i32[3] = v7.i32[3];
  int8x16_t v12 = (int8x16_t)vrev64q_s32(v11);
  *(void *)&double result = vextq_s8(v12, v12, 0xCuLL).u64[0];
  return result;
}

double sub_1B6415A60(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = vadd_s32(v4, vdup_lane_s32(v4, 1));
  unsigned int v6 = *(unsigned __int16 *)(*(void *)(a1 + 32) + v5.i32[0]);
  int v7 = (v6 >> 10) & 0x1F;
  if (v7 == 31) {
    int v8 = 2139095040;
  }
  else {
    int v8 = (v6 >> 10) & 0x1F;
  }
  if (v7) {
    BOOL v9 = v7 == 31;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    int v10 = v8;
  }
  else {
    int v10 = (v7 << 23) + 939524096;
  }
  v5.i32[0] = v10 | (v6 << 16) & 0x80000000 | (v6 >> 7) & 7 | (8 * (v6 & 0x3FF)) & 0x1FFF | ((v6 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(v5, 0).u64[0];
  return result;
}

double sub_1B6415B04(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v4, vdup_lane_s32(v4, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v5).u64[0];
  return result;
}

double sub_1B6415B60(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int16x4_t v5 = *(int16x4_t *)(*(void *)(a1 + 32) + vadd_s32(v4, vdup_lane_s32(v4, 1)).i32[0]);
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  int32x4_t v7 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v5), v6);
  int8x16_t v8 = (int8x16_t)vshll_n_u16((uint16x4_t)v5, 0xDuLL);
  int32x4_t v9 = (int32x4_t)vorrq_s8(vandq_s8(v8, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v7, vandq_s8(v8, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v7.i64[0] = 0x3800000038000000;
  v7.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v9, v7).u64[0];
  return result;
}

__n128 sub_1B6415BF0(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  return *(__n128 *)(*(void *)(a1 + 32) + vadd_s32(v4, vdup_lane_s32(v4, 1)).i32[0]);
}

double sub_1B6415C48(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = vadd_s32(v4, vdup_lane_s32(v4, 1));
  v5.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v5.i32[0]);
  *(float *)v5.i32 = (float)v5.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(v5, 0).u64[0];
  return result;
}

double sub_1B6415CB4(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = vdup_lane_s32(v4, 1);
  v4.i32[0] = vadd_s32(v4, v5).u32[0];
  v4.i8[0] = *(unsigned char *)(*(void *)(a1 + 32) + v4.i32[0]);
  *(float *)v5.i32 = (float)v4.u32[0] * 0.0039216;
  int32x4_t v6 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v5, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v6.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v6), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v5.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v5.i32), *(float *)v5.i32 * *(float *)v5.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v5.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v5.i32),
                                        *(float *)v5.i32 * *(float *)v5.i32),
                                      (float)(*(float *)v5.i32 * *(float *)v5.i32)
                                    * (float)(*(float *)v5.i32 * *(float *)v5.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v5.i32)).u64[0];
  return result;
}

double sub_1B6415DD4(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v4, vdup_lane_s32(v4, 1)).i32[0]);
  uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
  v7.i64[0] = 0xFF000000FFLL;
  v7.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B6415E58(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v4, vdup_lane_s32(v4, 1)).i32[0]);
  uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
  v7.i64[0] = 0xFF000000FFLL;
  v7.i64[1] = 0xFF000000FFLL;
  float32x4_t v8 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7));
  float32x4_t v9 = vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v10 = vmulq_f32(v9, v9);
  int32x4_t v11 = vcgeq_f32(v9, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v11.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v11), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v8), v10, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v8)), vmulq_f32(v10, v10), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v8), v10,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v8))), (int8x16_t)vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B6415F80(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v4, vdup_lane_s32(v4, 1)).i32[0]);
  uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
  v7.i64[0] = 0xFF000000FFLL;
  v7.i64[1] = 0xFF000000FFLL;
  int8x16_t v8 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v8, v8, 0xCuLL).u64[0];
  return result;
}

double sub_1B641600C(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, a2);
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = vmul_s32(*(int32x2_t *)(a1 + 16), vmin_s32(vcvt_s32_f32(vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3))), *(int32x2_t *)(a1 + 8)));
  int32x2_t v5 = (const float *)(*(void *)(a1 + 32) + vadd_s32(v4, vdup_lane_s32(v4, 1)).i32[0]);
  uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
  v7.i64[0] = 0xFF000000FFLL;
  v7.i64[1] = 0xFF000000FFLL;
  float32x4_t v8 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7));
  float32x4_t v9 = vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v10 = vmulq_f32(v9, v9);
  int8x16_t v11 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v8), v10, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v8)), vmulq_f32(v10, v10), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v8), v10, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v8)));
  int32x4_t v12 = vcgeq_f32(v9, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v12.i32[3] = 0;
  int32x4_t v13 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v12), v11, (int8x16_t)vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v13.i32[3] = v9.i32[3];
  int8x16_t v14 = (int8x16_t)vrev64q_s32(v13);
  *(void *)&double result = vextq_s8(v14, v14, 0xCuLL).u64[0];
  return result;
}

double sub_1B641613C(float32x2_t *a1, float32x2_t a2, double a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, double a7, float32x4_t a8)
{
  float32x2_t v8 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v13 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v8, _D1), (int8x8_t)vcltz_f32(v8));
  if ((vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v14 = (int32x2_t)a1[1];
  float32x2_t v15 = vmul_f32(*a1, v8);
  int32x2_t v16 = vmin_s32(vcvt_s32_f32(v15), v14);
  float32x2_t v17 = a1[4];
  *(float32x2_t *)a5.f32 = a1[2];
  *(int8x8_t *)a6.f32 = vand_s8(*(int8x8_t *)a5.f32, (int8x8_t)vcgt_s32(v14, v16));
  int32x2_t v18 = vmul_s32(*(int32x2_t *)a5.f32, v16);
  *(int32x2_t *)a4.f32 = vdup_lane_s32(v18, 1);
  uint64_t v19 = vadd_s32(v18, *(int32x2_t *)a4.f32).i32[0];
  unsigned int v20 = *(unsigned __int16 *)(*(void *)&v17 + v19);
  int v21 = (v20 >> 10) & 0x1F;
  if (v21 == 31) {
    int v22 = 2139095040;
  }
  else {
    int v22 = (v20 >> 10) & 0x1F;
  }
  if (v21) {
    _ZF = v21 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    int v24 = v22;
  }
  else {
    int v24 = (v21 << 23) + 939524096;
  }
  a4.i32[0] = v24 | (v20 << 16) & 0x80000000 | (v20 >> 7) & 7 | (8 * (v20 & 0x3FF)) & 0x1FFF | ((v20 & 0x3FF) << 13);
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0);
  uint64_t v26 = v19 + a6.i32[0];
  uint64_t v27 = v19 + a6.i32[1];
  uint64_t v28 = (int)v27 + (uint64_t)a6.i32[0];
  unsigned int v29 = *(unsigned __int16 *)(*(void *)&v17 + v26);
  int v30 = (v29 >> 10) & 0x1F;
  if (v30 == 31) {
    int v31 = 2139095040;
  }
  else {
    int v31 = (v29 >> 10) & 0x1F;
  }
  if (v30) {
    BOOL v32 = v30 == 31;
  }
  else {
    BOOL v32 = 1;
  }
  if (v32) {
    int v33 = v31;
  }
  else {
    int v33 = (v30 << 23) + 939524096;
  }
  a5.i32[0] = v33 | (v29 << 16) & 0x80000000 | (v29 >> 7) & 7 | (8 * (v29 & 0x3FF)) & 0x1FFF | ((v29 & 0x3FF) << 13);
  unsigned int v34 = *(unsigned __int16 *)(*(void *)&v17 + v27);
  int v35 = (v34 >> 10) & 0x1F;
  if (v35 == 31) {
    int v36 = 2139095040;
  }
  else {
    int v36 = (v34 >> 10) & 0x1F;
  }
  if (v35) {
    BOOL v37 = v35 == 31;
  }
  else {
    BOOL v37 = 1;
  }
  if (v37) {
    int v38 = v36;
  }
  else {
    int v38 = (v35 << 23) + 939524096;
  }
  a6.i32[0] = v38 | (v34 << 16) & 0x80000000 | (v34 >> 7) & 7 | (8 * (v34 & 0x3FF)) & 0x1FFF | ((v34 & 0x3FF) << 13);
  float32x4_t v39 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0);
  unsigned int v40 = *(unsigned __int16 *)(*(void *)&v17 + v28);
  int v41 = (v40 >> 10) & 0x1F;
  if (v41 == 31) {
    int v42 = 2139095040;
  }
  else {
    int v42 = (v40 >> 10) & 0x1F;
  }
  if (v41) {
    BOOL v43 = v41 == 31;
  }
  else {
    BOOL v43 = 1;
  }
  if (!v43) {
    int v42 = (v41 << 23) + 939524096;
  }
  a8.i32[0] = v42 | (v40 << 16) & 0x80000000 | (v40 >> 7) & 7 | (8 * (v40 & 0x3FF)) & 0x1FFF | ((v40 & 0x3FF) << 13);
  float32x2_t v44 = vsub_f32(v15, vrnd_f32(v15));
  float32x4_t v45 = (float32x4_t)vdupq_lane_s32((int32x2_t)v44, 0);
  float32x4_t v46 = vmlaq_n_f32(v25, v45, vsubq_f32(a5, a4).f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v46, vmlaq_n_f32(vsubq_f32(v39, v46), v45, vsubq_f32(a8, a6).f32[0]), v44, 1).u64[0];
  return result;
}

double sub_1B64162FC(float32x2_t *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v8 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v2, _D1), (int8x8_t)vcltz_f32(v2));
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v9 = (int32x2_t)a1[1];
  float32x2_t v10 = vmul_f32(*a1, v2);
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  float32x2_t v12 = a1[4];
  int32x2_t v13 = (int32x2_t)a1[2];
  int8x8_t v14 = (int8x8_t)vcgt_s32(v9, v11);
  int32x2_t v15 = vmul_s32(v13, v11);
  int32x2_t v16 = vdup_lane_s32(v15, 1);
  uint64_t v17 = vadd_s32(v15, v16).i32[0];
  v16.i32[0] = *(_DWORD *)(*(void *)&v12 + v17);
  int32x2_t v18 = (int32x2_t)vand_s8((int8x8_t)v13, v14);
  uint64_t v19 = v17 + v18.i32[0];
  uint64_t v20 = v17 + v18.i32[1];
  v13.i32[0] = *(_DWORD *)(*(void *)&v12 + v20);
  float v21 = *(float *)(*(void *)&v12 + (int)v20 + (uint64_t)v18.i32[0]);
  float32x2_t v22 = vsub_f32(v10, vrnd_f32(v10));
  *(float *)v18.i32 = *(float *)(*(void *)&v12 + v19) - *(float *)v16.i32;
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(v18, 0);
  float32x4_t v24 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v16, 0), v23, v22.f32[0]);
  v23.f32[0] = v21 - *(float *)v13.i32;
  *(void *)&double result = vmlaq_lane_f32(v24, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v13, 0), v24), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0), v22.f32[0]), v22, 1).u64[0];
  return result;
}

double sub_1B64163B8(float32x2_t *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v8 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v2, _D1), (int8x8_t)vcltz_f32(v2));
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v9 = (int32x2_t)a1[1];
  float32x2_t v10 = vmul_f32(*a1, v2);
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  float32x2_t v12 = a1[4];
  int32x2_t v13 = (int32x2_t)a1[2];
  int8x8_t v14 = vand_s8((int8x8_t)v13, (int8x8_t)vcgt_s32(v9, v11));
  int32x2_t v15 = vmul_s32(v13, v11);
  uint64_t v16 = vadd_s32(v15, vdup_lane_s32(v15, 1)).i32[0];
  int16x4_t v17 = *(int16x4_t *)(*(void *)&v12 + v16);
  v18.i64[0] = 0x8000000080000000;
  v18.i64[1] = 0x8000000080000000;
  int32x4_t v19 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v17), v18);
  int8x16_t v20 = (int8x16_t)vshll_n_u16((uint16x4_t)v17, 0xDuLL);
  int8x16_t v21 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v22 = (int8x16_t)vdupq_n_s32(0xF800000u);
  int32x4_t v23 = (int32x4_t)vorrq_s8(vandq_s8(v20, v22), vorrq_s8((int8x16_t)v19, vandq_s8(v20, v21)));
  v19.i64[0] = 0x3800000038000000;
  v19.i64[1] = 0x3800000038000000;
  float32x4_t v24 = (float32x4_t)vaddq_s32(v23, v19);
  uint64_t v25 = v16 + v14.i32[0];
  uint64_t v26 = v16 + v14.i32[1];
  uint64_t v27 = (int)v26 + (uint64_t)v14.i32[0];
  int16x4_t v28 = *(int16x4_t *)(*(void *)&v12 + v25);
  int8x16_t v29 = vandq_s8((int8x16_t)vmovl_s16(v28), v18);
  int8x16_t v30 = (int8x16_t)vshll_n_u16((uint16x4_t)v28, 0xDuLL);
  float32x4_t v31 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v30, v22), vorrq_s8(v29, vandq_s8(v30, v21))), v19);
  v29.i64[0] = *(void *)(*(void *)&v12 + v26);
  int8x16_t v32 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v29.i8), v18);
  int8x16_t v33 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v29.i8, 0xDuLL);
  float32x4_t v34 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v33, v22), vorrq_s8(v32, vandq_s8(v33, v21))), v19);
  v32.i64[0] = *(void *)(*(void *)&v12 + v27);
  int8x16_t v35 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v32.i8), v18);
  int8x16_t v36 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v32.i8, 0xDuLL);
  float32x2_t v37 = vsub_f32(v10, vrnd_f32(v10));
  float32x4_t v38 = vmlaq_n_f32(v24, vsubq_f32(v31, v24), v37.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v38, vmlaq_n_f32(vsubq_f32(v34, v38), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v36, v22), vorrq_s8(v35, vandq_s8(v36, v21))), v19), v34), v37.f32[0]), v37, 1).u64[0];
  return result;
}

double sub_1B64164FC(float32x2_t *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v8 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v2, _D1), (int8x8_t)vcltz_f32(v2));
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v9 = (int32x2_t)a1[1];
  float32x2_t v10 = vmul_f32(*a1, v2);
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  float32x2_t v12 = a1[4];
  int32x2_t v13 = (int32x2_t)a1[2];
  int8x8_t v14 = vand_s8((int8x8_t)v13, (int8x8_t)vcgt_s32(v9, v11));
  int32x2_t v15 = vmul_s32(v13, v11);
  uint64_t v16 = vadd_s32(v15, vdup_lane_s32(v15, 1)).i32[0];
  float32x2_t v17 = vsub_f32(v10, vrnd_f32(v10));
  float32x4_t v18 = vmlaq_n_f32(*(float32x4_t *)(*(void *)&v12 + v16), vsubq_f32(*(float32x4_t *)(*(void *)&v12 + v16 + v14.i32[0]), *(float32x4_t *)(*(void *)&v12 + v16)), v17.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v18, vmlaq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v12 + v16 + v14.i32[1]), v18), vsubq_f32(*(float32x4_t *)(*(void *)&v12 + (int)v16 + v14.i32[1] + (uint64_t)v14.i32[0]), *(float32x4_t *)(*(void *)&v12 + v16 + v14.i32[1])), v17.f32[0]), v17, 1).u64[0];
  return result;
}

double sub_1B64165A8(float32x2_t *a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  float32x2_t v9 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v15 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v9, _D1), (int8x8_t)vcltz_f32(v9));
  if ((vpmax_u32(v15, v15).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v16 = (int32x2_t)a1[1];
  float32x2_t v17 = vmul_f32(*a1, v9);
  int32x2_t v18 = vmin_s32(vcvt_s32_f32(v17), v16);
  float32x2_t v19 = a1[4];
  int32x2_t v20 = (int32x2_t)a1[2];
  int8x8_t v21 = (int8x8_t)vcgt_s32(v16, v18);
  int32x2_t v22 = vmul_s32(v20, v18);
  int32x2_t v23 = vdup_lane_s32(v22, 1);
  v22.i32[0] = vadd_s32(v22, v23).u32[0];
  uint64_t v24 = v22.i32[0];
  int32x2_t v25 = (int32x2_t)vand_s8((int8x8_t)v20, v21);
  v22.i8[0] = *(unsigned char *)(*(void *)&v19 + v22.i32[0]);
  *(float *)v23.i32 = (float)v22.u32[0] * 0.0039216;
  uint64_t v26 = v24 + v25.i32[0];
  uint64_t v27 = v24 + v25.i32[1];
  uint64_t v28 = (int)v27 + (uint64_t)v25.i32[0];
  v25.i8[0] = *(unsigned char *)(*(void *)&v19 + v26);
  LOBYTE(a7) = *(unsigned char *)(*(void *)&v19 + v27);
  *(float *)&a7 = (float)LODWORD(a7) * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(*(void *)&v19 + v28);
  float32x2_t v29 = vsub_f32(v17, vrnd_f32(v17));
  *(float *)v25.i32 = -(float)(*(float *)v23.i32 - (float)((float)v25.u32[0] * 0.0039216));
  float32x4_t v30 = (float32x4_t)vdupq_lane_s32(v25, 0);
  float32x4_t v31 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v23, 0), v30, v29.f32[0]);
  v30.f32[0] = -(float)(*(float *)&a7 - (float)((float)LODWORD(a9) * 0.0039216));
  *(void *)&double result = vmlaq_lane_f32(v31, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0), v31), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 0), v29.f32[0]), v29, 1).u64[0];
  return result;
}

double sub_1B6416684(float32x2_t *a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  float32x2_t v9 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v15 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v9, _D1), (int8x8_t)vcltz_f32(v9));
  if ((vpmax_u32(v15, v15).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v16 = (int32x2_t)a1[1];
  float32x2_t v17 = vmul_f32(*a1, v9);
  int32x2_t v18 = vmin_s32(vcvt_s32_f32(v17), v16);
  float32x2_t v19 = a1[4];
  int32x2_t v20 = (int32x2_t)a1[2];
  int32x2_t v21 = (int32x2_t)vand_s8((int8x8_t)v20, (int8x8_t)vcgt_s32(v16, v18));
  int32x2_t v22 = vmul_s32(v20, v18);
  v22.i32[0] = vadd_s32(v22, vdup_lane_s32(v22, 1)).u32[0];
  uint64_t v23 = v22.i32[0];
  v22.i8[0] = *(unsigned char *)(*(void *)&v19 + v22.i32[0]);
  *(float *)&a6 = (float)v22.u32[0] * 0.0039216;
  uint64_t v24 = v23 + v21.i32[0];
  uint64_t v25 = v23 + v21.i32[1];
  uint64_t v26 = (int)v25 + (uint64_t)v21.i32[0];
  v21.i8[0] = *(unsigned char *)(*(void *)&v19 + v24);
  LOBYTE(a7) = *(unsigned char *)(*(void *)&v19 + v25);
  *(float *)&a7 = (float)LODWORD(a7) * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(*(void *)&v19 + v26);
  float32x2_t v27 = vsub_f32(v17, vrnd_f32(v17));
  *(float *)v21.i32 = -(float)(*(float *)&a6 - (float)((float)v21.u32[0] * 0.0039216));
  float32x4_t v28 = (float32x4_t)vdupq_lane_s32(v21, 0);
  float32x4_t v29 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0), v28, v27.f32[0]);
  v28.f32[0] = -(float)(*(float *)&a7 - (float)((float)LODWORD(a9) * 0.0039216));
  float32x4_t v30 = vmlaq_lane_f32(v29, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0), v29), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), v27.f32[0]), v27, 1);
  float32x4_t v31 = vmulq_f32(v30, v30);
  int32x4_t v32 = vcgeq_f32(v30, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v32.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v32), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v30), v31, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v30)), vmulq_f32(v31, v31), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v30), v31,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v30))), (int8x16_t)vmulq_f32(v30, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6416814(float32x2_t *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v8 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v2, _D1), (int8x8_t)vcltz_f32(v2));
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v9 = (int32x2_t)a1[1];
  float32x2_t v10 = vmul_f32(*a1, v2);
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  float32x2_t v12 = a1[4];
  int32x2_t v13 = (int32x2_t)a1[2];
  int8x8_t v14 = (int8x8_t)vcgt_s32(v9, v11);
  int32x2_t v15 = vmul_s32(v13, v11);
  int8x8_t v16 = vand_s8((int8x8_t)v13, v14);
  uint64_t v17 = vadd_s32(v15, vdup_lane_s32(v15, 1)).i32[0];
  int32x2_t v18 = (const float *)(*(void *)&v12 + v17);
  uint32x4_t v19 = (uint32x4_t)vld1q_dup_f32(v18);
  v20.i64[0] = 0xFF000000FFLL;
  v20.i64[1] = 0xFF000000FFLL;
  float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v22 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v19, (uint32x4_t)xmmword_1B6E50360), v20)), v21);
  uint64_t v23 = v17 + v16.i32[0];
  uint64_t v24 = v17 + v16.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)v16.i32[0];
  uint64_t v26 = (const float *)(*(void *)&v12 + v23);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v26);
  float32x4_t v28 = (const float *)(*(void *)&v12 + v24);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v30 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), v20)), v21);
  float32x4_t v31 = (const float *)(*(void *)&v12 + v25);
  uint32x4_t v32 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x2_t v33 = vsub_f32(v10, vrnd_f32(v10));
  float32x4_t v34 = vmlaq_n_f32(v22, vmlaq_f32(vnegq_f32(v22), v21, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v20))), v33.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v34, vmlaq_n_f32(vsubq_f32(v30, v34), vmlaq_f32(vnegq_f32(v30), v21, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v32, (uint32x4_t)xmmword_1B6E50360), v20))), v33.f32[0]), v33, 1).u64[0];
  return result;
}

double sub_1B6416928(float32x2_t *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v8 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v2, _D1), (int8x8_t)vcltz_f32(v2));
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v9 = (int32x2_t)a1[1];
  float32x2_t v10 = vmul_f32(*a1, v2);
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  float32x2_t v12 = a1[4];
  int32x2_t v13 = (int32x2_t)a1[2];
  int8x8_t v14 = vand_s8((int8x8_t)v13, (int8x8_t)vcgt_s32(v9, v11));
  int32x2_t v15 = vmul_s32(v13, v11);
  uint64_t v16 = vadd_s32(v15, vdup_lane_s32(v15, 1)).i32[0];
  uint64_t v17 = (const float *)(*(void *)&v12 + v16);
  uint32x4_t v18 = (uint32x4_t)vld1q_dup_f32(v17);
  v19.i64[0] = 0xFF000000FFLL;
  v19.i64[1] = 0xFF000000FFLL;
  float32x4_t v20 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v21 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v18, (uint32x4_t)xmmword_1B6E50360), v19)), v20);
  uint64_t v22 = v16 + v14.i32[0];
  uint64_t v23 = v16 + v14.i32[1];
  uint64_t v24 = (int)v23 + (uint64_t)v14.i32[0];
  uint64_t v25 = (const float *)(*(void *)&v12 + v22);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v27 = (const float *)(*(void *)&v12 + v23);
  uint32x4_t v28 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v29 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v28, (uint32x4_t)xmmword_1B6E50360), v19)), v20);
  float32x4_t v30 = (const float *)(*(void *)&v12 + v24);
  uint32x4_t v31 = (uint32x4_t)vld1q_dup_f32(v30);
  float32x2_t v32 = vsub_f32(v10, vrnd_f32(v10));
  float32x4_t v33 = vmlaq_n_f32(v21, vmlaq_f32(vnegq_f32(v21), v20, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v19))), v32.f32[0]);
  float32x4_t v34 = vmlaq_lane_f32(v33, vmlaq_n_f32(vsubq_f32(v29, v33), vmlaq_f32(vnegq_f32(v29), v20, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v31, (uint32x4_t)xmmword_1B6E50360), v19))), v32.f32[0]), v32, 1);
  float32x4_t v35 = vmulq_f32(v34, v34);
  int32x4_t v36 = vcgeq_f32(v34, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v36.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v36), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v34), v35, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v34)), vmulq_f32(v35, v35), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v34), v35,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v34))), (int8x16_t)vmulq_f32(v34, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6416AF0(float32x2_t *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v8 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v2, _D1), (int8x8_t)vcltz_f32(v2));
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v9 = (int32x2_t)a1[1];
  float32x2_t v10 = vmul_f32(*a1, v2);
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  float32x2_t v12 = a1[4];
  int32x2_t v13 = (int32x2_t)a1[2];
  int8x8_t v14 = vand_s8((int8x8_t)v13, (int8x8_t)vcgt_s32(v9, v11));
  int32x2_t v15 = vmul_s32(v13, v11);
  uint64_t v16 = vadd_s32(v15, vdup_lane_s32(v15, 1)).i32[0];
  uint64_t v17 = (const float *)(*(void *)&v12 + v16);
  uint32x4_t v18 = (uint32x4_t)vld1q_dup_f32(v17);
  v19.i64[0] = 0xFF000000FFLL;
  v19.i64[1] = 0xFF000000FFLL;
  float32x4_t v20 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v21 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v18, (uint32x4_t)xmmword_1B6E50360), v19)), v20);
  uint64_t v22 = v16 + v14.i32[0];
  uint64_t v23 = v16 + v14.i32[1];
  uint64_t v24 = (int)v23 + (uint64_t)v14.i32[0];
  uint64_t v25 = (const float *)(*(void *)&v12 + v22);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v25);
  uint32x4_t v27 = (const float *)(*(void *)&v12 + v23);
  uint32x4_t v28 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v29 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v28, (uint32x4_t)xmmword_1B6E50360), v19)), v20);
  float32x4_t v30 = (const float *)(*(void *)&v12 + v24);
  uint32x4_t v31 = (uint32x4_t)vld1q_dup_f32(v30);
  float32x2_t v32 = vsub_f32(v10, vrnd_f32(v10));
  float32x4_t v33 = vmlaq_n_f32(v21, vmlaq_f32(vnegq_f32(v21), v20, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v19))), v32.f32[0]);
  int8x16_t v34 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_lane_f32(v33, vmlaq_n_f32(vsubq_f32(v29, v33), vmlaq_f32(vnegq_f32(v29), v20, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v31, (uint32x4_t)xmmword_1B6E50360), v19))), v32.f32[0]), v32, 1));
  *(void *)&double result = vextq_s8(v34, v34, 0xCuLL).u64[0];
  return result;
}

double sub_1B6416C0C(float32x2_t *a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, a1[6]);
  __asm { FMOV            V1.2S, #1.0 }
  uint32x2_t v8 = (uint32x2_t)vorr_s8((int8x8_t)vcge_f32(v2, _D1), (int8x8_t)vcltz_f32(v2));
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 0.0;
  }
  int32x2_t v9 = (int32x2_t)a1[1];
  float32x2_t v10 = vmul_f32(*a1, v2);
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  float32x2_t v12 = a1[4];
  int32x2_t v13 = (int32x2_t)a1[2];
  int8x8_t v14 = (int8x8_t)vcgt_s32(v9, v11);
  int32x2_t v15 = vmul_s32(v13, v11);
  uint64_t v16 = vadd_s32(v15, vdup_lane_s32(v15, 1)).i32[0];
  uint64_t v17 = (const float *)(*(void *)&v12 + v16);
  uint32x4_t v18 = (uint32x4_t)vld1q_dup_f32(v17);
  int8x8_t v19 = vand_s8((int8x8_t)v13, v14);
  v20.i64[0] = 0xFF000000FFLL;
  v20.i64[1] = 0xFF000000FFLL;
  float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v22 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v18, (uint32x4_t)xmmword_1B6E50360), v20)), v21);
  uint64_t v23 = v16 + v19.i32[0];
  uint64_t v24 = v16 + v19.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)v19.i32[0];
  uint32x4_t v26 = (const float *)(*(void *)&v12 + v23);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v26);
  uint32x4_t v28 = (const float *)(*(void *)&v12 + v24);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x4_t v30 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), v20)), v21);
  uint32x4_t v31 = (const float *)(*(void *)&v12 + v25);
  uint32x4_t v32 = (uint32x4_t)vld1q_dup_f32(v31);
  float32x2_t v33 = vsub_f32(v10, vrnd_f32(v10));
  float32x4_t v34 = vmlaq_n_f32(v22, vmlaq_f32(vnegq_f32(v22), v21, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v20))), v33.f32[0]);
  float32x4_t v35 = vmlaq_lane_f32(v34, vmlaq_n_f32(vsubq_f32(v30, v34), vmlaq_f32(vnegq_f32(v30), v21, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v32, (uint32x4_t)xmmword_1B6E50360), v20))), v33.f32[0]), v33, 1);
  float32x4_t v36 = vmulq_f32(v35, v35);
  int32x4_t v37 = vcgeq_f32(v35, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v37.i32[3] = 0;
  int32x4_t v38 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v37), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v35), v36, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v35)), vmulq_f32(v36, v36), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v35), v36,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v35))), (int8x16_t)vmulq_f32(v35, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v38.i32[3] = v35.i32[3];
  int8x16_t v39 = (int8x16_t)vrev64q_s32(v38);
  *(void *)&double result = vextq_s8(v39, v39, 0xCuLL).u64[0];
  return result;
}

double sub_1B6416DDC(float32x2_t *a1, float32x2_t a2, double a3, float32x4_t a4, double a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v12 = (int32x2_t)a1[1];
  float32x2_t v13 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v14 = vmin_s32(vcvt_s32_f32(v13), v12);
  float32x2_t v15 = a1[4];
  int32x2_t v16 = (int32x2_t)a1[2];
  *(int8x8_t *)a4.f32 = vand_s8((int8x8_t)v16, (int8x8_t)vcgt_s32(v12, v14));
  int32x2_t v17 = vmul_s32(v16, v14);
  signed __int32 v18 = vadd_s32(v17, vdup_lane_s32(v17, 1)).u32[0];
  unsigned int v19 = *(unsigned __int16 *)(*(void *)&v15 + v18);
  int v20 = (v19 >> 10) & 0x1F;
  if (v20 == 31) {
    int v21 = 2139095040;
  }
  else {
    int v21 = (v19 >> 10) & 0x1F;
  }
  if (v20) {
    _ZF = v20 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    int v23 = v21;
  }
  else {
    int v23 = (v20 << 23) + 939524096;
  }
  uint64_t v24 = v18 + (uint64_t)a4.i32[1];
  uint64_t v25 = (int)v24 + (uint64_t)a4.i32[0];
  unsigned int v26 = *(unsigned __int16 *)(*(void *)&v15 + v18 + (uint64_t)a4.i32[0]);
  int v27 = (v26 >> 10) & 0x1F;
  if (v27 == 31) {
    int v28 = 2139095040;
  }
  else {
    int v28 = (v26 >> 10) & 0x1F;
  }
  if (v27) {
    BOOL v29 = v27 == 31;
  }
  else {
    BOOL v29 = 1;
  }
  if (v29) {
    int v30 = v28;
  }
  else {
    int v30 = (v27 << 23) + 939524096;
  }
  unsigned int v31 = *(unsigned __int16 *)(*(void *)&v15 + v24);
  int v32 = (v31 >> 10) & 0x1F;
  if (v32 == 31) {
    int v33 = 2139095040;
  }
  else {
    int v33 = (v31 >> 10) & 0x1F;
  }
  if (v32) {
    BOOL v34 = v32 == 31;
  }
  else {
    BOOL v34 = 1;
  }
  if (v34) {
    int v35 = v33;
  }
  else {
    int v35 = (v32 << 23) + 939524096;
  }
  unsigned int v36 = *(unsigned __int16 *)(*(void *)&v15 + v25);
  int v37 = (v36 >> 10) & 0x1F;
  if (v37 == 31) {
    int v38 = 2139095040;
  }
  else {
    int v38 = (v36 >> 10) & 0x1F;
  }
  if (v37) {
    BOOL v39 = v37 == 31;
  }
  else {
    BOOL v39 = 1;
  }
  if (!v39) {
    int v38 = (v37 << 23) + 939524096;
  }
  a4.i32[0] = v35 | (v31 << 16) & 0x80000000 | (v31 >> 7) & 7 | (8 * (v31 & 0x3FF)) & 0x1FFF | ((v31 & 0x3FF) << 13);
  a6.i32[0] = v30 | (v26 << 16) & 0x80000000 | (v26 >> 7) & 7 | (8 * (v26 & 0x3FF)) & 0x1FFF | ((v26 & 0x3FF) << 13);
  a7.i32[0] = v23 | (v19 << 16) & 0x80000000 | (v19 >> 7) & 7 | (8 * (v19 & 0x3FF)) & 0x1FFF | ((v19 & 0x3FF) << 13);
  a8.i32[0] = v38 | (v36 << 16) & 0x80000000 | (v36 >> 7) & 7 | (8 * (v36 & 0x3FF)) & 0x1FFF | ((v36 & 0x3FF) << 13);
  float32x2_t v40 = vsub_f32(v13, vrnd_f32(v13));
  float32x4_t v41 = (float32x4_t)vdupq_lane_s32((int32x2_t)v40, 0);
  float32x4_t v42 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 0), v41, vsubq_f32(a6, a7).f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v42, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0), v42), v41, vsubq_f32(a8, a4).f32[0]), v40, 1).u64[0];
  return result;
}

double sub_1B6416F88(float32x2_t *a1, float32x2_t a2, double a3, double a4, double a5, double a6)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v11 = (int32x2_t)a1[1];
  float32x2_t v12 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v13 = vmin_s32(vcvt_s32_f32(v12), v11);
  float32x2_t v14 = a1[4];
  int32x2_t v15 = (int32x2_t)a1[2];
  int32x2_t v16 = (int32x2_t)vand_s8((int8x8_t)v15, (int8x8_t)vcgt_s32(v11, v13));
  int32x2_t v17 = vmul_s32(v15, v13);
  int32x2_t v18 = vdup_lane_s32(v17, 1);
  uint64_t v19 = vadd_s32(v17, v18).i32[0];
  v18.i32[0] = *(_DWORD *)(*(void *)&v14 + v19);
  uint64_t v20 = v19 + v16.i32[0];
  uint64_t v21 = v19 + v16.i32[1];
  LODWORD(a6) = *(_DWORD *)(*(void *)&v14 + v21);
  float v22 = *(float *)(*(void *)&v14 + (int)v21 + (uint64_t)v16.i32[0]);
  float32x2_t v23 = vsub_f32(v12, vrnd_f32(v12));
  *(float *)v16.i32 = *(float *)(*(void *)&v14 + v20) - *(float *)v18.i32;
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(v16, 0);
  float32x4_t v25 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v18, 0), v24, v23.f32[0]);
  v24.f32[0] = v22 - *(float *)&a6;
  *(void *)&double result = vmlaq_lane_f32(v25, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0), v25), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0), v23.f32[0]), v23, 1).u64[0];
  return result;
}

double sub_1B6417030(float32x2_t *a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = (int32x2_t)a1[1];
  float32x2_t v8 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v9 = vmin_s32(vcvt_s32_f32(v8), v7);
  float32x2_t v10 = a1[4];
  int32x2_t v11 = (int32x2_t)a1[2];
  int8x8_t v12 = (int8x8_t)vcgt_s32(v7, v9);
  int32x2_t v13 = vmul_s32(v11, v9);
  uint64_t v14 = vadd_s32(v13, vdup_lane_s32(v13, 1)).i32[0];
  int8x8_t v15 = vand_s8((int8x8_t)v11, v12);
  int16x4_t v16 = *(int16x4_t *)(*(void *)&v10 + v14);
  v17.i64[0] = 0x8000000080000000;
  v17.i64[1] = 0x8000000080000000;
  int32x4_t v18 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v16), v17);
  int8x16_t v19 = (int8x16_t)vshll_n_u16((uint16x4_t)v16, 0xDuLL);
  int8x16_t v20 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v21 = (int8x16_t)vdupq_n_s32(0xF800000u);
  int32x4_t v22 = (int32x4_t)vorrq_s8(vandq_s8(v19, v21), vorrq_s8((int8x16_t)v18, vandq_s8(v19, v20)));
  v18.i64[0] = 0x3800000038000000;
  v18.i64[1] = 0x3800000038000000;
  float32x4_t v23 = (float32x4_t)vaddq_s32(v22, v18);
  uint64_t v24 = v14 + v15.i32[0];
  uint64_t v25 = v14 + v15.i32[1];
  uint64_t v26 = (int)v25 + (uint64_t)v15.i32[0];
  int16x4_t v27 = *(int16x4_t *)(*(void *)&v10 + v24);
  int8x16_t v28 = vandq_s8((int8x16_t)vmovl_s16(v27), v17);
  int8x16_t v29 = (int8x16_t)vshll_n_u16((uint16x4_t)v27, 0xDuLL);
  float32x4_t v30 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v29, v21), vorrq_s8(v28, vandq_s8(v29, v20))), v18);
  v28.i64[0] = *(void *)(*(void *)&v10 + v25);
  int8x16_t v31 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v28.i8), v17);
  int8x16_t v32 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v28.i8, 0xDuLL);
  int32x4_t v33 = (int32x4_t)vorrq_s8(vandq_s8(v32, v21), vorrq_s8(v31, vandq_s8(v32, v20)));
  v31.i64[0] = *(void *)(*(void *)&v10 + v26);
  float32x4_t v34 = (float32x4_t)vaddq_s32(v33, v18);
  int8x16_t v35 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v31.i8), v17);
  int8x16_t v36 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v31.i8, 0xDuLL);
  float32x2_t v37 = vsub_f32(v8, vrnd_f32(v8));
  float32x4_t v38 = vmlaq_n_f32(v23, vsubq_f32(v30, v23), v37.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v38, vmlaq_n_f32(vsubq_f32(v34, v38), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v36, v21), vorrq_s8(v35, vandq_s8(v36, v20))), v18), v34), v37.f32[0]), v37, 1).u64[0];
  return result;
}

double sub_1B6417160(float32x2_t *a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = (int32x2_t)a1[1];
  float32x2_t v8 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v9 = vmin_s32(vcvt_s32_f32(v8), v7);
  float32x2_t v10 = a1[4];
  int32x2_t v11 = (int32x2_t)a1[2];
  int8x8_t v12 = vand_s8((int8x8_t)v11, (int8x8_t)vcgt_s32(v7, v9));
  int32x2_t v13 = vmul_s32(v11, v9);
  uint64_t v14 = vadd_s32(v13, vdup_lane_s32(v13, 1)).i32[0];
  float32x2_t v15 = vsub_f32(v8, vrnd_f32(v8));
  float32x4_t v16 = vmlaq_n_f32(*(float32x4_t *)(*(void *)&v10 + v14), vsubq_f32(*(float32x4_t *)(*(void *)&v10 + v14 + v12.i32[0]), *(float32x4_t *)(*(void *)&v10 + v14)), v15.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v16, vmlaq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v10 + v14 + v12.i32[1]), v16), vsubq_f32(*(float32x4_t *)(*(void *)&v10 + (int)v14 + v12.i32[1] + (uint64_t)v12.i32[0]), *(float32x4_t *)(*(void *)&v10 + v14 + v12.i32[1])), v15.f32[0]), v15, 1).u64[0];
  return result;
}

double sub_1B64171F8(float32x2_t *a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v14 = (int32x2_t)a1[1];
  float32x2_t v15 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v16 = vmin_s32(vcvt_s32_f32(v15), v14);
  float32x2_t v17 = a1[4];
  int32x2_t v18 = (int32x2_t)a1[2];
  int8x8_t v19 = (int8x8_t)vcgt_s32(v14, v16);
  int32x2_t v20 = vmul_s32(v18, v16);
  int32x2_t v21 = vdup_lane_s32(v20, 1);
  v20.i32[0] = vadd_s32(v20, v21).u32[0];
  uint64_t v22 = v20.i32[0];
  int32x2_t v23 = (int32x2_t)vand_s8((int8x8_t)v18, v19);
  v20.i8[0] = *(unsigned char *)(*(void *)&v17 + v20.i32[0]);
  *(float *)v21.i32 = (float)v20.u32[0] * 0.0039216;
  __int32 v24 = v23.i32[0];
  uint64_t v25 = v22 + v23.i32[0];
  uint64_t v26 = v22 + v23.i32[1];
  v23.i8[0] = *(unsigned char *)(*(void *)&v17 + v25);
  LOBYTE(a7) = *(unsigned char *)(*(void *)&v17 + v26);
  *(float *)&a7 = (float)LODWORD(a7) * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(*(void *)&v17 + (int)v26 + (uint64_t)v24);
  float32x2_t v27 = vsub_f32(v15, vrnd_f32(v15));
  *(float *)v23.i32 = -(float)(*(float *)v21.i32 - (float)((float)v23.u32[0] * 0.0039216));
  float32x4_t v28 = (float32x4_t)vdupq_lane_s32(v23, 0);
  float32x4_t v29 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v21, 0), v28, v27.f32[0]);
  v28.f32[0] = -(float)(*(float *)&a7 - (float)((float)LODWORD(a9) * 0.0039216));
  *(void *)&double result = vmlaq_lane_f32(v29, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0), v29), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), v27.f32[0]), v27, 1).u64[0];
  return result;
}

double sub_1B64172C0(float32x2_t *a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v14 = (int32x2_t)a1[1];
  float32x2_t v15 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v16 = vmin_s32(vcvt_s32_f32(v15), v14);
  float32x2_t v17 = a1[4];
  int32x2_t v18 = (int32x2_t)a1[2];
  int8x8_t v19 = (int8x8_t)vcgt_s32(v14, v16);
  int32x2_t v20 = vmul_s32(v18, v16);
  int32x2_t v21 = vdup_lane_s32(v20, 1);
  v20.i32[0] = vadd_s32(v20, v21).u32[0];
  uint64_t v22 = v20.i32[0];
  int32x2_t v23 = (int32x2_t)vand_s8((int8x8_t)v18, v19);
  v20.i8[0] = *(unsigned char *)(*(void *)&v17 + v20.i32[0]);
  *(float *)v21.i32 = (float)v20.u32[0] * 0.0039216;
  uint64_t v24 = v22 + v23.i32[0];
  uint64_t v25 = v22 + v23.i32[1];
  uint64_t v26 = (int)v25 + (uint64_t)v23.i32[0];
  v23.i8[0] = *(unsigned char *)(*(void *)&v17 + v24);
  LOBYTE(a7) = *(unsigned char *)(*(void *)&v17 + v25);
  *(float *)&a7 = (float)LODWORD(a7) * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(*(void *)&v17 + v26);
  float32x2_t v27 = vsub_f32(v15, vrnd_f32(v15));
  *(float *)v23.i32 = -(float)(*(float *)v21.i32 - (float)((float)v23.u32[0] * 0.0039216));
  float32x4_t v28 = (float32x4_t)vdupq_lane_s32(v23, 0);
  float32x4_t v29 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v21, 0), v28, v27.f32[0]);
  v28.f32[0] = -(float)(*(float *)&a7 - (float)((float)LODWORD(a9) * 0.0039216));
  float32x4_t v30 = vmlaq_lane_f32(v29, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0), v29), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 0), v27.f32[0]), v27, 1);
  float32x4_t v31 = vmulq_f32(v30, v30);
  int32x4_t v32 = vcgeq_f32(v30, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v32.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v32), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v30), v31, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v30)), vmulq_f32(v31, v31), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v30), v31,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v30))), (int8x16_t)vmulq_f32(v30, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B641743C(float32x2_t *a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = (int32x2_t)a1[1];
  float32x2_t v8 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v9 = vmin_s32(vcvt_s32_f32(v8), v7);
  float32x2_t v10 = a1[4];
  int32x2_t v11 = (int32x2_t)a1[2];
  int8x8_t v12 = (int8x8_t)vcgt_s32(v7, v9);
  int32x2_t v13 = vmul_s32(v11, v9);
  uint64_t v14 = vadd_s32(v13, vdup_lane_s32(v13, 1)).i32[0];
  float32x2_t v15 = (const float *)(*(void *)&v10 + v14);
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v15);
  int8x8_t v17 = vand_s8((int8x8_t)v11, v12);
  v18.i64[0] = 0xFF000000FFLL;
  v18.i64[1] = 0xFF000000FFLL;
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v20 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint64_t v21 = v14 + v17.i32[0];
  uint64_t v22 = v14 + v17.i32[1];
  uint64_t v23 = (int)v22 + (uint64_t)v17.i32[0];
  uint64_t v24 = (const float *)(*(void *)&v10 + v21);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v26 = (const float *)(*(void *)&v10 + v22);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v26);
  float32x4_t v28 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  float32x4_t v29 = (const float *)(*(void *)&v10 + v23);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x2_t v31 = vsub_f32(v8, vrnd_f32(v8));
  float32x4_t v32 = vmlaq_n_f32(v20, vmlaq_f32(vnegq_f32(v20), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), v18))), v31.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v32, vmlaq_n_f32(vsubq_f32(v28, v32), vmlaq_f32(vnegq_f32(v28), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), v18))), v31.f32[0]), v31, 1).u64[0];
  return result;
}

double sub_1B641753C(float32x2_t *a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = (int32x2_t)a1[1];
  float32x2_t v8 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v9 = vmin_s32(vcvt_s32_f32(v8), v7);
  float32x2_t v10 = a1[4];
  int32x2_t v11 = (int32x2_t)a1[2];
  int8x8_t v12 = (int8x8_t)vcgt_s32(v7, v9);
  int32x2_t v13 = vmul_s32(v11, v9);
  int8x8_t v14 = vand_s8((int8x8_t)v11, v12);
  uint64_t v15 = vadd_s32(v13, vdup_lane_s32(v13, 1)).i32[0];
  uint32x4_t v16 = (const float *)(*(void *)&v10 + v15);
  uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
  v18.i64[0] = 0xFF000000FFLL;
  v18.i64[1] = 0xFF000000FFLL;
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v20 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint64_t v21 = v15 + v14.i32[0];
  uint64_t v22 = v15 + v14.i32[1];
  uint64_t v23 = (int)v22 + (uint64_t)v14.i32[0];
  uint64_t v24 = (const float *)(*(void *)&v10 + v21);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v26 = (const float *)(*(void *)&v10 + v22);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v26);
  float32x4_t v28 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  float32x4_t v29 = (const float *)(*(void *)&v10 + v23);
  uint32x4_t v30 = (uint32x4_t)vld1q_dup_f32(v29);
  float32x2_t v31 = vsub_f32(v8, vrnd_f32(v8));
  float32x4_t v32 = vmlaq_n_f32(v20, vmlaq_f32(vnegq_f32(v20), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), v18))), v31.f32[0]);
  float32x4_t v33 = vmlaq_lane_f32(v32, vmlaq_n_f32(vsubq_f32(v28, v32), vmlaq_f32(vnegq_f32(v28), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v30, (uint32x4_t)xmmword_1B6E50360), v18))), v31.f32[0]), v31, 1);
  float32x4_t v34 = vmulq_f32(v33, v33);
  int32x4_t v35 = vcgeq_f32(v33, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v35.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v35), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v33), v34, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v33)), vmulq_f32(v34, v34), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v33), v34,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v33))), (int8x16_t)vmulq_f32(v33, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B64176F0(float32x2_t *a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = (int32x2_t)a1[1];
  float32x2_t v8 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v9 = vmin_s32(vcvt_s32_f32(v8), v7);
  float32x2_t v10 = a1[4];
  int32x2_t v11 = (int32x2_t)a1[2];
  int8x8_t v12 = (int8x8_t)vcgt_s32(v7, v9);
  int32x2_t v13 = vmul_s32(v11, v9);
  uint64_t v14 = vadd_s32(v13, vdup_lane_s32(v13, 1)).i32[0];
  int8x8_t v15 = vand_s8((int8x8_t)v11, v12);
  uint32x4_t v16 = (const float *)(*(void *)&v10 + v14);
  uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
  v18.i64[0] = 0xFF000000FFLL;
  v18.i64[1] = 0xFF000000FFLL;
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v20 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  __int32 v21 = v15.i32[0];
  uint64_t v22 = v14 + v15.i32[0];
  uint64_t v23 = v14 + v15.i32[1];
  uint64_t v24 = (const float *)(*(void *)&v10 + v22);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v24);
  uint64_t v26 = (int)v23 + (uint64_t)v21;
  uint32x4_t v27 = (const float *)(*(void *)&v10 + v23);
  uint32x4_t v28 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x4_t v29 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v28, (uint32x4_t)xmmword_1B6E50360), v18)), v19);
  uint32x4_t v30 = (const float *)(*(void *)&v10 + v26);
  uint32x4_t v31 = (uint32x4_t)vld1q_dup_f32(v30);
  float32x2_t v32 = vsub_f32(v8, vrnd_f32(v8));
  float32x4_t v33 = vmlaq_n_f32(v20, vmlaq_f32(vnegq_f32(v20), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), v18))), v32.f32[0]);
  int8x16_t v34 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_lane_f32(v33, vmlaq_n_f32(vsubq_f32(v29, v33), vmlaq_f32(vnegq_f32(v29), v19, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v31, (uint32x4_t)xmmword_1B6E50360), v18))), v32.f32[0]), v32, 1));
  *(void *)&double result = vextq_s8(v34, v34, 0xCuLL).u64[0];
  return result;
}

double sub_1B64177F8(float32x2_t *a1, float32x2_t a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int32x2_t v7 = (int32x2_t)a1[1];
  float32x2_t v8 = vmul_f32(*a1, vminnm_f32(vmaxnm_f32(vsub_f32(a2, a1[6]), 0), _D1));
  int32x2_t v9 = vmin_s32(vcvt_s32_f32(v8), v7);
  float32x2_t v10 = a1[4];
  int32x2_t v11 = (int32x2_t)a1[2];
  int8x8_t v12 = vand_s8((int8x8_t)v11, (int8x8_t)vcgt_s32(v7, v9));
  int32x2_t v13 = vmul_s32(v11, v9);
  uint64_t v14 = vadd_s32(v13, vdup_lane_s32(v13, 1)).i32[0];
  int8x8_t v15 = (const float *)(*(void *)&v10 + v14);
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v15);
  v17.i64[0] = 0xFF000000FFLL;
  v17.i64[1] = 0xFF000000FFLL;
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v19 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  uint64_t v20 = v14 + v12.i32[0];
  uint64_t v21 = v14 + v12.i32[1];
  uint64_t v22 = (int)v21 + (uint64_t)v12.i32[0];
  uint64_t v23 = (const float *)(*(void *)&v10 + v20);
  uint32x4_t v24 = (uint32x4_t)vld1q_dup_f32(v23);
  uint32x4_t v25 = (const float *)(*(void *)&v10 + v21);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x4_t v27 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v17)), v18);
  uint32x4_t v28 = (const float *)(*(void *)&v10 + v22);
  uint32x4_t v29 = (uint32x4_t)vld1q_dup_f32(v28);
  float32x2_t v30 = vsub_f32(v8, vrnd_f32(v8));
  float32x4_t v31 = vmlaq_n_f32(v19, vmlaq_f32(vnegq_f32(v19), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v24, (uint32x4_t)xmmword_1B6E50360), v17))), v30.f32[0]);
  float32x4_t v32 = vmlaq_lane_f32(v31, vmlaq_n_f32(vsubq_f32(v27, v31), vmlaq_f32(vnegq_f32(v27), v18, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v29, (uint32x4_t)xmmword_1B6E50360), v17))), v30.f32[0]), v30, 1);
  float32x4_t v33 = vmulq_f32(v32, v32);
  int32x4_t v34 = vcgeq_f32(v32, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v34.i32[3] = 0;
  int32x4_t v35 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v34), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v32), v33, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v32)), vmulq_f32(v33, v33), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v32), v33,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v32))), (int8x16_t)vmulq_f32(v32, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v35.i32[3] = v32.i32[3];
  int8x16_t v36 = (int8x16_t)vrev64q_s32(v35);
  *(void *)&double result = vextq_s8(v36, v36, 0xCuLL).u64[0];
  return result;
}

double sub_1B64179B4(uint64_t a1, float32x2_t a2, double a3, float32x4_t a4, double a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  float32x2_t v8 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v9 = *(int32x2_t *)(a1 + 8);
  float32x2_t v10 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v11 = vmin_s32(vcvt_s32_f32(v10), v9);
  uint64_t v12 = *(void *)(a1 + 32);
  a6.i64[0] = *(void *)(a1 + 16);
  *(int8x8_t *)a4.f32 = vbsl_s8((int8x8_t)vcgt_s32(v9, v11), *(int8x8_t *)a6.f32, *(int8x8_t *)(a1 + 24));
  int32x2_t v13 = vmul_s32(*(int32x2_t *)a6.f32, v11);
  signed __int32 v14 = vadd_s32(v13, vdup_lane_s32(v13, 1)).u32[0];
  unsigned int v15 = *(unsigned __int16 *)(v12 + v14);
  int v16 = (v15 >> 10) & 0x1F;
  if (v16 == 31) {
    int v17 = 2139095040;
  }
  else {
    int v17 = (v15 >> 10) & 0x1F;
  }
  if (v16) {
    BOOL v18 = v16 == 31;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18) {
    int v19 = v17;
  }
  else {
    int v19 = (v16 << 23) + 939524096;
  }
  uint64_t v20 = v14 + (uint64_t)a4.i32[1];
  uint64_t v21 = (int)v20 + (uint64_t)a4.i32[0];
  unsigned int v22 = *(unsigned __int16 *)(v12 + v14 + (uint64_t)a4.i32[0]);
  int v23 = (v22 >> 10) & 0x1F;
  if (v23 == 31) {
    int v24 = 2139095040;
  }
  else {
    int v24 = (v22 >> 10) & 0x1F;
  }
  if (v23) {
    BOOL v25 = v23 == 31;
  }
  else {
    BOOL v25 = 1;
  }
  if (v25) {
    int v26 = v24;
  }
  else {
    int v26 = (v23 << 23) + 939524096;
  }
  unsigned int v27 = *(unsigned __int16 *)(v12 + v20);
  int v28 = (v27 >> 10) & 0x1F;
  if (v28 == 31) {
    int v29 = 2139095040;
  }
  else {
    int v29 = (v27 >> 10) & 0x1F;
  }
  if (v28) {
    BOOL v30 = v28 == 31;
  }
  else {
    BOOL v30 = 1;
  }
  if (v30) {
    int v31 = v29;
  }
  else {
    int v31 = (v28 << 23) + 939524096;
  }
  unsigned int v32 = *(unsigned __int16 *)(v12 + v21);
  int v33 = (v32 >> 10) & 0x1F;
  if (v33 == 31) {
    int v34 = 2139095040;
  }
  else {
    int v34 = (v32 >> 10) & 0x1F;
  }
  if (v33) {
    BOOL v35 = v33 == 31;
  }
  else {
    BOOL v35 = 1;
  }
  if (!v35) {
    int v34 = (v33 << 23) + 939524096;
  }
  a4.i32[0] = v31 | (v27 << 16) & 0x80000000 | (v27 >> 7) & 7 | (8 * (v27 & 0x3FF)) & 0x1FFF | ((v27 & 0x3FF) << 13);
  a6.i32[0] = v26 | (v22 << 16) & 0x80000000 | (v22 >> 7) & 7 | (8 * (v22 & 0x3FF)) & 0x1FFF | ((v22 & 0x3FF) << 13);
  a7.i32[0] = v19 | (v15 << 16) & 0x80000000 | (v15 >> 7) & 7 | (8 * (v15 & 0x3FF)) & 0x1FFF | ((v15 & 0x3FF) << 13);
  a8.i32[0] = v34 | (v32 << 16) & 0x80000000 | (v32 >> 7) & 7 | (8 * (v32 & 0x3FF)) & 0x1FFF | ((v32 & 0x3FF) << 13);
  float32x2_t v36 = vsub_f32(v10, vrnd_f32(v10));
  float32x4_t v37 = (float32x4_t)vdupq_lane_s32((int32x2_t)v36, 0);
  float32x4_t v38 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 0), v37, vsubq_f32(a6, a7).f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v38, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0), v38), v37, vsubq_f32(a8, a4).f32[0]), v36, 1).u64[0];
  return result;
}

double sub_1B6417B64(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v3 = *(int32x2_t *)(a1 + 8);
  float32x2_t v4 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v5 = vmin_s32(vcvt_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = *(int32x2_t *)(a1 + 16);
  int32x2_t v8 = (int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v3, v5), (int8x8_t)v7, *(int8x8_t *)(a1 + 24));
  int32x2_t v9 = vmul_s32(v7, v5);
  int32x2_t v10 = vdup_lane_s32(v9, 1);
  uint64_t v11 = vadd_s32(v9, v10).i32[0];
  v10.i32[0] = *(_DWORD *)(v6 + v11);
  uint64_t v12 = v11 + v8.i32[0];
  uint64_t v13 = v11 + v8.i32[1];
  v7.i32[0] = *(_DWORD *)(v6 + v13);
  float v14 = *(float *)(v6 + (int)v13 + (uint64_t)v8.i32[0]);
  float32x2_t v15 = vsub_f32(v4, vrnd_f32(v4));
  *(float *)v8.i32 = *(float *)(v6 + v12) - *(float *)v10.i32;
  float32x4_t v16 = (float32x4_t)vdupq_lane_s32(v8, 0);
  float32x4_t v17 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v10, 0), v16, v15.f32[0]);
  v16.f32[0] = v14 - *(float *)v7.i32;
  *(void *)&double result = vmlaq_lane_f32(v17, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v7, 0), v17), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 0), v15.f32[0]), v15, 1).u64[0];
  return result;
}

double sub_1B6417C10(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v3 = *(int32x2_t *)(a1 + 8);
  float32x2_t v4 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v5 = vmin_s32(vcvt_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = *(int32x2_t *)(a1 + 16);
  int8x8_t v8 = (int8x8_t)vcgt_s32(v3, v5);
  int32x2_t v9 = vmul_s32(v7, v5);
  uint64_t v10 = vadd_s32(v9, vdup_lane_s32(v9, 1)).i32[0];
  int8x8_t v11 = vbsl_s8(v8, (int8x8_t)v7, *(int8x8_t *)(a1 + 24));
  int16x4_t v12 = *(int16x4_t *)(v6 + v10);
  v13.i64[0] = 0x8000000080000000;
  v13.i64[1] = 0x8000000080000000;
  int32x4_t v14 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v12), v13);
  int8x16_t v15 = (int8x16_t)vshll_n_u16((uint16x4_t)v12, 0xDuLL);
  int8x16_t v16 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v17 = (int8x16_t)vdupq_n_s32(0xF800000u);
  int32x4_t v18 = (int32x4_t)vorrq_s8(vandq_s8(v15, v17), vorrq_s8((int8x16_t)v14, vandq_s8(v15, v16)));
  v14.i64[0] = 0x3800000038000000;
  v14.i64[1] = 0x3800000038000000;
  float32x4_t v19 = (float32x4_t)vaddq_s32(v18, v14);
  uint64_t v20 = v10 + v11.i32[0];
  uint64_t v21 = v10 + v11.i32[1];
  uint64_t v22 = (int)v21 + (uint64_t)v11.i32[0];
  int16x4_t v23 = *(int16x4_t *)(v6 + v20);
  int8x16_t v24 = vandq_s8((int8x16_t)vmovl_s16(v23), v13);
  int8x16_t v25 = (int8x16_t)vshll_n_u16((uint16x4_t)v23, 0xDuLL);
  float32x4_t v26 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v25, v17), vorrq_s8(v24, vandq_s8(v25, v16))), v14);
  v24.i64[0] = *(void *)(v6 + v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v24.i8), v13);
  int8x16_t v28 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v24.i8, 0xDuLL);
  int32x4_t v29 = (int32x4_t)vorrq_s8(vandq_s8(v28, v17), vorrq_s8(v27, vandq_s8(v28, v16)));
  v27.i64[0] = *(void *)(v6 + v22);
  float32x4_t v30 = (float32x4_t)vaddq_s32(v29, v14);
  int8x16_t v31 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v27.i8), v13);
  int8x16_t v32 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v27.i8, 0xDuLL);
  float32x2_t v33 = vsub_f32(v4, vrnd_f32(v4));
  float32x4_t v34 = vmlaq_n_f32(v19, vsubq_f32(v26, v19), v33.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v34, vmlaq_n_f32(vsubq_f32(v30, v34), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v32, v17), vorrq_s8(v31, vandq_s8(v32, v16))), v14), v30), v33.f32[0]), v33, 1).u64[0];
  return result;
}

double sub_1B6417D44(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v3 = *(int32x2_t *)(a1 + 8);
  float32x2_t v4 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v5 = vmin_s32(vcvt_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = *(int32x2_t *)(a1 + 16);
  int8x8_t v8 = vbsl_s8((int8x8_t)vcgt_s32(v3, v5), (int8x8_t)v7, *(int8x8_t *)(a1 + 24));
  int32x2_t v9 = vmul_s32(v7, v5);
  uint64_t v10 = vadd_s32(v9, vdup_lane_s32(v9, 1)).i32[0];
  float32x2_t v11 = vsub_f32(v4, vrnd_f32(v4));
  float32x4_t v12 = vmlaq_n_f32(*(float32x4_t *)(v6 + v10), vsubq_f32(*(float32x4_t *)(v6 + v10 + v8.i32[0]), *(float32x4_t *)(v6 + v10)), v11.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v12, vmlaq_n_f32(vsubq_f32(*(float32x4_t *)(v6 + v10 + v8.i32[1]), v12), vsubq_f32(*(float32x4_t *)(v6 + (int)v10 + v8.i32[1] + (uint64_t)v8.i32[0]), *(float32x4_t *)(v6 + v10 + v8.i32[1])), v11.f32[0]), v11, 1).u64[0];
  return result;
}

double sub_1B6417DE0(uint64_t a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  float32x2_t v9 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v10 = *(int32x2_t *)(a1 + 8);
  float32x2_t v11 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v12 = vmin_s32(vcvt_s32_f32(v11), v10);
  uint64_t v13 = *(void *)(a1 + 32);
  int32x2_t v14 = *(int32x2_t *)(a1 + 16);
  int8x8_t v15 = (int8x8_t)vcgt_s32(v10, v12);
  int32x2_t v16 = vmul_s32(v14, v12);
  int32x2_t v17 = vdup_lane_s32(v16, 1);
  v16.i32[0] = vadd_s32(v16, v17).u32[0];
  uint64_t v18 = v16.i32[0];
  int32x2_t v19 = (int32x2_t)vbsl_s8(v15, (int8x8_t)v14, *(int8x8_t *)(a1 + 24));
  v16.i8[0] = *(unsigned char *)(v13 + v16.i32[0]);
  *(float *)v14.i32 = (float)v16.u32[0] * 0.0039216;
  __int32 v20 = v19.i32[0];
  uint64_t v21 = v18 + v19.i32[0];
  uint64_t v22 = v18 + v19.i32[1];
  v19.i8[0] = *(unsigned char *)(v13 + v21);
  v17.i8[0] = *(unsigned char *)(v13 + v22);
  *(float *)v17.i32 = (float)v17.u32[0] * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(v13 + (int)v22 + (uint64_t)v20);
  float32x2_t v23 = vsub_f32(v11, vrnd_f32(v11));
  *(float *)v19.i32 = -(float)(*(float *)v14.i32 - (float)((float)v19.u32[0] * 0.0039216));
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(v19, 0);
  float32x4_t v25 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), v24, v23.f32[0]);
  v24.f32[0] = -(float)(*(float *)v17.i32 - (float)((float)LODWORD(a9) * 0.0039216));
  *(void *)&double result = vmlaq_lane_f32(v25, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v17, 0), v25), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0), v23.f32[0]), v23, 1).u64[0];
  return result;
}

double sub_1B6417EAC(uint64_t a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  float32x2_t v9 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v10 = *(int32x2_t *)(a1 + 8);
  float32x2_t v11 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v12 = vmin_s32(vcvt_s32_f32(v11), v10);
  uint64_t v13 = *(void *)(a1 + 32);
  int32x2_t v14 = *(int32x2_t *)(a1 + 16);
  int8x8_t v15 = (int8x8_t)vcgt_s32(v10, v12);
  int32x2_t v16 = vmul_s32(v14, v12);
  int32x2_t v17 = vdup_lane_s32(v16, 1);
  v16.i32[0] = vadd_s32(v16, v17).u32[0];
  uint64_t v18 = v16.i32[0];
  int32x2_t v19 = (int32x2_t)vbsl_s8(v15, (int8x8_t)v14, *(int8x8_t *)(a1 + 24));
  v16.i8[0] = *(unsigned char *)(v13 + v16.i32[0]);
  *(float *)v14.i32 = (float)v16.u32[0] * 0.0039216;
  uint64_t v20 = v18 + v19.i32[0];
  uint64_t v21 = v18 + v19.i32[1];
  uint64_t v22 = (int)v21 + (uint64_t)v19.i32[0];
  v19.i8[0] = *(unsigned char *)(v13 + v20);
  v17.i8[0] = *(unsigned char *)(v13 + v21);
  *(float *)v17.i32 = (float)v17.u32[0] * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(v13 + v22);
  float32x2_t v23 = vsub_f32(v11, vrnd_f32(v11));
  *(float *)v19.i32 = -(float)(*(float *)v14.i32 - (float)((float)v19.u32[0] * 0.0039216));
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(v19, 0);
  float32x4_t v25 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), v24, v23.f32[0]);
  v24.f32[0] = -(float)(*(float *)v17.i32 - (float)((float)LODWORD(a9) * 0.0039216));
  float32x4_t v26 = vmlaq_lane_f32(v25, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v17, 0), v25), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0), v23.f32[0]), v23, 1);
  float32x4_t v27 = vmulq_f32(v26, v26);
  int32x4_t v28 = vcgeq_f32(v26, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v28.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v28), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v26), v27, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v26)), vmulq_f32(v27, v27), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v26), v27,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v26))), (int8x16_t)vmulq_f32(v26, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B641802C(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v3 = *(int32x2_t *)(a1 + 8);
  float32x2_t v4 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v5 = vmin_s32(vcvt_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = *(int32x2_t *)(a1 + 16);
  int8x8_t v8 = (int8x8_t)vcgt_s32(v3, v5);
  int32x2_t v9 = vmul_s32(v7, v5);
  uint64_t v10 = vadd_s32(v9, vdup_lane_s32(v9, 1)).i32[0];
  float32x2_t v11 = (const float *)(v6 + v10);
  uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
  int8x8_t v13 = vbsl_s8(v8, (int8x8_t)v7, *(int8x8_t *)(a1 + 24));
  v14.i64[0] = 0xFF000000FFLL;
  v14.i64[1] = 0xFF000000FFLL;
  float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v16 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  uint64_t v17 = v10 + v13.i32[0];
  uint64_t v18 = v10 + v13.i32[1];
  uint64_t v19 = (int)v18 + (uint64_t)v13.i32[0];
  uint64_t v20 = (const float *)(v6 + v17);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v20);
  uint64_t v22 = (const float *)(v6 + v18);
  uint32x4_t v23 = (uint32x4_t)vld1q_dup_f32(v22);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v23, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  float32x4_t v25 = (const float *)(v6 + v19);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x2_t v27 = vsub_f32(v4, vrnd_f32(v4));
  float32x4_t v28 = vmlaq_n_f32(v16, vmlaq_f32(vnegq_f32(v16), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), v14))), v27.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v28, vmlaq_n_f32(vsubq_f32(v24, v28), vmlaq_f32(vnegq_f32(v24), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v14))), v27.f32[0]), v27, 1).u64[0];
  return result;
}

double sub_1B6418130(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v3 = *(int32x2_t *)(a1 + 8);
  float32x2_t v4 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v5 = vmin_s32(vcvt_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = *(int32x2_t *)(a1 + 16);
  int8x8_t v8 = (int8x8_t)vcgt_s32(v3, v5);
  int32x2_t v9 = vmul_s32(v7, v5);
  int8x8_t v10 = vbsl_s8(v8, (int8x8_t)v7, *(int8x8_t *)(a1 + 24));
  uint64_t v11 = vadd_s32(v9, vdup_lane_s32(v9, 1)).i32[0];
  uint32x4_t v12 = (const float *)(v6 + v11);
  uint32x4_t v13 = (uint32x4_t)vld1q_dup_f32(v12);
  v14.i64[0] = 0xFF000000FFLL;
  v14.i64[1] = 0xFF000000FFLL;
  float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v16 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  uint64_t v17 = v11 + v10.i32[0];
  uint64_t v18 = v11 + v10.i32[1];
  uint64_t v19 = (int)v18 + (uint64_t)v10.i32[0];
  uint64_t v20 = (const float *)(v6 + v17);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v20);
  uint64_t v22 = (const float *)(v6 + v18);
  uint32x4_t v23 = (uint32x4_t)vld1q_dup_f32(v22);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v23, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  float32x4_t v25 = (const float *)(v6 + v19);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x2_t v27 = vsub_f32(v4, vrnd_f32(v4));
  float32x4_t v28 = vmlaq_n_f32(v16, vmlaq_f32(vnegq_f32(v16), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), v14))), v27.f32[0]);
  float32x4_t v29 = vmlaq_lane_f32(v28, vmlaq_n_f32(vsubq_f32(v24, v28), vmlaq_f32(vnegq_f32(v24), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v14))), v27.f32[0]), v27, 1);
  float32x4_t v30 = vmulq_f32(v29, v29);
  int32x4_t v31 = vcgeq_f32(v29, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v31.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v31), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v29), v30, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v29)), vmulq_f32(v30, v30), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v29), v30,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v29))), (int8x16_t)vmulq_f32(v29, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B64182E8(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v3 = *(int32x2_t *)(a1 + 8);
  float32x2_t v4 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v5 = vmin_s32(vcvt_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = *(int32x2_t *)(a1 + 16);
  int8x8_t v8 = (int8x8_t)vcgt_s32(v3, v5);
  int32x2_t v9 = vmul_s32(v7, v5);
  uint64_t v10 = vadd_s32(v9, vdup_lane_s32(v9, 1)).i32[0];
  int8x8_t v11 = vbsl_s8(v8, (int8x8_t)v7, *(int8x8_t *)(a1 + 24));
  uint32x4_t v12 = (const float *)(v6 + v10);
  uint32x4_t v13 = (uint32x4_t)vld1q_dup_f32(v12);
  v14.i64[0] = 0xFF000000FFLL;
  v14.i64[1] = 0xFF000000FFLL;
  float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v16 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  __int32 v17 = v11.i32[0];
  uint64_t v18 = v10 + v11.i32[0];
  uint64_t v19 = v10 + v11.i32[1];
  uint64_t v20 = (const float *)(v6 + v18);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v20);
  uint64_t v22 = (int)v19 + (uint64_t)v17;
  uint32x4_t v23 = (const float *)(v6 + v19);
  uint32x4_t v24 = (uint32x4_t)vld1q_dup_f32(v23);
  float32x4_t v25 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v24, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  uint32x4_t v26 = (const float *)(v6 + v22);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v26);
  float32x2_t v28 = vsub_f32(v4, vrnd_f32(v4));
  float32x4_t v29 = vmlaq_n_f32(v16, vmlaq_f32(vnegq_f32(v16), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), v14))), v28.f32[0]);
  int8x16_t v30 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_lane_f32(v29, vmlaq_n_f32(vsubq_f32(v25, v29), vmlaq_f32(vnegq_f32(v25), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v14))), v28.f32[0]), v28, 1));
  *(void *)&double result = vextq_s8(v30, v30, 0xCuLL).u64[0];
  return result;
}

double sub_1B64183F4(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vsub_f32(a2, *(float32x2_t *)(a1 + 48));
  int32x2_t v3 = *(int32x2_t *)(a1 + 8);
  float32x2_t v4 = vmul_f32(*(float32x2_t *)a1, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v5 = vmin_s32(vcvt_s32_f32(v4), v3);
  uint64_t v6 = *(void *)(a1 + 32);
  int32x2_t v7 = *(int32x2_t *)(a1 + 16);
  int8x8_t v8 = vbsl_s8((int8x8_t)vcgt_s32(v3, v5), (int8x8_t)v7, *(int8x8_t *)(a1 + 24));
  int32x2_t v9 = vmul_s32(v7, v5);
  uint64_t v10 = vadd_s32(v9, vdup_lane_s32(v9, 1)).i32[0];
  int8x8_t v11 = (const float *)(v6 + v10);
  uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
  v13.i64[0] = 0xFF000000FFLL;
  v13.i64[1] = 0xFF000000FFLL;
  float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
  uint64_t v16 = v10 + v8.i32[0];
  uint64_t v17 = v10 + v8.i32[1];
  uint64_t v18 = (int)v17 + (uint64_t)v8.i32[0];
  uint64_t v19 = (const float *)(v6 + v16);
  uint32x4_t v20 = (uint32x4_t)vld1q_dup_f32(v19);
  uint32x4_t v21 = (const float *)(v6 + v17);
  uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v21);
  float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
  uint32x4_t v24 = (const float *)(v6 + v18);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v24);
  float32x2_t v26 = vsub_f32(v4, vrnd_f32(v4));
  float32x4_t v27 = vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v20, (uint32x4_t)xmmword_1B6E50360), v13))), v26.f32[0]);
  float32x4_t v28 = vmlaq_lane_f32(v27, vmlaq_n_f32(vsubq_f32(v23, v27), vmlaq_f32(vnegq_f32(v23), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), v13))), v26.f32[0]), v26, 1);
  float32x4_t v29 = vmulq_f32(v28, v28);
  int32x4_t v30 = vcgeq_f32(v28, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v30.i32[3] = 0;
  int32x4_t v31 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v30), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v28), v29, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v28)), vmulq_f32(v29, v29), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v28), v29,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v28))), (int8x16_t)vmulq_f32(v28, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v31.i32[3] = v28.i32[3];
  int8x16_t v32 = (int8x16_t)vrev64q_s32(v31);
  *(void *)&double result = vextq_s8(v32, v32, 0xCuLL).u64[0];
  return result;
}

double sub_1B64185B4(uint64_t a1, float32x2_t a2, double a3, float32x4_t a4, double a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  float32x2_t v8 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v9 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v10 = *(int32x2_t *)(a1 + 8);
  float32x2_t v11 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v9, v9));
  int32x2_t v12 = vmin_s32(vcvt_s32_f32(v11), v10);
  uint64_t v13 = *(void *)(a1 + 32);
  a6.i64[0] = *(void *)(a1 + 16);
  *(int8x8_t *)a4.f32 = vbsl_s8((int8x8_t)vcgt_s32(v10, v12), *(int8x8_t *)a6.f32, *(int8x8_t *)(a1 + 24));
  int32x2_t v14 = vmul_s32(*(int32x2_t *)a6.f32, v12);
  signed __int32 v15 = vadd_s32(v14, vdup_lane_s32(v14, 1)).u32[0];
  unsigned int v16 = *(unsigned __int16 *)(v13 + v15);
  int v17 = (v16 >> 10) & 0x1F;
  if (v17 == 31) {
    int v18 = 2139095040;
  }
  else {
    int v18 = (v16 >> 10) & 0x1F;
  }
  if (v17) {
    BOOL v19 = v17 == 31;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19) {
    int v20 = v18;
  }
  else {
    int v20 = (v17 << 23) + 939524096;
  }
  uint64_t v21 = v15 + (uint64_t)a4.i32[1];
  uint64_t v22 = (int)v21 + (uint64_t)a4.i32[0];
  unsigned int v23 = *(unsigned __int16 *)(v13 + v15 + (uint64_t)a4.i32[0]);
  int v24 = (v23 >> 10) & 0x1F;
  if (v24 == 31) {
    int v25 = 2139095040;
  }
  else {
    int v25 = (v23 >> 10) & 0x1F;
  }
  if (v24) {
    BOOL v26 = v24 == 31;
  }
  else {
    BOOL v26 = 1;
  }
  if (v26) {
    int v27 = v25;
  }
  else {
    int v27 = (v24 << 23) + 939524096;
  }
  unsigned int v28 = *(unsigned __int16 *)(v13 + v21);
  int v29 = (v28 >> 10) & 0x1F;
  if (v29 == 31) {
    int v30 = 2139095040;
  }
  else {
    int v30 = (v28 >> 10) & 0x1F;
  }
  if (v29) {
    BOOL v31 = v29 == 31;
  }
  else {
    BOOL v31 = 1;
  }
  if (v31) {
    int v32 = v30;
  }
  else {
    int v32 = (v29 << 23) + 939524096;
  }
  unsigned int v33 = *(unsigned __int16 *)(v13 + v22);
  int v34 = (v33 >> 10) & 0x1F;
  if (v34 == 31) {
    int v35 = 2139095040;
  }
  else {
    int v35 = (v33 >> 10) & 0x1F;
  }
  if (v34) {
    BOOL v36 = v34 == 31;
  }
  else {
    BOOL v36 = 1;
  }
  if (!v36) {
    int v35 = (v34 << 23) + 939524096;
  }
  a4.i32[0] = v32 | (v28 << 16) & 0x80000000 | (v28 >> 7) & 7 | (8 * (v28 & 0x3FF)) & 0x1FFF | ((v28 & 0x3FF) << 13);
  a6.i32[0] = v27 | (v23 << 16) & 0x80000000 | (v23 >> 7) & 7 | (8 * (v23 & 0x3FF)) & 0x1FFF | ((v23 & 0x3FF) << 13);
  a7.i32[0] = v20 | (v16 << 16) & 0x80000000 | (v16 >> 7) & 7 | (8 * (v16 & 0x3FF)) & 0x1FFF | ((v16 & 0x3FF) << 13);
  a8.i32[0] = v35 | (v33 << 16) & 0x80000000 | (v33 >> 7) & 7 | (8 * (v33 & 0x3FF)) & 0x1FFF | ((v33 & 0x3FF) << 13);
  float32x2_t v37 = vsub_f32(v11, vrnd_f32(v11));
  float32x4_t v38 = (float32x4_t)vdupq_lane_s32((int32x2_t)v37, 0);
  float32x4_t v39 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 0), v38, vsubq_f32(a6, a7).f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v39, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0), v39), v38, vsubq_f32(a8, a4).f32[0]), v37, 1).u64[0];
  return result;
}

double sub_1B6418778(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = *(int32x2_t *)(a1 + 8);
  float32x2_t v5 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3));
  int32x2_t v6 = vmin_s32(vcvt_s32_f32(v5), v4);
  uint64_t v7 = *(void *)(a1 + 32);
  int32x2_t v8 = *(int32x2_t *)(a1 + 16);
  int32x2_t v9 = (int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v4, v6), (int8x8_t)v8, *(int8x8_t *)(a1 + 24));
  int32x2_t v10 = vmul_s32(v8, v6);
  int32x2_t v11 = vdup_lane_s32(v10, 1);
  uint64_t v12 = vadd_s32(v10, v11).i32[0];
  v11.i32[0] = *(_DWORD *)(v7 + v12);
  uint64_t v13 = v12 + v9.i32[0];
  uint64_t v14 = v12 + v9.i32[1];
  v8.i32[0] = *(_DWORD *)(v7 + v14);
  float v15 = *(float *)(v7 + (int)v14 + (uint64_t)v9.i32[0]);
  float32x2_t v16 = vsub_f32(v5, vrnd_f32(v5));
  *(float *)v9.i32 = *(float *)(v7 + v13) - *(float *)v11.i32;
  float32x4_t v17 = (float32x4_t)vdupq_lane_s32(v9, 0);
  float32x4_t v18 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v11, 0), v17, v16.f32[0]);
  v17.f32[0] = v15 - *(float *)v8.i32;
  *(void *)&double result = vmlaq_lane_f32(v18, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v8, 0), v18), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 0), v16.f32[0]), v16, 1).u64[0];
  return result;
}

double sub_1B6418838(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = *(int32x2_t *)(a1 + 8);
  float32x2_t v5 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3));
  int32x2_t v6 = vmin_s32(vcvt_s32_f32(v5), v4);
  uint64_t v7 = *(void *)(a1 + 32);
  int32x2_t v8 = *(int32x2_t *)(a1 + 16);
  int8x8_t v9 = (int8x8_t)vcgt_s32(v4, v6);
  int32x2_t v10 = vmul_s32(v8, v6);
  uint64_t v11 = vadd_s32(v10, vdup_lane_s32(v10, 1)).i32[0];
  int8x8_t v12 = vbsl_s8(v9, (int8x8_t)v8, *(int8x8_t *)(a1 + 24));
  int16x4_t v13 = *(int16x4_t *)(v7 + v11);
  v14.i64[0] = 0x8000000080000000;
  v14.i64[1] = 0x8000000080000000;
  int32x4_t v15 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v13), v14);
  int8x16_t v16 = (int8x16_t)vshll_n_u16((uint16x4_t)v13, 0xDuLL);
  int8x16_t v17 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v18 = (int8x16_t)vdupq_n_s32(0xF800000u);
  int32x4_t v19 = (int32x4_t)vorrq_s8(vandq_s8(v16, v18), vorrq_s8((int8x16_t)v15, vandq_s8(v16, v17)));
  v15.i64[0] = 0x3800000038000000;
  v15.i64[1] = 0x3800000038000000;
  float32x4_t v20 = (float32x4_t)vaddq_s32(v19, v15);
  uint64_t v21 = v11 + v12.i32[0];
  uint64_t v22 = v11 + v12.i32[1];
  uint64_t v23 = (int)v22 + (uint64_t)v12.i32[0];
  int16x4_t v24 = *(int16x4_t *)(v7 + v21);
  int8x16_t v25 = vandq_s8((int8x16_t)vmovl_s16(v24), v14);
  int8x16_t v26 = (int8x16_t)vshll_n_u16((uint16x4_t)v24, 0xDuLL);
  float32x4_t v27 = (float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v26, v18), vorrq_s8(v25, vandq_s8(v26, v17))), v15);
  v25.i64[0] = *(void *)(v7 + v22);
  int8x16_t v28 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v25.i8), v14);
  int8x16_t v29 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v25.i8, 0xDuLL);
  int32x4_t v30 = (int32x4_t)vorrq_s8(vandq_s8(v29, v18), vorrq_s8(v28, vandq_s8(v29, v17)));
  v28.i64[0] = *(void *)(v7 + v23);
  float32x4_t v31 = (float32x4_t)vaddq_s32(v30, v15);
  int8x16_t v32 = vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v28.i8), v14);
  int8x16_t v33 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v28.i8, 0xDuLL);
  float32x2_t v34 = vsub_f32(v5, vrnd_f32(v5));
  float32x4_t v35 = vmlaq_n_f32(v20, vsubq_f32(v27, v20), v34.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v35, vmlaq_n_f32(vsubq_f32(v31, v35), vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v33, v18), vorrq_s8(v32, vandq_s8(v33, v17))), v15), v31), v34.f32[0]), v34, 1).u64[0];
  return result;
}

double sub_1B6418980(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = *(int32x2_t *)(a1 + 8);
  float32x2_t v5 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3));
  int32x2_t v6 = vmin_s32(vcvt_s32_f32(v5), v4);
  uint64_t v7 = *(void *)(a1 + 32);
  int32x2_t v8 = *(int32x2_t *)(a1 + 16);
  int8x8_t v9 = vbsl_s8((int8x8_t)vcgt_s32(v4, v6), (int8x8_t)v8, *(int8x8_t *)(a1 + 24));
  int32x2_t v10 = vmul_s32(v8, v6);
  uint64_t v11 = vadd_s32(v10, vdup_lane_s32(v10, 1)).i32[0];
  float32x2_t v12 = vsub_f32(v5, vrnd_f32(v5));
  float32x4_t v13 = vmlaq_n_f32(*(float32x4_t *)(v7 + v11), vsubq_f32(*(float32x4_t *)(v7 + v11 + v9.i32[0]), *(float32x4_t *)(v7 + v11)), v12.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v13, vmlaq_n_f32(vsubq_f32(*(float32x4_t *)(v7 + v11 + v9.i32[1]), v13), vsubq_f32(*(float32x4_t *)(v7 + (int)v11 + v9.i32[1] + (uint64_t)v9.i32[0]), *(float32x4_t *)(v7 + v11 + v9.i32[1])), v12.f32[0]), v12, 1).u64[0];
  return result;
}

double sub_1B6418A30(uint64_t a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  float32x2_t v9 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v10 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v11 = *(int32x2_t *)(a1 + 8);
  float32x2_t v12 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v10, v10));
  int32x2_t v13 = vmin_s32(vcvt_s32_f32(v12), v11);
  uint64_t v14 = *(void *)(a1 + 32);
  int32x2_t v15 = *(int32x2_t *)(a1 + 16);
  int8x8_t v16 = (int8x8_t)vcgt_s32(v11, v13);
  int32x2_t v17 = vmul_s32(v15, v13);
  int32x2_t v18 = vdup_lane_s32(v17, 1);
  v17.i32[0] = vadd_s32(v17, v18).u32[0];
  uint64_t v19 = v17.i32[0];
  int32x2_t v20 = (int32x2_t)vbsl_s8(v16, (int8x8_t)v15, *(int8x8_t *)(a1 + 24));
  v17.i8[0] = *(unsigned char *)(v14 + v17.i32[0]);
  *(float *)v15.i32 = (float)v17.u32[0] * 0.0039216;
  __int32 v21 = v20.i32[0];
  uint64_t v22 = v19 + v20.i32[0];
  uint64_t v23 = v19 + v20.i32[1];
  v20.i8[0] = *(unsigned char *)(v14 + v22);
  v18.i8[0] = *(unsigned char *)(v14 + v23);
  *(float *)v18.i32 = (float)v18.u32[0] * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(v14 + (int)v23 + (uint64_t)v21);
  float32x2_t v24 = vsub_f32(v12, vrnd_f32(v12));
  *(float *)v20.i32 = -(float)(*(float *)v15.i32 - (float)((float)v20.u32[0] * 0.0039216));
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(v20, 0);
  float32x4_t v26 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v15, 0), v25, v24.f32[0]);
  v25.f32[0] = -(float)(*(float *)v18.i32 - (float)((float)LODWORD(a9) * 0.0039216));
  *(void *)&double result = vmlaq_lane_f32(v26, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v18, 0), v26), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0), v24.f32[0]), v24, 1).u64[0];
  return result;
}

double sub_1B6418B10(uint64_t a1, float32x2_t a2, double a3, double a4, double a5, double a6, double a7, double a8, float a9)
{
  float32x2_t v9 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v10 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v11 = *(int32x2_t *)(a1 + 8);
  float32x2_t v12 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v10, v10));
  int32x2_t v13 = vmin_s32(vcvt_s32_f32(v12), v11);
  uint64_t v14 = *(void *)(a1 + 32);
  int32x2_t v15 = *(int32x2_t *)(a1 + 16);
  int8x8_t v16 = (int8x8_t)vcgt_s32(v11, v13);
  int32x2_t v17 = vmul_s32(v15, v13);
  int32x2_t v18 = vdup_lane_s32(v17, 1);
  v17.i32[0] = vadd_s32(v17, v18).u32[0];
  uint64_t v19 = v17.i32[0];
  int32x2_t v20 = (int32x2_t)vbsl_s8(v16, (int8x8_t)v15, *(int8x8_t *)(a1 + 24));
  v17.i8[0] = *(unsigned char *)(v14 + v17.i32[0]);
  *(float *)v15.i32 = (float)v17.u32[0] * 0.0039216;
  uint64_t v21 = v19 + v20.i32[0];
  uint64_t v22 = v19 + v20.i32[1];
  uint64_t v23 = (int)v22 + (uint64_t)v20.i32[0];
  v20.i8[0] = *(unsigned char *)(v14 + v21);
  v18.i8[0] = *(unsigned char *)(v14 + v22);
  *(float *)v18.i32 = (float)v18.u32[0] * 0.0039216;
  LOBYTE(a9) = *(unsigned char *)(v14 + v23);
  float32x2_t v24 = vsub_f32(v12, vrnd_f32(v12));
  *(float *)v20.i32 = -(float)(*(float *)v15.i32 - (float)((float)v20.u32[0] * 0.0039216));
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(v20, 0);
  float32x4_t v26 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v15, 0), v25, v24.f32[0]);
  v25.f32[0] = -(float)(*(float *)v18.i32 - (float)((float)LODWORD(a9) * 0.0039216));
  float32x4_t v27 = vmlaq_lane_f32(v26, vmlaq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v18, 0), v26), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0), v24.f32[0]), v24, 1);
  float32x4_t v28 = vmulq_f32(v27, v27);
  int32x4_t v29 = vcgeq_f32(v27, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v29.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v29), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v27), v28, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v27)), vmulq_f32(v28, v28), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v27), v28,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v27))), (int8x16_t)vmulq_f32(v27, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6418CA4(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = *(int32x2_t *)(a1 + 8);
  float32x2_t v5 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3));
  int32x2_t v6 = vmin_s32(vcvt_s32_f32(v5), v4);
  uint64_t v7 = *(void *)(a1 + 32);
  int32x2_t v8 = *(int32x2_t *)(a1 + 16);
  int8x8_t v9 = (int8x8_t)vcgt_s32(v4, v6);
  int32x2_t v10 = vmul_s32(v8, v6);
  uint64_t v11 = vadd_s32(v10, vdup_lane_s32(v10, 1)).i32[0];
  float32x2_t v12 = (const float *)(v7 + v11);
  uint32x4_t v13 = (uint32x4_t)vld1q_dup_f32(v12);
  int8x8_t v14 = vbsl_s8(v9, (int8x8_t)v8, *(int8x8_t *)(a1 + 24));
  v15.i64[0] = 0xFF000000FFLL;
  v15.i64[1] = 0xFF000000FFLL;
  float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v17 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B6E50360), v15)), v16);
  uint64_t v18 = v11 + v14.i32[0];
  uint64_t v19 = v11 + v14.i32[1];
  uint64_t v20 = (int)v19 + (uint64_t)v14.i32[0];
  uint64_t v21 = (const float *)(v7 + v18);
  uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v21);
  uint64_t v23 = (const float *)(v7 + v19);
  uint32x4_t v24 = (uint32x4_t)vld1q_dup_f32(v23);
  float32x4_t v25 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v24, (uint32x4_t)xmmword_1B6E50360), v15)), v16);
  float32x4_t v26 = (const float *)(v7 + v20);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v26);
  float32x2_t v28 = vsub_f32(v5, vrnd_f32(v5));
  float32x4_t v29 = vmlaq_n_f32(v17, vmlaq_f32(vnegq_f32(v17), v16, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B6E50360), v15))), v28.f32[0]);
  *(void *)&double result = vmlaq_lane_f32(v29, vmlaq_n_f32(vsubq_f32(v25, v29), vmlaq_f32(vnegq_f32(v25), v16, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v15))), v28.f32[0]), v28, 1).u64[0];
  return result;
}

double sub_1B6418DBC(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = *(int32x2_t *)(a1 + 8);
  float32x2_t v5 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3));
  int32x2_t v6 = vmin_s32(vcvt_s32_f32(v5), v4);
  uint64_t v7 = *(void *)(a1 + 32);
  int32x2_t v8 = *(int32x2_t *)(a1 + 16);
  int8x8_t v9 = (int8x8_t)vcgt_s32(v4, v6);
  int32x2_t v10 = vmul_s32(v8, v6);
  int8x8_t v11 = vbsl_s8(v9, (int8x8_t)v8, *(int8x8_t *)(a1 + 24));
  uint64_t v12 = vadd_s32(v10, vdup_lane_s32(v10, 1)).i32[0];
  uint32x4_t v13 = (const float *)(v7 + v12);
  uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(v13);
  v15.i64[0] = 0xFF000000FFLL;
  v15.i64[1] = 0xFF000000FFLL;
  float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v17 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_1B6E50360), v15)), v16);
  uint64_t v18 = v12 + v11.i32[0];
  uint64_t v19 = v12 + v11.i32[1];
  uint64_t v20 = (int)v19 + (uint64_t)v11.i32[0];
  uint64_t v21 = (const float *)(v7 + v18);
  uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v21);
  uint64_t v23 = (const float *)(v7 + v19);
  uint32x4_t v24 = (uint32x4_t)vld1q_dup_f32(v23);
  float32x4_t v25 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v24, (uint32x4_t)xmmword_1B6E50360), v15)), v16);
  float32x4_t v26 = (const float *)(v7 + v20);
  uint32x4_t v27 = (uint32x4_t)vld1q_dup_f32(v26);
  float32x2_t v28 = vsub_f32(v5, vrnd_f32(v5));
  float32x4_t v29 = vmlaq_n_f32(v17, vmlaq_f32(vnegq_f32(v17), v16, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B6E50360), v15))), v28.f32[0]);
  float32x4_t v30 = vmlaq_lane_f32(v29, vmlaq_n_f32(vsubq_f32(v25, v29), vmlaq_f32(vnegq_f32(v25), v16, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v27, (uint32x4_t)xmmword_1B6E50360), v15))), v28.f32[0]), v28, 1);
  float32x4_t v31 = vmulq_f32(v30, v30);
  int32x4_t v32 = vcgeq_f32(v30, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v32.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v32), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v30), v31, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v30)), vmulq_f32(v31, v31), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v30), v31,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v30))), (int8x16_t)vmulq_f32(v30, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B6418F88(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = *(int32x2_t *)(a1 + 8);
  float32x2_t v5 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3));
  int32x2_t v6 = vmin_s32(vcvt_s32_f32(v5), v4);
  uint64_t v7 = *(void *)(a1 + 32);
  int32x2_t v8 = *(int32x2_t *)(a1 + 16);
  int8x8_t v9 = (int8x8_t)vcgt_s32(v4, v6);
  int32x2_t v10 = vmul_s32(v8, v6);
  uint64_t v11 = vadd_s32(v10, vdup_lane_s32(v10, 1)).i32[0];
  int8x8_t v12 = vbsl_s8(v9, (int8x8_t)v8, *(int8x8_t *)(a1 + 24));
  uint32x4_t v13 = (const float *)(v7 + v11);
  uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(v13);
  v15.i64[0] = 0xFF000000FFLL;
  v15.i64[1] = 0xFF000000FFLL;
  float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v17 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_1B6E50360), v15)), v16);
  __int32 v18 = v12.i32[0];
  uint64_t v19 = v11 + v12.i32[0];
  uint64_t v20 = v11 + v12.i32[1];
  uint64_t v21 = (const float *)(v7 + v19);
  uint32x4_t v22 = (uint32x4_t)vld1q_dup_f32(v21);
  uint64_t v23 = (int)v20 + (uint64_t)v18;
  uint32x4_t v24 = (const float *)(v7 + v20);
  uint32x4_t v25 = (uint32x4_t)vld1q_dup_f32(v24);
  float32x4_t v26 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v25, (uint32x4_t)xmmword_1B6E50360), v15)), v16);
  uint32x4_t v27 = (const float *)(v7 + v23);
  uint32x4_t v28 = (uint32x4_t)vld1q_dup_f32(v27);
  float32x2_t v29 = vsub_f32(v5, vrnd_f32(v5));
  float32x4_t v30 = vmlaq_n_f32(v17, vmlaq_f32(vnegq_f32(v17), v16, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B6E50360), v15))), v29.f32[0]);
  int8x16_t v31 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_lane_f32(v30, vmlaq_n_f32(vsubq_f32(v26, v30), vmlaq_f32(vnegq_f32(v26), v16, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v28, (uint32x4_t)xmmword_1B6E50360), v15))), v29.f32[0]), v29, 1));
  *(void *)&double result = vextq_s8(v31, v31, 0xCuLL).u64[0];
  return result;
}

double sub_1B64190A8(uint64_t a1, float32x2_t a2)
{
  float32x2_t v2 = vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x3F0000003F000000, vsub_f32(a2, *(float32x2_t *)(a1 + 48)));
  float32x2_t v3 = vabd_f32((float32x2_t)0x3F0000003F000000, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)));
  int32x2_t v4 = *(int32x2_t *)(a1 + 8);
  float32x2_t v5 = vmul_f32(*(float32x2_t *)a1, vadd_f32(v3, v3));
  int32x2_t v6 = vmin_s32(vcvt_s32_f32(v5), v4);
  uint64_t v7 = *(void *)(a1 + 32);
  int32x2_t v8 = *(int32x2_t *)(a1 + 16);
  int8x8_t v9 = vbsl_s8((int8x8_t)vcgt_s32(v4, v6), (int8x8_t)v8, *(int8x8_t *)(a1 + 24));
  int32x2_t v10 = vmul_s32(v8, v6);
  uint64_t v11 = vadd_s32(v10, vdup_lane_s32(v10, 1)).i32[0];
  int8x8_t v12 = (const float *)(v7 + v11);
  uint32x4_t v13 = (uint32x4_t)vld1q_dup_f32(v12);
  v14.i64[0] = 0xFF000000FFLL;
  v14.i64[1] = 0xFF000000FFLL;
  float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v16 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  uint64_t v17 = v11 + v9.i32[0];
  uint64_t v18 = v11 + v9.i32[1];
  uint64_t v19 = (int)v18 + (uint64_t)v9.i32[0];
  uint64_t v20 = (const float *)(v7 + v17);
  uint32x4_t v21 = (uint32x4_t)vld1q_dup_f32(v20);
  uint32x4_t v22 = (const float *)(v7 + v18);
  uint32x4_t v23 = (uint32x4_t)vld1q_dup_f32(v22);
  float32x4_t v24 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v23, (uint32x4_t)xmmword_1B6E50360), v14)), v15);
  uint32x4_t v25 = (const float *)(v7 + v19);
  uint32x4_t v26 = (uint32x4_t)vld1q_dup_f32(v25);
  float32x2_t v27 = vsub_f32(v5, vrnd_f32(v5));
  float32x4_t v28 = vmlaq_n_f32(v16, vmlaq_f32(vnegq_f32(v16), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v21, (uint32x4_t)xmmword_1B6E50360), v14))), v27.f32[0]);
  float32x4_t v29 = vmlaq_lane_f32(v28, vmlaq_n_f32(vsubq_f32(v24, v28), vmlaq_f32(vnegq_f32(v24), v15, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v26, (uint32x4_t)xmmword_1B6E50360), v14))), v27.f32[0]), v27, 1);
  float32x4_t v30 = vmulq_f32(v29, v29);
  int32x4_t v31 = vcgeq_f32(v29, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v31.i32[3] = 0;
  int32x4_t v32 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v31), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v29), v30, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v29)), vmulq_f32(v30, v30), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v29), v30,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v29))), (int8x16_t)vmulq_f32(v29, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v32.i32[3] = v29.i32[3];
  int8x16_t v33 = (int8x16_t)vrev64q_s32(v32);
  *(void *)&double result = vextq_s8(v33, v33, 0xCuLL).u64[0];
  return result;
}

float32x2_t vfx_sampler2d_make@<D0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>, int32x2_t a6@<D0>)
{
  uint64_t v6 = a2 - 1;
  if (v6 > 9) {
    unsigned int v7 = 2;
  }
  else {
    unsigned int v7 = dword_1B6E503B0[v6];
  }
  float32x2_t v8 = vcvt_f32_s32(a6);
  *(float32x2_t *)a5 = v8;
  *(int32x2_t *)(a5 + 8) = vadd_s32(a6, (int32x2_t)-1);
  int32x2_t v9 = vzip1_s32((int32x2_t)0x100000001, a6);
  v10.i32[0] = 1;
  v10.i32[1] = 1 - a6.i32[1];
  v11.i32[0] = vsub_s32((int32x2_t)0x100000001, a6).u32[0];
  int32x2_t v12 = vmul_n_s32(v10, a6.i32[0]);
  int32x2_t v13 = vdup_n_s32(v7);
  v11.i32[1] = v12.i32[1];
  uint64_t v14 = (uint64_t)*(&off_1F0FBA608 + 40 * a4 + 10 * a3 + a2);
  *(int32x2_t *)(a5 + 16) = vmul_s32(v13, v9);
  *(int32x2_t *)(a5 + 24) = vmul_s32(v13, v11);
  *(void *)(a5 + 32) = a1;
  *(void *)(a5 + 40) = v14;
  float32x2_t result = vdiv_f32((float32x2_t)0x3F0000003F000000, v8);
  *(float32x2_t *)(a5 + 48) = result;
  return result;
}

int32x2_t sub_1B641931C(uint64_t a1, float a2)
{
  *(double *)&int32x2_t result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    unsigned int v5 = *(unsigned __int16 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    int v6 = (v5 >> 10) & 0x1F;
    if (v6 == 31) {
      int v7 = 2139095040;
    }
    else {
      int v7 = (v5 >> 10) & 0x1F;
    }
    if (v6) {
      BOOL v8 = v6 == 31;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8) {
      int v9 = v7;
    }
    else {
      int v9 = (v6 << 23) + 939524096;
    }
    result.i32[0] = v9 | (v5 << 16) & 0x80000000 | (v5 >> 7) & 7 | (8 * (v5 & 0x3FF)) & 0x1FFF | ((v5 & 0x3FF) << 13);
    return (int32x2_t)vdupq_lane_s32(result, 0).u64[0];
  }
  return result;
}

double sub_1B64193B0(uint64_t a1, float a2)
{
  double result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    unsigned int v5 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    *(void *)&double result = vld1q_dup_f32(v5).u64[0];
  }
  return result;
}

double sub_1B64193F8(uint64_t a1, float a2)
{
  double result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    int16x4_t v5 = *(int16x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    v6.i64[0] = 0x8000000080000000;
    v6.i64[1] = 0x8000000080000000;
    int32x4_t v7 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v5), v6);
    int8x16_t v8 = (int8x16_t)vshll_n_u16((uint16x4_t)v5, 0xDuLL);
    int32x4_t v9 = (int32x4_t)vorrq_s8(vandq_s8(v8, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v7, vandq_s8(v8, (int8x16_t)vdupq_n_s32(0x7FE000u))));
    v7.i64[0] = 0x3800000038000000;
    v7.i64[1] = 0x3800000038000000;
    *(void *)&double result = vaddq_s32(v9, v7).u64[0];
  }
  return result;
}

__n128 sub_1B6419478(uint64_t a1, float a2)
{
  result.n128_u64[0] = 0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    return *(__n128 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
  }
  return result;
}

__n64 sub_1B64194C0(uint64_t a1, float a2)
{
  result.n64_u64[0] = 0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    result.n64_f32[0] = *(float *)a1 * a2;
    int v4 = (int)result.n64_f32[0];
    if ((int)result.n64_f32[0] >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    result.n64_u8[0] = *(unsigned char *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    result.n64_f32[0] = (float)result.n64_u32[0] * 0.0039216;
    return (__n64)vdupq_lane_s32((int32x2_t)result.n64_u64[0], 0).u64[0];
  }
  return result;
}

double sub_1B641951C(uint64_t a1, float a2, double a3)
{
  double result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    float v5 = *(float *)a1 * a2;
    int v6 = (int)v5;
    if ((int)v5 >= *(_DWORD *)(a1 + 4)) {
      int v6 = *(_DWORD *)(a1 + 4);
    }
    LOBYTE(v5) = *(unsigned char *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v6);
    *(float *)&a3 = (float)LODWORD(v5) * 0.0039216;
    int32x4_t v7 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
    v7.i32[3] = 0;
    *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v7), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)&a3), *(float *)&a3 * *(float *)&a3), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                            (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                            *(float *)&a3),
                                          *(float *)&a3 * *(float *)&a3),
                                        (float)(*(float *)&a3 * *(float *)&a3) * (float)(*(float *)&a3 * *(float *)&a3)),
                           (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)&a3)).u64[0];
  }
  return result;
}

double sub_1B641962C(uint64_t a1, float a2)
{
  double result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    float v5 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
    v7.i64[0] = 0xFF000000FFLL;
    v7.i64[1] = 0xFF000000FFLL;
    *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  }
  return result;
}

double sub_1B641969C(uint64_t a1, float a2)
{
  double result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    float v5 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
    v7.i64[0] = 0xFF000000FFLL;
    v7.i64[1] = 0xFF000000FFLL;
    float32x4_t v8 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7));
    float32x4_t v9 = vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x3B808081u));
    float32x4_t v10 = vmulq_f32(v9, v9);
    float32x4_t v11 = vmulq_f32(v10, v10);
    float32x4_t v12 = vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v8), v10, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v8));
    float32x4_t v13 = vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v8), v10, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v8));
    int32x4_t v14 = vcgeq_f32(v9, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
    v14.i32[3] = 0;
    *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v14), (int8x16_t)vmlaq_f32(v13, v11, v12), (int8x16_t)vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  }
  return result;
}

double sub_1B64197B0(uint64_t a1, float a2)
{
  double result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    float v5 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
    v7.i64[0] = 0xFF000000FFLL;
    v7.i64[1] = 0xFF000000FFLL;
    int8x16_t v8 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
    *(void *)&double result = vextq_s8(v8, v8, 0xCuLL).u64[0];
  }
  return result;
}

double sub_1B6419828(uint64_t a1, float a2)
{
  double result = 0.0;
  if (a2 < 1.0 && a2 >= 0.0)
  {
    int v4 = (int)(float)(*(float *)a1 * a2);
    if (v4 >= *(_DWORD *)(a1 + 4)) {
      int v4 = *(_DWORD *)(a1 + 4);
    }
    float v5 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
    uint32x4_t v6 = (uint32x4_t)vld1q_dup_f32(v5);
    v7.i64[0] = 0xFF000000FFLL;
    v7.i64[1] = 0xFF000000FFLL;
    float32x4_t v8 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v6, (uint32x4_t)xmmword_1B6E50360), v7));
    float32x4_t v9 = vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x3B808081u));
    float32x4_t v10 = vmulq_f32(v9, v9);
    int8x16_t v11 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v8), v10, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v8)), vmulq_f32(v10, v10), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v8), v10, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v8)));
    int32x4_t v12 = vcgeq_f32(v9, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
    v12.i32[3] = 0;
    int32x4_t v13 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v12), v11, (int8x16_t)vmulq_f32(v8, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
    v13.i32[3] = v9.i32[3];
    int8x16_t v14 = (int8x16_t)vrev64q_s32(v13);
    *(void *)&double result = vextq_s8(v14, v14, 0xCuLL).u64[0];
  }
  return result;
}

double sub_1B6419944(uint64_t a1, double a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(*(float *)&a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  unsigned int v3 = *(unsigned __int16 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  int v4 = (v3 >> 10) & 0x1F;
  if (v4 == 31) {
    int v5 = 2139095040;
  }
  else {
    int v5 = (v3 >> 10) & 0x1F;
  }
  if (v4) {
    BOOL v6 = v4 == 31;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    int v7 = v5;
  }
  else {
    int v7 = (v4 << 23) + 939524096;
  }
  LODWORD(a2) = v7 | (v3 << 16) & 0x80000000 | (v3 >> 7) & 7 | (8 * (v3 & 0x3FF)) & 0x1FFF | ((v3 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B64199CC(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  unsigned int v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  *(void *)&double result = vld1q_dup_f32(v3).u64[0];
  return result;
}

double sub_1B6419A08(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  int16x4_t v3 = *(int16x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  v4.i64[0] = 0x8000000080000000;
  v4.i64[1] = 0x8000000080000000;
  int32x4_t v5 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v3), v4);
  int8x16_t v6 = (int8x16_t)vshll_n_u16((uint16x4_t)v3, 0xDuLL);
  int32x4_t v7 = (int32x4_t)vorrq_s8(vandq_s8(v6, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v5, vandq_s8(v6, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v5.i64[0] = 0x3800000038000000;
  v5.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v7, v5).u64[0];
  return result;
}

__n128 sub_1B6419A7C(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  return *(__n128 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
}

double sub_1B6419AB8(uint64_t a1, double a2)
{
  *(float *)&a2 = *(float *)a1 * fminf(fmaxf(*(float *)&a2, 0.0), 1.0);
  int v2 = (int)*(float *)&a2;
  if ((int)*(float *)&a2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  LOBYTE(a2) = *(unsigned char *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  *(float *)&a2 = (float)LODWORD(a2) * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B6419B08(unsigned int *a1, float a2)
{
  int32x2_t v2 = (int32x2_t)*a1;
  float v3 = *(float *)v2.i32 * fminf(fmaxf(a2, 0.0), 1.0);
  int v4 = (int)v3;
  if ((int)v3 >= (int)a1[1]) {
    int v4 = a1[1];
  }
  LOBYTE(v3) = *(unsigned char *)(*((void *)a1 + 2) + (int)a1[2] * (uint64_t)v4);
  *(float *)v2.i32 = (float)LODWORD(v3) * 0.0039216;
  int32x4_t v5 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v2, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v5.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v5), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v2.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v2.i32), *(float *)v2.i32 * *(float *)v2.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v2.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v2.i32),
                                        *(float *)v2.i32 * *(float *)v2.i32),
                                      (float)(*(float *)v2.i32 * *(float *)v2.i32)
                                    * (float)(*(float *)v2.i32 * *(float *)v2.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v2.i32)).u64[0];
  return result;
}

double sub_1B6419C0C(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B6419C70(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int32x4_t v9 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v9.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6))), (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B6419D78(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  int8x16_t v6 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v6, v6, 0xCuLL).u64[0];
  return result;
}

double sub_1B6419DE4(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(fmaxf(a2, 0.0), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6)));
  int32x4_t v10 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v10.i32[3] = 0;
  int32x4_t v11 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v10), v9, (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v11.i32[3] = v7.i32[3];
  int8x16_t v12 = (int8x16_t)vrev64q_s32(v11);
  *(void *)&double result = vextq_s8(v12, v12, 0xCuLL).u64[0];
  return result;
}

double sub_1B6419EF4(uint64_t a1, double a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(*(float *)&a2 - floorf(*(float *)&a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  unsigned int v3 = *(unsigned __int16 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  int v4 = (v3 >> 10) & 0x1F;
  if (v4 == 31) {
    int v5 = 2139095040;
  }
  else {
    int v5 = (v3 >> 10) & 0x1F;
  }
  if (v4) {
    BOOL v6 = v4 == 31;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    int v7 = v5;
  }
  else {
    int v7 = (v4 << 23) + 939524096;
  }
  LODWORD(a2) = v7 | (v3 << 16) & 0x80000000 | (v3 >> 7) & 7 | (8 * (v3 & 0x3FF)) & 0x1FFF | ((v3 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B6419F80(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(a2 - floorf(a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  unsigned int v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  *(void *)&double result = vld1q_dup_f32(v3).u64[0];
  return result;
}

double sub_1B6419FC0(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(a2 - floorf(a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  int16x4_t v3 = *(int16x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  v4.i64[0] = 0x8000000080000000;
  v4.i64[1] = 0x8000000080000000;
  int32x4_t v5 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v3), v4);
  int8x16_t v6 = (int8x16_t)vshll_n_u16((uint16x4_t)v3, 0xDuLL);
  int32x4_t v7 = (int32x4_t)vorrq_s8(vandq_s8(v6, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v5, vandq_s8(v6, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v5.i64[0] = 0x3800000038000000;
  v5.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v7, v5).u64[0];
  return result;
}

__n128 sub_1B641A038(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(a2 - floorf(a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  return *(__n128 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
}

double sub_1B641A078(uint64_t a1, double a2)
{
  *(float *)&a2 = *(float *)a1 * fminf(*(float *)&a2 - floorf(*(float *)&a2), 1.0);
  int v2 = (int)*(float *)&a2;
  if ((int)*(float *)&a2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  LOBYTE(a2) = *(unsigned char *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  *(float *)&a2 = (float)LODWORD(a2) * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641A0CC(uint64_t a1, float a2, double a3)
{
  float v3 = *(float *)a1 * fminf(a2 - floorf(a2), 1.0);
  int v4 = (int)v3;
  if ((int)v3 >= *(_DWORD *)(a1 + 4)) {
    int v4 = *(_DWORD *)(a1 + 4);
  }
  LOBYTE(v3) = *(unsigned char *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
  *(float *)&a3 = (float)LODWORD(v3) * 0.0039216;
  int32x4_t v5 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v5.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v5), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)&a3), *(float *)&a3 * *(float *)&a3), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)&a3),
                                        *(float *)&a3 * *(float *)&a3),
                                      (float)(*(float *)&a3 * *(float *)&a3) * (float)(*(float *)&a3 * *(float *)&a3)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)&a3)).u64[0];
  return result;
}

double sub_1B641A1D4(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(a2 - floorf(a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B641A23C(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(a2 - floorf(a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int32x4_t v9 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v9.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6))), (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B641A348(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(a2 - floorf(a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  int8x16_t v6 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v6, v6, 0xCuLL).u64[0];
  return result;
}

double sub_1B641A3B8(uint64_t a1, float a2)
{
  int v2 = (int)(float)(*(float *)a1 * fminf(a2 - floorf(a2), 1.0));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6)));
  int32x4_t v10 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v10.i32[3] = 0;
  int32x4_t v11 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v10), v9, (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v11.i32[3] = v7.i32[3];
  int8x16_t v12 = (int8x16_t)vrev64q_s32(v11);
  *(void *)&double result = vextq_s8(v12, v12, 0xCuLL).u64[0];
  return result;
}

double sub_1B641A4CC(uint64_t a1, double a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(*(float *)&a2 * 0.5) + 0.5) - floorf((float)(*(float *)&a2 * 0.5) + 0.5), 1.0))* (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  unsigned int v3 = *(unsigned __int16 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  int v4 = (v3 >> 10) & 0x1F;
  if (v4 == 31) {
    int v5 = 2139095040;
  }
  else {
    int v5 = (v3 >> 10) & 0x1F;
  }
  if (v4) {
    BOOL v6 = v4 == 31;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    int v7 = v5;
  }
  else {
    int v7 = (v4 << 23) + 939524096;
  }
  LODWORD(a2) = v7 | (v3 << 16) & 0x80000000 | (v3 >> 7) & 7 | (8 * (v3 & 0x3FF)) & 0x1FFF | ((v3 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641A568(uint64_t a1, float a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
                  * (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  unsigned int v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  *(void *)&double result = vld1q_dup_f32(v3).u64[0];
  return result;
}

double sub_1B641A5B8(uint64_t a1, float a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
                  * (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  int16x4_t v3 = *(int16x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  v4.i64[0] = 0x8000000080000000;
  v4.i64[1] = 0x8000000080000000;
  int32x4_t v5 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v3), v4);
  int8x16_t v6 = (int8x16_t)vshll_n_u16((uint16x4_t)v3, 0xDuLL);
  int32x4_t v7 = (int32x4_t)vorrq_s8(vandq_s8(v6, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v5, vandq_s8(v6, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v5.i64[0] = 0x3800000038000000;
  v5.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v7, v5).u64[0];
  return result;
}

__n128 sub_1B641A640(uint64_t a1, float a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
                  * (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  return *(__n128 *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
}

double sub_1B641A690(uint64_t a1, double a2)
{
  *(float *)&a2 = vabds_f32(0.5, fminf((float)((float)(*(float *)&a2 * 0.5) + 0.5) - floorf((float)(*(float *)&a2 * 0.5) + 0.5), 1.0))* (float)(*(float *)a1 + *(float *)a1);
  int v2 = (int)*(float *)&a2;
  if ((int)*(float *)&a2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  LOBYTE(a2) = *(unsigned char *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  *(float *)&a2 = (float)LODWORD(a2) * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641A6F4(uint64_t a1, float a2, double a3)
{
  float v3 = vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
     * (float)(*(float *)a1 + *(float *)a1);
  int v4 = (int)v3;
  if ((int)v3 >= *(_DWORD *)(a1 + 4)) {
    int v4 = *(_DWORD *)(a1 + 4);
  }
  LOBYTE(v3) = *(unsigned char *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4);
  *(float *)&a3 = (float)LODWORD(v3) * 0.0039216;
  int32x4_t v5 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v5.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v5), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)&a3), *(float *)&a3 * *(float *)&a3), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)&a3),
                                        *(float *)&a3 * *(float *)&a3),
                                      (float)(*(float *)&a3 * *(float *)&a3) * (float)(*(float *)&a3 * *(float *)&a3)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)&a3)).u64[0];
  return result;
}

double sub_1B641A80C(uint64_t a1, float a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
                  * (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B641A884(uint64_t a1, float a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
                  * (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int32x4_t v9 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v9.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6))), (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B641A9A0(uint64_t a1, float a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
                  * (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  int8x16_t v6 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v6, v6, 0xCuLL).u64[0];
  return result;
}

double sub_1B641AA20(uint64_t a1, float a2)
{
  int v2 = (int)(float)(vabds_f32(0.5, fminf((float)((float)(a2 * 0.5) + 0.5) - floorf((float)(a2 * 0.5) + 0.5), 1.0))
                  * (float)(*(float *)a1 + *(float *)a1));
  if (v2 >= *(_DWORD *)(a1 + 4)) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  float v3 = (const float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v2);
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  v5.i64[0] = 0xFF000000FFLL;
  v5.i64[1] = 0xFF000000FFLL;
  float32x4_t v6 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_1B6E50360), v5));
  float32x4_t v7 = vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v8 = vmulq_f32(v7, v7);
  int8x16_t v9 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v6)), vmulq_f32(v8, v8), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v6), v8, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v6)));
  int32x4_t v10 = vcgeq_f32(v7, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v10.i32[3] = 0;
  int32x4_t v11 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v10), v9, (int8x16_t)vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v11.i32[3] = v7.i32[3];
  int8x16_t v12 = (int8x16_t)vrev64q_s32(v11);
  *(void *)&double result = vextq_s8(v12, v12, 0xCuLL).u64[0];
  return result;
}

double sub_1B641AB44(uint64_t a1, float a2, float32x4_t a3, float32x4_t a4)
{
  float v4 = a2 - *(float *)(a1 + 32);
  float32x4_t v5 = 0uLL;
  if (v4 < 1.0 && v4 >= 0.0)
  {
    v5.f32[0] = *(float *)a1 * v4;
    int v6 = *(_DWORD *)(a1 + 4);
    int v7 = *(_DWORD *)(a1 + 8);
    if ((int)v5.f32[0] >= v6) {
      int v8 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v8 = (int)v5.f32[0];
    }
    uint64_t v9 = *(void *)(a1 + 16);
    if (v6 <= (int)v5.f32[0]) {
      int v10 = 0;
    }
    else {
      int v10 = *(_DWORD *)(a1 + 8);
    }
    int v11 = v7 * v8;
    unsigned int v12 = *(unsigned __int16 *)(v9 + v7 * v8);
    int v13 = (v12 >> 10) & 0x1F;
    if (v13 == 31) {
      int v14 = 2139095040;
    }
    else {
      int v14 = (v12 >> 10) & 0x1F;
    }
    if (v13) {
      BOOL v15 = v13 == 31;
    }
    else {
      BOOL v15 = 1;
    }
    if (v15) {
      int v16 = v14;
    }
    else {
      int v16 = (v13 << 23) + 939524096;
    }
    a3.i32[0] = v16 | (v12 << 16) & 0x80000000 | (v12 >> 7) & 7 | (8 * (v12 & 0x3FF)) & 0x1FFF | ((v12 & 0x3FF) << 13);
    unsigned int v17 = *(unsigned __int16 *)(v9 + v11 + v10);
    int v18 = (v17 >> 10) & 0x1F;
    if (v18 == 31) {
      int v19 = 2139095040;
    }
    else {
      int v19 = (v17 >> 10) & 0x1F;
    }
    if (v18) {
      BOOL v20 = v18 == 31;
    }
    else {
      BOOL v20 = 1;
    }
    if (v20) {
      int v21 = v19;
    }
    else {
      int v21 = (v18 << 23) + 939524096;
    }
    a4.i32[0] = v21 | (v17 << 16) & 0x80000000 | (v17 >> 7) & 7 | (8 * (v17 & 0x3FF)) & 0x1FFF | ((v17 & 0x3FF) << 13);
    v5.f32[0] = v5.f32[0] - truncf(v5.f32[0]);
    v5.i64[0] = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmlaq_f32(a3, v5, vsubq_f32(a4, a3)), 0).u64[0];
  }
  return *(double *)v5.i64;
}

double sub_1B641AC38(uint64_t a1, float a2)
{
  float v2 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v2 < 1.0 && v2 >= 0.0)
  {
    *(float *)&double result = *(float *)a1 * v2;
    int v4 = *(_DWORD *)(a1 + 4);
    if ((int)*(float *)&result >= v4) {
      int v5 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v5 = (int)*(float *)&result;
    }
    if (v4 <= (int)*(float *)&result) {
      int v6 = 0;
    }
    else {
      int v6 = *(_DWORD *)(a1 + 8);
    }
    *(float *)&double result = *(float *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v5)
                      + (float)((float)(*(float *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v5 + v6)
                                      - *(float *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v5))
                              * (float)(*(float *)&result - truncf(*(float *)&result)));
    *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&result, 0).u64[0];
  }
  return result;
}

double sub_1B641ACA4(uint64_t a1, float a2)
{
  float v2 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v2 < 1.0 && v2 >= 0.0)
  {
    float v4 = *(float *)a1 * v2;
    int v5 = *(_DWORD *)(a1 + 4);
    int v6 = *(_DWORD *)(a1 + 8);
    if ((int)v4 >= v5) {
      int v7 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v7 = (int)v4;
    }
    uint64_t v8 = *(void *)(a1 + 16);
    if (v5 <= (int)v4) {
      int v9 = 0;
    }
    else {
      int v9 = *(_DWORD *)(a1 + 8);
    }
    int16x4_t v10 = *(int16x4_t *)(v8 + v6 * v7);
    v11.i64[0] = 0x8000000080000000;
    v11.i64[1] = 0x8000000080000000;
    int32x4_t v12 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v10), v11);
    int8x16_t v13 = (int8x16_t)vshll_n_u16((uint16x4_t)v10, 0xDuLL);
    int8x16_t v14 = (int8x16_t)vdupq_n_s32(0x7FE000u);
    int8x16_t v15 = (int8x16_t)vdupq_n_s32(0xF800000u);
    int32x4_t v16 = (int32x4_t)vorrq_s8(vandq_s8(v13, v15), vorrq_s8((int8x16_t)v12, vandq_s8(v13, v14)));
    v12.i64[0] = 0x3800000038000000;
    v12.i64[1] = 0x3800000038000000;
    float32x4_t v17 = (float32x4_t)vaddq_s32(v16, v12);
    int16x4_t v18 = *(int16x4_t *)(v8 + v6 * v7 + v9);
    int8x16_t v19 = vandq_s8((int8x16_t)vmovl_s16(v18), v11);
    int8x16_t v20 = (int8x16_t)vshll_n_u16((uint16x4_t)v18, 0xDuLL);
    *(void *)&double result = vmlaq_n_f32(v17, vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v20, v15), vorrq_s8(v19, vandq_s8(v20, v14))), v12), v17), v4 - truncf(v4)).u64[0];
  }
  return result;
}

double sub_1B641AD64(uint64_t a1, float a2)
{
  float v2 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v2 < 1.0 && v2 >= 0.0)
  {
    float v4 = *(float *)a1 * v2;
    int v5 = *(_DWORD *)(a1 + 4);
    if ((int)v4 >= v5) {
      int v6 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v6 = (int)v4;
    }
    if (v5 <= (int)v4) {
      int v7 = 0;
    }
    else {
      int v7 = *(_DWORD *)(a1 + 8);
    }
    *(void *)&double result = vmlaq_n_f32(*(float32x4_t *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v6), vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v6 + v7), *(float32x4_t *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v6)), v4 - truncf(v4)).u64[0];
  }
  return result;
}

double sub_1B641ADCC(uint64_t a1, float a2, double a3, double a4, float a5)
{
  float v5 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v5 < 1.0 && v5 >= 0.0)
  {
    *(float *)&double result = *(float *)a1 * v5;
    int v7 = *(_DWORD *)(a1 + 4);
    int v8 = *(_DWORD *)(a1 + 8);
    if ((int)*(float *)&result >= v7) {
      int v9 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v9 = (int)*(float *)&result;
    }
    uint64_t v10 = *(void *)(a1 + 16);
    if (v7 <= (int)*(float *)&result) {
      int v11 = 0;
    }
    else {
      int v11 = *(_DWORD *)(a1 + 8);
    }
    LOBYTE(v5) = *(unsigned char *)(v10 + v8 * v9);
    LOBYTE(a5) = *(unsigned char *)(v10 + v8 * v9 + v11);
    *(float *)&double result = (float)((float)LODWORD(v5) * 0.0039216)
                      + (float)((float)-(float)((float)((float)LODWORD(v5) * 0.0039216)
                                              - (float)((float)LODWORD(a5) * 0.0039216))
                              * (float)(*(float *)&result - truncf(*(float *)&result)));
    *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&result, 0).u64[0];
  }
  return result;
}

double sub_1B641AE4C(uint64_t a1, float a2, double a3, double a4, float a5)
{
  *(float *)&a3 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (*(float *)&a3 < 1.0 && *(float *)&a3 >= 0.0)
  {
    float v6 = *(float *)a1 * *(float *)&a3;
    int v7 = *(_DWORD *)(a1 + 4);
    int v8 = *(_DWORD *)(a1 + 8);
    if ((int)v6 >= v7) {
      int v9 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v9 = (int)v6;
    }
    uint64_t v10 = *(void *)(a1 + 16);
    if (v7 <= (int)v6) {
      int v11 = 0;
    }
    else {
      int v11 = *(_DWORD *)(a1 + 8);
    }
    LOBYTE(a3) = *(unsigned char *)(v10 + v8 * v9);
    LOBYTE(a5) = *(unsigned char *)(v10 + v8 * v9 + v11);
    *(float *)&a3 = (float)((float)LODWORD(a3) * 0.0039216)
                  + (float)((float)-(float)((float)((float)LODWORD(a3) * 0.0039216)
                                          - (float)((float)LODWORD(a5) * 0.0039216))
                          * (float)(v6 - truncf(v6)));
    int32x4_t v12 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
    v12.i32[3] = 0;
    *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v12), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)&a3), *(float *)&a3 * *(float *)&a3), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                            (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                            *(float *)&a3),
                                          *(float *)&a3 * *(float *)&a3),
                                        (float)(*(float *)&a3 * *(float *)&a3) * (float)(*(float *)&a3 * *(float *)&a3)),
                           (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)&a3)).u64[0];
  }
  return result;
}

double sub_1B641AF80(uint64_t a1, float a2)
{
  float v2 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v2 < 1.0 && v2 >= 0.0)
  {
    float v4 = *(float *)a1 * v2;
    int v5 = *(_DWORD *)(a1 + 4);
    int v6 = *(_DWORD *)(a1 + 8);
    if ((int)v4 >= v5) {
      int v7 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v7 = (int)v4;
    }
    uint64_t v8 = *(void *)(a1 + 16);
    if (v5 <= (int)v4) {
      int v9 = 0;
    }
    else {
      int v9 = *(_DWORD *)(a1 + 8);
    }
    int v10 = v6 * v7;
    int v11 = (const float *)(v8 + v6 * v7);
    uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
    v13.i64[0] = 0xFF000000FFLL;
    v13.i64[1] = 0xFF000000FFLL;
    float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
    int32x4_t v16 = (const float *)(v8 + v10 + v9);
    uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
    *(void *)&double result = vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v13))), v4 - truncf(v4)).u64[0];
  }
  return result;
}

double sub_1B641B028(uint64_t a1, float a2)
{
  float v2 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v2 < 1.0 && v2 >= 0.0)
  {
    float v4 = *(float *)a1 * v2;
    int v5 = *(_DWORD *)(a1 + 4);
    int v6 = *(_DWORD *)(a1 + 8);
    if ((int)v4 >= v5) {
      int v7 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v7 = (int)v4;
    }
    uint64_t v8 = *(void *)(a1 + 16);
    if (v5 <= (int)v4) {
      int v9 = 0;
    }
    else {
      int v9 = *(_DWORD *)(a1 + 8);
    }
    int v10 = v6 * v7;
    int v11 = (const float *)(v8 + v6 * v7);
    uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
    v13.i64[0] = 0xFF000000FFLL;
    v13.i64[1] = 0xFF000000FFLL;
    float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
    int32x4_t v16 = (const float *)(v8 + v10 + v9);
    uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
    float32x4_t v18 = vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v13))), v4 - truncf(v4));
    float32x4_t v19 = vmulq_f32(v18, v18);
    int32x4_t v20 = vcgeq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
    v20.i32[3] = 0;
    *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v20), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v18), v19, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v18)), vmulq_f32(v19, v19), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v18), v19,
                                          vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v18))), (int8x16_t)vmulq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  }
  return result;
}

double sub_1B641B184(uint64_t a1, float a2)
{
  float v2 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v2 < 1.0 && v2 >= 0.0)
  {
    float v4 = *(float *)a1 * v2;
    int v5 = *(_DWORD *)(a1 + 4);
    int v6 = *(_DWORD *)(a1 + 8);
    if ((int)v4 >= v5) {
      int v7 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v7 = (int)v4;
    }
    uint64_t v8 = *(void *)(a1 + 16);
    if (v5 <= (int)v4) {
      int v9 = 0;
    }
    else {
      int v9 = *(_DWORD *)(a1 + 8);
    }
    int v10 = v6 * v7;
    int v11 = (const float *)(v8 + v6 * v7);
    uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
    v13.i64[0] = 0xFF000000FFLL;
    v13.i64[1] = 0xFF000000FFLL;
    float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
    int32x4_t v16 = (const float *)(v8 + v10 + v9);
    uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
    int8x16_t v18 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v13))), v4 - truncf(v4)));
    *(void *)&double result = vextq_s8(v18, v18, 0xCuLL).u64[0];
  }
  return result;
}

double sub_1B641B234(uint64_t a1, float a2)
{
  float v2 = a2 - *(float *)(a1 + 32);
  double result = 0.0;
  if (v2 < 1.0 && v2 >= 0.0)
  {
    float v4 = *(float *)a1 * v2;
    int v5 = *(_DWORD *)(a1 + 4);
    int v6 = *(_DWORD *)(a1 + 8);
    if ((int)v4 >= v5) {
      int v7 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v7 = (int)v4;
    }
    uint64_t v8 = *(void *)(a1 + 16);
    BOOL v9 = v5 <= (int)v4;
    int v10 = (const float *)(v8 + v6 * v7);
    uint32x4_t v11 = (uint32x4_t)vld1q_dup_f32(v10);
    if (v9) {
      int v12 = 0;
    }
    else {
      int v12 = *(_DWORD *)(a1 + 8);
    }
    v13.i64[0] = 0xFF000000FFLL;
    v13.i64[1] = 0xFF000000FFLL;
    float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
    int32x4_t v16 = (const float *)(v8 + v6 * v7 + v12);
    uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
    float32x4_t v18 = vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v13))), v4 - truncf(v4));
    float32x4_t v19 = vmulq_f32(v18, v18);
    int32x4_t v20 = vcgeq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
    v20.i32[3] = 0;
    int32x4_t v21 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v20), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v18), v19, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v18)), vmulq_f32(v19, v19), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v18), v19,
                                      vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v18))), (int8x16_t)vmulq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
    v21.i32[3] = v18.i32[3];
    int8x16_t v22 = (int8x16_t)vrev64q_s32(v21);
    *(void *)&double result = vextq_s8(v22, v22, 0xCuLL).u64[0];
  }
  return result;
}

double sub_1B641B398(float *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  a3.i64[0] = *(unsigned int *)a1;
  a2.f32[0] = fminf(fmaxf(a2.f32[0] - a1[8], 0.0), 1.0) * a3.f32[0];
  int v4 = *((_DWORD *)a1 + 1);
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if ((int)a2.f32[0] >= v4) {
    int v6 = *((_DWORD *)a1 + 1);
  }
  else {
    int v6 = (int)a2.f32[0];
  }
  uint64_t v7 = *((void *)a1 + 2);
  if (v4 <= (int)a2.f32[0]) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = *((_DWORD *)a1 + 2);
  }
  int v9 = v5 * v6;
  unsigned int v10 = *(unsigned __int16 *)(v7 + (int)(v5 * v6));
  int v11 = (v10 >> 10) & 0x1F;
  if (v11 == 31) {
    int v12 = 2139095040;
  }
  else {
    int v12 = (v10 >> 10) & 0x1F;
  }
  if (v11) {
    BOOL v13 = v11 == 31;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13) {
    int v14 = v12;
  }
  else {
    int v14 = (v11 << 23) + 939524096;
  }
  unsigned int v15 = *(unsigned __int16 *)(v7 + (int)(v9 + v8));
  int v16 = (v15 >> 10) & 0x1F;
  if (v16 == 31) {
    int v17 = 2139095040;
  }
  else {
    int v17 = (v15 >> 10) & 0x1F;
  }
  if (v16) {
    BOOL v18 = v16 == 31;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18) {
    int v19 = v17;
  }
  else {
    int v19 = (v16 << 23) + 939524096;
  }
  a3.i32[0] = v14 | (v10 << 16) & 0x80000000 | (v10 >> 7) & 7 | (8 * (v10 & 0x3FF)) & 0x1FFF | ((v10 & 0x3FF) << 13);
  a4.i32[0] = v19 | (v15 << 16) & 0x80000000 | (v15 >> 7) & 7 | (8 * (v15 & 0x3FF)) & 0x1FFF | ((v15 & 0x3FF) << 13);
  a2.f32[0] = a2.f32[0] - truncf(a2.f32[0]);
  a2.i64[0] = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmlaq_f32(a3, a2, vsubq_f32(a4, a3)), 0).u64[0];
  return *(double *)a2.i64;
}

double sub_1B641B484(uint64_t a1, double a2)
{
  *(float *)&a2 = fminf(fmaxf(*(float *)&a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v2 = (int)*(float *)&a2;
  int v3 = *(_DWORD *)(a1 + 4);
  if (v3 <= (int)*(float *)&a2) {
    int v4 = 0;
  }
  else {
    int v4 = *(_DWORD *)(a1 + 8);
  }
  if (v2 >= v3) {
    int v2 = *(_DWORD *)(a1 + 4);
  }
  *(float *)&a2 = *(float *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v2)
                + (float)((float)(*(float *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v2 + v4)
                                - *(float *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v2))
                        * (float)(*(float *)&a2 - truncf(*(float *)&a2)));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641B4E8(uint64_t a1, float a2)
{
  float v2 = fminf(fmaxf(a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v3 = (int)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 4);
  if (v5 <= (int)v2) {
    int v6 = 0;
  }
  else {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  if (v3 >= v5) {
    int v3 = *(_DWORD *)(a1 + 4);
  }
  int v7 = *(_DWORD *)(a1 + 8) * v3;
  int16x4_t v8 = *(int16x4_t *)(v4 + v7);
  v9.i64[0] = 0x8000000080000000;
  v9.i64[1] = 0x8000000080000000;
  int32x4_t v10 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v8), v9);
  int8x16_t v11 = (int8x16_t)vshll_n_u16((uint16x4_t)v8, 0xDuLL);
  int8x16_t v12 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v13 = (int8x16_t)vdupq_n_s32(0xF800000u);
  int32x4_t v14 = (int32x4_t)vorrq_s8(vandq_s8(v11, v13), vorrq_s8((int8x16_t)v10, vandq_s8(v11, v12)));
  v10.i64[0] = 0x3800000038000000;
  v10.i64[1] = 0x3800000038000000;
  float32x4_t v15 = (float32x4_t)vaddq_s32(v14, v10);
  int16x4_t v16 = *(int16x4_t *)(v4 + v7 + v6);
  int8x16_t v17 = vandq_s8((int8x16_t)vmovl_s16(v16), v9);
  int8x16_t v18 = (int8x16_t)vshll_n_u16((uint16x4_t)v16, 0xDuLL);
  *(void *)&double result = vmlaq_n_f32(v15, vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v18, v13), vorrq_s8(v17, vandq_s8(v18, v12))), v10), v15), v2 - truncf(v2)).u64[0];
  return result;
}

double sub_1B641B5A0(uint64_t a1, float a2)
{
  float v2 = fminf(fmaxf(a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v3 = (int)v2;
  int v4 = *(_DWORD *)(a1 + 4);
  if (v4 <= (int)v2) {
    int v5 = 0;
  }
  else {
    int v5 = *(_DWORD *)(a1 + 8);
  }
  if (v3 >= v4) {
    int v3 = *(_DWORD *)(a1 + 4);
  }
  *(void *)&double result = vmlaq_n_f32(*(float32x4_t *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v3), vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v3 + v5), *(float32x4_t *)(*(void *)(a1 + 16) + *(_DWORD *)(a1 + 8) * v3)), v2 - truncf(v2)).u64[0];
  return result;
}

double sub_1B641B600(uint64_t a1, double a2, double a3, double a4, float a5)
{
  unsigned int v5 = *(_DWORD *)a1;
  *(float *)&a2 = fminf(fmaxf(*(float *)&a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v6 = (int)*(float *)&a2;
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = *(_DWORD *)(a1 + 4);
  if (v8 <= (int)*(float *)&a2) {
    int v9 = 0;
  }
  else {
    int v9 = *(_DWORD *)(a1 + 8);
  }
  if (v6 >= v8) {
    int v6 = *(_DWORD *)(a1 + 4);
  }
  int v10 = *(_DWORD *)(a1 + 8) * v6;
  LOBYTE(v5) = *(unsigned char *)(v7 + v10);
  LOBYTE(a5) = *(unsigned char *)(v7 + v10 + v9);
  *(float *)&a2 = (float)((float)v5 * 0.0039216)
                + (float)((float)-(float)((float)((float)v5 * 0.0039216) - (float)((float)LODWORD(a5) * 0.0039216))
                        * (float)(*(float *)&a2 - truncf(*(float *)&a2)));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641B678(float *a1, float a2, double a3, double a4, float a5)
{
  int32x2_t v5 = (int32x2_t)*(unsigned int *)a1;
  float v6 = fminf(fmaxf(a2 - a1[8], 0.0), 1.0) * *(float *)v5.i32;
  int v7 = (int)v6;
  uint64_t v8 = *((void *)a1 + 2);
  int v9 = *((_DWORD *)a1 + 1);
  if (v9 <= (int)v6) {
    unsigned int v10 = 0;
  }
  else {
    unsigned int v10 = *((_DWORD *)a1 + 2);
  }
  if (v7 >= v9) {
    int v7 = *((_DWORD *)a1 + 1);
  }
  int v11 = *((_DWORD *)a1 + 2) * v7;
  v5.i8[0] = *(unsigned char *)(v8 + v11);
  LOBYTE(a5) = *(unsigned char *)(v8 + (int)(v11 + v10));
  *(float *)v5.i32 = (float)((float)v5.u32[0] * 0.0039216)
                   + (float)((float)-(float)((float)((float)v5.u32[0] * 0.0039216)
                                           - (float)((float)LODWORD(a5) * 0.0039216))
                           * (float)(v6 - truncf(v6)));
  int32x4_t v12 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v5, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v12.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v12), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v5.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v5.i32), *(float *)v5.i32 * *(float *)v5.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v5.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v5.i32),
                                        *(float *)v5.i32 * *(float *)v5.i32),
                                      (float)(*(float *)v5.i32 * *(float *)v5.i32)
                                    * (float)(*(float *)v5.i32 * *(float *)v5.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v5.i32)).u64[0];
  return result;
}

double sub_1B641B7A4(uint64_t a1, float a2)
{
  float v2 = fminf(fmaxf(a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v3 = (int)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 4);
  if (v5 <= (int)v2) {
    int v6 = 0;
  }
  else {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  if (v3 >= v5) {
    int v3 = *(_DWORD *)(a1 + 4);
  }
  int v7 = *(_DWORD *)(a1 + 8) * v3;
  uint64_t v8 = (const float *)(v4 + v7);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v12 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), v11);
  int8x16_t v13 = (const float *)(v4 + v7 + v6);
  uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(v13);
  *(void *)&double result = vmlaq_n_f32(v12, vmlaq_f32(vnegq_f32(v12), v11, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_1B6E50360), v10))), v2 - truncf(v2)).u64[0];
  return result;
}

double sub_1B641B844(uint64_t a1, float a2)
{
  float v2 = fminf(fmaxf(a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v3 = (int)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 4);
  if (v5 <= (int)v2) {
    int v6 = 0;
  }
  else {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  if (v3 >= v5) {
    int v3 = *(_DWORD *)(a1 + 4);
  }
  int v7 = *(_DWORD *)(a1 + 8) * v3;
  uint64_t v8 = (const float *)(v4 + v7);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v12 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), v11);
  int8x16_t v13 = (const float *)(v4 + v7 + v6);
  uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(v13);
  float32x4_t v15 = vmlaq_n_f32(v12, vmlaq_f32(vnegq_f32(v12), v11, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_1B6E50360), v10))), v2 - truncf(v2));
  float32x4_t v16 = vmulq_f32(v15, v15);
  int32x4_t v17 = vcgeq_f32(v15, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v17.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v17), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v15), v16, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v15)), vmulq_f32(v16, v16), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v15), v16,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v15))), (int8x16_t)vmulq_f32(v15, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B641B998(uint64_t a1, float a2)
{
  float v2 = fminf(fmaxf(a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v3 = (int)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 4);
  if (v5 <= (int)v2) {
    int v6 = 0;
  }
  else {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  if (v3 >= v5) {
    int v3 = *(_DWORD *)(a1 + 4);
  }
  int v7 = *(_DWORD *)(a1 + 8) * v3;
  uint64_t v8 = (const float *)(v4 + v7);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v12 = (const float *)(v4 + v7 + v6);
  uint32x4_t v13 = (uint32x4_t)vld1q_dup_f32(v12);
  float32x4_t v14 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), v11);
  int8x16_t v15 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_n_f32(v14, vmlaq_f32(vnegq_f32(v14), v11, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B6E50360), v10))), v2 - truncf(v2)));
  *(void *)&double result = vextq_s8(v15, v15, 0xCuLL).u64[0];
  return result;
}

double sub_1B641BA40(uint64_t a1, float a2)
{
  float v2 = fminf(fmaxf(a2 - *(float *)(a1 + 32), 0.0), 1.0) * *(float *)a1;
  int v3 = (int)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 4);
  if (v5 <= (int)v2) {
    int v6 = 0;
  }
  else {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  if (v3 >= v5) {
    int v3 = *(_DWORD *)(a1 + 4);
  }
  int v7 = *(_DWORD *)(a1 + 8) * v3;
  uint64_t v8 = (const float *)(v4 + v7);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v12 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), v11);
  uint32x4_t v13 = (const float *)(v4 + v7 + v6);
  uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(v13);
  float32x4_t v15 = vmlaq_n_f32(v12, vmlaq_f32(vnegq_f32(v12), v11, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_1B6E50360), v10))), v2 - truncf(v2));
  float32x4_t v16 = vmulq_f32(v15, v15);
  int32x4_t v17 = vcgeq_f32(v15, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v17.i32[3] = 0;
  int32x4_t v18 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v17), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v15), v16, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v15)), vmulq_f32(v16, v16), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v15), v16,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v15))), (int8x16_t)vmulq_f32(v15, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v18.i32[3] = v15.i32[3];
  int8x16_t v19 = (int8x16_t)vrev64q_s32(v18);
  *(void *)&double result = vextq_s8(v19, v19, 0xCuLL).u64[0];
  return result;
}

double sub_1B641BB9C(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  a2.f32[0] = fminf((float)(a2.f32[0] - *(float *)(a1 + 32)) - floorf(a2.f32[0] - *(float *)(a1 + 32)), 1.0)
            * *(float *)a1;
  int v4 = *(_DWORD *)(a1 + 4);
  if ((int)a2.f32[0] >= v4) {
    int v5 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v5 = (int)a2.f32[0];
  }
  uint64_t v6 = 12;
  if (v4 > (int)a2.f32[0]) {
    uint64_t v6 = 8;
  }
  uint64_t v7 = *(int *)(a1 + v6);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(int *)(a1 + 8) * (uint64_t)v5;
  unsigned int v10 = *(unsigned __int16 *)(v8 + v9);
  int v11 = (v10 >> 10) & 0x1F;
  if (v11 == 31) {
    int v12 = 2139095040;
  }
  else {
    int v12 = (v10 >> 10) & 0x1F;
  }
  if (v11) {
    BOOL v13 = v11 == 31;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13) {
    int v14 = v12;
  }
  else {
    int v14 = (v11 << 23) + 939524096;
  }
  unsigned int v15 = *(unsigned __int16 *)(v8 + v7 + (int)v9);
  int v16 = (v15 >> 10) & 0x1F;
  if (v16 == 31) {
    int v17 = 2139095040;
  }
  else {
    int v17 = (v15 >> 10) & 0x1F;
  }
  if (v16) {
    BOOL v18 = v16 == 31;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18) {
    int v19 = v17;
  }
  else {
    int v19 = (v16 << 23) + 939524096;
  }
  a3.i32[0] = v14 | (v10 << 16) & 0x80000000 | (v10 >> 7) & 7 | (8 * (v10 & 0x3FF)) & 0x1FFF | ((v10 & 0x3FF) << 13);
  a4.i32[0] = v19 | (v15 << 16) & 0x80000000 | (v15 >> 7) & 7 | (8 * (v15 & 0x3FF)) & 0x1FFF | ((v15 & 0x3FF) << 13);
  a2.f32[0] = a2.f32[0] - truncf(a2.f32[0]);
  a2.i64[0] = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmlaq_f32(a3, a2, vsubq_f32(a4, a3)), 0).u64[0];
  return *(double *)a2.i64;
}

double sub_1B641BC9C(uint64_t a1, double a2)
{
  *(float *)&a2 = fminf((float)(*(float *)&a2 - *(float *)(a1 + 32)) - floorf(*(float *)&a2 - *(float *)(a1 + 32)), 1.0)
                * *(float *)a1;
  int v2 = *(_DWORD *)(a1 + 4);
  if ((int)*(float *)&a2 >= v2) {
    int v3 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v3 = (int)*(float *)&a2;
  }
  uint64_t v4 = 12;
  if (v2 > (int)*(float *)&a2) {
    uint64_t v4 = 8;
  }
  *(float *)&a2 = *(float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v3)
                + (float)((float)(*(float *)(*(void *)(a1 + 16)
                                           + *(int *)(a1 + v4)
                                           + (uint64_t)(*(_DWORD *)(a1 + 8) * v3))
                                - *(float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v3))
                        * (float)(*(float *)&a2 - truncf(*(float *)&a2)));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641BD14(uint64_t a1, float a2)
{
  float v2 = fminf((float)(a2 - *(float *)(a1 + 32)) - floorf(a2 - *(float *)(a1 + 32)), 1.0) * *(float *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  if ((int)v2 >= v3) {
    int v4 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v4 = (int)v2;
  }
  uint64_t v5 = 12;
  if (v3 > (int)v2) {
    uint64_t v5 = 8;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(int *)(a1 + 8) * (uint64_t)v4;
  int16x4_t v8 = *(int16x4_t *)(v6 + v7);
  v9.i64[0] = 0x8000000080000000;
  v9.i64[1] = 0x8000000080000000;
  int32x4_t v10 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v8), v9);
  int8x16_t v11 = (int8x16_t)vshll_n_u16((uint16x4_t)v8, 0xDuLL);
  int8x16_t v12 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v13 = (int8x16_t)vdupq_n_s32(0xF800000u);
  int32x4_t v14 = (int32x4_t)vorrq_s8(vandq_s8(v11, v13), vorrq_s8((int8x16_t)v10, vandq_s8(v11, v12)));
  v10.i64[0] = 0x3800000038000000;
  v10.i64[1] = 0x3800000038000000;
  float32x4_t v15 = (float32x4_t)vaddq_s32(v14, v10);
  int16x4_t v16 = *(int16x4_t *)(v6 + *(int *)(a1 + v5) + (uint64_t)(int)v7);
  int8x16_t v17 = vandq_s8((int8x16_t)vmovl_s16(v16), v9);
  int8x16_t v18 = (int8x16_t)vshll_n_u16((uint16x4_t)v16, 0xDuLL);
  *(void *)&double result = vmlaq_n_f32(v15, vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v18, v13), vorrq_s8(v17, vandq_s8(v18, v12))), v10), v15), v2 - truncf(v2)).u64[0];
  return result;
}

double sub_1B641BDE0(uint64_t a1, float a2)
{
  float v2 = fminf((float)(a2 - *(float *)(a1 + 32)) - floorf(a2 - *(float *)(a1 + 32)), 1.0) * *(float *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  if ((int)v2 >= v3) {
    int v4 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v4 = (int)v2;
  }
  uint64_t v5 = 12;
  if (v3 > (int)v2) {
    uint64_t v5 = 8;
  }
  *(void *)&double result = vmlaq_n_f32(*(float32x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4), vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 16)+ *(int *)(a1 + v5)+ (uint64_t)(*(_DWORD *)(a1 + 8) * v4)), *(float32x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v4)), v2 - truncf(v2)).u64[0];
  return result;
}

double sub_1B641BE54(uint64_t a1, double a2, double a3, double a4, float a5)
{
  unsigned int v5 = *(_DWORD *)a1;
  *(float *)&a2 = fminf((float)(*(float *)&a2 - *(float *)(a1 + 32)) - floorf(*(float *)&a2 - *(float *)(a1 + 32)), 1.0)
                * *(float *)a1;
  int v6 = *(_DWORD *)(a1 + 4);
  if ((int)*(float *)&a2 >= v6) {
    int v7 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v7 = (int)*(float *)&a2;
  }
  uint64_t v8 = 12;
  if (v6 > (int)*(float *)&a2) {
    uint64_t v8 = 8;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(int *)(a1 + 8) * (uint64_t)v7;
  LOBYTE(v5) = *(unsigned char *)(v9 + v10);
  LOBYTE(a5) = *(unsigned char *)(v9 + *(int *)(a1 + v8) + (uint64_t)(int)v10);
  *(float *)&a2 = (float)((float)v5 * 0.0039216)
                + (float)((float)-(float)((float)((float)v5 * 0.0039216) - (float)((float)LODWORD(a5) * 0.0039216))
                        * (float)(*(float *)&a2 - truncf(*(float *)&a2)));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641BEE0(uint64_t a1, float a2, double a3, double a4, float a5)
{
  LODWORD(a3) = *(_DWORD *)a1;
  float v5 = fminf((float)(a2 - *(float *)(a1 + 32)) - floorf(a2 - *(float *)(a1 + 32)), 1.0) * *(float *)a1;
  int v6 = *(_DWORD *)(a1 + 4);
  if ((int)v5 >= v6) {
    int v7 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v7 = (int)v5;
  }
  uint64_t v8 = 12;
  if (v6 > (int)v5) {
    uint64_t v8 = 8;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(int *)(a1 + 8) * (uint64_t)v7;
  LOBYTE(a3) = *(unsigned char *)(v9 + v10);
  LOBYTE(a5) = *(unsigned char *)(v9 + *(int *)(a1 + v8) + (uint64_t)(int)v10);
  *(float *)&a3 = (float)((float)LODWORD(a3) * 0.0039216)
                + (float)((float)-(float)((float)((float)LODWORD(a3) * 0.0039216)
                                        - (float)((float)LODWORD(a5) * 0.0039216))
                        * (float)(v5 - truncf(v5)));
  int32x4_t v11 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v11.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v11), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)&a3), *(float *)&a3 * *(float *)&a3), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)&a3),
                                        *(float *)&a3 * *(float *)&a3),
                                      (float)(*(float *)&a3 * *(float *)&a3) * (float)(*(float *)&a3 * *(float *)&a3)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)&a3)).u64[0];
  return result;
}

double sub_1B641C020(uint64_t a1, float a2)
{
  float v2 = fminf((float)(a2 - *(float *)(a1 + 32)) - floorf(a2 - *(float *)(a1 + 32)), 1.0) * *(float *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  int v4 = *(_DWORD *)(a1 + 8);
  if ((int)v2 >= v3) {
    int v5 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v5 = (int)v2;
  }
  uint64_t v6 = 12;
  if (v3 > (int)v2) {
    uint64_t v6 = 8;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = (const float *)(v7 + v4 * (uint64_t)v5);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v12 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), v11);
  int8x16_t v13 = (const float *)(v7 + *(int *)(a1 + v6) + (uint64_t)(v4 * v5));
  uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(v13);
  *(void *)&double result = vmlaq_n_f32(v12, vmlaq_f32(vnegq_f32(v12), v11, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_1B6E50360), v10))), v2 - truncf(v2)).u64[0];
  return result;
}

double sub_1B641C0D4(uint64_t a1, float a2)
{
  float v2 = fminf((float)(a2 - *(float *)(a1 + 32)) - floorf(a2 - *(float *)(a1 + 32)), 1.0) * *(float *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  int v4 = *(_DWORD *)(a1 + 8);
  if ((int)v2 >= v3) {
    int v5 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v5 = (int)v2;
  }
  uint64_t v6 = 12;
  if (v3 > (int)v2) {
    uint64_t v6 = 8;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = v4 * v5;
  uint32x4_t v9 = (const float *)(v7 + v4 * (uint64_t)v5);
  uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v13 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_1B6E50360), v11)), v12);
  uint32x4_t v14 = (const float *)(v7 + *(int *)(a1 + v6) + (uint64_t)v8);
  uint32x4_t v15 = (uint32x4_t)vld1q_dup_f32(v14);
  float32x4_t v16 = vmlaq_n_f32(v13, vmlaq_f32(vnegq_f32(v13), v12, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v15, (uint32x4_t)xmmword_1B6E50360), v11))), v2 - truncf(v2));
  float32x4_t v17 = vmulq_f32(v16, v16);
  int32x4_t v18 = vcgeq_f32(v16, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v18.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v18), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v16), v17, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v16)), vmulq_f32(v17, v17), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v16), v17,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v16))), (int8x16_t)vmulq_f32(v16, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B641C23C(uint64_t a1, float a2)
{
  float v2 = fminf((float)(a2 - *(float *)(a1 + 32)) - floorf(a2 - *(float *)(a1 + 32)), 1.0) * *(float *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  int v4 = *(_DWORD *)(a1 + 8);
  if ((int)v2 >= v3) {
    int v5 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v5 = (int)v2;
  }
  uint64_t v6 = 12;
  if (v3 > (int)v2) {
    uint64_t v6 = 8;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = v4 * v5;
  uint32x4_t v9 = (const float *)(v7 + v4 * (uint64_t)v5);
  uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v13 = (const float *)(v7 + *(int *)(a1 + v6) + (uint64_t)v8);
  uint32x4_t v14 = (uint32x4_t)vld1q_dup_f32(v13);
  float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_1B6E50360), v11)), v12);
  int8x16_t v16 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v12, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v14, (uint32x4_t)xmmword_1B6E50360), v11))), v2 - truncf(v2)));
  *(void *)&double result = vextq_s8(v16, v16, 0xCuLL).u64[0];
  return result;
}

double sub_1B641C2F8(uint64_t a1, float a2)
{
  float v2 = fminf((float)(a2 - *(float *)(a1 + 32)) - floorf(a2 - *(float *)(a1 + 32)), 1.0) * *(float *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  int v4 = *(_DWORD *)(a1 + 8);
  if ((int)v2 >= v3) {
    int v5 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v5 = (int)v2;
  }
  uint64_t v6 = 12;
  if (v3 > (int)v2) {
    uint64_t v6 = 8;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = v4 * v5;
  uint32x4_t v9 = (const float *)(v7 + v4 * (uint64_t)v5);
  uint32x4_t v10 = (uint32x4_t)vld1q_dup_f32(v9);
  v11.i64[0] = 0xFF000000FFLL;
  v11.i64[1] = 0xFF000000FFLL;
  float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v13 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v10, (uint32x4_t)xmmword_1B6E50360), v11)), v12);
  uint32x4_t v14 = (const float *)(v7 + *(int *)(a1 + v6) + (uint64_t)v8);
  uint32x4_t v15 = (uint32x4_t)vld1q_dup_f32(v14);
  float32x4_t v16 = vmlaq_n_f32(v13, vmlaq_f32(vnegq_f32(v13), v12, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v15, (uint32x4_t)xmmword_1B6E50360), v11))), v2 - truncf(v2));
  float32x4_t v17 = vmulq_f32(v16, v16);
  int32x4_t v18 = vcgeq_f32(v16, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v18.i32[3] = 0;
  int32x4_t v19 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v18), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v16), v17, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v16)), vmulq_f32(v17, v17), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v16), v17,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v16))), (int8x16_t)vmulq_f32(v16, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v19.i32[3] = v16.i32[3];
  int8x16_t v20 = (int8x16_t)vrev64q_s32(v19);
  *(void *)&double result = vextq_s8(v20, v20, 0xCuLL).u64[0];
  return result;
}

double sub_1B641C468(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float v4 = (float)((float)(a2.f32[0] - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v5 = vabds_f32(0.5, fminf(v4 - floorf(v4), 1.0));
  a2.f32[0] = *(float *)a1 * (float)(v5 + v5);
  int v6 = *(_DWORD *)(a1 + 4);
  if ((int)a2.f32[0] >= v6) {
    int v7 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v7 = (int)a2.f32[0];
  }
  uint64_t v8 = 12;
  if (v6 > (int)a2.f32[0]) {
    uint64_t v8 = 8;
  }
  uint64_t v9 = *(int *)(a1 + v8);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(int *)(a1 + 8) * (uint64_t)v7;
  unsigned int v12 = *(unsigned __int16 *)(v10 + v11);
  int v13 = (v12 >> 10) & 0x1F;
  if (v13 == 31) {
    int v14 = 2139095040;
  }
  else {
    int v14 = (v12 >> 10) & 0x1F;
  }
  if (v13) {
    BOOL v15 = v13 == 31;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15) {
    int v16 = v14;
  }
  else {
    int v16 = (v13 << 23) + 939524096;
  }
  unsigned int v17 = *(unsigned __int16 *)(v10 + v9 + (int)v11);
  int v18 = (v17 >> 10) & 0x1F;
  if (v18 == 31) {
    int v19 = 2139095040;
  }
  else {
    int v19 = (v17 >> 10) & 0x1F;
  }
  if (v18) {
    BOOL v20 = v18 == 31;
  }
  else {
    BOOL v20 = 1;
  }
  if (v20) {
    int v21 = v19;
  }
  else {
    int v21 = (v18 << 23) + 939524096;
  }
  a3.i32[0] = v16 | (v12 << 16) & 0x80000000 | (v12 >> 7) & 7 | (8 * (v12 & 0x3FF)) & 0x1FFF | ((v12 & 0x3FF) << 13);
  a4.i32[0] = v21 | (v17 << 16) & 0x80000000 | (v17 >> 7) & 7 | (8 * (v17 & 0x3FF)) & 0x1FFF | ((v17 & 0x3FF) << 13);
  a2.f32[0] = a2.f32[0] - truncf(a2.f32[0]);
  a2.i64[0] = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmlaq_f32(a3, a2, vsubq_f32(a4, a3)), 0).u64[0];
  return *(double *)a2.i64;
}

double sub_1B641C578(uint64_t a1, double a2)
{
  float v2 = (float)((float)(*(float *)&a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v3 = vabds_f32(0.5, fminf(v2 - floorf(v2), 1.0));
  *(float *)&a2 = *(float *)a1 * (float)(v3 + v3);
  int v4 = *(_DWORD *)(a1 + 4);
  if ((int)*(float *)&a2 >= v4) {
    int v5 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v5 = (int)*(float *)&a2;
  }
  uint64_t v6 = 12;
  if (v4 > (int)*(float *)&a2) {
    uint64_t v6 = 8;
  }
  *(float *)&a2 = *(float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v5)
                + (float)((float)(*(float *)&a2 - truncf(*(float *)&a2))
                        * (float)(*(float *)(*(void *)(a1 + 16)
                                           + *(int *)(a1 + v6)
                                           + (uint64_t)(*(_DWORD *)(a1 + 8) * v5))
                                - *(float *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v5)));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641C600(uint64_t a1, float a2)
{
  float v2 = (float)((float)(a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v3 = vabds_f32(0.5, fminf(v2 - floorf(v2), 1.0));
  float v4 = *(float *)a1 * (float)(v3 + v3);
  int v5 = *(_DWORD *)(a1 + 4);
  if ((int)v4 >= v5) {
    int v6 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v6 = (int)v4;
  }
  uint64_t v7 = 12;
  if (v5 > (int)v4) {
    uint64_t v7 = 8;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(int *)(a1 + 8) * (uint64_t)v6;
  int16x4_t v10 = *(int16x4_t *)(v8 + v9);
  v11.i64[0] = 0x8000000080000000;
  v11.i64[1] = 0x8000000080000000;
  int32x4_t v12 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(v10), v11);
  int8x16_t v13 = (int8x16_t)vshll_n_u16((uint16x4_t)v10, 0xDuLL);
  int8x16_t v14 = (int8x16_t)vdupq_n_s32(0x7FE000u);
  int8x16_t v15 = (int8x16_t)vdupq_n_s32(0xF800000u);
  int32x4_t v16 = (int32x4_t)vorrq_s8(vandq_s8(v13, v15), vorrq_s8((int8x16_t)v12, vandq_s8(v13, v14)));
  v12.i64[0] = 0x3800000038000000;
  v12.i64[1] = 0x3800000038000000;
  float32x4_t v17 = (float32x4_t)vaddq_s32(v16, v12);
  int16x4_t v18 = *(int16x4_t *)(v8 + *(int *)(a1 + v7) + (uint64_t)(int)v9);
  int8x16_t v19 = vandq_s8((int8x16_t)vmovl_s16(v18), v11);
  int8x16_t v20 = (int8x16_t)vshll_n_u16((uint16x4_t)v18, 0xDuLL);
  *(void *)&double result = vmlaq_n_f32(v17, vsubq_f32((float32x4_t)vaddq_s32((int32x4_t)vorrq_s8(vandq_s8(v20, v15), vorrq_s8(v19, vandq_s8(v20, v14))), v12), v17), v4 - truncf(v4)).u64[0];
  return result;
}

double sub_1B641C6DC(uint64_t a1, float a2)
{
  float v2 = (float)((float)(a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v3 = vabds_f32(0.5, fminf(v2 - floorf(v2), 1.0));
  float v4 = *(float *)a1 * (float)(v3 + v3);
  int v5 = *(_DWORD *)(a1 + 4);
  if ((int)v4 >= v5) {
    int v6 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v6 = (int)v4;
  }
  uint64_t v7 = 12;
  if (v5 > (int)v4) {
    uint64_t v7 = 8;
  }
  *(void *)&double result = vmlaq_n_f32(*(float32x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v6), vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 16)+ *(int *)(a1 + v7)+ (uint64_t)(*(_DWORD *)(a1 + 8) * v6)), *(float32x4_t *)(*(void *)(a1 + 16) + *(int *)(a1 + 8) * (uint64_t)v6)), v4 - truncf(v4)).u64[0];
  return result;
}

double sub_1B641C760(uint64_t a1, double a2, double a3, double a4, float a5)
{
  float v5 = (float)((float)(*(float *)&a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v6 = vabds_f32(0.5, fminf(v5 - floorf(v5), 1.0));
  unsigned int v7 = *(_DWORD *)a1;
  *(float *)&a2 = *(float *)a1 * (float)(v6 + v6);
  int v8 = *(_DWORD *)(a1 + 4);
  if ((int)*(float *)&a2 >= v8) {
    int v9 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v9 = (int)*(float *)&a2;
  }
  uint64_t v10 = 12;
  if (v8 > (int)*(float *)&a2) {
    uint64_t v10 = 8;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(int *)(a1 + 8) * (uint64_t)v9;
  LOBYTE(v7) = *(unsigned char *)(v11 + v12);
  LOBYTE(a5) = *(unsigned char *)(v11 + *(int *)(a1 + v10) + (uint64_t)(int)v12);
  *(float *)&a2 = (float)((float)v7 * 0.0039216)
                + (float)((float)(*(float *)&a2 - truncf(*(float *)&a2))
                        * (float)-(float)((float)((float)v7 * 0.0039216) - (float)((float)LODWORD(a5) * 0.0039216)));
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double sub_1B641C7FC(uint64_t a1, float a2, double a3, double a4, float a5)
{
  float v5 = (float)((float)(a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v6 = vabds_f32(0.5, fminf(v5 - floorf(v5), 1.0));
  LODWORD(a3) = *(_DWORD *)a1;
  float v7 = *(float *)a1 * (float)(v6 + v6);
  int v8 = *(_DWORD *)(a1 + 4);
  if ((int)v7 >= v8) {
    int v9 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v9 = (int)v7;
  }
  uint64_t v10 = 12;
  if (v8 > (int)v7) {
    uint64_t v10 = 8;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(int *)(a1 + 8) * (uint64_t)v9;
  LOBYTE(a3) = *(unsigned char *)(v11 + v12);
  LOBYTE(a5) = *(unsigned char *)(v11 + *(int *)(a1 + v10) + (uint64_t)(int)v12);
  *(float *)&a3 = (float)((float)LODWORD(a3) * 0.0039216)
                + (float)((float)(v7 - truncf(v7))
                        * (float)-(float)((float)((float)LODWORD(a3) * 0.0039216)
                                        - (float)((float)LODWORD(a5) * 0.0039216)));
  int32x4_t v13 = vcgeq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v13.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v13), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)&a3), *(float *)&a3 * *(float *)&a3), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)&a3), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)&a3),
                                        *(float *)&a3 * *(float *)&a3),
                                      (float)(*(float *)&a3 * *(float *)&a3) * (float)(*(float *)&a3 * *(float *)&a3)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)&a3)).u64[0];
  return result;
}

double sub_1B641C94C(uint64_t a1, float a2)
{
  float v2 = (float)((float)(a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v3 = vabds_f32(0.5, fminf(v2 - floorf(v2), 1.0));
  float v4 = *(float *)a1 * (float)(v3 + v3);
  int v5 = *(_DWORD *)(a1 + 4);
  int v6 = *(_DWORD *)(a1 + 8);
  if ((int)v4 >= v5) {
    int v7 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v7 = (int)v4;
  }
  uint64_t v8 = 12;
  if (v5 > (int)v4) {
    uint64_t v8 = 8;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = (const float *)(v9 + v6 * (uint64_t)v7);
  uint32x4_t v11 = (uint32x4_t)vld1q_dup_f32(v10);
  v12.i64[0] = 0xFF000000FFLL;
  v12.i64[1] = 0xFF000000FFLL;
  float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v14 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)xmmword_1B6E50360), v12)), v13);
  int8x16_t v15 = (const float *)(v9 + *(int *)(a1 + v8) + (uint64_t)(v6 * v7));
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v15);
  *(void *)&double result = vmlaq_n_f32(v14, vmlaq_f32(vnegq_f32(v14), v13, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v12))), v4 - truncf(v4)).u64[0];
  return result;
}

double sub_1B641CA10(uint64_t a1, float a2)
{
  float v2 = (float)((float)(a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v3 = vabds_f32(0.5, fminf(v2 - floorf(v2), 1.0));
  float v4 = *(float *)a1 * (float)(v3 + v3);
  int v5 = *(_DWORD *)(a1 + 4);
  int v6 = *(_DWORD *)(a1 + 8);
  if ((int)v4 >= v5) {
    int v7 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v7 = (int)v4;
  }
  uint64_t v8 = 12;
  if (v5 > (int)v4) {
    uint64_t v8 = 8;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = v6 * v7;
  uint32x4_t v11 = (const float *)(v9 + v6 * (uint64_t)v7);
  uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
  v13.i64[0] = 0xFF000000FFLL;
  v13.i64[1] = 0xFF000000FFLL;
  float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
  uint32x4_t v16 = (const float *)(v9 + *(int *)(a1 + v8) + (uint64_t)v10);
  uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
  float32x4_t v18 = vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v13))), v4 - truncf(v4));
  float32x4_t v19 = vmulq_f32(v18, v18);
  int32x4_t v20 = vcgeq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v20.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v20), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v18), v19, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v18)), vmulq_f32(v19, v19), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v18), v19,
                                        vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v18))), (int8x16_t)vmulq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D9E8391u))).u64[0];
  return result;
}

double sub_1B641CB88(uint64_t a1, float a2)
{
  float v2 = (float)((float)(a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v3 = vabds_f32(0.5, fminf(v2 - floorf(v2), 1.0));
  float v4 = *(float *)a1 * (float)(v3 + v3);
  int v5 = *(_DWORD *)(a1 + 4);
  int v6 = *(_DWORD *)(a1 + 8);
  if ((int)v4 >= v5) {
    int v7 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v7 = (int)v4;
  }
  uint64_t v8 = 12;
  if (v5 > (int)v4) {
    uint64_t v8 = 8;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = v6 * v7;
  uint32x4_t v11 = (const float *)(v9 + v6 * (uint64_t)v7);
  uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
  v13.i64[0] = 0xFF000000FFLL;
  v13.i64[1] = 0xFF000000FFLL;
  float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v15 = (const float *)(v9 + *(int *)(a1 + v8) + (uint64_t)v10);
  uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v15);
  float32x4_t v17 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
  int8x16_t v18 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_n_f32(v17, vmlaq_f32(vnegq_f32(v17), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v16, (uint32x4_t)xmmword_1B6E50360), v13))), v4 - truncf(v4)));
  *(void *)&double result = vextq_s8(v18, v18, 0xCuLL).u64[0];
  return result;
}

double sub_1B641CC54(uint64_t a1, float a2)
{
  float v2 = (float)((float)(a2 - *(float *)(a1 + 32)) * 0.5) + 0.5;
  float v3 = vabds_f32(0.5, fminf(v2 - floorf(v2), 1.0));
  float v4 = *(float *)a1 * (float)(v3 + v3);
  int v5 = *(_DWORD *)(a1 + 4);
  int v6 = *(_DWORD *)(a1 + 8);
  if ((int)v4 >= v5) {
    int v7 = *(_DWORD *)(a1 + 4);
  }
  else {
    int v7 = (int)v4;
  }
  uint64_t v8 = 12;
  if (v5 > (int)v4) {
    uint64_t v8 = 8;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = v6 * v7;
  uint32x4_t v11 = (const float *)(v9 + v6 * (uint64_t)v7);
  uint32x4_t v12 = (uint32x4_t)vld1q_dup_f32(v11);
  v13.i64[0] = 0xFF000000FFLL;
  v13.i64[1] = 0xFF000000FFLL;
  float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v15 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)xmmword_1B6E50360), v13)), v14);
  uint32x4_t v16 = (const float *)(v9 + *(int *)(a1 + v8) + (uint64_t)v10);
  uint32x4_t v17 = (uint32x4_t)vld1q_dup_f32(v16);
  float32x4_t v18 = vmlaq_n_f32(v15, vmlaq_f32(vnegq_f32(v15), v14, vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B6E50360), v13))), v4 - truncf(v4));
  float32x4_t v19 = vmulq_f32(v18, v18);
  int32x4_t v20 = vcgeq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v20.i32[3] = 0;
  int32x4_t v21 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v20), (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), v18), v19, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), v18)), vmulq_f32(v19, v19), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), v18), v19,
                                    vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)vdupq_n_s32(0x3E1C096Eu), v18))), (int8x16_t)vmulq_f32(v18, (float32x4_t)vdupq_n_s32(0x3D9E8391u)));
  v21.i32[3] = v18.i32[3];
  int8x16_t v22 = (int8x16_t)vrev64q_s32(v21);
  *(void *)&double result = vextq_s8(v22, v22, 0xCuLL).u64[0];
  return result;
}

__CFString *sub_1B641CDD4(int a1)
{
  switch(a1)
  {
    case 0:
      v1 = off_1E6141790;
      goto LABEL_10;
    case 1:
      v1 = off_1E6141798;
      goto LABEL_10;
    case 2:
      v1 = off_1E61417A0;
      goto LABEL_10;
    case 3:
      v1 = off_1E61417A8;
      goto LABEL_10;
    case 4:
      v1 = off_1E61417B0;
      goto LABEL_10;
    case 5:
      v1 = off_1E61417B8;
      goto LABEL_10;
    case 6:
      v1 = off_1E61417C0;
LABEL_10:
      double result = *v1;
      break;
    case 7:
      double result = @"vertexCrease";
      break;
    case 8:
      double result = @"edgeCrease";
      break;
    default:
      double result = 0;
      break;
  }
  return result;
}

uint64_t sub_1B641CE9C()
{
  if (qword_1EB995570 != -1) {
    dispatch_once(&qword_1EB995570, &unk_1F0FB5608);
  }
  return qword_1EB995578;
}

void sub_1B641CEE0()
{
  if (!qword_1EB995578)
  {
    qword_1EB995578 = sub_1B63C8D10(&qword_1EB995578);
    qword_1EB984688 = (uint64_t)sub_1B641EF2C;
  }
}

uint64_t sub_1B641CF38()
{
  if (qword_1EB995570 != -1) {
    dispatch_once(&qword_1EB995570, &unk_1F0FB5608);
  }
  CFTypeID v0 = qword_1EB995578;

  return sub_1B63C8D44(v0, 0x58uLL);
}

uint64_t sub_1B641CF98(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v11 = a2;
  uint64_t v13 = sub_1B63CA534(a5, a2, a3, a4, a5, a6, a7, a8) * a4;

  return sub_1B641D00C(v11, a1, a5, a4, a3, v13, 0, v14);
}

uint64_t sub_1B641D00C(__int16 a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12 = a3;
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"data");
  }
  if (a4 >= 5) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. No more than 4 components for mesh source value types", a3, a4, a5, a6, a7, a8, (uint64_t)"componentCount <= 4");
  }
  float32x4_t v15 = (const void *)sub_1B6534714(v12, a4, a5, a6, a7);
  uint64_t v16 = sub_1B641D0F8(v15, a1);
  *(void *)(v16 + 72) = CFRetain(a2);
  sub_1B6534974((uint64_t)v15, v16);
  if (v15) {
    CFRelease(v15);
  }
  return v16;
}

uint64_t sub_1B641D0F8(const void *a1, __int16 a2)
{
  uint64_t v10 = sub_1B641CF38();
  if (!v10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v4, v5, v6, v7, v8, v9, (uint64_t)"meshSource");
  }
  sub_1B6536468(v10, a1, v4, v5, v6, v7, v8, v9);
  *(_WORD *)(v10 + 96) = a2;
  return v10;
}

uint64_t sub_1B641D168(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B641D478(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v11 = v10;
  uint64_t v18 = sub_1B641D478(a2, v10, v12, v13, v14, v15, v16, v17);
  unint64_t v26 = v19;
  if (v11 != v19)
  {
    sub_1B63F2F54(16, @"Error: Morph: target vertex count do not match base vertex count (%d != %d)", v20, v21, v22, v23, v24, v25, v19);
    return 0;
  }
  uint64_t v27 = v18;
  if (v9)
  {
    if (v18) {
      goto LABEL_4;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v20, v21, v22, v23, v24, v25, (uint64_t)"bse.ptr");
    if (v27) {
      goto LABEL_4;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v20, v21, v22, v23, v24, v25, (uint64_t)"tgt.ptr");
LABEL_4:
  if ((v26 & 0xFF000000000000) == 0x1000000000000 && (v11 & 0xFF000000000000) == 0x1000000000000)
  {
    if (HIBYTE(v26) >= 3) {
      uint64_t v28 = 3;
    }
    else {
      uint64_t v28 = HIBYTE(v26);
    }
    float32x4_t v29 = (const UInt8 *)malloc_type_malloc((4 * v28) * (unint64_t)v11, 0x87A03909uLL);
    CFDataRef v37 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v29, (4 * v28) * (unint64_t)v11, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (v11)
    {
      unsigned int v38 = 0;
      unsigned int v39 = 0;
      uint64_t v40 = 0;
      do
      {
        if (v28)
        {
          float32x4_t v41 = (float *)(v27 + v39);
          uint64_t v42 = v28;
          BOOL v43 = (float *)v29;
          float32x2_t v44 = (float *)(v9 + v38);
          do
          {
            float v45 = *v41++;
            float v46 = v45;
            float v47 = *v44++;
            *v43++ = v46 - v47;
            --v42;
          }
          while (v42);
        }
        ++v40;
        v39 += BYTE5(v26);
        v38 += BYTE5(v11);
        v29 += 4 * v28;
      }
      while (v40 != v11);
    }
    if (!a2) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v31, v32, v33, v34, v35, v36, (uint64_t)"meshSource");
    }
    __int16 v48 = *(char *)(a2 + 96);
    uint64_t v49 = sub_1B63CA534(1, v30, v31, v32, v33, v34, v35, v36);
    uint64_t v51 = sub_1B641D00C(v48, v37, 1, v28, v11, v49 * v28, 0, v50);
    CFDataRef v52 = v37;
  }
  else
  {
    uint64_t v90 = sub_1B63CA534(BYTE4(v11), v19, v20, v21, v22, v23, v24, v25);
    unsigned int v54 = (const UInt8 *)malloc_type_malloc(v90 * v11, 0xDD971EDBuLL);
    CFDataRef v89 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v54, v90 * v11, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (v11)
    {
      uint64_t v65 = v27;
      uint64_t v66 = v9;
      unsigned int v67 = 0;
      unsigned int v68 = 0;
      uint64_t v69 = v11;
      do
      {
        *(double *)v70.i64 = sub_1B65D6198(BYTE4(v11), (const float *)(v66 + v67), v56, v57, v58, v59, v60, v61, v62, v63, v64);
        float32x4_t v91 = v70;
        *(double *)v79.i64 = sub_1B65D6198(BYTE4(v26), (const float *)(v65 + v68), v71, v72, v73, v74, v75, v76, v70, v77, v78);
        sub_1B65D6678(BYTE4(v11), (uint64_t)v54, v80, v81, v82, v83, v84, v85, vsubq_f32(v79, v91));
        v68 += BYTE5(v26);
        v67 += BYTE5(v11);
        v54 += v90;
        --v69;
      }
      while (v69);
    }
    if (!a2) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v56, v57, v58, v59, v60, v61, (uint64_t)"meshSource");
    }
    __int16 v86 = *(char *)(a2 + 96);
    uint64_t v87 = sub_1B63CA534(BYTE4(v11), v55, v56, v57, v58, v59, v60, v61);
    uint64_t v51 = sub_1B641D00C(v86, v89, BYTE4(v11), 1, v11, v87, 0, v88);
    CFDataRef v52 = v89;
  }
  CFRelease(v52);
  return v51;
}

uint64_t sub_1B641D478(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)sub_1B6536C44(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = sub_1B6534790((uint64_t)v9, v10, v11, v12, v13, v14, v15, v16);
  uint64_t v18 = 0;
  uint64_t v19 = sub_1B6534800((uint64_t)v9);
  if (v17 && v19)
  {
    if (sub_1B6536C9C(a1)) {
      uint64_t v26 = sub_1B65348F4(v9, 0, v20, v21, v22, v23, v24, v25);
    }
    else {
      uint64_t v26 = (uint64_t)sub_1B6534808(v9, 0, v20, v21, v22, v23, v24, v25);
    }
    uint64_t v18 = v26;
  }
  sub_1B65349B8((uint64_t)v9);
  unsigned int v27 = sub_1B6534654((uint64_t)v9);
  int v28 = sub_1B653465C((uint64_t)v9);
  if (v27 != sub_1B63CA908(v27, v29, v30, v31, v32, v33, v34, v35)) {
    sub_1B63CA958(v27, v36, v37, v38, v39, v40, v41, v42);
  }
  sub_1B63CAA3C(v27, v28, v37, v38, v39, v40, v41, v42);
  return v18;
}

uint64_t sub_1B641D56C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  return *(char *)(a1 + 96);
}

uint64_t sub_1B641D5B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = sub_1B641D478(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = v9;
  if (!v16) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"bse.ptr");
  }
  uint64_t v25 = sub_1B641D478(a2, v9, v10, v11, v12, v13, v14, v15);
  unint64_t v26 = v18;
  if (!v25) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v19, v20, v21, v22, v23, v24, (uint64_t)"dlt.ptr");
  }
  if (v17 != v26) {
    return 0;
  }
  if ((v26 & 0xFF000000000000) == 0x1000000000000 && (v17 & 0xFF000000000000) == 0x1000000000000)
  {
    if (HIBYTE(v26) >= 3) {
      uint64_t v27 = 3;
    }
    else {
      uint64_t v27 = HIBYTE(v26);
    }
    int v28 = (const UInt8 *)malloc_type_malloc((4 * v27) * (unint64_t)v17, 0x5738255BuLL);
    CFDataRef v36 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v28, (4 * v27) * (unint64_t)v17, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (v17)
    {
      unsigned int v37 = 0;
      unsigned int v38 = 0;
      uint64_t v39 = 0;
      do
      {
        if (v27)
        {
          uint64_t v40 = (float *)(v16 + v38);
          uint64_t v41 = v27;
          uint64_t v42 = (float *)v28;
          BOOL v43 = (float *)(v25 + v37);
          do
          {
            float v44 = *v40++;
            float v45 = v44;
            float v46 = *v43++;
            *v42++ = v45 + v46;
            --v41;
          }
          while (v41);
        }
        ++v39;
        v38 += BYTE5(v17);
        v37 += BYTE5(v26);
        v28 += 4 * v27;
      }
      while (v39 != v17);
    }
    if (!a2) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v30, v31, v32, v33, v34, v35, (uint64_t)"meshSource");
    }
    __int16 v47 = *(char *)(a2 + 96);
    uint64_t v48 = sub_1B63CA534(1, v29, v30, v31, v32, v33, v34, v35) * v27;
    __int16 v50 = v47;
    CFDataRef v51 = v36;
    uint64_t v52 = 1;
    uint64_t v53 = v27;
    uint64_t v54 = v17;
  }
  else
  {
    uint64_t v91 = sub_1B63CA534(BYTE4(v17), v18, v19, v20, v21, v22, v23, v24);
    uint64_t v56 = (const UInt8 *)malloc_type_malloc(v91 * v17, 0x78407D6BuLL);
    CFDataRef v90 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v56, v91 * v17, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (v17)
    {
      uint64_t v67 = v25;
      uint64_t v68 = v16;
      unsigned int v69 = 0;
      unsigned int v70 = 0;
      uint64_t v71 = v17;
      do
      {
        *(double *)v72.i64 = sub_1B65D6198(BYTE4(v17), (const float *)(v68 + v69), v58, v59, v60, v61, v62, v63, v64, v65, v66);
        float32x4_t v92 = v72;
        *(double *)v81.i64 = sub_1B65D6198(BYTE4(v26), (const float *)(v67 + v70), v73, v74, v75, v76, v77, v78, v72, v79, v80);
        sub_1B65D6678(BYTE4(v17), (uint64_t)v56, v82, v83, v84, v85, v86, v87, vaddq_f32(v92, v81));
        v70 += BYTE5(v26);
        v69 += BYTE5(v17);
        v56 += v91;
        --v71;
      }
      while (v71);
    }
    if (!a2) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v58, v59, v60, v61, v62, v63, (uint64_t)"meshSource");
    }
    __int16 v88 = *(char *)(a2 + 96);
    uint64_t v48 = sub_1B63CA534(BYTE4(v17), v57, v58, v59, v60, v61, v62, v63);
    __int16 v50 = v88;
    CFDataRef v36 = v90;
    CFDataRef v51 = v90;
    uint64_t v52 = BYTE4(v17);
    uint64_t v53 = 1;
    uint64_t v54 = v17;
  }
  uint64_t v55 = sub_1B641D00C(v50, v51, v52, v53, v54, v48, 0, v49);
  CFRelease(v36);
  return v55;
}

uint64_t sub_1B641D8A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v9 = *(void *)(a1 + 64);

  return sub_1B6534800(v9);
}

uint64_t sub_1B641D8FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"baseSource");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"intervalList");
LABEL_3:
  uint64_t v74 = 0;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v71 = 0u;
  sub_1B63D11F0(a2, a3, a3, a4, a5, a6, a7, a8, (uint64_t)&v71);
  unint64_t v18 = DWORD2(v71);
  if (DWORD2(v71))
  {
    unint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 1;
    do
    {
      switch(BYTE11(v72))
      {
        case 4u:
          int v22 = *(_DWORD *)(v71 + 4 * (*((void *)&v73 + 1) + v74 * (v21 - 1)));
          int v23 = *(_DWORD *)(v71 + 4 * (*((void *)&v73 + 1) + v74 * v21));
          break;
        case 2u:
          int v22 = *(unsigned __int16 *)(v71 + 2 * (*((void *)&v73 + 1) + v74 * (v21 - 1)));
          int v23 = *(unsigned __int16 *)(v71 + 2 * (*((void *)&v73 + 1) + v74 * v21));
          break;
        case 1u:
          int v22 = *(unsigned __int8 *)(v71 + *((void *)&v73 + 1) + v74 * (v21 - 1));
          int v23 = *(unsigned __int8 *)(v71 + *((void *)&v73 + 1) + v74 * v21);
          break;
        default:
          sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", v12, v13, v14, v15, v16, v17, BYTE11(v72));
          int v23 = 0;
          int v22 = 0;
          unint64_t v18 = DWORD2(v71);
          break;
      }
      v20 += (v23 - v22);
      ++v19;
      v21 += 2;
    }
    while (v19 < v18);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v24 = sub_1B641D478(a1, v11, v12, v13, v14, v15, v16, v17);
  unint64_t v26 = v25;
  uint64_t v27 = BYTE5(v25);
  if (BYTE5(v25) != sub_1B63CA534(BYTE4(v25), v25, v28, v29, v30, v31, v32, v33))
  {
    sub_1B63F2F54(16, @"Error: MeshSource packing only supports non interleaved float sources", v34, v35, v36, v37, v38, v39, v69);
    return 0;
  }
  CFIndex v40 = v27 * v20;
  if (!(v27 * v20)) {
    return 0;
  }
  uint64_t v70 = a1;
  __int16 v47 = (const UInt8 *)malloc_type_malloc(v27 * v20, 0xACEA9B4BuLL);
  if (DWORD2(v71))
  {
    unint64_t v48 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 1;
    do
    {
      switch(BYTE11(v72))
      {
        case 4u:
          int v51 = *(_DWORD *)(v71 + 4 * (*((void *)&v73 + 1) + v74 * (v50 - 1)));
          int v52 = *(_DWORD *)(v71 + 4 * (*((void *)&v73 + 1) + v74 * v50));
          break;
        case 2u:
          int v51 = *(unsigned __int16 *)(v71 + 2 * (*((void *)&v73 + 1) + v74 * (v50 - 1)));
          int v52 = *(unsigned __int16 *)(v71 + 2 * (*((void *)&v73 + 1) + v74 * v50));
          break;
        case 1u:
          int v51 = *(unsigned __int8 *)(v71 + *((void *)&v73 + 1) + v74 * (v50 - 1));
          int v52 = *(unsigned __int8 *)(v71 + *((void *)&v73 + 1) + v74 * v50);
          break;
        default:
          sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", v41, v42, v43, v44, v45, v46, BYTE11(v72));
          int v52 = 0;
          int v51 = 0;
          break;
      }
      size_t v53 = (v52 - v51) * BYTE5(v26);
      memcpy((void *)&v47[v49], (const void *)(v24 + v51 * BYTE5(v26)), v53);
      v49 += v53;
      ++v48;
      v50 += 2;
    }
    while (v48 < DWORD2(v71));
  }
  CFDataRef v61 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v47, v40, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v70) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v55, v56, v57, v58, v59, v60, (uint64_t)"meshSource");
  }
  __int16 v62 = *(char *)(v70 + 96);
  uint64_t v63 = HIBYTE(v26);
  uint64_t v64 = BYTE6(v26);
  uint64_t v65 = sub_1B63CA534(v64, v54, v55, v56, v57, v58, v59, v60);
  uint64_t v67 = sub_1B641D00C(v62, v61, v64, v63, v20, v65 * v63, 0, v66);
  CFRelease(v61);
  return v67;
}

double sub_1B641DC34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = sub_1B641D478(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v20 = v19;
  if (v19)
  {
    uint64_t v21 = (const float *)v8;
    int v22 = v9;
    uint64_t v23 = v10;
    float32x4_t v24 = 0uLL;
    do
    {
      float32x4_t v27 = v24;
      v25.i64[0] = COERCE_UNSIGNED_INT64(sub_1B65D6198(v22, v21, v11, v12, v13, v14, v15, v16, v24, v17.f32[0], v18)) & 0x7FFFFFFF7FFFFFFFLL;
      v25.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
      float32x4_t v17 = vmaxnmq_f32(v27, v25);
      float32x4_t v24 = v17;
      uint64_t v21 = (const float *)((char *)v21 + v23);
      --v20;
    }
    while (v20);
  }
  else
  {
    v24.i64[0] = 0;
  }
  return *(double *)v24.i64;
}

uint64_t sub_1B641DCB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B641D478(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if (v9)
    {
      uint64_t v21 = (const float *)result;
      int v22 = v10;
      uint64_t v23 = v11;
      uint64_t v24 = v9 - 1;
      do
      {
        *(double *)v18.i64 = sub_1B65D6198(v22, v21, v12, v13, v14, v15, v16, v17, v18, v19, v20);
        v18.i32[0] = v18.i32[3];
        uint64_t result = v18.f32[3] < 1.0;
        BOOL v25 = v18.f32[3] < 1.0 || v24-- == 0;
        uint64_t v21 = (const float *)((char *)v21 + v23);
      }
      while (!v25);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1B641DD34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, v65);
  }
  uint64_t v12 = sub_1B641D478(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v12) {
    return 0;
  }
  float v20 = (char *)v12;
  unint64_t v21 = v13;
  uint64_t v70 = a1;
  uint64_t v75 = 0;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v72 = 0u;
  sub_1B63D11F0(a2, a4, v14, v15, v16, v17, v18, v19, (uint64_t)&v72);
  if (BYTE10(v73) != 2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Provided mesh element is not an interval list", v23, v24, v25, v26, v27, v28, (uint64_t)"ind.type == kCFXMeshElementTypeLinesArray");
  }
  size_t v29 = sub_1B63CA534(BYTE4(v21), v22, v23, v24, v25, v26, v27, v28);
  uint64_t v71 = a3;
  CFIndex v67 = v29 * a3;
  uint64_t v30 = (const UInt8 *)malloc_type_malloc(v29 * a3, 0x66AA28E1uLL);
  uint64_t v68 = &v66;
  MEMORY[0x1F4188790](v30, v31);
  bzero((char *)&v66 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0), v29);
  unint64_t v69 = v21;
  if (DWORD2(v72))
  {
    unint64_t v38 = 0;
    unsigned int v39 = 0;
    do
    {
      switch(BYTE11(v73))
      {
        case 4u:
          unsigned int v40 = *(_DWORD *)(v72 + 4 * (*((void *)&v74 + 1) + v75 * 2 * v38));
          unsigned int v41 = *(_DWORD *)(v72 + 4 * (*((void *)&v74 + 1) + v75 * ((2 * v38) | 1)));
          break;
        case 2u:
          unsigned int v40 = *(unsigned __int16 *)(v72 + 2 * (*((void *)&v74 + 1) + v75 * 2 * v38));
          unsigned int v41 = *(unsigned __int16 *)(v72 + 2 * (*((void *)&v74 + 1) + v75 * ((2 * v38) | 1)));
          break;
        case 1u:
          unsigned int v40 = *(unsigned __int8 *)(v72 + *((void *)&v74 + 1) + v75 * 2 * v38);
          unsigned int v41 = *(unsigned __int8 *)(v72 + *((void *)&v74 + 1) + v75 * ((2 * v38) | 1));
          break;
        default:
          sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", v32, v33, v34, v35, v36, v37, BYTE11(v73));
          unsigned int v41 = 0;
          unsigned int v40 = 0;
          break;
      }
      unsigned int v42 = v40 - v39;
      if (v40 > v39)
      {
        uint64_t v43 = (UInt8 *)&v30[v29 * v39];
        do
        {
          memcpy(v43, (char *)&v66 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0), v29);
          v43 += v29;
          --v42;
        }
        while (v42);
      }
      unsigned int v44 = v41 - v40;
      if (v41 > v40)
      {
        uint64_t v45 = (UInt8 *)&v30[v29 * v40];
        do
        {
          memcpy(v45, v20, v29);
          v20 += BYTE5(v21);
          v45 += v29;
          --v44;
        }
        while (v44);
      }
      ++v38;
      unsigned int v39 = v41;
    }
    while (v38 < DWORD2(v72));
  }
  else
  {
    unsigned int v41 = 0;
  }
  uint64_t v47 = v71;
  if (v71 > v41)
  {
    uint64_t v48 = v71 - v41;
    uint64_t v49 = (UInt8 *)&v30[v29 * v41];
    do
    {
      memcpy(v49, (char *)&v66 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0), v29);
      v49 += v29;
      --v48;
    }
    while (v48);
  }
  CFDataRef v57 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v30, v67, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  uint64_t v58 = v70;
  if (!v70) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v51, v52, v53, v54, v55, v56, (uint64_t)"meshSource");
  }
  __int16 v59 = *(char *)(v58 + 96);
  uint64_t v60 = HIBYTE(v69);
  uint64_t v61 = BYTE6(v69);
  uint64_t v62 = sub_1B63CA534(BYTE6(v69), v50, v51, v52, v53, v54, v55, v56);
  uint64_t v46 = sub_1B641D00C(v59, v57, v61, v60, v47, v62 * v60, 0, v63);
  CFRelease(v57);
  return v46;
}

uint64_t sub_1B641E0A8(uint64_t a1)
{
  uint64_t v2 = sub_1B641CF38();
  float v3 = (const void *)sub_1B653497C(*(void *)(a1 + 64));
  sub_1B6536468(v2, v3, v4, v5, v6, v7, v8, v9);
  sub_1B6534974((uint64_t)v3, v2);
  CFRelease(v3);
  uint64_t v15 = *(const void **)(a1 + 72);
  uint64_t v16 = *(void *)(a1 + 80);
  if (v16) {
    sub_1B653666C(v2, (uint64_t)v15, v16, v10, v11, v12, v13, v14);
  }
  else {
    sub_1B65365A8(v2, v15, 0, v10, v11, v12, v13, v14);
  }
  *(_WORD *)(v2 + 96) = *(_WORD *)(a1 + 96);
  return v2;
}

uint64_t sub_1B641E128(uint64_t a1)
{
  uint64_t v2 = sub_1B641CF38();
  sub_1B65366C8(a1, v2, v3, v4, v5, v6, v7, v8);
  *(_WORD *)(v2 + 96) = *(_WORD *)(a1 + 96);
  return v2;
}

uint64_t sub_1B641E168(uint64_t a1)
{
  uint64_t v2 = sub_1B641CF38();
  sub_1B65369B4(a1, v2, v3, v4, v5, v6, v7, v8);
  *(_WORD *)(v2 + 96) = *(_WORD *)(a1 + 96);
  return v2;
}

uint64_t sub_1B641E1AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v9 = *(void *)(a1 + 64);

  return sub_1B65349B8(v9);
}

double sub_1B641E208(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v10 = *(void **)(a1 + 64);
  uint64_t v11 = sub_1B6534808(v10, a2, a3, a4, a5, a6, a7, a8);
  if (!v11) {
    return 0.0;
  }
  uint64_t v19 = (const float *)v11;
  int v20 = sub_1B6534780((uint64_t)v10, v12, v13, v14, v15, v16, v17, v18);
  return sub_1B65D6198(v20, v19, v21, v22, v23, v24, v25, v26, v27, v28, v29);
}

double sub_1B641E284(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v10 = *(void **)(a1 + 64);
  uint64_t v11 = (const float *)sub_1B6534808(v10, a2, a3, a4, a5, a6, a7, a8);
  int v19 = sub_1B6534780((uint64_t)v10, v12, v13, v14, v15, v16, v17, v18);
  return sub_1B65D6198(v19, v11, v20, v21, v22, v23, v24, v25, v26, v27, v28);
}

uint64_t sub_1B641E2F4(uint64_t a1)
{
  return sub_1B653465C(*(void *)(a1 + 64));
}

uint64_t sub_1B641E2FC(uint64_t a1)
{
  return sub_1B6534654(*(void *)(a1 + 64));
}

uint64_t sub_1B641E308(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t sub_1B641E310(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1;
  uint64_t v10 = (void *)sub_1B6536C44(a1, a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B6534654((uint64_t)v10) != 1)
  {
    int v19 = @"Error: Conversion from other types than float is not supported";
    goto LABEL_5;
  }
  if (sub_1B65349F4((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17))
  {
    int v19 = @"Error: Conversion of an interleaved source is not supported, please convert your sources before interleaving";
LABEL_5:
    sub_1B63F2F54(16, (uint64_t)v19, v12, v13, v14, v15, v16, v17, v81);
    return 0;
  }
  uint64_t v21 = sub_1B63CA534(a2, v18, v12, v13, v14, v15, v16, v17);
  uint64_t v22 = sub_1B653465C((uint64_t)v10);
  uint64_t v23 = v22 * v21;
  if (((v22 * v21) & 3) != 0) {
    uint64_t v24 = -(v22 * v21) & 3;
  }
  else {
    uint64_t v24 = 0;
  }
  uint64_t v25 = v24 + v23;
  uint64_t v26 = (v24 + v23) * sub_1B6534800((uint64_t)v10);
  float v27 = (char *)sub_1B63CA51C(v26);
  bzero(v27, v26);
  CFDataRef v34 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v27, v26, 0);
  if (!v9) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v28, v29, v30, v31, v32, v33, (uint64_t)"meshSource");
  }
  __int16 v35 = *(char *)(v9 + 96);
  uint64_t v36 = sub_1B653465C((uint64_t)v10);
  uint64_t v37 = sub_1B6534800((uint64_t)v10);
  uint64_t v82 = sub_1B641D00C(v35, v34, a2, v36, v37, v25, 0, v38);
  uint64_t v46 = sub_1B6536C44(v82, v39, v40, v41, v42, v43, v44, v45);
  sub_1B6534CBC(v46, v24);
  if (sub_1B641D8A0(v9, v47, v48, v49, v50, v51, v52, v53) >= 1)
  {
    uint64_t v60 = 0;
    while (1)
    {
      uint64_t v61 = v25;
      uint64_t v62 = v9;
      uint64_t v63 = sub_1B6534808(v10, v60, v54, v55, v56, v57, v58, v59);
      if (sub_1B653465C((uint64_t)v10) >= 1) {
        break;
      }
LABEL_34:
      ++v60;
      uint64_t v9 = v62;
      uint64_t v25 = v61;
      v27 += v61;
      if (v60 >= sub_1B641D8A0(v62, v64, v65, v66, v67, v68, v69, v70)) {
        goto LABEL_35;
      }
    }
    uint64_t v71 = 0;
    while (1)
    {
      if ((int)a2 > 13)
      {
        if (a2 == 14)
        {
          int v75 = HIWORD(*(_DWORD *)v63) & 0x8000;
          unsigned int v76 = (*(_DWORD *)v63 >> 23);
          unsigned int v77 = v76 - 112;
          unsigned int v78 = v76 - 113;
          __int16 v79 = v75 | 0x7BFF;
          if (v76 == 255) {
            __int16 v79 = v75 | ((*(_DWORD *)v63 & 0x7FFFFF) != 0) | 0x7C00;
          }
          if (v76 >= 0x71) {
            __int16 v80 = v79;
          }
          else {
            __int16 v80 = HIWORD(*(_DWORD *)v63) & 0x8000;
          }
          int v72 = HIWORD(*(_DWORD *)v63) & 0x8000 | (*(_DWORD *)v63 >> 13) & 0x3FF | (v77 << 10);
          if (v78 > 0x1D) {
            LOWORD(v72) = v80;
          }
LABEL_31:
          *(_WORD *)&v27[2 * v71] = v72;
          goto LABEL_33;
        }
        if (a2 != 15)
        {
LABEL_32:
          sub_1B63F2F54(16, @"Error: CFXMeshSourceCreateCopyWithComponentsBaseType: unsupported type", v65, v66, v67, v68, v69, v70, v81);
          goto LABEL_33;
        }
        float v73 = *(float *)v63;
        float v74 = 255.0;
      }
      else
      {
        if (a2 != 4)
        {
          if (a2 != 13) {
            goto LABEL_32;
          }
          int v72 = (int)(float)(*(float *)v63 * 32767.0);
          goto LABEL_31;
        }
        float v73 = *(float *)v63;
        float v74 = 127.0;
      }
      v27[v71] = (int)(float)(v73 * v74);
LABEL_33:
      ++v71;
      v63 += 4;
      if (sub_1B653465C((uint64_t)v10) <= v71) {
        goto LABEL_34;
      }
    }
  }
LABEL_35:
  CFRelease(v34);
  return v82;
}

uint64_t sub_1B641E5D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  uint64_t v11 = sub_1B641D478(a1, a2, a3, a4, a5, a6, a7, a8);
  unint64_t v13 = v12;
  uint64_t v20 = sub_1B63CAA3C(BYTE6(v12), HIBYTE(v12), v14, v15, v16, v17, v18, v19);
  if (v20 != a2)
  {
    uint64_t v35 = v20;
    uint64_t v36 = sub_1B63CA534(a2, v21, v22, v23, v24, v25, v26, v27);
    uint64_t v43 = v36;
    if ((v36 & 3) != 0) {
      uint64_t v44 = -(int)v36 & 3;
    }
    else {
      uint64_t v44 = 0;
    }
    if (sub_1B65D6000(a2, v35, v37, v38, v39, v40, v41, v42))
    {
      uint64_t v52 = v44 + v43;
      if (v8)
      {
        Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v52 * v13);
        CFDataSetLength(Mutable, v52 * v13);
      }
      else
      {
        uint64_t v69 = (const UInt8 *)malloc_type_calloc(v52 * v13, 1uLL, 0x74359840uLL);
        Mutable = CFDataCreateWithBytesNoCopy(0, v69, v52 * v13, 0);
      }
      BytePtr = CFDataGetBytePtr(Mutable);
      sub_1B65D605C((uint64_t)BytePtr, (unsigned __int16)(v44 + v43) | ((unsigned __int16)a2 << 16) | ((unint64_t)v13 << 32), v11, (v13 >> 16) & 0xFF0000 | BYTE5(v13) | ((unint64_t)v13 << 32), v71, v72, v73, v74);
      if (!a1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v75, v76, v77, v78, v79, v80, (uint64_t)"meshSource");
      }
      uint64_t v28 = sub_1B641D00C(*(char *)(a1 + 96), Mutable, a2, 1, v13, v52, 0, v80);
      CFRelease(Mutable);
      if (v8) {
        sub_1B6536CB8(v28);
      }
      uint64_t v88 = sub_1B6536C44(v28, v81, v82, v83, v84, v85, v86, v87);
      sub_1B6534CBC(v88, v44);
    }
    else
    {
      uint64_t v55 = sub_1B63CA8A4(v35, v45, v46, v47, v48, v49, v50, v51);
      sub_1B63CA8A4(a2, v56, v57, v58, v59, v60, v61, v62);
      sub_1B63F2F54(16, @"Error: Conversion from %@ to %@ to is not supported", v63, v64, v65, v66, v67, v68, (uint64_t)v55);
      return 0;
    }
    return v28;
  }
  if (v8)
  {
    uint64_t v28 = sub_1B641CF38();
    sub_1B65369B4(a1, v28, v29, v30, v31, v32, v33, v34);
    *(_WORD *)(v28 + 96) = *(_WORD *)(a1 + 96);
    return v28;
  }

  return sub_1B641E0A8(a1);
}

size_t sub_1B641E7F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t result = sub_1B641D478(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    size_t v18 = result;
    uint64_t v19 = v11;
    if (!a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"meshSource");
    }
    uint64_t v20 = sub_1B641CDD4(*(char *)(a1 + 96));
    uint64_t v21 = (FILE **)MEMORY[0x1E4F143D8];
    uint64_t v22 = (FILE *)*MEMORY[0x1E4F143D8];
    CStringPtr = CFStringGetCStringPtr(v20, 0x600u);
    size_t result = fprintf(v22, "%s\n", CStringPtr);
    uint64_t v24 = v19 >= a2 ? a2 : v19;
    if (v24 >= 1)
    {
      uint64_t v25 = 0;
      while (1)
      {
        if (BYTE4(v19) <= 0x17u)
        {
          switch(BYTE4(v19))
          {
            case 7u:
              uint64_t v28 = *v21;
              goto LABEL_26;
            case 8u:
              uint64_t v27 = *v21;
LABEL_27:
              size_t result = fprintf(v27, "%4d : %+.2f %+.2f %+.2f\n");
              goto LABEL_29;
            case 9u:
              uint64_t v26 = *v21;
LABEL_28:
              size_t result = fprintf(v26, "%4d : %+.2f %+.2f %+.2f %+.2f\n");
              goto LABEL_29;
          }
          goto LABEL_25;
        }
        if (BYTE4(v19) > 0x2Au) {
          break;
        }
        if (BYTE4(v19) != 24)
        {
          if (BYTE4(v19) == 42)
          {
            uint64_t v28 = *v21;
LABEL_26:
            size_t result = fprintf(v28, "%4d : %+.2f %+.2f\n");
            goto LABEL_29;
          }
          goto LABEL_25;
        }
        size_t result = fprintf(*v21, "%4d : %3d %3d %3d %3d\n");
LABEL_29:
        ++v25;
        v18 += BYTE5(v19);
        if (v24 == v25) {
          return result;
        }
      }
      if (BYTE4(v19) == 43)
      {
        uint64_t v27 = *v21;
        goto LABEL_27;
      }
      if (BYTE4(v19) == 44)
      {
        uint64_t v26 = *v21;
        goto LABEL_28;
      }
LABEL_25:
      size_t result = fwrite("type debugging not implemented\n", 0x1FuLL, 1uLL, *v21);
      goto LABEL_29;
    }
  }
  return result;
}

uint64_t sub_1B641ECDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  return *(unsigned __int8 *)(a1 + 99);
}

void sub_1B641ED28(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  *(unsigned char *)(a1 + 99) = a2;
}

id sub_1B641ED7C(uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B6536CC8(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    valuePtr = sub_1B6536AB4(a1, v9, v10, v11, v12, v13, v14, v15);
    CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, @"kCFXNotificationMeshSourceWillDie", v16, 0, 1u);
    CFRelease(v16);
  }
  return sub_1B653623C((uint64_t)a1, (uint64_t)v9, v10, v11, v12, v13, v14, v15);
}

__CFString *sub_1B641EE00(uint64_t a1)
{
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  int v3 = sub_1B6534654(*(void *)(a1 + 64));
  int v4 = sub_1B653465C(*(void *)(a1 + 64));
  uint64_t v12 = sub_1B641D8A0(a1, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v20 = sub_1B6536B50(a1, v13, v14, v15, v16, v17, v18, v19);
  unsigned int v28 = sub_1B6536C90(a1);
  uint64_t v29 = *(void *)(a1 + 64);
  if (v20) {
    uint64_t v30 = sub_1B6536B50(a1, (uint64_t)v21, v22, v23, v24, v25, v26, v27);
  }
  else {
    uint64_t v30 = (uint64_t)sub_1B6536AB4((void *)a1, v21, v22, v23, v24, v25, v26, v27);
  }
  uint64_t v37 = v30;
  int v38 = sub_1B63CAA3C(v3, v4, v31, v32, v33, v34, v35, v36);
  uint64_t v39 = sub_1B641CDD4(*(char *)(a1 + 96));
  uint64_t v47 = sub_1B63CA8A4(v38, v40, v41, v42, v43, v44, v45, v46);
  CFStringAppendFormat(Mutable, 0, @"<CFXMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%d stride:%d", a1, v39, v37, v28, v12, v47, *(unsigned __int8 *)(a1 + 98), v20 != 0, *(void *)(v29 + 48), *(void *)(v29 + 40));
  CFStringAppend(Mutable, @">");
  return Mutable;
}

__CFArray *sub_1B641EF2C(uint64_t a1)
{
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  int v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v17 = 2;
  int valuePtr = 5;
  uint64_t v16 = a1 + 64;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v17);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v16);
  CFDictionarySetValue(v3, @"name", @"accessor");
  CFDictionarySetValue(v3, @"type", v4);
  CFDictionarySetValue(v3, @"address", v6);
  CFDictionarySetValue(v3, @"semantic", v5);
  CFArrayAppendValue(Mutable, v3);
  CFRelease(v5);
  CFRelease(v3);
  CFRelease(v6);
  CFRelease(v4);
  uint64_t v7 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v17 = 2;
  int valuePtr = 5;
  uint64_t v16 = a1 + 72;
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v17);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberLongType, &v16);
  CFDictionarySetValue(v7, @"name", @"data");
  CFDictionarySetValue(v7, @"type", v8);
  CFDictionarySetValue(v7, @"address", v10);
  CFDictionarySetValue(v7, @"semantic", v9);
  CFArrayAppendValue(Mutable, v7);
  CFRelease(v9);
  CFRelease(v7);
  CFRelease(v10);
  CFRelease(v8);
  uint64_t v11 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v17 = 0;
  int valuePtr = 2;
  uint64_t v16 = a1 + 96;
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &v17);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberLongType, &v16);
  CFDictionarySetValue(v11, @"name", @"semantic");
  CFDictionarySetValue(v11, @"type", v12);
  CFDictionarySetValue(v11, @"address", v14);
  CFDictionarySetValue(v11, @"semantic", v13);
  CFArrayAppendValue(Mutable, v11);
  CFRelease(v13);
  CFRelease(v11);
  CFRelease(v14);
  CFRelease(v12);
  return Mutable;
}

uint64_t sub_1B641F61C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateVFXCoreTime_, a3, a4);
}

uint64_t sub_1B641F64C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  CFNumberRef v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA738, memory_order_acquire) & 1) == 0)
  {
    uint64_t v17 = a2;
    uint64_t v18 = a3;
    int v16 = __cxa_guard_acquire(&qword_1E9DDA738);
    CFNumberRef v8 = (void *)&unk_1E9DDA000;
    a2 = v17;
    a3 = v18;
    if (v16)
    {
      qword_1E9DDA730 = (uint64_t)sub_1B64208F8("MOTION_BLUR_FINAL_BLUR", 0x16u);
      __cxa_guard_release(&qword_1E9DDA738);
      CFNumberRef v8 = (void *)&unk_1E9DDA000;
      a2 = v17;
      a3 = v18;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8[230], 0);
  *(void *)a1 = &unk_1F0FB3838;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  long long v9 = *(_OWORD *)(a5 + 136);
  v19[6] = *(_OWORD *)(a5 + 120);
  v19[7] = v9;
  long long v10 = *(_OWORD *)(a5 + 168);
  v19[8] = *(_OWORD *)(a5 + 152);
  v19[9] = v10;
  long long v11 = *(_OWORD *)(a5 + 72);
  v19[2] = *(_OWORD *)(a5 + 56);
  v19[3] = v11;
  long long v12 = *(_OWORD *)(a5 + 104);
  v19[4] = *(_OWORD *)(a5 + 88);
  v19[5] = v12;
  long long v13 = *(_OWORD *)(a5 + 40);
  v19[0] = *(_OWORD *)(a5 + 24);
  v19[1] = v13;
  CFNumberRef v14 = sub_1B63CFDE4(a4, (uint64_t)"MB-Color", v19);
  *(void *)(a1 + 416) = v14;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v14, 0x100000000, 0);
  return a1;
}

void sub_1B641F78C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B641F7A0(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  prof_beginFlame((uint64_t)"Final Blur", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/MotionBlurPass.mm", 32);
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 416));
  uint64_t v6 = *(unsigned __int8 *)(v5 + 9);
  uint64_t v7 = *(void *)(v5 + 16);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v7 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v7 ^ v4)));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  uint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ ((0x9DDFEA08EB382D69 * (v9 ^ v6)) >> 47) ^ (0x9DDFEA08EB382D69 * (v9 ^ v6)))) ^ ((0x9DDFEA08EB382D69 * (v9 ^ ((0x9DDFEA08EB382D69 * (v9 ^ v6)) >> 47) ^ (0x9DDFEA08EB382D69 * (v9 ^ v6)))) >> 47));
  uint64_t v11 = CFX::CrossFrameResourceManager::get(a2[4], v10);
  *(void *)(a1 + 384) = v11;
  if (!v11)
  {
    *(void *)(a1 + 384) = sub_1B641F9BC(a2[4], v10);
    uint64_t v19 = (void *)sub_1B6445900(*(void *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
    uint64_t v23 = objc_msgSend_resourceManager(v19, v20, v21, v22);
    uint64_t v24 = *(void *)(a1 + 384);
    memset(v48, 0, sizeof(v48));
    uint64_t v49 = 0;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    uint64_t v62 = 0;
    long long v64 = 0u;
    uint64_t v65 = 0;
    uint64_t v25 = (void *)sub_1B653EFAC((uint64_t)v23);
    uint64_t v50 = objc_msgSend_frameworkLibrary(v25, v26, v27, v28);
    *(void *)&long long v51 = v7;
    LOBYTE(v56) = v6;
    uint64_t v63 = @"vfx_draw_fullscreen_triangle_VR_pos_uv_uvNorm_vertex";
    *(void *)&long long v64 = @"vfx_motionblur_blur";
    uint64_t v31 = objc_msgSend_newRenderPipelineStateWithDesc_(v23, v29, (uint64_t)v48, v30);
    uint64_t v32 = *(void **)(v24 + 16);
    if (v32 != (void *)v31)
    {
      if (v32) {

      }
      *(void *)(v24 + 16) = v31;
    }
    uint64_t v33 = *(void *)(a1 + 384);
    uint64_t v34 = (void *)sub_1B653EFAC((uint64_t)v23);
    *((void *)&v43 + 1) = objc_msgSend_frameworkLibrary(v34, v35, v36, v37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0);
    *(void *)&long long v44 = v7;
    LOBYTE(v45) = v6;
    *((void *)&v46 + 1) = @"vfx_draw_fullscreen_triangle_VR_pos_uv_uvNorm_vertex";
    *(void *)&long long v47 = @"vfx_motionblur_blur_resize";
    uint64_t v40 = objc_msgSend_newRenderPipelineStateWithDesc_(v23, v38, (uint64_t)&v42, v39);
    uint64_t v41 = *(void **)(v33 + 24);
    if (v41 != (void *)v40)
    {
      if (v41) {

      }
      *(void *)(v33 + 24) = v40;
    }
  }
  prof_endFlame();
}

void sub_1B641F99C(_Unwind_Exception *a1)
{
}

uint64_t sub_1B641F9BC(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B641FA50(uint64_t a1, CFX::GPUResourceManager **a2)
{
  prof_beginFlame((uint64_t)"Final Blur", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/MotionBlurPass.mm", 67);
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), v4, v5, v6, v7, v8, v9, v10);
  uint64_t v15 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  uint64_t v16 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 392));
  int v24 = *v16;
  int v25 = v16[1];
  uint64_t v26 = *(void *)(a1 + 384);
  if (*(unsigned __int16 *)(v26 + 32) == v24 && *(unsigned __int16 *)(v26 + 34) == v25)
  {
    uint64_t v29 = *(void **)(v26 + 16);
    uint64_t v28 = (void **)(v26 + 16);
    uint64_t v27 = v29;
    if (!v29) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v30 = *(void **)(v26 + 24);
    uint64_t v28 = (void **)(v26 + 24);
    uint64_t v27 = v30;
    if (!v30)
    {
LABEL_6:
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v18, v19, v20, v21, v22, v23, (uint64_t)"_ptr != NULL");
      uint64_t v27 = *v28;
    }
  }
  uint64_t v31 = objc_msgSend_state(v27, v17, v18, v19);
  objc_msgSend_setRenderPipelineState_(*(void **)(v15 + 16), v32, v31, v33);
  id Texture = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 392));
  id v35 = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 400));
  id v36 = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 408));
  sub_1B63C6ED0(v15, v35, 0, v37);
  sub_1B63C6ED0(v15, v36, 1, v38);
  sub_1B63C6ED0(v15, Texture, 2, v39);
  long long v43 = xmmword_1B6E4F490;
  long long v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  sub_1B649F334(*(void *)(v15 + 24), &v43, 0x10uLL, &v44);
  objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v15 + 16), v40, v45, v46, 0);
  sub_1B63C6F54(v15, v41);
  uint64_t v42 = *(void *)(a1 + 384);
  *(_WORD *)(v42 + 32) = v24;
  *(_WORD *)(v42 + 34) = v25;
  prof_endFlame();
}

void sub_1B641FBFC(_Unwind_Exception *a1)
{
}

void sub_1B641FC28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA748, memory_order_acquire) & 1) == 0)
  {
    uint64_t v10 = a2;
    uint64_t v11 = a3;
    int v9 = __cxa_guard_acquire(&qword_1E9DDA748);
    uint64_t v7 = &unk_1E9DDA000;
    a2 = v10;
    a3 = v11;
    if (v9)
    {
      byte_1E9DDA740 = 1;
      __cxa_guard_release(&qword_1E9DDA748);
      uint64_t v7 = (unsigned char *)&unk_1E9DDA000;
      a2 = v10;
      a3 = v11;
    }
  }
  if (v7[1856]) {
    uint64_t v8 = 0xF4EC03A93B2E1651;
  }
  else {
    uint64_t v8 = 0;
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v8, 0);
  *(void *)a1 = &unk_1F0FB3BE8;
  *(unsigned char *)(a1 + 376) = *(unsigned char *)(a5 + 16);
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
}

void sub_1B641FCF8(uint64_t *a1, uint64_t a2)
{
  prof_beginFlame((uint64_t)"Neighbor max", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/MotionBlurPass.mm", 130);
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
  a1[48] = v5;
  if (!v5)
  {
    a1[48] = sub_1B641FE00(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
    uint64_t v13 = (void *)sub_1B6445900(a1[46], v6, v7, v8, v9, v10, v11, v12);
    uint64_t v17 = objc_msgSend_resourceManager(v13, v14, v15, v16);
    uint64_t v18 = a1[48];
    uint64_t v23 = objc_msgSend_newComputePipelineStateWithFunctionName_(v17, v19, @"vfx_motionblur_neighbormax_x", v20);
    int v24 = *(void **)(v18 + 16);
    if (v24 != (void *)v23)
    {
      if (v24) {

      }
      *(void *)(v18 + 16) = v23;
    }
    uint64_t v25 = a1[48];
    uint64_t v26 = objc_msgSend_newComputePipelineStateWithFunctionName_(v17, v21, @"vfx_motionblur_neighbormax_y", v22);
    uint64_t v27 = *(void **)(v25 + 24);
    if (v27 != (void *)v26)
    {
      if (v27) {

      }
      *(void *)(v25 + 24) = v26;
    }
  }

  prof_endFlame();
}

void sub_1B641FDE8(_Unwind_Exception *a1)
{
}

uint64_t sub_1B641FE00(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B641FE88(uint64_t a1, uint64_t a2, void **a3)
{
  prof_beginFlame((uint64_t)"Neighbor max", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/MotionBlurPass.mm", 147);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 392));
  id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400));
  objc_msgSend_setTexture_atIndex_(*a3, v8, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(*a3, v9, (uint64_t)v7, 1);
  int v16 = *(unsigned __int8 *)(a1 + 376);
  uint64_t v17 = *(void *)(a1 + 384);
  if (v16)
  {
    uint64_t v20 = *(void *)(v17 + 24);
    uint64_t v19 = (uint64_t *)(v17 + 24);
    uint64_t v18 = v20;
    if (v20) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v21 = *(void *)(v17 + 16);
    uint64_t v19 = (uint64_t *)(v17 + 16);
    uint64_t v18 = v21;
    if (v21) {
      goto LABEL_6;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v10, v11, v12, v13, v14, v15, (uint64_t)"_ptr != NULL");
  uint64_t v18 = *v19;
LABEL_6:
  uint64_t v22 = sub_1B653EFB8(v18);
  objc_msgSend_setComputePipelineState_(*a3, v23, v22, v24);
  objc_msgSend_dispatchOnTexture2DWithoutOptimizedThreadGroupPerGrid_(*a3, v25, (uint64_t)v7, v26);

  prof_endFlame();
}

void sub_1B641FFA0(_Unwind_Exception *a1)
{
}

uint64_t sub_1B641FFB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA758, memory_order_acquire) & 1) == 0)
  {
    uint64_t v15 = a2;
    uint64_t v16 = a3;
    int v14 = __cxa_guard_acquire(&qword_1E9DDA758);
    uint64_t v8 = &unk_1E9DDA000;
    a2 = v15;
    a3 = v16;
    if (v14)
    {
      byte_1E9DDA750 = 1;
      __cxa_guard_release(&qword_1E9DDA758);
      uint64_t v8 = (unsigned char *)&unk_1E9DDA000;
      a2 = v15;
      a3 = v16;
    }
  }
  if (v8[1872]) {
    uint64_t v9 = 0xE171746C2A666EDCLL;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v9, 0);
  *(void *)a1 = &unk_1F0FB3578;
  *(_DWORD *)(a1 + 376) = *(_DWORD *)(a5 + 16);
  *(void *)(a1 + 400) = 0;
  uint64_t v11 = CFX::RG::ResourceIdentifier::finalColor(v10);
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(&v18, v11, *(float *)(a5 + 16));
  if (!BYTE1(v19)) {
    BYTE1(v19) = 1;
  }
  LOBYTE(v19) = 6;
  *((void *)&v19 + 1) = 115;
  LOBYTE(v20) = 1;
  v17[6] = v24;
  v17[7] = v25;
  v17[8] = v26;
  v17[9] = v27;
  v17[4] = v22;
  v17[5] = v23;
  v17[2] = v20;
  v17[3] = v21;
  v17[0] = v18;
  v17[1] = v19;
  uint64_t v12 = sub_1B63CFDE4(a4, (uint64_t)"MB-TileMax", v17);
  *(void *)(a1 + 392) = v12;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v12);
  return a1;
}

void sub_1B6420120(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6420134(uint64_t *a1, uint64_t a2)
{
  prof_beginFlame((uint64_t)"Motion blur tile max", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/MotionBlurPass.mm", 191);
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
  a1[48] = v5;
  if (!v5)
  {
    a1[48] = sub_1B6420208(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
    uint64_t v13 = (void *)sub_1B6445900(a1[46], v6, v7, v8, v9, v10, v11, v12);
    uint64_t v17 = objc_msgSend_resourceManager(v13, v14, v15, v16);
    uint64_t v18 = a1[48];
    uint64_t v21 = objc_msgSend_newComputePipelineStateWithFunctionName_(v17, v19, @"vfx_motionblur_tilemax", v20);
    long long v22 = *(void **)(v18 + 16);
    if (v22 != (void *)v21)
    {
      if (v22) {

      }
      *(void *)(v18 + 16) = v21;
    }
  }

  prof_endFlame();
}

void sub_1B64201F0(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6420208(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B6420290(uint64_t a1, uint64_t a2, void **a3)
{
  prof_beginFlame((uint64_t)"Motion blur tile max", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/MotionBlurPass.mm", 207);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400));
  id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 392));
  objc_msgSend_setTexture_atIndex_(*a3, v8, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(*a3, v9, (uint64_t)v7, 1);
  uint64_t v16 = *(void *)(a1 + 384);
  uint64_t v17 = *(void *)(v16 + 16);
  if (!v17)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v10, v11, v12, v13, v14, v15, (uint64_t)"_ptr != NULL");
    uint64_t v17 = *(void *)(v16 + 16);
  }
  uint64_t v18 = sub_1B653EFB8(v17);
  objc_msgSend_setComputePipelineState_(*a3, v19, v18, v20);
  objc_msgSend_dispatchOnTexture2D_(*a3, v21, (uint64_t)v7, v22);
  unint64_t v26 = 1;
  uint64_t v27 = (uint64_t)v7;
  while (v26 < objc_msgSend_mipmapLevelCount(v7, v23, v24, v25))
  {
    uint64_t v31 = objc_msgSend_pixelFormat(v7, v28, v29, v30);
    uint64_t v35 = objc_msgSend_textureType(v7, v32, v33, v34);
    uint64_t v37 = objc_msgSend_newTextureViewWithPixelFormat_textureType_levels_slices_(v7, v36, v31, v35, v26, 1, 0, 1);
    objc_msgSend_setTexture_atIndex_(*a3, v38, v27, 0);
    objc_msgSend_setTexture_atIndex_(*a3, v39, (uint64_t)v37, 1);
    objc_msgSend_dispatchOnTexture2D_(*a3, v40, (uint64_t)v7, v41);

    ++v26;
    uint64_t v27 = (uint64_t)v37;
  }

  prof_endFlame();
}

void sub_1B642040C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1B642042C(uint64_t *a1, uint64_t *a2)
{
  unint64_t v4 = (_OWORD *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[2]);
  CFX::RG::TextureDescriptorReference::withSampleCount(v4, 1, (uint64_t)v63);
  uint64_t v5 = sub_1B63CFDE4(a1, (uint64_t)"VELOCITY COPY", v63);
  *(void *)&long long v60 = a2[2];
  DWORD2(v60) = 0;
  long long v61 = v5;
  uint64_t v62 = 0x100000000;
  CFX::RG::makeCopyPass(a1, (uint64_t)"Copy velocity input", &v60);
  uint64_t v6 = (_OWORD *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[1]);
  CFX::RG::TextureDescriptorReference::withSampleCount(v6, 1, (uint64_t)v59);
  id v7 = sub_1B63CFDE4(a1, (uint64_t)"COLOR COPY", v59);
  *(void *)&long long v56 = a2[1];
  DWORD2(v56) = 0;
  long long v57 = v7;
  uint64_t v58 = 0x100000000;
  CFX::RG::makeCopyPass(a1, (uint64_t)"Copy color input", &v56);
  uint64_t v8 = *a2;
  uint64_t v29 = "MOTION_BLUR_TILE_MAX_BLUR";
  uint64_t v30 = v8;
  int v31 = 1056964608;
  uint64_t v9 = (uint64_t *)sub_1B642073C(a1, a1, (uint64_t)&v29);
  v9[50] = (uint64_t)v5;
  CFX::RG::Pass::readFrom(v9, v5);
  uint64_t v10 = (_OWORD *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[1]);
  CFX::RG::TextureDescriptorReference::withSampleCount(v10, 1, (uint64_t)&v46);
  LODWORD(v55) = 1015021568;
  *((void *)&v47 + 1) = 115;
  LOBYTE(v48) = 1;
  v45[6] = v52;
  v45[7] = v53;
  v45[4] = v50;
  v45[5] = v51;
  v45[8] = v54;
  v45[9] = v55;
  v45[2] = v48;
  v45[3] = v49;
  v45[0] = v46;
  v45[1] = v47;
  uint64_t v11 = sub_1B63CFDE4(a1, (uint64_t)"MB-TileMaxN-X", v45);
  uint64_t v12 = *a2;
  v44[0] = "MOTION_BLUR_NEIGHBOR_MAX";
  v44[1] = v12;
  v44[2] = 0;
  uint64_t v13 = (uint64_t *)sub_1B6420794(a1, (uint64_t)a1, (uint64_t)v44);
  uint64_t v14 = (CFX::RG::Resource *)v9[49];
  v13[49] = (uint64_t)v14;
  CFX::RG::Pass::readFrom(v13, v14);
  v13[50] = (uint64_t)v11;
  CFX::RG::Pass::writeTo(v13, v11);
  uint64_t v15 = *a2;
  uint64_t v29 = "MOTION_BLUR_NEIGHBOR_MAX";
  uint64_t v30 = v15;
  LOBYTE(v31) = 1;
  uint64_t v16 = (uint64_t *)sub_1B6420794(a1, (uint64_t)a1, (uint64_t)&v29);
  v16[49] = (uint64_t)v11;
  CFX::RG::Pass::readFrom(v16, v11);
  v43[6] = v52;
  v43[7] = v53;
  v43[8] = v54;
  v43[9] = v55;
  v43[2] = v48;
  v43[3] = v49;
  v43[4] = v50;
  v43[5] = v51;
  v43[0] = v46;
  v43[1] = v47;
  uint64_t v17 = sub_1B63CFDE4(a1, (uint64_t)"MB-TileMaxN-XY", v43);
  v16[50] = (uint64_t)v17;
  CFX::RG::Pass::writeTo(v16, v17);
  uint64_t v18 = *a2;
  uint64_t v29 = "MOTION_BLUR_FINAL_BLUR";
  uint64_t v30 = v18;
  LOWORD(v31) = 0;
  long long v19 = (long long *)CFX::RG::Resource::constTextureDesc(v7);
  long long v20 = *v19;
  long long v33 = v19[1];
  long long v32 = v20;
  long long v21 = v19[2];
  long long v22 = v19[3];
  long long v23 = v19[4];
  long long v37 = v19[5];
  long long v36 = v23;
  long long v35 = v22;
  long long v34 = v21;
  long long v24 = v19[6];
  long long v25 = v19[7];
  long long v26 = v19[8];
  long long v41 = v19[9];
  long long v40 = v26;
  long long v39 = v25;
  long long v38 = v24;
  uint64_t v42 = a2[3];
  uint64_t v27 = (uint64_t *)sub_1B64207EC(a1, a1, (uint64_t)&v29);
  v27[49] = (uint64_t)v7;
  CFX::RG::Pass::readFrom(v27, v7);
  v27[50] = (uint64_t)v5;
  CFX::RG::Pass::readFrom(v27, v5);
  v27[51] = (uint64_t)v17;
  CFX::RG::Pass::readFrom(v27, v17);
  return v27;
}

uint64_t sub_1B642073C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6420C3C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6420794(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v8[0] = *a1;
  v8[1] = v5;
  sub_1B6420C9C(v8[0], v5, v8, a2, a3);
  v8[0] = v6;
  sub_1B63C88CC(a1 + 18, v8);
  return v8[0];
}

uint64_t sub_1B64207EC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6420CEC(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6420848(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6420884(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64208C0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B64208F8(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      unint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      size_t result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B64209E4(void *a1)
{
  *a1 = &unk_1F0FB3818;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  return a1;
}

void sub_1B6420A3C(void *a1)
{
  *a1 = &unk_1F0FB3818;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6420AB4(void *a1)
{
  *a1 = &unk_1F0FB3BC8;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  return a1;
}

void sub_1B6420B0C(void *a1)
{
  *a1 = &unk_1F0FB3BC8;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6420B84(void *a1)
{
  *a1 = &unk_1F0FB3558;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6420BD0(void *a1)
{
  *a1 = &unk_1F0FB3558;
  v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6420C3C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x198u, 8u);
  return sub_1B641FFB8(v8, *a3, a3[1], a4, a5);
}

void sub_1B6420C9C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v9[0] = a1;
  v9[1] = a2;
  uint64_t v7 = sub_1B63C8330(v9, 0x198u, 8u);
  sub_1B641FC28(v7, *a3, a3[1], v8, a5);
}

uint64_t sub_1B6420CEC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A8u, 8u);
  return sub_1B641F64C(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6420D4C()
{
  if (qword_1EB9952C8 != -1) {
    dispatch_once(&qword_1EB9952C8, &unk_1F0FB5628);
  }
  return qword_1EB9952D0;
}

double sub_1B6420D90()
{
  if (!qword_1EB9952D0)
  {
    CFTypeID v0 = (void *)sub_1B63C8D10(&qword_1EB9952D0);
    qword_1EB9952D0 = (uint64_t)v0;
    v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E400(@"speed", 0x54u, 1, 0, 0, 0, v2, v3);
    sub_1B660E400(@"blendFactor", 0x50u, 1, 0, 0, 0, v4, v5);
    sub_1B660E3EC();
    double result = *(double *)&xmmword_1F0FB8700;
    xmmword_1EB9838F8 = xmmword_1F0FB8700;
  }
  return result;
}

uint64_t sub_1B6420E48(const void *a1)
{
  if (qword_1EB9952C8 != -1) {
    dispatch_once(&qword_1EB9952C8, &unk_1F0FB5628);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1EB9952D0, 0x50uLL);
  if (v2)
  {
    *(void *)(v2 + 72) = CFArrayCreateMutable(0, 1, MEMORY[0x1E4F1D510]);
    uint64_t v3 = *(const void **)(v2 + 64);
    if (v3 != a1)
    {
      if (v3)
      {
        CFRelease(v3);
        *(void *)(v2 + 64) = 0;
      }
      if (a1) {
        CFTypeRef v4 = CFRetain(a1);
      }
      else {
        CFTypeRef v4 = 0;
      }
      *(void *)(v2 + 64) = v4;
    }
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)(v2 + 80) = _D0;
    *(unsigned char *)(v2 + 88) = 0;
  }
  return v2;
}

CFTypeRef sub_1B6420F00(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 64);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 64) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 64) = result;
  }
  return result;
}

uint64_t sub_1B6420F7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  return *(void *)(a1 + 64);
}

void sub_1B6420FC8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
LABEL_3:
  CFArrayRef v10 = *(const __CFArray **)(a1 + 72);
  v15.length = CFArrayGetCount(v10);
  v15.location = 0;
  CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v10, v15, a2);
  if (FirstIndexOfValue != -1)
  {
    CFIndex v12 = FirstIndexOfValue;
    sub_1B6438910((uint64_t)a2, 0);
    uint64_t v13 = *(__CFArray **)(a1 + 72);
    CFArrayRemoveValueAtIndex(v13, v12);
  }
}

double sub_1B64210A8(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), value);
  sub_1B6438910((uint64_t)value, a1);
  uint64_t v16 = sub_1B6438908((uint64_t)value);
  if (!v16) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"animationManager");
  }
  if (!*(unsigned char *)(a1 + 88)) {
    sub_1B6423784(v16, (uint64_t)value, v10, v11, v12, v13, v14, v15);
  }
  double result = *(double *)(a1 + 80);
  *((double *)value + 6) = result;
  return result;
}

void sub_1B642115C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animationPlayer");
  }
  if (*(float *)(a1 + 84) != a2)
  {
    *(float *)(a1 + 84) = a2;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
        sub_1B643946C((uint64_t)ValueAtIndex, v15, v16, v17, v18, v19, v20, v21, a2);
      }
    }
  }
}

float sub_1B6421200(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  return *(float *)(a1 + 84);
}

void sub_1B642124C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animationPlayer");
  }
  if (*(float *)(a1 + 80) != a2)
  {
    *(float *)(a1 + 80) = a2;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
        *((float *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i) + 12) = a2;
    }
  }
}

float sub_1B64212EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  return *(float *)(a1 + 80);
}

void sub_1B6421338(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  if (*(unsigned __int8 *)(a1 + 88) != a2)
  {
    *(unsigned char *)(a1 + 88) = a2;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0; i != v11; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
        uint64_t v14 = sub_1B6438908((uint64_t)ValueAtIndex);
        if (v14)
        {
          uint64_t v15 = v14;
          sub_1B65C26E4();
          sub_1B6424274(v15, (uint64_t)ValueAtIndex, a2, 0, v16, v17, v18, v19, v20);
        }
      }
    }
  }
}

uint64_t sub_1B64213FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  return *(unsigned __int8 *)(a1 + 88);
}

CFIndex sub_1B6421448(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  *(unsigned char *)(a1 + 88) = 0;
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (result >= 1)
  {
    CFIndex v10 = result;
    for (CFIndex i = 0; i != v10; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      CFIndex result = sub_1B6438908((uint64_t)ValueAtIndex);
      if (result) {
        CFIndex result = sub_1B6423784(result, (uint64_t)ValueAtIndex, v13, v14, v15, v16, v17, v18);
      }
    }
  }
  return result;
}

CFIndex sub_1B64214E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  *(unsigned char *)(a1 + 88) = 1;
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (result >= 1)
  {
    CFIndex v10 = result;
    for (CFIndex i = 0; i != v10; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      CFIndex result = sub_1B6438908((uint64_t)ValueAtIndex);
      if (result) {
        CFIndex result = sub_1B6424144(result, (uint64_t)ValueAtIndex, v13, v14, v15, v16, v17, v18, 0.0);
      }
    }
  }
  return result;
}

CFIndex sub_1B6421580(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animationPlayer");
  }
  *(unsigned char *)(a1 + 88) = 1;
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (result >= 1)
  {
    CFIndex v12 = result;
    for (CFIndex i = 0; i != v12; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      CFIndex result = sub_1B6438908((uint64_t)ValueAtIndex);
      if (result) {
        CFIndex result = sub_1B6424144(result, (uint64_t)ValueAtIndex, v15, v16, v17, v18, v19, v20, a2);
      }
    }
  }
  return result;
}

void sub_1B642162C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  *(unsigned char *)(a1 + 89) = a2;
}

uint64_t sub_1B642167C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationPlayer");
  }
  return *(unsigned __int8 *)(a1 + 89);
}

void sub_1B64216CC(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), i);
      sub_1B6438910((uint64_t)ValueAtIndex, 0);
    }
  }
  uint64_t v6 = *(const void **)(a1 + 64);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 72);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 72) = 0;
  }
}

CFStringRef sub_1B642174C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationPlayer %p>", a1);
}

CFStringRef sub_1B642178C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationPlayer %p>", a1);
}

void sub_1B64217CC(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 + 84 == a2)
  {
    sub_1B642115C(a1, *a3, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  else if (a1 + 80 == a2)
  {
    sub_1B642124C(a1, *a3, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B64217F8()
{
  if (!qword_1E9DDA760) {
    qword_1E9DDA760 = sub_1B63C8D10(&qword_1E9DDA760);
  }
}

uint64_t sub_1B642183C()
{
  if (qword_1E9DDA768 != -1) {
    dispatch_once(&qword_1E9DDA768, &unk_1F0FB5648);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1E9DDA760, 0xA0uLL);
  if (v0)
  {
    *(void *)(v0 + 24) = sub_1B6621374(256, 64);
    *(void *)(v0 + 32) = CFDictionaryCreateMutable(0, 0, 0, 0);
    *(void *)(v0 + 48) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
    *(void *)(v0 + 56) = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
    *(void *)(v0 + 80) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    *(void *)(v0 + 112) = sub_1B661DE68(40, 64);
    *(_DWORD *)(v0 + 64) = 0;
  }
  return v0;
}

uint64_t sub_1B6421924(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_17:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_18;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  if (!a2) {
    goto LABEL_17;
  }
LABEL_3:
  if (a3) {
    goto LABEL_4;
  }
LABEL_18:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"target");
LABEL_4:
  uint64_t v11 = sub_1B6438704(a2, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v24 = sub_1B6493A4C((CFTypeRef)v11, (uint64_t)a3, v12, v13, v14, v15, v16, v17);
  if (v24)
  {
    sub_1B6439544(a2, a3);
    if (sub_1B6493708((unsigned char *)v11)) {
      int v25 = 4096;
    }
    else {
      int v25 = 0;
    }
    *(_DWORD *)(a2 + 121) = *(_DWORD *)(a2 + 121) & 0xFFFFEFFF | v25;
    if ((*(unsigned char *)(v11 + 84) & 4) != 0 && *(float *)(v11 + 76) > 1.0)
    {
      *(void *)(a2 + 112) = malloc_type_calloc(0x20uLL, 1uLL, 0x66A809F2uLL);
      int v33 = sub_1B660FA40((uint64_t)a3, v26, v27, v28, v29, v30, v31, v32);
      *(void *)(*(void *)(a2 + 112) + 24) = sub_1B65623D0(v33, 1, v34, v35, v36, v37, v38, v39);
      uint64_t v46 = sub_1B65623D0(v33, 1, v40, v41, v42, v43, v44, v45);
      *(void *)(*(void *)(a2 + 112) + 16) = v46;
      long long v54 = (void *)sub_1B6562568(v46, v47, v48, v49, v50, v51, v52, v53);
      sub_1B660F910((uint64_t)a3, v54, v55, v56, v57, v58, v59, v60);
      sub_1B6492C14(v11);
    }
    CFTypeID v61 = CFGetTypeID((CFTypeRef)a2);
    if (v61 == sub_1B6439AEC()) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. _CFXAnimationManagerAddAnimationNode - cluster not expected", v63, v64, v65, v66, v67, v68, (uint64_t)"CFGetTypeID(animationNode) != CFXAnimationClusterNodeGetTypeID()");
    }
    uint64_t v69 = (void *)sub_1B660F8C4((uint64_t)a3, v62, v63, v64, v65, v66, v67, v68);
    sub_1B6421B08(a1, (void *)a2, v69, a3, v70, v71, v72, v73);
  }
  else
  {
    sub_1B63F2F54(0, @"Warning: fail to setup the animation - won't be added to the animation stack", v18, v19, v20, v21, v22, v23, v75);
  }
  return v24;
}

void sub_1B6421B08(uint64_t a1, void *a2, void *key, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (a2) {
      goto LABEL_3;
    }
LABEL_14:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"animationNode");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_14;
  }
LABEL_3:
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), key);
  if (Value
    && (uint64_t v19 = (uint64_t)Value - 1,
        (uint64_t v20 = sub_1B66214AC(*(void *)(a1 + 24), (uint64_t)Value - 1, v13, v14, v15, v16, v17, v18)) != 0))
  {
    uint64_t v28 = (void *)v20;
  }
  else
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), key)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationManagerNewStackWithKey key already exist", v30, v31, v32, v33, v34, v35, (uint64_t)"CFDictionaryContainsKey(manager->_targetAddressToStackIndex, (void*)key) == false");
    }
    uint64_t v19 = sub_1B6621414(*(void *)(a1 + 24), v29, v30, v31, v32, v33, v34, v35);
    uint64_t v28 = sub_1B6621630(*(void *)(a1 + 24), 0);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), key, (const void *)(v19 + 1));
    sub_1B6436760(v28, v36, v37, v38, v39, v40, v41, v42);
    v28[5] = key;
    sub_1B643695C((uint64_t)v28, a4, v43, v44, v45, v46, v47, v48);
    uint64_t v49 = sub_1B6439AEC();
    CFTypeID v50 = CFGetTypeID(a2);
    *((unsigned char *)v28 + 48) = v49 == v50;
    if (v49 != v50)
    {
      uint64_t v51 = sub_1B6436A18((uint64_t)v28, v21, v22, v23, v24, v25, v26, v27);
      uint64_t v59 = v51;
      if (*(unsigned char *)(v51 + 37))
      {
        *((unsigned char *)v28 + 128) = 1;
        if (!*(unsigned char *)(a2[3] + 34)) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected semantic", v53, v54, v55, v56, v57, v58, (uint64_t)"animationNode->_target->_semantic != kCFXTypeSemanticNone");
        }
        *(_WORD *)(v59 + 32) = 10;
        *(unsigned char *)(v59 + 36) = sub_1B63CA534(10, v52, v53, v54, v55, v56, v57, v58);
        *(_WORD *)(v59 + 34) = 8;
        int v60 = 10;
        int v61 = 8;
      }
      else
      {
        *((unsigned char *)v28 + 128) = 0;
        int v62 = sub_1B660FA40(v51, v52, v53, v54, v55, v56, v57, v58);
        int v61 = sub_1B660F9A8(v59, v63, v64, v65, v66, v67, v68, v69);
        int v60 = v62;
      }
      v28[31] = sub_1B643079C(v60, v61, 0, 0);
      int v77 = sub_1B660FA40(v59, v70, v71, v72, v73, v74, v75, v76);
      *((unsigned char *)v28 + 242) = sub_1B63CA534(v77, v78, v79, v80, v81, v82, v83, v84);
      uint64_t v91 = *(void *)(a1 + 16);
      if (!v91) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v85, v86, v87, v88, v89, v90, (uint64_t)"modelValueStorage");
      }
      v28[4] = sub_1B660FCB0(v91, (const void *)v59, v85, v86, v87, v88, v89, v90);
    }
  }
  ++*(_DWORD *)(a1 + 160);
  uint64_t v92 = sub_1B6438704((uint64_t)a2, v21, v22, v23, v24, v25, v26, v27);
  if (sub_1B649394C(v92, v93, v94, v95, v96, v97, v98, v99)) {
    ++*(_DWORD *)(a1 + 168);
  }
  a2[19] = v19;
  a2[20] = key;

  sub_1B6436A64((uint64_t)v28, a2, a1, v100, v101, v102, v103, v104);
}

void sub_1B6421D80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  }
  if (*(unsigned char *)(a1 + 90)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _CFXAnimationManagerAppendCallback triggered while animation manager is muted", a3, a4, a5, a6, a7, a8, (uint64_t)"manager->_mute == false");
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
  if (Count >= 1)
  {
    CFIndex v10 = Count;
    CFArrayRef Copy = CFArrayCreateCopy(0, *(CFArrayRef *)(a1 + 80));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));
    CFIndex v12 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Copy, v12);
      uint64_t v21 = sub_1B6438704((uint64_t)ValueAtIndex, v14, v15, v16, v17, v18, v19, v20);
      uint64_t v29 = (void *)v21;
      int v30 = *(_DWORD *)((char *)ValueAtIndex + 121);
      *(_DWORD *)((char *)ValueAtIndex + 121) = v30 & 0xFFFE1FFF;
      if ((v30 & 0x22000) == 0x2000)
      {
        *(_DWORD *)((char *)ValueAtIndex + 121) = v30 & 0xFFFC1FFF | 0x20000;
        (*(void (**)(const __CFDictionary *))(v21 + 144))(ValueAtIndex);
      }
      if ((v30 & 0x8000) != 0)
      {
        int v31 = *(_DWORD *)((char *)ValueAtIndex + 121);
        if ((v31 & 0x80000) == 0)
        {
          *(_DWORD *)((char *)ValueAtIndex + 121) = v31 | 0x80000;
          uint64_t v32 = (void (*)(const __CFDictionary *))*((void *)ValueAtIndex + 26);
          if (v32) {
            v32(ValueAtIndex);
          }
          if (sub_1B64936B8((uint64_t)v29, v22, v23, v24, v25, v26, v27, v28) && !v29[19])
          {
            if (!a1) {
              sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"manager");
            }
            uint64_t v33 = *(void *)(a1 + 16);
            if (v33)
            {
              uint64_t v34 = *((void *)ValueAtIndex + 19);
              if (v34 != -1)
              {
                uint64_t v35 = sub_1B66214AC(*(void *)(a1 + 24), v34, v23, v24, v25, v26, v27, v28);
                sub_1B660FE2C(v33, *(void *)(v35 + 32), v36, v37, v38, v39, v40, v41);
              }
            }
          }
        }
      }
      if ((v30 & 0x4000) == 0) {
        goto LABEL_32;
      }
      unsigned int v42 = *(_DWORD *)((char *)ValueAtIndex + 121);
      if ((v42 & 0x40000) != 0) {
        goto LABEL_32;
      }
      *(_DWORD *)((char *)ValueAtIndex + 121) = v42 | 0x40000;
      CFRetain(v29);
      CFTypeID v50 = (uint64_t (*)(const __CFDictionary *, void, uint64_t, void))v29[19];
      if (v50 && (v50(ValueAtIndex, (v42 >> 10) & 1, a1, *((void *)ValueAtIndex + 17)) & 1) != 0
        || *((double *)ValueAtIndex + 11) == 0.0
        && !sub_1B6439404((uint64_t)ValueAtIndex, v43, v44, v45, v46, v47, v48, v49))
      {
        goto LABEL_31;
      }
      uint64_t v51 = (void *)sub_1B6438750((uint64_t)ValueAtIndex, v43, v44, v45, v46, v47, v48, v49);
      if ((sub_1B649394C((uint64_t)v29, v52, v53, v54, v55, v56, v57, v58) & 1) == 0
        && v51
        && sub_1B6422070(a1, v51, *((const void **)ValueAtIndex + 17), v59, v60, v61, v62, v63) == ValueAtIndex)
      {
        break;
      }
      sub_1B6422158(a1, (char *)ValueAtIndex, 8, v59, v60, v61, v62, v63);
      CFRelease(v29);
LABEL_35:
      if (v10 == ++v12)
      {
        CFRelease(Copy);
        return;
      }
    }
    sub_1B6423B50(a1, v51, *((void **)ValueAtIndex + 17), 0, v60, v61, v62, v63);
LABEL_31:
    CFRelease(v29);
LABEL_32:
    if ((v30 & 0x10000) != 0)
    {
      int v64 = *(_DWORD *)((char *)ValueAtIndex + 121);
      if ((v64 & 0x100000) == 0)
      {
        *(_DWORD *)((char *)ValueAtIndex + 121) = v64 | 0x100000;
        sub_1B6422240(a1, ValueAtIndex, v23, v24, v25, v26, v27, v28);
      }
    }
    goto LABEL_35;
  }
}

uint64_t sub_1B6422024(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  }
  return *(void *)(a1 + 16);
}

CFDictionaryRef sub_1B6422070(uint64_t a1, void *key, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
LABEL_9:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"rootObject");
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_10;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  if (!key) {
    goto LABEL_9;
  }
LABEL_3:
  if (a3) {
    goto LABEL_4;
  }
LABEL_10:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_4:
  CFDictionaryRef result = (const __CFDictionary *)sub_1B6423290(a1, key, 0, a4, a5, a6, a7, a8);
  if (result)
  {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a3);
  }
  return result;
}

void sub_1B6422150(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B6422158(uint64_t a1, char *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a3;
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
LABEL_3:
  if (*(unsigned char *)(a1 + 90)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _CFXAnimationManagerAppendCallback triggered while animation manager is muted", a3, a4, a5, a6, a7, a8, (uint64_t)"manager->_mute == false");
  }
  int v11 = *(_DWORD *)(value + 121);
  *(_DWORD *)(value + 121) = v11 | ((v8 & 0xF) << 13);
  if ((v11 & 0x1E000) == 0)
  {
    CFIndex v12 = *(__CFArray **)(a1 + 80);
    CFArrayAppendValue(v12, value);
  }
}

void sub_1B6422240(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
LABEL_3:
  uint64_t v10 = a2[19];
  if (v10 != -1)
  {
    uint64_t v11 = sub_1B66214AC(*(void *)(a1 + 24), v10, a3, a4, a5, a6, a7, a8);
    uint64_t v19 = sub_1B6438704((uint64_t)a2, v12, v13, v14, v15, v16, v17, v18);
    --*(_DWORD *)(a1 + 160);
    if (sub_1B649394C(v19, v20, v21, v22, v23, v24, v25, v26))
    {
      int v33 = *(_DWORD *)(a1 + 168);
      if (v33) {
        *(_DWORD *)(a1 + 168) = v33 - 1;
      }
      else {
        sub_1B63F2F54(16, @"Error: implicit animation count overflow", v27, v28, v29, v30, v31, v32, v120);
      }
    }
    sub_1B6436EC0(v11, a2, v27, v28, v29, v30, v31, v32);
    if (*(unsigned char *)(v11 + 48)) {
      sub_1B64367B4(v11, (uint64_t)a2, *(void *)(a1 + 16), (*(_WORD *)(v19 + 84) & 0x10) == 0, v37, v38, v39, v40);
    }
    if (sub_1B6436F98(v11, v34, v35, v36, v37, v38, v39, v40))
    {
      uint64_t v41 = (const void *)a2[20];
      uint64_t v42 = *(void *)(a1 + 16);
      if (v42 && !*(unsigned char *)(v11 + 48))
      {
        sub_1B6610004(*(void *)(a1 + 16), *(void *)(v11 + 32), a3, a4, a5, a6, a7, a8);
        sub_1B66100EC(v42, *(void *)(v11 + 32), v43, v44, v45, v46, v47, v48);
      }
      if (*(unsigned char *)(v11 + 241))
      {
        int v49 = *(_DWORD *)(a1 + 164);
        *(_DWORD *)(a1 + 164) = v49 - 1;
        if (v49 <= 0) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationManagerUpdateConstantCount", a3, a4, a5, a6, a7, a8, (uint64_t)"manager->_constantStackCount >= 0");
        }
      }
      if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v41) != 1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationManagerNewStackWithKey key doesn't exist", v50, v51, v52, v53, v54, v55, (uint64_t)"CFDictionaryContainsKey(manager->_targetAddressToStackIndex, (void*)key) == true");
      }
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v41);
      if (!Value) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v56, v57, v58, v59, v60, v61, (uint64_t)"removedIndex");
      }
      uint64_t v63 = (uint64_t)Value - 1;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v41);
      if (!sub_1B6621414(*(void *)(a1 + 24), v64, v65, v66, v67, v68, v69, v70)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v71, v72, v73, v74, v75, v76, (uint64_t)"lastIndex");
      }
      uint64_t v77 = sub_1B66214AC(*(void *)(a1 + 24), v63, v71, v72, v73, v74, v75, v76);
      sub_1B64368A8(v77, *(void *)(a1 + 16), v78, v79, v80, v81, v82, v83);
      int v84 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v84 + 1;
      if (v84 >= 511)
      {
        uint64_t v91 = sub_1B6621414(*(void *)(a1 + 24), v10, a3, a4, a5, a6, a7, a8);
        if (v91 < 1)
        {
          uint64_t v92 = 0;
        }
        else
        {
          uint64_t v92 = 0;
          for (uint64_t i = 0; i != v91; ++i)
          {
            uint64_t v94 = (long long *)sub_1B66214AC(*(void *)(a1 + 24), i, v85, v86, v87, v88, v89, v90);
            if (*(unsigned char *)v94)
            {
              if (v92)
              {
                uint64_t v95 = v94;
                uint64_t v96 = sub_1B66214AC(*(void *)(a1 + 24), i - v92, v85, v86, v87, v88, v89, v90);
                long long v97 = v95[3];
                long long v99 = *v95;
                long long v98 = v95[1];
                *(_OWORD *)(v96 + 32) = v95[2];
                *(_OWORD *)(v96 + 48) = v97;
                *(_OWORD *)uint64_t v96 = v99;
                *(_OWORD *)(v96 + 16) = v98;
                long long v100 = v95[7];
                long long v102 = v95[4];
                long long v101 = v95[5];
                *(_OWORD *)(v96 + 96) = v95[6];
                *(_OWORD *)(v96 + 112) = v100;
                *(_OWORD *)(v96 + 64) = v102;
                *(_OWORD *)(v96 + 80) = v101;
                long long v103 = v95[11];
                long long v105 = v95[8];
                long long v104 = v95[9];
                *(_OWORD *)(v96 + 160) = v95[10];
                *(_OWORD *)(v96 + 176) = v103;
                *(_OWORD *)(v96 + 128) = v105;
                *(_OWORD *)(v96 + 144) = v104;
                long long v106 = v95[15];
                long long v108 = v95[12];
                long long v107 = v95[13];
                *(_OWORD *)(v96 + 224) = v95[14];
                *(_OWORD *)(v96 + 240) = v106;
                *(_OWORD *)(v96 + 192) = v108;
                *(_OWORD *)(v96 + 208) = v107;
                v95[14] = 0u;
                v95[15] = 0u;
                v95[12] = 0u;
                v95[13] = 0u;
                v95[10] = 0u;
                v95[11] = 0u;
                v95[8] = 0u;
                v95[9] = 0u;
                v95[6] = 0u;
                v95[7] = 0u;
                v95[4] = 0u;
                v95[5] = 0u;
                v95[2] = 0u;
                v95[3] = 0u;
                *uint64_t v95 = 0u;
                v95[1] = 0u;
                *(unsigned char *)uint64_t v95 = 0;
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), *(const void **)(v96 + 40), (const void *)(i - v92 + 1));
                for (uint64_t j = *(void *)(v96 + 8); j; uint64_t j = *(void *)(j + 176))
                  *(void *)(j + 152) = i - v92;
              }
            }
            else
            {
              ++v92;
            }
          }
        }
        uint64_t v110 = v91 - v92;
        sub_1B66215D8(*(_DWORD **)(a1 + 24), v110);
        if (v110 <= 64) {
          int v111 = 64;
        }
        else {
          int v111 = v110;
        }
        sub_1B6621594(*(void *)(a1 + 24), v111);
        *(_DWORD *)(a1 + 40) = 0;
      }
    }
  }
  if (!sub_1B6438AD0((uint64_t)a2, v10, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v112 = sub_1B6438918((uint64_t)a2);
    if (v112) {
      sub_1B6420FC8(v112, a2, v113, v114, v115, v116, v117, v118);
    }
    sub_1B6438900((uint64_t)a2, 0);
    v119 = *(__CFSet **)(a1 + 56);
    CFSetRemoveValue(v119, a2);
  }
}

uint64_t sub_1B6422604(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a4;
  uint64_t v12 = (id *)sub_1B6438750(a3, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v20 = v12;
  if (v12)
  {
    if (sub_1B6583B18(v12)) {
      uint64_t v20 = sub_1B6583674(v20);
    }
    else {
      uint64_t v20 = 0;
    }
  }
  uint64_t v21 = (id *)sub_1B6438704(a3, v13, v14, v15, v16, v17, v18, v19);
  uint64_t v22 = sub_1B6583674(v21);
  uint64_t v30 = sub_1B661DEF0(a1[14], v23, v24, v25, v26, v27, v28, v29);
  uint64_t result = objc_msgSend_userAnimation(v22, v31, v32, v33);
  *((void *)v30 + 1) = result;
  *((void *)v30 + 2) = v20;
  v30[24] = v8;
  *(void *)uint64_t v30 = a2;
  *((void *)v30 + 4) = 0;
  uint64_t v35 = a1[13];
  if (v35) {
    uint64_t v36 = (char **)(v35 + 32);
  }
  else {
    uint64_t v36 = (char **)(a1 + 12);
  }
  *uint64_t v36 = v30;
  a1[13] = v30;
  return result;
}

void sub_1B64226C0(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animationManager");
  }
  *(double *)(a1 + 136) = a2;
}

double sub_1B6422718(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  }
  return *(double *)(a1 + 144);
}

void sub_1B6422764(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  }
  int v10 = *(_DWORD *)(a1 + 164) + a2;
  *(_DWORD *)(a1 + 164) = v10;
  if (v10 < 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationManagerUpdateConstantCount", a3, a4, a5, a6, a7, a8, (uint64_t)"manager->_constantStackCount >= 0");
  }
}

void sub_1B64227DC(uint64_t a1, double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a5, a6, a7, a8, a9, a10, (uint64_t)"manager");
  }
  *(unsigned char *)(a1 + 88) = 1;
  *(double *)(a1 + 136) = a3;
  *(double *)(a1 + 144) = a2;
  uint64_t v13 = *(void *)(a1 + 24);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = sub_1B6422908;
  v30[3] = &unk_1E6141CF8;
  v30[4] = a1;
  sub_1B66216D8(v13, (uint64_t)v30, a5, a6, a7, a8, a9, a10);
  CFSetApplyFunction(*(CFSetRef *)(a1 + 56), (CFSetApplierFunction)sub_1B6423050, (void *)a1);
  *(unsigned char *)(a1 + 88) = 0;
  uint64_t v21 = *(void **)(a1 + 96);
  if (v21)
  {
    do
    {
      uint64_t v22 = (void *)v21[4];
      (*(void (**)(void))(*v21 + 16))();
      v21[4] = 0;
      sub_1B661E084(*(void *)(a1 + 112), (unint64_t)v21, v23, v24, v25, v26, v27, v28, v29);
      *(void *)(a1 + 96) = v22;
      uint64_t v21 = v22;
    }
    while (v22);
  }
  *(void *)(a1 + 104) = 0;
  sub_1B6421D80(a1, v14, v15, v16, v17, v18, v19, v20);
}

void sub_1B6422908(uint64_t a1, uint64_t a2, __n128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3->n128_u8[0]) {
    sub_1B6422920(*(void *)(a1 + 32), a3, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B6422920(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  uint64_t v9 = a1;
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  if (a2[3].n128_u8[0])
  {
    uint64_t v10 = a2->n128_i64[1];
    if (!v10)
    {
      int v12 = 1;
LABEL_36:
      if (v8[15].n128_u8[1] != v12)
      {
        v8[15].n128_u8[1] = v12;
        if (v12) {
          int v85 = 1;
        }
        else {
          int v85 = -1;
        }
        sub_1B6422764(v9, v85, a3, a4, a5, a6, a7, a8);
      }
      return;
    }
    int v11 = 0;
    int v12 = 1;
    while (1)
    {
      if ((*(_WORD *)(v10 + 121) & 0x804) != 0)
      {
        BOOL v13 = 1;
      }
      else
      {
        uint64_t v14 = *(void *)(v10 + 16);
        BOOL v13 = !sub_1B6424D70(v9, v10, a3, a4, a5, a6, a7, a8);
        if ((*(unsigned char *)(v10 + 121) & 0x20) != 0)
        {
          float v16 = sub_1B6439228(v10, v15, a3, a4, a5, a6, a7, a8, *(float *)(v10 + 60));
          *(float *)(v10 + 56) = v16;
          if (v16 != 0.0)
          {
            uint64_t v28 = *(void *)(v14 + 168);
            float v147 = *(float *)(v10 + 72) * *(float *)(v14 + 72);
            uint64_t v144 = *(unsigned int *)(v28 + 20);
            unsigned int v29 = sub_1B642511C(*(float **)(v28 + 56), *(_DWORD *)(v28 + 16), &v147, 0, a5, a6, a7, a8);
            if (v29 + 1 < *(_DWORD *)(v28 + 16) - 1) {
              unsigned int v30 = v29 + 1;
            }
            else {
              unsigned int v30 = *(_DWORD *)(v28 + 16) - 1;
            }
            uint64_t v31 = *(void *)(v28 + 56);
            float v32 = *(float *)(v31 + 4 * v29);
            float v33 = *(float *)(v31 + 4 * v30) - v32;
            BOOL v141 = v13;
            int v142 = v12;
            if (v33 == 0.0) {
              float v34 = 0.0;
            }
            else {
              float v34 = (float)(v147 - v32) / v33;
            }
            float v147 = v34;
            uint64_t v35 = *(void *)(v28 + 64);
            int v36 = *(_DWORD *)(v28 + 24);
            long long v154 = 0u;
            long long v155 = 0u;
            long long v152 = 0u;
            long long v153 = 0u;
            uint64_t v37 = v144;
            if (v144)
            {
              uint64_t v38 = 0;
              uint64_t v39 = v35 + v36 * v30;
              uint64_t v40 = v35 + v36 * v29;
              uint64_t v143 = v28;
              do
              {
                uint64_t v41 = *(int *)(*(void *)(v10 + 224) + 4 * v38);
                uint64_t v42 = *(unsigned __int8 *)(*(void *)(v28 + 40) + v38);
                if (v41 != -1)
                {
                  uint64_t v49 = sub_1B66214AC(v8[3].n128_i64[1], v41, a3, a4, a5, a6, a7, a8);
                  if (!*(void *)v49) {
                    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v43, v44, v45, v46, v47, v48, (uint64_t)"stackItem->_modelValueItem");
                  }
                  (*(void (**)(uint64_t, uint64_t, void, void, void, void, long long *, double))(*(void *)(v28 + 48) + 8 * v38))(v40, v39, 0, 0, 0, 0, &v152, v147);
                  if (*(float *)(v10 + 56) < 1.0)
                  {
                    long long v150 = 0u;
                    long long v151 = 0u;
                    long long v148 = 0u;
                    long long v149 = 0u;
                    uint64_t v56 = *(void *)v49;
                    sub_1B66104F8(*(void *)(v9 + 16), *(void *)v49, v50, v51, v52, v53, v54, v55);
                    uint64_t v57 = *(void (**)(uint64_t, uint64_t, long long *, uint64_t, void, void))(v56 + 136);
                    uint64_t v65 = v9;
                    uint64_t v66 = sub_1B660F878(*(void *)(v56 + 24), v58, v59, v60, v61, v62, v63, v64);
                    uint64_t v67 = *(void *)(v56 + 24);
                    char v8 = a2;
                    uint64_t v75 = sub_1B660F8C4(v67, v68, v69, v70, v71, v72, v73, v74);
                    uint64_t v76 = v66;
                    uint64_t v9 = v65;
                    uint64_t v37 = v144;
                    v57(v76, v75, &v148, v42, *(char *)(v49 + 8), *(unsigned __int8 *)(v49 + 9));
                    uint64_t v28 = v143;
                    (*(void (**)(long long *, long long *, void, void, void, void, long long *, double))(v49 + 16))(&v148, &v152, 0, 0, 0, 0, &v152, *(float *)(v10 + 56));
                  }
                  sub_1B6610620(*(void *)(v9 + 16), *(uint64_t **)v49, *(char *)(v49 + 8), *(unsigned __int8 *)(v49 + 9), (uint64_t)&v152, v42, v54, v55);
                }
                v39 += (v42 + 15) & 0xF0;
                v40 += (v42 + 15) & 0xF0;
                ++v38;
              }
              while (v37 != v38);
            }
            int v11 = 1;
            BOOL v13 = v141;
            int v12 = v142;
            goto LABEL_15;
          }
        }
      }
      if (!v11)
      {
        uint64_t v17 = *(unsigned int *)(*(void *)(*(void *)(v10 + 16) + 168) + 20);
        if (v17)
        {
          uint64_t v18 = 0;
          uint64_t v19 = 4 * v17;
          do
          {
            uint64_t v20 = *(int *)(*(void *)(v10 + 224) + v18);
            if (v20 != -1)
            {
              uint64_t v21 = (uint64_t *)sub_1B66214AC(v8[3].n128_i64[1], v20, a3, a4, a5, a6, a7, a8);
              sub_1B6610004(*(void *)(v9 + 16), *v21, v22, v23, v24, v25, v26, v27);
            }
            v18 += 4;
          }
          while (v19 != v18);
        }
        int v11 = 0;
      }
LABEL_15:
      v12 &= v13;
      uint64_t v10 = *(void *)(v10 + 176);
      if (!v10) {
        goto LABEL_36;
      }
    }
  }
  a2[15].n128_u8[0] = 0;
  uint64_t v77 = a2 + 4;
  uint64_t v78 = (__n128 *)a2[2].n128_u64[0];
  BOOL v79 = a2[8].n128_u8[0] != 0;
  if (a2[8].n128_u8[0])
  {
    __n128 v81 = v78[3];
    a2[9] = v78[2];
    a2[10] = v81;
    __n128 v82 = v78[4];
    __n128 v83 = v78[5];
    __n128 v84 = v78[7];
    a2[13] = v78[6];
    a2[14] = v84;
    a2[11] = v82;
    a2[12] = v83;
  }
  else
  {
    memcpy(&a2[4], &v78[2], v78[8].n128_i16[1]);
  }
  uint64_t v86 = v8->n128_i64[1];
  if (!v86)
  {
    LOBYTE(v89) = 1;
LABEL_80:
    sub_1B6610004(*(void *)(a1 + 16), (uint64_t)v78, a3, a4, a5, a6, a7, a8);
    goto LABEL_81;
  }
  uint64_t v87 = v8;
  char v88 = 0;
  v145 = v87 + 9;
  int v89 = 1;
  do
  {
    if ((*(_WORD *)(v86 + 121) & 0x804) == 0)
    {
      v89 &= !sub_1B6424D70(a1, v86, a3, a4, a5, a6, a7, a8);
      if ((*(unsigned char *)(v86 + 121) & 0x20) != 0)
      {
        float v92 = sub_1B6439228(v86, v90, a3, a4, a5, a6, a7, a8, *(float *)(v86 + 60));
        *(float *)(v86 + 56) = v92;
        if (v92 != 0.0)
        {
          v93.n128_u64[1] = 0;
          long long v154 = 0u;
          long long v155 = 0u;
          long long v152 = 0u;
          long long v153 = 0u;
          long long v150 = 0u;
          long long v151 = 0u;
          long long v148 = 0u;
          long long v149 = 0u;
          v93.n128_u64[0] = *(unsigned int *)(v86 + 56);
          if (v93.n128_f32[0] >= 1.0)
          {
            long long v97 = a2;
          }
          else
          {
            if (v79)
            {
              a2[4] = sub_1B6454C84(v145, v91, a3, a4, a5, a6, a7, a8);
              a2[5] = v94;
              a2[6] = v95;
              a2[7] = v96;
            }
            long long v97 = a2;
            __memcpy_chk();
            BOOL v79 = 0;
          }
          if (v97[8].n128_u8[0]
            && ((*(_WORD *)(*(void *)(v86 + 16) + 84) & 2) != 0 || (*(unsigned char *)(v86 + 122) & 0x10) != 0))
          {
            sub_1B6455A38((uint64_t)v145, v77, *(unsigned __int8 *)(*(void *)(v86 + 24) + 36), *(char *)(*(void *)(v86 + 24) + 34), *(unsigned __int8 *)(*(void *)(v86 + 24) + 35), a6, a7, a8, v140);
          }
          if (!a1) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
          }
          if ((*(unsigned char *)(v86 + 121) & 0x20) != 0)
          {
            uint64_t v99 = sub_1B6438704(v86, v91, a3, a4, a5, a6, a7, a8);
            uint64_t v106 = v99;
            uint64_t v107 = *(void *)(v86 + 112);
            if (v107 && *(_DWORD *)v107)
            {
              sub_1B656264C(*(void *)(v107 + 24), v77, v100, v101, v102, v103, v104, v105);
              sub_1B6562568(*(void *)(*(void *)(v86 + 112) + 24), v108, v109, v110, v111, v112, v113, v114);
              char v98 = sub_1B6492C14(v106);
              sub_1B6562BD4(*(void *)(*(void *)(v86 + 112) + 8), *(void *)(*(void *)(v86 + 112) + 24), *(void *)(*(void *)(v86 + 112) + 24), v115, v116, v117, v118, v119, v140);
              sub_1B6562704(*(void *)(*(void *)(v86 + 112) + 24), v77, v120, v121, v122, v123, v124, v125);
            }
            else
            {
              char v98 = sub_1B6492C14(v99);
            }
          }
          else
          {
            char v98 = 0;
          }
          v88 |= v98;
          if (v88)
          {
            v126 = a2;
            if (a2[8].n128_u8[0])
            {
              a2[15].n128_u8[0] |= *(unsigned char *)(v86 + 120);
              sub_1B6456160(v145, (long long *)v77, *(unsigned __int8 *)(*(void *)(v86 + 24) + 36), *(char *)(*(void *)(v86 + 24) + 34), *(unsigned __int8 *)(*(void *)(v86 + 24) + 35), a6, a7, a8, v93, v140);
              if (*(float *)(v86 + 56) >= 1.0)
              {
                BOOL v79 = 1;
                goto LABEL_74;
              }
            }
            else
            {
              if (*(float *)(v86 + 56) >= 1.0) {
                goto LABEL_74;
              }
              v126 = a2;
              if (!v79) {
                goto LABEL_71;
              }
            }
            v126[4] = sub_1B6454C84(v145, v91, a3, a4, a5, a6, a7, a8);
            v126[5] = v127;
            v126[6] = v128;
            v126[7] = v129;
LABEL_71:
            __memcpy_chk();
            ((void (*)(long long *, long long *, void, void, void, void, __n128 *, double))v126[15].n128_u64[1])(&v152, &v148, 0, 0, 0, 0, v77, *(float *)(v86 + 56));
            if (v126[8].n128_u8[0]) {
              sub_1B6456160(v145, (long long *)v77, *(unsigned __int8 *)(v126[1].n128_u64[1] + 36), *(char *)(v126[1].n128_u64[1] + 34), *(unsigned __int8 *)(v126[1].n128_u64[1] + 35), a6, a7, a8, v130, v140);
            }
            BOOL v79 = 0;
          }
        }
      }
    }
LABEL_74:
    uint64_t v86 = *(void *)(v86 + 176);
  }
  while (v86);
  uint64_t v78 = (__n128 *)a2[2].n128_u64[0];
  if ((v88 & 1) == 0)
  {
    char v8 = a2;
    goto LABEL_80;
  }
  uint64_t v131 = *(void *)(a1 + 16);
  char v8 = a2;
  if (a2[8].n128_u8[0]) {
    sub_1B66106C0(v131, (uint64_t *)a2[2].n128_u64[0], v145, a2[15].n128_i8[0], a5, a6, a7, a8);
  }
  else {
    sub_1B6610620(v131, (uint64_t *)a2[2].n128_u64[0], 0, 0, (uint64_t)v77, a2[15].n128_u8[2], a7, a8);
  }
LABEL_81:
  if (v8[15].n128_u8[1] != (v89 & 1))
  {
    v8[15].n128_u8[1] = v89 & 1;
    int v138 = *(_DWORD *)(a1 + 164);
    int v139 = (v89 & 1) != 0 ? v138 + 1 : v138 - 1;
    *(_DWORD *)(a1 + 164) = v139;
    if (v139 < 0) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationManagerUpdateConstantCount", v132, v133, v134, v135, v136, v137, (uint64_t)"manager->_constantStackCount >= 0");
    }
  }
}

uint64_t sub_1B6423050(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(result + 152) == -1) {
    return sub_1B6424D70(a2, result, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

void sub_1B6423070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"target");
    *(unsigned char *)(a1 + 88) = 1;
    uint64_t v10 = (unsigned char *)(a1 + 88);
    *(unsigned char *)(a1 + 90) = 1;
    int v11 = (unsigned char *)(a1 + 90);
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"target");
    goto LABEL_6;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v10 = (unsigned char *)(a1 + 88);
  *(unsigned char *)(a1 + 90) = 1;
  int v11 = (unsigned char *)(a1 + 90);
LABEL_6:
  uint64_t v18 = (const void *)sub_1B660F8C4(a2, a2, a3, a4, a5, a6, a7, a8);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v18);
  if (Value)
  {
    uint64_t v26 = (__n128 *)sub_1B66214AC(*(void *)(a1 + 24), (uint64_t)Value - 1, v20, v21, v22, v23, v24, v25);
    if (v26)
    {
      *(void *)(v26[2].n128_u64[0] + 152) = 0;
      sub_1B6422920(a1, v26, v27, v28, v29, v30, v31, v32);
    }
  }
  *uint64_t v10 = 0;
  *int v11 = 0;
}

BOOL sub_1B6423178(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationManager");
  }
  uint64_t v9 = *(void *)(a1 + 24);
  return !v9 || sub_1B6621414(v9, a2, a3, a4, a5, a6, a7, a8) <= *(int *)(a1 + 40);
}

BOOL sub_1B64231E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (a1)
  {
    if (a2)
    {
LABEL_3:
      BOOL v10 = *(_DWORD *)(a1 + 168) <= 0;
      return !v10;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationManager");
    if (v8) {
      goto LABEL_3;
    }
  }
  uint64_t v11 = *(void *)(a1 + 24);
  if (v11) {
    uint64_t v12 = sub_1B6621414(v11, a2, a3, a4, a5, a6, a7, a8) - *(int *)(a1 + 40);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(int *)(a1 + 164);
  if (v12 < v13)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationManagerNeedsRedraw - inconsistant constant count", a3, a4, a5, a6, a7, a8, (uint64_t)"stackCount >= animationManager->_constantStackCount");
    uint64_t v13 = *(int *)(a1 + 164);
  }
  BOOL v10 = v12 <= v13;
  return !v10;
}

const void *sub_1B6423290(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (key) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"root");
LABEL_3:
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), key);
  if (Value) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = v8 == 0;
  }
  if (!v12)
  {
    Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), key, Value);
    CFRelease(Value);
  }
  return Value;
}

void sub_1B6423368(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v12 = (const void *)sub_1B6420F7C(a2, a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if (!v12) {
    return;
  }
  uint64_t v13 = v12;
  CFTypeID v14 = CFGetTypeID(v12);
  if (sub_1B6540E1C() != v14)
  {
    if (sub_1B654DC68() != v14)
    {
      BOOL v79 = sub_1B6492C1C((uint64_t)v13, a3, v38, v39, v40, v41, v42, v43);
      if (!v79) {
        return;
      }
      __n128 v83 = v79;
      uint64_t v32 = sub_1B6423610(a1, v13, v79, a3, a4, v80, v81, v82);
      CFRelease(v83);
      if (!v32) {
        return;
      }
      goto LABEL_15;
    }
    if (a1)
    {
      if (a3) {
        goto LABEL_11;
      }
    }
    else
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v38, v39, v40, v41, v42, v43, (uint64_t)"manager");
      if (a3)
      {
LABEL_11:
        if (a4)
        {
LABEL_12:
          sub_1B6423B50(a1, a3, a4, 0, v40, v41, v42, v43);
          uint64_t v48 = sub_1B6439928(a1, v13, (uint64_t)a3, a4, v44, v45, v46, v47);
          if (!v48) {
            return;
          }
          uint64_t v32 = (void *)v48;
          sub_1B643879C(v48, (uint64_t)a3, v49, v50, v51, v52, v53, v54);
          sub_1B6438900((uint64_t)v32, a1);
          sub_1B6421B08(a1, v32, a3, 0, v55, v56, v57, v58);
          goto LABEL_14;
        }
LABEL_27:
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v38, v39, v40, v41, v42, v43, (uint64_t)"key");
        goto LABEL_12;
      }
    }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v38, v39, v40, v41, v42, v43, (uint64_t)"root");
    if (a4) {
      goto LABEL_12;
    }
    goto LABEL_27;
  }
  if (a1)
  {
    if (a3) {
      goto LABEL_5;
    }
LABEL_23:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v15, v16, v17, v18, v19, v20, (uint64_t)"root");
    if (a4) {
      goto LABEL_6;
    }
LABEL_24:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v15, v16, v17, v18, v19, v20, (uint64_t)"key");
    goto LABEL_6;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v15, v16, v17, v18, v19, v20, (uint64_t)"manager");
  if (!a3) {
    goto LABEL_23;
  }
LABEL_5:
  if (!a4) {
    goto LABEL_24;
  }
LABEL_6:
  sub_1B6423B50(a1, a3, a4, 0, v17, v18, v19, v20);
  uint64_t v25 = sub_1B6439778(a1, v13, a3, a4, v21, v22, v23, v24);
  if (!v25) {
    return;
  }
  uint64_t v32 = (void *)v25;
  sub_1B643879C(v25, (uint64_t)a3, v26, v27, v28, v29, v30, v31);
  sub_1B6438900((uint64_t)v32, a1);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 56), v32);
LABEL_14:
  uint64_t v59 = (__CFDictionary *)sub_1B6423290(a1, a3, 1, v33, v34, v35, v36, v37);
  CFDictionarySetValue(v59, a4, v32);
  sub_1B65C3564((uint64_t)v32);
  CFRelease(v32);
LABEL_15:
  sub_1B64210A8(a2, v32, v60, v61, v62, v63, v64, v65);
  if ((sub_1B64213FC(a2, v66, v67, v68, v69, v70, v71, v72) & 1) == 0)
  {
    sub_1B6423784(a1, (uint64_t)v32, v73, v74, v75, v76, v77, v78);
  }
}

const void *sub_1B6423610(uint64_t a1, const void *a2, const void *a3, void *key, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)key, (uint64_t)a5, a6, a7, a8, (uint64_t)"manager");
    if (a2)
    {
LABEL_3:
      if (a3) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)key, (uint64_t)a5, a6, a7, a8, (uint64_t)"animation");
  if (a3)
  {
LABEL_4:
    if (key) {
      goto LABEL_5;
    }
LABEL_12:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)key, (uint64_t)a5, a6, a7, a8, (uint64_t)"root");
    if (a5) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_11:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)key, (uint64_t)a5, a6, a7, a8, (uint64_t)"target");
  if (!key) {
    goto LABEL_12;
  }
LABEL_5:
  if (a5) {
    goto LABEL_6;
  }
LABEL_13:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)key, (uint64_t)a5, a6, a7, a8, (uint64_t)"key");
LABEL_6:
  sub_1B6423B50(a1, key, a5, 0, (uint64_t)a5, a6, a7, a8);
  uint64_t v17 = sub_1B6439A1C(a1, a2, a3, a5, v13, v14, v15, v16);
  uint64_t v24 = (const void *)v17;
  if (v17)
  {
    sub_1B643879C(v17, (uint64_t)key, v18, v19, v20, v21, v22, v23);
    sub_1B6438900((uint64_t)v24, a1);
    uint64_t v30 = (__CFDictionary *)sub_1B6423290(a1, key, 1, v25, v26, v27, v28, v29);
    CFDictionarySetValue(v30, a5, v24);
    sub_1B65C3564((uint64_t)v24);
    CFRelease(v24);
  }
  return v24;
}

uint64_t sub_1B6423784(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (a1) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  if (!a1) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
LABEL_4:
  int v10 = *(_DWORD *)(a2 + 121);
  *(_DWORD *)(a2 + 121) = v10 & 0xFFFBFFFF;
  sub_1B64395F8(a2, 0, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B6438704(a2, v11, v12, v13, v14, v15, v16, v17);
  if (sub_1B649394C(v18, v19, v20, v21, v22, v23, v24, v25))
  {
    sub_1B65C26E4();
    double v34 = v33;
    int v35 = 0;
  }
  else
  {
    uint64_t v36 = sub_1B6438920(a2);
    if (v36 && (sub_1B642167C(v36, v26, v27, v28, v29, v30, v31, v32) & 1) != 0)
    {
      int v35 = 0;
      double v34 = 0.0;
    }
    else
    {
      if (!a1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v27, v28, v29, v30, v31, v32, (uint64_t)"manager");
      }
      double v34 = *(double *)(a1 + 144);
      int v35 = 1;
    }
  }
  double v44 = v34 + sub_1B64396D4(v18, v26, v27, v28, v29, v30, v31, v32);
  if ((v10 & 0x200000) == 0 || *(double *)(a2 + 128) == 0.0)
  {
    sub_1B64387EC(a2, v44, v37, v38, v39, v40, v41, v42, v43);
    if (v35) {
      sub_1B6438844(a2, v59, v53, v54, v55, v56, v57, v58);
    }
  }
  else
  {
    double v45 = sub_1B64396D4(a2, v37, v38, v39, v40, v41, v42, v43);
    sub_1B6438898(a2, v44 - v45, v46, v47, v48, v49, v50, v51, v52);
    *(void *)(a2 + 128) = 0;
  }
  *(void *)(a2 + 104) = 0;
  *(_DWORD *)(a2 + 121) &= 0xFFFFFFF3;
  *(_DWORD *)(a2 + 72) = -1082130432;
  uint64_t v60 = *(void *)(a2 + 152);
  if (v60 != -1)
  {
    uint64_t v61 = sub_1B66214AC(*(void *)(a1 + 24), v60, v53, v54, v55, v56, v57, v58);
    sub_1B6436E1C(v61, 0, a1, v62, v63, v64, v65, v66);
  }
  uint64_t result = (uint64_t)sub_1B6438BB8(a2, v60, v53, v54, v55, v56, v57, v58);
  if (result >= 1)
  {
    uint64_t v74 = result;
    for (CFIndex i = 0; i != v74; ++i)
    {
      CFArrayRef v76 = sub_1B6438C28(a2, i, v68, v69, v70, v71, v72, v73);
      uint64_t result = sub_1B6423784(a1, v76);
    }
  }
  return result;
}

const void *sub_1B6423958(uint64_t a1, const void *a2, const void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B6423610(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    return (const void *)sub_1B6423784(a1, (uint64_t)result, v10, v11, v12, v13, v14, v15);
  }
  return result;
}

void sub_1B64239A4(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (key) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"rootObject");
LABEL_3:
  CFDictionaryRef v10 = (const __CFDictionary *)sub_1B6423290(a1, key, 0, a4, a5, a6, a7, a8);
  if (v10)
  {
    CFDictionaryRef v11 = v10;
    CFRetain(v10);
    CFDictionaryRef Copy = CFDictionaryCreateCopy(0, v11);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = sub_1B6423AB0;
    v13[3] = &unk_1E6141D18;
    v13[4] = a1;
    v13[5] = key;
    v13[6] = v11;
    sub_1B63CCA7C(Copy, (uint64_t)v13);
    CFRelease(Copy);
    CFRelease(v11);
  }
}

void sub_1B6423AB0(uint64_t a1, void *key)
{
}

void sub_1B6423AC4(uint64_t a1, const void *a2, void *key, CFDictionaryRef theDict)
{
  Value = CFDictionaryGetValue(theDict, key);
  sub_1B6424F7C(a1, (uint64_t)Value, v9, v10, v11, v12, v13, v14);
  CFDictionaryRemoveValue(theDict, key);
  if (!CFDictionaryGetCount(theDict))
  {
    uint64_t v15 = *(__CFDictionary **)(a1 + 48);
    CFDictionaryRemoveValue(v15, a2);
  }
}

void sub_1B6423B50(uint64_t a1, void *key, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
LABEL_11:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"root");
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_12;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  if (!key) {
    goto LABEL_11;
  }
LABEL_3:
  if (a3) {
    goto LABEL_4;
  }
LABEL_12:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_4:
  CFDictionaryRef v11 = (const __CFDictionary *)sub_1B6423290(a1, key, 0, a4, a5, a6, a7, a8);
  if (v11)
  {
    CFDictionaryRef v12 = v11;
    CFRetain(v11);
    Value = CFDictionaryGetValue(v12, a3);
    if (Value)
    {
      uint64_t v14 = Value;
      CFRetain(Value);
      sub_1B643879C((uint64_t)v14, 0, v15, v16, v17, v18, v19, v20);
      sub_1B6423AC4(a1, key, a3, v12);
      CFRelease(v14);
    }
    CFRelease(v12);
  }
}

void sub_1B6423C84(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (a9 == 0.0)
  {
    sub_1B64239A4(a1, key, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (a1)
  {
    if (key) {
      goto LABEL_7;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (key) {
      goto LABEL_7;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"rootObject");
LABEL_7:
  CFDictionaryRef v12 = (const __CFDictionary *)sub_1B6423290(a1, key, 0, a4, a5, a6, a7, a8);
  if (v12)
  {
    CFDictionaryRef v13 = v12;
    CFRetain(v12);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = sub_1B6423DB4;
    v14[3] = &unk_1E6141D38;
    v14[4] = a1;
    *(double *)&v14[5] = a9;
    sub_1B63CCA7C(v13, (uint64_t)v14);
    CFRelease(v13);
  }
}

uint64_t sub_1B6423DB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 32);
  if (sub_1B649394C(*(void *)(a3 + 16), a2, a3, a4, a5, a6, a7, a8)) {
    uint64_t v18 = 136;
  }
  else {
    uint64_t v18 = 144;
  }
  *(void *)(a3 + 88) = *(void *)(v10 + v18);
  uint64_t v19 = *(void *)(a1 + 32);
  uint64_t result = sub_1B649394C(*(void *)(a3 + 16), v11, v12, v13, v14, v15, v16, v17);
  if (result) {
    uint64_t v21 = 136;
  }
  else {
    uint64_t v21 = 144;
  }
  *(void *)(a3 + 96) = *(void *)(v19 + v21);
  double v22 = *(double *)(a1 + 40);
  if (v22 < 0.0001) {
    double v22 = 0.0001;
  }
  *(double *)(a3 + 104) = v22;
  return result;
}

void sub_1B6423E40(uint64_t a1, void *key, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (a9 == 0.0)
  {
    sub_1B6423B50(a1, key, a3, 0, a5, a6, a7, a8);
    return;
  }
  if (a1)
  {
    if (key) {
      goto LABEL_7;
    }
LABEL_23:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"root");
    if (a3) {
      goto LABEL_8;
    }
    goto LABEL_24;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  if (!key) {
    goto LABEL_23;
  }
LABEL_7:
  if (a3) {
    goto LABEL_8;
  }
LABEL_24:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_8:
  CFDictionaryRef v13 = (const __CFDictionary *)sub_1B6423290(a1, key, 0, a4, a5, a6, a7, a8);
  if (v13)
  {
    CFDictionaryRef v14 = v13;
    CFRetain(v13);
    Value = (double *)CFDictionaryGetValue(v14, a3);
    if (Value)
    {
      uint64_t v23 = Value;
      if (sub_1B649394C(*((void *)Value + 2), v16, v17, v18, v19, v20, v21, v22)) {
        uint64_t v31 = 136;
      }
      else {
        uint64_t v31 = 144;
      }
      v23[11] = *(double *)(a1 + v31);
      if (sub_1B649394C(*((void *)v23 + 2), v24, v25, v26, v27, v28, v29, v30)) {
        uint64_t v32 = 136;
      }
      else {
        uint64_t v32 = 144;
      }
      double v33 = 0.0001;
      if (a9 >= 0.0001) {
        double v33 = a9;
      }
      v23[12] = *(double *)(a1 + v32);
      v23[13] = v33;
    }
    CFRelease(v14);
  }
}

void sub_1B6423FE4(uint64_t a1, void *key, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (key) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"root");
LABEL_3:

  sub_1B6423B50(a1, key, a3, 0, a5, a6, a7, a8);
}

CFDictionaryRef sub_1B6424084(uint64_t a1, void *key, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
LABEL_8:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"rootObject");
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  if (!key) {
    goto LABEL_8;
  }
LABEL_3:
  if (a3) {
    goto LABEL_4;
  }
LABEL_9:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_4:

  return sub_1B6422070(a1, key, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B6424144(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (a2)
  {
    if (a1) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a1) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
LABEL_3:
  int v12 = *(_DWORD *)(a2 + 121);
  if (a9 == 0.0)
  {
    *(_DWORD *)(a2 + 121) = v12 & 0xFFFFFFDB | 4;
  }
  else
  {
    *(_DWORD *)(a2 + 121) = v12 | 8;
    if (sub_1B649394C(*(void *)(a2 + 16), a2, a3, a4, a5, a6, a7, a8))
    {
      sub_1B65C26E4();
    }
    else
    {
      if (!a1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
      }
      uint64_t v13 = *(void *)(a1 + 144);
    }
    *(void *)(a2 + 96) = v13;
    *(double *)(a2 + 104) = a9;
  }
  *(void *)(a2 + 128) = 0;
  uint64_t result = (uint64_t)sub_1B6438BB8(a2, a2, a3, a4, a5, a6, a7, a8);
  if (result >= 1)
  {
    uint64_t v21 = result;
    for (CFIndex i = 0; i != v21; ++i)
    {
      CFArrayRef v23 = sub_1B6438C28(a2, i, v15, v16, v17, v18, v19, v20);
      uint64_t result = sub_1B6424144(a1, v23, a9);
    }
  }
  return result;
}

uint64_t sub_1B6424274(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (a2)
  {
    if (a1) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a1) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
LABEL_3:
  if (a4)
  {
    uint64_t result = sub_1B64396C8(a2);
    if (result == a3) {
      return result;
    }
    int v15 = sub_1B6439598(a2);
    sub_1B6439660(a2, a3, v16, v17, v18, v19, v20, v21);
  }
  else
  {
    uint64_t result = sub_1B64395A8(a2, a2, a3, a4, a5, a6, a7, a8);
    if (result == a3) {
      return result;
    }
    int v15 = sub_1B6439598(a2);
    sub_1B64395F8(a2, a3, v22, v23, v24, v25, v26, v27);
  }
  if (sub_1B6439598(a2)) {
    int v35 = 1;
  }
  else {
    int v35 = (*(_DWORD *)(a2 + 121) >> 2) & 1;
  }
  if (v35 != v15)
  {
    uint64_t v36 = sub_1B6438704(a2, v28, v29, v30, v31, v32, v33, v34);
    double v44 = a9;
    if ((sub_1B649394C(v36, v37, v38, v39, v40, v41, v42, v43) & 1) == 0) {
      double v44 = *(double *)(a1 + 144);
    }
    if (sub_1B6439598(a2))
    {
      sub_1B6439720(a2, v44, v45, v46, v47, v48, v49, v50, v51);
    }
    else
    {
      uint64_t v52 = *(void *)(a2 + 152);
      if (v52 != -1)
      {
        uint64_t v53 = sub_1B66214AC(*(void *)(a1 + 24), v52, v46, v47, v48, v49, v50, v51);
        sub_1B6436E1C(v53, 0, a1, v54, v55, v56, v57, v58);
      }
      if ((*(unsigned char *)(a2 + 121) & 4) != 0)
      {
        sub_1B64387EC(a2, v44, v52, v46, v47, v48, v49, v50, v51);
      }
      else
      {
        double v59 = sub_1B64396D4(a2, v52, v46, v47, v48, v49, v50, v51);
        sub_1B6438898(a2, v44 - v59, v60, v61, v62, v63, v64, v65, v66);
      }
      *(_DWORD *)(a2 + 121) &= ~4u;
    }
  }
  uint64_t result = (uint64_t)sub_1B6438BB8(a2, v28, v29, v30, v31, v32, v33, v34);
  if (result >= 1)
  {
    uint64_t v73 = result;
    for (CFIndex i = 0; i != v73; ++i)
    {
      CFArrayRef v75 = sub_1B6438C28(a2, i, v67, v68, v69, v70, v71, v72);
      uint64_t result = sub_1B6424274(a1, v75, a3, a4, a9);
    }
  }
  return result;
}

CFDictionaryRef sub_1B6424458(uint64_t a1, void *key, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (a1)
  {
    if (key) {
      goto LABEL_3;
    }
LABEL_11:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"root");
    if (a3) {
      goto LABEL_4;
    }
LABEL_12:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"key");
    goto LABEL_4;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
  if (!key) {
    goto LABEL_11;
  }
LABEL_3:
  if (!a3) {
    goto LABEL_12;
  }
LABEL_4:
  CFDictionaryRef result = (const __CFDictionary *)sub_1B6423290(a1, key, 0, a4, a5, a6, a7, a8);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, a3);
    if (result)
    {
      return (const __CFDictionary *)sub_1B6424274(a1, (uint64_t)result, a4, a5, v16, v17, v18, v19, a9);
    }
  }
  return result;
}

CFTypeRef sub_1B6424578(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (cf) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (cf) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"storage");
LABEL_3:
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16) = result;
  }
  return result;
}

void sub_1B6424684(uint64_t a1)
{
  CFAllocatorRef v2 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v5 = *(void **)(a1 + 72);
  if (v5) {
    objc_msgSend_enumerateObjectsUsingBlock_(v5, v3, (uint64_t)&unk_1F0FB6C48, v4);
  }

  os_unfair_lock_unlock(v2);
}

void *sub_1B64246D8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  memset(v63, 0, sizeof(v63));
  uint64_t v16 = (_OWORD *)sub_1B660F8C4(a2[2], (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = a2[4];
  if (v17)
  {
    uint64_t v18 = sub_1B660F8C4(a2[3], v9, v10, v11, v12, v13, v14, v15);
    (*(void (**)(uint64_t, _OWORD *, uint64_t, _OWORD *))(v17 + 16))(v17, v16, v18, v63);
    uint64_t v16 = v63;
  }
  uint64_t v19 = (const void *)sub_1B660F878(a2[3], v9, v10, v11, v12, v13, v14, v15);
  uint64_t v27 = (void *)sub_1B660F8C4(a2[3], v20, v21, v22, v23, v24, v25, v26);
  int v35 = sub_1B660FA40(a2[3], v28, v29, v30, v31, v32, v33, v34);
  size_t v43 = sub_1B63CA534(v35, v36, v37, v38, v39, v40, v41, v42);
  uint64_t v51 = sub_1B660F9A8(a2[3], v44, v45, v46, v47, v48, v49, v50);
  uint64_t v59 = sub_1B660F9F4(a2[3], v52, v53, v54, v55, v56, v57, v58);
  return sub_1B63F4524(v19, v27, v16, v43, v51, v59, v60, v61);
}

uint64_t sub_1B64247DC(uint64_t a1, void *a2, const __CFString *a3, void *a4, const __CFString *a5, void *a6)
{
  uint64_t v10 = a2;
  CFStringRef v12 = sub_1B660CA68(a2, a3, 0);
  if (!v12)
  {
LABEL_9:
    if (sub_1B6583B18(v10)) {
      uint64_t v74 = sub_1B6583470((uint64_t)v10, v49, v50, v51, v52, v53, v54, v55);
    }
    else {
      uint64_t v74 = (uint64_t)v10;
    }
    sub_1B63F2F54(16, @"Error: Binding: Unable to resolve destination keypath: %@(%@)", v50, v51, v52, v53, v54, v55, v74);
    return 0;
  }
  uint64_t v20 = (__CFXModelTarget *)v12;
  if (!sub_1B660F8C4((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19))
  {
    CFRelease(v20);
    goto LABEL_9;
  }
  CFStringRef v21 = sub_1B660CA68(a4, a5, 0);
  if (!v21)
  {
    uint64_t v56 = v20;
LABEL_15:
    CFRelease(v56);
    return 0;
  }
  uint64_t v29 = (__CFXModelTarget *)v21;
  if (!sub_1B660F8C4((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28))
  {
    CFRelease(v20);
    uint64_t v56 = v29;
    goto LABEL_15;
  }
  int v37 = sub_1B660FA40((uint64_t)v20, v30, v31, v32, v33, v34, v35, v36);
  if (v37 != sub_1B660FA40((uint64_t)v29, v38, v39, v40, v41, v42, v43, v44))
  {
    CFRelease(v20);
    CFRelease(v29);
    if (sub_1B6583B18(v10) && sub_1B6583B18(a4))
    {
      uint64_t v10 = (void *)sub_1B6583470((uint64_t)v10, v64, v58, v59, v60, v61, v62, v63);
      sub_1B6583470((uint64_t)a4, v65, v66, v67, v68, v69, v70, v71);
    }
    sub_1B63F2F54(16, @"Error: Binding: Trying to bind two incompatible keypaths: %@(%@) -> %@(%@)", v58, v59, v60, v61, v62, v63, (uint64_t)v10);
    return 0;
  }
  sub_1B64249DC(a1, v10, a3);
  uint64_t v47 = objc_alloc_init(CFXAnimationBinding);
  v47->_source = v29;
  v47->_destination = v20;
  if (v10) {
    uint64_t v48 = (void *)CFRetain(v10);
  }
  else {
    uint64_t v48 = 0;
  }
  v47->_owner = v48;
  uint64_t v72 = (const void *)objc_msgSend_objectForKeyedSubscript_(a6, v45, @"VFXBindingValueTransformerKey", v46);
  if (v72) {
    v47->_valueTransformer = _Block_copy(v72);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v73 = *(__CFArray **)(a1 + 72);
  if (!v73)
  {
    uint64_t v73 = (__CFArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    *(void *)(a1 + 72) = v73;
  }
  CFArrayAppendValue(v73, v47);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));

  return 1;
}

void sub_1B64249DC(uint64_t a1, void *a2, const __CFString *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v7 = *(void **)(a1 + 72);
  if (v7)
  {
    CFStringRef v8 = sub_1B660CA68(a2, a3, 0);
    uint64_t v16 = sub_1B660F8C4((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15);
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3221225472;
    v22[2] = sub_1B6424AB0;
    v22[3] = &unk_1E6141D78;
    v22[4] = a2;
    v22[5] = v16;
    uint64_t v19 = objc_msgSend_indexesOfObjectsPassingTest_(v7, v17, (uint64_t)v22, v18);
    objc_msgSend_removeObjectsAtIndexes_(v7, v20, v19, v21);
    CFRelease(v8);
  }
  os_unfair_lock_unlock(v6);
}

BOOL sub_1B6424AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *(void *)(a2 + 8) == *(void *)(a1 + 32)
      && sub_1B660F8C4(*(void *)(a2 + 24), a2, a3, a4, a5, a6, a7, a8) == *(void *)(a1 + 40);
}

void sub_1B6424AFC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v7 = *(void **)(a1 + 72);
  if (v7)
  {
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = sub_1B6424BAC;
    v11[3] = &unk_1E6141D98;
    v11[4] = a2;
    uint64_t v8 = objc_msgSend_indexesOfObjectsPassingTest_(v7, v5, (uint64_t)v11, v6);
    objc_msgSend_removeObjectsAtIndexes_(v7, v9, v8, v10);
  }
  os_unfair_lock_unlock(v4);
}

BOOL sub_1B6424BAC(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8) == *(void *)(a1 + 32);
}

void sub_1B6424BC4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[3];
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  v20[2] = sub_1B6424D60;
  v20[3] = &unk_1E6141CF8;
  v20[4] = a1;
  sub_1B66216D8(v9, (uint64_t)v20, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = (const void *)a1[3];
  if (v10)
  {
    CFRelease(v10);
    a1[3] = 0;
  }
  uint64_t v11 = (const void *)a1[4];
  if (v11)
  {
    CFRelease(v11);
    a1[4] = 0;
  }
  uint64_t v12 = (const void *)a1[10];
  if (v12)
  {
    CFRelease(v12);
    a1[10] = 0;
  }
  uint64_t v13 = (const void *)a1[6];
  if (v13)
  {
    CFRelease(v13);
    a1[6] = 0;
  }
  uint64_t v14 = (const void *)a1[7];
  if (v14)
  {
    CFRelease(v14);
    a1[7] = 0;
  }
  uint64_t v15 = (const void *)a1[2];
  if (v15)
  {
    CFRelease(v15);
    a1[2] = 0;
  }
  uint64_t v16 = (const void *)a1[14];
  if (v16)
  {
    CFRelease(v16);
    a1[14] = 0;
  }
  uint64_t v17 = (const void *)a1[15];
  if (v17)
  {
    CFRelease(v17);
    a1[15] = 0;
  }
  uint64_t v18 = (const void *)a1[16];
  if (v18)
  {
    CFRelease(v18);
    a1[16] = 0;
  }
  uint64_t v19 = (const void *)a1[9];
  if (v19)
  {
    CFRelease(v19);
    a1[9] = 0;
  }
}

CFStringRef sub_1B6424CE0(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationManager %p>", a1);
}

CFStringRef sub_1B6424D20(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationManager %p>", a1);
}

void sub_1B6424D60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

BOOL sub_1B6424D70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (a2) {
      goto LABEL_3;
    }
LABEL_27:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_27;
  }
LABEL_3:
  uint64_t v10 = *(void *)(a2 + 16);
  if (sub_1B6439598(a2) || (*(unsigned char *)(a2 + 121) & 4) != 0) {
    return 0;
  }
  int v18 = sub_1B649394C(v10, v11, v12, v13, v14, v15, v16, v17);
  uint64_t v26 = 144;
  if (v18) {
    uint64_t v26 = 136;
  }
  double v27 = *(double *)(a1 + v26);
  int v28 = *(_DWORD *)(a2 + 121);
  if ((v28 & 2) != 0)
  {
    *(_DWORD *)(a2 + 121) = v28 & 0xFFFFFFFD;
    *(double *)(a2 + 80) = v27 + sub_1B64396D4(v10, v19, v20, v21, v22, v23, v24, v25);
    int v28 = *(_DWORD *)(a2 + 121);
  }
  __int16 v51 = 0;
  BOOL v50 = 0;
  double v35 = sub_1B6438D78(a2, (BOOL *)&v51 + 1, &v51, &v50, v22, v23, v24, v25, v27);
  unsigned int v36 = *(_DWORD *)(a2 + 121);
  int v37 = HIBYTE(v51);
  BOOL v38 = v50;
  *(_DWORD *)(a2 + 121) = v36 & 0xFFFFFFCF | (16 * HIBYTE(v51)) | (32 * v50);
  if (v36 & 0x20 | v38)
  {
    float v39 = *(float *)(v10 + 72);
    double v40 = v39;
    BOOL v41 = v39 == 0.0;
    double v42 = 1.0;
    if (!v41) {
      double v42 = v40;
    }
    double v43 = v35 / v42;
    float v44 = *(float *)(a2 + 72);
    float v45 = v43;
    *(float *)(a2 + 72) = v45;
    uint64_t v46 = *(void *)(v10 + 96);
    if (v46) {
      sub_1B661A8C0((void *)a1, v46, (v36 >> 4) & 1, v37 != 0, a2, v32, v33, v34, v44, v43);
    }
  }
  if (!*(unsigned char *)(a1 + 90))
  {
    int v47 = *(_DWORD *)(a2 + 121);
    if ((v47 & 1) == 0)
    {
      *(_DWORD *)(a2 + 121) = v47 | 1;
      if (*(void *)(v10 + 144)) {
        sub_1B6422158(a1, (char *)a2, 1, v30, v31, v32, v33, v34);
      }
    }
    if ((_BYTE)v51)
    {
      *(_DWORD *)(a2 + 121) |= 0x400u;
      sub_1B6424F58(a1, a2, v29, v30, v31, v32, v33, v34);
    }
  }
  BOOL result = 1;
  if ((v28 & 0x100) != 0 && (_BYTE)v51)
  {
    uint64_t v49 = *(void *)(a2 + 40);
    if (v49) {
      return (*(unsigned char *)(v49 + 122) & 1) == 0;
    }
    return 0;
  }
  return result;
}

void sub_1B6424F58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)(a1 + 90))
  {
    int v8 = *(_DWORD *)(a2 + 121);
    if ((v8 & 0x40) == 0)
    {
      *(_DWORD *)(a2 + 121) = v8 | 0x40;
      sub_1B6422158(a1, (char *)a2, 6, a4, a5, a6, a7, a8);
    }
  }
}

void sub_1B6424F7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (a1) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a1) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
LABEL_3:
  CFRetain((CFTypeRef)a2);
  if (*(unsigned char *)(a1 + 88)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Inconsistency in _CFXAnimationManagerRemoveAnimationNode: triggered while applying animations", v10, v11, v12, v13, v14, v15, (uint64_t)"manager->_applying == false");
  }
  sub_1B6424F58(a1, a2, v10, v11, v12, v13, v14, v15);
  if (*(unsigned char *)(a1 + 88)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationManagerRemoveAnimationNode removing an animation while applying", v16, v17, v18, v19, v20, v21, (uint64_t)"manager->_applying==false");
  }
  sub_1B6422240(a1, (void *)a2, v16, v17, v18, v19, v20, v21);
  *(_DWORD *)(a2 + 121) |= 0x800u;
  sub_1B643879C(a2, 0, v22, v23, v24, v25, v26, v27);
  uint64_t v35 = *(void *)(a2 + 192);
  if (v35) {
    sub_1B6420FC8(v35, (const void *)a2, v29, v30, v31, v32, v33, v34);
  }
  CFArrayRef v36 = sub_1B6438BB8(a2, v28, v29, v30, v31, v32, v33, v34);
  if ((uint64_t)v36 >= 1)
  {
    CFArrayRef v43 = v36;
    for (CFIndex i = 0; (const __CFArray *)i != v43; ++i)
    {
      CFArrayRef v45 = sub_1B6438C28(a2, i, v37, v38, v39, v40, v41, v42);
      sub_1B6424F7C(a1, v45);
    }
  }

  CFRelease((CFTypeRef)a2);
}

void sub_1B64250D8()
{
  if (!qword_1E9DDA770) {
    qword_1E9DDA770 = sub_1B63C8D10(&qword_1E9DDA770);
  }
}

uint64_t sub_1B642511C(float *a1, int a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2 - 1;
  float v11 = *a3;
  if (a2 - 1 >= 1)
  {
    uint64_t v12 = 0;
    do
    {
      int v13 = v10 + v12;
      if (v10 + (int)v12 < 0 != __OFADD__(v10, v12)) {
        int v14 = v13 + 1;
      }
      else {
        int v14 = v10 + v12;
      }
      if (v13 <= -2) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. _CFXPreviousKeyIndexForTime - unexpected integer division", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"middle >= 0");
      }
      int v15 = v14 >> 1;
      if (a1[v14 >> 1] >= v11)
      {
        int v10 = v15 - 1;
      }
      else
      {
        if (v12 == v15)
        {
          if (a1[v10] <= v11) {
            return v10;
          }
          else {
            return v12;
          }
        }
        uint64_t v12 = (v14 >> 1);
      }
    }
    while (v10 > (int)v12);
    if (v12) {
      return v12;
    }
  }
  uint64_t v12 = 0;
  if (*a1 > v11) {
    *a3 = *a1;
  }
  return v12;
}

uint64_t sub_1B6425204()
{
  if (qword_1E9DDA778 != -1) {
    dispatch_once(&qword_1E9DDA778, &unk_1F0FB5668);
  }
  CFTypeID v0 = qword_1E9DDA770;

  return sub_1B63C8D44(v0, 0x58uLL);
}

uint64_t sub_1B642525C(unsigned int a1, unsigned int a2, char a3, int a4, int a5)
{
  uint64_t v16 = sub_1B6425204();
  if (v16)
  {
    if (!a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"keyCount");
    }
    *(void *)(v16 + 40) = sub_1B63CA51C(4 * a1);
    *(_DWORD *)(v16 + 24) = a1;
    unsigned __int8 v24 = sub_1B63CA534(a2, v17, v18, v19, v20, v21, v22, v23);
    *(unsigned char *)(v16 + 30) = v24;
    *(_WORD *)(v16 + 28) = a2;
    *(unsigned char *)(v16 + 99) = a3;
    *(void *)(v16 + 48) = sub_1B63CA51C(v24 * a1);
    if (a4)
    {
      *(void *)(v16 + 56) = sub_1B63CA51C(4 * a1);
      *(void *)(v16 + 64) = sub_1B63CA51C(4 * a1);
      *(void *)(v16 + 72) = sub_1B63CA51C(4 * a1);
    }
    *(unsigned char *)(v16 + 98) = a4 & a5;
    if (a5)
    {
      unsigned __int8 v32 = sub_1B63CA958(a2, v25, v26, v27, v28, v29, v30, v31);
      *(unsigned char *)(v16 + 97) = v32;
      *(void *)(v16 + 80) = sub_1B63CA51C(v32 * 8 * a1);
      *(void *)(v16 + 88) = sub_1B63CA51C(8 * a1 * *(unsigned __int8 *)(v16 + 97));
    }
    *(void *)(v16 + 32) = sub_1B643079C(*(__int16 *)(v16 + 28), *(char *)(v16 + 99), 0, *(char *)(v16 + 31));
  }
  return v16;
}

BOOL sub_1B6425394(uint64_t a1, unsigned int a2, void *__src, const void *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, float a10, float a11, float a12)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)__src, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"controller");
  }
  unsigned int v21 = *(_DWORD *)(a1 + 24);
  if (v21 <= a2)
  {
    sub_1B63F2F54(16, @"Error: CFXKeyframeControllerRef - index out of bounds", (uint64_t)__src, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v31);
  }
  else
  {
    float v22 = a9;
    uint64_t v23 = *(void *)(a1 + 48);
    *(float *)(*(void *)(a1 + 40) + 4 * a2) = v22;
    double v24 = *(double *)(a1 + 16);
    if (v24 <= a9) {
      double v24 = a9;
    }
    *(double *)(a1 + 16) = v24;
    memcpy((void *)(v23 + *(unsigned __int8 *)(a1 + 30) * a2), __src, *(unsigned __int8 *)(a1 + 30));
    uint64_t v25 = *(void *)(a1 + 56);
    if (v25) {
      *(float *)(v25 + 4 * a2) = a10;
    }
    uint64_t v26 = *(void *)(a1 + 64);
    if (v26) {
      *(float *)(v26 + 4 * a2) = a11;
    }
    uint64_t v27 = *(void *)(a1 + 72);
    if (v27) {
      *(float *)(v27 + 4 * a2) = a12;
    }
    if (a4)
    {
      uint64_t v28 = *(void *)(a1 + 80);
      if (v28)
      {
        *(unsigned char *)(a1 + 98) = 0;
        memcpy((void *)(v28 + 8 * *(unsigned __int8 *)(a1 + 97) * a2), a4, 8 * *(unsigned __int8 *)(a1 + 97));
      }
    }
    if (a5)
    {
      uint64_t v29 = *(void *)(a1 + 88);
      if (v29)
      {
        *(unsigned char *)(a1 + 98) = 0;
        memcpy((void *)(v29 + 8 * *(unsigned __int8 *)(a1 + 97) * a2), a5, 8 * *(unsigned __int8 *)(a1 + 97));
      }
    }
  }
  return v21 > a2;
}

double sub_1B6425514(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  return *(double *)(a1 + 16);
}

uint64_t sub_1B6425560(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  if (!*(void *)(a1 + 48)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller->_values");
  }
  if (!*(void *)(a1 + 32)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller->_evaluate");
  }
  int v14 = *(_DWORD *)(a1 + 24);
  if (!v14)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXKeyframeControllerEvaluateAtTime animation has no key", a3, a4, a5, a6, a7, a8, (uint64_t)"controller->_keyCount > 0");
    int v14 = *(_DWORD *)(a1 + 24);
  }
  int v15 = *(unsigned __int8 *)(a1 + 31);
  float v16 = a9;
  float v29 = v16;
  unsigned int v17 = sub_1B642511C(*(float **)(a1 + 40), v14, &v29, a4, a5, a6, a7, a8);
  unsigned int v19 = v17;
  if (v17 + 1 < *(_DWORD *)(a1 + 24) - 1) {
    unsigned int v20 = v17 + 1;
  }
  else {
    unsigned int v20 = *(_DWORD *)(a1 + 24) - 1;
  }
  uint64_t v21 = *(void *)(a1 + 48);
  int v22 = *(unsigned __int8 *)(a1 + 30);
  uint64_t v23 = v21 + v17 * v22;
  uint64_t v24 = v21 + v20 * v22;
  if (v15 != 1 && *(_WORD *)(a1 + 28) != 3)
  {
    uint64_t v26 = *(void *)(a1 + 40);
    float v27 = *(float *)(v26 + 4 * v19);
    float v28 = *(float *)(v26 + 4 * v20) - v27;
    if (v28 == 0.0)
    {
      v18.n128_u64[0] = 0;
      if (v15) {
        goto LABEL_20;
      }
    }
    else
    {
      v18.n128_f64[0] = (float)((float)(v29 - v27) / v28);
      if (v15)
      {
LABEL_20:
        (*(void (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, __n128))(a1 + 32))(v23, v24, (char)v15, *(void *)(a1 + 88) + 8 * v19 * *(unsigned __int8 *)(a1 + 97), *(void *)(a1 + 80) + 8 * v20 * *(unsigned __int8 *)(a1 + 97), a3, a4, v18);
        return 1;
      }
    }
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t, uint64_t, __n128))(a1 + 32))(v23, v24, 0, 0, 0, a3, a4, v18);
    return 1;
  }
  if (a2) {
    uint64_t v23 = v21 + v20 * v22;
  }
  v18.n128_f64[0] = v29;
  (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t, uint64_t, __n128))(a1 + 32))(v23, v23, (char)v15, 0, 0, a3, a4, v18);
  return 1;
}

uint64_t sub_1B6425734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1B6425780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  return *(__int16 *)(a1 + 28);
}

double sub_1B64257CC(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  uint64_t v10 = *(void *)(a1 + 40);
  double result = 0.0;
  if (v10)
  {
    if (*(_DWORD *)(a1 + 24) > a2) {
      return *(float *)(v10 + 4 * a2);
    }
  }
  return result;
}

uint64_t sub_1B6425838(uint64_t a1, int a2, void *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)__dst, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  uint64_t v11 = *(void *)(a1 + 48);
  if (!v11) {
    return 0;
  }
  memcpy(__dst, (const void *)(v11 + *(unsigned __int8 *)(a1 + 30) * a2), *(unsigned __int8 *)(a1 + 30));
  return *(unsigned __int8 *)(a1 + 30);
}

void sub_1B64258B8(uint64_t a1, float32x4_t a2, float32x4_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a5, a6, a7, a8, a9, a10, (uint64_t)"controller");
  }
  if (!*(void *)(a1 + 48)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a5, a6, a7, a8, a9, a10, (uint64_t)"controller->_values");
  }
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  if (v11 >= 2)
  {
    if (!*(void *)(a1 + 40)) {
      *(void *)(a1 + 40) = sub_1B63CA51C(4 * v11);
    }
    uint64_t v12 = (v11 - 1);
    uint64_t v13 = *(float32x4_t **)(a1 + 48);
    uint64_t v14 = *(__int16 *)(a1 + 28);
    double v15 = 0.0;
    uint64_t v16 = 1;
    do
    {
      unsigned int v17 = v13;
      uint64_t v18 = *(void *)(a1 + 48);
      uint64_t v19 = v16 * *(unsigned __int8 *)(a1 + 30);
      uint64_t v13 = (float32x4_t *)(v18 + v19);
      switch((int)v14)
      {
        case 1:
          a2.f32[0] = vabds_f32(v17->f32[0], v13->f32[0]);
          goto LABEL_15;
        case 2:
          float v20 = v17->f32[0];
          float v21 = v13->f32[0];
          goto LABEL_25;
        case 3:
        case 15:
          LODWORD(v20) = v17->u8[0];
          LODWORD(v21) = v13->u8[0];
          goto LABEL_25;
        case 4:
          LODWORD(v20) = v17->i8[0];
          LODWORD(v21) = v13->i8[0];
          goto LABEL_25;
        case 6:
          *(double *)a2.i64 = vabdd_f64(*(double *)v17->i64, *(double *)v13->i64);
          break;
        case 7:
        case 17:
          float32x2_t v22 = vsub_f32(*(float32x2_t *)v17->f32, *(float32x2_t *)v13->f32);
          *(float32x2_t *)a2.f32 = vmul_f32(v22, v22);
          goto LABEL_14;
        case 8:
        case 18:
          a2.i64[0] = v17->i64[0];
          a2.i32[2] = v17->i32[2];
          a3.i64[0] = v13->i64[0];
          a3.i32[2] = v13->i32[2];
          float32x4_t v23 = vsubq_f32(a2, a3);
          float32x4_t v24 = vmulq_f32(v23, v23);
          a3 = vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1));
          a2 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), a3);
          a2.f32[0] = sqrtf(a2.f32[0]);
          goto LABEL_15;
        case 9:
        case 19:
          float32x4_t v25 = vsubq_f32(*v17, *v13);
          a2 = vmulq_f32(v25, v25);
          a3 = (float32x4_t)vextq_s8((int8x16_t)a2, (int8x16_t)a2, 8uLL);
          *(float32x2_t *)a2.f32 = vadd_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)a3.f32);
LABEL_14:
          a2.f32[0] = sqrtf(vaddv_f32(*(float32x2_t *)a2.f32));
          goto LABEL_15;
        case 10:
          float32x4_t v26 = vsubq_f32(*v17, *v13);
          float32x4_t v27 = vsubq_f32(v17[1], v13[1]);
          float32x4_t v28 = vsubq_f32(v17[2], v13[2]);
          float32x4_t v29 = vsubq_f32(v17[3], v13[3]);
          a2 = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v26, v26), v27, v27), v28, v28), v29, v29);
          a3 = (float32x4_t)vextq_s8((int8x16_t)a2, (int8x16_t)a2, 8uLL);
          a2.f32[0] = vaddv_f32(vadd_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)a3.f32));
          goto LABEL_15;
        case 12:
          a2.f32[0] = sub_1B63C9014(v17->f32, (float *)(v18 + v19));
LABEL_15:
          *(double *)a2.i64 = a2.f32[0];
          break;
        case 13:
          LODWORD(v20) = v17->i16[0];
          LODWORD(v21) = v13->i16[0];
          goto LABEL_25;
        case 16:
          LODWORD(v20) = v17->u16[0];
          LODWORD(v21) = v13->u16[0];
LABEL_25:
          *(double *)a2.i64 = fabs((double)(LODWORD(v20) - LODWORD(v21)));
          break;
        default:
          sub_1B63F2F54(0, @"Warning: _CFXKeyDistance - can't compute key distance for type %d", a5, a6, a7, a8, a9, a10, v14);
          a2.i64[0] = 0;
          break;
      }
      double v15 = v15 + *(double *)a2.i64;
      float v30 = v15;
      uint64_t v31 = *(_DWORD **)(a1 + 40);
      *(float *)&v31[v16++] = v30;
      uint64_t v32 = v16 - v12;
    }
    while (v16 - v12 != 1);
    *uint64_t v31 = 0;
    do
    {
      if (v15 == 0.0) {
        double v33 = (float)((float)v32 / (float)v11) + -1.0;
      }
      else {
        double v33 = *(float *)&v31[v32] / v15;
      }
      float v34 = v33;
      *(float *)&v31[v32++] = v34;
    }
    while (v11 != v32);
    *(double *)(a1 + 16) = *(float *)&v31[v12];
  }
}

void sub_1B6425BCC(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  *(unsigned char *)(a1 + 96) = a2;
}

uint64_t sub_1B6425C1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  return *(char *)(a1 + 96);
}

uint64_t (*sub_1B6425C68(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))()
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  *(unsigned char *)(a1 + 31) = a2;
  double result = sub_1B643079C(*(__int16 *)(a1 + 28), *(char *)(a1 + 99), 0, a2);
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t sub_1B6425CD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  return *(char *)(a1 + 31);
}

void sub_1B6425D1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  int v10 = *(unsigned __int8 *)(a1 + 31);
  if (*(void *)(a1 + 80))
  {
    if (v10 == 2)
    {
LABEL_5:
      uint64_t v11 = @"Warning: can't simplify keyframes because of cubic interpolation";
LABEL_14:
      sub_1B63F2F54(0, (uint64_t)v11, a3, a4, a5, a6, a7, a8, a9);
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 88)) {
      BOOL v12 = v10 == 2;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12) {
      goto LABEL_5;
    }
  }
  if (*(void *)(a1 + 56) || *(void *)(a1 + 72) || *(void *)(a1 + 64))
  {
    uint64_t v11 = @"Warning: can't simplify keyframes because of tcb values";
    goto LABEL_14;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 24);
  if (v13 >= 3)
  {
    memset(__dst, 0, sizeof(__dst));
    memset(v78, 0, sizeof(v78));
    memset(v77, 0, sizeof(v77));
    memset(v76, 0, sizeof(v76));
    uint64_t v19 = (const void *)sub_1B649185C();
    uint64_t v20 = 0;
    unsigned int v21 = 0;
    int v22 = *(unsigned __int16 *)(a1 + 28);
    BOOL v24 = v10 == 1 || v22 == 3;
    uint64_t v75 = v13;
    uint64_t v25 = (v13 - 1) - 1;
    uint64_t v26 = (char)v10;
    uint64_t v27 = (__int16)v22;
    do
    {
      sub_1B6425838(a1, v20 + 1, __dst, v14, v15, v16, v17, v18);
      sub_1B6425838(a1, v21, v77, v28, v29, v30, v31, v32);
      if (v24)
      {
        v38.n128_u64[0] = 0;
        (*(void (**)(_OWORD *, _OWORD *, uint64_t, void, void, void, _OWORD *, __n128))(a1 + 32))(v77, v77, v26, 0, 0, 0, v78, v38);
      }
      else
      {
        sub_1B6425838(a1, v20 + 2, v76, v33, v34, v35, v36, v37);
        double v50 = sub_1B64257CC(a1, (int)v20 + 1, v44, v45, v46, v47, v48, v49);
        double v57 = sub_1B64257CC(a1, v21, v51, v52, v53, v54, v55, v56);
        v64.n128_f64[0] = (v50 - v57) / (sub_1B64257CC(a1, (int)v20 + 2, v58, v59, v60, v61, v62, v63) - v57);
        (*(void (**)(_OWORD *, _OWORD *, uint64_t, void, void, void, _OWORD *, __n128))(a1 + 32))(v77, v76, v26, 0, 0, 0, v78, v64);
      }
      if (sub_1B642606C((float *)__dst, (float *)v78, v27, v39, v40, v41, v42, v43)) {
        unsigned int v21 = v20 + 1;
      }
      else {
        sub_1B6492824((uint64_t)v19, v20 + 1);
      }
      ++v20;
    }
    while (v25 != v20);
    uint64_t v65 = sub_1B6491884((uint64_t)v19);
    if (v65 >= 1)
    {
      int v66 = v75 - v65;
      uint64_t v68 = *(float **)(a1 + 40);
      uint64_t v67 = *(char **)(a1 + 48);
      *(_DWORD *)(a1 + 24) = v75 - v65;
      *(void *)(a1 + 40) = sub_1B63CA51C(4 * (v75 - v65));
      uint64_t v69 = sub_1B63CA51C(v66 * *(unsigned __int8 *)(a1 + 30));
      uint64_t v70 = 0;
      unsigned int v71 = 0;
      *(void *)(a1 + 48) = v69;
      do
      {
        if ((sub_1B6491CE0((uint64_t)v19, v70) & 1) == 0) {
          sub_1B6425394(a1, v71++, &v67[v70 * *(unsigned __int8 *)(a1 + 30)], 0, 0, v72, v73, v74, v68[v70], 0.0, 0.0, 0.0);
        }
        ++v70;
      }
      while (v75 != v70);
      if (v68) {
        free(v68);
      }
      if (v67) {
        free(v67);
      }
    }
    CFRelease(v19);
  }
}

BOOL sub_1B642606C(float *a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch((int)a3)
  {
    case 1:
    case 12:
      unint64_t v17 = sub_1B63CA534(a3, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      if (v17 < 4) {
        return 0;
      }
      if (vabds_f32(*a1, *a2) > 0.000001) {
        return 1;
      }
      unint64_t v13 = v17 >> 2;
      uint64_t v18 = 1;
      do
      {
        unint64_t v15 = v18;
        if (v13 == v18) {
          break;
        }
        double v19 = vabds_f32(a1[v18], a2[v18]);
        ++v18;
      }
      while (v19 <= 0.000001);
      return v15 < v13;
    case 2:
    case 3:
    case 4:
    case 5:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      size_t v10 = sub_1B63CA534(a3, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      return memcmp(a1, a2, v10) != 0;
    case 6:
      unint64_t v20 = sub_1B63CA534(a3, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      if (v20 < 8) {
        return 0;
      }
      if (vabdd_f64(*(double *)a1, *(double *)a2) > 0.000001) {
        return 1;
      }
      unint64_t v13 = v20 >> 3;
      uint64_t v21 = 1;
      do
      {
        unint64_t v15 = v21;
        if (v13 == v21) {
          break;
        }
        double v22 = vabdd_f64(*(double *)&a1[2 * v21], *(double *)&a2[2 * v21]);
        ++v21;
      }
      while (v22 <= 0.000001);
      return v15 < v13;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      unint64_t v12 = sub_1B63CA534(a3, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      if (v12 < 4) {
        return 0;
      }
      if (vabds_f32(*a1, *a2) > 0.000001) {
        return 1;
      }
      unint64_t v13 = v12 >> 2;
      uint64_t v14 = 1;
      do
      {
        unint64_t v15 = v14;
        if (v13 == v14) {
          break;
        }
        double v16 = vabds_f32(a1[v14], a2[v14]);
        ++v14;
      }
      while (v16 <= 0.000001);
      return v15 < v13;
    default:
      return 1;
  }
}

void sub_1B6426270(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  sub_1B6425D1C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v28);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"controller");
  }
  if (a2) {
    *a2 = 0;
  }
  if ((!*(void *)(a1 + 80) && !*(void *)(a1 + 88) || *(unsigned char *)(a1 + 31) != 2)
    && !*(void *)(a1 + 56)
    && !*(void *)(a1 + 72)
    && !*(void *)(a1 + 64)
    && *(_DWORD *)(a1 + 24) == 2)
  {
    memset(__dst, 0, sizeof(__dst));
    memset(v29, 0, sizeof(v29));
    __int16 v16 = *(_WORD *)(a1 + 28);
    if (sub_1B6425838(a1, 0, __dst, v11, v12, v13, v14, v15))
    {
      if (sub_1B6425838(a1, 1, v29, v17, v18, v19, v20, v21))
      {
        BOOL v27 = sub_1B642606C((float *)__dst, (float *)v29, v16, v22, v23, v24, v25, v26);
        if (a2)
        {
          if (!v27) {
            *a2 = 1;
          }
        }
      }
    }
  }
}

uint64_t sub_1B642639C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 97);
}

BOOL sub_1B64263A4(uint64_t a1)
{
  return *(void *)(a1 + 56) && *(void *)(a1 + 72) != 0;
}

float sub_1B64263C4(uint64_t a1, unsigned int a2)
{
  return *(float *)(*(void *)(a1 + 56) + 4 * a2);
}

float sub_1B64263D0(uint64_t a1, unsigned int a2)
{
  return *(float *)(*(void *)(a1 + 64) + 4 * a2);
}

float sub_1B64263DC(uint64_t a1, unsigned int a2)
{
  return *(float *)(*(void *)(a1 + 72) + 4 * a2);
}

BOOL sub_1B64263E8(uint64_t a1)
{
  return *(void *)(a1 + 80) && *(void *)(a1 + 88) != 0;
}

uint64_t sub_1B6426408(uint64_t a1, int a2)
{
  return *(void *)(a1 + 88) + 8 * *(unsigned __int8 *)(a1 + 97) * a2;
}

uint64_t sub_1B642641C(uint64_t a1, int a2)
{
  return *(void *)(a1 + 80) + 8 * *(unsigned __int8 *)(a1 + 97) * a2;
}

void sub_1B6426434(void *a1)
{
  CFAllocatorRef v2 = (void *)a1[5];
  if (v2) {
    free(v2);
  }
  CFIndex v3 = (void *)a1[6];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[7];
  if (v4) {
    free(v4);
  }
  uint64_t v5 = (void *)a1[8];
  if (v5) {
    free(v5);
  }
  uint64_t v6 = (void *)a1[9];
  if (v6) {
    free(v6);
  }
  uint64_t v7 = (void *)a1[10];
  if (v7) {
    free(v7);
  }
  int v8 = (void *)a1[11];
  if (v8)
  {
    free(v8);
  }
}

CFStringRef sub_1B64264C0(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXKeyframeController %p>", a1);
}

CFStringRef sub_1B6426500(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXKeyframeController %p>", a1);
}

char *sub_1B6426B00(char *result, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int a5, float a6)
{
  uint64_t v9 = result;
  unsigned int v10 = *a4;
  if (*a4 != a5 || *(float *)(a2 + 4 * (a5 - 1)) > a6)
  {
    unsigned int v11 = 0;
    if (v10)
    {
      unsigned int v12 = *a4;
      do
      {
        unsigned int v13 = v11 + (v12 >> 1);
        unsigned int v14 = v12 >> 1;
        v12 += ~(v12 >> 1);
        if (*(float *)(a2 + 4 * v13) <= a6) {
          unsigned int v11 = v13 + 1;
        }
        else {
          unsigned int v12 = v14;
        }
      }
      while (v12);
    }
    if (v10 + 1 < a5) {
      unsigned int v15 = v10 + 1;
    }
    else {
      unsigned int v15 = a5;
    }
    *a4 = v15;
    uint64_t v16 = v11;
    unsigned int v17 = v15 + ~v11;
    if (v17)
    {
      memmove(&result[8 * v11 + 8], &result[8 * v11], 8 * (v15 + ~v11));
      double result = (char *)memmove((void *)(a2 + 4 * v16 + 4), (const void *)(a2 + 4 * v16), 4 * v17);
    }
    *(void *)&v9[8 * v16] = a3;
    *(float *)(a2 + 4 * v16) = a6;
  }
  return result;
}

void vfx_uniform_grid_fill2d(void *a1, unint64_t *a2, unsigned int a3, float a4, float32x4_t a5, double a6)
{
  *(float *)&a6 = a4;
  a5.i64[0] = *a2;
  if (a3 < 2)
  {
    float32x4_t v11 = a5;
  }
  else
  {
    uint64_t v9 = a3 - 1;
    unsigned int v10 = a2 + 1;
    float32x4_t v11 = a5;
    do
    {
      unint64_t v12 = *v10++;
      v11.i32[3] = 0;
      float32x4_t v11 = vminnmq_f32(v11, (float32x4_t)v12);
      a5.i32[3] = 0;
      a5 = vmaxnmq_f32(a5, (float32x4_t)v12);
      --v9;
    }
    while (v9);
  }
  sub_1B6427324((uint64_t)a1, v11, a5, a6);
  sub_1B6426C88(a1, a2, a3);

  sub_1B6426D08((uint64_t)a1);
}

double sub_1B6426C88(void *a1, unint64_t *a2, unsigned int a3)
{
  sub_1B6428318((uint64_t)a1, a2, a3);
  uint64_t v6 = a1[15];
  int v7 = 0;
  uint64_t v8 = a1[16] - 1;
  if (a1[16] != 1)
  {
    uint64_t v9 = (int *)a1[15];
    uint64_t v10 = a1[16] - 1;
    do
    {
      int v11 = *v9;
      *v9++ = v7;
      v7 += v11;
      --v10;
    }
    while (v10);
  }
  *(_DWORD *)(v6 + 4 * v8) = v7;

  return sub_1B64283D8(a1, (uint64_t)a2, a3);
}

void sub_1B6426D08(uint64_t a1)
{
  v87[14] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *(void *)(a1 + 248) - *(void *)(a1 + 240);
  uint64_t v86 = (void *)(a1 + 288);
  unint64_t v74 = (v2 >> 2);
  sub_1B64279A8((void *)(a1 + 288), v74);
  uint64_t v4 = *(void *)(a1 + 288);
  uint64_t v3 = *(void *)(a1 + 296);
  while (v4 != v3)
  {
    *(void *)(v4 + 8) = *(void *)v4;
    sub_1B6427A50((void **)v4, 0x32uLL);
    v4 += 24;
  }
  if ((v2 & 0x3FFFFFFFCLL) == 0) {
    return;
  }
  uint64_t v5 = 0;
  v6.i64[0] = -1;
  v6.i64[1] = -1;
  int32x4_t v77 = vaddq_s32(*(int32x4_t *)a1, v6);
  v7.i32[3] = 8;
  do
  {
    uint64_t v8 = 0;
    unsigned int v9 = 0;
    unsigned int v10 = *(_DWORD *)(*(void *)(a1 + 240) + 4 * v5);
    int v11 = (int *)(*(void *)(a1 + 264) + 8 * v10);
    int v12 = *v11;
    unsigned int v13 = *(_DWORD *)(a1 + 40);
    int v14 = *v11 / v13;
    int v15 = *v11 % v13;
    v7.i32[0] = v15 % *(_DWORD *)a1;
    v7.i32[1] = v15 / *(_DWORD *)a1;
    v7.i32[2] = v14;
    int v16 = v11[1] + 1;
    int v17 = -1;
    int v18 = -1;
    do
    {
      int32x4_t v19 = vaddq_s32((int32x4_t)xmmword_1B6E503E0[v8], (int32x4_t)v7);
      uint32x4_t v20 = (uint32x4_t)vorrq_s8((int8x16_t)vcltzq_s32(v19), (int8x16_t)vcgtq_s32(v19, v77));
      v20.i32[3] = v20.i32[2];
      if ((vmaxvq_u32(v20) & 0x80000000) == 0)
      {
        int32x4_t v21 = vmulq_s32(*(int32x4_t *)(a1 + 32), v19);
        unsigned __int32 v22 = vaddq_s32(vaddq_s32(v21, vdupq_lane_s32(*(int32x2_t *)v21.i8, 1)), vdupq_laneq_s32(v21, 2)).u32[0];
        uint64_t v23 = *(void *)(a1 + 120);
        int v24 = *(_DWORD *)(v23 + 4 * v22);
        int v25 = *(_DWORD *)(v23 + 4 * (v22 + 1));
        if (v24 != v25)
        {
          if (v12 == v22)
          {
            v24 += v16;
          }
          else if (v17 == v24)
          {
            int v26 = v9 - 1;
LABEL_14:
            BOOL v27 = (int *)&v87[v26];
            *BOOL v27 = v18;
            v27[1] = v25;
            int v17 = v25;
            goto LABEL_15;
          }
          int v26 = v9++;
          int v18 = v24;
          goto LABEL_14;
        }
      }
LABEL_15:
      ++v8;
    }
    while (v8 != 14);
    uint64_t v75 = v5;
    if (v9)
    {
      uint64_t v28 = 0;
      uint64_t v29 = (const float *)(*(void *)(a1 + 168) + 4 * v5);
      float32x4_t v30 = vld1q_dup_f32(v29);
      uint64_t v31 = (const float *)(*(void *)(a1 + 192) + 4 * v5);
      float32x4_t v32 = vld1q_dup_f32(v31);
      float32x4_t v81 = v32;
      float32x4_t v82 = v30;
      uint64_t v33 = (const float *)(*(void *)(a1 + 216) + 4 * v5);
      float32x4_t v34 = vld1q_dup_f32(v33);
      v32.f32[0] = *(float *)(a1 + 112) * *(float *)(a1 + 112);
      int8x16_t v7 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 0);
      float32x4_t v79 = (float32x4_t)v7;
      float32x4_t v80 = v34;
      uint64_t v76 = v9;
      do
      {
        uint64_t v78 = v28;
        uint64_t v35 = &v87[v28];
        unsigned int v36 = v35[1];
        unsigned int v37 = *v35 & 0xFFFFFFFC;
        if (v37 < v36)
        {
          unsigned int v83 = v35[1];
          unsigned int v84 = (0xF0u >> (4 - (v36 & 3))) & 0xF;
          int v38 = ~(-1 << (*v35 & 3));
          do
          {
            unsigned int v85 = v37 + 4;
            unsigned int v39 = v84;
            if ((int)(v37 + 4 - v36) <= 0) {
              unsigned int v39 = 0;
            }
            uint64_t v40 = 4 * v37;
            float32x4_t v41 = vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 168) + v40), v82);
            float32x4_t v42 = vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 192) + v40), v81);
            float32x4_t v43 = vsubq_f32(*(float32x4_t *)(*(void *)(a1 + 216) + v40), v80);
            int8x16_t v7 = vandq_s8((int8x16_t)vcltzq_s32((int32x4_t)vsubq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v42, v42), v41, v41), v43, v43), v79)), (int8x16_t)xmmword_1B6E50330);
            *(int8x8_t *)v7.i8 = vorr_s8(*(int8x8_t *)v7.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
            for (unsigned int i = vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).u32[0] & ~(v39 | v38);
                  i;
                  *uint64_t v63 = v65)
            {
              unsigned int v45 = __clz(__rbit32(i));
              unsigned int v46 = *(_DWORD *)(*(void *)(a1 + 240) + 4 * (v45 + v37));
              uint64_t v47 = *(void *)(a1 + 288) + 24 * v10;
              uint64_t v49 = (unsigned int **)(v47 + 8);
              uint64_t v48 = *(unsigned int **)(v47 + 8);
              uint64_t v51 = (void *)(v47 + 16);
              unint64_t v50 = *(void *)(v47 + 16);
              if ((unint64_t)v48 >= v50)
              {
                uint64_t v53 = *(unsigned int **)v47;
                uint64_t v54 = ((uint64_t)v48 - *(void *)v47) >> 2;
                unint64_t v55 = v54 + 1;
                if ((unint64_t)(v54 + 1) >> 62) {
                  goto LABEL_60;
                }
                uint64_t v56 = v50 - (void)v53;
                if (v56 >> 1 > v55) {
                  unint64_t v55 = v56 >> 1;
                }
                if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v57 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v57 = v55;
                }
                if (v57)
                {
                  uint64_t v58 = (char *)sub_1B64282E0((uint64_t)v51, v57);
                  uint64_t v48 = *v49;
                  uint64_t v53 = *(unsigned int **)v47;
                }
                else
                {
                  uint64_t v58 = 0;
                }
                uint64_t v59 = &v58[4 * v54];
                *(_DWORD *)uint64_t v59 = v46;
                uint64_t v52 = (unsigned int *)(v59 + 4);
                while (v48 != v53)
                {
                  int v60 = *--v48;
                  *((_DWORD *)v59 - 1) = v60;
                  v59 -= 4;
                }
                *(void *)uint64_t v47 = v59;
                *uint64_t v49 = v52;
                *uint64_t v51 = &v58[4 * v57];
                if (v53) {
                  operator delete(v53);
                }
              }
              else
              {
                *uint64_t v48 = v46;
                uint64_t v52 = v48 + 1;
              }
              *uint64_t v49 = v52;
              uint64_t v61 = *v86 + 24 * v46;
              uint64_t v63 = (unsigned int **)(v61 + 8);
              uint64_t v62 = *(unsigned int **)(v61 + 8);
              unint64_t v64 = *(void *)(v61 + 16);
              if ((unint64_t)v62 >= v64)
              {
                int v66 = *(unsigned int **)v61;
                uint64_t v67 = ((uint64_t)v62 - *(void *)v61) >> 2;
                unint64_t v68 = v67 + 1;
                if ((unint64_t)(v67 + 1) >> 62) {
LABEL_60:
                }
                  abort();
                uint64_t v69 = v64 - (void)v66;
                if (v69 >> 1 > v68) {
                  unint64_t v68 = v69 >> 1;
                }
                if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v70 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v70 = v68;
                }
                if (v70)
                {
                  unsigned int v71 = (char *)sub_1B64282E0(v61 + 16, v70);
                  uint64_t v62 = *v63;
                  int v66 = *(unsigned int **)v61;
                }
                else
                {
                  unsigned int v71 = 0;
                }
                uint64_t v72 = &v71[4 * v67];
                *(_DWORD *)uint64_t v72 = v10;
                uint64_t v65 = (unsigned int *)(v72 + 4);
                while (v62 != v66)
                {
                  int v73 = *--v62;
                  *((_DWORD *)v72 - 1) = v73;
                  v72 -= 4;
                }
                *(void *)uint64_t v61 = v72;
                *uint64_t v63 = v65;
                *(void *)(v61 + 16) = &v71[4 * v70];
                if (v66) {
                  operator delete(v66);
                }
              }
              else
              {
                *uint64_t v62 = v10;
                uint64_t v65 = v62 + 1;
              }
              i &= ~(1 << v45);
            }
            int v38 = 0;
            v37 += 4;
            unsigned int v36 = v83;
          }
          while (v85 < v83);
        }
        uint64_t v28 = v78 + 1;
      }
      while (v78 + 1 != v76);
    }
    uint64_t v5 = v75 + 1;
  }
  while (v75 + 1 != v74);
}

void vfx_uniform_grid_fill3d(void *a1, float32x4_t *a2, unsigned int a3, float a4, double a5, double a6)
{
  *(float *)&a6 = a4;
  float32x4_t v9 = *a2;
  if (a3 < 2)
  {
    float32x4_t v12 = *a2;
  }
  else
  {
    uint64_t v10 = a3 - 1;
    int v11 = a2 + 1;
    float32x4_t v12 = *a2;
    do
    {
      float32x4_t v13 = *v11++;
      float32x4_t v14 = v13;
      v12.i32[3] = 0;
      v14.i32[3] = 0;
      float32x4_t v12 = vminnmq_f32(v12, v14);
      v9.i32[3] = 0;
      float32x4_t v9 = vmaxnmq_f32(v9, v14);
      --v10;
    }
    while (v10);
  }
  sub_1B6427324((uint64_t)a1, v12, v9, a6);
  sub_1B64272A0(a1, a2, a3);

  sub_1B6426D08((uint64_t)a1);
}

double sub_1B64272A0(void *a1, float32x4_t *a2, unsigned int a3)
{
  sub_1B642889C((uint64_t)a1, a2, a3);
  uint64_t v6 = a1[15];
  int v7 = 0;
  uint64_t v8 = a1[16] - 1;
  if (a1[16] != 1)
  {
    float32x4_t v9 = (int *)a1[15];
    uint64_t v10 = a1[16] - 1;
    do
    {
      int v11 = *v9;
      *v9++ = v7;
      v7 += v11;
      --v10;
    }
    while (v10);
  }
  *(_DWORD *)(v6 + 4 * v8) = v7;

  *(void *)&double result = sub_1B6428954(a1, (uint64_t)a2, a3).n128_u64[0];
  return result;
}

void sub_1B6427324(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4)
{
  float32x4_t v5 = vmulq_f32(vsubq_f32(a3, a2), (float32x4_t)vdupq_n_s32(0x3C23D70Au));
  float32x4_t v6 = vsubq_f32(a2, v5);
  float32x4_t v7 = vaddq_f32(a3, v5);
  float32x4_t v8 = vsubq_f32(v7, v6);
  *(float *)&a4 = fmaxf(*(float *)&a4, fmaxf(fmaxf(v8.f32[0], v8.f32[2]), v8.f32[1]) * 0.0039062);
  float32x4_t v9 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
  *(_DWORD *)(a1 + 112) = LODWORD(a4);
  *(float32x4_t *)(a1 + 64) = v7;
  *(float32x4_t *)(a1 + 80) = v9;
  __asm { FMOV            V1.4S, #1.0 }
  *(float32x4_t *)(a1 + 96) = vdivq_f32(_Q1, v9);
  float32x4_t v19 = v9;
  int32x4_t v15 = vcvtq_s32_f32(vdivq_f32(v8, v9));
  v16.i64[0] = 0x100000001;
  v16.i64[1] = 0x100000001;
  int32x4_t v17 = vaddq_s32(v15, v16);
  *(int32x4_t *)a1 = v17;
  *(int32x4_t *)(a1 + 16) = v15;
  v16.i32[1] = v17.i32[0];
  v16.i32[2] = v17.i32[0] * v17.i32[1];
  *(int32x4_t *)(a1 + 32) = v16;
  *(float32x4_t *)(a1 + 48) = v6;
  unint64_t v18 = v17.i32[0] * v17.i32[1] * v17.i32[2] + 1;
  *(void *)(a1 + 128) = v18;
  if (*(void *)(a1 + 136) >= v18)
  {
    bzero(*(void **)(a1 + 120), 4 * v18);
  }
  else
  {
    *(void *)(a1 + 136) = v18;
    free(*(void **)(a1 + 120));
    *(void *)(a1 + 120) = malloc_type_calloc(*(void *)(a1 + 128), 4uLL, 0x100004052888210uLL);
  }
  *(float32x4_t *)(a1 + 64) = vmlaq_f32(*(float32x4_t *)(a1 + 48), vcvtq_f32_s32(*(int32x4_t *)a1), v19);

  sub_1B6427B4C(a1 + 144, 0);
}

char *vfx_uniform_grid_add_points(uint64_t a1, char *__src, unsigned int a3)
{
  return sub_1B6427CC4(a1 + 144, *(void *)(a1 + 152), __src, &__src[16 * a3], a3);
}

double vfx_uniform_grid_finalize(uint64_t a1)
{
  return sub_1B64272A0((void *)a1, *(float32x4_t **)(a1 + 144), (*(void *)(a1 + 152) - *(void *)(a1 + 144)) >> 4);
}

uint64_t sub_1B6427494(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  unsigned int v60 = 0;
  *(double *)v5.i64 = MEMORY[0x1F4188790](a1, a2);
  __int32 v55 = v8.i32[1];
  __int32 v59 = v8.i32[3];
  float32x4_t v53 = v5;
  int v54 = v9;
  uint64_t v56 = v10;
  unint64_t v57 = &v50[-v11];
  int v58 = v12;
  LOBYTE(v59) = v13;
  float v15 = *(float *)(v14 + 112);
  if (v15 * 0.5 <= v7)
  {
    if (v7 >= v15)
    {
      sub_1B6427F60((char *)a1, 0, (*(void *)(a1 + 248) - *(void *)(a1 + 240)) >> 2, &v60, (uint64_t)&v53);
      return v60;
    }
    else
    {
      uint64_t result = 0;
      v34.i64[0] = -1;
      v34.i64[1] = -1;
      int32x4_t v35 = vaddq_s32((int32x4_t)v6, v34);
      v35.i32[3] = 0;
      int32x4_t v36 = vmaxq_s32(v35, v8);
      int32x4_t v37 = vaddq_s32(*(int32x4_t *)a1, v34);
      v38.i64[0] = 0x100000001;
      v38.i64[1] = 0x100000001;
      int32x4_t v39 = vaddq_s32((int32x4_t)v6, v38);
      v37.i32[3] = 0;
      v39.i32[3] = 0;
      int32x4_t v40 = vminq_s32(v37, v39);
      __int32 v41 = v36.i32[2];
      __int32 v42 = v40.i32[2];
      if (v36.i32[2] <= v40.i32[2])
      {
        uint64_t result = 0;
        __int32 v43 = v36.i32[1];
        __int32 v44 = v40.i32[1];
        __int32 v45 = v36.i32[0];
        __int32 v46 = v40.i32[0];
        __int32 v47 = v40.i32[0] + 1;
        __int32 v51 = v36.i32[1];
        uint64_t v52 = v50;
        while (v43 > v44)
        {
LABEL_19:
          BOOL v31 = v41++ == v42;
          __int32 v43 = v51;
          if (v31) {
            return result;
          }
        }
        while (1)
        {
          __int32 v48 = v45;
          if (v45 <= v46) {
            break;
          }
LABEL_26:
          BOOL v31 = v43++ == v44;
          if (v31) {
            goto LABEL_19;
          }
        }
        while (1)
        {
          v36.i64[0] = __PAIR64__(v43, v48);
          v36.i32[2] = v41;
          int32x4_t v49 = vmulq_s32(*(int32x4_t *)(a1 + 32), v36);
          v49.i32[0] = vaddq_s32(vaddq_s32(v49, vdupq_lane_s32(*(int32x2_t *)v49.i8, 1)), vdupq_laneq_s32(v49, 2)).u32[0];
          sub_1B6427F60((char *)a1, *(_DWORD *)(*(void *)(a1 + 120) + 4 * v49.u32[0]), *(_DWORD *)(*(void *)(a1 + 120) + 4 * (v49.i32[0] + 1)), &v60, (uint64_t)&v53);
          uint64_t result = v60;
          if (a3)
          {
            if (v60 == a3) {
              break;
            }
          }
          if (v47 == ++v48) {
            goto LABEL_26;
          }
        }
      }
    }
  }
  else
  {
    uint64_t result = 0;
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    float32x4_t v18 = vmlaq_f32(*(float32x4_t *)(a1 + 48), *(float32x4_t *)(a1 + 80), vaddq_f32(vcvtq_f32_s32((int32x4_t)v6), v17));
    v17.i64[0] = -1;
    v17.i64[1] = -1;
    int32x4_t v19 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, v5), v6, (int8x16_t)vaddq_s32((int32x4_t)v6, (int32x4_t)v17));
    v19.i32[3] = 0;
    int32x4_t v20 = vmaxq_s32(v19, v8);
    int32x4_t v21 = vaddq_s32(*(int32x4_t *)a1, (int32x4_t)v17);
    v17.i64[0] = 0x100000001;
    v17.i64[1] = 0x100000001;
    int32x4_t v22 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v5, v18), v6, (int8x16_t)vaddq_s32((int32x4_t)v6, (int32x4_t)v17));
    v21.i32[3] = 0;
    v22.i32[3] = 0;
    int32x4_t v23 = vminq_s32(v21, v22);
    __int32 v24 = v20.i32[2];
    __int32 v25 = v23.i32[2];
    if (v20.i32[2] <= v23.i32[2])
    {
      uint64_t result = 0;
      __int32 v26 = v20.i32[1];
      __int32 v27 = v23.i32[1];
      __int32 v28 = v20.i32[0];
      __int32 v29 = v23.i32[0];
      __int32 v30 = v23.i32[0] + 1;
      __int32 v51 = v20.i32[1];
      uint64_t v52 = v50;
      while (v26 > v27)
      {
LABEL_5:
        BOOL v31 = v24++ == v25;
        __int32 v26 = v51;
        if (v31) {
          return result;
        }
      }
      while (1)
      {
        __int32 v32 = v28;
        if (v28 <= v29) {
          break;
        }
LABEL_12:
        BOOL v31 = v26++ == v27;
        if (v31) {
          goto LABEL_5;
        }
      }
      while (1)
      {
        v23.i64[0] = __PAIR64__(v26, v32);
        v23.i32[2] = v24;
        int32x4_t v33 = vmulq_s32(*(int32x4_t *)(a1 + 32), v23);
        v33.i32[0] = vaddq_s32(vaddq_s32(v33, vdupq_lane_s32(*(int32x2_t *)v33.i8, 1)), vdupq_laneq_s32(v33, 2)).u32[0];
        sub_1B6427F60((char *)a1, *(_DWORD *)(*(void *)(a1 + 120) + 4 * v33.u32[0]), *(_DWORD *)(*(void *)(a1 + 120) + 4 * (v33.i32[0] + 1)), &v60, (uint64_t)&v53);
        uint64_t result = v60;
        if (a3)
        {
          if (v60 == a3) {
            break;
          }
        }
        if (v30 == ++v32) {
          goto LABEL_12;
        }
      }
    }
  }
  return result;
}

uint64_t vfx_uniform_grid_apply(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = (void *)(*(void *)(result + 288) + 24 * a2);
  if (((v3[1] - *v3) >> 2)) {
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  return result;
}

uint64_t vfx_uniform_grid_find(uint64_t a1, unsigned int a2, void *a3, unsigned int a4)
{
  uint64_t v4 = *(void *)(a1 + 288) + 24 * a2;
  uint64_t v5 = (*(void *)(v4 + 8) - *(void *)v4) >> 2;
  if (a3)
  {
    bzero(a3, 4 * a4);
    if (v5)
    {
      if (v5 >= a4) {
        uint64_t v5 = a4;
      }
      else {
        uint64_t v5 = v5;
      }
      memcpy(a3, *(const void **)v4, 4 * v5);
    }
  }
  return v5;
}

uint64_t vfx_uniform_grid_get_count(uint64_t a1, unsigned int a2)
{
  return (*(void *)(*(void *)(a1 + 288) + 24 * a2 + 8) - *(void *)(*(void *)(a1 + 288) + 24 * a2)) >> 2;
}

__n128 vfx_uniform_grid_get_aabb(uint64_t a1, _OWORD *a2, __n128 *a3)
{
  *a2 = *(_OWORD *)(a1 + 48);
  __n128 result = *(__n128 *)(a1 + 64);
  *a3 = result;
  return result;
}

float32x4_t *vfx_uniform_grid_for_each_cell(float32x4_t *result, uint64_t a2, double a3, int32x4_t a4)
{
  uint64_t v4 = (result->i32[0] * result->i32[1] * result->i32[2]);
  if (v4)
  {
    int8x16_t v6 = result;
    for (uint64_t i = 0; i != v4; ++i)
    {
      int v8 = *(_DWORD *)(v6[7].i64[1] + 4 * i);
      int v9 = *(_DWORD *)(v6[7].i64[1] + 4 * i + 4);
      uint64_t v10 = (v9 - v8);
      if (v9 != v8)
      {
        unsigned __int32 v11 = v6[2].u32[2];
        unsigned int v12 = i / v11;
        signed int v13 = i % v11;
        a4.i32[0] = v13 % v6->i32[0];
        a4.i32[1] = v13 / v6->i32[0];
        a4.i32[2] = v12;
        float32x4_t v14 = v6[5];
        __n128 v15 = (__n128)vmlaq_f32(v6[3], v14, vcvtq_f32_s32(a4));
        __n128 result = (float32x4_t *)(*(uint64_t (**)(uint64_t, uint64_t, __n128, float32x4_t))(a2 + 16))(a2, v10, v15, vaddq_f32(v14, (float32x4_t)v15));
      }
    }
  }
  return result;
}

void sub_1B64279A8(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1B6428044(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = a1[1];
      do
      {
        uint64_t v10 = *(void **)(v8 - 24);
        v8 -= 24;
        int v9 = v10;
        if (v10)
        {
          *(void *)(v3 - 16) = v9;
          operator delete(v9);
        }
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void sub_1B6427A50(void **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)sub_1B64282E0(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    int v9 = &v6[4 * v8];
    uint64_t v10 = (char *)*a1;
    unsigned __int32 v11 = (char *)a1[1];
    unsigned int v12 = v7;
    if (v11 != *a1)
    {
      unsigned int v12 = v7;
      do
      {
        int v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void sub_1B6427AF4(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      unint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      int64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void sub_1B6427B4C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    sub_1B6427B7C((void **)a1, a2 - v2);
  }
}

void sub_1B6427B7C(void **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      int v13 = (char *)sub_1B6427C8C(v4, v12);
    }
    else {
      int v13 = 0;
    }
    float32x4_t v14 = &v13[16 * v10];
    __n128 v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    int32x4_t v16 = &v14[16 * a2];
    float32x4_t v18 = (char *)*a1;
    float32x4_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        long long v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 16;
      }
      while (v17 != v18);
      float32x4_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *sub_1B6427C8C(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_1B63C8620();
  }
  return operator new(16 * a2);
}

char *sub_1B6427CC4(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  int64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    int v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 >> 60) {
      abort();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 4;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      float32x4_t v18 = (char *)sub_1B6427C8C(v9, v17);
    }
    else {
      float32x4_t v18 = 0;
    }
    __int32 v28 = &v18[16 * v15];
    __p = v18;
    int32x4_t v34 = v28;
    int32x4_t v36 = &v18[16 * v17];
    uint64_t v29 = 16 * a5;
    __int32 v30 = &v28[16 * a5];
    do
    {
      long long v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)__int32 v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    int32x4_t v35 = v30;
    int64_t v5 = sub_1B6427E98((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    int32x4_t v21 = &__src[16 * a5];
    int32x4_t v23 = *(char **)(v9 - 8);
LABEL_17:
    __int32 v24 = &v5[16 * a5];
    __int32 v25 = &v23[-16 * a5];
    __int32 v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      __int32 v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)__int32 v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  int32x4_t v21 = &__src[16 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  }
  int32x4_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

char *sub_1B6427E98(void **a1, uint64_t a2, char *__src)
{
  int64_t v5 = *(char **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      long long v9 = *((_OWORD *)v8 - 1);
      v8 -= 16;
      *((_OWORD *)v7 - 1) = v9;
      v7 -= 16;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  int v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

char *sub_1B6427F60(char *result, unsigned int a2, unsigned int a3, unsigned int *a4, uint64_t a5)
{
  unsigned int v5 = a3 - a2;
  if (a3 > a2)
  {
    uint64_t v8 = result;
    uint64_t v9 = 4 * a2;
    do
    {
      float v10 = *(float *)(*((void *)v8 + 21) + v9) - *(float *)a5;
      float v11 = *(float *)(*((void *)v8 + 24) + v9) - *(float *)(a5 + 4);
      float v12 = *(float *)(*((void *)v8 + 27) + v9) - *(float *)(a5 + 8);
      float v13 = (float)((float)(v11 * v11) + (float)(v10 * v10)) + (float)(v12 * v12);
      if (v13 < *(float *)(a5 + 16))
      {
        unsigned int v14 = *(_DWORD *)(a5 + 40);
        if (!v14)
        {
          int v16 = *a4 + 1;
LABEL_10:
          *a4 = v16;
          goto LABEL_11;
        }
        uint64_t v15 = *(unsigned int *)(*((void *)v8 + 30) + v9);
        if (!*(unsigned char *)(a5 + 44))
        {
          uint64_t v17 = *a4;
          if (v17 >= v14) {
            return result;
          }
          *(void *)(*(void *)(a5 + 24) + 8 * v17) = v15;
          int v16 = v17 + 1;
          goto LABEL_10;
        }
        __n128 result = sub_1B6426B00(*(char **)(a5 + 24), *(void *)(a5 + 32), v15, a4, v14, v13);
      }
LABEL_11:
      v9 += 4;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_1B6428044(void *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      float v12 = (char *)sub_1B6428204(v4, v11);
    }
    else {
      float v12 = 0;
    }
    uint64_t v15 = v12;
    int v16 = &v12[24 * v8];
    float32x4_t v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    sub_1B6428194(a1, &v15);
    sub_1B642824C((uint64_t)&v15);
  }
}

void *sub_1B6428194(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  unint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    *unint64_t v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *__n128 result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1B6428204(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_1B63C8620();
  }
  return operator new(24 * a2);
}

uint64_t sub_1B642824C(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1B6428284(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    long long v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void *sub_1B64282E0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_1B63C8620();
  }
  return operator new(4 * a2);
}

void sub_1B6428318(uint64_t a1, unint64_t *a2, unsigned int a3)
{
  uint64_t v6 = a3;
  sub_1B6428494(a1 + 264, a3);
  if (a3)
  {
    uint64_t v7 = *(void *)(a1 + 120);
    uint64_t v8 = (_DWORD *)(*(void *)(a1 + 264) + 4);
    do
    {
      unint64_t v9 = *a2++;
      int32x4_t v10 = *(int32x4_t *)(a1 + 16);
      v10.i32[3] = 0;
      int32x4_t v11 = vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)(a1 + 96), vsubq_f32((float32x4_t)v9, *(float32x4_t *)(a1 + 48))));
      v11.i32[3] = 0;
      int32x4_t v12 = vminq_s32(v10, v11);
      v12.i32[3] = 0;
      int32x4_t v13 = vmulq_s32(*(int32x4_t *)(a1 + 32), vmaxq_s32(v12, (int32x4_t)0));
      v13.i32[0] = vaddq_s32(vaddq_s32(v13, vdupq_lane_s32(*(int32x2_t *)v13.i8, 1)), vdupq_laneq_s32(v13, 2)).u32[0];
      int v14 = *(_DWORD *)(v7 + 4 * v13.u32[0]);
      *(_DWORD *)(v7 + 4 * v13.u32[0]) = v14 + 1;
      *(v8 - 1) = v13.i32[0];
      _DWORD *v8 = v14;
      v8 += 2;
      --v6;
    }
    while (v6);
  }
}

double sub_1B64283D8(void *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v6 = a3;
  sub_1B642860C((uint64_t)(a1 + 21), a3);
  sub_1B642860C((uint64_t)(a1 + 24), v6);
  sub_1B642860C((uint64_t)(a1 + 27), v6);
  sub_1B642863C((uint64_t)(a1 + 30), v6);
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a1[15];
    uint64_t v10 = a1[21];
    uint64_t v11 = a1[24];
    uint64_t v12 = a1[27];
    uint64_t v13 = a1[30];
    int v14 = (_DWORD *)(a1[33] + 4);
    do
    {
      unsigned int v15 = *v14 + *(_DWORD *)(v9 + 4 * *(v14 - 1));
      double result = *(double *)(a2 + 8 * v8);
      *(_DWORD *)(v10 + 4 * v15) = LODWORD(result);
      *(_DWORD *)(v11 + 4 * v15) = HIDWORD(result);
      *(_DWORD *)(v12 + 4 * v15) = 0;
      *(_DWORD *)(v13 + 4 * v15) = v8++;
      v14 += 2;
    }
    while (v6 != v8);
  }
  return result;
}

void sub_1B6428494(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_1B64284C4((void **)a1, a2 - v2);
  }
}

void sub_1B64284C4(void **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  long long v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      uint64_t v13 = (char *)sub_1B64285D4(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    int v14 = &v13[8 * v10];
    unsigned int v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    int v16 = &v14[8 * a2];
    float32x4_t v18 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *sub_1B64285D4(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1B63C8620();
  }
  return operator new(8 * a2);
}

void sub_1B642860C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    sub_1B642866C((char **)a1, a2 - v2);
  }
}

void sub_1B642863C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    sub_1B6428784((char **)a1, a2 - v2);
  }
}

void sub_1B642866C(char **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  long long v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      abort();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      int v14 = (char *)sub_1B64282E0(v4, v13);
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      int v14 = 0;
    }
    unsigned int v15 = &v14[4 * v11];
    int v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    uint64_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void sub_1B6428784(char **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  long long v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      abort();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      int v14 = (char *)sub_1B64282E0(v4, v13);
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      int v14 = 0;
    }
    unsigned int v15 = &v14[4 * v11];
    int v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    uint64_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void sub_1B642889C(uint64_t a1, float32x4_t *a2, unsigned int a3)
{
  uint64_t v6 = a3;
  sub_1B6428494(a1 + 264, a3);
  if (a3)
  {
    uint64_t v7 = *(void *)(a1 + 120);
    uint64_t v8 = (_DWORD *)(*(void *)(a1 + 264) + 4);
    do
    {
      float32x4_t v9 = *a2++;
      int32x4_t v10 = *(int32x4_t *)(a1 + 16);
      v10.i32[3] = 0;
      int32x4_t v11 = vcvtq_s32_f32(vmulq_f32(vsubq_f32(v9, *(float32x4_t *)(a1 + 48)), *(float32x4_t *)(a1 + 96)));
      v11.i32[3] = 0;
      int32x4_t v12 = vminq_s32(v10, v11);
      v12.i32[3] = 0;
      int32x4_t v13 = vmulq_s32(*(int32x4_t *)(a1 + 32), vmaxq_s32(v12, (int32x4_t)0));
      v13.i32[0] = vaddq_s32(vaddq_s32(v13, vdupq_lane_s32(*(int32x2_t *)v13.i8, 1)), vdupq_laneq_s32(v13, 2)).u32[0];
      int v14 = *(_DWORD *)(v7 + 4 * v13.u32[0]);
      *(_DWORD *)(v7 + 4 * v13.u32[0]) = v14 + 1;
      *(v8 - 1) = v13.i32[0];
      _DWORD *v8 = v14;
      v8 += 2;
      --v6;
    }
    while (v6);
  }
}

__n128 sub_1B6428954(void *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v6 = a3;
  sub_1B642860C((uint64_t)(a1 + 21), a3);
  sub_1B642860C((uint64_t)(a1 + 24), v6);
  sub_1B642860C((uint64_t)(a1 + 27), v6);
  sub_1B642863C((uint64_t)(a1 + 30), v6);
  if (a3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a1[15];
    uint64_t v10 = a1[21];
    uint64_t v11 = a1[24];
    uint64_t v12 = a1[27];
    uint64_t v13 = a1[30];
    int v14 = (_DWORD *)(a1[33] + 4);
    do
    {
      __n128 result = *(__n128 *)(a2 + 16 * v8);
      unsigned int v15 = *v14 + *(_DWORD *)(v9 + 4 * *(v14 - 1));
      *(_DWORD *)(v10 + 4 * v15) = result.n128_u32[0];
      *(_DWORD *)(v11 + 4 * v15) = result.n128_u32[1];
      *(_DWORD *)(v12 + 4 * v15) = result.n128_u32[2];
      *(_DWORD *)(v13 + 4 * v15) = v8++;
      v14 += 2;
    }
    while (v6 != v8);
  }
  return result;
}

void sub_1B6428B88(void *a1, unint64_t a2, long long *a3, long long *a4)
{
  uint64_t v8 = a1[1];
  if (!a1[8]) {
    a1[8] = sub_1B6450670(@"ManipulatorWireframe_vert", @"ManipulatorWireframe_frag");
  }
  long long v27 = 0uLL;
  if (a3)
  {
    long long v27 = *a3;
    if (!a4) {
      goto LABEL_11;
    }
  }
  else
  {
    sub_1B63C8F2C((float *)&v27, 1.0, 1.0, 1.0, 1.0);
    if (!a4) {
      goto LABEL_11;
    }
  }
  uint64_t v9 = (long long *)sub_1B6447988(v8, 1);
  uint64_t v10 = (float32x4_t *)sub_1B6447988(v8, 0);
  uint64_t v11 = 0;
  float32x4_t v12 = *v10;
  float32x4_t v13 = v10[1];
  float32x4_t v14 = v10[2];
  float32x4_t v15 = v10[3];
  long long v16 = v9[1];
  long long v17 = v9[2];
  long long v18 = v9[3];
  long long v28 = *v9;
  long long v29 = v16;
  long long v30 = v17;
  long long v31 = v18;
  float32x4_t v32 = 0u;
  float32x4_t v33 = 0u;
  float32x4_t v34 = 0u;
  float32x4_t v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v11) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(*(long long *)((char *)&v28 + v11))), v13, *(float32x2_t *)((char *)&v28 + v11), 1), v14, *(float32x4_t *)((char *)&v28 + v11), 2), v15, *(float32x4_t *)((char *)&v28 + v11), 3);
    v11 += 16;
  }
  while (v11 != 64);
  uint64_t v19 = 0;
  float32x4_t v20 = v32;
  float32x4_t v21 = v33;
  float32x4_t v22 = v34;
  float32x4_t v23 = v35;
  long long v24 = a4[1];
  long long v25 = a4[2];
  long long v26 = a4[3];
  long long v28 = *a4;
  long long v29 = v24;
  long long v30 = v25;
  long long v31 = v26;
  float32x4_t v32 = 0u;
  float32x4_t v33 = 0u;
  float32x4_t v34 = 0u;
  float32x4_t v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v19) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v20, COERCE_FLOAT(*(long long *)((char *)&v28 + v19))), v21, *(float32x2_t *)((char *)&v28 + v19), 1), v22, *(float32x4_t *)((char *)&v28 + v19), 2), v23, *(float32x4_t *)((char *)&v28 + v19), 3);
    v19 += 16;
  }
  while (v19 != 64);
LABEL_11:
  sub_1B644FD80(a1[8233], a2);
}

uint64_t sub_1B6428D18(uint64_t a1)
{
  unint64_t v2 = [VFXAuthoringEnvironment alloc];

  return MEMORY[0x1F4181798](v2, sel__initWithEngineContext_, a1, v3);
}

void sub_1B6429158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v10 = a5;
  uint64_t v11 = (__int16 *)a4;
  unsigned int v12 = a3;
  if ((*(_DWORD *)(a6 + 12) + a3) <= *(_DWORD *)(a6 + 20)
    && (*(_DWORD *)(a6 + 8) + a5) <= *(_DWORD *)(a6 + 24))
  {
LABEL_6:
    if (!*(void *)(a6 + 56))
    {
      if (*(unsigned char *)(a6 + 53))
      {
        float32x4_t v15 = (void *)sub_1B6445900(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
        if (objc_msgSend_count(*(void **)(a6 + 128), v16, v17, v18))
        {
          float32x4_t v22 = (const void *)objc_msgSend_anyObject(*(void **)(a6 + 128), v19, v20, v21);
          objc_msgSend_addObject_(*(void **)(a6 + 120), v23, (uint64_t)v22, v24);
          objc_msgSend_removeObject_(*(void **)(a6 + 128), v25, (uint64_t)v22, v26);
        }
        else
        {
          float32x4_t v22 = (const void *)sub_1B64AB284();
          objc_msgSend_addObject_(*(void **)(a6 + 120), v34, (uint64_t)v22, v35);
          CFRelease(v22);
          BOOL v43 = a1 + 72 == a6 || a1 + 224 == a6 || a1 + 1136 == a6;
          BOOL v44 = 1;
          BOOL v141 = v15;
          if (a1 + 376 != a6 && a1 + 528 != a6 && a1 + 832 != a6) {
            BOOL v44 = a1 + 680 == a6 || a1 + 984 == a6;
          }
          BOOL v46 = v43;
          if (v43) {
            uint64_t v47 = 2;
          }
          else {
            uint64_t v47 = 3;
          }
          __int32 v48 = (const void *)sub_1B647BB2C(0, v47, 1, v36, v37, v38, v39, v40);
          sub_1B64AC000((uint64_t)v22, v48, 0, 0, v49, v50, v51, v52);
          if (v48) {
            CFRelease(v48);
          }
          BOOL v53 = v46;
          if (v44 || v46 || a1 + 1288 == a6)
          {
            int v54 = (const void *)sub_1B647BB2C(2, 4, 20, v29, v30, v31, v32, v33);
            sub_1B64AC000((uint64_t)v22, v54, 0, 0, v55, v56, v57, v58);
            if (v54) {
              CFRelease(v54);
            }
          }
          float32x4_t v15 = v141;
          if (v53)
          {
            __int32 v59 = (const void *)sub_1B647BB2C(3, 2, 1, v29, v30, v31, v32, v33);
            sub_1B64AC000((uint64_t)v22, v59, 0, 0, v60, v61, v62, v63);
            if (v59) {
              CFRelease(v59);
            }
          }
          *(void *)(a6 + 20) = 0x200000002000;
        }
        if (*(unsigned char *)(a6 + 48) == 1)
        {
          uint64_t VolatileMeshElementOfType_primitiveCount_bytesPerIndex = objc_msgSend_createVolatileMeshElementOfType_primitiveCount_bytesPerIndex_(v15, v27, 2, 4096, 2);
        }
        else if (*(unsigned char *)(a6 + 48))
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Only GL_LINES and kCFXManipulatorDrawModeTriangles are supported", v28, v29, v30, v31, v32, v33, (uint64_t)"0");
          uint64_t VolatileMeshElementOfType_primitiveCount_bytesPerIndex = objc_msgSend_createVolatileMeshElementOfType_primitiveCount_bytesPerIndex_(v15, v72, 0, 0x2000, 2);
        }
        else
        {
          uint64_t VolatileMeshElementOfType_primitiveCount_bytesPerIndex = objc_msgSend_createVolatileMeshElementOfType_primitiveCount_bytesPerIndex_(v15, v27, 0, 2730, 2);
        }
        *(void *)(a6 + 56) = v22;
        *(void *)(a6 + 64) = VolatileMeshElementOfType_primitiveCount_bytesPerIndex;
        if (v15) {
          objc_msgSend_mapVolatileMesh_verticesCount_(v15, v65, (uint64_t)v22, 0x2000);
        }
        if (*(_DWORD *)(a6 + 12)) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. basevertex should be 0 here.", v66, v67, v68, v69, v70, v71, (uint64_t)"glInfo->baseVertex == 0");
        }
        int v73 = sub_1B64AC5F8(*(void *)(a6 + 56), 0, 0, 1, v68, v69, v70, v71);
        float32x4_t v81 = (void *)sub_1B641E1A8((uint64_t)v73, v74, v75, v76, v77, v78, v79, v80);
        *(void *)(a6 + 72) = sub_1B65349B8((uint64_t)v81);
        *(void *)(a6 + 96) = sub_1B65348F4(v81, 0, v82, v83, v84, v85, v86, v87);
        uint64_t v92 = (uint64_t)sub_1B64AC5F8(*(void *)(a6 + 56), 3, 0, 1, v88, v89, v90, v91);
        if (v92)
        {
          uint64_t v100 = (void *)sub_1B641E1A8(v92, v93, v94, v95, v96, v97, v98, v99);
          *(void *)(a6 + 88) = sub_1B65349B8((uint64_t)v100);
          uint64_t v92 = sub_1B65348F4(v100, 0, v101, v102, v103, v104, v105, v106);
        }
        else
        {
          *(void *)(a6 + 88) = 0;
        }
        *(void *)(a6 + 112) = v92;
        uint64_t v107 = (uint64_t)sub_1B64AC5F8(*(void *)(a6 + 56), 2, 0, 1, v96, v97, v98, v99);
        if (v107)
        {
          uint64_t v108 = (void *)sub_1B641E1A8(v107, a2, a3, a4, a5, a6, a7, a8);
          *(void *)(a6 + 80) = sub_1B65349B8((uint64_t)v108);
          uint64_t v107 = sub_1B65348F4(v108, 0, v109, v110, v111, v112, v113, v114);
        }
        else
        {
          *(void *)(a6 + 80) = 0;
        }
        *(void *)(a6 + 104) = v107;
        if (*(_DWORD *)(a6 + 8)) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Base index should be reset at this point\n", a3, a4, a5, a6, a7, a8, (uint64_t)"glInfo->baseIndex == 0");
        }
      }
      if (!*(void *)(a6 + 56)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. A mesh should have been allocated by now", a3, a4, a5, a6, a7, a8, (uint64_t)"glInfo->mesh != NULL");
      }
    }
    uint64_t v115 = *(void *)(a6 + 72);
    uint64_t v116 = *(void *)(a6 + 96);
    uint64_t v118 = *(unsigned int *)(a6 + 12);
    int v117 = *(_DWORD *)(a6 + 16);
    uint64_t v119 = v115 * v118;
    if (v117 == 12)
    {
      if (v12)
      {
        uint64_t v128 = v12;
        __n128 v129 = (int *)(a2 + 8);
        __n128 v130 = (_DWORD *)(v119 + v116 + 8);
        do
        {
          *(v130 - 2) = *(v129 - 2);
          *(v130 - 1) = *(v129 - 1);
          int v131 = *v129;
          v129 += 3;
          *__n128 v130 = v131;
          __n128 v130 = (_DWORD *)((char *)v130 + v115);
          --v128;
        }
        while (v128);
      }
    }
    else
    {
      uint64_t v120 = *(void *)(a6 + 80);
      uint64_t v121 = (_DWORD *)(*(void *)(a6 + 104) + v120 * v118);
      if (v117 == 16)
      {
        if (v12)
        {
          uint64_t v132 = v12;
          uint64_t v133 = (_DWORD *)(a2 + 8);
          uint64_t v134 = (_DWORD *)(v119 + v116 + 8);
          do
          {
            *(v134 - 2) = *(v133 - 2);
            *(v134 - 1) = *(v133 - 1);
            *uint64_t v134 = *v133;
            *uint64_t v121 = v133[1];
            v133 += 4;
            uint64_t v134 = (_DWORD *)((char *)v134 + v115);
            uint64_t v121 = (_DWORD *)((char *)v121 + v120);
            --v132;
          }
          while (v132);
        }
      }
      else if (v117 == 20 && v12)
      {
        uint64_t v122 = *(void *)(a6 + 88);
        uint64_t v123 = v122 * v118;
        uint64_t v124 = v12;
        uint64_t v125 = (_DWORD *)(v119 + v116 + 4);
        v126 = (_DWORD *)(a2 + 8);
        __n128 v127 = (_DWORD *)(v123 + *(void *)(a6 + 112) + 4);
        do
        {
          *(v125 - 1) = *(v126 - 2);
          *uint64_t v125 = *(v126 - 1);
          *uint64_t v121 = v126[2];
          *(v127 - 1) = *v126;
          uint64_t v125 = (_DWORD *)((char *)v125 + v115);
          *__n128 v127 = v126[1];
          uint64_t v121 = (_DWORD *)((char *)v121 + v120);
          v126 += 5;
          __n128 v127 = (_DWORD *)((char *)v127 + v122);
          --v124;
        }
        while (v124);
      }
    }
    uint64_t v135 = sub_1B63D1B54(*(void *)(a6 + 64), a2, a3, a4, a5, a6, a7, a8);
    uint64_t v136 = *(unsigned int *)(a6 + 8);
    if (v135)
    {
      int v137 = *(_DWORD *)(a6 + 12);
      if (v10)
      {
        int v138 = (_WORD *)(v135 + 2 * v136);
        uint64_t v139 = v10;
        do
        {
          __int16 v140 = *v11++;
          *v138++ = v140 + v137;
          --v139;
        }
        while (v139);
      }
    }
    else
    {
      int v137 = *(_DWORD *)(a6 + 12);
    }
    *(_DWORD *)(a6 + 8) = v136 + v10;
    *(_DWORD *)(a6 + 12) = v137 + v12;
    return;
  }
  if (a7)
  {
    if (*(_DWORD *)(a6 + 8)) {
      sub_1B64296C4(a1, a6, a3, a4, a5, a6, a7, a8);
    }
    goto LABEL_6;
  }

  sub_1B63F2F54(16, @"Error: Cannot append manipulator vertex data because we encountered an overflow and we are not allowed to flush", a3, a4, a5, a6, a7, a8, a9);
}

void sub_1B64296C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = (void *)sub_1B6445900(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v18 = v10;
    uint64_t v19 = *(void *)(a2 + 56);
    if (v19) {
      objc_msgSend_unmapVolatileMesh_modifiedVerticesCount_(v10, v11, v19, *(unsigned int *)(a2 + 12));
    }
    uint64_t v12 = *(void *)(a2 + 64);
    if (v12) {
      objc_msgSend_unmapVolatileMeshElement_(v18, v11, v12, v13);
    }
  }
  if (!*(void *)(a2 + 56)) {
    goto LABEL_29;
  }
  if (*(unsigned char *)(a2 + 53))
  {
    if (!*(_DWORD *)(a2 + 12)) {
      goto LABEL_29;
    }
    if (*(unsigned char *)(a2 + 48) == 1)
    {
      unsigned int v20 = *(_DWORD *)(a2 + 8) >> 1;
      goto LABEL_13;
    }
    if (!*(unsigned char *)(a2 + 48))
    {
      unsigned int v20 = *(_DWORD *)(a2 + 8) / 3u;
LABEL_13:
      sub_1B63D0F70(*(void *)(a2 + 64), 0, v20);
    }
  }
  uint64_t v21 = *(__n128 **)(a1 + 8);
  float32x4_t v22 = (void *)sub_1B6445900((uint64_t)v21, (uint64_t)v11, v12, v13, v14, v15, v16, v17);
  float v23 = sub_1B6447C0C((uint64_t)v21);
  if (*(unsigned char *)(a2 + 49))
  {
    float v24 = v23;
    __n128 v25 = sub_1B64479C4(v21);
    unint64_t v26 = vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, v24 * (float)(2.0 / v25.n128_f32[2])).u64[0];
    unint64_t v27 = vmulq_n_f32((float32x4_t)xmmword_1B6E4F320, v24 * (float)(2.0 / v25.n128_f32[3])).u64[0];
    *(double *)&unint64_t v28 = -0.00781250557;
    double v29 = 0.0;
    if (!v22) {
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v30 = (long long *)sub_1B6447988((uint64_t)v21, 1);
    long long v50 = v30[1];
    long long v52 = *v30;
    long long v46 = v30[3];
    long long v48 = v30[2];
    uint64_t v31 = (float32x4_t *)sub_1B6447988((uint64_t)v21, 0);
    uint64_t v32 = 0;
    float32x4_t v33 = *v31;
    float32x4_t v34 = v31[1];
    float32x4_t v35 = v31[2];
    float32x4_t v36 = v31[3];
    v54[0] = v52;
    v54[1] = v50;
    v54[2] = v48;
    v54[3] = v46;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    do
    {
      *(long long *)((char *)&v55 + v32 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, COERCE_FLOAT(v54[v32])), v34, *(float32x2_t *)&v54[v32], 1), v35, (float32x4_t)v54[v32], 2), v36, (float32x4_t)v54[v32], 3);
      ++v32;
    }
    while (v32 != 4);
    unint64_t v26 = *(unint64_t *)&v55;
    unint64_t v27 = *(unint64_t *)&v56;
    double v29 = *(double *)&v57;
    unint64_t v28 = *(unint64_t *)&v58;
    if (!v22) {
      goto LABEL_29;
    }
  }
  uint64_t v37 = *(void *)a2;
  if (*(void *)a2)
  {
    uint64_t v38 = 1568;
    if (!*(unsigned char *)(a2 + 52)) {
      uint64_t v38 = 1584;
    }
    uint64_t v39 = 1576;
    if (!*(unsigned char *)(a2 + 52)) {
      uint64_t v39 = 1592;
    }
    if (*(unsigned char *)(a2 + 51)) {
      uint64_t v40 = v38;
    }
    else {
      uint64_t v40 = v39;
    }
    uint64_t v41 = *(void *)(a1 + v40);
    uint64_t v42 = *(void *)(a2 + 56);
    uint64_t v43 = *(void *)(a2 + 64);
    double v47 = *(double *)&v26;
    double v49 = *(double *)&v27;
    double v51 = v29;
    double v53 = *(double *)&v28;
    uint64_t v44 = sub_1B64E35DC();
    objc_msgSend_renderMesh_meshElement_withProgram_engineContext_transform_color_rasterizerStates_blendState_texture_depthBias_(v22, v45, v42, v43, v37, v21, 0, v41, v47, v49, v51, v53, v44, *(void *)(a2 + 32), 0);
  }
LABEL_29:
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
}

uint64_t sub_1B642993C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a1 + 65816;
  if (*(unsigned char *)(a1 + 65816) || sub_1B642F984((void *)a1) || *(unsigned char *)(v10 + 32))
  {
    uint64_t v11 = (const void *)sub_1B644558C(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v11, 0, 1u);
  }

  return MEMORY[0x1F4181798](a1, sel_worldDidChange_, a2, a4);
}

uint64_t sub_1B64299CC(_DWORD *a1)
{
  objc_sync_enter(a1);
  a1[16468] = 0;
  objc_msgSend_update(a1, v2, v3, v4);

  return objc_sync_exit(a1);
}

void sub_1B6429A18(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_1B6429A2C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (uint64_t)(a1 + 9);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 9), a3, a4, a5, a6, a7, a8);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 28), v10, v11, v12, v13, v14, v15);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 47), v16, v17, v18, v19, v20, v21);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 66), v22, v23, v24, v25, v26, v27);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 85), v28, v29, v30, v31, v32, v33);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 104), v34, v35, v36, v37, v38, v39);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 123), v40, v41, v42, v43, v44, v45);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 142), v46, v47, v48, v49, v50, v51);
  sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 161), v52, v53, v54, v55, v56, v57);
  sub_1B6429B70(a1, v9);
  sub_1B6429B70(a1, (uint64_t)(a1 + 28));
  sub_1B6429B70(a1, (uint64_t)(a1 + 47));
  sub_1B6429B70(a1, (uint64_t)(a1 + 66));
  sub_1B6429B70(a1, (uint64_t)(a1 + 85));
  sub_1B6429B70(a1, (uint64_t)(a1 + 104));
  sub_1B6429B70(a1, (uint64_t)(a1 + 123));
  sub_1B6429B70(a1, (uint64_t)(a1 + 142));

  return sub_1B6429B70(a1, (uint64_t)(a1 + 161));
}

void *sub_1B6429B70(void *result, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 53))
  {
    uint64_t v3 = result[1];
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v4 = *(void **)(a2 + 120);
    uint64_t v5 = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, (const char *)a2, (uint64_t)&v38, (uint64_t)v43, 16);
    if (v5)
    {
      uint64_t v8 = v5;
      uint64_t v9 = *(void *)v39;
      do
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          if (*(void *)v39 != v9) {
            objc_enumerationMutation(v4);
          }
          objc_msgSend_addObject_(*(void **)(a2 + 128), v6, *(void *)(*((void *)&v38 + 1) + 8 * i), v7);
        }
        uint64_t v8 = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v6, (uint64_t)&v38, (uint64_t)v43, 16);
      }
      while (v8);
    }
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    uint64_t v11 = *(void **)(a2 + 136);
    uint64_t v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(v11, v6, (uint64_t)&v34, (uint64_t)v42, 16);
    if (v12)
    {
      uint64_t v16 = v12;
      uint64_t v17 = *(void *)v35;
      do
      {
        for (uint64_t j = 0; j != v16; ++j)
        {
          if (*(void *)v35 != v17) {
            objc_enumerationMutation(v11);
          }
          objc_msgSend_addObject_(*(void **)(a2 + 144), v13, *(void *)(*((void *)&v34 + 1) + 8 * j), v15);
        }
        uint64_t v16 = objc_msgSend_countByEnumeratingWithState_objects_count_(v11, v13, (uint64_t)&v34, (uint64_t)v42, 16);
      }
      while (v16);
    }
    objc_msgSend_removeAllObjects(*(void **)(a2 + 120), v13, v14, v15);
    objc_msgSend_removeAllObjects(*(void **)(a2 + 136), v19, v20, v21);
    __n128 result = (void *)sub_1B6445900(v3, v22, v23, v24, v25, v26, v27, v28);
    if (result)
    {
      uint64_t v31 = result;
      uint64_t v32 = *(void *)(a2 + 56);
      if (v32) {
        __n128 result = objc_msgSend_unmapVolatileMesh_modifiedVerticesCount_(result, v29, v32, *(unsigned int *)(a2 + 12));
      }
      uint64_t v33 = *(void *)(a2 + 64);
      if (v33) {
        __n128 result = objc_msgSend_unmapVolatileMeshElement_(v31, v29, v33, v30);
      }
    }
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
  }
  return result;
}

void sub_1B6429D40(uint64_t *a1)
{
  if ((sub_1B6446228(a1[1]) & 0x8000) != 0)
  {
    sub_1B6429E7C(a1, (uint64_t)(a1 + 47), v2, v3, v4, v5, v6, v7);
    int v11 = 0;
LABEL_6:
    uint64_t v12 = (float *)&xmmword_1B6E50680;
    for (float32x4_t i = (float32x4_t)xmmword_1B6E4F300; ; float32x4_t i = v20)
    {
      while (1)
      {
        float32x4_t v20 = i;
        sub_1B642A10C((uint64_t)a1, 0, v12, v12, (uint64_t)(a1 + 47), (float32x4_t)0, i, v8, v9, v10);
        if (!++v11) {
          goto LABEL_6;
        }
        if (v11 != 1) {
          break;
        }
        uint64_t v12 = (float *)&unk_1B6E50690;
        float32x4_t i = (float32x4_t)xmmword_1B6E4F320;
      }
      if (v11 == 2) {
        break;
      }
      uint64_t v12 = 0;
    }
    sub_1B642A10C((uint64_t)a1, 0, flt_1B6E506A0, flt_1B6E506A0, (uint64_t)(a1 + 47), (float32x4_t)0, (float32x4_t)xmmword_1B6E4F340, v8, v9, v10);
    sub_1B64296C4((uint64_t)a1, (uint64_t)(a1 + 85), v14, v15, v16, v17, v18, v19);
  }
}

void sub_1B6429E7C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)a2)
  {
    BOOL v10 = a1 + 9 == (uint64_t *)a2 || a1 + 28 == (uint64_t *)a2;
    int v11 = a1 + 47;
    int v13 = v10 || a1 + 142 == (uint64_t *)a2;
    uint64_t v14 = a1 + 66;
    uint64_t v15 = a1 + 104;
    uint64_t v16 = a1 + 123;
    uint64_t v17 = a1 + 85;
    BOOL v22 = v11 == (uint64_t *)a2
       || v14 == (uint64_t *)a2
       || v15 == (uint64_t *)a2
       || v17 == (uint64_t *)a2
       || v16 == (uint64_t *)a2;
    if (!*(void *)(a2 + 120)) {
      *(void *)(a2 + 120) = (id)objc_msgSend_set(MEMORY[0x1E4F1CA80], (const char *)a2, a3, a4);
    }
    if (!*(void *)(a2 + 128)) {
      *(void *)(a2 + 128) = (id)objc_msgSend_set(MEMORY[0x1E4F1CA80], (const char *)a2, a3, a4);
    }
    if (!*(void *)(a2 + 136)) {
      *(void *)(a2 + 136) = (id)objc_msgSend_set(MEMORY[0x1E4F1CA80], (const char *)a2, a3, a4);
    }
    if (!*(void *)(a2 + 144)) {
      *(void *)(a2 + 144) = (id)objc_msgSend_set(MEMORY[0x1E4F1CA80], (const char *)a2, a3, a4);
    }
    uint64_t v23 = a1 + 161;
    if (!sub_1B6445900(a1[1], a2, a3, a4, a5, a6, a7, a8))
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. There should be at lease a valid CFXRendererContext or a valid VFXRenderer", v24, v25, v26, v27, v28, v29, (uint64_t)"0");
      goto LABEL_50;
    }
    if (v13)
    {
      uint64_t v30 = (void *)a1[6];
      if (!v30)
      {
        uint64_t v30 = sub_1B6450670(@"ManipulatorColorAndTexture_vert", @"ManipulatorColorAndTexture_frag");
        a1[6] = (uint64_t)v30;
      }
      int v31 = 20;
    }
    else if (v22)
    {
      uint64_t v30 = (void *)a1[5];
      if (!v30)
      {
        uint64_t v30 = sub_1B6450670(@"ManipulatorColorOnly_vert", @"ManipulatorColorOnly_frag");
        a1[5] = (uint64_t)v30;
      }
      int v31 = 16;
    }
    else
    {
      if (v23 != (uint64_t *)a2)
      {
        sub_1B63F2F54(16, @"Unreachable code: Unknown use of manipulators", v24, v25, v26, v27, v28, v29, v33);
        goto LABEL_50;
      }
      uint64_t v30 = (void *)a1[7];
      if (!v30)
      {
        uint64_t v30 = sub_1B6450670(@"ManipulatorLightProbe_vert", @"ManipulatorLightProbe_frag");
        a1[7] = (uint64_t)v30;
      }
      int v31 = 12;
    }
    *(_DWORD *)(a2 + 16) = v31;
    *(void *)a2 = v30;
LABEL_50:
    if (v11 == (uint64_t *)a2)
    {
      *(_WORD *)(a2 + 48) = 1;
    }
    else
    {
      if (v14 == (uint64_t *)a2)
      {
        *(_WORD *)(a2 + 48) = 1;
        *(_WORD *)(a2 + 51) = 0;
        goto LABEL_60;
      }
      if (v15 == (uint64_t *)a2)
      {
        int v32 = 257;
        goto LABEL_62;
      }
      if (v16 == (uint64_t *)a2)
      {
LABEL_56:
        int v32 = 256;
LABEL_62:
        *(_DWORD *)(a2 + 48) = v32;
        *(_WORD *)(a2 + 52) = 256;
        goto LABEL_63;
      }
      if (v17 != (uint64_t *)a2)
      {
        if (v13) {
          goto LABEL_56;
        }
        if (v23 != (uint64_t *)a2)
        {
          sub_1B63F2F54(16, @"Unreachable code: Unknown use of manipulators", v24, v25, v26, v27, v28, v29, v33);
LABEL_63:
          if (!*(void *)a2) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. No program for the auth env!", v24, v25, v26, v27, v28, v29, (uint64_t)"glInfo->weakProgram != nil");
          }
          return;
        }
      }
      *(_WORD *)(a2 + 48) = 0;
    }
    *(_WORD *)(a2 + 51) = 1;
LABEL_60:
    *(unsigned char *)(a2 + 53) = 1;
    goto LABEL_63;
  }
}

void sub_1B642A10C(uint64_t a1, float32x4_t *a2, float *a3, float *a4, uint64_t a5, float32x4_t a6, float32x4_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    float32x4_t v10 = a2[1];
    float32x4_t v11 = a2[2];
    a7 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a2[3], v11, a7, 2), v10, *(float32x2_t *)a7.f32, 1), *a2, a7.f32[0]);
    a6 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a2[3], v11, a6, 2), v10, *(float32x2_t *)a6.f32, 1), *a2, a6.f32[0]);
  }
  unint64_t v21 = a6.i64[0];
  unsigned __int32 v22 = a6.u32[2];
  int v12 = (int)(float)(a3[3] * 255.0);
  int v13 = (int)(float)(fminf(fmaxf(a3[2], 0.0), 1.0) * 255.0);
  int v14 = (int)(float)(fminf(fmaxf(a3[1], 0.0), 1.0) * 255.0);
  int v15 = (int)(float)(fminf(fmaxf(*a3, 0.0), 1.0) * 255.0);
  int v16 = (int)(float)(a4[3] * 255.0);
  int v17 = (int)(float)(fminf(fmaxf(a4[2], 0.0), 1.0) * 255.0);
  float v18 = *a4;
  float v19 = fminf(fmaxf(a4[1], 0.0), 1.0) * 255.0;
  unsigned __int32 v25 = a7.u32[2];
  unint64_t v24 = a7.i64[0];
  int v23 = (v12 << 24) | (v13 << 16) | (v14 << 8) | v15;
  int v26 = (v16 << 24) | (v17 << 16) | ((int)v19 << 8) | (int)(float)(fminf(fmaxf(v18, 0.0), 1.0) * 255.0);
  HIDWORD(v20) = 0x10000;
  sub_1B6429158(a1, (uint64_t)&v21, 2, (uint64_t)&v20 + 4, 2, a5, 1, a10, v20);
}

void sub_1B642A27C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 65848))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      if ((sub_1B6446228(v2) & 0x20000) != 0)
      {
        if (*(unsigned char *)(a1 + 24))
        {
          uint64_t v6 = *(void **)(a1 + 16);
          uint64_t v7 = objc_msgSend_defaultCameraController(v6, v3, v4, v5);
          if (objc_msgSend_isTargetFromHitTest(v7, v8, v9, v10))
          {
            int v14 = objc_msgSend_defaultCameraController(v6, v11, v12, v13);
            if ((unint64_t)(objc_msgSend_interactionMode(v14, v15, v16, v17) - 1) <= 3)
            {
              unint64_t v21 = objc_msgSend_defaultCameraController(v6, v18, v19, v20);
              objc_msgSend_simdTarget(v21, v22, v23, v24);
              float32x4_t v77 = v25;
              int v26 = (_OWORD *)sub_1B6447988(*(void *)(a1 + 8), 1);
              uint64_t v27 = (float32x4_t *)sub_1B6447988(*(void *)(a1 + 8), 0);
              uint64_t v35 = 0;
              float32x4_t v36 = *v27;
              float32x4_t v37 = v27[1];
              float32x4_t v38 = v27[2];
              float32x4_t v39 = v27[3];
              long long v40 = v26[1];
              long long v41 = v26[2];
              long long v42 = v26[3];
              v80[0] = *v26;
              v80[1] = v40;
              v80[2] = v41;
              v80[3] = v42;
              float32x4_t v81 = 0u;
              float32x4_t v82 = 0u;
              float32x4_t v83 = 0u;
              float32x4_t v84 = 0u;
              do
              {
                *(float32x4_t *)((char *)&v81 + v35 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v36, COERCE_FLOAT(v80[v35])), v37, *(float32x2_t *)&v80[v35], 1), v38, (float32x4_t)v80[v35], 2), v39, (float32x4_t)v80[v35], 3);
                ++v35;
              }
              while (v35 != 4);
              float32x4_t v43 = vaddq_f32(v84, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v81, v77.f32[0]), v82, *(float32x2_t *)v77.f32, 1), v83, v77, 2));
              if (v43.f32[3] > 0.001)
              {
                int32x4_t v76 = (int32x4_t)v43;
                sub_1B6445900(*(void *)(a1 + 8), v28, v29, v30, v31, v32, v33, v34);
                *(float *)v44.i32 = sub_1B6447C0C(*(void *)(a1 + 8));
                int32x2_t v78 = v44;
                __n128 v45 = sub_1B64479C4((__n128 *)*(void *)(a1 + 8));
                __asm
                {
                  FMOV            V2.2D, #1.0
                  FMOV            V1.2D, #0.5
                }
                v45.n128_u64[0] = (unint64_t)vdiv_f32(vrndm_f32(vcvt_f32_f64(vmulq_f64(vmulq_f64(vaddq_f64(vcvtq_f64_f32(vdiv_f32(*(float32x2_t *)v76.i8, (float32x2_t)vdup_laneq_s32(v76, 3))), _Q2), vcvt_hight_f64_f32((float32x4_t)v45)), _Q1))), (float32x2_t)vdup_lane_s32(v78, 0));
                float v52 = v45.n128_f32[0] + -5.0;
                float v53 = v45.n128_f32[0] + 5.0;
                v45.n128_u64[1] = v45.n128_u64[0];
                float32x4_t v79 = vaddq_f32((float32x4_t)v45, (float32x4_t)xmmword_1B6E504D0);
                float v54 = v45.n128_f32[1] + -1.0;
                float v55 = v45.n128_f32[1] + 1.0;
                sub_1B6429E7C((uint64_t *)a1, a1 + 984, v56, v57, v58, v59, v60, v61);
                sub_1B642A58C(a1, 0x3F8000003F800000, 0x3F8000003F800000, 0, a1 + 984, 1, v62, v63, v79.f32[0], v79.f32[1], v79.f32[2], v79.f32[3]);
                sub_1B642A58C(a1, 0x3F8000003F800000, 0x3F8000003F800000, 0, a1 + 984, 1, v64, v65, v52, v54, v53, v55);
                sub_1B642A58C(a1, 0, 0x3F80000000000000, 0, a1 + 984, 1, v66, v67, v79.f32[0] + 0.5, v79.f32[1] + 0.5, v79.f32[2] + -0.5, v79.f32[3] + -0.5);
                sub_1B642A58C(a1, 0, 0x3F80000000000000, 0, a1 + 984, 1, v68, v69, v52 + 0.5, v54 + 0.5, v53 + -0.5, v55 + -0.5);
                sub_1B64296C4(a1, a1 + 984, v70, v71, v72, v73, v74, v75);
              }
            }
          }
        }
      }
    }
  }
}

void sub_1B642A58C(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9, float a10, float a11, float a12)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = *(void *)(a5 + 32);
  if (a4)
  {
    if (!v21) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. __appendRect2D: uv but not texture", a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"glInfo->textureImage != nil");
    }
    float v26 = a9;
    float v27 = a10;
    float v23 = a4[1];
    float v28 = *a4;
    *(float *)&int v29 = v23;
    int v30 = ((int)(float)(*((float *)&a3 + 1) * 255.0) << 24) | ((int)(float)(fminf(fmaxf(*(float *)&a3, 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(*((float *)&a2 + 1), 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*(float *)&a2, 0.0), 1.0) * 255.0);
    float v31 = a11;
    float v32 = a10;
    float v24 = a4[3];
    float v33 = a4[2];
    float v34 = v23;
    float v35 = *(float *)&v30;
    float v36 = a11;
    float v37 = a12;
    float v38 = v33;
    float v39 = v24;
    int v40 = v30;
    float v41 = a9;
    float v42 = a12;
    float v43 = v28;
    float v44 = v24;
    int v45 = v30;
  }
  else
  {
    if (v21) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. __appendRect2D: no uv but texture", a3, 0, a5, a6, a7, a8, (uint64_t)"glInfo->textureImage == nil");
    }
    float v26 = a9;
    float v27 = a10;
    float v28 = 0.0;
    int v29 = ((int)(float)(*((float *)&a3 + 1) * 255.0) << 24) | ((int)(float)(fminf(fmaxf(*(float *)&a3, 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(*((float *)&a2 + 1), 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*(float *)&a2, 0.0), 1.0) * 255.0);
    *(float *)&int v30 = a11;
    float v31 = a10;
    float v32 = 0.0;
    float v33 = *(float *)&v29;
    float v34 = a11;
    float v35 = a12;
    float v36 = 0.0;
    float v37 = *(float *)&v29;
    float v38 = a9;
    float v39 = a12;
    int v40 = 0;
    float v41 = *(float *)&v29;
  }
  sub_1B6429158(a1, (uint64_t)&v26, 4, (uint64_t)&unk_1B6E50730, 6, a5, a6, a8, v25);
}

double sub_1B642A7B4(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(double *)(a1 + 1752) != 0.0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Can not nest two Timed record", a4, a5, a6, a7, a8, a9, (uint64_t)"authoringEnvironment->_timedRecordingExpirationTime == 0");
  }
  double result = sub_1B6447718(*(void *)(a1 + 8)) + a2;
  *(double *)(a1 + 1752) = result;
  return result;
}

uint64_t sub_1B642A824(uint64_t result)
{
  *(void *)(result + 1752) = 0;
  return result;
}

void sub_1B642A82C(uint64_t a1, int a2, void *__src, uint64_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)(a1 + 65760);
  int v9 = (__n + 31) & 0xFFFFFFF0;
  uint64_t v10 = *(unsigned int *)(a1 + 65764);
  unsigned int v11 = v10 + v9;
  if ((v10 + v9) >> 9 >= 0x7D)
  {
    if (v11 == 64000)
    {
      int v12 = 64000 - v10;
      uint64_t v13 = *(void *)(a1 + 1752);
      uint64_t v14 = a1 + v10;
      *(_DWORD *)(v14 + 1760) = -1;
      *(_DWORD *)(v14 + 1764) = v12;
      *(void *)(v14 + 1768) = v13;
    }
    LODWORD(v10) = 0;
    *(_DWORD *)(a1 + 65764) = 0;
    unsigned int v11 = (__n + 31) & 0xFFFFFFF0;
  }
  if (v10 < *v8 && v11 > *v8)
  {
    sub_1B63F2F54(0, @"Warning: ring buffer is full [%d/%d]", (uint64_t)__src, __n, a5, a6, a7, a8, *v8);
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 1752);
    uint64_t v17 = a1 + 1760 + v10;
    *(_DWORD *)uint64_t v17 = a2;
    *(_DWORD *)(v17 + 4) = v9;
    *(void *)(v17 + 8) = v16;
    memcpy((void *)(a1 + 1760 + *(unsigned int *)(a1 + 65764) + 16), __src, __n);
    v8[1] = v11;
  }
}

void sub_1B642A904(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int *a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  unsigned int v11 = a3;
  unsigned int v12 = a2;
  if (a2 == a3)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. start != end", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"start != end");
LABEL_4:
    unsigned int v13 = v11;
    goto LABEL_5;
  }
  if (a2 >> 4 > 0xF9E) {
    goto LABEL_4;
  }
  uint64_t v17 = a1 + 1760;
  unsigned int v13 = a3;
  unsigned int v18 = a2;
  do
  {
    uint64_t v19 = v17 + v18;
    int v20 = *(_DWORD *)(v19 + 4);
    if (!v20) {
      break;
    }
    if (*(double *)(v19 + 8) <= a9)
    {
      v18 += v20;
    }
    else
    {
      int v21 = *(_DWORD *)v19;
      if (*(_DWORD *)v19 == 3)
      {
        sub_1B642AC18(a1, (long long *)(v19 + 32), (long long *)(v19 + 96), (uint64_t)a4, (uint64_t)a5, a6, a7, a8, *(__n128 *)(v19 + 16));
      }
      else if (v21 == 1)
      {
        sub_1B642AB40(a1, 0, (float *)(v19 + 48), (uint64_t)a4, (uint64_t)a5, a6, a7, a8, *(float32x4_t *)(v19 + 16), *(float32x4_t *)(v19 + 32));
      }
      else if (!v21)
      {
        sub_1B642AA68(a1, 0, (float *)(v19 + 48), (uint64_t)a4, (uint64_t)a5, a6, a7, a8, *(float32x4_t *)(v19 + 16), *(float32x4_t *)(v19 + 32));
      }
      if (v13 >= v18) {
        unsigned int v13 = v18;
      }
      v18 += *(_DWORD *)(v19 + 4);
      if (v12 <= v18) {
        unsigned int v12 = v18;
      }
    }
  }
  while (v18 != v11 && v18 >> 4 < 0xF9F);
LABEL_5:
  *a4 = v13;
  if (v13 <= v12) {
    unsigned int v14 = v12;
  }
  else {
    unsigned int v14 = v13;
  }
  *a5 = v14;
}

void sub_1B642AA68(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10)
{
  if (*(double *)(a1 + 1752) > 0.0)
  {
    float32x4_t __src = a9;
    float32x4_t v25 = a10;
    long long v26 = *(_OWORD *)a3;
    if (a2)
    {
      float32x4_t v13 = *(float32x4_t *)(a2 + 16);
      float32x4_t v14 = *(float32x4_t *)(a2 + 32);
      float32x4_t v15 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a2 + 48), v14, a10, 2), v13, *(float32x2_t *)a10.f32, 1), *(float32x4_t *)a2, a10.f32[0]);
      float32x4_t __src = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a2 + 48), v14, a9, 2), v13, *(float32x2_t *)a9.f32, 1), *(float32x4_t *)a2, a9.f32[0]);
      float32x4_t v25 = v15;
    }
    sub_1B642A82C(a1, 0, &__src, 48, a5, a6, a7, a8);
  }
  sub_1B6429E7C((uint64_t *)a1, a1 + 376, (uint64_t)a3, a4, a5, a6, a7, a8);

  sub_1B642B56C(a1, a2, a3, a3, a1 + 376, a9, a10, v19, v20, v21, v16, v17, v18);
}

void sub_1B642AB40(uint64_t a1, float32x4_t *a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10)
{
  if (*(double *)(a1 + 1752) > 0.0)
  {
    float32x4_t __src = a9;
    float32x4_t v22 = a10;
    long long v23 = *(_OWORD *)a3;
    if (a2)
    {
      float32x4_t v13 = a2[1];
      float32x4_t v14 = a2[2];
      float32x4_t v15 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a2[3], v14, a10, 2), v13, *(float32x2_t *)a10.f32, 1), *a2, a10.f32[0]);
      float32x4_t __src = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a2[3], v14, a9, 2), v13, *(float32x2_t *)a9.f32, 1), *a2, a9.f32[0]);
      float32x4_t v22 = v15;
    }
    sub_1B642A82C(a1, 1, &__src, 48, a5, a6, a7, a8);
  }
  sub_1B6429E7C((uint64_t *)a1, a1 + 376, (uint64_t)a3, a4, a5, a6, a7, a8);

  sub_1B642A10C(a1, a2, a3, a3, a1 + 376, a9, a10, v16, v17, v18);
}

void sub_1B642AC18(uint64_t a1, long long *a2, long long *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (*(double *)(a1 + 1752) > 0.0)
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    __n128 __src = a9;
    if (a2)
    {
      long long v12 = a2[1];
      long long v15 = *a2;
      long long v16 = v12;
      long long v13 = a2[3];
      long long v17 = a2[2];
      long long v18 = v13;
    }
    else
    {
      long long v15 = xmmword_1B6E4F300;
      long long v16 = xmmword_1B6E4F320;
      long long v17 = xmmword_1B6E4F2E0;
      long long v18 = xmmword_1B6E4F370;
    }
    long long v19 = *a3;
    sub_1B642A82C(a1, 3, &__src, 96, a5, a6, a7, a8);
  }
  sub_1B6429E7C((uint64_t *)a1, a1 + 376, (uint64_t)a3, a4, a5, a6, a7, a8);

  sub_1B64300A8(a1, (float32x4_t *)a2, (uint64_t)a3, a1 + 376);
}

void sub_1B642AD04(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = (_DWORD *)(a1 + 65760);
  unsigned int v10 = *(_DWORD *)(a1 + 65760);
  uint64_t v11 = *(unsigned int *)(a1 + 65764);
  if (v10 != v11)
  {
    uint64_t v14 = 0;
    if (v10 < v11)
    {
      sub_1B642A904(a1, v10, v11, (unsigned int *)&v14 + 1, (unsigned int *)&v14, a7, a8, a9, a2);
      *int v9 = HIDWORD(v14);
LABEL_8:
      v9[1] = v14;
      return;
    }
    if (v10 >> 9 <= 0x7C)
    {
      sub_1B642A904(a1, v10, 64000, (unsigned int *)&v14 + 1, (unsigned int *)&v14, a7, a8, a9, a2);
      *int v9 = HIDWORD(v14);
      uint64_t v11 = v9[1];
    }
    if (v11)
    {
      sub_1B642A904(a1, 0, v11, (unsigned int *)&v14 + 1, (unsigned int *)&v14, a7, a8, a9, a2);
      goto LABEL_8;
    }
  }
}

void sub_1B642ADCC(uint64_t a1)
{
  uint64_t v189 = *MEMORY[0x1E4F143B8];
  sub_1B6429D40((uint64_t *)a1);
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    if (sub_1B6446228(v7))
    {
      uint64_t v10 = sub_1B644558C(*(void *)(a1 + 8), v8, v9, v2, v3, v4, v5, v6);
      if (v10)
      {
        long long v12 = objc_msgSend_worldWithWorldRef_(VFXWorld, v11, v10, v2);
        long long v16 = objc_msgSend_physicsWorld(v12, v13, v14, v15);
        if (v16)
        {
          long long v17 = v16;
          id v18 = v16;
          objc_msgSend__drawDebugInAuthoringEnvironment_(v17, v19, a1, v20);
        }
      }
    }
  }
  sub_1B644FD84(*(uint64_t ***)(a1 + 65864), *(void *)(a1 + 8), *(void *)(a1 + 64), v2, v3, v4, v5, v6);
  float v24 = objc_msgSend_manipulator((void *)a1, v21, v22, v23);
  if (objc_msgSend_isDragging(v24, v25, v26, v27))
  {
    objc_msgSend_lockSnapGuides(v24, v28, v29, v30);
    sub_1B6429E7C((uint64_t *)a1, a1 + 376, v31, v32, v33, v34, v35, v36);
    objc_msgSend_transform(v24, v37, v38, v39);
    __int32 v172 = v40.i32[1];
    float32x4_t v173 = v40;
    __int32 v175 = v40.i32[2];
    v180[0] = (float32x4_t)xmmword_1B6E4F300;
    v180[1] = (float32x4_t)xmmword_1B6E4F320;
    v180[2] = (float32x4_t)xmmword_1B6E4F2E0;
    v180[3] = (float32x4_t)xmmword_1B6E4F370;
    float v43 = objc_msgSend_snapGuideIndexesOnAxis_(v24, v41, 1, v42);
    uint64_t Index = objc_msgSend_firstIndex(v43, v44, v45, v46);
    if (Index != 0x7FFFFFFFFFFFFFFFLL)
    {
      for (uint64_t i = Index; i != 0x7FFFFFFFFFFFFFFFLL; uint64_t i = objc_msgSend_indexGreaterThanIndex_(v43, v76, i, v77))
      {
        uint64_t v51 = objc_msgSend_snapInfoAtIndex_axis_(v24, v48, i, 1, *(_OWORD *)&v165);
        float32x4_t v178 = 0u;
        float32x4_t v179 = 0u;
        uint64_t v59 = sub_1B64A01D4(*(void *)(v51 + 8), v52, v53, v54, v55, v56, v57, v58);
        long long v167 = *(_OWORD *)(v59 + 48);
        sub_1B649F7D4(*(void *)(v51 + 8), &v178);
        v60.f32[0] = *(float *)v51 - *(float *)(v51 + 16);
        float32x4_t v61 = v60;
        *(uint64_t *)((char *)v61.i64 + 4) = *(void *)((char *)&v167 + 4);
        v60.i32[1] = v172;
        float32x4_t v62 = v60;
        v62.i32[2] = DWORD2(v167);
        v60.i32[2] = v175;
        float32x4_t v165 = v62;
        float32x4_t v168 = v60;
        sub_1B642A10C(a1, v180, flt_1B6E506B0, flt_1B6E506B0, a1 + 376, v61, v62, v63, v64, v65);
        sub_1B642A10C(a1, v180, flt_1B6E506B0, flt_1B6E506B0, a1 + 376, v165, v168, v66, v67, v68);
        int8x16_t v69 = (int8x16_t)vaddq_f32(v179, v179);
        float32x4_t v70 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3);
        v70.i32[0] = v69.i32[0];
        float32x4_t v181 = vsubq_f32(v178, v179);
        float32x4_t v182 = vaddq_f32(v181, v70);
        float32x4_t v183 = vaddq_f32(v181, (float32x4_t)vextq_s8(v69, (int8x16_t)vuzp2q_s32((int32x4_t)v69, (int32x4_t)v69), 0xCuLL));
        float32x4_t v184 = vaddq_f32(v70, v183);
        int8x16_t v71 = (int8x16_t)vzip2q_s32((int32x4_t)v69, (int32x4_t)v69);
        float32x4_t v72 = (float32x4_t)vextq_s8(v71, v71, 8uLL);
        float32x4_t v185 = vaddq_f32(v181, v72);
        float32x4_t v186 = vaddq_f32(v72, v182);
        float32x4_t v187 = vaddq_f32(v72, v183);
        float32x4_t v188 = vaddq_f32(v72, v184);
        sub_1B642C720(a1, (uint64_t)&v181, (float32x4_t *)v59, flt_1B6E506B0, a1 + 376, v73, v74, v75);
      }
    }
    int32x2_t v78 = objc_msgSend_snapGuideIndexesOnAxis_(v24, v48, 2, v49, *(_OWORD *)&v165);
    uint64_t v82 = objc_msgSend_firstIndex(v78, v79, v80, v81);
    if (v82 != 0x7FFFFFFFFFFFFFFFLL)
    {
      for (uint64_t j = v82; j != 0x7FFFFFFFFFFFFFFFLL; uint64_t j = objc_msgSend_indexGreaterThanIndex_(v78, v111, j, v112))
      {
        uint64_t v86 = objc_msgSend_snapInfoAtIndex_axis_(v24, v83, j, 2, *(_OWORD *)&v166);
        float32x4_t v178 = 0u;
        float32x4_t v179 = 0u;
        uint64_t v94 = sub_1B64A01D4(*(void *)(v86 + 8), v87, v88, v89, v90, v91, v92, v93);
        float32x4_t v169 = *(float32x4_t *)(v94 + 48);
        sub_1B649F7D4(*(void *)(v86 + 8), &v178);
        float32x4_t v95 = v169;
        v95.f32[1] = *(float *)v86 - *(float *)(v86 + 16);
        v95.i32[2] = v169.i32[2];
        float32x4_t v96 = v173;
        v96.f32[1] = v95.f32[1];
        float32x4_t v97 = v96;
        v97.i32[2] = v169.i32[2];
        v96.i32[2] = v175;
        float32x4_t v166 = v97;
        float32x4_t v170 = v96;
        sub_1B642A10C(a1, v180, flt_1B6E506B0, flt_1B6E506B0, a1 + 376, v95, v97, v98, v99, v100);
        sub_1B642A10C(a1, v180, flt_1B6E506B0, flt_1B6E506B0, a1 + 376, v166, v170, v101, v102, v103);
        int8x16_t v104 = (int8x16_t)vaddq_f32(v179, v179);
        float32x4_t v105 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v104, 3);
        v105.i32[0] = v104.i32[0];
        float32x4_t v181 = vsubq_f32(v178, v179);
        float32x4_t v182 = vaddq_f32(v181, v105);
        float32x4_t v183 = vaddq_f32(v181, (float32x4_t)vextq_s8(v104, (int8x16_t)vuzp2q_s32((int32x4_t)v104, (int32x4_t)v104), 0xCuLL));
        float32x4_t v184 = vaddq_f32(v105, v183);
        int8x16_t v106 = (int8x16_t)vzip2q_s32((int32x4_t)v104, (int32x4_t)v104);
        float32x4_t v107 = (float32x4_t)vextq_s8(v106, v106, 8uLL);
        float32x4_t v185 = vaddq_f32(v181, v107);
        float32x4_t v186 = vaddq_f32(v107, v182);
        float32x4_t v187 = vaddq_f32(v107, v183);
        float32x4_t v188 = vaddq_f32(v107, v184);
        sub_1B642C720(a1, (uint64_t)&v181, (float32x4_t *)v94, flt_1B6E506B0, a1 + 376, v108, v109, v110);
      }
    }
    uint64_t v113 = objc_msgSend_snapGuideIndexesOnAxis_(v24, v83, 4, v84, *(_OWORD *)&v166);
    uint64_t v117 = objc_msgSend_firstIndex(v113, v114, v115, v116);
    if (v117 != 0x7FFFFFFFFFFFFFFFLL)
    {
      uint64_t v125 = v117;
      float32x4_t v126 = v173;
      v126.i32[1] = v172;
      float32x4_t v174 = v126;
      do
      {
        uint64_t v127 = objc_msgSend_snapInfoAtIndex_axis_(v24, v118, v125, 4);
        float32x4_t v178 = 0u;
        float32x4_t v179 = 0u;
        uint64_t v135 = sub_1B64A01D4(*(void *)(v127 + 8), v128, v129, v130, v131, v132, v133, v134);
        float32x4_t v176 = *(float32x4_t *)(v135 + 48);
        sub_1B649F7D4(*(void *)(v127 + 8), &v178);
        float32x4_t v136 = v176;
        float32x4_t v137 = v176;
        v137.f32[2] = *(float *)v127 - *(float *)(v127 + 16);
        v136.i32[1] = v172;
        v136.f32[2] = v137.f32[2];
        float32x4_t v177 = v136;
        float32x4_t v138 = v174;
        v138.f32[2] = v137.f32[2];
        float32x4_t v171 = v138;
        sub_1B642A10C(a1, v180, flt_1B6E506B0, flt_1B6E506B0, a1 + 376, v137, v136, v139, v140, v141);
        sub_1B642A10C(a1, v180, flt_1B6E506B0, flt_1B6E506B0, a1 + 376, v177, v171, v142, v143, v144);
        int8x16_t v145 = (int8x16_t)vaddq_f32(v179, v179);
        float32x4_t v146 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v145, 3);
        v146.i32[0] = v145.i32[0];
        float32x4_t v181 = vsubq_f32(v178, v179);
        float32x4_t v182 = vaddq_f32(v181, v146);
        float32x4_t v183 = vaddq_f32(v181, (float32x4_t)vextq_s8(v145, (int8x16_t)vuzp2q_s32((int32x4_t)v145, (int32x4_t)v145), 0xCuLL));
        float32x4_t v184 = vaddq_f32(v146, v183);
        int8x16_t v147 = (int8x16_t)vzip2q_s32((int32x4_t)v145, (int32x4_t)v145);
        float32x4_t v148 = (float32x4_t)vextq_s8(v147, v147, 8uLL);
        float32x4_t v185 = vaddq_f32(v181, v148);
        float32x4_t v186 = vaddq_f32(v148, v182);
        float32x4_t v187 = vaddq_f32(v148, v183);
        float32x4_t v188 = vaddq_f32(v148, v184);
        sub_1B642C720(a1, (uint64_t)&v181, (float32x4_t *)v135, flt_1B6E506B0, a1 + 376, v149, v150, v151);
        uint64_t v125 = objc_msgSend_indexGreaterThanIndex_(v113, v152, v125, v153);
      }
      while (v125 != 0x7FFFFFFFFFFFFFFFLL);
    }
    sub_1B64296C4(a1, a1 + 376, v119, v120, v121, v122, v123, v124);
    objc_msgSend_unlockSnapGuides(v24, v154, v155, v156);
  }
  double v157 = sub_1B6447718(*(void *)(a1 + 8));
  sub_1B642AD04(a1, v157, v158, v159, v160, v161, v162, v163, v164);
}

void sub_1B642B354(uint64_t a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(unsigned char *)(a1 + 65816))
  {
    a2.n128_u64[0] = (unint64_t)vadd_f32(vrndx_f32(*(float32x2_t *)(a1 + 65800)), (float32x2_t)0x3F0000003F000000);
    __n128 v35 = a2;
    a2.n128_u64[0] = (unint64_t)vadd_f32(vrndx_f32(*(float32x2_t *)(a1 + 65808)), (float32x2_t)0x3F0000003F000000);
    __n128 v41 = a2;
    sub_1B6429E7C((uint64_t *)a1, a1 + 984, a4, a5, a6, a7, a8, a9);
    sub_1B642A58C(a1, 0x3CCCCCCD3CCCCCCDLL, 0x3D4CCCCD3CCCCCCDLL, 0, a1 + 984, 1, v10, v11, v35.n128_f32[0], v35.n128_f32[1], v41.n128_f32[0], v41.n128_f32[1]);
    sub_1B6429E7C((uint64_t *)a1, a1 + 832, v12, v13, v14, v15, v16, v17);
    float32x4_t v18 = (float32x4_t)v35;
    v18.i32[2] = 0;
    float32x4_t v39 = v18;
    v18.i32[1] = v35.n128_i32[1];
    float32x4_t v34 = v18;
    float32x4_t v19 = (float32x4_t)v41;
    v19.i32[2] = 0;
    float32x4_t v37 = v19;
    v19.i32[1] = v35.n128_i32[1];
    float32x4_t v36 = v19;
    sub_1B642A10C(a1, 0, (float *)&xmmword_1B6E50720, (float *)&xmmword_1B6E50720, a1 + 832, v18, v19, v20, v21, v22);
    float32x4_t v23 = v37;
    v23.i32[1] = v41.n128_i32[1];
    float32x4_t v38 = v23;
    sub_1B642A10C(a1, 0, (float *)&xmmword_1B6E50720, (float *)&xmmword_1B6E50720, a1 + 832, v36, v23, v24, v25, v26);
    float32x4_t v27 = v39;
    v27.i32[1] = v41.n128_i32[1];
    float32x4_t v40 = v27;
    sub_1B642A10C(a1, 0, (float *)&xmmword_1B6E50720, (float *)&xmmword_1B6E50720, a1 + 832, v38, v27, v28, v29, v30);
    sub_1B642A10C(a1, 0, (float *)&xmmword_1B6E50720, (float *)&xmmword_1B6E50720, a1 + 832, v40, v34, v31, v32, v33);
  }

  sub_1B642A27C(a1);
}

void sub_1B642B4F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B64296C4(a1, a1 + 1288, a3, a4, a5, a6, a7, a8);
  sub_1B64296C4(a1, a1 + 1136, v9, v10, v11, v12, v13, v14);
  sub_1B64296C4(a1, a1 + 376, v15, v16, v17, v18, v19, v20);
  sub_1B64296C4(a1, a1 + 528, v21, v22, v23, v24, v25, v26);
  sub_1B64296C4(a1, a1 + 680, v27, v28, v29, v30, v31, v32);
  sub_1B64296C4(a1, a1 + 984, v33, v34, v35, v36, v37, v38);

  sub_1B64296C4(a1, a1 + 832, v39, v40, v41, v42, v43, v44);
}

void sub_1B642B56C(uint64_t a1, uint64_t a2, float *a3, float *a4, uint64_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, double a9, float32x4_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    a8 = *(int8x16_t *)a2;
    float32x4_t v13 = *(float32x4_t *)(a2 + 16);
    a10 = *(float32x4_t *)(a2 + 32);
    a7 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a2 + 48), a10, a7, 2), v13, *(float32x2_t *)a7.f32, 1), *(float32x4_t *)a2, a7.f32[0]);
    a6 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a2 + 48), a10, a6, 2), v13, *(float32x2_t *)a6.f32, 1), *(float32x4_t *)a2, a6.f32[0]);
  }
  float32x4_t v14 = vsubq_f32(a7, a6);
  a10.i32[0] = v14.i32[2];
  a8.i32[0] = 1.0;
  v15.i64[0] = 0x8000000080000000;
  v15.i64[1] = 0x8000000080000000;
  v15.i32[0] = vbslq_s8(v15, a8, (int8x16_t)a10).i32[0];
  float v16 = v14.f32[1] / (float)(fabsf(v14.f32[2]) + 1.0);
  a10.f32[0] = v14.f32[2] + (float)(*(float *)v15.i32 * vmuls_lane_f32(v16, *(float32x2_t *)v14.f32, 1));
  a10.f32[1] = *(float *)v15.i32 * (float)-(float)(v14.f32[0] * v16);
  a10.f32[2] = -v14.f32[0];
  float32x4_t v17 = vmulq_f32(a10, (float32x4_t)vdupq_n_s32(0x3E4CCCCDu));
  float32x4_t v18 = vaddq_f32(a7, vmulq_f32(v14, (float32x4_t)vdupq_n_s32(0xBE99999A)));
  float32x4_t v19 = vaddq_f32(v18, v17);
  float32x4_t v20 = vsubq_f32(v18, v17);
  unint64_t v22 = a6.i64[0];
  unsigned __int32 v23 = a6.u32[2];
  unsigned __int32 v26 = a7.u32[2];
  unint64_t v25 = a7.i64[0];
  __int32 v29 = v19.i32[2];
  uint64_t v28 = v19.i64[0];
  uint64_t v30 = v20.i64[0];
  __int32 v31 = v20.i32[2];
  int v24 = ((int)(float)(a3[3] * 255.0) << 24) | ((int)(float)(fminf(fmaxf(a3[2], 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(a3[1], 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*a3, 0.0), 1.0) * 255.0);
  int v27 = ((int)(float)(a4[3] * 255.0) << 24) | ((int)(float)(fminf(fmaxf(a4[2], 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(a4[1], 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*a4, 0.0), 1.0) * 255.0);
  sub_1B6429158(a1, (uint64_t)&v22, 4, (uint64_t)&unk_1B6E5073C, 6, a5, 1, a13, v21);
}

void sub_1B642B758(uint64_t *a1, float32x4_t *a2, float *a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, float32x4_t a10)
{
  uint64_t v14 = (uint64_t)(a1 + 47);
  sub_1B6429E7C(a1, (uint64_t)(a1 + 47), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);

  sub_1B642A10C((uint64_t)a1, a2, a3, a4, v14, a9, a10, v15, v16, v17);
}

__n128 sub_1B642B7D4(uint64_t a1, float32x4_t *a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (*(double *)(a1 + 1752) > 0.0)
  {
    float32x4_t v29 = 0u;
    float32x4_t v30 = 0u;
    float32x4_t v27 = 0u;
    float32x4_t v28 = 0u;
    float32x4_t v12 = a2[1];
    float32x4_t v25 = *a2;
    float32x4_t v26 = v12;
    if (a3)
    {
      float32x4_t v13 = *(float32x4_t *)(a3 + 16);
      float32x4_t v27 = *(float32x4_t *)a3;
      float32x4_t v28 = v13;
      float32x4_t v14 = *(float32x4_t *)(a3 + 48);
      float32x4_t v29 = *(float32x4_t *)(a3 + 32);
      float32x4_t v30 = v14;
    }
    else
    {
      float32x4_t v27 = (float32x4_t)xmmword_1B6E4F300;
      float32x4_t v28 = (float32x4_t)xmmword_1B6E4F320;
      float32x4_t v29 = (float32x4_t)xmmword_1B6E4F2E0;
      float32x4_t v30 = (float32x4_t)xmmword_1B6E4F370;
    }
    float32x4_t v31 = *(float32x4_t *)a4;
    sub_1B642A82C(a1, 4, &v25, 112, a5, a6, a7, a8);
  }
  sub_1B6429E7C((uint64_t *)a1, a1 + 376, a3, (uint64_t)a4, a5, a6, a7, a8);
  float32x4_t v15 = a2[1];
  float32x4_t v16 = vsubq_f32(*a2, v15);
  int8x16_t v17 = (int8x16_t)vaddq_f32(v15, v15);
  float32x4_t v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 3);
  v18.i32[0] = v17.i32[0];
  float32x4_t v25 = v16;
  float32x4_t v26 = vaddq_f32(v16, v18);
  float32x4_t v27 = vaddq_f32(v16, (float32x4_t)vextq_s8(v17, (int8x16_t)vuzp2q_s32((int32x4_t)v17, (int32x4_t)v17), 0xCuLL));
  float32x4_t v28 = vaddq_f32(v18, v27);
  int8x16_t v19 = (int8x16_t)vzip2q_s32((int32x4_t)v17, (int32x4_t)v17);
  float32x4_t v20 = (float32x4_t)vextq_s8(v19, v19, 8uLL);
  float32x4_t v29 = vaddq_f32(v16, v20);
  float32x4_t v30 = vaddq_f32(v20, v26);
  float32x4_t v31 = vaddq_f32(v20, v27);
  float32x4_t v32 = vaddq_f32(v20, v28);
  sub_1B642C720(a1, (uint64_t)&v25, (float32x4_t *)a3, a4, a1 + 376, v21, v22, v23);
  return result;
}

void sub_1B642B93C(uint64_t *a1, uint64_t a2, float32x4_t *a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v243 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = (uint64_t)(a1 + 47);
  sub_1B6429E7C(a1, (uint64_t)(a1 + 47), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if (a3)
  {
    unint64_t v16 = 0;
    float32x4_t v17 = *a3;
    float32x4_t v18 = a3[1];
    float32x4_t v20 = a3[2];
    float32x4_t v19 = a3[3];
    float32x4_t v21 = *(float32x4_t *)(a2 + 48);
    float32x4_t v237 = *(float32x4_t *)(a2 + 32);
    float32x4_t v238 = v21;
    float32x4_t v22 = *(float32x4_t *)(a2 + 80);
    float32x4_t v239 = *(float32x4_t *)(a2 + 64);
    float32x4_t v240 = v22;
    float32x4_t v23 = *(float32x4_t *)(a2 + 16);
    float32x4_t v235 = *(float32x4_t *)a2;
    float32x4_t v236 = v23;
    int32x4_t v24 = (int32x4_t)vmulq_f32(v17, v17);
    int32x4_t v25 = (int32x4_t)vmulq_f32(v18, v18);
    int32x4_t v26 = (int32x4_t)vmulq_f32(v20, v20);
    int32x4_t v27 = vzip2q_s32(v24, v26);
    float32x4_t v28 = (float32x4_t)vzip1q_s32(vzip1q_s32(v24, v26), v25);
    float32x4_t v29 = (float32x4_t)vtrn2q_s32(v24, v25);
    v29.i32[2] = v26.i32[1];
    float32x4_t v30 = vaddq_f32((float32x4_t)vzip1q_s32(v27, vdupq_laneq_s32(v25, 2)), vaddq_f32(v28, v29));
    __asm { FMOV            V5.4S, #1.0 }
    int32x4_t v36 = vceqzq_f32(v30);
    v36.i32[3] = 0;
    float32x4_t v37 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v36), (int8x16_t)v30, (int8x16_t)vdivq_f32(_Q5, v30));
    float32x4_t v38 = vmulq_n_f32(v17, v37.f32[0]);
    float32x4_t v39 = vmulq_lane_f32(v18, *(float32x2_t *)v37.f32, 1);
    float32x4_t v40 = vmulq_laneq_f32(v20, v37, 2);
    do
    {
      *(float32x4_t *)((char *)&v235 + v16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v38, COERCE_FLOAT(*(_OWORD *)((char *)&v235 + v16))), v39, *(float32x2_t *)&v235.f32[v16 / 4], 1), v40, *(float32x4_t *)((char *)&v235 + v16), 2), v19, *(float32x4_t *)((char *)&v235 + v16), 3);
      v16 += 16;
    }
    while (v16 != 96);
    float32x4_t v41 = v235;
    float32x4_t v42 = v236;
    int8x16_t v44 = (int8x16_t)v237;
    float32x4_t v43 = v238;
    float32x4_t v45 = v239;
    float32x4_t v46 = v240;
  }
  else
  {
    float32x4_t v41 = *(float32x4_t *)a2;
    float32x4_t v42 = *(float32x4_t *)(a2 + 16);
    int8x16_t v44 = *(int8x16_t *)(a2 + 32);
    float32x4_t v43 = *(float32x4_t *)(a2 + 48);
    float32x4_t v45 = *(float32x4_t *)(a2 + 64);
    float32x4_t v46 = *(float32x4_t *)(a2 + 80);
  }
  float32x4_t v47 = (float32x4_t)vextq_s8(vextq_s8(v44, v44, 0xCuLL), v44, 8uLL);
  float32x4_t v48 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v42, (int32x4_t)v42), (int8x16_t)v42, 0xCuLL);
  float32x4_t v49 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), v44, 0xCuLL);
  float32x4_t v50 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v42, (int8x16_t)v42, 0xCuLL), (int8x16_t)v42, 8uLL);
  float32x4_t v51 = vmlaq_f32(vmulq_f32(v50, vnegq_f32(v49)), v48, v47);
  float32x4_t v52 = vmulq_f32(v46, v51);
  int32x2_t v53 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).u64[0];
  if (*(float *)v53.i32 != 0.0)
  {
    float32x4_t v54 = v46;
    v54.f32[0] = -v46.f32[3];
    int8x16_t v55 = v44;
    *(float *)v55.i32 = -*(float *)&v44.i32[3];
    int8x16_t v56 = (int8x16_t)v42;
    *(float *)v56.i32 = -v42.f32[3];
    float32x4_t v57 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v56, v56, 0xCuLL), v56, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v55, (int32x4_t)v55), v55, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v56, (int32x4_t)v56), v56, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v55, v55, 0xCuLL), v55, 8uLL));
    float32x4_t v58 = v46;
    v58.f32[1] = -v46.f32[3];
    int8x16_t v59 = v44;
    *(float *)&v59.i32[1] = -*(float *)&v44.i32[3];
    int32x4_t v60 = (int32x4_t)vmulq_f32(v54, v57);
    int8x16_t v61 = (int8x16_t)v42;
    *(float *)&v61.i32[1] = -v42.f32[3];
    int32x4_t v62 = (int32x4_t)vmulq_f32(v58, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v61, v61, 0xCuLL), v61, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), v59, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v61, (int32x4_t)v61), v61, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v59, v59, 0xCuLL), v59, 8uLL)));
    *(float32x2_t *)v58.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v60.i8, *(int32x2_t *)v62.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v60.i8, *(int32x2_t *)v62.i8));
    float32x4_t v63 = (float32x4_t)vzip2q_s32(v60, v62);
    *(float32x2_t *)v63.f32 = vadd_f32(*(float32x2_t *)v63.f32, *(float32x2_t *)v58.f32);
    float32x4_t v64 = v46;
    v64.f32[2] = -v46.f32[3];
    int8x16_t v65 = v44;
    *(float *)&v65.i32[2] = -*(float *)&v44.i32[3];
    int8x16_t v66 = (int8x16_t)v42;
    *(float *)&v66.i32[2] = -v42.f32[3];
    float32x4_t v67 = vmulq_f32(v64, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v66, v66, 0xCuLL), v66, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v65, (int32x4_t)v65), v65, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v66, (int32x4_t)v66), v66, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v65, v65, 0xCuLL), v65, 8uLL)));
    v63.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 2), vaddq_f32(v67, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v67.f32, 1))).u32[0];
    float32x4_t v235 = vdivq_f32(v63, (float32x4_t)vdupq_lane_s32(v53, 0));
  }
  float32x4_t v68 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v41, (int8x16_t)v41, 0xCuLL), (int8x16_t)v41, 8uLL);
  float32x4_t v69 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), (int8x16_t)v41, 0xCuLL);
  float32x4_t v70 = vmlaq_f32(vmulq_f32(v47, vnegq_f32(v69)), v49, v68);
  float32x4_t v71 = vmulq_f32(v46, v70);
  int32x2_t v72 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 2), vaddq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 1))).u64[0];
  if (*(float *)v72.i32 != 0.0)
  {
    float32x4_t v73 = v46;
    v73.f32[0] = -v46.f32[3];
    int8x16_t v74 = (int8x16_t)v41;
    *(float *)v74.i32 = -v41.f32[3];
    int8x16_t v75 = v44;
    *(float *)v75.i32 = -*(float *)&v44.i32[3];
    float32x4_t v76 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v75, v75, 0xCuLL), v75, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v74, (int32x4_t)v74), v74, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), v75, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v74, v74, 0xCuLL), v74, 8uLL));
    float32x4_t v77 = v46;
    v77.f32[1] = -v46.f32[3];
    int8x16_t v78 = (int8x16_t)v41;
    *(float *)&v78.i32[1] = -v41.f32[3];
    int32x4_t v79 = (int32x4_t)vmulq_f32(v73, v76);
    int8x16_t v80 = v44;
    *(float *)&v80.i32[1] = -*(float *)&v44.i32[3];
    int32x4_t v81 = (int32x4_t)vmulq_f32(v77, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v80, v80, 0xCuLL), v80, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v78, (int32x4_t)v78), v78, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v80, (int32x4_t)v80), v80, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v78, v78, 0xCuLL), v78, 8uLL)));
    *(float32x2_t *)v77.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v79.i8, *(int32x2_t *)v81.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v79.i8, *(int32x2_t *)v81.i8));
    float32x4_t v82 = (float32x4_t)vzip2q_s32(v79, v81);
    *(float32x2_t *)v82.f32 = vadd_f32(*(float32x2_t *)v82.f32, *(float32x2_t *)v77.f32);
    float32x4_t v83 = v46;
    v83.f32[2] = -v46.f32[3];
    int8x16_t v84 = (int8x16_t)v41;
    *(float *)&v84.i32[2] = -v41.f32[3];
    int8x16_t v85 = v44;
    *(float *)&v85.i32[2] = -*(float *)&v44.i32[3];
    float32x4_t v86 = vmulq_f32(v83, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v85, v85, 0xCuLL), v85, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v84, (int32x4_t)v84), v84, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v85, (int32x4_t)v85), v85, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v84, v84, 0xCuLL), v84, 8uLL)));
    v82.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 2), vaddq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v86.f32, 1))).u32[0];
    float32x4_t v236 = vdivq_f32(v82, (float32x4_t)vdupq_lane_s32(v72, 0));
  }
  float32x4_t v87 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), (int8x16_t)v43, 0xCuLL);
  float32x4_t v88 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v43, (int8x16_t)v43, 0xCuLL), (int8x16_t)v43, 8uLL);
  float32x4_t v89 = vmlaq_f32(vmulq_f32(v88, vnegq_f32(v48)), v87, v50);
  float32x4_t v90 = vmulq_f32(v46, v89);
  int32x2_t v91 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 2), vaddq_f32(v90, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v90.f32, 1))).u64[0];
  if (*(float *)v91.i32 != 0.0)
  {
    float32x4_t v92 = v46;
    v92.f32[0] = -v46.f32[3];
    int8x16_t v93 = (int8x16_t)v42;
    *(float *)v93.i32 = -v42.f32[3];
    int8x16_t v94 = (int8x16_t)v43;
    *(float *)v94.i32 = -v43.f32[3];
    float32x4_t v95 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v94, v94, 0xCuLL), v94, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), v93, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v94, (int32x4_t)v94), v94, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v93, v93, 0xCuLL), v93, 8uLL));
    float32x4_t v96 = v46;
    v96.f32[1] = -v46.f32[3];
    int8x16_t v97 = (int8x16_t)v42;
    *(float *)&v97.i32[1] = -v42.f32[3];
    int32x4_t v98 = (int32x4_t)vmulq_f32(v92, v95);
    int8x16_t v99 = (int8x16_t)v43;
    *(float *)&v99.i32[1] = -v43.f32[3];
    int32x4_t v100 = (int32x4_t)vmulq_f32(v96, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v99, v99, 0xCuLL), v99, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v97, (int32x4_t)v97), v97, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v99, (int32x4_t)v99), v99, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v97, v97, 0xCuLL), v97, 8uLL)));
    *(float32x2_t *)v96.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v98.i8, *(int32x2_t *)v100.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v98.i8, *(int32x2_t *)v100.i8));
    float32x4_t v101 = (float32x4_t)vzip2q_s32(v98, v100);
    *(float32x2_t *)v101.f32 = vadd_f32(*(float32x2_t *)v101.f32, *(float32x2_t *)v96.f32);
    float32x4_t v102 = v46;
    v102.f32[2] = -v46.f32[3];
    int8x16_t v103 = (int8x16_t)v42;
    *(float *)&v103.i32[2] = -v42.f32[3];
    int8x16_t v104 = (int8x16_t)v43;
    *(float *)&v104.i32[2] = -v43.f32[3];
    float32x4_t v105 = vmulq_f32(v102, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v104, v104, 0xCuLL), v104, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), v103, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v104, (int32x4_t)v104), v104, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v103, v103, 0xCuLL), v103, 8uLL)));
    v101.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 2), vaddq_f32(v105, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v105.f32, 1))).u32[0];
    float32x4_t v237 = vdivq_f32(v101, (float32x4_t)vdupq_lane_s32(v91, 0));
  }
  float32x4_t v106 = vmlaq_f32(vmulq_f32(v68, vnegq_f32(v87)), v69, v88);
  float32x4_t v107 = vmulq_f32(v46, v106);
  int32x2_t v108 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 2), vaddq_f32(v107, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v107.f32, 1))).u64[0];
  if (*(float *)v108.i32 != 0.0)
  {
    float32x4_t v109 = v46;
    v109.f32[0] = -v46.f32[3];
    int8x16_t v110 = (int8x16_t)v43;
    *(float *)v110.i32 = -v43.f32[3];
    int8x16_t v111 = (int8x16_t)v41;
    *(float *)v111.i32 = -v41.f32[3];
    float32x4_t v112 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v111, v111, 0xCuLL), v111, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v110, (int32x4_t)v110), v110, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v111, (int32x4_t)v111), v111, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v110, v110, 0xCuLL), v110, 8uLL));
    float32x4_t v113 = v46;
    v113.f32[1] = -v46.f32[3];
    int8x16_t v114 = (int8x16_t)v43;
    *(float *)&v114.i32[1] = -v43.f32[3];
    int32x4_t v115 = (int32x4_t)vmulq_f32(v109, v112);
    int8x16_t v116 = (int8x16_t)v41;
    *(float *)&v116.i32[1] = -v41.f32[3];
    int32x4_t v117 = (int32x4_t)vmulq_f32(v113, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v116, v116, 0xCuLL), v116, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v114, (int32x4_t)v114), v114, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v116, (int32x4_t)v116), v116, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v114, v114, 0xCuLL), v114, 8uLL)));
    *(float32x2_t *)v113.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v115.i8, *(int32x2_t *)v117.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v115.i8, *(int32x2_t *)v117.i8));
    float32x4_t v118 = (float32x4_t)vzip2q_s32(v115, v117);
    *(float32x2_t *)v118.f32 = vadd_f32(*(float32x2_t *)v118.f32, *(float32x2_t *)v113.f32);
    float32x4_t v119 = v46;
    v119.f32[2] = -v46.f32[3];
    int8x16_t v120 = (int8x16_t)v43;
    *(float *)&v120.i32[2] = -v43.f32[3];
    int8x16_t v121 = (int8x16_t)v41;
    *(float *)&v121.i32[2] = -v41.f32[3];
    float32x4_t v122 = vmulq_f32(v119, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v121, v121, 0xCuLL), v121, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v120, (int32x4_t)v120), v120, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v121, (int32x4_t)v121), v121, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v120, v120, 0xCuLL), v120, 8uLL)));
    v118.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v122, 2), vaddq_f32(v122, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v122.f32, 1))).u32[0];
    float32x4_t v238 = vdivq_f32(v118, (float32x4_t)vdupq_lane_s32(v108, 0));
  }
  float32x4_t v123 = vmulq_f32(v45, v51);
  int32x2_t v124 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v123, 2), vaddq_f32(v123, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v123.f32, 1))).u64[0];
  if (*(float *)v124.i32 != 0.0)
  {
    float32x4_t v125 = v45;
    v125.f32[0] = -v45.f32[3];
    int8x16_t v126 = v44;
    *(float *)v126.i32 = -*(float *)&v44.i32[3];
    int8x16_t v127 = (int8x16_t)v42;
    *(float *)v127.i32 = -v42.f32[3];
    float32x4_t v128 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v127, v127, 0xCuLL), v127, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v126, (int32x4_t)v126), v126, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v127, (int32x4_t)v127), v127, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v126, v126, 0xCuLL), v126, 8uLL));
    float32x4_t v129 = v45;
    v129.f32[1] = -v45.f32[3];
    int8x16_t v130 = v44;
    *(float *)&v130.i32[1] = -*(float *)&v44.i32[3];
    int32x4_t v131 = (int32x4_t)vmulq_f32(v125, v128);
    int8x16_t v132 = (int8x16_t)v42;
    *(float *)&v132.i32[1] = -v42.f32[3];
    int32x4_t v133 = (int32x4_t)vmulq_f32(v129, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v132, v132, 0xCuLL), v132, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v130, (int32x4_t)v130), v130, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v132, (int32x4_t)v132), v132, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v130, v130, 0xCuLL), v130, 8uLL)));
    *(float32x2_t *)v129.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v131.i8, *(int32x2_t *)v133.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v131.i8, *(int32x2_t *)v133.i8));
    float32x4_t v134 = (float32x4_t)vzip2q_s32(v131, v133);
    *(float32x2_t *)v134.f32 = vadd_f32(*(float32x2_t *)v134.f32, *(float32x2_t *)v129.f32);
    float32x4_t v135 = v45;
    v135.f32[2] = -v45.f32[3];
    int8x16_t v136 = v44;
    *(float *)&v136.i32[2] = -*(float *)&v44.i32[3];
    int8x16_t v137 = (int8x16_t)v42;
    *(float *)&v137.i32[2] = -v42.f32[3];
    float32x4_t v138 = vmulq_f32(v135, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v137, v137, 0xCuLL), v137, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v136, (int32x4_t)v136), v136, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v137, (int32x4_t)v137), v137, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v136, v136, 0xCuLL), v136, 8uLL)));
    v134.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v138, 2), vaddq_f32(v138, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v138.f32, 1))).u32[0];
    float32x4_t v239 = vdivq_f32(v134, (float32x4_t)vdupq_lane_s32(v124, 0));
  }
  float32x4_t v139 = vmulq_f32(v45, v70);
  int32x2_t v140 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 2), vaddq_f32(v139, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v139.f32, 1))).u64[0];
  if (*(float *)v140.i32 != 0.0)
  {
    float32x4_t v141 = v45;
    v141.f32[0] = -v45.f32[3];
    int8x16_t v142 = (int8x16_t)v41;
    *(float *)v142.i32 = -v41.f32[3];
    int8x16_t v143 = v44;
    *(float *)v143.i32 = -*(float *)&v44.i32[3];
    float32x4_t v144 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v143, v143, 0xCuLL), v143, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v142, (int32x4_t)v142), v142, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v143, (int32x4_t)v143), v143, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v142, v142, 0xCuLL), v142, 8uLL));
    float32x4_t v145 = v45;
    v145.f32[1] = -v45.f32[3];
    int8x16_t v146 = (int8x16_t)v41;
    *(float *)&v146.i32[1] = -v41.f32[3];
    int32x4_t v147 = (int32x4_t)vmulq_f32(v141, v144);
    int8x16_t v148 = v44;
    *(float *)&v148.i32[1] = -*(float *)&v44.i32[3];
    int32x4_t v149 = (int32x4_t)vmulq_f32(v145, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v148, v148, 0xCuLL), v148, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v146, (int32x4_t)v146), v146, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v148, (int32x4_t)v148), v148, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v146, v146, 0xCuLL), v146, 8uLL)));
    *(float32x2_t *)v145.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v147.i8, *(int32x2_t *)v149.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v147.i8, *(int32x2_t *)v149.i8));
    float32x4_t v150 = (float32x4_t)vzip2q_s32(v147, v149);
    *(float32x2_t *)v150.f32 = vadd_f32(*(float32x2_t *)v150.f32, *(float32x2_t *)v145.f32);
    float32x4_t v151 = v45;
    v151.f32[2] = -v45.f32[3];
    int8x16_t v152 = (int8x16_t)v41;
    *(float *)&v152.i32[2] = -v41.f32[3];
    int8x16_t v153 = v44;
    *(float *)&v153.i32[2] = -*(float *)&v44.i32[3];
    float32x4_t v154 = vmulq_f32(v151, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v153, v153, 0xCuLL), v153, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v152, (int32x4_t)v152), v152, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v153, (int32x4_t)v153), v153, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v152, v152, 0xCuLL), v152, 8uLL)));
    v150.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 2), vaddq_f32(v154, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v154.f32, 1))).u32[0];
    float32x4_t v240 = vdivq_f32(v150, (float32x4_t)vdupq_lane_s32(v140, 0));
  }
  float32x4_t v155 = vmulq_f32(v45, v89);
  int32x2_t v156 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v155, 2), vaddq_f32(v155, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v155.f32, 1))).u64[0];
  if (*(float *)v156.i32 != 0.0)
  {
    float32x4_t v157 = v45;
    v157.f32[0] = -v45.f32[3];
    int8x16_t v158 = (int8x16_t)v42;
    *(float *)v158.i32 = -v42.f32[3];
    int8x16_t v159 = (int8x16_t)v43;
    *(float *)v159.i32 = -v43.f32[3];
    float32x4_t v160 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v159, v159, 0xCuLL), v159, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v158, (int32x4_t)v158), v158, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v159, (int32x4_t)v159), v159, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v158, v158, 0xCuLL), v158, 8uLL));
    float32x4_t v161 = v45;
    v161.f32[1] = -v45.f32[3];
    int8x16_t v162 = (int8x16_t)v42;
    *(float *)&v162.i32[1] = -v42.f32[3];
    int32x4_t v163 = (int32x4_t)vmulq_f32(v157, v160);
    int8x16_t v164 = (int8x16_t)v43;
    *(float *)&v164.i32[1] = -v43.f32[3];
    int32x4_t v165 = (int32x4_t)vmulq_f32(v161, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v164, v164, 0xCuLL), v164, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v162, (int32x4_t)v162), v162, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v164, (int32x4_t)v164), v164, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v162, v162, 0xCuLL), v162, 8uLL)));
    *(float32x2_t *)v161.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v163.i8, *(int32x2_t *)v165.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v163.i8, *(int32x2_t *)v165.i8));
    float32x4_t v166 = (float32x4_t)vzip2q_s32(v163, v165);
    *(float32x2_t *)v166.f32 = vadd_f32(*(float32x2_t *)v166.f32, *(float32x2_t *)v161.f32);
    float32x4_t v167 = v45;
    v167.f32[2] = -v45.f32[3];
    int8x16_t v168 = (int8x16_t)v42;
    *(float *)&v168.i32[2] = -v42.f32[3];
    int8x16_t v169 = (int8x16_t)v43;
    *(float *)&v169.i32[2] = -v43.f32[3];
    float32x4_t v170 = vmulq_f32(v167, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v169, v169, 0xCuLL), v169, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v168, (int32x4_t)v168), v168, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v169, (int32x4_t)v169), v169, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v168, v168, 0xCuLL), v168, 8uLL)));
    v166.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v170, 2), vaddq_f32(v170, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v170.f32, 1))).u32[0];
    float32x4_t v241 = vdivq_f32(v166, (float32x4_t)vdupq_lane_s32(v156, 0));
  }
  float32x4_t v223 = (float32x4_t)v44;
  float32x4_t v171 = vmulq_f32(v45, v106);
  int32x2_t v172 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v171, 2), vaddq_f32(v171, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v171.f32, 1))).u64[0];
  if (*(float *)v172.i32 != 0.0)
  {
    float32x4_t v173 = v45;
    v173.f32[0] = -v45.f32[3];
    int8x16_t v174 = (int8x16_t)v43;
    *(float *)v174.i32 = -v43.f32[3];
    int8x16_t v175 = (int8x16_t)v41;
    *(float *)v175.i32 = -v41.f32[3];
    float32x4_t v176 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v175, v175, 0xCuLL), v175, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v174, (int32x4_t)v174), v174, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v175, (int32x4_t)v175), v175, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v174, v174, 0xCuLL), v174, 8uLL));
    float32x4_t v177 = v45;
    v177.f32[1] = -v45.f32[3];
    int8x16_t v178 = (int8x16_t)v43;
    *(float *)&v178.i32[1] = -v43.f32[3];
    int32x4_t v179 = (int32x4_t)vmulq_f32(v173, v176);
    int8x16_t v180 = (int8x16_t)v41;
    *(float *)&v180.i32[1] = -v41.f32[3];
    int32x4_t v181 = (int32x4_t)vmulq_f32(v177, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v180, v180, 0xCuLL), v180, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v178, (int32x4_t)v178), v178, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v180, (int32x4_t)v180), v180, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v178, v178, 0xCuLL), v178, 8uLL)));
    *(float32x2_t *)v177.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v179.i8, *(int32x2_t *)v181.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v179.i8, *(int32x2_t *)v181.i8));
    float32x4_t v182 = (float32x4_t)vzip2q_s32(v179, v181);
    *(float32x2_t *)v182.f32 = vadd_f32(*(float32x2_t *)v182.f32, *(float32x2_t *)v177.f32);
    float32x4_t v183 = v45;
    v183.f32[2] = -v45.f32[3];
    int8x16_t v184 = (int8x16_t)v43;
    *(float *)&v184.i32[2] = -v43.f32[3];
    int8x16_t v185 = (int8x16_t)v41;
    *(float *)&v185.i32[2] = -v41.f32[3];
    float32x4_t v186 = vmulq_f32(v183, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v185, v185, 0xCuLL), v185, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v184, (int32x4_t)v184), v184, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v185, (int32x4_t)v185), v185, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v184, v184, 0xCuLL), v184, 8uLL)));
    v182.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v186, 2), vaddq_f32(v186, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v186.f32, 1))).u32[0];
    float32x4_t v242 = vdivq_f32(v182, (float32x4_t)vdupq_lane_s32(v172, 0));
  }
  sub_1B642C720((uint64_t)a1, (uint64_t)&v235, 0, a4, v12, v13, v14, v15);
  float32x4_t v228 = v238;
  float32x4_t v230 = v235;
  float32x4_t v225 = v242;
  float32x4_t v226 = v239;
  float32x4_t v187 = vsubq_f32(v235, v242);
  float32x4_t v188 = vmulq_f32(v187, v187);
  *(float *)v189.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v188, 2), vaddq_f32(v188, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v188.f32, 1))).f32[0])* 0.05;
  int8x16_t v234 = v189;
  v190.i64[0] = 0x3F0000003F000000;
  v190.i64[1] = 0x3F0000003F000000;
  float32x4_t v191 = vmulq_f32(vaddq_f32(v235, v238), v190);
  float32x4_t v224 = vmulq_f32(vaddq_f32(v242, v239), v190);
  sub_1B642B56C((uint64_t)a1, 0, a4, a4, v12, v191, vmlaq_n_f32(v191, v46, *(float *)v189.i32), (int8x16_t)v46, *(double *)v189.i64, v238, v192, v193, v194);
  sub_1B642B56C((uint64_t)a1, 0, a4, a4, v12, v224, vmlaq_n_f32(v224, v45, *(float *)v234.i32), (int8x16_t)v45, *(double *)v224.i64, v198, v195, v196, v197);
  v199.i64[0] = 0x3F0000003F000000;
  v199.i64[1] = 0x3F0000003F000000;
  float32x4_t v233 = vmulq_f32(vaddq_f32(v237, v241), v199);
  float32x4_t v200 = vmulq_f32(vaddq_f32(v225, v228), v199);
  float32x4_t v201 = vmulq_f32(vaddq_f32(v230, v226), v199);
  float32x4_t v227 = vmulq_f32(vaddq_f32(v236, v240), v199);
  float32x4_t v229 = v201;
  float32x4_t v202 = vmulq_f32(vaddq_f32(v201, v233), v199);
  float32x4_t v231 = vmulq_f32(vaddq_f32(v200, v227), v199);
  float32x4_t v232 = v200;
  sub_1B642B56C((uint64_t)a1, 0, a4, a4, v12, v202, vmlaq_n_f32(v202, v42, *(float *)v234.i32), (int8x16_t)v42, *(double *)v234.i64, v201, v203, v204, v205);
  sub_1B642B56C((uint64_t)a1, 0, a4, a4, v12, v231, vmlaq_n_f32(v231, v41, *(float *)v234.i32), v234, *(double *)v231.i64, v209, v206, v207, v208);
  v210.i64[0] = 0x3F0000003F000000;
  v210.i64[1] = 0x3F0000003F000000;
  float32x4_t v211 = vmulq_f32(vaddq_f32(v232, v233), v210);
  sub_1B642B56C((uint64_t)a1, 0, a4, a4, v12, v211, vmlaq_n_f32(v211, v43, *(float *)v234.i32), (int8x16_t)v43, *(double *)v234.i64, v215, v212, v213, v214);
  v220.i64[0] = 0x3F0000003F000000;
  v220.i64[1] = 0x3F0000003F000000;
  float32x4_t v221 = vmulq_f32(vaddq_f32(v229, v227), v220);
  float32x4_t v222 = vmlaq_n_f32(v221, v223, *(float *)v234.i32);

  sub_1B642B56C((uint64_t)a1, 0, a4, a4, v12, v221, v222, (int8x16_t)v223, *(double *)v234.i64, v219, v216, v217, v218);
}

void sub_1B642C6B4(uint64_t *a1, uint64_t a2, float32x4_t *a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = (uint64_t)(a1 + 47);
  sub_1B6429E7C(a1, (uint64_t)(a1 + 47), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);

  sub_1B642C720((uint64_t)a1, a2, a3, a4, v12, v13, v14, v15);
}

void sub_1B642C720(uint64_t a1, uint64_t a2, float32x4_t *a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    for (uint64_t i = 0; i != 128; i += 16)
      *(float32x4_t *)(a2 + i) = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a3[3], a3[2], *(float32x4_t *)(a2 + i), 2), a3[1], *(float32x2_t *)(a2 + i), 1), *a3, COERCE_FLOAT(*(_OWORD *)(a2 + i)));
  }
  for (uint64_t j = 0; j != 128; j += 16)
  {
    uint64_t v10 = &v15[j];
    int v11 = *(_DWORD *)(a2 + j + 8);
    *(void *)uint64_t v10 = *(void *)(a2 + j);
    *((_DWORD *)v10 + 2) = v11;
  }
  int v12 = ((int)(float)(a4[3] * 255.0) << 24) | ((int)(float)(fminf(fmaxf(a4[2], 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(a4[1], 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*a4, 0.0), 1.0) * 255.0);
  for (uint64_t k = 12; k != 140; k += 16)
    *(_DWORD *)&v15[k] = v12;
  sub_1B6429158(a1, (uint64_t)v15, 8, (uint64_t)&unk_1B6E50748, 24, a5, 1, a8, v14);
}

void sub_1B642C85C(uint64_t *a1, uint64_t a2, float32x4_t *a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = (uint64_t)(a1 + 47);
  sub_1B6429E7C(a1, (uint64_t)(a1 + 47), (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if (sub_1B662E060(a2))
  {
    uint64_t v13 = sub_1B6355ECC(a2);
    uint64_t v14 = sub_1B65349B8(a2);
    int v15 = sub_1B662E070(a2);
    if (v15 >= 1)
    {
      uint64_t v19 = v15;
      float32x4_t v20 = (int *)(v14 + 4);
      do
      {
        sub_1B642A10C((uint64_t)a1, a3, a4, a4, v12, *(float32x4_t *)(v13 + 16 * *(v20 - 1)), *(float32x4_t *)(v13 + 16 * *v20), v16, v17, v18);
        v20 += 2;
        --v19;
      }
      while (v19);
    }
  }
}

void sub_1B642C918(void *a1, float32x4_t *a2)
{
  __int16 v11 = sub_1B6446228(a1[1]);
  if ((v11 & 0x80) != 0)
  {
    uint64_t v12 = sub_1B64A16A0((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = (__n128 *)sub_1B64A01D4((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
      LODWORD(v15) = 12.5;
      sub_1B63E0A94((__n128 *)a1[1], v15, *v14, v14[1], v14[2], v14[3]);
      sub_1B6525B0C(v13, (uint64_t)a1, (uint64_t)a2, v16, v17, v18, v19, v20, v21);
    }
  }
  if ((v11 & 0x100) != 0) {
    sub_1B642CA78((uint64_t)a1, (uint64_t)a2, v5, v6, v7, v8, v9, v10);
  }
  if ((v11 & 2) != 0)
  {
    uint64_t v22 = sub_1B64A16A0((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
    if (v22) {
      sub_1B6525D00(v22, (uint64_t)a1, (uint64_t)a2, v25, v26, v27, v28, v29);
    }
    int v30 = sub_1B649FA1C((uint64_t)a2, v23, v24, v25, v26, v27, v28, v29);
    memset(v60, 0, sizeof(v60));
    if (sub_1B64A00F0(a2, 1, v60, v31, v32, v33, v34, v35))
    {
      uint64_t v36 = sub_1B64A01D4((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
      v59[0] = 0;
      v59[1] = 0;
      float v37 = 0.0;
      if (!v30) {
        float v37 = 1.0;
      }
      sub_1B63C8F2C((float *)v59, 1.0, v37, 0.9, 1.0);
      sub_1B642B7D4((uint64_t)a1, v60, v36, (float *)v59, v38, v39, v40, v41);
    }
  }
  if ((v11 & 0x100) != 0)
  {
    float32x4_t v42 = (long long *)sub_1B64A01D4((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
    uint64_t v50 = sub_1B649F5F4((uint64_t)a2, v43, v44, v45, v46, v47, v48, v49);
    if (v50)
    {
      unint64_t v58 = sub_1B63CCE68(v50, v51, v52, v53, v54, v55, v56, v57);
      if (v58) {
        sub_1B6428B88(a1, v58, 0, v42);
      }
    }
  }
}

void sub_1B642CA78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B649F5F4(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v18 = v10;
    uint64_t v19 = sub_1B63CCE68(v10, v11, v12, v13, v14, v15, v16, v17);
    if (v19)
    {
      uint64_t v27 = v19;
      uint64_t v28 = (__n128 *)sub_1B64A01D4(a2, v20, v21, v22, v23, v24, v25, v26);
      LODWORD(v29) = 6.25;
      sub_1B63E0A94(*(__n128 **)(a1 + 8), v29, *v28, v28[1], v28[2], v28[3]);
      unsigned __int32 v122 = v30;
      uint64_t v36 = sub_1B64ACE9C(v27, 0, 0, v31, v32, v33, v34, v35);
      uint64_t v41 = sub_1B64AC5F8(v27, 0, 0, 0, v37, v38, v39, v40);
      uint64_t v42 = sub_1B6451064(v18);
      uint64_t v43 = sub_1B63D0F30(v18);
      if (v42)
      {
        uint64_t v48 = v43;
        if (v43)
        {
          if (sub_1B63D11A8(v43) != 1) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Found crease element with more than 1 channel", v50, v51, v52, v53, v54, v55, (uint64_t)"CFXMeshElementGetIndicesChannelCount(creaseElement) == 1");
          }
          uint64_t v123 = sub_1B641E1A8(v42, v49, v50, v51, v52, v53, v54, v55);
          uint64_t v56 = sub_1B63D11E8(v48);
          CFArrayRef v64 = sub_1B64ABD08(v27, v57, v58, v59, v60, v61, v62, v63);
          if ((uint64_t)v64 >= 1)
          {
            CFArrayRef v66 = v64;
            for (CFIndex i = 0; (const __CFArray *)i != v66; ++i)
            {
              float32x4_t v68 = sub_1B64ABD78(v27, i, 0, v65, v44, v45, v46, v47);
              uint64_t v131 = 0;
              long long v129 = 0u;
              long long v130 = 0u;
              long long v128 = 0u;
              sub_1B63D11F0((uint64_t)v68, v36, v69, v70, v71, v72, v73, v74, (uint64_t)&v128);
              v127[0] = MEMORY[0x1E4F143A8];
              v127[1] = 3221225472;
              v127[2] = sub_1B642CD3C;
              v127[3] = &unk_1E6141DD8;
              v127[4] = v56;
              v127[5] = v48;
              v127[6] = 0;
              v127[7] = v123;
              v127[8] = v41;
              v127[9] = a1;
              v127[10] = v28;
              v125[0] = v128;
              v125[1] = v129;
              v125[2] = v130;
              uint64_t v126 = v131;
              sub_1B63D1BEC((uint64_t *)v125, (uint64_t)v127, v75, v76, v77, v78, v79, v80);
            }
          }
        }
      }
      int32x4_t v81 = sub_1B64AC5F8(v27, 7, 0, 0, v44, v45, v46, v47);
      if (v81)
      {
        float32x4_t v89 = (void *)sub_1B641E1A8((uint64_t)v81, v82, v83, v84, v85, v86, v87, v88);
        uint64_t v97 = sub_1B641D8A0((uint64_t)v41, v90, v91, v92, v93, v94, v95, v96);
        if (v97 >= 1)
        {
          uint64_t v104 = v97;
          for (uint64_t j = 0; j != v104; ++j)
          {
            v106.n128_f64[0] = sub_1B641E208((uint64_t)v41, j, v98, v99, v100, v101, v102, v103);
            __n128 v124 = v106;
            float32x4_t v113 = sub_1B6534808(v89, j, v107, v108, v109, v110, v111, v112);
            float v119 = *(float *)v113 * 0.5;
            if (v119 > 1.0) {
              float v119 = 1.0;
            }
            float v120 = 2.0 - (float)(*(float *)v113 * 0.5);
            if (v120 > 1.0) {
              float v120 = 1.0;
            }
            *(void *)&long long v128 = LODWORD(v119) | ((unint64_t)LODWORD(v120) << 32);
            *((void *)&v128 + 1) = 0x3F80000000000000;
            __n128 v121 = v124;
            v121.n128_u32[3] = v122;
            sub_1B642AC18(a1, (long long *)v28, &v128, v114, v115, v116, v117, v118, v121);
          }
        }
      }
    }
  }
}

void sub_1B642CD3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    uint64_t v10 = 0;
    uint64_t v11 = a4;
    do
    {
      uint64_t v12 = *(unsigned int *)(a3 + 4 * v10++);
      uint64_t v13 = v10;
      if (v10 == v11) {
        uint64_t v13 = 0;
      }
      uint64_t v14 = *(unsigned int *)(a3 + 4 * v13);
      float v15 = 0.0;
      if (*(uint64_t *)(a1 + 32) >= 1)
      {
        uint64_t v16 = 0;
        while (1)
        {
          int v17 = sub_1B63D14A0(*(void *)(a1 + 40), v16, 0, *(void *)(a1 + 48), a5, a6, a7, a8);
          int v22 = sub_1B63D14A0(*(void *)(a1 + 40), v16, 1, *(void *)(a1 + 48), v18, v19, v20, v21);
          if (v12 == v17 && v14 == v22) {
            break;
          }
          if (v12 == v22 && v14 == v17) {
            break;
          }
          if (++v16 >= *(void *)(a1 + 32)) {
            goto LABEL_18;
          }
        }
        float v15 = *(float *)sub_1B6534808(*(void **)(a1 + 56), v16, a3, a4, a5, a6, a7, a8);
      }
LABEL_18:
      *(double *)v25.i64 = sub_1B641E208(*(void *)(a1 + 64), v12, a3, a4, a5, a6, a7, a8);
      float32x4_t v41 = v25;
      *(double *)v37.i64 = sub_1B641E208(*(void *)(a1 + 64), v14, v26, v27, v28, v29, v30, v31);
      float32x4_t v38 = v37;
      float v39 = v15 * 0.5;
      if ((float)(v15 * 0.5) > 1.0) {
        float v39 = 1.0;
      }
      float v40 = 2.0 - (float)(v15 * 0.5);
      if (v40 > 1.0) {
        float v40 = 1.0;
      }
      v42[0] = LODWORD(v39) | ((unint64_t)LODWORD(v40) << 32);
      v42[1] = 0x3F80000000000000;
      sub_1B642AB40(*(void *)(a1 + 72), *(float32x4_t **)(a1 + 80), (float *)v42, v32, v33, v34, v35, v36, v41, v38);
    }
    while (v10 != v11);
  }
}

void sub_1B642CEA4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = 47;
  if (a6) {
    uint64_t v13 = 66;
  }
  uint64_t v14 = (uint64_t)&a1[v13];
  sub_1B6429E7C(a1, (uint64_t)&a1[v13], a3, a4, a5, a6, a7, a8);

  sub_1B642CF40((uint64_t)a1, a2, a3, a4, a5, v14);
}

void sub_1B642CF40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  int v8 = *(unsigned __int8 *)(a6 + 48);
  if (*(unsigned char *)(a6 + 48)) {
    uint64_t v9 = 51;
  }
  else {
    uint64_t v9 = 52;
  }
  *(double *)v13.i64 = MEMORY[0x1F4188790](a1, a2);
  int v17 = (_OWORD *)&v54.f32[-4 * v9];
  float32x4_t v19 = *v18;
  float32x4_t v20 = vmlaq_n_f32(*v10, *v18, v13.f32[0]);
  if (v11)
  {
    float32x4_t v13 = *v11;
    float32x4_t v15 = v11[1];
    float32x4_t v21 = v11[2];
    float32x4_t v22 = vmulq_f32(v19, v19);
    float32x4_t v23 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32(v21, v19, 2), v15, *(float32x2_t *)v19.f32, 1), *v11, v19.f32[0]);
    float v24 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0]);
    float32x4_t v25 = vmulq_f32(v23, v23);
    v25.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).u64[0];
    float32x4_t v26 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0);
    v26.i32[3] = 0;
    float32x4_t v27 = vrsqrteq_f32(v26);
    float32x4_t v28 = vmulq_f32(v27, vrsqrtsq_f32(v26, vmulq_f32(v27, v27)));
    int32x4_t v29 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v25.f32[0] != 0.0)), 0x1FuLL));
    v29.i32[3] = 0;
    float32x4_t v19 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v29), (int8x16_t)vmulq_f32(v23, vmulq_n_f32(vmulq_f32(v28, vrsqrtsq_f32(v26, vmulq_f32(v28, v28))), v24)), (int8x16_t)v23);
    float32x4_t v16 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v11[3], v21, v20, 2), v15, *(float32x2_t *)v20.f32, 1), *v11, v20.f32[0]);
    float32x4_t v20 = v16;
    float32x4_t v54 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v11[3], v21, *v10, 2), v15, *(float32x2_t *)v10->f32, 1), *v11, COERCE_FLOAT(*v10));
  }
  else
  {
    float32x4_t v54 = *v10;
  }
  uint64_t v30 = 0;
  v13.i32[0] = v19.i32[2];
  v15.i32[0] = 1.0;
  v31.i64[0] = 0x8000000080000000;
  v31.i64[1] = 0x8000000080000000;
  v31.i32[0] = vbslq_s8(v31, (int8x16_t)v15, (int8x16_t)v13).i32[0];
  v16.f32[0] = v19.f32[1] / (float)(fabsf(v19.f32[2]) + 1.0);
  float v32 = vmuls_lane_f32(v16.f32[0], *(float32x2_t *)v19.f32, 1);
  v16.f32[0] = -(float)(v19.f32[0] * v16.f32[0]);
  v13.f32[0] = v19.f32[2] + (float)(*(float *)v31.i32 * v32);
  v13.f32[1] = *(float *)v31.i32 * v16.f32[0];
  v13.f32[2] = -v19.f32[0];
  float v33 = 0.0;
  int v34 = ((int)(float)(v12[3] * 255.0) << 24) | ((int)(float)(fminf(fmaxf(v12[2], 0.0), 1.0) * 255.0) << 16);
  v16.f32[1] = 1.0 - v32;
  v16.i32[2] = vmuls_lane_f32(-*(float *)v31.i32, *(float32x2_t *)v19.f32, 1);
  float32x4_t v55 = vmulq_n_f32(v16, v14);
  float32x4_t v56 = vmulq_n_f32(v13, v14);
  int v35 = v34 | ((int)(float)(fminf(fmaxf(v12[1], 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*v12, 0.0), 1.0)
                                                                                       * 255.0);
  float32x4_t v57 = v20;
  do
  {
    __float2 v38 = __sincosf_stret(v33);
    float32x4_t v39 = v57;
    float32x4_t v40 = vmlaq_n_f32(vmlaq_n_f32(v57, v56, v38.__cosval), v55, v38.__sinval);
    float32x4_t v41 = &v17[v30];
    *(void *)float32x4_t v41 = v40.i64[0];
    DWORD2(v17[v30]) = v40.i32[2];
    *((_DWORD *)v41 + 3) = v35;
    float v33 = v33 + 0.12566;
    ++v30;
  }
  while (v30 != 50);
  __int32 v42 = v54.i32[2];
  *((void *)v17 + 100) = v54.i64[0];
  *((_DWORD *)v17 + 202) = v42;
  *((_DWORD *)v17 + 203) = v35;
  if (!v8)
  {
    *((void *)v17 + 102) = v39.i64[0];
    *((_DWORD *)v17 + 206) = v39.i32[2];
    *((_DWORD *)v17 + 207) = v35;
  }
  ((void (*)(void, void))MEMORY[0x1F4188790])(v36, v37);
  uint64_t v46 = (char *)&v54 - v45;
  unsigned int v47 = -49;
  for (CFIndex i = (float32x4_t *)((char *)&v54 - v45); ; CFIndex i = (float32x4_t *)v51)
  {
    __int16 v49 = v47 + 49;
    __int16 v50 = v47;
    if (v47 >= 0xFFFFFFCF) {
      __int16 v50 = v47 + 50;
    }
    if (!v8) {
      break;
    }
    uint64_t v51 = &i->i16[2];
    i->i16[0] = v49;
    i->i16[1] = v50;
    if (!v47)
    {
      *(_OWORD *)uint64_t v51 = xmmword_1B6E504E0;
      goto LABEL_24;
    }
LABEL_18:
    ++v47;
  }
  uint64_t v51 = &i->i16[3];
  i->i16[2] = v50;
  i->i16[0] = 51;
  i->i16[1] = v49;
  if (v47) {
    goto LABEL_18;
  }
  for (int j = 1; j != 51; ++j)
  {
    *uint64_t v51 = 50;
    v51[1] = j - 1;
    if (j == 50) {
      __int16 v53 = 0;
    }
    else {
      __int16 v53 = j;
    }
    v51[2] = v53;
    v51 += 3;
  }
LABEL_24:
  sub_1B6429158(a1, (uint64_t)(&v54 - v9), v9, (uint64_t)v46, v43, a6, 1, v44, v54.i64[0]);
}

void sub_1B642D2C4(uint64_t *a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, float *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, float a10)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 47;
  if (a6) {
    uint64_t v16 = 66;
  }
  uint64_t v17 = (uint64_t)&a1[v16];
  sub_1B6429E7C(a1, (uint64_t)&a1[v16], (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8);
  v19.i32[0] = 1.0;
  v20.i64[0] = 0x8000000080000000;
  v20.i64[1] = 0x8000000080000000;
  float v22 = a3->f32[1];
  v21.i32[0] = a3->i32[2];
  v20.i32[0] = vbslq_s8(v20, v19, v21).i32[0];
  float v23 = v22 / (float)(fabsf(*(float *)v21.i32) + 1.0);
  v24.f32[0] = -(float)(a3->f32[0] * v23);
  v25.f32[0] = *(float *)v21.i32 + (float)(*(float *)v20.i32 * (float)(v22 * v23));
  v25.f32[1] = *(float *)v20.i32 * v24.f32[0];
  v25.f32[2] = -a3->f32[0];
  v24.f32[1] = 1.0 - (float)(v22 * v23);
  v24.f32[2] = -(float)(*(float *)v20.i32 * v22);
  float32x4_t v26 = vmulq_n_f32(*a3, *(float *)&a9);
  float32x4_t v27 = vmlaq_n_f32(v26, vaddq_f32(v24, v25), a10 * 0.5);
  float32x4_t v28 = vmlaq_n_f32(v26, vsubq_f32(v25, v24), a10 * 0.5);
  float32x4_t v29 = vmlaq_n_f32(v26, vsubq_f32(vnegq_f32(v25), v24), a10 * 0.5);
  float32x4_t v30 = vmlaq_n_f32(v26, vsubq_f32(v24, v25), a10 * 0.5);
  float32x4_t v31 = *a2;
  if (a4)
  {
    float32x4_t v32 = *(float32x4_t *)(a4 + 16);
    float32x4_t v33 = *(float32x4_t *)(a4 + 32);
    float32x4_t v30 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a4 + 48), v33, v30, 2), v32, *(float32x2_t *)v30.f32, 1), *(float32x4_t *)a4, v30.f32[0]);
    float32x4_t v29 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a4 + 48), v33, v29, 2), v32, *(float32x2_t *)v29.f32, 1), *(float32x4_t *)a4, v29.f32[0]);
    float32x4_t v28 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a4 + 48), v33, v28, 2), v32, *(float32x2_t *)v28.f32, 1), *(float32x4_t *)a4, v28.f32[0]);
    float32x4_t v27 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a4 + 48), v33, v27, 2), v32, *(float32x2_t *)v27.f32, 1), *(float32x4_t *)a4, v27.f32[0]);
    float32x4_t v31 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a4 + 48), v33, v31, 2), v32, *(float32x2_t *)v31.f32, 1), *(float32x4_t *)a4, v31.f32[0]);
  }
  uint64_t v35 = v31.i64[0];
  __int32 v36 = v31.i32[2];
  uint64_t v38 = v27.i64[0];
  __int32 v39 = v27.i32[2];
  uint64_t v41 = v28.i64[0];
  __int32 v42 = v28.i32[2];
  uint64_t v44 = v29.i64[0];
  __int32 v45 = v29.i32[2];
  uint64_t v47 = v30.i64[0];
  __int32 v48 = v30.i32[2];
  int v49 = ((int)(float)(a5[3] * 255.0) << 24) | ((int)(float)(fminf(fmaxf(a5[2], 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(a5[1], 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*a5, 0.0), 1.0) * 255.0);
  int v46 = v49;
  int v43 = v49;
  int v40 = v49;
  int v37 = v49;
  sub_1B6429158((uint64_t)a1, (uint64_t)&v35, 5, (uint64_t)&unk_1B6E50778, 16, v17, 1, v18, *(uint64_t *)&a9);
}

void sub_1B642D538(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v13 = a1 + 1136;
  sub_1B6429E7C((uint64_t *)a1, a1 + 1136, a3, a4, a5, a6, a7, a8);
  sub_1B642D61C(a1, a1 + 1440, (uint64_t (*)(void))sub_1B642DAE0, 0, 0);
  CFTypeRef v14 = *(CFTypeRef *)(a1 + 1168);
  CFTypeRef v15 = *(CFTypeRef *)(a1 + 1440);
  if (v14 != v15)
  {
    if (v14)
    {
      CFRelease(*(CFTypeRef *)(a1 + 1168));
      *(void *)(a1 + 1168) = 0;
      CFTypeRef v15 = *(CFTypeRef *)(a1 + 1440);
    }
    if (v15) {
      CFTypeRef v15 = CFRetain(v15);
    }
    *(void *)(a1 + 1168) = v15;
  }
  if (a3) {
    uint64_t v16 = (uint64_t *)a3;
  }
  else {
    uint64_t v16 = (uint64_t *)&xmmword_1B6E50720;
  }
  double v17 = a9;
  sub_1B643049C(a1, &v17, v16, a2, v13, a1 + 1440, 1u, 1);
}

void sub_1B642D61C(uint64_t a1, uint64_t a2, uint64_t (*a3)(void), uint64_t a4, uint64_t a5)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  float v9 = sub_1B6447C0C(*(void *)(a1 + 8));
  int v10 = v9 > 1.0;
  if (*(void *)a2)
  {
    if (*(unsigned __int8 *)(a2 + 24) == v10) {
      return;
    }
    CFRelease(*(CFTypeRef *)a2);
    *(void *)a2 = 0;
  }
  uint64_t v63 = 0;
  long long v61 = *MEMORY[0x1E4F1DB30];
  *(_OWORD *)uint64_t v62 = v61;
  if (a4)
  {
    uint64_t v11 = *(void **)(a2 + 56);
    if (v11) {
      free(v11);
    }
    (*(void (**)(uint64_t, uint64_t *, double *, uint64_t))(a4 + 16))(a4, &v63, v62, a2 + 56);
    if (!v63)
    {
      *(void *)(a2 + 56) = 0;
      *(_OWORD *)uint64_t v62 = v61;
    }
  }
  uint64_t v12 = (const __CTFont *)a3();
  MEMORY[0x1F4188790](Length, v14);
  unint64_t v15 = (2 * Length + 15) & 0xFFFFFFFFFFFFFFF0;
  v67.location = 0;
  v67.length = Length;
    v67,
    (UniChar *)((char *)&v62[-2] - v15));
  MEMORY[0x1F4188790](v16, v17);
  BOOL GlyphsForCharacters = CTFontGetGlyphsForCharacters(v12, (const UniChar *)((char *)&v62[-2] - v15), (CGGlyph *)((char *)&v62[-2] - v15), Length);
  MEMORY[0x1F4188790](GlyphsForCharacters, v19);
  int8x16_t v20 = (CGSize *)&v62[-2 * Length - 2];
  CTFontGetAdvancesForGlyphs(v12, kCTFontOrientationHorizontal, (const CGGlyph *)((char *)&v62[-2] - v15), v20, Length);
  *(void *)(a2 + 40) = malloc_type_realloc(*(void **)(a2 + 40), 4 * Length, 0x100004052888210uLL);
  *(_WORD *)(a2 + 36) = 0;
  CGRect BoundingBox = CTFontGetBoundingBox(v12);
  *(_WORD *)(a2 + 48) = vcvtpd_s64_f64(BoundingBox.size.height);
  if (Length >= 1)
  {
    int8x16_t v21 = *(float **)(a2 + 40);
    LOWORD(v22) = *(_WORD *)(a2 + 36);
    CFIndex v23 = Length;
    do
    {
      double width = v20->width;
      ++v20;
      float v25 = width;
      *v21++ = v25;
      double v26 = ceil(width);
      if (v26 <= (double)(__int16)v22) {
        double v26 = (double)(__int16)v22;
      }
      int v22 = (int)v26;
      --v23;
    }
    while (v23);
    *(_WORD *)(a2 + 36) = v22;
  }
  double Descent = CTFontGetDescent(v12);
  double Ascent = CTFontGetAscent(v12);
  double v29 = Ascent + CTFontGetDescent(v12);
  float v30 = v29 + CTFontGetLeading(v12);
  *(float *)(a2 + 32) = v30;
  MEMORY[0x1F4188790](v31, v32);
  uint64_t v33 = *(__int16 *)(a2 + 36);
  if (Length > 0)
  {
    uint64_t v34 = 0;
    float v35 = Descent;
    double v36 = v35;
    int v37 = &v62[-2 * Length - 1];
    CFIndex v38 = Length;
    do
    {
      *(v37 - 1) = (double)v34;
      *int v37 = v36;
      v37 += 2;
      v34 += v33;
      --v38;
    }
    while (v38);
  }
  float v39 = ceil(v62[0]) + (float)((float)(int)v33 + (float)(Length * v33));
  double v40 = (double)*(__int16 *)(a2 + 48);
  double v41 = ceil(v62[1]);
  if (v41 > v40) {
    double v40 = v41;
  }
  float v42 = v40;
  double v43 = v42;
  *(double *)(a2 + 8) = v39;
  *(double *)(a2 + 16) = v42;
  *(unsigned char *)(a2 + 24) = v10;
  float v44 = v9 * v42;
  size_t v45 = vcvtms_u32_f32(v9 * v42);
  int v46 = (CGColorSpace *)sub_1B63C93CC();
  CGContextRef v47 = CGBitmapContextCreate(0, vcvtms_u32_f32(v9 * v39), v45, 8uLL, vcvts_n_u32_f32(floorf(v9 * v39), 2uLL), v46, 0x4001u);
  if (v47)
  {
    float32x4_t v54 = v47;
    float32x4_t v55 = (CGColorSpace *)sub_1B63C93CC();
    CGContextSetFillColorSpace(v54, v55);
    *(_OWORD *)components = xmmword_1B6E50798;
    long long v65 = unk_1B6E507A8;
    CGContextSetFillColor(v54, components);
    CGContextTranslateCTM(v54, 0.0, floorf(v44));
    CGContextScaleCTM(v54, v9, (float)-v9);
    CTFontDrawGlyphs(v12, (const CGGlyph *)((char *)&v62[-2] - v15), (const CGPoint *)&v62[-2 * Length - 2], Length, v54);
    int v56 = *(__int16 *)(a2 + 36);
    v69.origin.x = (float)(v39 - (float)v56);
    v69.size.double width = (double)v56;
    v69.size.height = (double)*(__int16 *)(a2 + 48);
    v69.origin.y = 0.0;
    CGContextFillRect(v54, v69);
    if (a5)
    {
      uint64_t v57 = v63;
      if (v63)
      {
        uint64_t v58 = Length * *(__int16 *)(a2 + 36);
        if (v63 >= 1)
        {
          uint64_t v59 = *(float **)(a2 + 56);
          do
          {
            *uint64_t v59 = *v59 + (float)v58;
            v59 += 4;
            --v57;
          }
          while (v57);
        }
        CGContextTranslateCTM(v54, (double)v58, 0.0);
        UIGraphicsPushContext(v54);
        (*(void (**)(uint64_t, double, double))(a5 + 16))(a5, v39, v43);
        UIGraphicsPopContext();
      }
    }
    Image = CGBitmapContextCreateImage(v54);
    *(void *)a2 = sub_1B643AD04(Image);
    CFRelease(Image);
    CFRelease(v54);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: Unable to create context", v48, v49, v50, v51, v52, v53, v61);
  }
}

uint64_t sub_1B642DAE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_monospacedSystemFontOfSize_weight_(MEMORY[0x1E4FB1798], a2, a3, a4, 11.0, *MEMORY[0x1E4FB29C8]);
}

void sub_1B642DAFC(uint64_t a1, uint64_t *a2, const __CFString *a3, float64x2_t a4, float64_t a5, float a6)
{
  a4.f64[1] = a5;
  float32x2_t v20 = vcvt_f32_f64(vaddq_f64(a4, (float64x2_t)xmmword_1B6E504F0));
  double v10 = nullsub_1(a1);
  long long v22 = xmmword_1B6E505A0;
  sub_1B642A58C(a1, *a2, a2[1], (float *)&v22, a1 + 72, 1, v11, v12, *(float *)&v10, v13, v14, v15);
  float32x2_t v23 = v20;
  sub_1B643049C(a1, &v23, (uint64_t *)&xmmword_1B6E50720, a3, a1 + 72, a1 + 1440, 1u, 1);
  if (a6 > 0.000001)
  {
    v18.i32[1] = v20.i32[1];
    v18.f32[0] = v20.f32[0] + 90.0;
    float32x2_t v21 = v18;
    CFStringRef v19 = (const __CFString *)objc_msgSend_stringWithFormat_(NSString, v16, @"%2.1fms", v17, (float)(a6 * 1000.0));
    float32x2_t v23 = v21;
    sub_1B643049C(a1, &v23, (uint64_t *)&xmmword_1B6E50720, v19, a1 + 72, a1 + 1440, 1u, 1);
  }
}

void sub_1B642DC68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v9 = (void *)sub_1B6445900(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
  __n128 v201 = sub_1B64479C4((__n128 *)*(void *)(a1 + 8));
  float v10 = sub_1B6447C0C(*(void *)(a1 + 8));
  objc_msgSend_pushDebugGroup_(v9, v11, @"VFX - Draw Statistics", v12);
  __n128 v204 = sub_1B64479F4((__n128 *)*(void *)(a1 + 8));
  sub_1B6429E7C((uint64_t *)a1, a1 + 72, v13, v14, v15, v16, v17, v18);
  sub_1B6429E7C((uint64_t *)a1, a1 + 224, v19, v20, v21, v22, v23, v24);
  v209[0] = 0;
  v209[1] = v209;
  v209[2] = 0x3052000000;
  v209[3] = sub_1B642ED2C;
  v209[4] = sub_1B642ED3C;
  v209[5] = 0;
  v208[0] = MEMORY[0x1E4F143A8];
  v208[1] = 3221225472;
  v208[2] = sub_1B642ED48;
  v208[3] = &unk_1E6141E00;
  v208[4] = v209;
  v207[0] = MEMORY[0x1E4F143A8];
  v207[1] = 3221225472;
  v207[2] = sub_1B642EF2C;
  v207[3] = &unk_1E6141E28;
  v207[4] = v209;
  sub_1B642D61C(a1, a1 + 1504, (uint64_t (*)(void))sub_1B642F068, (uint64_t)v208, (uint64_t)v207);
  sub_1B642D61C(a1, a1 + 1440, (uint64_t (*)(void))sub_1B642DAE0, 0, 0);
  CFTypeRef v25 = *(CFTypeRef *)(a1 + 104);
  CFTypeRef v26 = *(CFTypeRef *)(a1 + 1440);
  if (v25 != v26)
  {
    if (v25)
    {
      CFRelease(*(CFTypeRef *)(a1 + 104));
      *(void *)(a1 + 104) = 0;
      CFTypeRef v26 = *(CFTypeRef *)(a1 + 1440);
    }
    if (v26) {
      CFTypeRef v26 = CFRetain(v26);
    }
    *(void *)(a1 + 104) = v26;
  }
  float32x4_t v27 = *(const void **)(a1 + 112);
  if (v27)
  {
    CFRelease(v27);
    *(void *)(a1 + 112) = 0;
  }
  CFTypeRef v28 = *(CFTypeRef *)(a1 + 256);
  CFTypeRef v29 = *(CFTypeRef *)(a1 + 1504);
  if (v28 != v29)
  {
    if (v28)
    {
      CFRelease(*(CFTypeRef *)(a1 + 256));
      *(void *)(a1 + 256) = 0;
      CFTypeRef v29 = *(CFTypeRef *)(a1 + 1504);
    }
    if (v29) {
      CFTypeRef v29 = CFRetain(v29);
    }
    *(void *)(a1 + 256) = v29;
  }
  float v30 = *(const void **)(a1 + 264);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(a1 + 264) = 0;
  }
  if (*(unsigned char *)(a1 + 65881)) {
    float v31 = (float)(*(float *)(a1 + 1472) * 7.0) + 14.0;
  }
  else {
    float v31 = 0.0;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v37 = objc_msgSend_preferredFramesPerSecond(*(void **)(a1 + 16), v32, v33, v34);
    if (v37) {
      uint64_t v38 = v37;
    }
    else {
      uint64_t v38 = 60;
    }
  }
  else
  {
    uint64_t v38 = 60;
  }
  int v39 = *(unsigned __int8 *)(a1 + 65881);
  float v40 = v204.n128_f32[1] + v31;
  float v41 = v201.n128_f32[2] / v10;
  if (*(unsigned char *)(a1 + 65881))
  {
    long long v206 = xmmword_1B6E505A0;
    if (v41 < 400.0) {
      float v42 = 225.0;
    }
    else {
      float v42 = 280.0;
    }
    double v43 = *(double *)(a1 + 66064);
    double v44 = *(double *)(a1 + 66152);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v50 = objc_msgSend_preferredFramesPerSecond(*(void **)(a1 + 16), v45, v46, v47);
      if (v50) {
        uint64_t v38 = v50;
      }
      else {
        uint64_t v38 = 60;
      }
    }
    float v51 = v43 - v44;
    if ((float)(1.0 / (float)v38) <= v51) {
      float v52 = v43 - v44;
    }
    else {
      float v52 = 1.0 / (float)v38;
    }
    sub_1B642A58C(a1, 0x3E19999A3E19999ALL, 0x3F4000003E19999ALL, (float *)&v206, a1 + 72, 1, v48, v49, 0.0, 0.0, v41, v40);
    float v197 = v31;
    float v199 = v42;
    float v195 = v204.n128_f32[1] + v31;
    float v53 = v41;
    float32x2_t v193 = vadd_f32((float32x2_t)v204.n128_u64[0], (float32x2_t)vdup_n_s32(0x425C0000u));
    float64x2_t v54 = vcvtq_f64_f32(v193);
    long long v205 = xmmword_1B6E50580;
    double v55 = v54.f64[1];
    float v56 = 0.0;
    double v202 = v54.f64[0];
    sub_1B642F084(a1, (float *)&v205, a1 + 72, v54.f64[0], v54.f64[1], 0.0, 6.2832);
    float v59 = v204.n128_f32[0] + 110.0;
    double v60 = *(double *)(a1 + 66096);
    if (v60 >= 0.0)
    {
      float v56 = v60 * 6.28318531 / v52 + 0.0;
      long long v205 = xmmword_1B6E50500;
      sub_1B642F084(a1, (float *)&v205, a1 + 72, v202, v55, 0.0, v56);
      float v62 = v60;
      if (v53 < 400.0) {
        float v62 = 0.0;
      }
      v61.f64[0] = v59;
      sub_1B642DAFC(a1, (uint64_t *)&v205, @"Animations", v61, (float)(v204.n128_f32[1] + 80.0), v62);
    }
    double v63 = *(double *)(a1 + 66080);
    if (v63 >= 0.0)
    {
      float v64 = v63 * 6.28318531 / v52 + v56;
      long long v205 = xmmword_1B6E50510;
      sub_1B642F084(a1, (float *)&v205, a1 + 72, v202, v55, v56, v64);
      float v66 = v63;
      if (v53 < 400.0) {
        float v66 = 0.0;
      }
      v65.f64[0] = v59;
      sub_1B642DAFC(a1, (uint64_t *)&v205, @"Physics", v65, (float)(v204.n128_f32[1] + 60.0), v66);
    }
    else
    {
      float v64 = v56;
    }
    double v67 = *(double *)(a1 + 66072);
    if (v67 >= 0.0)
    {
      float v68 = v67 * 6.28318531 / v52 + v64;
      long long v205 = xmmword_1B6E50520;
      sub_1B642F084(a1, (float *)&v205, a1 + 72, v202, v55, v64, v68);
      float v70 = v67;
      if (v53 < 400.0) {
        float v70 = 0.0;
      }
      v69.f64[0] = v59;
      sub_1B642DAFC(a1, (uint64_t *)&v205, @"Constraints", v69, (float)(v204.n128_f32[1] + 40.0), v70);
    }
    else
    {
      float v68 = v64;
    }
    float v71 = v199 + v204.n128_f32[0];
    double v72 = *(double *)(a1 + 66136);
    if (v72 >= 0.0)
    {
      float v73 = v72 * 6.28318531 / v52 + v68;
      long long v205 = xmmword_1B6E50530;
      sub_1B642F084(a1, (float *)&v205, a1 + 72, v202, v55, v68, v73);
      float v75 = v72;
      if (v53 < 400.0) {
        float v75 = 0.0;
      }
      v74.f64[0] = v71;
      sub_1B642DAFC(a1, (uint64_t *)&v205, @"Delegate", v74, (float)(v204.n128_f32[1] + 80.0), v75);
    }
    else
    {
      float v73 = v68;
    }
    double v76 = *(double *)(a1 + 66120);
    if (v76 >= 0.0)
    {
      float v77 = v76 * 6.28318531 / v52 + v73;
      long long v205 = xmmword_1B6E50540;
      sub_1B642F084(a1, (float *)&v205, a1 + 72, v202, v55, v73, v77);
      float v79 = v76;
      if (v53 < 400.0) {
        float v79 = 0.0;
      }
      v78.f64[0] = v71;
      sub_1B642DAFC(a1, (uint64_t *)&v205, @"Rendering", v78, (float)(v204.n128_f32[1] + 60.0), v79);
    }
    else
    {
      float v77 = v73;
    }
    double v80 = *(double *)(a1 + 66168);
    if (v80 >= 0.0)
    {
      v81.f64[1] = 0.00781250185;
      long long v205 = xmmword_1B6E50550;
      float v82 = v80;
      if (v53 < 400.0) {
        float v82 = 0.0;
      }
      v81.f64[0] = v71;
      sub_1B642DAFC(a1, (uint64_t *)&v205, @"GPU", v81, (float)(v204.n128_f32[1] + 40.0), v82);
    }
    double v83 = *(double *)(a1 + 66128);
    if (v83 >= 0.0)
    {
      float v84 = v83 * 6.28318531 / v52 + v77;
      long long v205 = xmmword_1B6E50560;
      sub_1B642F084(a1, (float *)&v205, a1 + 72, v202, v55, v77, v84);
      float v86 = v83;
      if (v53 < 400.0) {
        float v86 = 0.0;
      }
      v85.f64[0] = v71;
      sub_1B642DAFC(a1, (uint64_t *)&v205, @"2D", v85, (float)(v204.n128_f32[1] + 20.0), v86);
    }
    double v87 = *(double *)(a1 + 66064) - fmax(*(double *)(a1 + 66152), 0.0);
    if (v87 < 0.0 || v87 >= 100.0)
    {
      uint64_t v91 = (__CFString *)objc_msgSend_stringWithFormat_(NSString, v57, @"--- ms", v58);
      float v41 = v53;
      float v40 = v195;
      float v31 = v197;
    }
    else
    {
      float v88 = v87;
      double v89 = v88;
      if (v87 >= 0.1) {
        uint64_t v90 = @"%2.1f s";
      }
      else {
        uint64_t v90 = @"%2.1f ms";
      }
      if (v87 >= 0.1) {
        uint64_t v91 = (__CFString *)objc_msgSend_stringWithFormat_(NSString, v57, (uint64_t)v90, v58, *(void *)&v89);
      }
      else {
        uint64_t v91 = (__CFString *)objc_msgSend_stringWithFormat_(NSString, v57, (uint64_t)v90, v58, v89 * 1000.0);
      }
      float v41 = v53;
      float v40 = v195;
      float v31 = v197;
    }
    CFStringRef v95 = v91;
    unint64_t v96 = objc_msgSend_length(v91, v92, v93, v94);
    int8x8_t v97 = (int8x8_t)vadd_f32(v193, (float32x2_t)0xC0C00000C1C80000);
    v98.i32[1] = v97.i32[1];
    *(float *)v98.i32 = *(float *)v97.i32 + 5.0;
    v210[0] = vbsl_s8((int8x8_t)vcgtd_u64(7uLL, v96), v98, v97);
    sub_1B643049C(a1, v210, (uint64_t *)&xmmword_1B6E50720, v95, a1 + 224, a1 + 1504, 1u, 1);
    int v39 = *(unsigned __int8 *)(a1 + 65881);
  }
  float v99 = *(float *)(a1 + 1472) + 6.0;
  if (v39) {
    float v100 = v40;
  }
  else {
    float v100 = 0.0;
  }
  if (v39) {
    float v101 = v40;
  }
  else {
    float v101 = v204.n128_f32[1];
  }
  float v102 = v101 + v99;
  long long v206 = xmmword_1B6E505A0;
  sub_1B642A58C(a1, 0, 0x3F40000000000000, (float *)&v206, a1 + 224, 1, v35, v36, 0.0, v100, v41, v101 + v99);
  *(void *)&long long v205 = 0;
  sub_1B643049C(0, &v205, 0, @"$1$", 0, a1 + 1504, 0, 0);
  __asm { FMOV            V1.2S, #7.0 }
  _D1.f32[1] = v31 + 3.0;
  float32x2_t v108 = vadd_f32((float32x2_t)v204.n128_u64[0], _D1);
  float v200 = *(float *)&v205;
  float32x2_t v203 = v108;
  if (*(unsigned char *)(a1 + 65881)) {
    CFStringRef v109 = @"$1$";
  }
  else {
    CFStringRef v109 = @"$0$";
  }
  if (*(void *)(a1 + 65896)) {
    uint64_t v110 = (uint64_t *)&xmmword_1B6E50720;
  }
  else {
    uint64_t v110 = (uint64_t *)&unk_1B6E50590;
  }
  *(float32x2_t *)&long long v205 = v108;
  sub_1B643049C(a1, &v205, v110, v109, a1 + 224, a1 + 1504, 1u, 1);
  float v111 = *(float *)(a1 + 65888);
  if ((float)(*(float *)(a1 + 65884) / (float)v38) <= 1.0) {
    float v112 = *(float *)(a1 + 65884) / (float)v38;
  }
  else {
    float v112 = 1.0;
  }
  if (v111 * 60.0 <= 1.0) {
    double v113 = v111 * 60.0;
  }
  else {
    double v113 = 1.0;
  }
  *(float *)&unsigned int v114 = v112 * 0.33;
  unint64_t v115 = sub_1B63C904C(v114 | 0x3F80000000000000, 1065353216);
  uint64_t v119 = v115;
  uint64_t v120 = v116;
  double v190 = v113;
  float v189 = v41;
  float v121 = ceilf(v203.f32[0] + (float)(v200 + 5.0));
  uint64_t v122 = 0x3F8000003F000000;
  uint64_t v123 = 0x3F0000003F000000;
  float v124 = (float)(v102 - v99) + (float)(v99 + -10.0) * 0.5;
  float32x4_t v125 = *(float **)(a1 + 1560);
  float v126 = v125[8];
  *(void *)&long long v205 = 0;
  DWORD2(v205) = 0;
  float v127 = v125[10];
  float v128 = v125[11] / *(double *)(a1 + 1520);
  *((float *)&v205 + 3) = v128;
  float v191 = v126;
  double v129 = v126;
  double v130 = *(double *)(a1 + 1512);
  float v131 = v126 / v130;
  *(float *)&long long v205 = v131;
  float v198 = v127;
  if (v112 >= 0.083333)
  {
    double v133 = v127;
    float v132 = v121;
    uint64_t v137 = v115;
    uint64_t v138 = v120;
  }
  else
  {
    float v132 = v121 + (float)(v112 * 60.0);
    double v133 = v127;
    double v134 = v129 + (float)(v112 / 0.083333) * (v127 * 0.5);
    float v135 = v134 / v130;
    *((float *)&v205 + 2) = v135;
    sub_1B642A58C(a1, v115, v116, (float *)&v205, a1 + 224, 1, v117, v118, v121, v124, v132, v124 + 10.0);
    double v130 = *(double *)(a1 + 1512);
    float v136 = v134 / v130;
    *(float *)&long long v205 = v136;
    uint64_t v137 = 0x3F0000003F000000;
    uint64_t v138 = 0x3F8000003F000000;
  }
  float v139 = (v129 + v133 * 0.5) / v130;
  *((float *)&v205 + 2) = v139;
  float v194 = v121 + 5.0;
  sub_1B642A58C(a1, v137, v138, (float *)&v205, a1 + 224, 1, v117, v118, v132, v124, v121 + 5.0, v124 + 10.0);
  LODWORD(v205) = 1065351538;
  DWORD2(v205) = 1065353216;
  if (v112 <= 0.083333 || v112 >= 0.91667)
  {
    if (v112 >= 0.91667)
    {
      uint64_t v122 = v120;
      uint64_t v123 = v119;
    }
    float v142 = v121 + 5.0;
  }
  else
  {
    float v142 = (float)(v121 + (float)(v112 * 60.0)) + -5.0;
    sub_1B642A58C(a1, v119, v120, (float *)&v205, a1 + 224, 1, v140, v141, v194, v124, v142, v124 + 10.0);
  }
  float v196 = v121 + 60.0;
  float v192 = (float)(v121 + 60.0) + -5.0;
  sub_1B642A58C(a1, v123, v122, (float *)&v205, a1 + 224, 1, v140, v141, v142, v124, v192, v124 + 10.0);
  if (v112 <= 0.91667)
  {
    float v152 = v198;
    double v150 = *(double *)(a1 + 1512);
    double v151 = (v129 + v198 * 0.5) / v150;
    float v145 = (float)(v121 + 60.0) + -5.0;
  }
  else
  {
    float v145 = v121 + (float)(v112 * 60.0);
    double v146 = *(double *)(a1 + 1512);
    float v147 = (v129 + v198 * 0.5) / v146;
    double v148 = v129 + ((float)(v112 + -0.91667) / 0.0833333135 + 1.0) * v198 * 0.5;
    float v149 = v148 / v146;
    *(float *)&long long v205 = v147;
    *((float *)&v205 + 2) = v149;
    sub_1B642A58C(a1, v119, v120, (float *)&v205, a1 + 224, 1, v143, v144, v192, v124, v145, v124 + 10.0);
    double v150 = *(double *)(a1 + 1512);
    double v151 = v148 / v150;
    float v152 = v198;
  }
  float v153 = v151;
  float v154 = (float)(v191 + v152) / v150;
  *(float *)&long long v205 = v153;
  *((float *)&v205 + 2) = v154;
  sub_1B642A58C(a1, 0x3F0000003F000000, 0x3F8000003F000000, (float *)&v205, a1 + 224, 1, v143, v144, v145, v124, v196, v124 + 10.0);
  float v157 = v190;
  double v158 = *(double *)(a1 + 1512);
  float v159 = v129 / v158;
  *((float *)&v205 + 3) = *((float *)&v205 + 3) * 0.25;
  *(float *)&long long v205 = v159;
  if (v157 >= 0.083333)
  {
    double v161 = v129 + v198 * 0.5;
    float v160 = v121 + 5.0;
  }
  else
  {
    float v160 = v121 + (float)(v157 * 60.0);
    double v161 = v129 + (float)(v157 / 0.083333) * (v198 * 0.5);
  }
  float v162 = v161 / v158;
  *((float *)&v205 + 2) = v162;
  sub_1B642A58C(a1, 0x3F00000000000000, 0x3F8000003F800000, (float *)&v205, a1 + 224, 1, v155, v156, v121, v124, v160, v124 + 2.5);
  if (v157 <= 0.083333 || v157 >= 0.91667)
  {
    float v165 = v121 + 60.0;
    if (v157 <= 0.91667) {
      goto LABEL_117;
    }
  }
  else
  {
    float v165 = v121 + (float)(v157 * 60.0);
  }
  LODWORD(v205) = 1065351538;
  DWORD2(v205) = 1065353216;
  sub_1B642A58C(a1, 0x3F00000000000000, 0x3F8000003F800000, (float *)&v205, a1 + 224, 1, v163, v164, v194, v124, v165 + -5.0, v124 + 2.5);
LABEL_117:
  if (v157 > 0.91667)
  {
    double v166 = *(double *)(a1 + 1512);
    float v167 = (v129 + v198 * 0.5) / v166;
    float v168 = (v129 + ((float)(v157 + -0.91667) / 0.0833333135 + 1.0) * v198 * 0.5) / v166;
    *(float *)&long long v205 = v167;
    *((float *)&v205 + 2) = v168;
    sub_1B642A58C(a1, 0x3F00000000000000, 0x3F8000003F800000, (float *)&v205, a1 + 224, 1, v163, v164, v192, v124, v121 + (float)(v157 * 60.0), v124 + 2.5);
  }
  HIDWORD(v169) = v203.i32[1];
  *(float *)&uint64_t v169 = v196 + 7.0;
  CFStringRef v170 = *(const __CFString **)(a1 + 65904);
  v210[0] = v169;
  sub_1B643049C(a1, v210, (uint64_t *)&xmmword_1B6E50720, v170, a1 + 224, a1 + 1504, 1u, 1);
  CFStringRef v171 = *(const __CFString **)(a1 + 65912);
  v210[0] = 0;
  sub_1B643049C(0, v210, 0, v171, 0, a1 + 1504, 0, 0);
  HIDWORD(v172) = v203.i32[1];
  *(float *)&uint64_t v172 = ceilf((float)(v189 + -7.0) - *(float *)v210) - v204.n128_f32[2];
  CFStringRef v173 = *(const __CFString **)(a1 + 65912);
  v210[0] = v172;
  sub_1B643049C(a1, v210, (uint64_t *)&xmmword_1B6E50720, v173, a1 + 224, a1 + 1504, 1u, 1);
  sub_1B64296C4(a1, a1 + 224, v174, v175, v176, v177, v178, v179);
  sub_1B64296C4(a1, a1 + 72, v180, v181, v182, v183, v184, v185);
  *(unsigned char *)(a1 + 65880) = 1;
  if (v9) {
    objc_msgSend_popDebugGroup(v9, v186, v187, v188);
  }
  _Block_object_dispose(v209, 8);
}

void sub_1B642ECE4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_1B642ED2C(uint64_t a1, uint64_t a2)
{
}

void sub_1B642ED3C(uint64_t a1)
{
}

uint64_t sub_1B642ED48(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4)
{
  v25[2] = *MEMORY[0x1E4F143B8];
  *a2 = 7;
  uint64_t v7 = (char *)malloc_type_malloc(0x70uLL, 0x1000040451B5BE8uLL);
  *a4 = (uint64_t)v7;
  *(_DWORD *)uint64_t v7 = 0;
  *(_OWORD *)(v7 + 4) = xmmword_1B6E50570;
  *((_DWORD *)v7 + 7) = 1098907648;
  *(void *)(v7 + 20) = 0x4180000000000000;
  float v8 = (float)(*((float *)v7 + 4) + *((float *)v7 + 6)) + 1.0;
  *((float *)v7 + 8) = v8;
  *(void *)(v7 + 36) = 0x4120000000000000;
  *((_DWORD *)v7 + 11) = 1092616192;
  float v9 = v8 + 10.0;
  uint64_t v13 = objc_msgSend_monospacedSystemFontOfSize_weight_(MEMORY[0x1E4FB1798], v10, v11, v12, 11.0, *MEMORY[0x1E4FB29C8]);
  uint64_t v14 = *MEMORY[0x1E4FB12B8];
  v24[0] = *MEMORY[0x1E4FB12B0];
  v24[1] = v14;
  v25[0] = v13;
  v25[1] = objc_msgSend_whiteColor(MEMORY[0x1E4FB1618], v15, v16, v17);
  uint64_t result = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v18, (uint64_t)v25, (uint64_t)v24, 2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  uint64_t v20 = *a4;
  *(float *)(v20 + 48) = v9 + 1.0;
  *(void *)(v20 + 52) = 0x40D3EC00BF800000;
  *(_DWORD *)(v20 + 60) = 1095761920;
  float v21 = (float)(v9 + 1.0) + 6.6226;
  *(float *)(v20 + 64) = v21;
  *(void *)(v20 + 68) = 0x40D99800BF800000;
  *(_DWORD *)(v20 + 76) = 1095761920;
  float v22 = v21 + 6.7998;
  *(float *)(v20 + 80) = v22;
  *(void *)(v20 + 84) = 0x40D99800C0400000;
  *(_DWORD *)(v20 + 92) = 1095761920;
  float v23 = v22 + 6.7998;
  *(float *)(v20 + 96) = v23;
  *(void *)(v20 + 100) = 0x40D3EC00BF800000;
  *(_DWORD *)(v20 + 108) = 1095761920;
  *(double *)a3 = (float)((float)(v23 + 6.6226) + 32.0);
  *(void *)(a3 + 8) = 0x4030000000000000;
  return result;
}

void sub_1B642EF2C(uint64_t a1, double a2, double a3)
{
  id v5 = objc_alloc(MEMORY[0x1E4F28B18]);
  uint64_t v7 = objc_msgSend_initWithString_attributes_(v5, v6, @"+", *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
  objc_msgSend_drawAtPoint_(v7, v8, v9, v10, 0.0, 0.0);

  id v11 = objc_alloc(MEMORY[0x1E4F28B18]);
  uint64_t v13 = objc_msgSend_initWithString_attributes_(v11, v12, @"-", *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
  objc_msgSend_drawAtPoint_(v13, v14, v15, v16, 16.0, 0.0);

  uint64_t v20 = objc_msgSend_bezierPathWithOvalInRect_(MEMORY[0x1E4FB14C0], v17, v18, v19, 33.0, 0.0, 10.0, 10.0);
  objc_msgSend_fill(v20, v21, v22, v23);
  CurrentContext = UIGraphicsGetCurrentContext();
  CGContextScaleCTM(CurrentContext, 1.0, -1.0);
  CGContextTranslateCTM(CurrentContext, 0.0, 4.0 - a3);
  id v25 = objc_alloc(MEMORY[0x1E4F28B18]);
  id v30 = (id)objc_msgSend_initWithString_attributes_(v25, v26, @".", *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
  objc_msgSend_drawAtPoint_(v30, v27, v28, v29, 44.0, 0.0);
}

uint64_t sub_1B642F068(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_monospacedSystemFontOfSize_weight_(MEMORY[0x1E4FB1798], a2, a3, a4, 11.0, *MEMORY[0x1E4FB29A8]);
}

void sub_1B642F084(uint64_t a1, float *a2, uint64_t a3, double a4, double a5, float a6, float a7)
{
  float v10 = a2[2];
  float v11 = a2[3];
  float v12 = *a2;
  float v13 = a2[1];
  float v14 = a7 - a6;
  int v15 = (int)fmax((float)(a7 - a6) / 6.28318531 * 100.0, 1.0);
  int v41 = 2 * v15 + 2;
  uint64_t v16 = (char *)malloc_type_malloc(20 * v41, 0x1000040A86A77D5uLL);
  uint64_t v40 = (6 * v15);
  uint64_t v18 = malloc_type_malloc(12 * v15, 0x1000040BDFB0063uLL);
  if ((v15 & 0x80000000) == 0)
  {
    __int16 v19 = 0;
    int v20 = 0;
    uint64_t v21 = 0;
    int v22 = ((int)(float)(v11 * 255.0) << 24) | ((int)(float)(fminf(fmaxf(v10, 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(v13, 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(v12, 0.0), 1.0) * 255.0);
    float v23 = v14 / (float)v15;
    float v24 = 1.57079633 - a6;
    unsigned int v25 = v15 + 1;
    uint64_t v26 = 6 * v15;
    uint64_t v27 = 6 * v25;
    uint64_t v28 = (float *)(v16 + 20);
    int32x2_t v29 = vdup_n_s32(0x3F7FBE77u);
    __asm { FMOV            V14.2S, #1.0 }
    do
    {
      __float2 v35 = __sincosf_stret(v24 - (float)((float)v20 * v23));
      float v36 = a4 + (float)(v35.__cosval * 40.0);
      float v37 = a5 + (float)(v35.__sinval * 40.0);
      float v38 = a4 + (float)(v35.__cosval * 30.0);
      *(v28 - 5) = v36;
      *(v28 - 4) = v37;
      *((_DWORD *)v28 - 1) = v22;
      *(void *)(v28 - 3) = _D14;
      float v39 = a5 + (float)(v35.__sinval * 30.0);
      *uint64_t v28 = v38;
      v28[1] = v39;
      *((_DWORD *)v28 + 4) = v22;
      *((int32x2_t *)v28 + 1) = v29;
      if (v26 != v21)
      {
        v18[v21] = v19;
        v18[(v21 + 1)] = v19 + 2;
        v18[(v21 + 2)] = v19 + 1;
        v18[(v21 + 3)] = v19 + 1;
        v18[(v21 + 4)] = v19 + 2;
        v18[(v21 + 5)] = v19 + 3;
      }
      v21 += 6;
      ++v20;
      v19 += 2;
      v28 += 10;
    }
    while (v27 != v21);
  }
  sub_1B6429158(a1, (uint64_t)v16, v41, (uint64_t)v18, v40, a3, 1, v17, v40);
  free(v18);

  free(v16);
}

char *sub_1B642F328(char *result, const void *a2, unsigned int a3)
{
  if (a3 <= 9) {
    return (char *)memcpy(result + 65928, a2, 4 * a3);
  }
  return result;
}

void sub_1B642F344(uint64_t a1, double *__src, uint64_t a3)
{
  if (a1)
  {
    uint64_t v6 = a1 + 65768;
    uint64_t v7 = *(const void **)(a1 + 65920);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(v6 + 152) = 0;
    }
    float v8 = *(const void **)(v6 + 144);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(v6 + 144) = 0;
    }
    uint64_t v9 = *(const void **)(v6 + 136);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(v6 + 136) = 0;
    }
    if (*((_DWORD *)__src + 4))
    {
      memcpy((void *)(a1 + 65968), __src, 0x358uLL);
      if (a3)
      {
        long long v10 = *(_OWORD *)(a3 + 216);
        long long v11 = *(_OWORD *)(a3 + 248);
        *(_OWORD *)(a1 + 66200) = *(_OWORD *)(a3 + 232);
        *(_OWORD *)(a1 + 66216) = v11;
        *(_OWORD *)(a1 + 66184) = v10;
        long long v12 = *(_OWORD *)(a3 + 264);
        long long v13 = *(_OWORD *)(a3 + 280);
        long long v14 = *(_OWORD *)(a3 + 296);
        *(void *)(a1 + 66280) = *(void *)(a3 + 312);
        *(_OWORD *)(a1 + 66248) = v13;
        *(_OWORD *)(a1 + 66264) = v14;
        *(_OWORD *)(a1 + 66232) = v12;
      }
      double v15 = __src[41];
      float v16 = 0.0;
      if (v15 != 0.0) {
        float v16 = 1.0 / v15;
      }
      float v17 = __src[23];
      *(float *)(v6 + 116) = v16;
      *(float *)(v6 + 120) = v17;
      uint64_t v18 = sub_1B642F520(*((unsigned int *)__src + 2));
      __int16 v19 = sub_1B642F520(*((unsigned int *)__src + 1));
      int v20 = sub_1B642F520(*(unsigned int *)__src);
      if (*(_DWORD *)(v6 + 160))
      {
        BOOL v21 = 1;
      }
      else
      {
        unint64_t v22 = 0;
        do
        {
          unint64_t v23 = v22;
          if (v22 == 8) {
            break;
          }
        }
        while (!*(_DWORD *)(a1 + 65932 + 4 * v22++));
        BOOL v21 = v23 < 8;
      }
      *(unsigned char *)uint64_t v6 = *(unsigned char *)v6 & 0xFE | v21;
      CFAllocatorRef v25 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      *(void *)(v6 + 144) = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"$3$%@ $4$%@", v18, v19);
      CFRelease(v18);
      CFRelease(v19);
      CFRelease(v20);
      sub_1B6445900(*(void *)(a1 + 8), v26, v27, v28, v29, v30, v31, v32);
      LODWORD(v33) = llroundf(*(float *)(v6 + 116));
      *(void *)(v6 + 136) = CFStringCreateWithFormat(v25, 0, @"%dfps", v33);
    }
  }
}

__CFString *sub_1B642F520(unint64_t a1)
{
  if (!a1) {
    return @"0";
  }
  if (a1 <= 0x3E7) {
    return (__CFString *)CFStringCreateWithFormat(0, 0, @"%zu", a1);
  }
  double v2 = (double)a1;
  float v3 = (double)a1 / 1000.0;
  if (v3 < 1000.0) {
    return (__CFString *)CFStringCreateWithFormat(0, 0, @"%.3gK", v3);
  }
  float v4 = v2 / 1000000.0;
  if (v4 < 1000.0) {
    return (__CFString *)CFStringCreateWithFormat(0, 0, @"%.3gM", v4);
  }
  float v5 = v2 / 1000000000.0;
  return (__CFString *)CFStringCreateWithFormat(0, 0, @"%.3gG", v5);
}

uint64_t sub_1B642F620(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    long long v10 = (void *)result;
    uint64_t v11 = sub_1B64B2864(a2, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v19 = sub_1B64B20C4(a2, v12, v13, v14, v15, v16, v17, v18);
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v10, v20, (uint64_t)&v30, (uint64_t)v34, 16);
    if (result)
    {
      uint64_t v24 = result;
      uint64_t v25 = *(void *)v31;
      do
      {
        uint64_t v26 = 0;
        do
        {
          if (*(void *)v31 != v25) {
            objc_enumerationMutation(v10);
          }
          uint64_t v27 = *(void **)(*((void *)&v30 + 1) + 8 * v26);
          if (objc_msgSend_forceField(v27, v21, v22, v23))
          {
            uint64_t v28 = (const void *)objc_msgSend_nodeRef(v27, v21, v22, v23);
            CFDictionaryRef v29 = sub_1B6454798(v11, v28);
            if (v29) {
              sub_1B6511930(v19, (uint64_t)v29, a3);
            }
          }
          ++v26;
        }
        while (v24 != v26);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v10, v21, (uint64_t)&v30, (uint64_t)v34, 16);
        uint64_t v24 = result;
      }
      while (result);
    }
  }
  return result;
}

void sub_1B642F8F8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B642F910(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  float v4 = a2;
  if (objc_msgSend_isAuthoring(a2, (const char *)a2, a3, a4)
    && objc_msgSend_authoringTargetNode(v4, v6, v7, v8))
  {
    float v4 = objc_msgSend_authoringTargetNode(v4, v6, v9, v8);
  }
  uint64_t v11 = objc_msgSend_nodeManipulatorItemWithNode_screenSize_(VFXNodeManipulableItem, v6, (uint64_t)v4, v8, 0.0);
  uint64_t v13 = *(void **)(a1 + 32);

  return objc_msgSend_addObject_(v13, v10, v11, v12);
}

BOOL sub_1B642F984(void *a1)
{
  objc_sync_enter(a1);
  float v5 = objc_msgSend_selectedNodes(a1, v2, v3, v4);
  BOOL v9 = objc_msgSend_count(v5, v6, v7, v8) != 0;
  objc_sync_exit(a1);
  return v9;
}

void sub_1B642F9C8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B642F9DC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_array(MEMORY[0x1E4F1CA48], a2, a3, a4);
  objc_sync_enter(a1);
  BOOL v9 = objc_msgSend_selectedNodes(a1, v6, v7, v8);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = sub_1B642FA94;
  v13[3] = &unk_1E6141E50;
  v13[4] = v5;
  objc_msgSend_enumerateObjectsUsingBlock_(v9, v10, (uint64_t)v13, v11);
  objc_sync_exit(a1);
  return v5;
}

void sub_1B642FA80(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B642FA94(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2;
  uint64_t v6 = objc_msgSend_authoringTargetNode(a2, (const char *)a2, a3, a4);
  long long v10 = *(void **)(a1 + 32);
  if (v6) {
    uint64_t v4 = objc_msgSend_authoringTargetNode(v4, v7, v8, v9);
  }
  uint64_t v12 = objc_msgSend_nodeRef(v4, v7, v8, v9);

  return objc_msgSend_addObject_(v10, v11, v12, v13);
}

void sub_1B642FF60(void *a1, uint64_t a2)
{
  sub_1B6429B70(a1, a2);
  uint64_t v3 = *(const void **)(a2 + 32);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a2 + 32) = 0;
  }
  uint64_t v4 = *(const void **)(a2 + 40);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 40) = 0;
  }

  uint64_t v5 = *(void **)(a2 + 144);
}

void sub_1B64300A8(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v62 = a1;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a4 + 48);
  if (*(unsigned char *)(a4 + 48)) {
    uint64_t v7 = 288;
  }
  else {
    uint64_t v7 = 432;
  }
  *(double *)v8.i64 = MEMORY[0x1F4188790](a1, a2);
  long long v10 = (char *)&v61 - v9;
  int v11 = 0;
  int v13 = ((int)(float)(v12[3] * 255.0) << 24) | ((int)(float)(fminf(fmaxf(v12[2], 0.0), 1.0) * 255.0) << 16) | ((int)(float)(fminf(fmaxf(v12[1], 0.0), 1.0) * 255.0) << 8) | (int)(float)(fminf(fmaxf(*v12, 0.0), 1.0) * 255.0);
  float32x4_t v65 = (float32x4_t)v8;
  float32x4_t v64 = (float32x4_t)vdupq_laneq_s32(v8, 3);
  uint64_t v14 = v66;
  do
  {
    float v15 = (double)++v11 * 3.14159265 * 0.25;
    __float2 v17 = __sincosf_stret(v15);
    *(float *)&uint64_t v16 = v17.__cosval;
    uint64_t v63 = v16;
    uint64_t v18 = 0;
    float v19 = 0.0;
    do
    {
      __float2 v20 = __sincosf_stret(v19);
      v21.f32[0] = v17.__sinval * v20.__cosval;
      v21.i32[1] = v63;
      v21.f32[2] = v17.__sinval * v20.__sinval;
      uint64_t v22 = &v14[v18];
      float32x4_t v23 = vmlaq_f32(v65, v21, v64);
      *(void *)uint64_t v22 = v23.i64[0];
      *(_DWORD *)&v14[v18 + 8] = v23.i32[2];
      *((_DWORD *)v22 + 3) = v13;
      float v19 = v19 + 0.2618;
      v18 += 16;
    }
    while (v18 != 384);
    v14 += 384;
  }
  while (v11 != 3);
  int v24 = 0;
  double v25 = 0.0;
  do
  {
    float v26 = v25 * 3.14159265 / 3.0;
    __float2 v27 = __sincosf_stret(v26);
    uint64_t v28 = 0;
    float v29 = 0.0;
    do
    {
      __float2 v31 = __sincosf_stret(v29);
      v32.f32[0] = v27.__cosval * v31.__cosval;
      v32.i32[1] = LODWORD(v31.__sinval);
      v32.f32[2] = v27.__sinval * v31.__cosval;
      long long v33 = &v14[v28];
      float32x4_t v34 = vmlaq_f32(v65, v32, v64);
      *(void *)long long v33 = v34.i64[0];
      *(_DWORD *)&v14[v28 + 8] = v34.i32[2];
      *((_DWORD *)v33 + 3) = v13;
      float v29 = v29 + 0.2618;
      v28 += 16;
    }
    while (v28 != 384);
    v14 += 384;
    double v25 = v25 + 1.0;
    ++v24;
  }
  while (v24 != 3);
  if (a2)
  {
    uint64_t v35 = 0;
    float32x4_t v36 = *a2;
    float32x4_t v37 = a2[1];
    float32x4_t v38 = a2[2];
    float32x4_t v39 = a2[3];
    do
    {
      uint64_t v40 = &v66[v35];
      float32x4_t v41 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(v39, v38, *(float *)&v66[v35 + 8]), v37, *(float *)&v66[v35 + 4]), v36, *(float *)&v66[v35]);
      *(void *)uint64_t v40 = v41.i64[0];
      *((_DWORD *)v40 + 2) = v41.i32[2];
      v35 += 16;
    }
    while (v35 != 2304);
  }
  int v42 = 0;
  unsigned int v43 = 0;
  if (v6)
  {
    v44.i64[0] = 0x100000001;
    v44.i64[1] = 0x100000001;
    v45.i64[0] = 0x1800000018;
    v45.i64[1] = 0x1800000018;
    v46.i64[0] = 0x800000008;
    v46.i64[1] = 0x800000008;
    uint64_t v47 = v10;
    do
    {
      uint64_t v48 = 0;
      int32x4_t v49 = vdupq_n_s32(v43);
      int32x4_t v50 = (int32x4_t)xmmword_1B6E4B1A0;
      int32x4_t v51 = (int32x4_t)xmmword_1B6E4B190;
      do
      {
        float v52 = (__int16 *)&v47[v48];
        v68.val[0] = vuzp1q_s16((int16x8_t)vaddq_s32(v50, v49), (int16x8_t)vaddq_s32(v51, v49));
        int8x16_t v53 = (int8x16_t)vaddq_s32(v51, v44);
        int8x16_t v54 = (int8x16_t)vaddq_s32(v50, v44);
        v68.val[1] = vuzp1q_s16((int16x8_t)vaddq_s32((int32x4_t)vbicq_s8(v54, (int8x16_t)vceqq_s32((int32x4_t)v54, v45)), v49), (int16x8_t)vaddq_s32((int32x4_t)vbicq_s8(v53, (int8x16_t)vceqq_s32((int32x4_t)v53, v45)), v49));
        vst2q_s16(v52, v68);
        int32x4_t v50 = vaddq_s32(v50, v46);
        int32x4_t v51 = vaddq_s32(v51, v46);
        v48 += 32;
      }
      while (v48 != 96);
      v43 += 24;
      ++v42;
      v47 += 96;
    }
    while (v42 != 6);
  }
  else
  {
    double v55 = v10;
    do
    {
      for (int i = 24; i != 48; ++i)
      {
        *double v55 = v43 + i - 24;
        int v57 = i - 23;
        if (i == 47) {
          int v57 = 0;
        }
        unsigned int v58 = v57 + v43;
        v55[1] = v58;
        float v59 = v55 + 3;
        v55[2] = i + v43 - 144 * ((v43 + i) / 0x90);
        if (v43 + i - 24 > 0x8F || v58 > 0x8F) {
          ++v43;
        }
        v55 += 3;
      }
      v43 += 24;
      ++v42;
      double v55 = v59;
    }
    while (v42 != 6);
  }
  sub_1B6429158(v62, (uint64_t)v66, 144, (uint64_t)v10, v7, a4, 1, *(void *)&v30, v61);
}

void sub_1B643049C(uint64_t a1, void *a2, uint64_t *a3, CFStringRef theString, uint64_t a5, uint64_t a6, unsigned int a7, int a8)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (theString)
  {
    uint64_t Length = CFStringGetLength(theString);
    int32x4_t v50 = v47;
    MEMORY[0x1F4188790](Length, v17);
    float v19 = (UniChar *)&v47[-((v18 + 15) & 0xFFFFFFFFFFFFFFF0)];
    v53.location = 0;
    v53.length = Length;
    CFStringGetCharacters(theString, v53, v19);
    if (Length >= 1)
    {
      uint64_t v23 = 1;
      int v24 = v19;
      uint64_t v25 = Length;
      do
      {
        int v26 = *v24++;
        if (v26 == 10) {
          ++v23;
        }
        --v25;
      }
      while (v25);
      *(void *)&long long v22 = *a2;
      unsigned int v48 = a7;
      uint64_t v27 = 0;
      char v28 = 0;
      char v29 = 0;
      float v30 = *((float *)&v22 + 1) + (float)((float)(v23 - 1) * *(float *)(a6 + 32));
      while (1)
      {
        unsigned int v32 = *v19++;
        uint64_t v31 = v32;
        if (v32 == 32)
        {
          *(float *)&long long v22 = *(float *)&v22 + **(float **)(a6 + 40);
        }
        else if (v31 == 10)
        {
          *(void *)&long long v22 = *a2;
          float v30 = v30 - *(float *)(a6 + 32);
        }
        else if (v29)
        {
          if (v31 == 36)
          {
            float64x2_t v33 = *(float64x2_t *)(a6 + 8);
            if ((v28 & 1) == 0) {
              goto LABEL_21;
            }
            float32x4_t v51 = 0uLL;
            uint64_t v34 = *(void *)(a6 + 56) + 16 * v27;
            float32x4_t v51 = *(float32x4_t *)v34;
            float32x2_t v35 = vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v51.f32), v33));
            float32x2_t v36 = vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vadd_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)&v51.u32[2])), v33));
            *(float32x2_t *)v51.f32 = v35;
            *(float32x2_t *)&v51.u32[2] = v36;
            float v37 = *(float *)(v34 + 8);
            if (a8)
            {
              float v38 = *(float *)&v22 + v37;
              sub_1B642A58C(a1, *a3, a3[1], v51.f32, a5, v48, v20, v21, roundf(*(float *)&v22), roundf(v30), roundf(*(float *)&v22 + v37), roundf(v30 + *(float *)(v34 + 12)));
              *(float *)&long long v22 = v38;
            }
            else
            {
              *(float *)&long long v22 = *(float *)&v22 + v37;
            }
            char v29 = 0;
          }
          else
          {
            uint64_t v27 = v31 + 10 * v27 - 48;
            char v29 = 1;
          }
          char v28 = 1;
        }
        else
        {
          if (v31 != 36)
          {
            float64x2_t v33 = *(float64x2_t *)(a6 + 8);
LABEL_21:
            uint64_t v39 = v31 - 32;
            float v40 = (float)(v39 * *(__int16 *)(a6 + 36));
            float v41 = (float)*(__int16 *)(a6 + 36);
            int v42 = *(__int16 *)(a6 + 48);
            v43.f64[0] = (float)(v41 + v40);
            v43.f64[1] = (double)v42;
            float32x4_t v51 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64((float64x2_t)COERCE_UNSIGNED_INT64(v40), v33)), vdivq_f64(v43, v33));
            float v44 = *(float *)(*(void *)(a6 + 40) + 4 * v39);
            if (a8)
            {
              uint64_t v45 = *a3;
              uint64_t v46 = a3[1];
              long long v49 = v22;
              sub_1B642A58C(a1, v45, v46, v51.f32, a5, v48, v20, v21, roundf(*(float *)&v22), roundf(v30), roundf(*(float *)&v22 + v41), roundf(v30 + (float)v42));
              long long v22 = v49;
            }
            char v29 = 0;
            *(float *)&long long v22 = *(float *)&v22 + v44;
            goto LABEL_27;
          }
          char v28 = 0;
          uint64_t v27 = 0;
          char v29 = 1;
        }
LABEL_27:
        if (!--Length) {
          goto LABEL_30;
        }
      }
    }
    *(void *)&long long v22 = *a2;
LABEL_30:
    *(_DWORD *)a2 = v22;
  }
}

uint64_t (*sub_1B643079C(int a1, int a2, int a3, unsigned int a4))()
{
  uint64_t v4 = sub_1B64327B0;
  switch(a1)
  {
    case 1:
      uint64_t v5 = sub_1B6430AC4;
      if (a4 >= 3) {
        return (uint64_t (*)())v5;
      }
      int v6 = &off_1F0FBAB08;
      return v6[a4];
    case 2:
      uint64_t v5 = sub_1B6430D50;
      if (a4 >= 3) {
        return (uint64_t (*)())v5;
      }
      int v6 = &off_1F0FBAB38;
      return v6[a4];
    case 3:
      return (uint64_t (*)())v4;
    case 4:
    case 15:
      uint64_t v5 = sub_1B64328C8;
      if (a4 >= 3) {
        return (uint64_t (*)())v5;
      }
      int v6 = &off_1F0FBAC10;
      return v6[a4];
    case 6:
      uint64_t v5 = sub_1B6430C0C;
      if (a4 >= 3) {
        return (uint64_t (*)())v5;
      }
      int v6 = &off_1F0FBAB20;
      return v6[a4];
    case 7:
    case 17:
      uint64_t v5 = sub_1B643149C;
      if (a4 >= 3) {
        return (uint64_t (*)())v5;
      }
      int v6 = &off_1F0FBABC8;
      return v6[a4];
    case 8:
    case 18:
      uint64_t v5 = sub_1B64312F8;
      if (a4 >= 3) {
        return (uint64_t (*)())v5;
      }
      int v6 = &off_1F0FBABB0;
      return v6[a4];
    case 9:
    case 19:
      if (a2 == 3)
      {
        uint64_t v5 = sub_1B6430FBC;
        if (a4 >= 3) {
          return (uint64_t (*)())v5;
        }
        int v6 = &off_1F0FBAB68;
      }
      else if (a2 == 4)
      {
        uint64_t v5 = sub_1B6430E48;
        if (a4 >= 3) {
          return (uint64_t (*)())v5;
        }
        int v6 = &off_1F0FBAB50;
      }
      else
      {
        uint64_t v5 = sub_1B643105C;
        if (a4 >= 3) {
          return (uint64_t (*)())v5;
        }
        int v6 = &off_1F0FBAB80;
      }
      return v6[a4];
    case 10:
      if (a3)
      {
        uint64_t v5 = sub_1B64316E0;
        if (a4 < 3)
        {
          int v6 = &off_1F0FBABE0;
          return v6[a4];
        }
      }
      else
      {
        uint64_t v5 = sub_1B6432790;
        if (a4 < 3)
        {
          int v6 = &off_1F0FBABF8;
          return v6[a4];
        }
      }
      return (uint64_t (*)())v5;
    case 12:
      uint64_t v5 = sub_1B6431140;
      if (a4 >= 3) {
        return (uint64_t (*)())v5;
      }
      int v6 = &off_1F0FBAB98;
      return v6[a4];
    default:
      return 0;
  }
}

float sub_1B64309D0(float *a1, float *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float *a8)
{
  double v8 = *a1 + (float)(*a2 - *a1) * a3;
  if (a7) {
    double v8 = v8 + *a8;
  }
  float result = v8;
  *a8 = result;
  return result;
}

float *sub_1B6430A04(float *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float *a7)
{
  float v7 = *result;
  if (a6) {
    float v7 = v7 + *a7;
  }
  *a7 = v7;
  return result;
}

void sub_1B6430A1C(float *a1, float *a2, double a3, uint64_t a4, void *a5, void *a6, int a7, float *a8)
{
  float v10 = *a1;
  float v11 = *a2;
  float v12 = *a1 + COERCE_FLOAT(HIDWORD(*a5));
  float v13 = *a2 + COERCE_FLOAT(HIDWORD(*a6));
  float v14 = a3;
  float v15 = sub_1B6432964(v14, COERCE_FLOAT(*a5), COERCE_FLOAT(*a6));
  float v16 = (float)((float)((float)(v12 * (float)(v15 * (float)((float)((float)(1.0 - v15) * (float)(1.0 - v15)) * 3.0)))
                      + (float)((float)((float)(1.0 - v15) * (float)((float)(1.0 - v15) * (float)(1.0 - v15))) * v10))
              + (float)((float)(v15 * (float)(v15 * v15)) * v11))
      + (float)((float)((float)(v15 * v15) * (float)((float)(1.0 - v15) * 3.0)) * v13);
  if (a7) {
    float v16 = v16 + *a8;
  }
  *a8 = v16;
}

void sub_1B6430AC4(float *a1, float *a2, int a3, void *a4, void *a5, int a6, float *a7, double a8)
{
  if (!a3)
  {
    double v9 = *a1 + (float)(*a2 - *a1) * a8;
    if (a6) {
      double v9 = v9 + *a7;
    }
    float v8 = v9;
    goto LABEL_8;
  }
  if (a3 == 1)
  {
    float v8 = *a1;
    if (a6) {
      float v8 = v8 + *a7;
    }
LABEL_8:
    *a7 = v8;
    return;
  }
  sub_1B6430A1C(a1, a2, a8, 0, a4, a5, a6, a7);
}

double *sub_1B6430B20(double *result, double *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, double *a8)
{
  double v8 = *result + (*a2 - *result) * a3;
  if (a7) {
    double v8 = *a8 + v8;
  }
  *a8 = v8;
  return result;
}

double *sub_1B6430B44(double *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, double *a7)
{
  double v7 = *result;
  if (a6) {
    double v7 = v7 + *a7;
  }
  *a7 = v7;
  return result;
}

void sub_1B6430B5C(double a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, int a7, double *a8)
{
  float v10 = a1;
  int v20 = HIDWORD(*a6);
  float v11 = sub_1B6432964(v10, COERCE_FLOAT(*a5), COERCE_FLOAT(*a6));
  _S1 = (float)(v11 * v11) * (float)((float)(1.0 - v11) * 3.0);
  _V2.S[1] = v20;
  __asm { FMLA            S0, S1, V2.S[1] }
  double v19 = _S0;
  if (a7) {
    double v19 = *a8 + v19;
  }
  *a8 = v19;
}

void sub_1B6430C0C(double *a1, double *a2, int a3, void *a4, void *a5, int a6, double *a7, double a8)
{
  if (!a3)
  {
    double v8 = *a1 + (*a2 - *a1) * a8;
    if (!a6) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (a3 == 1)
  {
    double v8 = *a1;
    if (!a6)
    {
LABEL_5:
      *a7 = v8;
      return;
    }
LABEL_4:
    double v8 = v8 + *a7;
    goto LABEL_5;
  }
  sub_1B6430B5C(a8, (uint64_t)a1, (uint64_t)a2, 0, a4, a5, a6, a7);
}

int *sub_1B6430C50(int *result, _DWORD *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int *a8)
{
  double v8 = (double)*result + (double)(*a2 - *result) * a3;
  if (a7) {
    double v8 = v8 + (double)*a8;
  }
  *a8 = (int)v8;
  return result;
}

int *sub_1B6430C84(int *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, _DWORD *a7)
{
  int v7 = *result;
  if (a6) {
    v7 += *a7;
  }
  *a7 = v7;
  return result;
}

void sub_1B6430C9C(double a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, int a7, int *a8)
{
  float v10 = a1;
  int v19 = HIDWORD(*a6);
  float v11 = sub_1B6432964(v10, COERCE_FLOAT(*a5), COERCE_FLOAT(*a6));
  _S1 = (float)(v11 * v11) * (float)((float)(1.0 - v11) * 3.0);
  _V2.S[1] = v19;
  __asm { FMLA            S0, S1, V2.S[1] }
  if (a7) {
    _S0 = _S0 + (float)*a8;
  }
  *a8 = (int)_S0;
}

void sub_1B6430D50(int *a1, uint64_t a2, unsigned int a3, void *a4, void *a5, int a6, int *a7, double a8)
{
  if (a3 > 1)
  {
    sub_1B6430C9C(a8, (uint64_t)a1, a2, 0, a4, a5, a6, a7);
  }
  else
  {
    int v8 = *a1;
    if (a6) {
      v8 += *a7;
    }
    *a7 = v8;
  }
}

float32x4_t *sub_1B6430D7C(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float32x4_t v8 = *result;
  v9.i64[0] = 0x3400000034000000;
  v9.i64[1] = 0x3400000034000000;
  uint32x4_t v10 = (uint32x4_t)vcgeq_f32(v9, vabsq_f32(*result));
  v10.i32[3] = v10.i32[2];
  unsigned int v11 = vminvq_u32(v10);
  float32x4_t v12 = *a2;
  if ((v11 & 0x80000000) != 0)
  {
    float32x4_t v8 = *a2;
    v8.i32[3] = 0;
    float32x4_t v16 = v8;
    float result = &v16;
  }
  uint32x4_t v13 = (uint32x4_t)vcgeq_f32(v9, vabsq_f32(v12));
  v13.i32[3] = v13.i32[2];
  if ((vminvq_u32(v13) & 0x80000000) != 0)
  {
    v8.i32[3] = 0;
    float32x4_t v16 = v8;
    float32x4_t v12 = v8;
  }
  float v14 = a3;
  float32x4_t v15 = vmlaq_n_f32(*result, vsubq_f32(v12, *result), v14);
  if (a7) {
    float32x4_t v15 = vaddq_f32(*a8, v15);
  }
  *a8 = v15;
  return result;
}

float32x4_t *sub_1B6430E00(float32x4_t *result, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  float32x4_t v7 = *result;
  v8.i64[0] = 0x3400000034000000;
  v8.i64[1] = 0x3400000034000000;
  uint32x4_t v9 = (uint32x4_t)vcgeq_f32(v8, vabsq_f32(*result));
  v9.i32[3] = v9.i32[2];
  if ((vminvq_u32(v9) & 0x80000000) != 0)
  {
    float32x4_t v7 = *a2;
    v7.i32[3] = 0;
    if (a6) {
      goto LABEL_3;
    }
LABEL_5:
    float32x4_t v10 = *result;
    goto LABEL_6;
  }
  if (!a6) {
    goto LABEL_5;
  }
LABEL_3:
  float32x4_t v10 = vaddq_f32(v7, *a7);
LABEL_6:
  *a7 = v10;
  return result;
}

float32x4_t *sub_1B6430E48(float32x4_t *result, float32x4_t *a2, int a3, double a4, int32x4_t a5, double a6, int32x4_t a7, uint64_t a8, uint64_t a9, int a10, float32x4_t *a11)
{
  if (a3 == 1)
  {
    float32x4_t v11 = *result;
    v12.i64[0] = 0x3400000034000000;
    v12.i64[1] = 0x3400000034000000;
    uint32x4_t v13 = (uint32x4_t)vcgeq_f32(v12, vabsq_f32(*result));
    v13.i32[3] = v13.i32[2];
    if ((vminvq_u32(v13) & 0x80000000) != 0)
    {
      float32x4_t v11 = *a2;
      v11.i32[3] = 0;
      if (a10) {
        goto LABEL_4;
      }
    }
    else if (a10)
    {
LABEL_4:
      float32x4_t v14 = vaddq_f32(v11, *a11);
LABEL_14:
      *a11 = v14;
      return result;
    }
    float32x4_t v14 = *result;
    goto LABEL_14;
  }
  a5.i32[0] = 0;
  v15.i64[0] = 0x3400000034000000;
  v15.i64[1] = 0x3400000034000000;
  uint32x4_t v16 = (uint32x4_t)vcgeq_f32(v15, vabsq_f32(*result));
  v16.i32[3] = v16.i32[2];
  a7.i32[0] = vminvq_u32(v16);
  float32x4_t v17 = *a2;
  int8x16_t v18 = *(int8x16_t *)a2;
  v18.i32[3] = 0;
  float32x4_t v19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a7), 0), v18, *(int8x16_t *)result);
  uint32x4_t v20 = (uint32x4_t)vcgeq_f32(v15, vabsq_f32(*a2));
  v20.i32[3] = v20.i32[2];
  if ((vminvq_u32(v20) & 0x80000000) != 0)
  {
    uint64_t v21 = &v24;
    if (a7.i32[0] >= 0) {
      uint64_t v21 = result;
    }
    float32x4_t v17 = v19;
    v17.i32[3] = 0;
    float32x4_t v24 = v17;
    float32x4_t v19 = *v21;
  }
  float v22 = a4;
  float32x4_t v23 = vmlaq_n_f32(v19, vsubq_f32(v17, v19), v22);
  if (a10) {
    float32x4_t v23 = vaddq_f32(v23, *a11);
  }
  *a11 = v23;
  return result;
}

double sub_1B6430F2C(float32x4_t *a1, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  if (a7)
  {
    float32x4_t v12 = 0uLL;
    float v9 = a3;
    sub_1B63F8B48(a1, a2, &v12, v9);
    *(void *)&double result = sub_1B63F8A80(&v12, a8, a8).u64[0];
  }
  else
  {
    float v11 = a3;
    *(void *)&double result = sub_1B63F8B48(a1, a2, a8, v11).u64[0];
  }
  return result;
}

float32x4_t sub_1B6430FA0(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  if (a6)
  {
    result.i64[0] = sub_1B63F8A80(a1, a7, a7).u64[0];
  }
  else
  {
    float32x4_t result = *a1;
    *a7 = *a1;
  }
  return result;
}

float32x4_t sub_1B6430FBC(float32x4_t *a1, float32x4_t *a2, int a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7, double a8)
{
  if (a3 == 1)
  {
    if (a6)
    {
      result.i64[0] = sub_1B63F8A80(a1, a7, a7).u64[0];
    }
    else
    {
      float32x4_t result = *a1;
      *a7 = *a1;
    }
  }
  else
  {
    *(double *)result.i64 = sub_1B6430F2C(a1, a2, a8, 0, a4, a5, a6, a7);
  }
  return result;
}

float32x4_t *sub_1B6430FE8(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v8 = a3;
  float32x4_t v9 = vmlaq_n_f32(*result, vsubq_f32(*a2, *result), v8);
  if (a7) {
    float32x4_t v9 = vaddq_f32(*a8, v9);
  }
  *a8 = v9;
  return result;
}

float32x4_t sub_1B6431010(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  if (a6)
  {
    float32x4_t result = vaddq_f32(*a1, *a7);
    *a7 = result;
  }
  else
  {
    float32x4_t result = *a1;
    *a7 = *a1;
  }
  return result;
}

float32x4_t *sub_1B6431034(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v8 = a3;
  float32x4_t v9 = vmlaq_n_f32(*result, vsubq_f32(*a2, *result), v8);
  if (a7) {
    float32x4_t v9 = vaddq_f32(*a8, v9);
  }
  *a8 = v9;
  return result;
}

float32x4_t *sub_1B643105C(float32x4_t *result, float32x4_t *a2, int a3, double a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  if (a3 == 1)
  {
    if (a7) {
      float32x4_t v8 = vaddq_f32(*result, *a8);
    }
    else {
      float32x4_t v8 = *result;
    }
    *a8 = v8;
  }
  else
  {
    float v9 = a4;
    float32x4_t v10 = vmlaq_n_f32(*result, vsubq_f32(*a2, *result), v9);
    if (a7) {
      float32x4_t v10 = vaddq_f32(v10, *a8);
    }
    *a8 = v10;
  }
  return result;
}

float sub_1B64310B0(float *a1, float *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float *a8)
{
  if (a7)
  {
    v12[0] = 0;
    v12[1] = 0;
    float v9 = a3;
    sub_1B63C8F38(a1, a2, (float *)v12, v9);
    return sub_1B63C8F8C((float *)v12, a8, a8);
  }
  else
  {
    float v11 = a3;
    return sub_1B63C8F38(a1, a2, a8, v11);
  }
}

__n128 sub_1B6431124(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float *a7)
{
  if (a6)
  {
    result.n128_f32[0] = sub_1B63C8F8C(a1, a7, a7);
  }
  else
  {
    __n128 result = *(__n128 *)a1;
    *(_OWORD *)a7 = *(_OWORD *)a1;
  }
  return result;
}

__n128 sub_1B6431140(float *a1, float *a2, int a3, uint64_t a4, uint64_t a5, int a6, float *a7, double a8)
{
  if (a3 == 1)
  {
    if (a6)
    {
      result.n128_f32[0] = sub_1B63C8F8C(a1, a7, a7);
    }
    else
    {
      __n128 result = *(__n128 *)a1;
      *(_OWORD *)a7 = *(_OWORD *)a1;
    }
  }
  else
  {
    result.n128_f32[0] = sub_1B64310B0(a1, a2, a8, 0, a4, a5, a6, a7);
  }
  return result;
}

uint64_t sub_1B643116C(uint64_t result, uint64_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10)
{
  a4.i64[0] = *(void *)result;
  a4.i32[2] = *(_DWORD *)(result + 8);
  a5.i64[0] = *(void *)a2;
  a5.i32[2] = *(_DWORD *)(a2 + 8);
  float v10 = *(double *)a3.i64;
  float32x4_t v11 = vmlaq_n_f32(a4, vsubq_f32(a5, a4), v10);
  if (a9)
  {
    a3.i64[0] = *(void *)a10;
    a3.i32[2] = *(_DWORD *)(a10 + 8);
    float32x4_t v11 = vaddq_f32(v11, a3);
  }
  *(void *)a10 = v11.i64[0];
  *(_DWORD *)(a10 + 8) = v11.i32[2];
  return result;
}

float *sub_1B64311B4(float *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float *a7)
{
  if (a6)
  {
    float v7 = a7[1];
    *a7 = *result + *a7;
    a7[1] = result[1] + v7;
    a7[2] = result[2] + a7[2];
  }
  else
  {
    uint64_t v8 = *(void *)result;
    a7[2] = result[2];
    *(void *)a7 = v8;
  }
  return result;
}

void sub_1B64311FC(uint64_t a1, uint64_t a2, double a3, float32x4_t a4, uint64_t a5, int32x2_t *a6, int32x2_t *a7, int a8, uint64_t a9)
{
  a4.i64[0] = *(void *)a1;
  a4.i32[2] = *(_DWORD *)(a1 + 8);
  float32x4_t v22 = a4;
  a4.i64[0] = *(void *)a2;
  a4.i32[2] = *(_DWORD *)(a2 + 8);
  float32x4_t v21 = a4;
  float v13 = a3;
  int32x2_t v19 = *a6;
  int32x2_t v20 = *a7;
  float v14 = sub_1B6432964(v13, COERCE_FLOAT(*a6), COERCE_FLOAT(*a7));
  *(int32x2_t *)v16.f32 = vzip2_s32(v19, a6[1]);
  *(int32x2_t *)&v16.u32[2] = vdup_lane_s32(a6[2], 1);
  *(int32x2_t *)v17.f32 = vzip2_s32(v20, a7[1]);
  *(int32x2_t *)&v17.u32[2] = vdup_lane_s32(a7[2], 1);
  float32x4_t v18 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v16, v14 * (float)((float)((float)(1.0 - v14) * (float)(1.0 - v14)) * 3.0)), v22, (float)(1.0 - v14) * (float)((float)(1.0 - v14) * (float)(1.0 - v14))), v21, v14 * (float)(v14 * v14)), v17, (float)(v14 * v14) * (float)((float)(1.0 - v14) * 3.0));
  if (a8)
  {
    v15.i64[0] = *(void *)a9;
    v15.i32[2] = *(_DWORD *)(a9 + 8);
    float32x4_t v18 = vaddq_f32(v18, v15);
  }
  *(void *)a9 = v18.i64[0];
  *(_DWORD *)(a9 + 8) = v18.i32[2];
}

void sub_1B64312F8(float *a1, uint64_t a2, int a3, int32x2_t *a4, int32x2_t *a5, int a6, float *a7, float32x4_t a8, float32x4_t a9, float32x4_t a10)
{
  if (a3)
  {
    if (a3 == 1)
    {
      if (a6)
      {
        float v10 = a7[1];
        *a7 = *a1 + *a7;
        a7[1] = a1[1] + v10;
        a7[2] = a1[2] + a7[2];
      }
      else
      {
        uint64_t v13 = *(void *)a1;
        a7[2] = a1[2];
        *(void *)a7 = v13;
      }
    }
    else
    {
      sub_1B64311FC((uint64_t)a1, a2, *(double *)a8.i64, a9, 0, a4, a5, a6, (uint64_t)a7);
    }
  }
  else
  {
    a9.i64[0] = *(void *)a1;
    a9.f32[2] = a1[2];
    a10.i64[0] = *(void *)a2;
    a10.i32[2] = *(_DWORD *)(a2 + 8);
    float v11 = *(double *)a8.i64;
    float32x4_t v12 = vmlaq_n_f32(a9, vsubq_f32(a10, a9), v11);
    if (a6)
    {
      a8.i64[0] = *(void *)a7;
      a8.f32[2] = a7[2];
      float32x4_t v12 = vaddq_f32(v12, a8);
    }
    *(void *)a7 = v12.i64[0];
    a7[2] = v12.f32[2];
  }
}

float32x2_t *sub_1B643139C(float32x2_t *result, float32x2_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x2_t *a8)
{
  float v8 = a3;
  float32x2_t v9 = vmla_n_f32(*result, vsub_f32(*a2, *result), v8);
  if (a7) {
    float32x2_t v9 = vadd_f32(v9, *a8);
  }
  *a8 = v9;
  return result;
}

float32x2_t *sub_1B64313C4(float32x2_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x2_t *a7)
{
  float32x2_t v7 = *result;
  if (a6) {
    float32x2_t v7 = vadd_f32(v7, *a7);
  }
  *a7 = v7;
  return result;
}

void sub_1B64313DC(float32x2_t *a1, float32x2_t *a2, double a3, uint64_t a4, int32x2_t *a5, int32x2_t *a6, int a7, float32x2_t *a8)
{
  float32x2_t v12 = *a1;
  float32x2_t v13 = *a2;
  float v14 = a3;
  int32x2_t v18 = *a5;
  int32x2_t v19 = *a6;
  float v15 = sub_1B6432964(v14, COERCE_FLOAT(*a5), COERCE_FLOAT(*a6));
  float v16 = 1.0 - v15;
  float32x2_t v17 = vmla_n_f32(vmla_n_f32(vmla_n_f32(vmul_n_f32((float32x2_t)vzip2_s32(v18, a5[1]), v15 * (float)((float)(v16 * v16) * 3.0)), v12, v16 * (float)(v16 * v16)), v13, v15 * (float)(v15 * v15)), (float32x2_t)vzip2_s32(v19, a6[1]), (float)(v15 * v15) * (float)((float)(1.0 - v15) * 3.0));
  if (a7) {
    float32x2_t v17 = vadd_f32(v17, *a8);
  }
  *a8 = v17;
}

void sub_1B643149C(float32x2_t *a1, float32x2_t *a2, int a3, int32x2_t *a4, int32x2_t *a5, int a6, float32x2_t *a7, double a8)
{
  if (a3)
  {
    if (a3 == 1)
    {
      float32x2_t v8 = *a1;
      if (a6) {
        float32x2_t v8 = vadd_f32(v8, *a7);
      }
      *a7 = v8;
    }
    else
    {
      sub_1B64313DC(a1, a2, a8, 0, a4, a5, a6, a7);
    }
  }
  else
  {
    float v9 = a8;
    float32x2_t v10 = vmla_n_f32(*a1, vsub_f32(*a2, *a1), v9);
    if (a6) {
      float32x2_t v10 = vadd_f32(v10, *a7);
    }
    *a7 = v10;
  }
}

float32x4_t *sub_1B64314F0(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v8 = a3;
  float32x4_t v9 = vmlaq_n_f32(vmulq_n_f32(*a2, v8), *result, 1.0 - v8);
  float32x4_t v10 = vmlaq_n_f32(vmulq_n_f32(a2[1], v8), result[1], 1.0 - v8);
  float32x4_t v11 = vmlaq_n_f32(vmulq_n_f32(a2[2], v8), result[2], 1.0 - v8);
  float32x4_t v12 = vmlaq_n_f32(vmulq_n_f32(a2[3], v8), result[3], 1.0 - v8);
  if (a7)
  {
    uint64_t v13 = 0;
    float32x4_t v14 = *a8;
    float32x4_t v15 = a8[1];
    float32x4_t v16 = a8[2];
    float32x4_t v17 = a8[3];
    v21[0] = v9;
    v21[1] = v10;
    v21[2] = v11;
    v21[3] = v12;
    float32x4_t v22 = 0u;
    float32x4_t v23 = 0u;
    float32x4_t v24 = 0u;
    float32x4_t v25 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v22 + v13 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(v21[v13])), v15, *(float32x2_t *)&v21[v13], 1), v16, (float32x4_t)v21[v13], 2), v17, (float32x4_t)v21[v13], 3);
      ++v13;
    }
    while (v13 != 4);
    float32x4_t v18 = v23;
    float32x4_t v19 = v24;
    float32x4_t v20 = v25;
    *a8 = v22;
    a8[1] = v18;
    a8[2] = v19;
    a8[3] = v20;
  }
  else
  {
    *a8 = v9;
    a8[1] = v10;
    a8[2] = v11;
    a8[3] = v12;
  }
  return result;
}

float32x4_t sub_1B64315A4(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  if (a6)
  {
    uint64_t v7 = 0;
    float32x4_t result = *a7;
    float32x4_t v9 = a7[1];
    float32x4_t v10 = a7[2];
    float32x4_t v11 = a7[3];
    float32x4_t v12 = a1[1];
    float32x4_t v13 = a1[2];
    float32x4_t v14 = a1[3];
    v20[0] = *a1;
    v20[1] = v12;
    v20[2] = v13;
    v20[3] = v14;
    float32x4_t v21 = 0u;
    float32x4_t v22 = 0u;
    float32x4_t v23 = 0u;
    float32x4_t v24 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v21 + v7 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(result, COERCE_FLOAT(v20[v7])), v9, *(float32x2_t *)&v20[v7], 1), v10, (float32x4_t)v20[v7], 2), v11, (float32x4_t)v20[v7], 3);
      ++v7;
    }
    while (v7 != 4);
    result.i64[0] = v21.i64[0];
    float32x4_t v15 = v22;
    float32x4_t v16 = v23;
    float32x4_t v17 = v24;
    *a7 = v21;
    a7[1] = v15;
    a7[2] = v16;
    a7[3] = v17;
  }
  else
  {
    float32x4_t result = *a1;
    float32x4_t v18 = a1[1];
    float32x4_t v19 = a1[3];
    a7[2] = a1[2];
    a7[3] = v19;
    *a7 = result;
    a7[1] = v18;
  }
  return result;
}

float32x4_t *sub_1B643162C(float32x4_t *result, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v8 = a3;
  float32x4_t v9 = vmlaq_n_f32(vmulq_n_f32(*a2, v8), *result, 1.0 - v8);
  float32x4_t v10 = vmlaq_n_f32(vmulq_n_f32(a2[1], v8), result[1], 1.0 - v8);
  float32x4_t v11 = vmlaq_n_f32(vmulq_n_f32(a2[2], v8), result[2], 1.0 - v8);
  float32x4_t v12 = vmlaq_n_f32(vmulq_n_f32(a2[3], v8), result[3], 1.0 - v8);
  if (a7)
  {
    uint64_t v13 = 0;
    float32x4_t v14 = *a8;
    float32x4_t v15 = a8[1];
    float32x4_t v16 = a8[2];
    float32x4_t v17 = a8[3];
    v21[0] = v9;
    v21[1] = v10;
    v21[2] = v11;
    v21[3] = v12;
    float32x4_t v22 = 0u;
    float32x4_t v23 = 0u;
    float32x4_t v24 = 0u;
    float32x4_t v25 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v22 + v13 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(v21[v13])), v15, *(float32x2_t *)&v21[v13], 1), v16, (float32x4_t)v21[v13], 2), v17, (float32x4_t)v21[v13], 3);
      ++v13;
    }
    while (v13 != 4);
    float32x4_t v18 = v23;
    float32x4_t v19 = v24;
    float32x4_t v20 = v25;
    *a8 = v22;
    a8[1] = v18;
    a8[2] = v19;
    a8[3] = v20;
  }
  else
  {
    *a8 = v9;
    a8[1] = v10;
    a8[2] = v11;
    a8[3] = v12;
  }
  return result;
}

void sub_1B64316E0(float32x4_t *a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7, double a8)
{
  if (a3)
  {
    if (a3 == 1) {
      sub_1B64315A4(a1, (uint64_t)a2, 0, a4, a5, a6, a7);
    }
    else {
      sub_1B643162C(a1, a2, a8, 0, a4, a5, a6, a7);
    }
  }
  else
  {
    sub_1B64314F0(a1, a2, a8, a3, a4, a5, a6, a7);
  }
}

void sub_1B6431700(_OWORD *a1, _OWORD *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v9 = a3;
  float v178 = v9;
  float32x4_t v10 = *(float32x4_t *)a1;
  float32x4_t v11 = *((float32x4_t *)a1 + 1);
  float32x4_t v12 = *((float32x4_t *)a1 + 2);
  __n128 v13 = *((__n128 *)a1 + 3);
  float32x4_t v154 = *((float32x4_t *)a2 + 1);
  float32x4_t v155 = *(float32x4_t *)a2;
  __n128 v152 = *((__n128 *)a2 + 3);
  float32x4_t v153 = *((float32x4_t *)a2 + 2);
  float32x4_t v170 = *(float32x4_t *)a1;
  __n128 v175 = v13;
  float32x4_t v156 = v12;
  float32x4_t v161 = v11;
  if (a7)
  {
    float32x4_t v180 = 0uLL;
    v179[0] = 0uLL;
    v187.i32[2] = 0;
    v187.i64[0] = 0;
    v186.i32[2] = 0;
    v186.i64[0] = 0;
    v185.i32[2] = 0;
    v185.i64[0] = 0;
    v184.i32[2] = 0;
    v184.i64[0] = 0;
    int v14 = sub_1B64329E8(&v180, (__n128 *)&v187, &v185, v10, v11, v12, v13);
    int v15 = sub_1B64329E8(v179, (__n128 *)&v186, &v184, v155, v154, v153, v152);
    if (v14)
    {
      float32x4_t v16 = v170;
      float32x4_t v17 = (float32x4_t)v175;
      float32x4_t v18 = v156;
      float32x4_t v19 = v161;
      if (v15)
      {
        int8x16_t v20 = (int8x16_t)vmulq_f32(v180, v179[0]);
        float32x4_t v171 = v179[0];
        float32x4_t v176 = v180;
        float v21 = 1.0;
        if (vaddv_f32(vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL))) >= 0.0)
        {
          float v73 = 1.0 - v178;
          float32x4_t v74 = vsubq_f32(v180, v179[0]);
          int8x16_t v75 = (int8x16_t)vmulq_f32(v74, v74);
          float32x4_t v76 = vaddq_f32(v180, v179[0]);
          int8x16_t v77 = (int8x16_t)vmulq_f32(v76, v76);
          float v78 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v77.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v77, v77, 8uLL)))));
          float v79 = v78 + v78;
          _ZF = (float)(v78 + v78) == 0.0;
          float v80 = 1.0;
          if (!_ZF) {
            float v80 = sinf(v79) / v79;
          }
          float v81 = v80;
          float32x2_t v82 = vrecpe_f32((float32x2_t)LODWORD(v80));
          int32x2_t v83 = (int32x2_t)vmul_f32(v82, vrecps_f32((float32x2_t)LODWORD(v81), v82));
          LODWORD(v84) = vmul_f32((float32x2_t)v83, vrecps_f32((float32x2_t)LODWORD(v81), (float32x2_t)v83)).u32[0];
          if ((float)(v73 * v79) != 0.0)
          {
            float v166 = v84;
            *(float *)v83.i32 = sinf(v73 * v79);
            float v84 = v166;
            float v21 = *(float *)v83.i32 / (float)(v73 * v79);
          }
          *(float *)v83.i32 = v73 * (float)(v84 * v21);
          float32x4_t v85 = (float32x4_t)vdupq_lane_s32(v83, 0);
          float v39 = v178;
          float v86 = v79 * v178;
          float v87 = 1.0;
          if (v86 != 0.0)
          {
            float32x4_t v159 = v85;
            float v167 = v84;
            float v88 = sinf(v86);
            float32x4_t v85 = v159;
            float v84 = v167;
            float v39 = v178;
            float v87 = v88 / v86;
          }
          float32x4_t v43 = vmlaq_f32(vmulq_n_f32(v171, (float)(v84 * v87) * v39), v176, v85);
        }
        else
        {
          float v22 = 1.0 - v178;
          float32x4_t v23 = vaddq_f32(v180, v179[0]);
          int8x16_t v24 = (int8x16_t)vmulq_f32(v23, v23);
          float32x4_t v25 = vsubq_f32(v180, v179[0]);
          int8x16_t v26 = (int8x16_t)vmulq_f32(v25, v25);
          float v27 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)))));
          float v28 = v27 + v27;
          _ZF = (float)(v27 + v27) == 0.0;
          float v30 = 1.0;
          if (!_ZF) {
            float v30 = sinf(v28) / v28;
          }
          float v31 = v30;
          float32x2_t v32 = vrecpe_f32((float32x2_t)LODWORD(v30));
          float32x2_t v33 = vmul_f32(v32, vrecps_f32((float32x2_t)LODWORD(v31), v32));
          LODWORD(v34) = vmul_f32(v33, vrecps_f32((float32x2_t)LODWORD(v31), v33)).u32[0];
          if ((float)(v22 * v28) != 0.0)
          {
            float v162 = v34;
            float v35 = sinf(v22 * v28);
            float v34 = v162;
            float v21 = v35 / (float)(v22 * v28);
          }
          v36.i32[1] = v171.i32[1];
          float32x4_t v37 = vnegq_f32(v171);
          *(float *)v36.i32 = v22 * (float)(v34 * v21);
          float32x4_t v38 = (float32x4_t)vdupq_lane_s32(v36, 0);
          float v39 = v178;
          float v40 = v28 * v178;
          float v41 = 1.0;
          if (v40 != 0.0)
          {
            float v163 = v34;
            float32x4_t v172 = v37;
            float32x4_t v157 = v38;
            float v42 = sinf(v40);
            float32x4_t v38 = v157;
            float v34 = v163;
            float32x4_t v37 = v172;
            float v39 = v178;
            float v41 = v42 / v40;
          }
          float32x4_t v43 = vmlaq_f32(vmulq_n_f32(v37, (float)(v34 * v41) * v39), v176, v38);
        }
        int8x16_t v89 = (int8x16_t)vmulq_f32(v43, v43);
        *(float32x2_t *)v89.i8 = vadd_f32(*(float32x2_t *)v89.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v89, v89, 8uLL));
        float32x4_t v90 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v89.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v89.i8, 1)), 0);
        float32x4_t v91 = vrsqrteq_f32(v90);
        float32x4_t v92 = vmulq_f32(v91, vrsqrtsq_f32(v90, vmulq_f32(v91, v91)));
        __asm { FMOV            V3.4S, #1.0 }
        float32x4_t v97 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v90), _Q3, (int8x16_t)vmulq_f32(v92, vrsqrtsq_f32(v90, vmulq_f32(v92, v92))));
        float32x4_t v17 = vmlaq_n_f32(v187, vsubq_f32(v186, v187), v39);
        float32x4_t v98 = vmlaq_n_f32(v185, vsubq_f32(v184, v185), v39);
        v17.i32[3] = 1.0;
        float32x4_t v99 = vabsq_f32(v98);
        v99.i32[3] = 0;
        float32x4_t v100 = vmulq_f32(v43, v97);
        float32x4_t v101 = vmaxnmq_f32(v99, (float32x4_t)xmmword_1B6E4FCD0);
        v99.i64[0] = 0x8000000080000000;
        v99.i64[1] = 0x8000000080000000;
        float32x4_t v102 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v98, (int8x16_t)v99), (int8x16_t)(*(_OWORD *)&v101 & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        float32x4_t v103 = vmulq_f32(v100, v100);
        float32x4_t v104 = vmulq_laneq_f32(v100, v100, 3);
        float v105 = vmulq_lane_f32(v100, *(float32x2_t *)v100.f32, 1).f32[0];
        float32x4_t v106 = vaddq_f32(v102, v102);
        v103.f32[0] = 0.5 - v103.f32[0];
        *(float32x2_t *)v100.f32 = vmul_laneq_f32(*(float32x2_t *)v100.f32, v100, 2);
        v107.i32[3] = 0;
        v107.f32[0] = (float)(0.5 - v103.f32[1]) - v103.f32[2];
        v107.f32[1] = v105 + v104.f32[2];
        v108.i32[3] = 0;
        v107.f32[2] = v100.f32[0] - v104.f32[1];
        float32x4_t v16 = vmulq_n_f32(v107, v106.f32[0]);
        v108.f32[0] = v105 - v104.f32[2];
        v108.f32[1] = v103.f32[0] - v103.f32[2];
        v108.f32[2] = v100.f32[1] + v104.f32[0];
        float32x4_t v19 = vmulq_lane_f32(v108, *(float32x2_t *)v106.f32, 1);
        *(int32x2_t *)v104.f32 = vrev64_s32(*(int32x2_t *)v104.f32);
        v109.i32[0] = vadd_f32(*(float32x2_t *)v100.f32, *(float32x2_t *)v104.f32).u32[0];
        v109.i32[1] = vsub_f32(*(float32x2_t *)&v100, *(float32x2_t *)&v104).i32[1];
        v109.f32[2] = v103.f32[0] - v103.f32[1];
        v109.i32[3] = 0;
        float32x4_t v18 = vmulq_laneq_f32(v109, v106, 2);
      }
    }
    else
    {
      float32x4_t v16 = v170;
      float32x4_t v17 = (float32x4_t)v175;
      float32x4_t v18 = v156;
      float32x4_t v19 = v161;
    }
    uint64_t v110 = 0;
    float32x4_t v111 = *a8;
    float32x4_t v112 = a8[1];
    float32x4_t v113 = a8[2];
    float32x4_t v114 = a8[3];
    v179[0] = v16;
    v179[1] = v19;
    v179[2] = v18;
    v179[3] = v17;
    float32x4_t v180 = 0u;
    float32x4_t v181 = 0u;
    float32x4_t v182 = 0u;
    float32x4_t v183 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v180 + v110 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v111, COERCE_FLOAT(*(_OWORD *)&v179[v110])), v112, *(float32x2_t *)v179[v110].f32, 1), v113, v179[v110], 2), v114, v179[v110], 3);
      ++v110;
    }
    while (v110 != 4);
    float32x4_t v115 = v181;
    float32x4_t v116 = v182;
    float32x4_t v117 = v183;
    *a8 = v180;
    a8[1] = v115;
    a8[2] = v116;
    a8[3] = v117;
  }
  else
  {
    float32x4_t v180 = 0uLL;
    v179[0] = 0uLL;
    v187.i32[2] = 0;
    v187.i64[0] = 0;
    v186.i32[2] = 0;
    v186.i64[0] = 0;
    v185.i32[2] = 0;
    v185.i64[0] = 0;
    v184.i32[2] = 0;
    v184.i64[0] = 0;
    int v44 = sub_1B64329E8(&v180, (__n128 *)&v187, &v185, v10, v11, v12, v13);
    int v45 = sub_1B64329E8(v179, (__n128 *)&v186, &v184, v155, v154, v153, v152);
    if (v44)
    {
      float32x4_t v46 = v170;
      float32x4_t v47 = (float32x4_t)v175;
      float32x4_t v48 = v156;
      float32x4_t v49 = v161;
      if (v45)
      {
        int8x16_t v50 = (int8x16_t)vmulq_f32(v180, v179[0]);
        float32x4_t v173 = v179[0];
        float32x4_t v177 = v180;
        float v51 = 1.0;
        if (vaddv_f32(vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL))) >= 0.0)
        {
          float v118 = 1.0 - v178;
          float32x4_t v119 = vsubq_f32(v180, v179[0]);
          int8x16_t v120 = (int8x16_t)vmulq_f32(v119, v119);
          float32x4_t v121 = vaddq_f32(v180, v179[0]);
          int8x16_t v122 = (int8x16_t)vmulq_f32(v121, v121);
          float v123 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v120.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v122.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v122, v122, 8uLL)))));
          float v124 = v123 + v123;
          _ZF = (float)(v123 + v123) == 0.0;
          float v125 = 1.0;
          if (!_ZF) {
            float v125 = sinf(v124) / v124;
          }
          float v126 = v125;
          float32x2_t v127 = vrecpe_f32((float32x2_t)LODWORD(v125));
          int32x2_t v128 = (int32x2_t)vmul_f32(v127, vrecps_f32((float32x2_t)LODWORD(v126), v127));
          LODWORD(v129) = vmul_f32((float32x2_t)v128, vrecps_f32((float32x2_t)LODWORD(v126), (float32x2_t)v128)).u32[0];
          if ((float)(v118 * v124) != 0.0)
          {
            float v168 = v129;
            *(float *)v128.i32 = sinf(v118 * v124);
            float v129 = v168;
            float v51 = *(float *)v128.i32 / (float)(v118 * v124);
          }
          *(float *)v128.i32 = v118 * (float)(v129 * v51);
          float32x4_t v130 = (float32x4_t)vdupq_lane_s32(v128, 0);
          float v68 = v178;
          float v131 = v124 * v178;
          float v132 = 1.0;
          if (v131 != 0.0)
          {
            float32x4_t v160 = v130;
            float v169 = v129;
            float v133 = sinf(v131);
            float32x4_t v130 = v160;
            float v129 = v169;
            float v68 = v178;
            float v132 = v133 / v131;
          }
          float32x4_t v72 = vmlaq_f32(vmulq_n_f32(v173, (float)(v129 * v132) * v68), v177, v130);
        }
        else
        {
          float v52 = 1.0 - v178;
          float32x4_t v53 = vaddq_f32(v180, v179[0]);
          int8x16_t v54 = (int8x16_t)vmulq_f32(v53, v53);
          float32x4_t v55 = vsubq_f32(v180, v179[0]);
          int8x16_t v56 = (int8x16_t)vmulq_f32(v55, v55);
          float v57 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)))));
          float v58 = v57 + v57;
          _ZF = (float)(v57 + v57) == 0.0;
          float v59 = 1.0;
          if (!_ZF) {
            float v59 = sinf(v58) / v58;
          }
          float v60 = v59;
          float32x2_t v61 = vrecpe_f32((float32x2_t)LODWORD(v59));
          float32x2_t v62 = vmul_f32(v61, vrecps_f32((float32x2_t)LODWORD(v60), v61));
          LODWORD(v63) = vmul_f32(v62, vrecps_f32((float32x2_t)LODWORD(v60), v62)).u32[0];
          if ((float)(v52 * v58) != 0.0)
          {
            float v164 = v63;
            float v64 = sinf(v52 * v58);
            float v63 = v164;
            float v51 = v64 / (float)(v52 * v58);
          }
          v65.i32[1] = v173.i32[1];
          float32x4_t v66 = vnegq_f32(v173);
          *(float *)v65.i32 = v52 * (float)(v63 * v51);
          float32x4_t v67 = (float32x4_t)vdupq_lane_s32(v65, 0);
          float v68 = v178;
          float v69 = v58 * v178;
          float v70 = 1.0;
          if (v69 != 0.0)
          {
            float v165 = v63;
            float32x4_t v174 = v66;
            float32x4_t v158 = v67;
            float v71 = sinf(v69);
            float32x4_t v67 = v158;
            float v63 = v165;
            float32x4_t v66 = v174;
            float v68 = v178;
            float v70 = v71 / v69;
          }
          float32x4_t v72 = vmlaq_f32(vmulq_n_f32(v66, (float)(v63 * v70) * v68), v177, v67);
        }
        int8x16_t v134 = (int8x16_t)vmulq_f32(v72, v72);
        *(float32x2_t *)v134.i8 = vadd_f32(*(float32x2_t *)v134.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v134, v134, 8uLL));
        float32x4_t v135 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v134.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v134.i8, 1)), 0);
        float32x4_t v136 = vrsqrteq_f32(v135);
        float32x4_t v137 = vmulq_f32(v136, vrsqrtsq_f32(v135, vmulq_f32(v136, v136)));
        __asm { FMOV            V3.4S, #1.0 }
        float32x4_t v139 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v135), _Q3, (int8x16_t)vmulq_f32(v137, vrsqrtsq_f32(v135, vmulq_f32(v137, v137))));
        float32x4_t v47 = vmlaq_n_f32(v187, vsubq_f32(v186, v187), v68);
        float32x4_t v140 = vmlaq_n_f32(v185, vsubq_f32(v184, v185), v68);
        v47.i32[3] = 1.0;
        float32x4_t v141 = vabsq_f32(v140);
        v141.i32[3] = 0;
        float32x4_t v142 = vmulq_f32(v72, v139);
        float32x4_t v143 = vmaxnmq_f32(v141, (float32x4_t)xmmword_1B6E4FCD0);
        v141.i64[0] = 0x8000000080000000;
        v141.i64[1] = 0x8000000080000000;
        float32x4_t v144 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v140, (int8x16_t)v141), (int8x16_t)(*(_OWORD *)&v143 & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        float32x4_t v145 = vmulq_f32(v142, v142);
        float32x4_t v146 = vmulq_laneq_f32(v142, v142, 3);
        float v147 = vmulq_lane_f32(v142, *(float32x2_t *)v142.f32, 1).f32[0];
        float32x4_t v148 = vaddq_f32(v144, v144);
        v145.f32[0] = 0.5 - v145.f32[0];
        *(float32x2_t *)v142.f32 = vmul_laneq_f32(*(float32x2_t *)v142.f32, v142, 2);
        v149.i32[3] = 0;
        v149.f32[0] = (float)(0.5 - v145.f32[1]) - v145.f32[2];
        v149.f32[1] = v147 + v146.f32[2];
        v150.i32[3] = 0;
        v149.f32[2] = v142.f32[0] - v146.f32[1];
        float32x4_t v46 = vmulq_n_f32(v149, v148.f32[0]);
        v150.f32[0] = v147 - v146.f32[2];
        v150.f32[1] = v145.f32[0] - v145.f32[2];
        v150.f32[2] = v142.f32[1] + v146.f32[0];
        float32x4_t v49 = vmulq_lane_f32(v150, *(float32x2_t *)v148.f32, 1);
        *(int32x2_t *)v146.f32 = vrev64_s32(*(int32x2_t *)v146.f32);
        v151.i32[0] = vadd_f32(*(float32x2_t *)v142.f32, *(float32x2_t *)v146.f32).u32[0];
        v151.i32[1] = vsub_f32(*(float32x2_t *)&v142, *(float32x2_t *)&v146).i32[1];
        v151.f32[2] = v145.f32[0] - v145.f32[1];
        v151.i32[3] = 0;
        float32x4_t v48 = vmulq_laneq_f32(v151, v148, 2);
      }
    }
    else
    {
      float32x4_t v46 = v170;
      float32x4_t v47 = (float32x4_t)v175;
      float32x4_t v48 = v156;
      float32x4_t v49 = v161;
    }
    *a8 = v46;
    a8[1] = v49;
    a8[2] = v48;
    a8[3] = v47;
  }
}

float32x4_t sub_1B6431F04(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7)
{
  if (a6)
  {
    uint64_t v7 = 0;
    float32x4_t result = *a7;
    float32x4_t v9 = a7[1];
    float32x4_t v10 = a7[2];
    float32x4_t v11 = a7[3];
    float32x4_t v12 = a1[1];
    float32x4_t v13 = a1[2];
    float32x4_t v14 = a1[3];
    v20[0] = *a1;
    v20[1] = v12;
    v20[2] = v13;
    v20[3] = v14;
    float32x4_t v21 = 0u;
    float32x4_t v22 = 0u;
    float32x4_t v23 = 0u;
    float32x4_t v24 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v21 + v7 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(result, COERCE_FLOAT(v20[v7])), v9, *(float32x2_t *)&v20[v7], 1), v10, (float32x4_t)v20[v7], 2), v11, (float32x4_t)v20[v7], 3);
      ++v7;
    }
    while (v7 != 4);
    result.i64[0] = v21.i64[0];
    float32x4_t v15 = v22;
    float32x4_t v16 = v23;
    float32x4_t v17 = v24;
    *a7 = v21;
    a7[1] = v15;
    a7[2] = v16;
    a7[3] = v17;
  }
  else
  {
    float32x4_t result = *a1;
    float32x4_t v18 = a1[1];
    float32x4_t v19 = a1[3];
    a7[2] = a1[2];
    a7[3] = v19;
    *a7 = result;
    a7[1] = v18;
  }
  return result;
}

void sub_1B6431F8C(_OWORD *a1, _OWORD *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8)
{
  float v9 = a3;
  float v178 = v9;
  float32x4_t v10 = *(float32x4_t *)a1;
  float32x4_t v11 = *((float32x4_t *)a1 + 1);
  float32x4_t v12 = *((float32x4_t *)a1 + 2);
  __n128 v13 = *((__n128 *)a1 + 3);
  float32x4_t v154 = *((float32x4_t *)a2 + 1);
  float32x4_t v155 = *(float32x4_t *)a2;
  __n128 v152 = *((__n128 *)a2 + 3);
  float32x4_t v153 = *((float32x4_t *)a2 + 2);
  float32x4_t v170 = *(float32x4_t *)a1;
  __n128 v175 = v13;
  float32x4_t v156 = v12;
  float32x4_t v161 = v11;
  if (a7)
  {
    float32x4_t v180 = 0uLL;
    v179[0] = 0uLL;
    v187.i32[2] = 0;
    v187.i64[0] = 0;
    v186.i32[2] = 0;
    v186.i64[0] = 0;
    v185.i32[2] = 0;
    v185.i64[0] = 0;
    v184.i32[2] = 0;
    v184.i64[0] = 0;
    int v14 = sub_1B64329E8(&v180, (__n128 *)&v187, &v185, v10, v11, v12, v13);
    int v15 = sub_1B64329E8(v179, (__n128 *)&v186, &v184, v155, v154, v153, v152);
    if (v14)
    {
      float32x4_t v16 = v170;
      float32x4_t v17 = (float32x4_t)v175;
      float32x4_t v18 = v156;
      float32x4_t v19 = v161;
      if (v15)
      {
        int8x16_t v20 = (int8x16_t)vmulq_f32(v180, v179[0]);
        float32x4_t v171 = v179[0];
        float32x4_t v176 = v180;
        float v21 = 1.0;
        if (vaddv_f32(vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL))) >= 0.0)
        {
          float v73 = 1.0 - v178;
          float32x4_t v74 = vsubq_f32(v180, v179[0]);
          int8x16_t v75 = (int8x16_t)vmulq_f32(v74, v74);
          float32x4_t v76 = vaddq_f32(v180, v179[0]);
          int8x16_t v77 = (int8x16_t)vmulq_f32(v76, v76);
          float v78 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v77.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v77, v77, 8uLL)))));
          float v79 = v78 + v78;
          _ZF = (float)(v78 + v78) == 0.0;
          float v80 = 1.0;
          if (!_ZF) {
            float v80 = sinf(v79) / v79;
          }
          float v81 = v80;
          float32x2_t v82 = vrecpe_f32((float32x2_t)LODWORD(v80));
          int32x2_t v83 = (int32x2_t)vmul_f32(v82, vrecps_f32((float32x2_t)LODWORD(v81), v82));
          LODWORD(v84) = vmul_f32((float32x2_t)v83, vrecps_f32((float32x2_t)LODWORD(v81), (float32x2_t)v83)).u32[0];
          if ((float)(v73 * v79) != 0.0)
          {
            float v166 = v84;
            *(float *)v83.i32 = sinf(v73 * v79);
            float v84 = v166;
            float v21 = *(float *)v83.i32 / (float)(v73 * v79);
          }
          *(float *)v83.i32 = v73 * (float)(v84 * v21);
          float32x4_t v85 = (float32x4_t)vdupq_lane_s32(v83, 0);
          float v39 = v178;
          float v86 = v79 * v178;
          float v87 = 1.0;
          if (v86 != 0.0)
          {
            float32x4_t v159 = v85;
            float v167 = v84;
            float v88 = sinf(v86);
            float32x4_t v85 = v159;
            float v84 = v167;
            float v39 = v178;
            float v87 = v88 / v86;
          }
          float32x4_t v43 = vmlaq_f32(vmulq_n_f32(v171, (float)(v84 * v87) * v39), v176, v85);
        }
        else
        {
          float v22 = 1.0 - v178;
          float32x4_t v23 = vaddq_f32(v180, v179[0]);
          int8x16_t v24 = (int8x16_t)vmulq_f32(v23, v23);
          float32x4_t v25 = vsubq_f32(v180, v179[0]);
          int8x16_t v26 = (int8x16_t)vmulq_f32(v25, v25);
          float v27 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)))));
          float v28 = v27 + v27;
          _ZF = (float)(v27 + v27) == 0.0;
          float v30 = 1.0;
          if (!_ZF) {
            float v30 = sinf(v28) / v28;
          }
          float v31 = v30;
          float32x2_t v32 = vrecpe_f32((float32x2_t)LODWORD(v30));
          float32x2_t v33 = vmul_f32(v32, vrecps_f32((float32x2_t)LODWORD(v31), v32));
          LODWORD(v34) = vmul_f32(v33, vrecps_f32((float32x2_t)LODWORD(v31), v33)).u32[0];
          if ((float)(v22 * v28) != 0.0)
          {
            float v162 = v34;
            float v35 = sinf(v22 * v28);
            float v34 = v162;
            float v21 = v35 / (float)(v22 * v28);
          }
          v36.i32[1] = v171.i32[1];
          float32x4_t v37 = vnegq_f32(v171);
          *(float *)v36.i32 = v22 * (float)(v34 * v21);
          float32x4_t v38 = (float32x4_t)vdupq_lane_s32(v36, 0);
          float v39 = v178;
          float v40 = v28 * v178;
          float v41 = 1.0;
          if (v40 != 0.0)
          {
            float v163 = v34;
            float32x4_t v172 = v37;
            float32x4_t v157 = v38;
            float v42 = sinf(v40);
            float32x4_t v38 = v157;
            float v34 = v163;
            float32x4_t v37 = v172;
            float v39 = v178;
            float v41 = v42 / v40;
          }
          float32x4_t v43 = vmlaq_f32(vmulq_n_f32(v37, (float)(v34 * v41) * v39), v176, v38);
        }
        int8x16_t v89 = (int8x16_t)vmulq_f32(v43, v43);
        *(float32x2_t *)v89.i8 = vadd_f32(*(float32x2_t *)v89.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v89, v89, 8uLL));
        float32x4_t v90 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v89.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v89.i8, 1)), 0);
        float32x4_t v91 = vrsqrteq_f32(v90);
        float32x4_t v92 = vmulq_f32(v91, vrsqrtsq_f32(v90, vmulq_f32(v91, v91)));
        __asm { FMOV            V3.4S, #1.0 }
        float32x4_t v97 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v90), _Q3, (int8x16_t)vmulq_f32(v92, vrsqrtsq_f32(v90, vmulq_f32(v92, v92))));
        float32x4_t v17 = vmlaq_n_f32(v187, vsubq_f32(v186, v187), v39);
        float32x4_t v98 = vmlaq_n_f32(v185, vsubq_f32(v184, v185), v39);
        v17.i32[3] = 1.0;
        float32x4_t v99 = vabsq_f32(v98);
        v99.i32[3] = 0;
        float32x4_t v100 = vmulq_f32(v43, v97);
        float32x4_t v101 = vmaxnmq_f32(v99, (float32x4_t)xmmword_1B6E4FCD0);
        v99.i64[0] = 0x8000000080000000;
        v99.i64[1] = 0x8000000080000000;
        float32x4_t v102 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v98, (int8x16_t)v99), (int8x16_t)(*(_OWORD *)&v101 & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        float32x4_t v103 = vmulq_f32(v100, v100);
        float32x4_t v104 = vmulq_laneq_f32(v100, v100, 3);
        float v105 = vmulq_lane_f32(v100, *(float32x2_t *)v100.f32, 1).f32[0];
        float32x4_t v106 = vaddq_f32(v102, v102);
        v103.f32[0] = 0.5 - v103.f32[0];
        *(float32x2_t *)v100.f32 = vmul_laneq_f32(*(float32x2_t *)v100.f32, v100, 2);
        v107.i32[3] = 0;
        v107.f32[0] = (float)(0.5 - v103.f32[1]) - v103.f32[2];
        v107.f32[1] = v105 + v104.f32[2];
        v108.i32[3] = 0;
        v107.f32[2] = v100.f32[0] - v104.f32[1];
        float32x4_t v16 = vmulq_n_f32(v107, v106.f32[0]);
        v108.f32[0] = v105 - v104.f32[2];
        v108.f32[1] = v103.f32[0] - v103.f32[2];
        v108.f32[2] = v100.f32[1] + v104.f32[0];
        float32x4_t v19 = vmulq_lane_f32(v108, *(float32x2_t *)v106.f32, 1);
        *(int32x2_t *)v104.f32 = vrev64_s32(*(int32x2_t *)v104.f32);
        v109.i32[0] = vadd_f32(*(float32x2_t *)v100.f32, *(float32x2_t *)v104.f32).u32[0];
        v109.i32[1] = vsub_f32(*(float32x2_t *)&v100, *(float32x2_t *)&v104).i32[1];
        v109.f32[2] = v103.f32[0] - v103.f32[1];
        v109.i32[3] = 0;
        float32x4_t v18 = vmulq_laneq_f32(v109, v106, 2);
      }
    }
    else
    {
      float32x4_t v16 = v170;
      float32x4_t v17 = (float32x4_t)v175;
      float32x4_t v18 = v156;
      float32x4_t v19 = v161;
    }
    uint64_t v110 = 0;
    float32x4_t v111 = *a8;
    float32x4_t v112 = a8[1];
    float32x4_t v113 = a8[2];
    float32x4_t v114 = a8[3];
    v179[0] = v16;
    v179[1] = v19;
    v179[2] = v18;
    v179[3] = v17;
    float32x4_t v180 = 0u;
    float32x4_t v181 = 0u;
    float32x4_t v182 = 0u;
    float32x4_t v183 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v180 + v110 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v111, COERCE_FLOAT(*(_OWORD *)&v179[v110])), v112, *(float32x2_t *)v179[v110].f32, 1), v113, v179[v110], 2), v114, v179[v110], 3);
      ++v110;
    }
    while (v110 != 4);
    float32x4_t v115 = v181;
    float32x4_t v116 = v182;
    float32x4_t v117 = v183;
    *a8 = v180;
    a8[1] = v115;
    a8[2] = v116;
    a8[3] = v117;
  }
  else
  {
    float32x4_t v180 = 0uLL;
    v179[0] = 0uLL;
    v187.i32[2] = 0;
    v187.i64[0] = 0;
    v186.i32[2] = 0;
    v186.i64[0] = 0;
    v185.i32[2] = 0;
    v185.i64[0] = 0;
    v184.i32[2] = 0;
    v184.i64[0] = 0;
    int v44 = sub_1B64329E8(&v180, (__n128 *)&v187, &v185, v10, v11, v12, v13);
    int v45 = sub_1B64329E8(v179, (__n128 *)&v186, &v184, v155, v154, v153, v152);
    if (v44)
    {
      float32x4_t v46 = v170;
      float32x4_t v47 = (float32x4_t)v175;
      float32x4_t v48 = v156;
      float32x4_t v49 = v161;
      if (v45)
      {
        int8x16_t v50 = (int8x16_t)vmulq_f32(v180, v179[0]);
        float32x4_t v173 = v179[0];
        float32x4_t v177 = v180;
        float v51 = 1.0;
        if (vaddv_f32(vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL))) >= 0.0)
        {
          float v118 = 1.0 - v178;
          float32x4_t v119 = vsubq_f32(v180, v179[0]);
          int8x16_t v120 = (int8x16_t)vmulq_f32(v119, v119);
          float32x4_t v121 = vaddq_f32(v180, v179[0]);
          int8x16_t v122 = (int8x16_t)vmulq_f32(v121, v121);
          float v123 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v120.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v122.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v122, v122, 8uLL)))));
          float v124 = v123 + v123;
          _ZF = (float)(v123 + v123) == 0.0;
          float v125 = 1.0;
          if (!_ZF) {
            float v125 = sinf(v124) / v124;
          }
          float v126 = v125;
          float32x2_t v127 = vrecpe_f32((float32x2_t)LODWORD(v125));
          int32x2_t v128 = (int32x2_t)vmul_f32(v127, vrecps_f32((float32x2_t)LODWORD(v126), v127));
          LODWORD(v129) = vmul_f32((float32x2_t)v128, vrecps_f32((float32x2_t)LODWORD(v126), (float32x2_t)v128)).u32[0];
          if ((float)(v118 * v124) != 0.0)
          {
            float v168 = v129;
            *(float *)v128.i32 = sinf(v118 * v124);
            float v129 = v168;
            float v51 = *(float *)v128.i32 / (float)(v118 * v124);
          }
          *(float *)v128.i32 = v118 * (float)(v129 * v51);
          float32x4_t v130 = (float32x4_t)vdupq_lane_s32(v128, 0);
          float v68 = v178;
          float v131 = v124 * v178;
          float v132 = 1.0;
          if (v131 != 0.0)
          {
            float32x4_t v160 = v130;
            float v169 = v129;
            float v133 = sinf(v131);
            float32x4_t v130 = v160;
            float v129 = v169;
            float v68 = v178;
            float v132 = v133 / v131;
          }
          float32x4_t v72 = vmlaq_f32(vmulq_n_f32(v173, (float)(v129 * v132) * v68), v177, v130);
        }
        else
        {
          float v52 = 1.0 - v178;
          float32x4_t v53 = vaddq_f32(v180, v179[0]);
          int8x16_t v54 = (int8x16_t)vmulq_f32(v53, v53);
          float32x4_t v55 = vsubq_f32(v180, v179[0]);
          int8x16_t v56 = (int8x16_t)vmulq_f32(v55, v55);
          float v57 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)))));
          float v58 = v57 + v57;
          _ZF = (float)(v57 + v57) == 0.0;
          float v59 = 1.0;
          if (!_ZF) {
            float v59 = sinf(v58) / v58;
          }
          float v60 = v59;
          float32x2_t v61 = vrecpe_f32((float32x2_t)LODWORD(v59));
          float32x2_t v62 = vmul_f32(v61, vrecps_f32((float32x2_t)LODWORD(v60), v61));
          LODWORD(v63) = vmul_f32(v62, vrecps_f32((float32x2_t)LODWORD(v60), v62)).u32[0];
          if ((float)(v52 * v58) != 0.0)
          {
            float v164 = v63;
            float v64 = sinf(v52 * v58);
            float v63 = v164;
            float v51 = v64 / (float)(v52 * v58);
          }
          v65.i32[1] = v173.i32[1];
          float32x4_t v66 = vnegq_f32(v173);
          *(float *)v65.i32 = v52 * (float)(v63 * v51);
          float32x4_t v67 = (float32x4_t)vdupq_lane_s32(v65, 0);
          float v68 = v178;
          float v69 = v58 * v178;
          float v70 = 1.0;
          if (v69 != 0.0)
          {
            float v165 = v63;
            float32x4_t v174 = v66;
            float32x4_t v158 = v67;
            float v71 = sinf(v69);
            float32x4_t v67 = v158;
            float v63 = v165;
            float32x4_t v66 = v174;
            float v68 = v178;
            float v70 = v71 / v69;
          }
          float32x4_t v72 = vmlaq_f32(vmulq_n_f32(v66, (float)(v63 * v70) * v68), v177, v67);
        }
        int8x16_t v134 = (int8x16_t)vmulq_f32(v72, v72);
        *(float32x2_t *)v134.i8 = vadd_f32(*(float32x2_t *)v134.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v134, v134, 8uLL));
        float32x4_t v135 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v134.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v134.i8, 1)), 0);
        float32x4_t v136 = vrsqrteq_f32(v135);
        float32x4_t v137 = vmulq_f32(v136, vrsqrtsq_f32(v135, vmulq_f32(v136, v136)));
        __asm { FMOV            V3.4S, #1.0 }
        float32x4_t v139 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v135), _Q3, (int8x16_t)vmulq_f32(v137, vrsqrtsq_f32(v135, vmulq_f32(v137, v137))));
        float32x4_t v47 = vmlaq_n_f32(v187, vsubq_f32(v186, v187), v68);
        float32x4_t v140 = vmlaq_n_f32(v185, vsubq_f32(v184, v185), v68);
        v47.i32[3] = 1.0;
        float32x4_t v141 = vabsq_f32(v140);
        v141.i32[3] = 0;
        float32x4_t v142 = vmulq_f32(v72, v139);
        float32x4_t v143 = vmaxnmq_f32(v141, (float32x4_t)xmmword_1B6E4FCD0);
        v141.i64[0] = 0x8000000080000000;
        v141.i64[1] = 0x8000000080000000;
        float32x4_t v144 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)v140, (int8x16_t)v141), (int8x16_t)(*(_OWORD *)&v143 & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        float32x4_t v145 = vmulq_f32(v142, v142);
        float32x4_t v146 = vmulq_laneq_f32(v142, v142, 3);
        float v147 = vmulq_lane_f32(v142, *(float32x2_t *)v142.f32, 1).f32[0];
        float32x4_t v148 = vaddq_f32(v144, v144);
        v145.f32[0] = 0.5 - v145.f32[0];
        *(float32x2_t *)v142.f32 = vmul_laneq_f32(*(float32x2_t *)v142.f32, v142, 2);
        v149.i32[3] = 0;
        v149.f32[0] = (float)(0.5 - v145.f32[1]) - v145.f32[2];
        v149.f32[1] = v147 + v146.f32[2];
        v150.i32[3] = 0;
        v149.f32[2] = v142.f32[0] - v146.f32[1];
        float32x4_t v46 = vmulq_n_f32(v149, v148.f32[0]);
        v150.f32[0] = v147 - v146.f32[2];
        v150.f32[1] = v145.f32[0] - v145.f32[2];
        v150.f32[2] = v142.f32[1] + v146.f32[0];
        float32x4_t v49 = vmulq_lane_f32(v150, *(float32x2_t *)v148.f32, 1);
        *(int32x2_t *)v146.f32 = vrev64_s32(*(int32x2_t *)v146.f32);
        v151.i32[0] = vadd_f32(*(float32x2_t *)v142.f32, *(float32x2_t *)v146.f32).u32[0];
        v151.i32[1] = vsub_f32(*(float32x2_t *)&v142, *(float32x2_t *)&v146).i32[1];
        v151.f32[2] = v145.f32[0] - v145.f32[1];
        v151.i32[3] = 0;
        float32x4_t v48 = vmulq_laneq_f32(v151, v148, 2);
      }
    }
    else
    {
      float32x4_t v46 = v170;
      float32x4_t v47 = (float32x4_t)v175;
      float32x4_t v48 = v156;
      float32x4_t v49 = v161;
    }
    *a8 = v46;
    a8[1] = v49;
    a8[2] = v48;
    a8[3] = v47;
  }
}

void sub_1B6432790(float32x4_t *a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float32x4_t *a7, double a8)
{
  if (a3)
  {
    if (a3 == 1) {
      sub_1B6431F04(a1, (uint64_t)a2, 0, a4, a5, a6, a7);
    }
    else {
      sub_1B6431F8C(a1, a2, a8, 0, a4, a5, a6, a7);
    }
  }
  else
  {
    sub_1B6431700(a1, a2, a8, a3, a4, a5, a6, a7);
  }
}

unsigned char *sub_1B64327B0(unsigned char *result, unsigned char *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  if (a3 < 1.0) {
    a2 = result;
  }
  *a8 = *a2;
  return result;
}

unsigned __int8 *sub_1B64327C8(unsigned __int8 *result, unsigned __int8 *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned char *a8)
{
  unsigned int v8 = *result;
  double v9 = (double)v8;
  double v10 = (double)v8 + (double)(int)(*a2 - v8) * a3;
  if (a7)
  {
    LOBYTE(v9) = *a8;
    double v10 = v10 + (double)*(unint64_t *)&v9;
  }
  *a8 = (int)v10;
  return result;
}

char *sub_1B64327FC(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned char *a7)
{
  char v7 = *result;
  if (a6) {
    v7 += *a7;
  }
  *a7 = v7;
  return result;
}

void sub_1B6432814(double a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, int a7, unsigned char *a8)
{
  float v10 = a1;
  int v19 = HIDWORD(*a6);
  float v11 = sub_1B6432964(v10, COERCE_FLOAT(*a5), COERCE_FLOAT(*a6));
  _S1 = (float)(v11 * v11) * (float)((float)(1.0 - v11) * 3.0);
  _V2.S[1] = v19;
  __asm { FMLA            S0, S1, V2.S[1] }
  if (a7)
  {
    LOBYTE(_S1) = *a8;
    _S0 = _S0 + (float)LODWORD(_S1);
  }
  *a8 = (int)_S0;
}

void sub_1B64328C8(unsigned char *a1, unsigned __int8 *a2, int a3, void *a4, void *a5, int a6, unsigned char *a7, double a8)
{
  if (!a3)
  {
    unsigned int v9 = *a1;
    double v10 = (double)v9;
    double v11 = (double)v9 + (double)(int)(*a2 - v9) * a8;
    if (a6)
    {
      LOBYTE(v10) = *a7;
      double v11 = v11 + (double)*(unint64_t *)&v10;
    }
    int v8 = (int)v11;
    goto LABEL_8;
  }
  if (a3 == 1)
  {
    LOBYTE(v8) = *a1;
    if (a6) {
      LOBYTE(v8) = *a7 + v8;
    }
LABEL_8:
    *a7 = v8;
    return;
  }
  sub_1B6432814(a8, (uint64_t)a1, (uint64_t)a2, 0, a4, a5, a6, a7);
}

uint64_t sub_1B6432924(double (*a1)(float32x4_t *a1, float32x4_t *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, float32x4_t *a8))
{
  if (a1 == sub_1B6430F2C || (char *)a1 == (char *)sub_1B6430FBC || (char *)a1 == (char *)sub_1B6430FA0) {
    return 3;
  }
  else {
    return 0;
  }
}

float sub_1B6432964(float a1, float a2, float a3)
{
  float v3 = a3 + 1.0;
  float v4 = 0.0;
  int v5 = 20;
  float v6 = 0.5;
  float v7 = 1.0;
  do
  {
    float v8 = (float)((float)(v6 * (float)(v6 * v6))
               + (float)(a2 * (float)(v6 * (float)((float)((float)(1.0 - v6) * (float)(1.0 - v6)) * 3.0))))
       + (float)(v3 * (float)((float)(v6 * v6) * (float)((float)(1.0 - v6) * 3.0)));
    if (vabds_f32(v8, a1) < 0.00001) {
      break;
    }
    if (v8 >= a1) {
      float v7 = v6;
    }
    else {
      float v4 = v6;
    }
    float v6 = (float)(v4 + v7) * 0.5;
    --v5;
  }
  while (v5);
  return v6;
}

uint64_t sub_1B64329E8(float32x4_t *a1, __n128 *a2, float32x4_t *a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, __n128 a7)
{
  if (a3)
  {
    float32x4_t v7 = vmulq_f32(a4, a4);
    float32x4_t v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1)));
    v8.f32[0] = sqrtf(v8.f32[0]);
    float32x4_t v9 = vmulq_f32(a5, a5);
    float32x4_t v10 = vmulq_f32(a6, a6);
    v8.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
    v8.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
    *a3 = v8;
  }
  if (a2) {
    *a2 = a7;
  }
  if (a1)
  {
    if (a3)
    {
      float32x4_t v11 = *a3;
    }
    else
    {
      float32x4_t v13 = vmulq_f32(a4, a4);
      float32x4_t v11 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1)));
      float32x4_t v14 = vmulq_f32(a5, a5);
      v11.f32[0] = sqrtf(v11.f32[0]);
      float32x4_t v15 = vmulq_f32(a6, a6);
      v11.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
      v11.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0]);
    }
    uint32x4_t v16 = (uint32x4_t)vceqzq_f32(v11);
    v16.i32[3] = v16.i32[2];
    v16.i32[0] = vmaxvq_u32(v16);
    BOOL v12 = v16.i32[0] >= 0;
    if (v16.i32[0] < 0)
    {
      float32x4_t v48 = (float32x4_t)xmmword_1B6E4F370;
LABEL_31:
      *a1 = v48;
      return v12;
    }
    float32x4_t v17 = vdivq_f32(a4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0));
    float32x4_t v18 = vdivq_f32(a5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1));
    float32x4_t v19 = vdivq_f32(a6, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2));
    int32x4_t v20 = (int32x4_t)vmulq_f32(v17, v17);
    int32x4_t v21 = (int32x4_t)vmulq_f32(v18, v18);
    int32x4_t v22 = (int32x4_t)vmulq_f32(v19, v19);
    int32x4_t v23 = vzip2q_s32(v20, v22);
    float32x4_t v24 = (float32x4_t)vzip1q_s32(vzip1q_s32(v20, v22), v21);
    float32x4_t v25 = (float32x4_t)vtrn2q_s32(v20, v21);
    v25.i32[2] = v22.i32[1];
    float32x4_t v26 = vaddq_f32((float32x4_t)vzip1q_s32(v23, vdupq_laneq_s32(v21, 2)), vaddq_f32(v24, v25));
    v25.i64[0] = 0x80000000800000;
    v25.i64[1] = 0x80000000800000;
    int32x4_t v27 = vcgeq_f32(v25, v26);
    v26.i32[3] = 0;
    float32x4_t v28 = vrsqrteq_f32(v26);
    float32x4_t v29 = vmulq_f32(v28, vrsqrtsq_f32(v26, vmulq_f32(v28, v28)));
    int32x4_t v30 = v27;
    v30.i32[3] = 0;
    float32x4_t v31 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v30), (int8x16_t)v26, (int8x16_t)vmulq_f32(v29, vrsqrtsq_f32(v26, vmulq_f32(v29, v29))));
    float32x4_t v32 = vmulq_n_f32(v17, v31.f32[0]);
    float32x4_t v33 = vmulq_lane_f32(v18, *(float32x2_t *)v31.f32, 1);
    float32x4_t v34 = vmulq_laneq_f32(v19, v31, 2);
    int8x16_t v35 = (int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34);
    int8x16_t v36 = (int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33);
    int32x4_t v37 = (int32x4_t)v32;
    if (v27.i32[0])
    {
      int32x4_t v38 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v35, (int8x16_t)v34, 0xCuLL), vnegq_f32(v33)), v34, (float32x4_t)vextq_s8(v36, (int8x16_t)v33, 0xCuLL));
      int32x4_t v37 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v38, v38), (int8x16_t)v38, 0xCuLL);
    }
    int8x16_t v39 = (int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32);
    float32x4_t v40 = v33;
    if (v27.i32[1])
    {
      int32x4_t v41 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v39, (int8x16_t)v32, 0xCuLL), vnegq_f32(v34)), v32, (float32x4_t)vextq_s8(v35, (int8x16_t)v34, 0xCuLL));
      float32x4_t v40 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v41, v41), (int8x16_t)v41, 0xCuLL);
    }
    if (v27.i32[2])
    {
      int32x4_t v27 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v36, (int8x16_t)v33, 0xCuLL), vnegq_f32(v32)), v33, (float32x4_t)vextq_s8(v39, (int8x16_t)v32, 0xCuLL));
      float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v27, v27), (int8x16_t)v27, 0xCuLL);
    }
    float v42 = (float)(*(float *)v37.i32 + v40.f32[1]) + v34.f32[2];
    if (v42 > 0.0)
    {
      float32x4_t v43 = (float32x4_t)vzip2q_s32((int32x4_t)v40, vuzp1q_s32((int32x4_t)v40, (int32x4_t)v34));
      v43.i32[2] = v37.i32[1];
      float v44 = sqrtf(v42 + 1.0);
      float32x4_t v45 = (float32x4_t)vtrn2q_s32((int32x4_t)v34, vzip2q_s32((int32x4_t)v34, v37));
      v45.i32[2] = v40.i32[0];
      float32x4_t v47 = vsubq_f32(v43, v45);
      v43.f32[3] = v44;
      v45.f32[3] = v44;
      float32x4_t v46 = vmulq_f32(v43, v45);
      v47.i32[3] = v46.i32[3];
LABEL_29:
      v46.f32[0] = 0.5 / v44;
      float32x4_t v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 0);
      goto LABEL_30;
    }
    if (*(float *)v37.i32 < v40.f32[1] || *(float *)v37.i32 < v34.f32[2])
    {
      if (v40.f32[1] <= v34.f32[2])
      {
        float v44 = sqrtf((float)((float)(v34.f32[2] + 1.0) - *(float *)v37.i32) - v40.f32[1]);
        *(float32x2_t *)v47.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v37, (int32x4_t)v40), *(float32x2_t *)v34.f32);
        float32x2_t v59 = (float32x2_t)__PAIR64__(v37.u32[1], LODWORD(v44));
        float32x2_t v60 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.f32, 0);
        *(float32x2_t *)v46.f32 = vsub_f32(*(float32x2_t *)v37.i8, v60);
        v60.f32[0] = v44;
        v60.i32[0] = vmul_f32(v59, v60).u32[0];
        v60.i32[1] = v46.i32[1];
        *(float32x2_t *)&v47.u32[2] = v60;
        goto LABEL_29;
      }
      float v52 = sqrtf((float)((float)(v40.f32[1] + 1.0) - *(float *)v37.i32) - v34.f32[2]);
      *(int32x2_t *)v27.i8 = vdup_laneq_s32((int32x4_t)v40, 2);
      int8x16_t v50 = (int8x16_t)v27;
      *(float *)v50.i32 = v52;
      v50.i32[0] = vmul_f32(*(float32x2_t *)v50.i8, (float32x2_t)__PAIR64__(v34.u32[1], LODWORD(v52))).u32[0];
      v50.i32[1] = vadd_f32(*(float32x2_t *)&v27, *(float32x2_t *)&v34).i32[1];
      int8x16_t v51 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 1), v40);
      int32x2_t v57 = (int32x2_t)vsubq_f32(v34, (float32x4_t)vdupq_laneq_s32(v37, 2)).u64[0];
      float32x4_t v58 = (float32x4_t)vextq_s8(vextq_s8(v51, v51, 4uLL), v50, 0xCuLL);
      v58.i32[3] = v57.i32[0];
    }
    else
    {
      float v52 = sqrtf((float)((float)(*(float *)v37.i32 + 1.0) - v40.f32[1]) - v34.f32[2]);
      float32x2_t v53 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.f32, 0);
      float32x2_t v54 = vadd_f32(*(float32x2_t *)v37.i8, v53);
      v53.f32[0] = v52;
      v58.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v37.u32[1], LODWORD(v52)), v53).u32[0];
      v58.i32[1] = v54.i32[1];
      float32x2_t v55 = (float32x2_t)vzip2q_s32(v37, (int32x4_t)v40).u64[0];
      LODWORD(v56) = vadd_f32(v55, *(float32x2_t *)v34.f32).u32[0];
      int32x2_t v57 = (int32x2_t)vsub_f32(v55, *(float32x2_t *)v34.f32);
      HIDWORD(v56) = v57.i32[1];
      v58.i64[1] = v56;
    }
    *(float *)v57.i32 = 0.5 / v52;
    float32x4_t v47 = (float32x4_t)vdupq_lane_s32(v57, 0);
LABEL_30:
    float32x4_t v48 = vmulq_f32(v47, v58);
    goto LABEL_31;
  }
  return 1;
}

double sub_1B6432D4C(float *a1, double a2, float a3)
{
  double v4 = a3 * a2;
  float v5 = a1[6];
  if (v5 >= 1.0)
  {
    double v6 = a1[8] + a1[10] * v4;
    double v9 = exp(-(v4 * a1[7]));
  }
  else
  {
    double v6 = exp(-(v4 * v5) * a1[7]);
    double v7 = a1[8];
    __double2 v8 = __sincos_stret(v4 * a1[9]);
    double v9 = v8.__sinval * a1[10] + v7 * v8.__cosval;
  }
  return 1.0 - v6 * v9;
}

double sub_1B6432E04(float *a1, double a2)
{
  float v2 = a1[1];
  double v3 = *a1 * 3.0;
  double v4 = -(v3 - (float)(a1[2] - *a1) * 3.0);
  double v5 = 1.0 - v3 - v4;
  int v6 = 8;
  double v7 = a2;
  do
  {
    double v8 = v7 * (v3 + (v5 * v7 - (v3 - (float)(a1[2] - *a1) * 3.0)) * v7);
    if (vabdd_f64(v8, a2) < 0.001) {
      goto LABEL_13;
    }
    double v9 = v3 + (v4 + v4 + v5 * 3.0 * v7) * v7;
    if (fabs(v9) < 0.000001) {
      break;
    }
    double v7 = v7 - (v8 - a2) / v9;
    --v6;
  }
  while (v6);
  float v10 = 0.0;
  if (a2 >= 0.0)
  {
    float v10 = 1.0;
    double v11 = 1.0;
    if (a2 <= 1.0)
    {
      double v12 = 0.0;
      double v7 = a2;
      do
      {
        double v13 = v7 * (v3 + (v5 * v7 - (v3 - (float)(a1[2] - *a1) * 3.0)) * v7);
        if (vabdd_f64(v13, a2) < 0.001) {
          break;
        }
        if (v13 >= a2) {
          double v11 = v7;
        }
        else {
          double v12 = v7;
        }
        double v7 = v12 + (v11 - v12) * 0.5;
      }
      while (v12 < v11);
LABEL_13:
      float v10 = v7;
    }
  }
  double v14 = v2 * 3.0;
  double v15 = -(v14 - (float)(a1[3] - v2) * 3.0);
  return (v14 + (v15 + (1.0 - v14 - v15) * v10) * v10) * v10;
}

double sub_1B6432F28(uint64_t a1, double a2)
{
  return sub_1B6432E04((float *)(a1 + 24), a2);
}

void sub_1B6432F30()
{
  if (!qword_1EB9956B8) {
    qword_1EB9956B8 = sub_1B63C8D10(&qword_1EB9956B8);
  }
}

__n128 sub_1B6432F74(__CFString *a1)
{
  if (qword_1EB9956B0 != -1) {
    dispatch_once(&qword_1EB9956B0, &unk_1F0FB5688);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1EB9956B8, 0x20uLL);
  *(void *)(v2 + 16) = sub_1B6432F28;
  if (@"default" == a1)
  {
    double v4 = &xmmword_1B6E50800;
  }
  else if (@"easeIn" == a1)
  {
    double v4 = &xmmword_1B6E50820;
  }
  else if (@"easeOut" == a1)
  {
    double v4 = &xmmword_1B6E50830;
  }
  else
  {
    if (@"easeInEaseOut" != a1)
    {
      *(void *)(v2 + 16) = nullsub_27;
      return result;
    }
    double v4 = &xmmword_1B6E50840;
  }
  __n128 result = (__n128)*v4;
  *(_OWORD *)(v2 + 24) = *v4;
  return result;
}

uint64_t sub_1B6433074(float a1, float a2, float a3, float a4)
{
  if (qword_1EB9956B0 != -1) {
    dispatch_once(&qword_1EB9956B0, &unk_1F0FB5688);
  }
  uint64_t result = sub_1B63C8D44(qword_1EB9956B8, 0x20uLL);
  float v9 = sqrtf(a2 / a1);
  float v10 = sqrtf(a1 * a2);
  float v11 = a3 / (float)(v10 + v10);
  if (v11 >= 1.0)
  {
    float v13 = v9 - a4;
    float v12 = 0.0;
  }
  else
  {
    float v12 = v9 * sqrtf(1.0 - (float)(v11 * v11));
    float v13 = (float)-(float)(a4 - (float)(v11 * v9)) / v12;
  }
  *(float *)(result + 24) = v11;
  *(float *)(result + 28) = v9;
  *(_DWORD *)(result + 32) = 1065353216;
  *(float *)(result + 36) = v12;
  *(float *)(result + 40) = v13;
  *(void *)(result + 16) = sub_1B6432D4C;
  return result;
}

void sub_1B6433144()
{
  if (!qword_1EB9956A8)
  {
    sub_1B6432F74(@"default");
    qword_1EB9956A8 = v0;
  }
}

uint64_t sub_1B6433180(float a1, float a2, float a3, float a4)
{
  if (qword_1EB9956B0 != -1) {
    dispatch_once(&qword_1EB9956B0, &unk_1F0FB5688);
  }
  uint64_t result = sub_1B63C8D44(qword_1EB9956B8, 0x20uLL);
  *(float *)(result + 24) = a1;
  *(float *)(result + 28) = a2;
  *(float *)(result + 32) = a3;
  *(float *)(result + 36) = a4;
  *(void *)(result + 16) = sub_1B6432F28;
  return result;
}

uint64_t sub_1B6433204(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"timingFunc");
  }
  return a1 + 24;
}

BOOL sub_1B6433250(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"timingFunc");
  }
  return *(void *)(a1 + 16) == (void)nullsub_27;
}

uint64_t sub_1B64332B0(uint64_t a1, __n128 a2, __n128 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unsigned __int32 v10 = a3.n128_u32[0];
  unint64_t v11 = a2.n128_u64[0];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a5, a6, a7, a8, a9, a10, (uint64_t)"timingFunc");
  }
  float v13 = *(uint64_t (**)(uint64_t, __n128, __n128))(a1 + 16);
  a2.n128_u64[0] = v11;
  a3.n128_u32[0] = v10;

  return v13(a1, a2, a3);
}

CFStringRef sub_1B6433330(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXTimingFunction>");
}

CFStringRef sub_1B6433364(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXTimingFunction>");
}

uint64_t sub_1B6435F14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B649F390(a2, a2, a3, a4, a5, a6, a7, a8)) {
    return 1;
  }
  if (!sub_1B649FCB4(a2, v10, v11, v12, v13, v14, v15, v16))
  {
    float32x4_t v25 = (const void *)sub_1B649F5F4(a2, v18, v19, v20, v21, v22, v23, v24);
    if (v25)
    {
      if (sub_1B63F49F8(v25, 0, (uint64_t)&v39, v26, v27, v28, v29, v30))
      {
        int32x4_t v38 = (float32x4_t *)sub_1B64A01D4(a2, v31, v32, v33, v34, v35, v36, v37);
        sub_1B6403C2C(&v39, v38, &v39);
        sub_1B6403B98(*(float32x4_t **)(a1 + 32), *(float32x4_t **)(a1 + 32), &v39);
      }
    }
  }
  return 0;
}

void sub_1B643670C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1B643670C(a1, *a2);
    sub_1B643670C(a1, a2[1]);
    operator delete(a2);
  }
}

void sub_1B6436760(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationStackInit called twice", a3, a4, a5, a6, a7, a8, (uint64_t)"animationStack->_valid == false");
  }
  *a1 = 1;
}

void sub_1B64367B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(*(void *)(*(void *)(a2 + 16) + 168) + 20);
  if (v8)
  {
    int v9 = a4;
    uint64_t v13 = 0;
    uint64_t v14 = *(void *)(a2 + 224);
    uint64_t v15 = 4 * v8;
    do
    {
      uint64_t v16 = *(int *)(v14 + v13);
      if (v16 != -1)
      {
        float32x4_t v17 = (uint64_t *)sub_1B66214AC(*(void *)(a1 + 56), v16, a3, a4, a5, a6, a7, a8);
        uint64_t v18 = *v17;
        if (*v17
          || (sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"stackItem->_modelValueItem"), (uint64_t v18 = *v17) != 0))
        {
          int v19 = *(unsigned __int16 *)(v18 + 16);
          if (v9) {
            sub_1B660FF60(a3, v18, a3, a4, a5, a6, a7, a8);
          }
          else {
            sub_1B66100EC(a3, v18, a3, a4, a5, a6, a7, a8);
          }
          if (v19 == 1) {
            *float32x4_t v17 = 0;
          }
        }
        uint64_t v14 = *(void *)(a2 + 224);
        *(_DWORD *)(v14 + v13) = -1;
      }
      v13 += 4;
    }
    while (v15 != v13);
  }
}

void sub_1B64368A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)a1)
  {
    *(unsigned char *)a1 = 0;
    for (int i = *(void **)(a1 + 8); i; int i = (void *)i[22])
    {
      if (*(unsigned char *)(a1 + 48))
      {
        uint64_t v11 = i[2];
        if (v11) {
          BOOL v12 = (*(_WORD *)(v11 + 84) & 0x10) == 0;
        }
        else {
          BOOL v12 = 1;
        }
        sub_1B64367B4(a1, (uint64_t)i, a2, v12, a5, a6, a7, a8);
      }
      i[19] = -1;
    }
    uint64_t v13 = *(const void **)(a1 + 56);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 56) = 0;
    }
    uint64_t v14 = *(const void **)(a1 + 8);
    if (v14)
    {
      CFRelease(v14);
      *(void *)(a1 + 8) = 0;
    }
    uint64_t v15 = *(const void **)(a1 + 24);
    if (v15)
    {
      CFRelease(v15);
      *(void *)(a1 + 24) = 0;
    }
  }
}

void sub_1B643695C(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v8 = cf;
  if (a1)
  {
    if (!cf) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationStack");
  if (v8) {
LABEL_3:
  }
    CFTypeRef v8 = (CFTypeRef)sub_1B660F7E0((uint64_t)v8);
LABEL_4:
  CFTypeRef v10 = *(CFTypeRef *)(a1 + 24);
  if (v10 != v8)
  {
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 24) = 0;
    }
    if (v8) {
      CFTypeRef v11 = CFRetain(v8);
    }
    else {
      CFTypeRef v11 = 0;
    }
    *(void *)(a1 + 24) = v11;
  }
  if (v8)
  {
    CFRelease(v8);
  }
}

uint64_t sub_1B6436A18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationStack");
  }
  return *(void *)(a1 + 24);
}

void sub_1B6436A64(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v9 = cf;
  if (a1)
  {
    if (cf) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationStack");
  if (!v9) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
LABEL_4:
  if (!*(unsigned char *)a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXAnimationStack invalid", a3, a4, a5, a6, a7, a8, (uint64_t)"animationStack->_valid == true");
  }
  if (*(void *)(a1 + 8))
  {
    if (v9) {
      CFTypeRef v11 = CFRetain(v9);
    }
    else {
      CFTypeRef v11 = 0;
    }
    uint64_t v13 = *(void *)(a1 + 16);
    *(void *)(v13 + 176) = v11;
    *((void *)v9 + 21) = v13;
  }
  else
  {
    if (v9) {
      CFTypeRef v12 = CFRetain(v9);
    }
    else {
      CFTypeRef v12 = 0;
    }
    *(void *)(a1 + 8) = v12;
  }
  *(void *)(a1 + 16) = v9;
  sub_1B6436E1C(a1, 0, a3, a4, a5, a6, a7, a8);
  if (*(unsigned char *)(a1 + 128))
  {
    unsigned int v14 = *(char *)(*((void *)v9 + 3) + 34) - 3;
    if (v14 <= 5) {
      *((unsigned char *)v9 + 120) = 0x70401020202uLL >> (8 * v14);
    }
  }
  if (*(unsigned char *)(a1 + 48))
  {
    CFTypeID v15 = CFGetTypeID(v9);
    if (v15 != sub_1B6439AEC()) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected animation node class", v17, v18, v19, v20, v21, v22, (uint64_t)"CFGetTypeID(animationNode) == CFXAnimationClusterNodeGetTypeID()");
    }
    uint64_t v110 = sub_1B6422024(a3, v16, v17, v18, v19, v20, v21, v22);
    if (!v110) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"modelValueStorage");
    }
    uint64_t v29 = *((void *)v9 + 2);
    uint64_t v30 = *(unsigned int *)(*(void *)(v29 + 168) + 20);
    if (!*(void *)(a1 + 56)) {
      *(void *)(a1 + 56) = sub_1B6621374(24, *(_DWORD *)(*(void *)(v29 + 168) + 20));
    }
    *((void *)v9 + 28) = malloc_type_malloc(4 * v30, 0x100004052888210uLL);
    uint64_t v38 = sub_1B6621414(*(void *)(a1 + 56), v31, v32, v33, v34, v35, v36, v37);
    float32x4_t v111 = (void *)sub_1B6438750((uint64_t)v9, v39, v40, v41, v42, v43, v44, v45);
    if (v30)
    {
      uint64_t v46 = 0;
      float32x4_t v107 = v9;
      uint64_t v108 = v30;
      uint64_t v109 = v29;
      do
      {
        float32x4_t v47 = (__int16 *)sub_1B660C900(v111, *(const __CFArray **)(*(void *)(*(void *)(v29 + 168) + 72) + 8 * v46), 0);
        if (!sub_1B660F8C4((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54))
        {
          *(_DWORD *)(*((void *)v9 + 28) + 4 * v46) = -1;
          if (!v47) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
        uint64_t v67 = sub_1B660FCB0(v110, v47, v55, v56, v57, v58, v59, v60);
        if (v38 < 1) {
          goto LABEL_46;
        }
        uint64_t v68 = 0;
        uint64_t v69 = -1;
        uint64_t v70 = -1;
        do
        {
          uint64_t v71 = sub_1B66214AC(*(void *)(a1 + 56), v68, v61, v62, v63, v64, v65, v66);
          if (*(void *)v71)
          {
            if (v67 == *(void *)v71)
            {
              uint64_t v73 = v71;
              int v74 = *(unsigned __int8 *)(v71 + 8);
              if (v74 == sub_1B660F9A8((uint64_t)v47, v72, v61, v62, v63, v64, v65, v66))
              {
                int v75 = *(unsigned __int8 *)(v73 + 9);
                if (v75 == sub_1B660F9F4((uint64_t)v47, v72, v61, v62, v63, v64, v65, v66))
                {
                  uint64_t v70 = v68;
                  uint64_t v68 = v38;
                }
              }
            }
          }
          else
          {
            uint64_t v69 = v68;
          }
          ++v68;
        }
        while (v68 < v38);
        if (v70 != -1)
        {
          CFTypeRef v9 = v107;
          *(_DWORD *)(v107[28] + 4 * v46) = v70;
          goto LABEL_48;
        }
        CFTypeRef v9 = v107;
        if (v69 == -1)
        {
LABEL_46:
          sub_1B6621630(*(void *)(a1 + 56), 0);
          uint64_t v76 = v38 + 1;
        }
        else
        {
          uint64_t v76 = v38;
          uint64_t v38 = v69;
        }
        *(_DWORD *)(*((void *)v9 + 28) + 4 * v46) = v38;
        uint64_t v77 = sub_1B66214AC(*(void *)(a1 + 56), v38, v61, v62, v63, v64, v65, v66);
        *(void *)uint64_t v77 = v67;
        *(unsigned char *)(v77 + 8) = sub_1B660F9A8((uint64_t)v47, v78, v79, v80, v81, v82, v83, v84);
        *(unsigned char *)(v77 + 9) = sub_1B660F9F4((uint64_t)v47, v85, v86, v87, v88, v89, v90, v91);
        int v99 = sub_1B660FA40((uint64_t)v47, v92, v93, v94, v95, v96, v97, v98);
        *(void *)(v77 + 16) = sub_1B643079C(v99, *(char *)(v77 + 8), 0, 0);
        uint64_t v38 = v76;
LABEL_48:
        uint64_t v30 = v108;
        uint64_t v29 = v109;
        uint64_t v100 = *(unsigned __int8 *)(*(void *)(*(void *)(v109 + 168) + 40) + v46);
        if (sub_1B63CA534(v47[16], v72, v61, v62, v63, v64, v65, v66) != v100) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected size", v101, v102, v103, v104, v105, v106, (uint64_t)"animationCluster->_keyframes->_valueSize[index] == CFXSizeOfBaseType(target->_baseType)");
        }
LABEL_50:
        CFRelease(v47);
LABEL_51:
        ++v46;
      }
      while (v46 != v30);
    }
  }
}

void sub_1B6436E1C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a3) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"stack");
    if (a3) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"manager");
LABEL_3:
  if (*(unsigned __int8 *)(a1 + 241) != a2)
  {
    if (a2) {
      int v11 = 1;
    }
    else {
      int v11 = -1;
    }
    sub_1B6422764(a3, v11, a3, a4, a5, a6, a7, a8);
    *(unsigned char *)(a1 + 241) = a2;
  }
}

void sub_1B6436EC0(uint64_t a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (cf) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationStack");
    if (cf) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
LABEL_3:
  CFTypeRef v10 = cf + 21;
  uint64_t v11 = cf[21];
  cf[19] = -1;
  if (v11) {
    *(void *)(v11 + 176) = cf[22];
  }
  uint64_t v12 = cf[22];
  if (v12) {
    *(void *)(v12 + 168) = v11;
  }
  if (*(void **)(a1 + 8) == cf) {
    *(void *)(a1 + 8) = v12;
  }
  if (*(void **)(a1 + 16) == cf) {
    *(void *)(a1 + 16) = *v10;
  }
  *CFTypeRef v10 = 0;
  cf[22] = 0;

  CFRelease(cf);
}

BOOL sub_1B6436F98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"stack");
  }
  return *(void *)(a1 + 8) == 0;
}

id sub_1B6436FEC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  compression_stream_operation v4 = a4;
  compression_algorithm v5 = a3;
  if (!objc_msgSend_length(a1, a2, a3, a4)) {
    return 0;
  }
  memset(&v25, 0, sizeof(v25));
  if (v4)
  {
    id v7 = 0;
    if (v4 != COMPRESSION_STREAM_DECODE) {
      return v7;
    }
    int v8 = 0;
  }
  else
  {
    int v8 = 1;
  }
  if (compression_stream_init(&v25, v4, v5) == COMPRESSION_STATUS_ERROR) {
    return 0;
  }
  v25.src_ptr = (const uint8_t *)objc_msgSend_bytes(a1, v9, v10, v11, *(_OWORD *)&v25.dst_ptr, *(_OWORD *)&v25.src_ptr, v25.state);
  v25.src_size = objc_msgSend_length(a1, v12, v13, v14);
  unint64_t v15 = (unint64_t)malloc_type_malloc(0x1000uLL, 0x9A46FD1uLL);
  v25.dst_ptr = (uint8_t *)v15;
  v25.dst_size = 4096;
  id v7 = (id)objc_opt_new();
  while (1)
  {
    compression_status v16 = compression_stream_process(&v25, v8);
    if (v16) {
      break;
    }
    if (!v25.dst_size)
    {
      objc_msgSend_appendBytes_length_(v7, v17, v15, 4096);
      v25.dst_ptr = (uint8_t *)v15;
      v25.dst_size = 4096;
    }
  }
  if (v16 == COMPRESSION_STATUS_ERROR)
  {
    free((void *)v15);
    return 0;
  }
  if (v16 == COMPRESSION_STATUS_END && v25.dst_ptr > (uint8_t *)v15) {
    objc_msgSend_appendBytes_length_(v7, v17, v15, (uint64_t)&v25.dst_ptr[-v15]);
  }
  compression_stream_destroy(&v25);
  free((void *)v15);
  uint64_t v21 = objc_msgSend_length(v7, v18, v19, v20);
  objc_msgSend_setLength_(v7, v22, v21, v23);
  return v7;
}

uint64_t sub_1B643714C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](a1, sel__operateOnDataUsingCompressionAlgorithm_operation_, a3, 0);
}

uint64_t sub_1B6437154(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](a1, sel__operateOnDataUsingCompressionAlgorithm_operation_, a3, 1);
}

id sub_1B643715C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v9 = objc_msgSend_mutableCopy(a1, a2, a3, a4);
  switch(a3)
  {
    case 4:
      compression_stream v25 = (unsigned int *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v29 = (_DWORD *)objc_msgSend_bytes(v9, v26, v27, v28);
      *uint64_t v29 = *v25;
      unsigned int v30 = *v25;
      unint64_t v34 = objc_msgSend_length(a1, v31, v32, v33);
      if (v34 >= 8)
      {
        uint64_t v35 = (v34 >> 2) - 1;
        uint64_t v36 = v29 + 1;
        uint64_t v37 = v25 + 1;
        do
        {
          *v36++ = v30 - *v37;
          unsigned int v39 = *v37++;
          unsigned int v38 = v39;
          if (v39 > v30) {
            unsigned int v30 = v38;
          }
          --v35;
        }
        while (v35);
      }
      break;
    case 2:
      uint64_t v40 = (unsigned __int16 *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v44 = (_WORD *)objc_msgSend_bytes(v9, v41, v42, v43);
      _WORD *v44 = *v40;
      unsigned __int16 v45 = *v40;
      unint64_t v49 = objc_msgSend_length(a1, v46, v47, v48);
      if (v49 >= 4)
      {
        uint64_t v50 = (v49 >> 1) - 1;
        uint64_t v51 = v44 + 1;
        uint64_t v52 = v40 + 1;
        do
        {
          *v51++ = v45 - *v52;
          unsigned int v54 = (unsigned __int16)*v52++;
          unsigned __int16 v53 = v54;
          if (v54 > v45) {
            unsigned __int16 v45 = v53;
          }
          --v50;
        }
        while (v50);
      }
      break;
    case 1:
      uint64_t v10 = (unsigned __int8 *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v14 = (unsigned char *)objc_msgSend_bytes(v9, v11, v12, v13);
      *uint64_t v14 = *v10;
      unsigned __int8 v15 = *v10;
      unint64_t v19 = objc_msgSend_length(a1, v16, v17, v18);
      if (v19 >= 2)
      {
        unint64_t v20 = v19 - 1;
        uint64_t v21 = v14 + 1;
        uint64_t v22 = v10 + 1;
        do
        {
          *v21++ = v15 - *v22;
          unsigned int v24 = *v22++;
          unsigned __int8 v23 = v24;
          if (v24 > v15) {
            unsigned __int8 v15 = v23;
          }
          --v20;
        }
        while (v20);
      }
      break;
  }

  return v9;
}

id sub_1B64372FC(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v9 = objc_msgSend_mutableCopy(a1, a2, a3, a4);
  switch(a3)
  {
    case 4:
      compression_stream v25 = (unsigned int *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v29 = (_DWORD *)objc_msgSend_bytes(v9, v26, v27, v28);
      *uint64_t v29 = *v25;
      unsigned int v30 = *v25;
      unint64_t v34 = objc_msgSend_length(a1, v31, v32, v33);
      if (v34 >= 8)
      {
        uint64_t v35 = (v34 >> 2) - 1;
        uint64_t v36 = v29 + 1;
        uint64_t v37 = (int *)(v25 + 1);
        do
        {
          int v38 = *v37++;
          unsigned int v39 = v30 - v38;
          *v36++ = v30 - v38;
          if (v30 - v38 > v30) {
            unsigned int v30 = v39;
          }
          --v35;
        }
        while (v35);
      }
      break;
    case 2:
      uint64_t v40 = (unsigned __int16 *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v44 = (_WORD *)objc_msgSend_bytes(v9, v41, v42, v43);
      _WORD *v44 = *v40;
      unsigned __int16 v45 = *v40;
      unint64_t v49 = objc_msgSend_length(a1, v46, v47, v48);
      if (v49 >= 4)
      {
        uint64_t v50 = (v49 >> 1) - 1;
        uint64_t v51 = v44 + 1;
        uint64_t v52 = (__int16 *)(v40 + 1);
        do
        {
          __int16 v53 = *v52++;
          unsigned int v54 = (unsigned __int16)(v45 - v53);
          *v51++ = v45 - v53;
          if (v54 > v45) {
            unsigned __int16 v45 = v54;
          }
          --v50;
        }
        while (v50);
      }
      break;
    case 1:
      uint64_t v10 = (unsigned __int8 *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v14 = (unsigned char *)objc_msgSend_bytes(v9, v11, v12, v13);
      *uint64_t v14 = *v10;
      unsigned __int8 v15 = *v10;
      unint64_t v19 = objc_msgSend_length(a1, v16, v17, v18);
      if (v19 >= 2)
      {
        unint64_t v20 = v19 - 1;
        uint64_t v21 = v14 + 1;
        uint64_t v22 = (char *)(v10 + 1);
        do
        {
          char v23 = *v22++;
          unsigned int v24 = (v15 - v23);
          *v21++ = v15 - v23;
          if (v24 > v15) {
            unsigned __int8 v15 = v24;
          }
          --v20;
        }
        while (v20);
      }
      break;
  }

  return v9;
}

id sub_1B6437498(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v9 = objc_msgSend_mutableCopy(a1, a2, a3, a4);
  switch(a3)
  {
    case 4:
      uint64_t v22 = (_DWORD *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v26 = (_DWORD *)objc_msgSend_bytes(v9, v23, v24, v25);
      _DWORD *v26 = *v22;
      unint64_t v30 = objc_msgSend_length(a1, v27, v28, v29);
      if (v30 >= 8)
      {
        uint64_t v31 = (v30 >> 2) - 1;
        uint64_t v32 = v26 + 1;
        uint64_t v33 = v22 + 1;
        do
        {
          *v32++ = *v33 - *(v33 - 1);
          ++v33;
          --v31;
        }
        while (v31);
      }
      break;
    case 2:
      unint64_t v34 = (_WORD *)objc_msgSend_bytes(a1, v6, v7, v8);
      int v38 = (_WORD *)objc_msgSend_bytes(v9, v35, v36, v37);
      _WORD *v38 = *v34;
      unint64_t v42 = objc_msgSend_length(a1, v39, v40, v41);
      if (v42 >= 4)
      {
        uint64_t v43 = (v42 >> 1) - 1;
        uint64_t v44 = v38 + 1;
        unsigned __int16 v45 = v34 + 1;
        do
        {
          *v44++ = *v45 - *(v45 - 1);
          ++v45;
          --v43;
        }
        while (v43);
      }
      break;
    case 1:
      uint64_t v10 = (unsigned char *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v14 = (unsigned char *)objc_msgSend_bytes(v9, v11, v12, v13);
      *uint64_t v14 = *v10;
      unint64_t v18 = objc_msgSend_length(a1, v15, v16, v17);
      if (v18 >= 2)
      {
        unint64_t v19 = v18 - 1;
        unint64_t v20 = v14 + 1;
        uint64_t v21 = v10 + 1;
        do
        {
          *v20++ = *v21 - *(v21 - 1);
          ++v21;
          --v19;
        }
        while (v19);
      }
      break;
  }

  return v9;
}

id sub_1B643760C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v9 = objc_msgSend_mutableCopy(a1, a2, a3, a4);
  switch(a3)
  {
    case 4:
      uint64_t v25 = (int *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v29 = (int *)objc_msgSend_bytes(v9, v26, v27, v28);
      *uint64_t v29 = *v25;
      unint64_t v33 = objc_msgSend_length(a1, v30, v31, v32);
      if (v33 >= 8)
      {
        int v36 = *v29;
        uint64_t v35 = v29 + 1;
        int v34 = v36;
        uint64_t v37 = (v33 >> 2) - 1;
        int v38 = v25 + 1;
        do
        {
          int v39 = *v38++;
          v34 += v39;
          *v35++ = v34;
          --v37;
        }
        while (v37);
      }
      break;
    case 2:
      uint64_t v40 = (_WORD *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v44 = (_WORD *)objc_msgSend_bytes(v9, v41, v42, v43);
      _WORD *v44 = *v40;
      unint64_t v48 = objc_msgSend_length(a1, v45, v46, v47);
      if (v48 >= 4)
      {
        int v51 = (unsigned __int16)*v44;
        uint64_t v50 = v44 + 1;
        int v49 = v51;
        uint64_t v52 = (v48 >> 1) - 1;
        __int16 v53 = v40 + 1;
        do
        {
          int v54 = *v53++;
          v49 += v54;
          *v50++ = v49;
          --v52;
        }
        while (v52);
      }
      break;
    case 1:
      uint64_t v10 = (unsigned char *)objc_msgSend_bytes(a1, v6, v7, v8);
      uint64_t v14 = (unsigned char *)objc_msgSend_bytes(v9, v11, v12, v13);
      *uint64_t v14 = *v10;
      unint64_t v18 = objc_msgSend_length(a1, v15, v16, v17);
      if (v18 >= 2)
      {
        int v21 = *v14;
        unint64_t v20 = v14 + 1;
        int v19 = v21;
        unint64_t v22 = v18 - 1;
        char v23 = v10 + 1;
        do
        {
          int v24 = *v23++;
          v19 += v24;
          *v20++ = v19;
          --v22;
        }
        while (v22);
      }
      break;
  }

  return v9;
}

uint64_t sub_1B643776C(void *a1, const char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = objc_msgSend_bytes(a1, a2, a3, a4);
  unint64_t v10 = objc_msgSend_length(a1, v7, v8, v9);
  unint64_t v11 = v10 / a3;
  uint64_t v12 = malloc_type_malloc(v10 / a3 * a3, 0xCD1B45FBuLL);
  uint64_t v14 = v12;
  unsigned __int8 v15 = v12;
  if (v10 >= a3)
  {
    unint64_t v16 = 0;
    unsigned __int8 v15 = v12;
    do
    {
      unint64_t v17 = v16 + 3;
      if (v16 + 3 >= v11)
      {
        unint64_t v18 = v16 * a3;
      }
      else
      {
        unint64_t v18 = v16 * a3;
        int v19 = (unsigned __int16 *)(v6 + v16 * a3);
        switch(a3)
        {
          case 4uLL:
            int v20 = *(_DWORD *)v19;
            uint64_t v13 = (const char *)*((unsigned int *)v19 + 1);
            HIDWORD(v48) = *(_DWORD *)v19;
            LODWORD(v49) = v13;
            int v21 = *((_DWORD *)v19 + 2);
            break;
          case 2uLL:
            int v20 = *v19;
            uint64_t v13 = (const char *)v19[1];
            HIDWORD(v48) = v20;
            LODWORD(v49) = v13;
            int v21 = v19[2];
            break;
          case 1uLL:
            int v20 = *(unsigned __int8 *)v19;
            uint64_t v13 = (const char *)*((unsigned __int8 *)v19 + 1);
            HIDWORD(v48) = v20;
            LODWORD(v49) = v13;
            int v21 = *((unsigned __int8 *)v19 + 2);
            break;
          default:
            goto LABEL_19;
        }
        HIDWORD(v49) = v21;
        if (v20 != v13 && v13 != v21 && v21 != v20)
        {
          uint64_t v27 = (unsigned __int16 *)(v6 + v17 * a3);
          if (a3 == 4)
          {
            uint64_t v47 = *(void *)v27;
            int v29 = *((_DWORD *)v27 + 2);
          }
          else if (a3 == 2)
          {
            int v30 = v27[1];
            LODWORD(v47) = *v27;
            HIDWORD(v47) = v30;
            int v29 = v27[2];
          }
          else
          {
            int v28 = *((unsigned __int8 *)v27 + 1);
            LODWORD(v47) = *(unsigned __int8 *)v27;
            HIDWORD(v47) = v28;
            int v29 = *((unsigned __int8 *)v27 + 2);
          }
          unint64_t v31 = 0;
          LODWORD(v48) = v29;
          BOOL v32 = 1;
LABEL_30:
          unint64_t v33 = 0;
          unint64_t v34 = v31;
          uint64_t v13 = (const char *)*((unsigned int *)&v48 + ++v31);
          if (v31 == 3) {
            unint64_t v35 = 0;
          }
          else {
            unint64_t v35 = v34 + 1;
          }
          unsigned int v36 = *((_DWORD *)&v48 + v35 + 1);
          while (1)
          {
            if (*((_DWORD *)&v47 + v33) == v36)
            {
              int v37 = v33 > 1 ? -2 : 1;
              if (*((_DWORD *)&v47 + (v37 + v33)) == v13) {
                break;
              }
            }
            if (++v33 == 3)
            {
              BOOL v32 = v34 < 2;
              if (v31 != 3) {
                goto LABEL_30;
              }
              goto LABEL_19;
            }
          }
          unsigned int v38 = v34 + 2;
          unsigned int v39 = v34 - 1;
          if (v38 >= 3) {
            unsigned int v38 = v39;
          }
          int v40 = *((_DWORD *)&v48 + (int)v38 + 1);
          unsigned int v41 = v33 + 2;
          unsigned int v42 = v33 - 1;
          if (v41 < 3) {
            unsigned int v42 = v41;
          }
          int v43 = *((_DWORD *)&v47 + v42);
          if (v13 >= v36)
          {
            if (a3 == 4)
            {
              *(_DWORD *)unsigned __int8 v15 = v36;
              *((_DWORD *)v15 + 1) = v13;
              *((_DWORD *)v15 + 2) = v43;
              *((_DWORD *)v15 + 3) = v40;
              if (!v32) {
                goto LABEL_60;
              }
            }
            else if (a3 == 2)
            {
              *(_WORD *)unsigned __int8 v15 = v36;
              *((_WORD *)v15 + 1) = (_WORD)v13;
              *((_WORD *)v15 + 2) = v43;
              *((_WORD *)v15 + 3) = v40;
              if (!v32) {
                goto LABEL_63;
              }
            }
            else
            {
              *unsigned __int8 v15 = v36;
              v15[1] = (char)v13;
              v15[2] = v43;
              v15[3] = v40;
              if (!v32) {
                goto LABEL_22;
              }
            }
          }
          else if (a3 == 4)
          {
            *(_DWORD *)unsigned __int8 v15 = v13;
            *((_DWORD *)v15 + 1) = v36;
            *((_DWORD *)v15 + 2) = v40;
            *((_DWORD *)v15 + 3) = v43;
            if (!v32) {
              goto LABEL_60;
            }
          }
          else if (a3 == 2)
          {
            *(_WORD *)unsigned __int8 v15 = (_WORD)v13;
            *((_WORD *)v15 + 1) = v36;
            *((_WORD *)v15 + 2) = v40;
            *((_WORD *)v15 + 3) = v43;
            if (!v32) {
              goto LABEL_63;
            }
          }
          else
          {
            *unsigned __int8 v15 = (char)v13;
            v15[1] = v36;
            v15[2] = v40;
            v15[3] = v43;
            if (!v32) {
              goto LABEL_22;
            }
          }
          unint64_t v17 = v16 + 6;
          uint64_t v44 = 4 * a3;
          goto LABEL_83;
        }
      }
LABEL_19:
      int v19 = (unsigned __int16 *)(v6 + v18);
      switch(a3)
      {
        case 4uLL:
LABEL_60:
          unsigned int v24 = *(_DWORD *)v19;
          unsigned int v25 = *((_DWORD *)v19 + 1);
          unsigned int v26 = *((_DWORD *)v19 + 2);
          break;
        case 2uLL:
LABEL_63:
          unsigned int v24 = *v19;
          unsigned int v25 = v19[1];
          unsigned int v26 = v19[2];
          break;
        case 1uLL:
LABEL_22:
          unsigned int v24 = *(unsigned __int8 *)v19;
          unsigned int v25 = *((unsigned __int8 *)v19 + 1);
          unsigned int v26 = *((unsigned __int8 *)v19 + 2);
          break;
        default:
          unsigned int v26 = 0;
          unsigned int v24 = 0;
          unsigned int v25 = 0;
LABEL_69:
          switch(a3)
          {
            case 4uLL:
              *(_DWORD *)unsigned __int8 v15 = v24;
              *((_DWORD *)v15 + 1) = v25;
              uint64_t v44 = 12;
              *((_DWORD *)v15 + 2) = v26;
              break;
            case 2uLL:
              *(_WORD *)unsigned __int8 v15 = v24;
              *((_WORD *)v15 + 1) = v25;
              uint64_t v44 = 6;
              *((_WORD *)v15 + 2) = v26;
              break;
            case 1uLL:
              *unsigned __int8 v15 = v24;
              v15[1] = v25;
              uint64_t v44 = 3;
              v15[2] = v26;
              break;
            default:
              uint64_t v44 = 3 * a3;
              break;
          }
          goto LABEL_83;
      }
      if (v24 >= v25) {
        goto LABEL_69;
      }
      if (v25 >= v26)
      {
        if (a3 == 4)
        {
          *(_DWORD *)unsigned __int8 v15 = v25;
          *((_DWORD *)v15 + 1) = v26;
          uint64_t v44 = 12;
          *((_DWORD *)v15 + 2) = v24;
        }
        else if (a3 == 2)
        {
          *(_WORD *)unsigned __int8 v15 = v25;
          *((_WORD *)v15 + 1) = v26;
          uint64_t v44 = 6;
          *((_WORD *)v15 + 2) = v24;
        }
        else
        {
          *unsigned __int8 v15 = v25;
          v15[1] = v26;
          uint64_t v44 = 3;
          v15[2] = v24;
        }
      }
      else if (a3 == 4)
      {
        *(_DWORD *)unsigned __int8 v15 = v26;
        *((_DWORD *)v15 + 1) = v24;
        uint64_t v44 = 12;
        *((_DWORD *)v15 + 2) = v25;
      }
      else if (a3 == 2)
      {
        *(_WORD *)unsigned __int8 v15 = v26;
        *((_WORD *)v15 + 1) = v24;
        uint64_t v44 = 6;
        *((_WORD *)v15 + 2) = v25;
      }
      else
      {
        *unsigned __int8 v15 = v26;
        v15[1] = v24;
        uint64_t v44 = 3;
        v15[2] = v25;
      }
LABEL_83:
      v15 += v44;
      unint64_t v16 = v17;
    }
    while (v17 < v11);
  }
  uint64_t v45 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v13, (uint64_t)v14, v15 - v14, v47, v48, v49);
  free(v14);
  return v45;
}

uint64_t sub_1B6437BE4(void *a1, const char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_bytes(a1, a2, a3, a4);
  unint64_t v10 = objc_msgSend_length(a1, v7, v8, v9);
  unint64_t v11 = (char *)malloc_type_malloc((((3 * (v10 / a3)) >> 1) & 0x3FFFFFFFFFFFFFFFLL) * a3, 0x9FD4C66uLL);
  uint64_t v13 = v11;
  uint64_t v14 = v11;
  if (v10 >= a3)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 3 * a3;
    uint64_t v14 = v11;
    do
    {
      unint64_t v17 = (unsigned __int8 *)(v6 + v15 * a3);
      switch(a3)
      {
        case 1uLL:
          unsigned int v18 = *v17;
          unsigned int v20 = v17[1];
          unsigned __int8 v22 = v17[2];
          *uint64_t v14 = v18;
          v14[1] = v20;
          v14[2] = v22;
          break;
        case 2uLL:
          unsigned int v18 = *(unsigned __int16 *)v17;
          unsigned int v20 = *((unsigned __int16 *)v17 + 1);
          __int16 v21 = *((_WORD *)v17 + 2);
          *(_WORD *)uint64_t v14 = v18;
          *((_WORD *)v14 + 1) = v20;
          *((_WORD *)v14 + 2) = v21;
          break;
        case 4uLL:
          unsigned int v18 = *(_DWORD *)v17;
          uint64_t v19 = *(void *)(v17 + 4);
          *(_DWORD *)uint64_t v14 = *(_DWORD *)v17;
          *(void *)(v14 + 4) = v19;
          unsigned int v20 = v19;
          break;
        default:
          unint64_t v23 = v15 + 3;
LABEL_17:
          v14 += v16;
          goto LABEL_18;
      }
      unint64_t v23 = v15 + 3;
      v14 += v16;
      if (v18 < v20)
      {
        unint64_t v24 = v23 * a3;
        if (a3 == 4)
        {
          int v26 = *(_DWORD *)(v6 + v24);
          *(_DWORD *)uint64_t v14 = v18;
          *((_DWORD *)v14 + 1) = v26;
          *((_DWORD *)v14 + 2) = v20;
        }
        else if (a3 == 2)
        {
          __int16 v27 = *(_WORD *)(v6 + v24);
          *(_WORD *)uint64_t v14 = v18;
          *((_WORD *)v14 + 1) = v27;
          *((_WORD *)v14 + 2) = v20;
        }
        else
        {
          char v25 = *(unsigned char *)(v6 + v24);
          *uint64_t v14 = v18;
          v14[1] = v25;
          v14[2] = v20;
        }
        unint64_t v23 = v15 + 4;
        goto LABEL_17;
      }
LABEL_18:
      unint64_t v15 = v23;
    }
    while (v23 < v10 / a3);
  }
  uint64_t v28 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v12, (uint64_t)v11, v14 - v11);
  free(v13);
  return v28;
}

uint64_t sub_1B6437D6C()
{
  if (qword_1EB995510 != -1) {
    dispatch_once(&qword_1EB995510, &unk_1F0FB56A8);
  }
  return qword_1EB995518;
}

void sub_1B6437DB0()
{
  if (!qword_1EB995518) {
    qword_1EB995518 = sub_1B63C8D10(&qword_1EB995518);
  }
}

uint64_t sub_1B6437DF4()
{
  if (qword_1EB995510 != -1) {
    dispatch_once(&qword_1EB995510, &unk_1F0FB56A8);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995518, 0xA0uLL);
  sub_1B6492BF4(v0);
  return v0;
}

void sub_1B6437E54(uint64_t a1, uint64_t cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v8 = (CFTypeRef)cf;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  CFTypeRef v10 = *(CFTypeRef *)(a1 + 168);
  if (v10 != v8)
  {
    if (v10)
    {
      CFRelease(v10);
      *(void *)(a1 + 168) = 0;
    }
    if (v8) {
      CFTypeRef v8 = CFRetain(v8);
    }
    *(void *)(a1 + 168) = v8;
  }
  if (*(float *)(a1 + 72) == 0.0 && v8 != 0)
  {
    double v19 = sub_1B6425514((uint64_t)v8, cf, a3, a4, a5, a6, a7, a8);
    float v20 = v19;
    sub_1B6492D2C(a1, v20, v12, v13, v14, v15, v16, v17, v18);
  }
}

uint64_t sub_1B6437F0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(void *)(a1 + 168);
}

uint64_t sub_1B6437F58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  int v10 = a2;
  if (a1)
  {
    if (a3) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"anim");
    if (a3) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"outputAddress");
LABEL_3:
  uint64_t result = *(void *)(a1 + 168);
  if (result)
  {
    float v14 = sub_1B6425514(result, a2, a3, a4, a5, a6, a7, a8);
    float v15 = v14 * a9;
    uint64_t v16 = *(void *)(a1 + 168);
    double v17 = v15;
    uint64_t v25 = sub_1B64931A0(a1, v18, v19, v20, v21, v22, v23, v24);
    return sub_1B6425560(v16, v10, v25, a3, v26, v27, v28, v29, v17);
  }
  return result;
}

uint64_t sub_1B643804C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"animation");
  }
  uint64_t v15 = *(void *)(a1 + 168);
  if (v15)
  {
    if (sub_1B6425C1C(*(void *)(a1 + 168), a2, a3, a4, a5, a6, a7, a8) == 1
      || sub_1B6425514(v15, v16, v17, v18, v19, v20, v21, v22) == 0.0)
    {
      *(double *)v23.i64 = sub_1B6492D84(a1, v16, v17, v18, v19, v20, v21, v22);
      sub_1B64258B8(v15, v23, v31, v24, v25, v26, v27, v28, v29, v30);
    }
    unsigned int v32 = sub_1B6425734(v15, v16, v17, v18, v19, v20, v21, v22);
    if (*(unsigned char *)(v15 + 98))
    {
      unsigned int v33 = v32;
      int v92 = sub_1B642639C(v15);
      memset(__dst, 0, sizeof(__dst));
      if (v33)
      {
        unsigned int v40 = 0;
        do
        {
          unsigned int v41 = v40;
          double v48 = sub_1B64257CC(v15, v40++, v34, v35, v36, v37, v38, v39);
          if (v40 >= v33)
          {
            double v55 = v48 + v48 - sub_1B64257CC(v15, v41 - 1, v42, v43, v44, v45, v46, v47);
            if (!v41)
            {
LABEL_14:
              double v56 = v48 - (sub_1B64257CC(v15, v40, v49, v50, v51, v52, v53, v54) - v48);
              goto LABEL_15;
            }
          }
          else
          {
            double v55 = sub_1B64257CC(v15, v40, v42, v43, v44, v45, v46, v47);
            if (!v41) {
              goto LABEL_14;
            }
          }
          double v56 = sub_1B64257CC(v15, v41 - 1, v49, v50, v51, v52, v53, v54);
LABEL_15:
          float v57 = sub_1B64263C4(v15, v41);
          float v58 = sub_1B64263D0(v15, v41);
          float v59 = sub_1B64263DC(v15, v41);
          uint64_t v60 = sub_1B6426408(v15, v41);
          uint64_t v61 = sub_1B642641C(v15, v41);
          if (v92)
          {
            uint64_t v62 = v61;
            uint64_t v63 = 0;
            double v64 = v48 - v56;
            double v65 = v55 - v48;
            double v66 = v55 - v48 + v48 - v56;
            double v67 = (v55 - v48) / v66;
            double v68 = (v48 - v56) / v66;
            float v69 = (float)(1.0 - v57) * (float)(v58 + 1.0);
            double v70 = v67 * (float)(v69 * (float)(v59 + 1.0));
            float v71 = (float)(1.0 - v57) * (float)(1.0 - v58);
            double v72 = v67 * (float)(v71 * (float)(1.0 - v59));
            double v73 = v68 * (float)(v71 * (float)(v59 + 1.0));
            double v74 = v68 * (float)(v69 * (float)(1.0 - v59));
            *(float *)&double v68 = v65 * v72 + v70 * v64;
            *(float *)&double v64 = v65 * v74 + v73 * v64;
            unsigned int v93 = LODWORD(v64);
            unsigned int v94 = LODWORD(v68);
            do
            {
              sub_1B6425838(v15, v41, __dst, v35, v36, v37, v38, v39);
              float v80 = *((float *)__dst + v63);
              if (v40 >= v33)
              {
                sub_1B6425838(v15, v41 - 1, __dst, v75, v76, v77, v78, v79);
                float v86 = v80 + (float)(v80 - *((float *)__dst + v63));
              }
              else
              {
                sub_1B6425838(v15, v40, __dst, v75, v76, v77, v78, v79);
                float v86 = *((float *)__dst + v63);
              }
              if (v41)
              {
                sub_1B6425838(v15, v41 - 1, __dst, v81, v82, v83, v84, v85);
                float v87 = *((float *)__dst + v63);
              }
              else
              {
                sub_1B6425838(v15, v40, __dst, v81, v82, v83, v84, v85);
                float v87 = v80 - (float)(*((float *)__dst + v63) - v80);
              }
              double v88 = (float)(v80 - v87);
              double v89 = (float)(v86 - v80);
              *(float *)&unsigned int v90 = v72 * v89 + v70 * v88;
              *(void *)(v60 + 8 * v63) = __PAIR64__(v90, v94);
              *(float *)&double v88 = v74 * v89 + v73 * v88;
              *(void *)(v62 + 8 * v63++) = __PAIR64__(LODWORD(v88), v93);
            }
            while (v92 != v63);
          }
        }
        while (v40 != v33);
      }
    }
  }
  else
  {
    sub_1B6425734(0, a2, a3, a4, a5, a6, a7, a8);
  }
  return 1;
}

void sub_1B64383C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_8:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dest");
    if (a1) {
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  if (!a2) {
    goto LABEL_8;
  }
LABEL_3:
  if (a1) {
    goto LABEL_4;
  }
LABEL_9:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
LABEL_4:
  uint64_t v10 = *(void *)(a1 + 168);

  sub_1B6437E54(a2, v10, a3, a4, a5, a6, a7, a8);
}

id sub_1B6438474(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (const void *)a1[21];
  if (v9)
  {
    CFRelease(v9);
    a1[21] = 0;
  }

  return sub_1B6492B90(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B64384B8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXKeyframedAnimation %p>", a1);
}

CFStringRef sub_1B64384F8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXKeyframedAnimation %p>", a1);
}

double sub_1B6438538()
{
  if (!qword_1E9DDA780)
  {
    qword_1E9DDA780 = sub_1B63C8D10(&qword_1E9DDA780);
    double result = *(double *)&xmmword_1F0FB86F0;
    xmmword_1EB973940 = xmmword_1F0FB86F0;
  }
  return result;
}

uint64_t sub_1B6438590(const void *a1)
{
  if (qword_1E9DDA788 != -1) {
    dispatch_once(&qword_1E9DDA788, &unk_1F0FB56C8);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1E9DDA780, 0xD0uLL);
  uint64_t v9 = v2;
  if (v2) {
    sub_1B6438600(v2, a1, v3, v4, v5, v6, v7, v8);
  }
  return v9;
}

float sub_1B6438600(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)(a1 + 60) = 2139095039;
  *(_DWORD *)(a1 + 72) = -1082130432;
  int v10 = *(_DWORD *)(a1 + 121);
  *(void *)(a1 + 152) = -1;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(a1 + 48) = _D0;
  *(_DWORD *)(a1 + 121) = v10 | 0x24;
  sub_1B6438688(a1, a2, a3, a4, a5, a6, a7, a8);
  float v23 = sub_1B6492D84((uint64_t)a2, v16, v17, v18, v19, v20, v21, v22);
  if (v23 == 0.0)
  {
    double v24 = +[VFXTransaction animationDuration]_0();
    if (v24 == 0.0) {
      double v24 = 0.25;
    }
  }
  else
  {
    double v24 = v23;
  }
  float result = v24;
  *(float *)(a1 + 76) = result;
  return result;
}

CFTypeRef sub_1B6438688(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t sub_1B6438704(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  return *(void *)(a1 + 16);
}

uint64_t sub_1B6438750(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(void *)(a1 + 144);
}

void sub_1B643879C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  *(void *)(a1 + 144) = a2;
}

void sub_1B64387EC(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animationNode");
  }
  *(double *)(a1 + 80) = a2;
}

void sub_1B6438844(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  *(_DWORD *)(a1 + 121) |= 2u;
}

void sub_1B6438898(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animationNode");
  }
  if (*(unsigned char *)(a1 + 121)) {
    *(double *)(a1 + 80) = *(double *)(a1 + 80) + a2;
  }
}

uint64_t sub_1B6438900(uint64_t result, uint64_t a2)
{
  *(void *)(result + 184) = a2;
  return result;
}

uint64_t sub_1B6438908(uint64_t a1)
{
  return *(void *)(a1 + 184);
}

uint64_t sub_1B6438910(uint64_t result, uint64_t a2)
{
  *(void *)(result + 192) = a2;
  return result;
}

uint64_t sub_1B6438918(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

uint64_t sub_1B6438920(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  while (1)
  {
    uint64_t v1 = *(void *)(a1 + 192);
    if (v1) {
      break;
    }
    a1 = *(void *)(a1 + 40);
    if (!a1) {
      return 0;
    }
  }
  return v1;
}

CFTypeRef sub_1B6438940(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 136);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 136) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 136) = result;
  }
  return result;
}

uint64_t sub_1B64389BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return a1 + 208;
}

CFTypeRef sub_1B6438A08(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 200);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 200) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 200) = result;
  }
  return result;
}

uint64_t sub_1B6438A84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(void *)(a1 + 200);
}

uint64_t sub_1B6438AD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  return *(void *)(a1 + 40);
}

void sub_1B6438B1C(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"child");
LABEL_3:
  Mutable = *(__CFArray **)(a1 + 32);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    *(void *)(a1 + 32) = Mutable;
  }
  CFArrayAppendValue(Mutable, value);
  *((void *)value + 5) = a1;
}

CFArrayRef sub_1B6438BB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 32);
  if (result)
  {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

CFArrayRef sub_1B6438C28(uint64_t a1, CFIndex idx, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 32);
  if (result)
  {
    return (const __CFArray *)CFArrayGetValueAtIndex(result, idx);
  }
  return result;
}

void sub_1B6438CA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a2;
  uint64_t v10 = *(void *)(a1 + 112);
  if (!v10)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node->_cumulativeCache");
    uint64_t v10 = *(void *)(a1 + 112);
  }
  unsigned int v11 = *(_DWORD *)v10;
  if (*(_DWORD *)v10 != v8)
  {
    uint64_t v12 = *(void *)(v10 + 8);
    if (!v12)
    {
      int v13 = sub_1B65625B4(*(void *)(v10 + 16), a2, a3, a4, a5, a6, a7, a8);
      uint64_t v12 = sub_1B65623D0(v13, 1, v14, v15, v16, v17, v18, v19);
      uint64_t v20 = *(void *)(a1 + 112);
      *(void *)(v20 + 8) = v12;
      unsigned int v11 = *(_DWORD *)v20;
    }
    if (v11 - 1 >= v8)
    {
      uint64_t v21 = (void *)sub_1B6562568(v12, a2, a3, a4, a5, a6, a7, a8);
      sub_1B6562704(*(void *)(*(void *)(a1 + 112) + 16), v21, v22, v23, v24, v25, v26, v27);
      unsigned int v11 = 1;
    }
    unsigned int v28 = v8 - v11;
    if (v8 > v11)
    {
      do
      {
        sub_1B6562BD4(*(void *)(*(void *)(a1 + 112) + 8), *(void *)(*(void *)(a1 + 112) + 16), *(void *)(*(void *)(a1 + 112) + 8), a4, a5, a6, a7, a8, v29);
        --v28;
      }
      while (v28);
    }
    **(_DWORD **)(a1 + 112) = v8;
  }
}

double sub_1B6438D78(uint64_t a1, BOOL *a2, unsigned char *a3, BOOL *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  if ((*(unsigned char *)(a1 + 123) & 0x60) != 0) {
    a9 = *(double *)(a1 + 128);
  }
  if (a9 != *(float *)(a1 + 60))
  {
    float v14 = a9;
    *(float *)(a1 + 60) = v14;
    __int16 v78 = 0;
    unsigned __int8 v77 = 1;
    uint64_t v15 = *(void *)(a1 + 40);
    if (v15)
    {
      sub_1B6438D78(v15, (char *)&v78 + 1, &v78, &v77, a9);
      int v17 = v77;
      if (!v77)
      {
        uint64_t v41 = 0;
        int v42 = 0;
        double v40 = 0.0;
        double v43 = 0.0;
        goto LABEL_98;
      }
      a9 = v16;
    }
    uint64_t v18 = *(void *)(a1 + 16);
    float v26 = sub_1B6492D84(v18, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
    if (*(void *)(a1 + 40)) {
      double v27 = sub_1B64396D4(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    else {
      double v27 = *(double *)(a1 + 80);
    }
    float v28 = *(float *)(a1 + 52);
    float v29 = v28 * sub_1B6493464(v18, v19, v20, v21, v22, v23, v24, v25);
    double v38 = sub_1B64933C0(v18, v30, v31, v32, v33, v34, v35, v36);
    if (v26 > 0.0) {
      float v39 = v26;
    }
    else {
      float v39 = 1.0;
    }
    if (v29 < 0.0) {
      HIBYTE(v78) ^= 1u;
    }
    double v40 = a9 - v27;
    if (v26 == 0.0)
    {
      uint64_t v41 = 0;
      int v42 = 0;
      double v43 = 0.0;
    }
    else
    {
      if (v29 == 0.0) {
        double v43 = *(float *)(a1 + 64);
      }
      else {
        double v43 = v40 * fabsf(v29) / v39;
      }
      double v40 = v43;
      if (v43 < 0.0)
      {
        char v44 = sub_1B649399C(v18, v37, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
        double v40 = 0.0;
        if ((v44 & 2) == 0)
        {
          uint64_t v41 = 0;
          int v42 = 0;
          int v17 = 0;
          goto LABEL_98;
        }
      }
      float v45 = *(float *)(v18 + 76);
      BOOL v46 = v45 == 3.4028e38 || v45 == INFINITY;
      __int16 v47 = *(_WORD *)(v18 + 84);
      if ((v47 & 1) != 0 || (uint64_t v41 = 0, v48 = 1.0, v45 != 0.0) && v45 != 1.0)
      {
        if (v45 == 0.0) {
          float v48 = 1.0;
        }
        else {
          float v48 = *(float *)(v18 + 76);
        }
        if (v46)
        {
          double v49 = v43 * 0.5;
          if ((v47 & 1) == 0) {
            double v49 = v43;
          }
          uint64_t v41 = (int)v49;
        }
        else
        {
          if (v47) {
            float v48 = v48 + v48;
          }
          double v50 = v43 * 0.5;
          if ((v47 & 1) == 0) {
            double v50 = v43;
          }
          uint64_t v41 = (int)v50;
          double v43 = v43 / v48;
        }
      }
      int v51 = !v46;
      if (v43 < 1.0) {
        int v51 = 0;
      }
      if ((_BYTE)v78) {
        int v42 = 1;
      }
      else {
        int v42 = v51;
      }
      double v52 = *(double *)(a1 + 88);
      if (v52 != 0.0 && v52 + *(double *)(a1 + 104) < a9) {
        int v42 = 1;
      }
      if (v43 > 1.0 && v42 != 0)
      {
        if (((v47 & 0x10) == 0 || (*(unsigned char *)(a1 + 121) & 0x40) != 0 || *(void *)(a1 + 40))
          && (sub_1B649399C(v18, v37, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8) & 1) == 0)
        {
          int v17 = 0;
          int v42 = 1;
          double v40 = 0.0;
          goto LABEL_98;
        }
        double v40 = v48;
        double v43 = 1.0;
        if (v46) {
          double v40 = 1.0;
        }
      }
      double v54 = v39;
      double v55 = v38 / v54;
      if (v29 < 0.0) {
        double v55 = -(v38 / v54);
      }
      if (v38 == 0.0) {
        double v56 = v40;
      }
      else {
        double v56 = v55 + v40;
      }
      if (v38 == 0.0) {
        double v57 = 0.0;
      }
      else {
        double v57 = v55;
      }
      if (v56 <= 1.0)
      {
        double v58 = v56;
        if (v56 < 0.0) {
          double v58 = fmod(v56, 1.0) + 1.0;
        }
      }
      else
      {
        double v58 = fmod(v56, 1.0);
      }
      if (*(_WORD *)(v18 + 84))
      {
        if (v43 < 1.0 || v46)
        {
          BOOL v60 = v56 < 0.0;
          double v61 = (double)(int)v56;
          double v62 = 1.0 - v56;
        }
        else
        {
          double v63 = v57 + v48;
          BOOL v60 = v63 > 0.0;
          double v62 = (double)(int)v63;
          double v61 = 1.0 - v63;
        }
        double v64 = v60 ? v62 : v61;
        if (v29 < 0.0 == (((int)v64 & 1) == 0))
        {
          HIBYTE(v78) ^= 1u;
          double v58 = 1.0 - v58;
        }
      }
      if (v29 >= 0.0) {
        double v65 = v58;
      }
      else {
        double v65 = 1.0 - v58;
      }
      uint64_t v66 = sub_1B6493034(v18, v37, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
      if (v66)
      {
        if (v65 >= 0.0 && v65 <= 1.0)
        {
          v68.n128_f64[0] = v65;
          v69.n128_f32[0] = v26;
          sub_1B64332B0(v66, v68, v69, v67, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
          double v65 = v71;
        }
      }
      double v40 = v65 * v54;
    }
    int v17 = 128;
LABEL_98:
    float v72 = v43;
    unsigned int v73 = *(_DWORD *)(a1 + 121) & 0xFFFFFC7F | (HIBYTE(v78) << 9);
    float v74 = v40;
    *(float *)(a1 + 64) = v72;
    *(float *)(a1 + 68) = v74;
    if (v42)
    {
      if (*(void *)(a1 + 40)) {
        int v75 = v78 << 8;
      }
      else {
        int v75 = 256;
      }
    }
    else
    {
      int v75 = 0;
    }
    *(_DWORD *)(a1 + 121) = v73 | v17 | v75;
    if (*(void *)(a1 + 112)) {
      sub_1B6438CA0(a1, v41, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
    }
  }
  if (a2) {
    *a2 = (*(_DWORD *)(a1 + 121) & 0x200) != 0;
  }
  if (a3) {
    *a3 = *(unsigned char *)(a1 + 122) & 1;
  }
  if (a4) {
    *a4 = (*(_DWORD *)(a1 + 121) & 0x80) != 0;
  }
  return *(float *)(a1 + 68);
}

float sub_1B6439228(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
  }
  if (*(void *)(a1 + 40)) {
    sub_1B6439228(a9);
  }
  else {
    float v11 = 1.0;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  float v13 = v11 * (float)(*(float *)(v12 + 104) * *(float *)(a1 + 48));
  if (*(float *)(v12 + 108) != 0.0 || *(float *)(v12 + 112) != 0.0)
  {
    float v14 = *(float *)(a1 + 64);
    if (v14 < 0.0) {
      float v14 = 0.0;
    }
    float v15 = fminf(v14, 1.0);
    float v16 = *(float *)(v12 + 76);
    if (v16 == INFINITY || v16 == 3.4028e38) {
      float v18 = sub_1B6492D84(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      float v18 = sub_1B6492DD0(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
    }
    float v19 = *(float *)(v12 + 108);
    float v20 = v15 * v18;
    if (v19 != 0.0 && v20 < v19) {
      float v13 = v20 / v19 * v13;
    }
    float v22 = *(float *)(v12 + 112);
    if (v22 != 0.0)
    {
      float v23 = *(float *)(v12 + 76);
      BOOL v24 = v23 == INFINITY || v23 == 3.4028e38;
      if (!v24 && (*(_WORD *)(v12 + 84) & 0x28) != 0x20)
      {
        float v25 = (float)(1.0 - v15) * v18;
        if (v25 >= 0.0 && v25 < v22) {
          float v13 = v25 / v22 * v13;
        }
      }
    }
  }
  double v27 = *(double *)(a1 + 104);
  if (v27 != 0.0)
  {
    double v28 = 1.0 - (a9 - *(double *)(a1 + 96)) / v27;
    if (v28 <= 0.0) {
      double v28 = 0.0;
    }
    float v29 = v28;
    float v13 = v13 * v29;
    if (v29 == 0.0)
    {
      int v30 = *(_DWORD *)(a1 + 121);
      if ((v30 & 8) != 0) {
        *(_DWORD *)(a1 + 121) = v30 & 0xFFFFFFD3 | 4;
      }
    }
  }
  return v13;
}

uint64_t sub_1B6439404(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  do
  {
    if (!a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animationNode");
    }
    uint64_t result = sub_1B64931F0(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      break;
    }
    a1 = *(void *)(a1 + 40);
  }
  while (a1);
  return result;
}

void sub_1B643946C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  float v10 = *(float *)(a1 + 52);
  if (v10 != a9)
  {
    if (*(unsigned char *)(a1 + 121))
    {
      uint64_t v12 = *(void *)(a1 + 16);
      float v13 = *(float *)(v12 + 80);
      float v14 = v10 * v13;
      if (sub_1B649394C(v12, a2, a3, a4, a5, a6, a7, a8))
      {
        sub_1B65C26E4();
      }
      else
      {
        uint64_t v23 = *(void *)(a1 + 184);
        if (v23)
        {
          double v22 = sub_1B6422718(v23, v15, v16, v17, v18, v19, v20, v21);
        }
        else
        {
          sub_1B63F2F54(16, @"Error: CFXAnimationNodeChangeSpeed - can't ensure animation continuity since animation manager is dead", v16, v17, v18, v19, v20, v21, v26);
          double v22 = 0.0;
        }
      }
      float v24 = v13 * a9;
      if (v14 == 0.0) {
        double v25 = (float)(*(float *)(a1 + 64) * *(float *)(a1 + 76));
      }
      else {
        double v25 = (v22 - *(double *)(a1 + 80)) * v14;
      }
      if (v24 != 0.0) {
        *(double *)(a1 + 80) = -(v25 / v24 - v22);
      }
    }
    *(float *)(a1 + 52) = a9;
  }
}

CFTypeRef sub_1B6439544(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 24);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 24) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 24) = result;
  }
  return result;
}

BOOL sub_1B6439598(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 123) & 0x60) != 0;
}

uint64_t sub_1B64395A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return (*(unsigned __int8 *)(a1 + 123) >> 5) & 1;
}

void sub_1B64395F8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if (a2) {
    int v10 = 0x200000;
  }
  else {
    int v10 = 0;
  }
  *(_DWORD *)(a1 + 121) = *(_DWORD *)(a1 + 121) & 0xFFDFFFFF | v10;
}

void sub_1B6439660(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  if (a2) {
    int v10 = 0x400000;
  }
  else {
    int v10 = 0;
  }
  *(_DWORD *)(a1 + 121) = *(_DWORD *)(a1 + 121) & 0xFFBFFFFF | v10;
}

uint64_t sub_1B64396C8(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 123) >> 6) & 1;
}

double sub_1B64396D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"animation");
  }
  return *(double *)(a1 + 128);
}

void sub_1B6439720(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"animation");
  }
  *(double *)(a1 + 128) = a2;
}

uint64_t sub_1B6439778(uint64_t a1, const void *a2, void *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"animationGroup");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v12 = sub_1B643981C(a1, a2, a3);
  sub_1B6438940(v12, a4, v13, v14, v15, v16, v17, v18);
  return v12;
}

uint64_t sub_1B643981C(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v6 = sub_1B6438590(a2);
  CFIndex v14 = sub_1B6541028((uint64_t)a2, v7, v8, v9, v10, v11, v12, v13);
  if (v14 >= 1)
  {
    CFIndex v21 = v14;
    for (CFIndex i = 0; v21 != i; ++i)
    {
      uint64_t v23 = sub_1B6541084((uint64_t)a2, i, v15, v16, v17, v18, v19, v20);
      if (sub_1B6492CFC(v23))
      {
        int v30 = (void *)sub_1B643981C(a1, v23, a3);
        if (v30)
        {
          uint64_t v31 = v30;
          sub_1B6438B1C(v6, v30, v15, v16, v17, v18, v19, v20);
LABEL_10:
          CFRelease(v31);
        }
      }
      else
      {
        uint64_t v32 = sub_1B6492C1C((uint64_t)v23, a3, v24, v25, v26, v27, v28, v29);
        uint64_t v31 = v32;
        if (v23)
        {
          uint64_t v33 = (void *)sub_1B6438590(v23);
          sub_1B6438B1C(v6, v33, v34, v35, v36, v37, v38, v39);
          CFRelease(v33);
          if (v31)
          {
            sub_1B6421924(a1, (uint64_t)v33, v31, v16, v17, v18, v19, v20);
            goto LABEL_10;
          }
        }
        else if (v32)
        {
          goto LABEL_10;
        }
      }
    }
  }
  return v6;
}

uint64_t sub_1B6439928(uint64_t a1, const void *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"manager");
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"animationCluster");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = sub_1B64399B4(a2);
  sub_1B6438940(v10, a4, v11, v12, v13, v14, v15, v16);
  return v10;
}

uint64_t sub_1B64399B4(const void *a1)
{
  if (qword_1E9DDA798 != -1) {
    dispatch_once(&qword_1E9DDA798, &unk_1F0FB6248);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1E9DDA790, 0xD8uLL);
  sub_1B6438600(v2, a1, v3, v4, v5, v6, v7, v8);
  return v2;
}

uint64_t sub_1B6439A1C(uint64_t a1, const void *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_6:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"animation");
    if (a3) {
      goto LABEL_4;
    }
LABEL_7:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"target");
    goto LABEL_4;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"manager");
  if (!a2) {
    goto LABEL_6;
  }
LABEL_3:
  if (!a3) {
    goto LABEL_7;
  }
LABEL_4:
  uint64_t v12 = sub_1B6438590(a2);
  sub_1B6438940(v12, a4, v13, v14, v15, v16, v17, v18);
  sub_1B6421924(a1, v12, a3, v19, v20, v21, v22, v23);
  return v12;
}

uint64_t sub_1B6439AEC()
{
  if (qword_1E9DDA798 != -1) {
    dispatch_once(&qword_1E9DDA798, &unk_1F0FB6248);
  }
  return qword_1E9DDA790;
}

double sub_1B6439B30()
{
  if (!qword_1E9DDA790)
  {
    qword_1E9DDA790 = sub_1B63C8D10(&qword_1E9DDA790);
    double result = *(double *)&xmmword_1F0FB86E0;
    xmmword_1EB9736B8 = xmmword_1F0FB86E0;
  }
  return result;
}

void sub_1B6439B8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v9 = *(const __CFArray **)(a1 + 32);
  if (v9)
  {
    CFIndex Count = CFArrayGetCount(v9);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0; i != v11; ++i)
        *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i) + 5) = 0;
    }
    CFRelease(*(CFTypeRef *)(a1 + 32));
  }
  if (*(void *)(a1 + 200))
  {
    uint64_t v13 = *(void (**)(uint64_t))(a1 + 216);
    if (!v13 || (v13(a1), *(void *)(a1 + 200)))
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Completion item will be released without having handled a completion or interruption event. This can lead to an inconsistent state.", a3, a4, a5, a6, a7, a8, (uint64_t)"node->_completionItem == NULL");
      uint64_t v14 = *(const void **)(a1 + 200);
      if (v14)
      {
        CFRelease(v14);
        *(void *)(a1 + 200) = 0;
      }
    }
  }
  uint64_t v15 = *(const void **)(a1 + 16);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v16 = *(const void **)(a1 + 136);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 136) = 0;
  }
  uint64_t v17 = *(const void **)(a1 + 24);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v18 = *(CFTypeRef **)(a1 + 112);
  if (v18)
  {
    if (v18[1])
    {
      CFRelease(v18[1]);
      uint64_t v18 = *(CFTypeRef **)(a1 + 112);
      v18[1] = 0;
    }
    if (v18[3])
    {
      CFRelease(v18[3]);
      uint64_t v18 = *(CFTypeRef **)(a1 + 112);
      v18[3] = 0;
    }
    if (v18[2])
    {
      CFRelease(v18[2]);
      uint64_t v18 = *(CFTypeRef **)(a1 + 112);
      v18[2] = 0;
    }
  }
  free(v18);
  uint64_t v19 = *(const void **)(a1 + 176);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 176) = 0;
  }
}

CFStringRef sub_1B6439CDC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationNode %p>", a1);
}

CFStringRef sub_1B6439D1C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationNode %p>", a1);
}

void sub_1B6439D5C(uint64_t a1, void *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((void *)(a1 + 52) == __dst) {
    sub_1B643946C(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, *__src);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

void sub_1B6439D84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B6439B8C(a1, a2, a3, a4, a5, a6, a7, a8);
  CFArrayRef v9 = *(void **)(a1 + 224);

  free(v9);
}

CFStringRef sub_1B6439DBC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationClusterNode %p>", a1);
}

CFStringRef sub_1B6439DFC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAnimationClusterNode %p>", a1);
}

void sub_1B6439E3C(uint64_t a1, void *__dst, float *__src, size_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((void *)(a1 + 52) == __dst) {
    sub_1B643946C(a1, (uint64_t)__dst, (uint64_t)__src, __n, a5, a6, a7, a8, *__src);
  }
  else {
    memcpy(__dst, __src, __n);
  }
}

__CFString *sub_1B6439E60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  if (*(_DWORD *)(a1 + 96) != 1) {
    return 0;
  }
  CFURLRef v9 = *(const __CFURL **)(a1 + 88);
  if (!v9) {
    return 0;
  }
  CFStringRef v10 = CFURLCopyPathExtension(v9);
  if (!v10) {
    return 0;
  }
  CFStringRef v11 = v10;
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(0, 0, v10);
  CFStringLowercase(MutableCopy, 0);
  CFRelease(v11);
  return MutableCopy;
}

uint64_t sub_1B6439EF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  if (*(_DWORD *)(a1 + 96) == 1) {
    return *(void *)(a1 + 88);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B6439F58()
{
  if (qword_1EB9954E8 != -1) {
    dispatch_once(&qword_1EB9954E8, &unk_1F0FB56E8);
  }
  return qword_1EB9954F0;
}

void sub_1B6439F9C()
{
  if (!qword_1EB9954F0)
  {
    qword_1EB9954F0 = sub_1B63C8D10(&qword_1EB9954F0);
    qword_1EB9840A0 = (uint64_t)sub_1B643C8F8;
  }
}

uint64_t sub_1B6439FF4()
{
  if (qword_1EB9954E8 != -1) {
    dispatch_once(&qword_1EB9954E8, &unk_1F0FB56E8);
  }
  uint64_t result = sub_1B63C8D44(qword_1EB9954F0, 0x70uLL);
  *(unsigned char *)(result + 116) &= 0xFCu;
  *(_DWORD *)(result + 120) = 1;
  return result;
}

uint64_t sub_1B643A054(const void *a1)
{
  uint64_t v2 = sub_1B6439FF4();
  if (v2)
  {
    *(void *)(v2 + 88) = CFRetain(a1);
    *(_DWORD *)(v2 + 96) = 1;
  }
  return v2;
}

uint64_t sub_1B643A098(const void *a1)
{
  uint64_t v2 = sub_1B6439FF4();
  if (v2)
  {
    *(void *)(v2 + 88) = CFRetain(a1);
    *(_DWORD *)(v2 + 96) = 2;
  }
  return v2;
}

uint64_t sub_1B643A0DC(uint64_t a1, int a2, char a3, double a4)
{
  pthread_mutex_lock(&stru_1E9DCA0E8);
  if (*(void *)(a1 + 72)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. image has already compression infos", v8, v9, v10, v11, v12, v13, (uint64_t)"image->_textureRawData == NULL");
  }
  *(void *)(a1 + 72) = malloc_type_calloc(1uLL, 0x28uLL, 0x1020040E4F71BD7uLL);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  uint64_t v15 = *(void *)(a1 + 72);
  *(void *)(v15 + 32) = Mutable;
  *(_DWORD *)uint64_t v15 = a2;
  *(unsigned char *)(a1 + 80) &= ~2u;
  *(double *)(a1 + 104) = a4;
  *(unsigned char *)(a1 + 116) = *(unsigned char *)(a1 + 116) & 0xFE | a3 | 0xC;

  return pthread_mutex_unlock(&stru_1E9DCA0E8);
}

uint64_t sub_1B643A1CC(uint64_t a1)
{
  pthread_mutex_lock(&stru_1E9DCA0E8);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v2, v3, v4, v5, v6, v7, (uint64_t)"image");
  }
  if ((*(unsigned char *)(a1 + 80) & 2) != 0) {
    *(unsigned char *)(a1 + 116) &= ~8u;
  }
  sub_1B643A59C(a1);
  uint64_t v8 = *(void *)(a1 + 72);
  pthread_mutex_unlock(&stru_1E9DCA0E8);
  return v8;
}

CFURLRef sub_1B643A250(CFStringRef filePath)
{
  CFURLRef result = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], filePath, kCFURLPOSIXPathStyle, 0);
  if (result)
  {
    CFURLRef v2 = result;
    uint64_t v3 = sub_1B643A054(result);
    CFRelease(v2);
    return (CFURLRef)v3;
  }
  return result;
}

uint64_t sub_1B643A2A4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = 0;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  do
  {
    if (!a1[v9])
    {
      sub_1B63F2F54(16, @"Error: Cannot build cubemap from array of images because image at index %d is NULL", a3, a4, a5, a6, a7, a8, v9);
      return 0;
    }
    ++v9;
  }
  while (v9 != 6);
  uint64_t v10 = 0;
  size_t v11 = 0;
  do
  {
    double v12 = sub_1B643A59C(a1[v10], a2, a3, a4, a5, a6, a7, a8);
    if (*(float *)&v12 != *((float *)&v12 + 1))
    {
      sub_1B63F2F54(16, @"Error: Cannot build cubemap from array of images because image at index %d is not square: %fx%f", a3, a4, a5, a6, a7, a8, v10);
      return 0;
    }
    float v13 = floorf(*(float *)&v12);
    if (v10)
    {
      float v14 = floorf(*((float *)&v12 + 1));
      if (v13 != (float)v11 || v14 != (float)v11)
      {
        sub_1B63F2F54(16, @"Error: Cannot build cubemap from array of images because image at index %d (%fx%f) does not have the expected size (%zux%zu)", a3, a4, a5, a6, a7, a8, v10);
        return 0;
      }
    }
    else
    {
      size_t v11 = (unint64_t)v13;
    }
    ++v10;
  }
  while (v10 != 6);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  while (1)
  {
    uint64_t v18 = sub_1B643A1CC(a1[v16]);
    if (!v18) {
      break;
    }
    if (v16 * 8)
    {
      if (!sub_1B643A9B8(v17, v18)) {
        break;
      }
    }
    else
    {
      uint64_t v17 = v18;
    }
    if (++v16 == 6)
    {
      uint64_t v26 = (int *)sub_1B643A1CC(*a1);
      uint64_t v27 = sub_1B6439FF4();
      *(float *)&double v28 = (float)v11;
      *((float *)&v28 + 1) = (float)(6 * v11);
      sub_1B643A0DC(v27, *v26, 0, v28);
      *(unsigned char *)(v27 + 116) |= 0x38u;
      *(_DWORD *)(v27 + 120) = 5;
      uint64_t v29 = sub_1B643A1CC(v27);
      sub_1B643AA34(v29, (uint64_t)v26);
      for (uint64_t i = 0; i != 6; ++i)
      {
        uint64_t v31 = sub_1B643A1CC(a1[i]);
        CFArrayAppendValue(*(CFMutableArrayRef *)(v29 + 32), *(const void **)(v31 + 32));
      }
      return v27;
    }
  }
  uint64_t v33 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  *(_OWORD *)image = 0u;
  do
  {
    uint64_t v34 = sub_1B643AA68(a1[v33], v19, v20, v21, v22, v23, v24, v25);
    if (!v34)
    {
      sub_1B63F2F54(16, @"Error: Cannot build cubemap from array of images because conversion to CGImageRef of image at index %d failed", v20, v21, v22, v23, v24, v25, v33);
      uint64_t v27 = 0;
      goto LABEL_35;
    }
    image[v33++] = v34;
  }
  while (v33 != 6);
  ColorSpace = CGImageGetColorSpace(image[0]);
  uint64_t v36 = CGBitmapContextCreate(0, v11, 6 * v11, 8uLL, 4 * v11, ColorSpace, 0x4001u);
  double v37 = (double)v11;
  for (uint64_t j = 5; j != -1; --j)
  {
    v46.origin.x = 0.0;
    v46.origin.y = 0.0;
    v46.size.double width = v37;
    v46.size.height = v37;
    CGContextDrawImage(v36, v46, image[j]);
    CGContextTranslateCTM(v36, 0.0, v37);
  }
  uint64_t v39 = CGBitmapContextCreateImage(v36);
  uint64_t v27 = sub_1B643AD04(v39);
  *(_DWORD *)(v27 + 120) = 5;
  CGImageRelease(v39);
  CGContextRelease(v36);
LABEL_35:
  for (uint64_t k = 0; k != 6; ++k)
  {
    CGImageRef v41 = image[k];
    if (v41)
    {
      CFRelease(v41);
      image[k] = 0;
    }
  }
  return v27;
}

double sub_1B643A59C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 116) & 8) == 0)
  {
    *(void *)(a1 + 104) = 0;
    if (sub_1B65A9104(a1, a2, a3, a4, a5, a6, a7, a8))
    {
      if sub_1B63CC3B8() && (sub_1B65A9360(a1)) {
        goto LABEL_62;
      }
      if ((sub_1B65172D0(a1, v16, v17, v18, v19, v20, v21, v22) & 1) == 0)
      {
LABEL_9:
        if ((sub_1B63CC3B8() & 1) == 0 && *(_DWORD *)(a1 + 96) == 1)
        {
          int v30 = *(void **)(a1 + 88);
          if (v30)
          {
            uint64_t v31 = objc_msgSend_URLByDeletingPathExtension(v30, v23, v24, v25);
            uint64_t v34 = (const void *)objc_msgSend_URLByAppendingPathExtension_(v31, v32, @"pvrtc", v33);
            if (sub_1B65D7E88((const __CFURL *)v34))
            {
              uint64_t v35 = *(const void **)(a1 + 88);
              if (v35 != v34)
              {
                if (v35)
                {
                  CFRelease(v35);
                  *(void *)(a1 + 88) = 0;
                }
                if (v34) {
                  CFTypeRef v36 = CFRetain(v34);
                }
                else {
                  CFTypeRef v36 = 0;
                }
                *(void *)(a1 + 88) = v36;
              }
            }
          }
        }
LABEL_20:
        if sub_1B6629184(a1, (uint64_t)v23, v24, v25, v26, v27, v28, v29) && (sub_1B6629208(a1)) {
          goto LABEL_62;
        }
        pthread_mutex_lock(&stru_1E9DCA0E8);
        double v37 = *(CGContext **)(a1 + 64);
        if (v37)
        {
          float Width = (float)CGBitmapContextGetWidth(v37);
          size_t Height = CGBitmapContextGetHeight(*(CGContextRef *)(a1 + 64));
          *(float *)&uint64_t v39 = Width;
          *((float *)&v39 + 1) = (float)Height;
          *(void *)(a1 + 104) = v39;
          pthread_mutex_unlock(&stru_1E9DCA0E8);
          goto LABEL_62;
        }
        pthread_mutex_unlock(&stru_1E9DCA0E8);
        int v47 = *(_DWORD *)(a1 + 96);
        if (v47 == 1)
        {
          CFURLRef v50 = *(const __CFURL **)(a1 + 88);
          if (v50)
          {
            CGImageSourceRef v49 = sub_1B65F41A8(v50);
            goto LABEL_30;
          }
        }
        else if (v47 == 2)
        {
          CFDataRef v48 = *(const __CFData **)(a1 + 88);
          if (v48)
          {
            CGImageSourceRef v49 = CGImageSourceCreateWithData(v48, 0);
LABEL_30:
            int v51 = v49;
            if (v49)
            {
              CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F2FF08], (const void *)*MEMORY[0x1E4F1CFC8]);
              CFDictionaryRef v53 = CGImageSourceCopyPropertiesAtIndex(v51, 0, Mutable);
              CFRelease(Mutable);
              uint64_t v54 = 0;
              if (v53)
              {
                CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v53, (const void *)*MEMORY[0x1E4F2FD00]);
                CFNumberRef v56 = (const __CFNumber *)CFDictionaryGetValue(v53, (const void *)*MEMORY[0x1E4F2FCE8]);
                CFNumberRef v57 = (const __CFNumber *)CFDictionaryGetValue(v53, (const void *)*MEMORY[0x1E4F2FCA0]);
                if (Value && v56)
                {
                  CFNumberRef v58 = v57;
                  uint64_t valuePtr = 0;
                  CFNumberGetValue(Value, kCFNumberFloatType, (char *)&valuePtr + 4);
                  CFNumberGetValue(v56, kCFNumberFloatType, &valuePtr);
                  if (v58)
                  {
                    HIDWORD(v81) = 0;
                    CFNumberGetValue(v58, kCFNumberIntType, (char *)&v81 + 4);
                    BOOL v59 = SHIDWORD(v81) > 4;
                  }
                  else
                  {
                    BOOL v59 = 0;
                  }
                  CFNumberRef v60 = (const __CFNumber *)CFDictionaryGetValue(v53, (const void *)*MEMORY[0x1E4F2F6A8]);
                  if (v60)
                  {
                    CFNumberRef v61 = v60;
                    CFNumberRef v62 = (const __CFNumber *)CFDictionaryGetValue(v53, (const void *)*MEMORY[0x1E4F2F6B0]);
                    if (v62)
                    {
                      CFNumberRef v63 = v62;
                      uint64_t v81 = 0;
                      CFNumberGetValue(v61, kCFNumberFloatType, (char *)&v81 + 4);
                      CFNumberGetValue(v63, kCFNumberFloatType, &v81);
                      if (*((float *)&v81 + 1) != *(float *)&v81 && *(float *)&v81 > 0.01)
                      {
                        float v64 = *(float *)&v81 / *((float *)&v81 + 1);
                        if (*(float *)&v81 <= *((float *)&v81 + 1)) {
                          float v64 = 1.0;
                        }
                        if (*((float *)&v81 + 1) <= *(float *)&v81) {
                          float v65 = 1.0;
                        }
                        else {
                          float v65 = *((float *)&v81 + 1) / *(float *)&v81;
                        }
                        if (v59) {
                          float v66 = v64;
                        }
                        else {
                          float v66 = v65;
                        }
                        if (!v59) {
                          float v65 = v64;
                        }
                        *(float *)&uint64_t valuePtr = v65 * *(float *)&valuePtr;
                        *((float *)&valuePtr + 1) = v66 * *((float *)&valuePtr + 1);
                      }
                    }
                  }
                  float v67 = *(float *)&valuePtr;
                  if (v59) {
                    *(float *)&uint64_t v68 = *(float *)&valuePtr;
                  }
                  else {
                    *(float *)&uint64_t v68 = *((float *)&valuePtr + 1);
                  }
                  if (v59) {
                    float v67 = *((float *)&valuePtr + 1);
                  }
                  *((float *)&v68 + 1) = v67;
                  uint64_t v80 = v68;
                  CFRelease(v53);
                  uint64_t v54 = v80;
                }
                else
                {
                  CFRelease(v53);
                  uint64_t v54 = 0;
                }
              }
              *(void *)(a1 + 104) = v54;
              CFRelease(v51);
              if (COERCE_FLOAT(*(void *)(a1 + 104)) > 0.0) {
                goto LABEL_62;
              }
            }
          }
        }
        __n128 v69 = sub_1B643AA68(a1, v40, v41, v42, v43, v44, v45, v46);
        if (!v69)
        {
          sub_1B63F2F54(16, @"Error: Failed to load %@", v70, v71, v72, v73, v74, v75, a1);
          char v77 = 16 * ((*(_DWORD *)(a1 + 120) - 3) < 5);
          goto LABEL_63;
        }
        uint64_t v76 = v69;
        *(float *)(a1 + 104) = (float)CGImageGetWidth(v69);
        *(float *)(a1 + 108) = (float)CGImageGetHeight(v76);
        CFRelease(v76);
LABEL_62:
        char v77 = 16;
LABEL_63:
        *(unsigned char *)(a1 + 116) = *(unsigned char *)(a1 + 116) & 0xCF | v77 | 0x28;
        return *(double *)(a1 + 104);
      }
    }
    else if (!sub_1B65172D0(a1, v9, v10, v11, v12, v13, v14, v15))
    {
      goto LABEL_20;
    }
    if (sub_1B6517338(a1)) {
      goto LABEL_62;
    }
    goto LABEL_9;
  }
  return *(double *)(a1 + 104);
}

BOOL sub_1B643A9B8(uint64_t a1, uint64_t a2)
{
  if (a1 == a2 || (uint64_t v3 = 0, a1) && a2)
  {
    if (*(unsigned __int8 *)(a1 + 4) == *(unsigned __int8 *)(a2 + 4) && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
      return Count == CFArrayGetCount(*(CFArrayRef *)(a2 + 32));
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

double sub_1B643AA34(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(_WORD *)(a1 + 11) = *(_WORD *)(a2 + 11);
  double result = *(double *)(a2 + 16);
  *(double *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

CGImageRef sub_1B643AA68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v50[1] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  if (*(_DWORD *)(a1 + 96) != 3)
  {
    pthread_mutex_lock(&stru_1E9DCA0E8);
    uint64_t v17 = *(CGContext **)(a1 + 64);
    if (v17)
    {
LABEL_8:
      Image = CGBitmapContextCreateImage(v17);
LABEL_9:
      pthread_mutex_unlock(&stru_1E9DCA0E8);
      return (CGImageRef)Image;
    }
    int v19 = *(_DWORD *)(a1 + 96);
    if (v19 == 2)
    {
      uint64_t v26 = *(void *)(a1 + 88);
      if (v26)
      {
        uint64_t v34 = CGImageSourceCreateWithData(*(CFDataRef *)(a1 + 88), 0);
        if (v34)
        {
LABEL_18:
          uint64_t v47 = *MEMORY[0x1E4F2FF00];
          uint64_t v48 = MEMORY[0x1E4F1CC38];
          CFDictionaryRef v35 = (const __CFDictionary *)objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v27, (uint64_t)&v48, (uint64_t)&v47, 1);
          Image = CGImageSourceCreateImageAtIndex(v34, 0, v35);
          if (!Image)
          {
            CGImageSourceGetStatusAtIndex(v34, 0);
            sub_1B63F2F54(16, @"Error: Failed to create image from image source %@ (status: %d)", v36, v37, v38, v39, v40, v41, (uint64_t)v34);
          }
          CFRelease(v34);
          goto LABEL_28;
        }
        sub_1B63F2F54(16, @"Error: Failed to create image source from data %@", v28, v29, v30, v31, v32, v33, v26);
      }
    }
    else
    {
      if (v19 != 1)
      {
LABEL_26:
        if (v19 != 4) {
          goto LABEL_29;
        }
        Image = (void *)sub_1B64F41F0(*(void **)(a1 + 88));
LABEL_28:
        if (Image) {
          goto LABEL_9;
        }
LABEL_29:
        uint64_t v17 = *(CGContext **)(a1 + 64);
        if (v17) {
          goto LABEL_8;
        }
LABEL_30:
        Image = 0;
        goto LABEL_9;
      }
      CFURLRef v20 = *(const __CFURL **)(a1 + 88);
      if (v20)
      {
        char v46 = 0;
        CFDataRef v21 = (const __CFData *)sub_1B643B200(a1, &v46, v11, v12, v13, v14, v15, v16);
        if (v21)
        {
          CFDataRef v22 = v21;
          uint64_t v23 = CGImageSourceCreateWithData(v21, 0);
          CFRelease(v22);
          if (v23)
          {
            uint64_t v49 = *MEMORY[0x1E4F2FF00];
            v50[0] = MEMORY[0x1E4F1CC38];
            CFDictionaryRef v25 = (const __CFDictionary *)objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v24, (uint64_t)v50, (uint64_t)&v49, 1);
            Image = CGImageSourceCreateImageAtIndex(v23, 0, v25);
            CFRelease(v23);
            goto LABEL_9;
          }
        }
        if (v46) {
          goto LABEL_30;
        }
        CGImageSourceRef v42 = sub_1B65F41A8(v20);
        if (v42)
        {
          uint64_t v34 = v42;
          goto LABEL_18;
        }
        uint64_t v45 = (CGImage *)sub_1B64FB464(v20, v27, v43, v44);
        if (v45)
        {
          Image = v45;
          CGImageRetain(v45);
          goto LABEL_9;
        }
      }
    }
    int v19 = *(_DWORD *)(a1 + 96);
    goto LABEL_26;
  }
  uint64_t v9 = *(CGImage **)(a1 + 88);

  return CGImageRetain(v9);
}

uint64_t sub_1B643AD04(CGImage *a1)
{
  uint64_t v2 = sub_1B6439FF4();
  if (v2)
  {
    *(void *)(v2 + 88) = CGImageRetain(a1);
    *(_DWORD *)(v2 + 96) = 3;
  }
  return v2;
}

_DWORD *sub_1B643AD48(_DWORD *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = cf;
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  int v9 = v8[30];
  if ((v9 - 3) >= 5)
  {
    sub_1B63F2F54(16, @"Error: Cannot build column cubemap from non-cubemap image", a3, a4, a5, a6, a7, a8, v11);
    return 0;
  }
  if (v9 != 5) {
    return 0;
  }
  CFRetain(v8);
  return v8;
}

BOOL sub_1B643ADCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  return (*(_DWORD *)(a1 + 120) - 3) < 5;
}

uint64_t sub_1B643AE24(const void *a1)
{
  uint64_t v2 = sub_1B6439FF4();
  if (v2)
  {
    *(void *)(v2 + 88) = CFRetain(a1);
    *(_DWORD *)(v2 + 96) = 4;
  }
  return v2;
}

CFURLRef sub_1B643AE68(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (__CFString *)a1;
  uint64_t v5 = VFXGetResourceBundle(a1, a2, a3, a4);
  uint64_t v8 = objc_msgSend_defaultUICatalogForBundle_(MEMORY[0x1E4F5E048], v6, v5, v7);
  uint64_t v11 = objc_msgSend_namedTextureWithName_scaleFactor_(v8, v9, (uint64_t)v4, v10, 1.0);
  if (!v11) {
    goto LABEL_3;
  }
  uint64_t v15 = v11;
  objc_msgSend_size(v11, v12, v13, v14);
  float64_t v47 = v17;
  float64_t v48 = v16;
  char isOpaque = objc_msgSend_isOpaque(v15, v18, v19, v20);
  v22.f64[0] = v48;
  v22.f64[1] = v47;
  CFURLRef result = (CFURLRef)sub_1B643AFC0(v4, isOpaque, COERCE_DOUBLE(vcvt_f32_f64(v22)));
  if (!result)
  {
LABEL_3:
    CFURLRef v24 = sub_1B63CC0F4(v4, v12, v13, v14);
    if (v24)
    {
      CFURLRef v27 = v24;
      uint64_t v28 = sub_1B643A054(v24);
      CFRelease(v27);
      return (CFURLRef)v28;
    }
    else
    {
      uint64_t v29 = objc_msgSend_valueForKey_(VFXTransaction, v25, @"VFXWorldDecodingCurrentEnclosingFolder", v26);
      if (v29
        && (uint64_t v32 = objc_msgSend_URLByAppendingPathComponent_(v29, v30, (uint64_t)v4, v31),
            objc_msgSend_checkResourceIsReachableAndReturnError_(v32, v33, 0, v34)))
      {
        return (CFURLRef)sub_1B643A054(v32);
      }
      else
      {
        if (objc_msgSend_characterAtIndex_(v4, v30, 0, v31) != 47)
        {
          BOOL v35 = VFXHasSpecialResourceBundle();
          BOOL v36 = v35;
          uint64_t v40 = (void *)VFXGetResourceBundle(v35, v37, v38, v39);
          if (v36) {
            uint64_t v44 = objc_msgSend_bundlePath(v40, v41, v42, v43);
          }
          else {
            uint64_t v44 = objc_msgSend_resourcePath(v40, v41, v42, v43);
          }
          uint64_t v4 = (__CFString *)objc_msgSend_stringByAppendingPathComponent_(v44, v45, (uint64_t)v4, v46);
        }
        return sub_1B643A250(v4);
      }
    }
  }
  return result;
}

uint64_t sub_1B643AFC0(const void *a1, char a2, double a3)
{
  uint64_t v6 = sub_1B6439FF4();
  if (v6)
  {
    *(void *)(v6 + 88) = CFRetain(a1);
    *(_DWORD *)(v6 + 96) = 5;
    char v7 = *(unsigned char *)(v6 + 116);
    *(double *)(v6 + 104) = a3;
    *(unsigned char *)(v6 + 116) = v7 & 0xFE | a2 ^ 1 | 0x1C;
  }
  return v6;
}

CGContext *sub_1B643B038(CGImage *a1)
{
  unint64_t Width = CGImageGetWidth(a1);
  unint64_t Height = CGImageGetHeight(a1);
  __int16 BitmapInfo = CGImageGetBitmapInfo(a1);
  ColorSpace = CGImageGetColorSpace(a1);
  if (ColorSpace)
  {
    uint64_t v6 = ColorSpace;
    CGColorSpaceRef BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    if (BaseColorSpace) {
      uint64_t v6 = BaseColorSpace;
    }
    BOOL IsWideGamutRGB = CGColorSpaceIsWideGamutRGB(v6);
    if ((BitmapInfo & 0x100) == 0 && (sub_1B63CC4D8() & IsWideGamutRGB) != 1)
    {
      BOOL v9 = CGColorSpaceGetNumberOfComponents(v6) == 1;
      goto LABEL_9;
    }
LABEL_12:
    size_t v14 = 8 * Width;
    uint32_t v13 = 4353;
    size_t v11 = 16;
    uint64_t v15 = sub_1B63C9410();
    goto LABEL_17;
  }
  if ((BitmapInfo & 0x100) != 0) {
    goto LABEL_12;
  }
  sub_1B63CC4D8();
  BOOL v9 = 1;
LABEL_9:
  int v10 = BitmapInfo & 0x1F;
  if ((BitmapInfo & 0x1F) == 0 && v9)
  {
    size_t v11 = 8;
    uint64_t v12 = (CGColorSpace *)sub_1B63C9B20();
    uint32_t v13 = 0;
    size_t v14 = Width;
    goto LABEL_18;
  }
  size_t v14 = 4 * Width;
  if (v10) {
    uint32_t v13 = 16385;
  }
  else {
    uint32_t v13 = 16389;
  }
  size_t v11 = 8;
  uint64_t v15 = sub_1B63C9388();
LABEL_17:
  uint64_t v12 = (CGColorSpace *)v15;
LABEL_18:
  double v16 = CGBitmapContextCreate(0, Width, Height, v11, v14, v12, v13);
  uint64_t v23 = v16;
  if (v16)
  {
    v25.size.double width = (double)Width;
    v25.size.height = (double)Height;
    v25.origin.x = 0.0;
    v25.origin.y = 0.0;
    CGContextDrawImage(v16, v25, a1);
  }
  else
  {
    sub_1B63F2F54(0, @"Warning: Failed to create bitmap context for CG image %@", v17, v18, v19, v20, v21, v22, (uint64_t)a1);
  }
  return v23;
}

BOOL sub_1B643B19C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 96) == 5;
}

uint64_t sub_1B643B1AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 96) != 5) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Can't get name for non catalog texture", a3, a4, a5, a6, a7, a8, (uint64_t)"image->_sourceType == kCFXImageSourceTypeCatalogTexture");
  }
  return *(void *)(a1 + 88);
}

uint64_t sub_1B643B200(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  if (*(_DWORD *)(a1 + 96) == 1)
  {
    int v10 = *(void **)(a1 + 88);
    size_t v11 = objc_msgSend_query(v10, a2, a3, a4);
  }
  else
  {
    int v10 = 0;
    size_t v11 = objc_msgSend_query(0, a2, a3, a4);
  }
  uint64_t v15 = objc_msgSend_length(v11, v12, v13, v14);
  if (a2) {
    *a2 = v15 != 0;
  }
  if (!v15) {
    return 0;
  }
  uint64_t v19 = objc_msgSend_path(v10, v16, v17, v18);
  uint64_t v23 = objc_msgSend_stringByStandardizingPath(v19, v20, v21, v22);
  CGRect v25 = objc_msgSend_componentsWithURL_resolvingAgainstBaseURL_(MEMORY[0x1E4F29088], v24, (uint64_t)v10, 0);
  Items = objc_msgSend_queryItems(v25, v26, v27, v28);
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  uint64_t v31 = objc_msgSend_countByEnumeratingWithState_objects_count_(Items, v30, (uint64_t)&v83, (uint64_t)v87, 16);
  if (!v31) {
    goto LABEL_23;
  }
  uint64_t v39 = v31;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = *(void *)v84;
  do
  {
    for (uint64_t i = 0; i != v39; ++i)
    {
      if (*(void *)v84 != v42) {
        objc_enumerationMutation(Items);
      }
      uint64_t v44 = *(void **)(*((void *)&v83 + 1) + 8 * i);
      uint64_t v45 = objc_msgSend_name(v44, v32, v33, v34);
      if (objc_msgSend_isEqualToString_(v45, v46, @"offset", v47))
      {
        int v51 = objc_msgSend_value(v44, v48, v49, v50);
        uint64_t v40 = (int)objc_msgSend_intValue(v51, v52, v53, v54);
      }
      else
      {
        double v55 = objc_msgSend_name(v44, v48, v49, v50);
        if (objc_msgSend_isEqualToString_(v55, v56, @"size", v57))
        {
          CFNumberRef v58 = objc_msgSend_value(v44, v32, v33, v34);
          uint64_t v41 = (int)objc_msgSend_intValue(v58, v59, v60, v61);
        }
      }
    }
    uint64_t v39 = objc_msgSend_countByEnumeratingWithState_objects_count_(Items, v32, (uint64_t)&v83, (uint64_t)v87, 16);
  }
  while (v39);
  if (v41 < 1)
  {
LABEL_23:
    sub_1B63F2F54(16, @"Error: failed to resolve image inside %@", v33, v34, v35, v36, v37, v38, v23);
    return 0;
  }
  id v62 = objc_alloc(NSClassFromString(&cfstr_Mdlmemorymappe.isa));
  uint64_t v65 = objc_msgSend_fileURLWithPath_(MEMORY[0x1E4F1CB10], v63, v23, v64);
  float v67 = objc_msgSend_initWithURL_offset_length_(v62, v66, v65, v40, v41);
  uint64_t v71 = objc_msgSend_dataNoCopy(v67, v68, v69, v70);
  uint64_t v75 = objc_msgSend_copy(v71, v72, v73, v74);

  if (!v75)
  {
    sub_1B63F2F54(16, @"Error: failed to map image data for image inside %@", v76, v77, v78, v79, v80, v81, v23);
    goto LABEL_23;
  }
  return v75;
}

uint64_t sub_1B643B460(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  if (*(_DWORD *)(a1 + 96) == 2) {
    return *(void *)(a1 + 88);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B643B4C0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v4 = *(_DWORD *)(a1 + 96);
  if (v4 == 5) {
    return *(void *)(a1 + 88);
  }
  if (v4 == 1) {
    return objc_msgSend_lastPathComponent(*(void **)(a1 + 88), a2, a3, a4);
  }
  return 0;
}

uint64_t sub_1B643B4EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  pthread_mutex_lock(&stru_1E9DCA0E8);
  if (!*(void *)(a1 + 64) && *(_DWORD *)(a1 + 96) != 5 && (*(unsigned char *)(a1 + 80) & 2) == 0 && !sub_1B643A1CC(a1))
  {
    BOOL v9 = sub_1B63F2EE0();
    os_signpost_id_t v10 = os_signpost_id_generate(v9);
    size_t v11 = sub_1B63F2EE0();
    if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v19 = v11;
      if (os_signpost_enabled(v11))
      {
        if (*(_DWORD *)(a1 + 96) == 1) {
          uint64_t v20 = *(void *)(a1 + 88);
        }
        else {
          uint64_t v20 = 0;
        }
        *(_DWORD *)buf = 138412290;
        uint64_t v53 = v20;
        _os_signpost_emit_with_name_impl(&dword_1B6287000, v19, OS_SIGNPOST_INTERVAL_BEGIN, v10, "LoadImage (CG)", "url=%@", buf, 0xCu);
      }
    }
    uint64_t v27 = sub_1B643AA68(a1, v12, v13, v14, v15, v16, v17, v18);
    if (*(void *)(a1 + 64)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. CFXImageCacheBitmap context is not null when it should be", v21, v22, v23, v24, v25, v26, (uint64_t)"image->_bitmapContext==NULL");
    }
    if (v27)
    {
      uint64_t v28 = sub_1B643B038(v27);
      *(void *)(a1 + 64) = v28;
      if (v28)
      {
        CGColorSpaceRef ColorSpace = CGBitmapContextGetColorSpace(v28);
        if (ColorSpace != (CGColorSpaceRef)sub_1B63C9410()
          && ColorSpace != (CGColorSpaceRef)sub_1B63C9B90()
          && ColorSpace != (CGColorSpaceRef)sub_1B63C93CC()
          && (*(unsigned char *)(a1 + 116) & 2) == 0)
        {
          sub_1B643B7B8(v27, a1, v36, v37, v38, v39, v40, v41);
          if (sub_1B643BA44(a1, v42, v43, v44, v45, v46, v47, v48))
          {
            CACurrentMediaTime();
            sub_1B643BB5C(*(CGContext **)(a1 + 64));
          }
        }
      }
      else
      {
        sub_1B63F2F54(16, @"Error: failed to create a CGBitmapContext from a CGImage for %@", v29, v30, v31, v32, v33, v34, a1);
      }
      CGImageRelease(v27);
    }
    uint64_t v49 = sub_1B63F2EE0();
    if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v50 = v49;
      if (os_signpost_enabled(v49))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1B6287000, v50, OS_SIGNPOST_INTERVAL_END, v10, "LoadImage (CG)", "", buf, 2u);
      }
    }
  }
  return pthread_mutex_unlock(&stru_1E9DCA0E8);
}

BOOL sub_1B643B738(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 80) & 2) != 0 || sub_1B643A1CC(a1) != 0;
}

uint64_t sub_1B643B768(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  return (*(unsigned __int8 *)(a1 + 116) >> 1) & 1;
}

void sub_1B643B7B8(CGImageRef image, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  if ((*(unsigned char *)(a2 + 116) & 4) == 0)
  {
    os_signpost_id_t v10 = *(CGContext **)(a2 + 64);
    if (v10)
    {
      CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(image);
      unsigned int v12 = AlphaInfo - 1;
      BOOL v14 = AlphaInfo == kCGImageAlphaOnly || v12 < 4;
      if (v12 > 3) {
        goto LABEL_53;
      }
      Data = (unsigned __int16 *)CGBitmapContextGetData(v10);
      if (!Data) {
        goto LABEL_52;
      }
      uint64_t v16 = Data;
      unsigned int Width = CGBitmapContextGetWidth(v10);
      unsigned int Height = CGBitmapContextGetHeight(v10);
      size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(v10);
      size_t v20 = (CGBitmapContextGetBitsPerPixel(v10) / BitsPerComponent * BitsPerComponent) >> 3;
      size_t BytesPerRow = CGBitmapContextGetBytesPerRow(v10);
      if (v20 == 4)
      {
        if (CGImageGetBitmapInfo(image) == 0x2000) {
          int v22 = 0;
        }
        else {
          int v22 = 3;
        }
        if (Height)
        {
          int v23 = 0;
          unsigned int v24 = 0;
          BOOL v25 = 1;
          while (!Width)
          {
LABEL_23:
            BOOL v14 = 0;
            ++v24;
            v23 += BytesPerRow;
            BOOL v25 = v24 < Height;
            if (v24 == Height) {
              goto LABEL_53;
            }
          }
          unsigned int v26 = v23 + v22;
          unsigned int v27 = Width;
          while (*((unsigned __int8 *)v16 + v26) >= 0xFEu)
          {
            v26 += 4;
            if (!--v27) {
              goto LABEL_23;
            }
          }
          BOOL v14 = v25;
          goto LABEL_53;
        }
        goto LABEL_52;
      }
      if ((CGBitmapContextGetBitmapInfo(v10) & 0x100) != 0)
      {
        if (v20 == 8)
        {
          if (Height)
          {
            uint64_t v32 = 0;
            while (1)
            {
              uint64_t v33 = Width;
              uint64_t v34 = v16;
              if (Width) {
                break;
              }
LABEL_50:
              BOOL v14 = 0;
              ++v32;
              uint64_t v16 = (unsigned __int16 *)((char *)v16 + BytesPerRow);
              if (v32 == Height) {
                goto LABEL_53;
              }
            }
            while (1)
            {
              unsigned int v36 = *v34;
              v34 += 4;
              unsigned int v35 = v36;
              int v37 = (v36 >> 10) & 0x1F;
              int v38 = v37 == 31 ? 2139095040 : v37;
              BOOL v39 = !v37 || v37 == 31;
              int v40 = v39 ? v38 : (v37 << 23) + 939524096;
              if (COERCE_FLOAT(v40 | (v35 << 16) & 0x80000000 | (v35 >> 7) & 7 | (8 * (v35 & 0x3FF)) & 0x1FFF | ((v35 & 0x3FF) << 13)) < 0.999) {
                goto LABEL_55;
              }
              if (!--v33) {
                goto LABEL_50;
              }
            }
          }
        }
        else if (v20 == 16 && Height)
        {
          uint64_t v28 = 0;
          uint64_t v29 = (float *)(v16 + 6);
          while (1)
          {
            uint64_t v30 = Width;
            uint64_t v31 = v29;
            if (Width) {
              break;
            }
LABEL_33:
            BOOL v14 = 0;
            ++v28;
            uint64_t v29 = (float *)((char *)v29 + BytesPerRow);
            if (v28 == Height) {
              goto LABEL_53;
            }
          }
          while (*v31 >= 0.999)
          {
            v31 += 4;
            if (!--v30) {
              goto LABEL_33;
            }
          }
LABEL_55:
          BOOL v14 = 1;
          goto LABEL_53;
        }
      }
LABEL_52:
      BOOL v14 = 0;
LABEL_53:
      *(unsigned char *)(a2 + 116) = *(unsigned char *)(a2 + 116) & 0xFE | v14 | 4;
    }
  }
}

uint64_t sub_1B643BA44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"image");
  }
  if ((*(_DWORD *)(a1 + 120) - 3) < 5) {
    return 0;
  }
  char v16 = *(unsigned char *)(a1 + 116);
  if (*(_DWORD *)(a1 + 96) != 5 && (*(unsigned char *)(a1 + 116) & 4) == 0)
  {
    pthread_mutex_lock(&stru_1E9DCA0E8);
    if ((*(unsigned char *)(a1 + 80) & 2) != 0 || sub_1B643A1CC(a1))
    {
      if ((*(unsigned char *)(a1 + 116) & 4) == 0) {
        *(unsigned char *)(a1 + 116) = *(unsigned char *)(a1 + 116) & 0xFE | *(unsigned char *)(*(void *)(a1 + 72) + 6) & 1 | 4;
      }
    }
    else
    {
      pthread_mutex_unlock(&stru_1E9DCA0E8);
      pthread_mutex_lock(&stru_1E9DCA0E8);
      uint64_t v17 = (const void *)sub_1B643BBE4(a1, 1);
      if (v17) {
        CFRelease(v17);
      }
    }
    pthread_mutex_unlock(&stru_1E9DCA0E8);
    char v16 = *(unsigned char *)(a1 + 116);
  }
  return v16 & 1;
}

void sub_1B643BB5C(CGContext *a1)
{
  CGBitmapContextGetWidth(a1);
  CGBitmapContextGetHeight(a1);
  if (CGBitmapContextGetData(a1))
  {
    size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(a1);
    if (((CGBitmapContextGetBitsPerPixel(a1) / BitsPerComponent * BitsPerComponent) & 0xFFFFFFFFFFFFFFF8) == 0x20)
    {
      CGBitmapContextGetBytesPerRow(a1);
      CGBitmapContext_fixIncorrectPremultiply(a1);
    }
  }
}

CFTypeRef sub_1B643BBE4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  pthread_mutex_lock(&stru_1E9DCA0E8);
  uint64_t v17 = *(const void **)(a1 + 64);
  if (v17) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = a2 == 0;
  }
  if (!v18)
  {
    sub_1B643B4EC(a1, v10, v11, v12, v13, v14, v15, v16);
    uint64_t v17 = *(const void **)(a1 + 64);
  }
  if (v17) {
    CFTypeRef v19 = CFRetain(v17);
  }
  else {
    CFTypeRef v19 = 0;
  }
  pthread_mutex_unlock(&stru_1E9DCA0E8);
  return v19;
}

void sub_1B643BC7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  if (*(_DWORD *)(a1 + 96))
  {
    pthread_mutex_lock(&stru_1E9DCA0E8);
    uint64_t v9 = *(const void **)(a1 + 64);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 64) = 0;
      *(unsigned char *)(a1 + 80) |= 1u;
    }
    pthread_mutex_unlock(&stru_1E9DCA0E8);
    pthread_mutex_lock(&stru_1E9DCA0E8);
    if (*(void *)(a1 + 72))
    {
      sub_1B643BD50(a1);
      *(unsigned char *)(a1 + 80) |= 2u;
    }
    pthread_mutex_unlock(&stru_1E9DCA0E8);
  }
}

void sub_1B643BD50(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (v1)
  {
    CFRelease(*(CFTypeRef *)(v1 + 32));
    free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0;
  }
}

BOOL sub_1B643BD8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8 = sub_1B643A59C(a1, a2, a3, a4, a5, a6, a7, a8);
  return (unint64_t)*(float *)&v8 == 2 * (unint64_t)*((float *)&v8 + 1);
}

int32x2_t sub_1B643BDB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(double *)&int32x2_t result = sub_1B643A59C(a1, a2, a3, a4, a5, a6, a7, a8);
  switch(*(_DWORD *)(a1 + 120))
  {
    case 2:
    case 4:
      return vdup_lane_s32(result, 1);
    case 5:
      goto LABEL_6;
    case 6:
      float v10 = *(float *)&result.i32[1] / 3.0;
      goto LABEL_5;
    case 7:
      float v10 = *(float *)&result.i32[1] * 0.25;
LABEL_5:
      *(float *)result.i32 = ceilf(v10);
LABEL_6:
      int32x2_t result = vdup_lane_s32(result, 0);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1B643BE4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 120) != 2) {
    return 1;
  }
  uint32x2_t v8 = vcvt_u32_f32(vrnda_f32(COERCE_FLOAT32X2_T(sub_1B643A59C(a1, a2, a3, a4, a5, a6, a7, a8))));
  if (v8.i32[0] <= (unsigned __int32)v8.i32[1]) {
    return v8.i32[1] / (unsigned __int32)v8.i32[0];
  }
  else {
    return v8.i32[0] / (unsigned __int32)v8.i32[1];
  }
}

uint64_t sub_1B643BE9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  return *(unsigned int *)(a1 + 120);
}

void sub_1B643BEE8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  *(_DWORD *)(a1 + 120) = a2;
}

BOOL sub_1B643BF38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  return (*(_DWORD *)(a1 + 120) & 0xFFFFFFFC) == 4;
}

void sub_1B643BF90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"image");
  }
  if (*(_DWORD *)(a1 + 120) != 2)
  {
    uint64x2_t v15 = vcvtq_u64_f64(vcvtq_f64_f32(vrnda_f32(COERCE_FLOAT32X2_T(sub_1B643A59C(a1, a2, a3, a4, a5, a6, a7, a8)))));
    if (v15.i64[1] * v15.i64[0])
    {
      if (!(v15.i64[0] % (unint64_t)v15.i64[1])) {
        *(_DWORD *)(a1 + 120) = 2;
      }
    }
  }
}

void sub_1B643C03C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"image");
  }
  if ((*(_DWORD *)(a1 + 120) - 3) >= 5)
  {
    double v15 = sub_1B643A59C(a1, a2, a3, a4, a5, a6, a7, a8);
    unint64_t v16 = vcvtas_u32_f32(*(float *)&v15);
    unint64_t v17 = vcvtas_u32_f32(*((float *)&v15 + 1));
    if (*(float *)&v15 == (float)v16 && *((float *)&v15 + 1) == (float)v17)
    {
      if (6 * v17 == v16)
      {
        int v19 = 4;
      }
      else
      {
        if (6 * v16 != v17) {
          return;
        }
        int v19 = 5;
      }
      *(_DWORD *)(a1 + 120) = v19;
    }
  }
}

void sub_1B643C108(unsigned int a1, uint64_t a2, uint64_t a3, size_t a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a2;
  if (a1 == 5)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3 * a2;
    do
    {
      (*(void (**)(uint64_t, void, uint64_t))(a7 + 16))(a7, v11++, a6);
      a6 += v12;
    }
    while (v11 != 6);
    return;
  }
  unsigned int v15 = a1;
  __dst = (char *)malloc_type_malloc(a4 * a2, 0x3D6689DFuLL);
  if (v15 <= 7 && ((1 << v15) & 0xD0) != 0)
  {
    unint64_t v22 = 0;
    uint64_t v38 = a6;
    __srca = (char *)(a6 + a5 * (v10 - 1 + v10) + a3 * (3 * v10 + v10 - 1));
    uint64_t v37 = a3 * v10;
    uint64_t v42 = v10;
    unsigned int v39 = v15;
    while (1)
    {
      unint64_t v41 = v22;
      if (v15 == 4)
      {
        uint64_t v23 = 0;
        uint64_t v24 = v22;
        if (v10) {
          goto LABEL_20;
        }
      }
      else
      {
        if (v15 == 7)
        {
          uint64_t v23 = 1;
          uint64_t v24 = 2;
          switch(v22)
          {
            case 0uLL:
              goto LABEL_19;
            case 1uLL:
              uint64_t v24 = 0;
              uint64_t v23 = 1;
              if (v10) {
                goto LABEL_20;
              }
              goto LABEL_22;
            case 2uLL:
              uint64_t v23 = 0;
              goto LABEL_27;
            case 3uLL:
              uint64_t v23 = 2;
              goto LABEL_27;
            case 4uLL:
              uint64_t v23 = 1;
LABEL_27:
              uint64_t v24 = 1;
              if (!v10) {
                goto LABEL_22;
              }
              goto LABEL_20;
            case 5uLL:
              if (a5)
              {
                if (v10)
                {
                  uint64_t v28 = 0;
                  uint64_t v29 = __dst;
                  uint64_t v30 = __srca;
                  uint64_t v36 = a7;
                  do
                  {
                    uint64_t v31 = v29;
                    uint64_t v32 = v42;
                    uint64_t v33 = v30;
                    do
                    {
                      memcpy(v31, v33, a5);
                      v33 -= a5;
                      v31 += a5;
                      --v32;
                    }
                    while (v32);
                    ++v28;
                    v30 -= a3;
                    v29 += a4;
                    a7 = v36;
                  }
                  while (v28 != v42);
                }
              }
              else
              {
                sub_1B63F2F54(16, @"Error: Cannot support rotation layout for compressed texture", v16, v17, v18, v19, v20, v21, (uint64_t)__srca);
              }
              goto LABEL_22;
            default:
              goto LABEL_18;
          }
        }
        if (v22 >= 6)
        {
LABEL_18:
          uint64_t v23 = 0;
          uint64_t v24 = 0;
LABEL_19:
          if (!v10) {
            goto LABEL_22;
          }
LABEL_20:
          BOOL v25 = (char *)(v38 + v24 * a4 + v37 * v23);
          unsigned int v26 = __dst;
          uint64_t v27 = v42;
          do
          {
            memcpy(v26, v25, a4);
            v26 += a4;
            v25 += a3;
            --v27;
          }
          while (v27);
          goto LABEL_22;
        }
        uint64_t v23 = qword_1B6E508C8[v22];
        uint64_t v24 = qword_1B6E508F8[v22];
        if (v10) {
          goto LABEL_20;
        }
      }
LABEL_22:
      (*(void (**)(uint64_t, void, char *))(a7 + 16))(a7, v41, __dst);
      unint64_t v22 = v41 + 1;
      uint64_t v10 = v42;
      unsigned int v15 = v39;
      if (v41 == 5) {
        goto LABEL_38;
      }
    }
  }
  sub_1B63F2F54(16, @"Error: Unknown cubemap image type", v16, v17, v18, v19, v20, v21, (uint64_t)__src);
LABEL_38:

  free(__dst);
}

void sub_1B643C418(int a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1 == 2)
  {
    uint64_t v11 = (char *)a7;
    uint64_t v16 = (char *)malloc_type_malloc(a5 * a2, 0xCCAEA4D2uLL);
    uint64_t v17 = a2;
    uint64_t v18 = v16;
    if (a3)
    {
      uint64_t v19 = 0;
      uint64_t v23 = a6 * a2;
      do
      {
        uint64_t v20 = v11;
        uint64_t v21 = v18;
        for (uint64_t i = v17; i; --i)
        {
          memcpy(v21, v20, a5);
          v21 += a5;
          v20 += a4;
        }
        (*(void (**)(uint64_t, void, char *))(a8 + 16))(a8, v19++, v18);
        v11 += v23;
        uint64_t v17 = a2;
      }
      while (v19 != a3);
    }
    free(v18);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: Unknown Texture3D image type", a3, a4, a5, a6, a7, a8, a9);
  }
}

const void *sub_1B643C53C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  }
  uint64_t v9 = sub_1B6540584();

  return sub_1B65405E8(v9, a1, v10, v11, v12, v13, v14, v15);
}

void sub_1B643C59C(const void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
LABEL_3:
  uint64_t v10 = sub_1B6540584();

  sub_1B6540954(v10, a2, a1, v11, v12, v13, v14, v15);
}

uint64_t sub_1B643C62C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"image");
  }
  unsigned int v9 = *(unsigned __int8 *)(a1 + 116);
  if ((v9 & 0x20) == 0)
  {
    if (*(_DWORD *)(a1 + 96) == 5)
    {
      int v10 = v9 | 0x10;
    }
    else
    {
      sub_1B643A59C(a1, a2, a3, a4, a5, a6, a7, a8);
      int v10 = *(unsigned __int8 *)(a1 + 116);
    }
    unsigned int v9 = v10 | 0x20;
    *(unsigned char *)(a1 + 116) = v9;
  }
  return (v9 >> 4) & 1;
}

uint64_t sub_1B643C6A8(uint64_t a1, unsigned char *a2)
{
  uint64_t result = sub_1B643A1CC(a1);
  if (result)
  {
    uint64_t v11 = result;
    if (!a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v5, v6, v7, v8, v9, v10, (uint64_t)"image");
    }
    int v12 = *(_DWORD *)(a1 + 120);
    if ((v12 - 3) > 4)
    {
      CFArrayRef v13 = *(const __CFArray **)(v11 + 32);
    }
    else
    {
      CFArrayRef v13 = *(const __CFArray **)(v11 + 32);
      if ((v12 & 0xFFFFFFFC) != 4)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v13, 0);
        CFTypeID v15 = CFGetTypeID(ValueAtIndex);
        if (v15 != CFArrayGetTypeID())
        {
          uint64_t result = CFArrayGetCount(*(CFArrayRef *)(v11 + 32)) / 6;
          if (!a2) {
            return result;
          }
LABEL_10:
          *a2 = 1;
          return result;
        }
        CFArrayRef v13 = (const __CFArray *)ValueAtIndex;
      }
    }
    uint64_t result = CFArrayGetCount(v13);
    if (!a2) {
      return result;
    }
    goto LABEL_10;
  }
  return result;
}

unsigned int *sub_1B643C788(uint64_t a1)
{
  uint64_t result = (unsigned int *)sub_1B643A1CC(a1);
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

id sub_1B643C7AC(uint64_t a1)
{
  uint64_t valuePtr = a1;
  CFNumberRef v2 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kCFXNotificationImageWillDie", v2, 0, 1u);
  CFRelease(v2);
  sub_1B643BD50(valuePtr);
  uint64_t v11 = valuePtr;
  int v12 = *(const void **)(valuePtr + 88);
  if (v12)
  {
    CFRelease(v12);
    uint64_t v11 = valuePtr;
    *(void *)(valuePtr + 88) = 0;
  }
  CFArrayRef v13 = *(const void **)(v11 + 64);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(valuePtr + 64) = 0;
  }
  return sub_1B658325C(a1, v4, v5, v6, v7, v8, v9, v10);
}

CFStringRef sub_1B643C854(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 96);
  BOOL v3 = v2 > 4;
  int v4 = (1 << v2) & 0x16;
  if (v3 || v4 == 0)
  {
    CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
    return CFStringCreateWithFormat(v8, 0, @"<CFXImage %p src:%p [%fx%f]>", a1, *(void *)(a1 + 88), COERCE_FLOAT(*(void *)(a1 + 104)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 104))));
  }
  else
  {
    CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
    return CFStringCreateWithFormat(v6, 0, @"<CFXImage %p src:%@ [%fx%f]>", a1, *(void *)(a1 + 88), COERCE_FLOAT(*(void *)(a1 + 104)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 104))));
  }
}

__CFArray *sub_1B643C8F8(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  int v3 = *(_DWORD *)(a1 + 96);
  if (v3 == 1)
  {
    int v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v41 = 2;
    int valuePtr = 5;
    int v40 = (char *)(a1 + 88);
    CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v4, @"name", @"url");
    CFDictionarySetValue(v4, @"type", v5);
    CFDictionarySetValue(v4, @"address", v7);
    CFDictionarySetValue(v4, @"semantic", v6);
    CFArrayAppendValue(Mutable, v4);
    CFRelease(v6);
    CFRelease(v4);
    CFRelease(v7);
    CFRelease(v5);
    int v3 = *(_DWORD *)(a1 + 96);
  }
  if (v3 == 2)
  {
    CFAllocatorRef v8 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v41 = 2;
    int valuePtr = 5;
    int v40 = (char *)(a1 + 88);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v8, @"name", @"data");
    CFDictionarySetValue(v8, @"type", v9);
    CFDictionarySetValue(v8, @"address", v11);
    CFDictionarySetValue(v8, @"semantic", v10);
    CFArrayAppendValue(Mutable, v8);
    CFRelease(v10);
    CFRelease(v8);
    CFRelease(v11);
    CFRelease(v9);
    int v3 = *(_DWORD *)(a1 + 96);
  }
  if (v3 == 3)
  {
    int v12 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v41 = 2;
    int valuePtr = 5;
    int v40 = (char *)(a1 + 88);
    CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v12, @"name", @"cgImage");
    CFDictionarySetValue(v12, @"type", v13);
    CFDictionarySetValue(v12, @"address", v15);
    CFDictionarySetValue(v12, @"semantic", v14);
    CFArrayAppendValue(Mutable, v12);
    CFRelease(v14);
    CFRelease(v12);
    CFRelease(v15);
    CFRelease(v13);
    int v3 = *(_DWORD *)(a1 + 96);
  }
  if (v3 == 4)
  {
    uint64_t v16 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v41 = 2;
    int valuePtr = 5;
    int v40 = (char *)(a1 + 88);
    CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v40);
    CFDictionarySetValue(v16, @"name", @"clientImage");
    CFDictionarySetValue(v16, @"type", v17);
    CFDictionarySetValue(v16, @"address", v19);
    CFDictionarySetValue(v16, @"semantic", v18);
    CFArrayAppendValue(Mutable, v16);
    CFRelease(v18);
    CFRelease(v16);
    CFRelease(v19);
    CFRelease(v17);
  }
  uint64_t v20 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v21 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  unint64_t v22 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v41 = 2;
  int valuePtr = 5;
  int v40 = (char *)(a1 + 64);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v22, @"name", @"bitmap");
  CFDictionarySetValue(v22, @"type", v23);
  CFDictionarySetValue(v22, @"address", v25);
  CFDictionarySetValue(v22, @"semantic", v24);
  CFArrayAppendValue(Mutable, v22);
  CFRelease(v24);
  CFRelease(v22);
  CFRelease(v25);
  CFRelease(v23);
  char v39 = *(unsigned char *)(a1 + 116) & 1;
  unsigned int v26 = CFDictionaryCreateMutable(0, 4, v20, v21);
  int v41 = 0;
  int valuePtr = 3;
  int v40 = &v39;
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v26, @"name", @"hasAlpha");
  CFDictionarySetValue(v26, @"type", v27);
  CFDictionarySetValue(v26, @"address", v29);
  CFDictionarySetValue(v26, @"semantic", v28);
  CFArrayAppendValue(Mutable, v26);
  CFRelease(v28);
  CFRelease(v26);
  CFRelease(v29);
  CFRelease(v27);
  uint64_t v30 = CFDictionaryCreateMutable(0, 4, v20, v21);
  int v41 = 0;
  int valuePtr = 7;
  int v40 = (char *)(a1 + 104);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v30, @"name", @"size");
  CFDictionarySetValue(v30, @"type", v31);
  CFDictionarySetValue(v30, @"address", v33);
  CFDictionarySetValue(v30, @"semantic", v32);
  CFArrayAppendValue(Mutable, v30);
  CFRelease(v32);
  CFRelease(v30);
  CFRelease(v33);
  CFRelease(v31);
  uint64_t v34 = CFDictionaryCreateMutable(0, 4, v20, v21);
  int v41 = 0;
  int valuePtr = 2;
  int v40 = (char *)(a1 + 120);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v34, @"name", @"type");
  CFDictionarySetValue(v34, @"type", v35);
  CFDictionarySetValue(v34, @"address", v37);
  CFDictionarySetValue(v34, @"semantic", v36);
  CFArrayAppendValue(Mutable, v34);
  CFRelease(v36);
  CFRelease(v34);
  CFRelease(v37);
  CFRelease(v35);
  return Mutable;
}

uint64_t sub_1B643D0F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  CFAllocatorRef v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA7A8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v21 = a2;
    uint64_t v22 = a3;
    int v20 = __cxa_guard_acquire(&qword_1E9DDA7A8);
    CFAllocatorRef v8 = &unk_1E9DDA000;
    a2 = v21;
    a3 = v22;
    if (v20)
    {
      byte_1E9DDA7A0 = 1;
      __cxa_guard_release(&qword_1E9DDA7A8);
      CFAllocatorRef v8 = (unsigned char *)&unk_1E9DDA000;
      a2 = v21;
      a3 = v22;
    }
  }
  if (v8[1952]) {
    uint64_t v9 = 0x783DB8AC31EF5870;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v9, 0);
  *(void *)a1 = &unk_1F0FB3B78;
  long long v10 = *(_OWORD *)(a5 + 16);
  long long v11 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 408) = v11;
  *(_OWORD *)(a1 + 376) = v10;
  long long v12 = *(_OWORD *)(a5 + 64);
  long long v13 = *(_OWORD *)(a5 + 80);
  long long v14 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v14;
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 440) = v13;
  long long v15 = *(_OWORD *)(a5 + 128);
  long long v16 = *(_OWORD *)(a5 + 144);
  long long v17 = *(_OWORD *)(a5 + 160);
  *(void *)(a1 + 536) = *(void *)(a5 + 176);
  *(_OWORD *)(a1 + 504) = v16;
  *(_OWORD *)(a1 + 520) = v17;
  *(_OWORD *)(a1 + 488) = v15;
  *(_OWORD *)(a1 + 552) = 0u;
  CFX::RG::TextureDescriptorReference::withSizeFactor((_OWORD *)(a5 + 24), 0.5, (float *)v24);
  v23[6] = v24[6];
  v23[7] = v24[7];
  v23[8] = v24[8];
  v23[9] = v24[9];
  v23[2] = v24[2];
  v23[3] = v24[3];
  v23[4] = v24[4];
  v23[5] = v24[5];
  v23[0] = v24[0];
  v23[1] = v24[1];
  CFNumberRef v18 = sub_1B63CFDE4(a4, (uint64_t)"DOUGHNUT_BOKEH_OUTPUT", v23);
  *(void *)(a1 + 560) = v18;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v18);
  return a1;
}

void sub_1B643D270(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B643D284(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10 = sub_1B64A3B48(a1[47], a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B649B288((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
  unsigned int v26 = sub_1B652C7E8(v18, v19, v20, v21, v22, v23, v24, v25);
  char v49 = v26;
  unint64_t v27 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v28 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v27 ^ ((0x9DDFEA08EB382D69 * (v27 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v27 ^ v26)))) ^ ((0x9DDFEA08EB382D69 * (v27 ^ ((0x9DDFEA08EB382D69 * (v27 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v27 ^ v26)))) >> 47));
  uint64_t v29 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v28);
  a1[68] = v29;
  if (!v29)
  {
    a1[68] = sub_1B643D398(*(CFX::CrossFrameResourceManager **)(a2 + 32), v28);
    CFNumberRef v37 = (void *)sub_1B6445900(a1[46], v30, v31, v32, v33, v34, v35, v36);
    int v41 = objc_msgSend_resourceManager(v37, v38, v39, v40);
    id v42 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v42, v43, (uint64_t)&v49, 53, @"mask_enabled");
    uint64_t v44 = a1[68];
    uint64_t v46 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v41, v45, @"doughnut_bokeh", (uint64_t)v42);
    uint64_t v47 = *(void **)(v44 + 16);
    if (v47 != (void *)v46)
    {
      uint64_t v48 = v46;
      if (v47) {

      }
      *(void *)(v44 + 16) = v48;
    }
  }
}

uint64_t sub_1B643D398(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B643D420(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10 = *a3;
  CFDictionaryRef v11 = sub_1B64A3B48(*(void *)(a1 + 376), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = sub_1B649B288((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18);
  uint64_t v27 = v19;
  if (v19) {
    double v28 = sub_1B6529330(v19, v20, v21, v22, v23, v24, v25, v26);
  }
  else {
    double v28 = 0.0;
  }
  float v29 = v28 / 1000.0;
  float v53 = v29;
  double v54 = sub_1B652C744(v27, v20, v21, v22, v23, v24, v25, v26);
  float v55 = sub_1B6529D4C(v27, v30, v31, v32, v33, v34, v35, v36);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 552));
  id v38 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  objc_msgSend_setBytes_length_atIndex_(v10, v39, (uint64_t)&v53, 24, 0);
  objc_msgSend_setTexture_atIndex_(v10, v40, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v10, v41, (uint64_t)v38, 1);
  uint64_t v48 = *(void *)(a1 + 544);
  uint64_t v49 = *(void *)(v48 + 16);
  if (!v49)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v42, v43, v44, v45, v46, v47, (uint64_t)"_ptr != NULL");
    uint64_t v49 = *(void *)(v48 + 16);
  }
  uint64_t v50 = sub_1B653EFB8(v49);
  return objc_msgSend_dispatch_onTexture2D_(v10, v51, v50, (uint64_t)v38);
}

uint64_t *sub_1B643D540(CFX::RG *a1, CFX::RG::RenderGraphContext *a2, CFX::RG::Resource **a3, CFX::RG::Resource *a4)
{
  CFAllocatorRef v8 = (_OWORD *)CFX::RG::Resource::constTextureDesc(a3[22]);
  long long v9 = v8[1];
  v29[0] = *v8;
  v29[1] = v9;
  long long v10 = v8[5];
  long long v12 = v8[2];
  long long v11 = v8[3];
  _OWORD v29[4] = v8[4];
  v29[5] = v10;
  v29[2] = v12;
  v29[3] = v11;
  long long v13 = v8[9];
  long long v15 = v8[6];
  long long v14 = v8[7];
  v29[8] = v8[8];
  v29[9] = v13;
  v29[6] = v15;
  v29[7] = v14;
  CFX::RG::TextureDescriptorReference::withSampleCount(v29, 1, (uint64_t)v28);
  uint64_t v17 = (const CFX::RG::Resource *)CFX::RG::copyIfNeeded(a1, a3[22], a4, (CFX::RG::Pass *)v28, 0, v16);
  uint64_t v18 = (_OWORD *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, v17);
  v27[0] = *v18;
  long long v19 = v18[4];
  long long v21 = v18[1];
  long long v20 = v18[2];
  v27[3] = v18[3];
  v27[4] = v19;
  v27[1] = v21;
  v27[2] = v20;
  uint64_t v24 = "DoughnutBokehPass";
  long long v25 = *(_OWORD *)a3;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(&v26, v27);
  uint64_t v22 = (uint64_t *)sub_1B643D650((uint64_t *)a1, (uint64_t *)a1, (uint64_t)&v24);
  v22[69] = (uint64_t)v17;
  CFX::RG::Pass::readFrom(v22, v17);
  return v22;
}

uint64_t sub_1B643D650(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B643D79C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B643D6AC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B643D6E4(void *a1)
{
  *a1 = &unk_1F0FB3B58;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B643D730(void *a1)
{
  *a1 = &unk_1F0FB3B58;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B643D79C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x238u, 8u);
  return sub_1B643D0F8(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B643D7FC(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

void sub_1B643D804()
{
  if (!qword_1E9DDA7B0)
  {
    qword_1E9DDA7B0 = sub_1B63C8D10(&qword_1E9DDA7B0);
    qword_1EB975450 = (uint64_t)sub_1B643E0AC;
  }
}

double sub_1B643D85C()
{
  if (qword_1E9DDA7B8 != -1) {
    dispatch_once(&qword_1E9DDA7B8, &unk_1F0FB5708);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1E9DDA7B0, 0x30uLL);
  *(_OWORD *)(v0 + 16) = xmmword_1B6E50930;
  *(void *)&double result = 2;
  *(void *)(v0 + 32) = 2;
  *(_DWORD *)(v0 + 40) = 2139095039;
  *(void *)(v0 + 56) = ((unint64_t)*(unsigned __int8 *)(v0 + 44) << 16) | 0x2893;
  return result;
}

_DWORD *sub_1B643D8D8(const __CFDictionary *a1)
{
  sub_1B643D85C();
  int v3 = v2;
  CFNumberRef Value = CFDictionaryGetValue(a1, @"minificationFilter");
  if (Value) {
    int v5 = sub_1B643DA0C(Value);
  }
  else {
    int v5 = 1;
  }
  v3[7] = v5;
  CFNumberRef v6 = CFDictionaryGetValue(a1, @"magnificationFilter");
  if (v6) {
    int v7 = sub_1B643DA0C(v6);
  }
  else {
    int v7 = 1;
  }
  v3[8] = v7;
  uint64_t v8 = CFDictionaryGetValue(a1, @"mipFilter");
  if (v8) {
    LODWORD(v8) = sub_1B643DA0C(v8);
  }
  v3[8] = v8;
  long long v9 = CFDictionaryGetValue(a1, @"wrapS");
  if (v9) {
    int v10 = sub_1B643DA5C(v9);
  }
  else {
    int v10 = 1;
  }
  v3[4] = v10;
  long long v11 = CFDictionaryGetValue(a1, @"wrapT");
  if (v11) {
    int v12 = sub_1B643DA5C(v11);
  }
  else {
    int v12 = 1;
  }
  v3[5] = v12;
  long long v13 = CFDictionaryGetValue(a1, @"wrapP");
  if (v13) {
    int v14 = sub_1B643DA5C(v13);
  }
  else {
    int v14 = 1;
  }
  v3[6] = v14;
  CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(a1, @"maxAnisotropy");
  if (v15)
  {
    float valuePtr = 0.0;
    CFNumberGetValue(v15, kCFNumberFloatType, &valuePtr);
    sub_1B643DACC((uint64_t)v3, valuePtr, v16, v17, v18, v19, v20, v21, v22);
  }
  return v3;
}

uint64_t sub_1B643DA0C(const void *a1)
{
  if (CFEqual(a1, @"linear")) {
    return 2;
  }
  else {
    return CFEqual(a1, @"nearest") != 0;
  }
}

uint64_t sub_1B643DA5C(const void *a1)
{
  if (CFEqual(a1, @"clamp")) {
    return 1;
  }
  if (CFEqual(a1, @"repeat")) {
    return 2;
  }
  if (CFEqual(a1, @"clampToBorder")) {
    return 3;
  }
  return 4;
}

int8x8_t sub_1B643DACC(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"textureSampler");
  }
  *(float *)(a1 + 40) = a2;
  if (a2 <= 128.0) {
    unsigned int v11 = ((a2 * 65536.0 * 0.0078125) << 19) | 1;
  }
  else {
    unsigned int v11 = 1;
  }
  int8x16_t v12 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(a1 + 16), (uint32x4_t)xmmword_1B6E50940);
  int8x8_t result = vorr_s8(*(int8x8_t *)v12.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  *(void *)(a1 + 56) = result.i32[0] | result.i32[1] | (*(_DWORD *)(a1 + 32) << 12) | (*(_DWORD *)(a1 + 36) << 14) | (*(unsigned __int8 *)(a1 + 44) << 16) | v11;
  return result;
}

void sub_1B643DB9C(int a1, int a2, int a3, int a4, int a5, int a6)
{
  sub_1B643D85C();
  *(_DWORD *)(v12 + 16) = a4;
  *(_DWORD *)(v12 + 20) = a5;
  *(_DWORD *)(v12 + 24) = a6;
  *(_DWORD *)(v12 + 28) = a1;
  *(_DWORD *)(v12 + 32) = a2;
  *(_DWORD *)(v12 + 36) = a3;
  float v13 = *(float *)(v12 + 40);
  unsigned int v14 = 1;
  if (v13 <= 128.0) {
    unsigned int v14 = ((v13 * 65536.0 * 0.0078125) << 19) | 1;
  }
  *(void *)(v12 + 56) = (a2 << 12) | (a1 << 10) | (a3 << 14) | (2 * a4) | (16 * a5) | (a6 << 7) | v14 | (*(unsigned __int8 *)(v12 + 44) << 16);
}

void sub_1B643DC50(int a1, int a2, int a3, int a4, int a5, int a6, float a7)
{
  sub_1B643D85C();
  *(_DWORD *)(v14 + 16) = a4;
  *(_DWORD *)(v14 + 20) = a5;
  *(_DWORD *)(v14 + 24) = a6;
  *(_DWORD *)(v14 + 28) = a1;
  *(_DWORD *)(v14 + 32) = a2;
  *(_DWORD *)(v14 + 36) = a3;
  unsigned int v15 = 1;
  *(float *)(v14 + 40) = a7;
  if (a7 <= 128.0) {
    unsigned int v15 = ((a7 * 65536.0 * 0.0078125) << 19) | 1;
  }
  *(void *)(v14 + 56) = (a2 << 12) | (a1 << 10) | (a3 << 14) | (2 * a4) | (16 * a5) | (a6 << 7) | v15 | (*(unsigned __int8 *)(v14 + 44) << 16);
}

uint64_t sub_1B643DD10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureSampler");
  }
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_1B643DD5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureSampler");
  }
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_1B643DDA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureSampler");
  }
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1B643DDF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureSampler");
  }
  return *(unsigned int *)(a1 + 28);
}

uint64_t sub_1B643DE40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureSampler");
  }
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1B643DE8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureSampler");
  }
  return *(unsigned int *)(a1 + 36);
}

float sub_1B643DED8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureSampler");
  }
  return *(float *)(a1 + 40);
}

uint64_t sub_1B643DF24()
{
  if (qword_1E9DDA7C8 != -1) {
    dispatch_once(&qword_1E9DDA7C8, &unk_1F0FB65A8);
  }
  return qword_1E9DDA7C0;
}

void sub_1B643DF68()
{
  sub_1B643D85C();
  qword_1E9DDA7C0 = v0;
}

uint64_t sub_1B643DF88()
{
  if (qword_1E9DDA7D8 != -1) {
    dispatch_once(&qword_1E9DDA7D8, &unk_1F0FB69C8);
  }
  return qword_1E9DDA7D0;
}

double sub_1B643DFCC()
{
  sub_1B643D85C();
  qword_1E9DDA7D0 = v0;
  *(void *)(v0 + 32) = 0x100000002;
  *(void *)&double result = 0x100000001;
  *(_OWORD *)(v0 + 16) = xmmword_1B6E50930;
  *(_DWORD *)(v0 + 48) = 2;
  *(_DWORD *)(v0 + 40) = 1065353216;
  *(void *)(v0 + 56) = ((unint64_t)*(unsigned __int8 *)(v0 + 44) << 16) | 0x10006893;
  return result;
}

BOOL sub_1B643E030(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t sub_1B643E03C(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

CFStringRef sub_1B643E044(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXTextureSampler>");
}

CFStringRef sub_1B643E078(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXTextureSampler>");
}

__CFArray *sub_1B643E0AC(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  int v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  int v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v35 = 0;
  int valuePtr = 2;
  uint64_t v34 = a1 + 16;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v35);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v34);
  CFDictionarySetValue(v5, @"name", @"wrapS");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  long long v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v35 = 0;
  int valuePtr = 2;
  uint64_t v34 = a1 + 20;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v35);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v34);
  CFDictionarySetValue(v9, @"name", @"wrapT");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  float v13 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v35 = 0;
  int valuePtr = 2;
  uint64_t v34 = a1 + 24;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v35);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v34);
  CFDictionarySetValue(v13, @"name", @"wrapP");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  uint64_t v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v35 = 0;
  int valuePtr = 2;
  uint64_t v34 = a1 + 28;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v35);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v34);
  CFDictionarySetValue(v17, @"name", @"minFilter");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  uint64_t v21 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v35 = 0;
  int valuePtr = 2;
  uint64_t v34 = a1 + 32;
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v35);
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberLongType, &v34);
  CFDictionarySetValue(v21, @"name", @"magFilter");
  CFDictionarySetValue(v21, @"type", v22);
  CFDictionarySetValue(v21, @"address", v24);
  CFDictionarySetValue(v21, @"semantic", v23);
  CFArrayAppendValue(Mutable, v21);
  CFRelease(v23);
  CFRelease(v21);
  CFRelease(v24);
  CFRelease(v22);
  long long v25 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v35 = 0;
  int valuePtr = 2;
  uint64_t v34 = a1 + 36;
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberSInt32Type, &v35);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberLongType, &v34);
  CFDictionarySetValue(v25, @"name", @"mipFilter");
  CFDictionarySetValue(v25, @"type", v26);
  CFDictionarySetValue(v25, @"address", v28);
  CFDictionarySetValue(v25, @"semantic", v27);
  CFArrayAppendValue(Mutable, v25);
  CFRelease(v27);
  CFRelease(v25);
  CFRelease(v28);
  CFRelease(v26);
  float v29 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v35 = 0;
  int valuePtr = 1;
  uint64_t v34 = a1 + 40;
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, &v35);
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberLongType, &v34);
  CFDictionarySetValue(v29, @"name", @"anisotropy");
  CFDictionarySetValue(v29, @"type", v30);
  CFDictionarySetValue(v29, @"address", v32);
  CFDictionarySetValue(v29, @"semantic", v31);
  CFArrayAppendValue(Mutable, v29);
  CFRelease(v31);
  CFRelease(v29);
  CFRelease(v32);
  CFRelease(v30);
  return Mutable;
}

void sub_1B643E8B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a11)
  {
    if (a12) {
      sub_1B6E073C4(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B643E8D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 136), sel__preTick_, a3, a4);
}

void sub_1B643EB00(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B643EB70(uint64_t a1, uint64_t a2)
{
  int v3 = (unsigned char *)(a1 + 10528);
  *(void *)(a1 + 10520) = a2;
  *(unsigned char *)(a1 + 10528) = objc_opt_respondsToSelector() & 1;
  v3[1] = objc_opt_respondsToSelector() & 1;
  uint64_t result = objc_opt_respondsToSelector();
  v3[2] = result & 1;
  *(_DWORD *)(a1 + 10504) = 0;
  if (*v3) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v3[1] == 0;
  }
  if (!v5 || (result & 1) != 0)
  {
    if (v3[1]) {
      int v6 = 3;
    }
    else {
      int v6 = 1;
    }
    if (result) {
      int v7 = 4;
    }
    else {
      int v7 = 0;
    }
    *(_DWORD *)(a1 + 10504) = v6 | v7;
  }
  return result;
}

void sub_1B643ECB8()
{
  off_1E9E49940 = sub_1B643ECD4;
}

uint64_t sub_1B643ECD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, int a6, int a7)
{
  return 1;
}

uint64_t sub_1B643F138(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend__willRemoveFromPhysicsWorld_(a2, (const char *)a2, *(void *)(a1 + 32), a4);
}

uint64_t sub_1B643F290(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 8);
  if (result)
  {
    int v3 = *(_DWORD *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = v3;
    int v9 = 0;
    (*(void (**)(uint64_t, uint64_t *))(*(void *)result + 144))(result, &v7);
    return objc_msgSend_wakeUpAllBodies(*(void **)(a1 + 48), v4, v5, v6);
  }
  return result;
}

float sub_1B643F41C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v1)
  {
    float result = *(float *)(a1 + 40);
    *(float *)(v1 + 228) = result;
  }
  return result;
}

uint64_t sub_1B643F434(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](a2, sel_updateGlobalScale_, a3, a4);
}

uint64_t sub_1B643F50C(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 32) + 8);
  if (v1) {
    return sub_1B643EB70(*(void *)(v1 + 40), *(void *)(result + 40));
  }
  return result;
}

uint64_t sub_1B643F5E8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_activatePhysicsJoint_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
}

uint64_t sub_1B643F774(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_deactivatePhysicsJoint_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
}

id sub_1B643F9EC(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  if (!a1 || *(_DWORD *)(a1 + 264) != 2) {
    return 0;
  }
  int v3 = (const void *)sub_1B63DA8D0(*(const void **)(*(void *)(a1 + 536) + 72), *a2, *a3);
  int v4 = [VFXHitTestResult alloc];
  id v7 = (id)objc_msgSend_initWithResult_(v4, v5, (uint64_t)v3, v6);
  if (v3) {
    CFRelease(v3);
  }
  return v7;
}

void sub_1B643FD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1B643FD70(void *a1)
{
  *a1 = &unk_1F0FB1B38;
  uint64_t v2 = (uint64_t)(a1 + 18);
  sub_1B6441B40((uint64_t)(a1 + 30));
  sub_1B6441B40((uint64_t)(a1 + 26));
  sub_1B6441B40((uint64_t)(a1 + 22));
  sub_1B6441B40(v2);
  return a1;
}

void *sub_1B64402F4(uint64_t a1, uint64_t a2, double *a3, double *a4, float a5, float a6)
{
  uint64_t v6 = 0;
  if (a1 && (*(_DWORD *)(a1 + 264) & 2) != 0)
  {
    id v13 = (id)objc_opt_new();
    if ((*(unsigned char *)(a1 + 264) & 2) != 0
      && (uint64_t v14 = *(void *)(a1 + 536)) != 0
      && (v6 = v13, (CFNumberRef v15 = sub_1B6583674(*(id **)(v14 + 72))) != 0))
    {
      uint64_t v19 = (uint64_t)v15;
      if (a2 && (*(unsigned char *)(a2 + 264) & 2) != 0 && (uint64_t v20 = *(void *)(a2 + 536)) != 0) {
        uint64_t v21 = sub_1B6583674(*(id **)(v20 + 72));
      }
      else {
        uint64_t v21 = 0;
      }
      *(float *)&double v17 = -a5;
      *(float *)&double v18 = a6;
      objc_msgSend__fillNodeA_nodeB_contactPoint_collisionImpulse_distance_hitFraction_(v6, v16, v19, (uint64_t)v21, *a3, *a4, v17, v18);
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t sub_1B6440444(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 8);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    int v3 = *(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 8) + 24);
    return v3();
  }
  return result;
}

uint64_t sub_1B6440750(uint64_t result, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, __n128 a7)
{
  if (a2)
  {
    uint64_t v12 = result;
    float v13 = *(float *)(result + 228);
    uint64_t v14 = *(void *)(a2 + 536);
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    CFNumberRef v15 = (__n128 *)sub_1B6E073B8(80, 16);
    sub_1B6544084((uint64_t)v15, (uint64_t)a3, v13);
    sub_1B65440AC(v15, a7);
    *(void *)(a2 + 536) = v15;
    if (v15) {
      (*(void (**)(__n128 *, uint64_t))(v15->n128_u64[0] + 16))(v15, a2 + 16);
    }
    uint64_t result = sub_1B63F4F54(a3, v16, v17, v18, v19, v20, v21, v22);
    if (result)
    {
      uint64_t result = sub_1B64A3178((uint64_t)a3, v23, v24, v25, v26, v27, v28, v29);
      if ((result & 1) == 0)
      {
        if (sub_1B649F390((uint64_t)a3, v30, v31, v32, v33, v34, v35, v36)) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Node should be visible", v37, v38, v39, v40, v41, v42, (uint64_t)"CFXNodeIsHidden(nodeRef) == false");
        }
        uint64_t v43 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 176);
        return v43(v12, a2, a4, a5, a6);
      }
    }
  }
  return result;
}

void sub_1B64408E4(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

void sub_1B64409C4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(unsigned int *)(a1 + 10540);
  if ((int)v5 <= 0)
  {
    long long v16 = 0uLL;
    if ((v5 & 0x80000000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_15;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 16 * v5;
  do
  {
    uint64_t v8 = *(void *)(a1 + 10552) + v6;
    int v9 = *(void **)v8;
    int v10 = *(_DWORD *)(v8 + 8);
    switch(v10)
    {
      case 2:
        objc_msgSend_physicsWorld_didEndContact_(*(void **)(a1 + 10520), a2, *(void *)(a1 + 10512), (uint64_t)v9);
        break;
      case 1:
        if (objc_msgSend__shouldPostUpdate(v9, a2, a3, a4)) {
          objc_msgSend_physicsWorld_didUpdateContact_(*(void **)(a1 + 10520), v11, *(void *)(a1 + 10512), (uint64_t)v9);
        }
        break;
      case 0:
        objc_msgSend_physicsWorld_didBeginContact_(*(void **)(a1 + 10520), a2, *(void *)(a1 + 10512), (uint64_t)v9);
        break;
    }

    v6 += 16;
  }
  while (v7 != v6);
  LODWORD(v5) = *(_DWORD *)(a1 + 10540);
  long long v16 = 0uLL;
  if ((int)v5 <= 0 && (v5 & 0x80000000) != 0)
  {
LABEL_15:
    if ((*(_DWORD *)(a1 + 10544) & 0x80000000) != 0)
    {
      uint64_t v12 = *(void *)(a1 + 10552);
      if (v12 && *(unsigned char *)(a1 + 10560)) {
        sub_1B6E073C4(v12);
      }
      *(unsigned char *)(a1 + 10560) = 1;
      *(void *)(a1 + 10552) = 0;
      *(_DWORD *)(a1 + 10544) = 0;
    }
    uint64_t v13 = 16 * (int)v5;
    uint64_t v14 = (int)v5 + 1;
    do
    {
      *(_OWORD *)(*(void *)(a1 + 10552) + v13) = v16;
      v13 += 16;
    }
    while (v14++);
  }
LABEL_22:
  *(_DWORD *)(a1 + 10540) = 0;
}

void *sub_1B64412DC(id *a1, id *a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1B6583674(a1);
  if (result)
  {
    int v4 = result;
    uint64_t result = sub_1B6583674(a2);
    if (result)
    {
      uint64_t result = objc_msgSend_physicsBody(result, v5, v6, v7);
      if (result)
      {
        CFNumberRef v11 = result;
        uint64_t v12 = objc_msgSend_physicsWorld(v4, v8, v9, v10);
        uint64_t v16 = objc_msgSend_categoryBitMask(v11, v13, v14, v15);
        uint64_t v20 = objc_msgSend_collisionBitMask(v11, v17, v18, v19);
        uint64_t v24 = objc_msgSend_contactTestBitMask(v11, v21, v22, v23);
        objc_msgSend_addPhysicsBody_nodeRef_colGroup_colMask_colTest_(v12, v25, (uint64_t)v11, (uint64_t)a2, v16, v20, v24);
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        uint64_t v29 = objc_msgSend_physicsJoints(v12, v26, v27, v28, 0);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v29, v30, (uint64_t)&v46, (uint64_t)v50, 16);
        if (result)
        {
          uint64_t v34 = result;
          uint64_t v35 = *(void *)v47;
          do
          {
            uint64_t v36 = 0;
            do
            {
              if (*(void *)v47 != v35) {
                objc_enumerationMutation(v29);
              }
              uint64_t v37 = *(void **)(*((void *)&v46 + 1) + 8 * (void)v36);
              if (objc_msgSend_bodyA(v37, v31, v32, v33) == v11
                || objc_msgSend_bodyB(v37, v31, v32, v33) == v11)
              {
                uint64_t v38 = objc_msgSend_bodyA(v37, v31, v32, v33);
                if (objc_msgSend_isActive(v38, v39, v40, v41))
                {
                  uint64_t v42 = objc_msgSend_bodyB(v37, v31, v32, v33);
                  if (objc_msgSend_isActive(v42, v43, v44, v45)) {
                    objc_msgSend_activatePhysicsJoint_(v12, v31, (uint64_t)v37, v33);
                  }
                }
              }
              uint64_t v36 = (char *)v36 + 1;
            }
            while (v34 != v36);
            uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v29, v31, (uint64_t)&v46, (uint64_t)v50, 16);
            uint64_t v34 = result;
          }
          while (result);
        }
      }
    }
  }
  return result;
}

void *sub_1B6441484(id *a1, id *a2)
{
  uint64_t result = sub_1B6583674(a1);
  if (result)
  {
    int v4 = result;
    uint64_t result = sub_1B6583674(a2);
    if (result)
    {
      uint64_t result = objc_msgSend_physicsBody(result, v5, v6, v7);
      if (result)
      {
        CFNumberRef v11 = result;
        uint64_t v12 = objc_msgSend__handle(result, v8, v9, v10);
        uint64_t v16 = objc_msgSend_physicsWorld(v4, v13, v14, v15);
        return (void *)MEMORY[0x1F4181798](v16, sel_removePhysicsBody_handle_, v11, v12);
      }
    }
  }
  return result;
}

uint64_t sub_1B6441508(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_1B6DD1A64(a1, a2);
  *(void *)uint64_t v5 = &unk_1F0FB2058;
  *(void *)(v5 + 10496) = &unk_1F0FB2108;
  *(void *)(v5 + 10512) = a3;
  *(unsigned char *)(v5 + 10560) = 1;
  *(void *)(v5 + 10552) = 0;
  *(void *)(v5 + 10540) = 0;
  sub_1B643EB70(v5, 0);
  return a1;
}

void sub_1B6441598(_Unwind_Exception *a1)
{
  sub_1B6441B40((uint64_t)(v1 + 1317));
  sub_1B6DD1D3C(v1);
  _Unwind_Resume(a1);
}

void sub_1B64415BC(uint64_t a1)
{
  sub_1B6441B88(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B64415F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1B6DD1E4C(a1, a2, a3);
  if (*(_DWORD *)(a1 + 10504)) {
    *(void *)(result + 824) = a1 + 10496;
  }
  return result;
}

uint64_t sub_1B644162C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_1B6441634(uint64_t a1, int a2)
{
  return *(void *)(*(void *)(a1 + 32) + 8 * a2);
}

uint64_t sub_1B6441640(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20)) {
    return *(void *)(a1 + 32);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B6441658(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t sub_1B6441660(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

void sub_1B6441668(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = (unsigned char *)(a1 + 10528);
  if (*(unsigned char *)(a1 + 10528) || *(unsigned char *)(a1 + 10529) || *(unsigned char *)(a1 + 10530))
  {
    uint64_t v6 = a3;
    *(void *)(a2 + 192 * a3 + 128) = objc_alloc_init(VFXPhysicsContact);
    if (*v5)
    {
      uint64_t v8 = *(void **)(a2 + 784);
      if (v8) {
        uint64_t v8 = (void *)v8[25];
      }
      uint64_t v9 = *(void *)(a2 + 792);
      if (v9)
      {
        if (v8)
        {
          uint64_t v10 = *(void *)(v9 + 200);
          if (v10)
          {
            if ((*(void *)(v10 + 8) & v8[3]) != 0 || (*(void *)(v10 + 24) & v8[1]) != 0)
            {
              id v11 = (id)objc_msgSend__contactWithManifold_index_(VFXPhysicsContact, v7, a2, v6);
              int v12 = *(_DWORD *)(a1 + 10540);
              if (v12 == *(_DWORD *)(a1 + 10544))
              {
                int v13 = v12 ? 2 * v12 : 1;
                if (v12 < v13)
                {
                  if (v13)
                  {
                    uint64_t v14 = sub_1B6E073B8(16 * v13, 16);
                    int v12 = *(_DWORD *)(a1 + 10540);
                  }
                  else
                  {
                    uint64_t v14 = 0;
                  }
                  if (v12 >= 1)
                  {
                    uint64_t v15 = 0;
                    uint64_t v16 = 16 * v12;
                    do
                    {
                      *(_OWORD *)(v14 + v15) = *(_OWORD *)(*(void *)(a1 + 10552) + v15);
                      v15 += 16;
                    }
                    while (v16 != v15);
                  }
                  uint64_t v17 = *(void *)(a1 + 10552);
                  if (v17)
                  {
                    if (v5[32]) {
                      sub_1B6E073C4(v17);
                    }
                  }
                  v5[32] = 1;
                  *(void *)(a1 + 10552) = v14;
                  *(_DWORD *)(a1 + 10544) = v13;
                  int v12 = *(_DWORD *)(a1 + 10540);
                }
              }
              uint64_t v18 = *(void *)(a1 + 10552) + 16 * v12;
              *(void *)uint64_t v18 = v11;
              *(_DWORD *)(v18 + 8) = 0;
              ++*(_DWORD *)(a1 + 10540);
            }
          }
        }
      }
    }
  }
}

void sub_1B64417E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  uint64_t v11 = a1 + 10529;
  if (!*(unsigned char *)(a1 + 10529)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. update should not be called if not implemented by the delegate", a3, a4, a5, a6, a7, a8, (uint64_t)"_implementDidUpdateContact");
  }
  int v12 = *(void **)(a2 + 784);
  uint64_t v13 = *(void *)(a2 + 792);
  if (v12) {
    int v12 = (void *)v12[25];
  }
  if (v13)
  {
    if (v12)
    {
      uint64_t v14 = *(void *)(v13 + 200);
      if (v14)
      {
        if ((*(void *)(v14 + 8) & v12[3]) != 0 || (*(void *)(v14 + 24) & v12[1]) != 0)
        {
          id v17 = (id)objc_msgSend__contactWithManifold_index_(VFXPhysicsContact, (const char *)a2, a2, v8);
          int v18 = *(_DWORD *)(a1 + 10540);
          if (v18 == *(_DWORD *)(a1 + 10544))
          {
            int v19 = v18 ? 2 * v18 : 1;
            if (v18 < v19)
            {
              if (v19)
              {
                uint64_t v20 = sub_1B6E073B8(16 * v19, 16);
                int v18 = *(_DWORD *)(a1 + 10540);
              }
              else
              {
                uint64_t v20 = 0;
              }
              if (v18 >= 1)
              {
                uint64_t v21 = 0;
                uint64_t v22 = 16 * v18;
                do
                {
                  *(_OWORD *)(v20 + v21) = *(_OWORD *)(*(void *)(a1 + 10552) + v21);
                  v21 += 16;
                }
                while (v22 != v21);
              }
              uint64_t v23 = *(void *)(a1 + 10552);
              if (v23 && *(unsigned char *)(v11 + 31)) {
                sub_1B6E073C4(v23);
              }
              *(unsigned char *)(v11 + 31) = 1;
              *(void *)(a1 + 10552) = v20;
              *(_DWORD *)(a1 + 10544) = v19;
              int v18 = *(_DWORD *)(a1 + 10540);
            }
          }
          uint64_t v24 = *(void *)(a1 + 10552) + 16 * v18;
          *(void *)uint64_t v24 = v17;
          *(_DWORD *)(v24 + 8) = 1;
          ++*(_DWORD *)(a1 + 10540);
          MEMORY[0x1F4181798](v17, sel__prepareUpdate, v15, v16);
        }
      }
    }
  }
}

void sub_1B6441990(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  uint64_t v11 = (unsigned char *)(a1 + 10530);
  if (*(unsigned char *)(a1 + 10530)
    || (sub_1B63F2F54(17, @"Assertion '%s' failed. update should not be called if not implemented by the delegate", a3, a4, a5, a6, a7, a8, (uint64_t)"_implementDidEndContact"), *v11))
  {
    int v12 = *(void **)(a2 + 784);
    if (v12) {
      int v12 = (void *)v12[25];
    }
    uint64_t v13 = *(void *)(a2 + 792);
    if (v13)
    {
      if (v12)
      {
        uint64_t v14 = *(void *)(v13 + 200);
        if (v14)
        {
          if ((*(void *)(v14 + 8) & v12[3]) != 0 || (*(void *)(v14 + 24) & v12[1]) != 0)
          {
            id v15 = (id)objc_msgSend__contactWithManifold_index_(VFXPhysicsContact, (const char *)a2, a2, v8);
            int v16 = *(_DWORD *)(a1 + 10540);
            if (v16 == *(_DWORD *)(a1 + 10544))
            {
              int v17 = v16 ? 2 * v16 : 1;
              if (v16 < v17)
              {
                if (v17)
                {
                  uint64_t v18 = sub_1B6E073B8(16 * v17, 16);
                  int v16 = *(_DWORD *)(a1 + 10540);
                }
                else
                {
                  uint64_t v18 = 0;
                }
                if (v16 >= 1)
                {
                  uint64_t v19 = 0;
                  uint64_t v20 = 16 * v16;
                  do
                  {
                    *(_OWORD *)(v18 + v19) = *(_OWORD *)(*(void *)(a1 + 10552) + v19);
                    v19 += 16;
                  }
                  while (v20 != v19);
                }
                uint64_t v21 = *(void *)(a1 + 10552);
                if (v21)
                {
                  if (v11[30]) {
                    sub_1B6E073C4(v21);
                  }
                }
                v11[30] = 1;
                *(void *)(a1 + 10552) = v18;
                *(_DWORD *)(a1 + 10544) = v17;
                int v16 = *(_DWORD *)(a1 + 10540);
              }
            }
            uint64_t v22 = *(void *)(a1 + 10552) + 16 * v16;
            *(void *)uint64_t v22 = v15;
            *(_DWORD *)(v22 + 8) = 2;
            ++*(_DWORD *)(a1 + 10540);
          }
        }
      }
    }
  }
}

void sub_1B6441B18(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_1B6441B24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B6441B30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B6441B40(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 && *(unsigned char *)(a1 + 24)) {
    sub_1B6E073C4(v2);
  }
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

double sub_1B6441B88(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB2058;
  *(void *)(a1 + 10496) = &unk_1F0FB2108;
  if (*(void *)(a1 + 10520))
  {
    int v2 = *(_DWORD *)(a1 + 20);
    if (v2 >= 1)
    {
      for (uint64_t i = 0; i < v2; ++i)
      {
        uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8 * i);
        if (v4)
        {
          if (*(int *)(v4 + 800) >= 1)
          {
            uint64_t v5 = 0;
            uint64_t v6 = v4 + 16;
            do
            {
              sub_1B6DF3428((void *)v4, v6);
              ++v5;
              v6 += 192;
            }
            while (v5 < *(int *)(v4 + 800));
            int v2 = *(_DWORD *)(a1 + 20);
          }
          *(_DWORD *)(v4 + 800) = 0;
        }
      }
    }
  }
  sub_1B6441B40(a1 + 10536);

  return sub_1B6DD1D3C((void *)a1);
}

void sub_1B6441C84(_Unwind_Exception *a1)
{
  sub_1B6441B40((uint64_t)(v1 + 1317));
  sub_1B6DD1D3C(v1);
  _Unwind_Resume(a1);
}

void sub_1B6441CA8()
{
}

void sub_1B6441CBC(uint64_t a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    float v10 = *(float *)(a1 + 12);
    float32x4_t v11 = vmulq_n_f32(*a2, v10);
    float32x4_t v12 = vmulq_n_f32(*a3, v10);
    uint64_t v13 = *(void *)a4;
    int v14 = *(_DWORD *)(a4 + 8);
    int v15 = 1065353216;
    sub_1B642AB40(v9, 0, (float *)&v13, a4, a5, a6, a7, a8, v11, v12);
  }
}

void sub_1B6441D1C(uint64_t a1, float32x4_t *a2, float32x4_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(uint64_t **)(a1 + 16);
  if (v9)
  {
    float v10 = *(float *)(a1 + 12);
    float32x4_t v11 = vmulq_n_f32(*a2, v10);
    float32x4_t v12 = vmulq_n_f32(*a3, v10);
    uint64_t v16 = *a4;
    int v17 = *((_DWORD *)a4 + 2);
    int v18 = 1065353216;
    uint64_t v13 = *(void *)a5;
    int v14 = *(_DWORD *)(a5 + 8);
    int v15 = 1065353216;
    sub_1B642B758(v9, 0, (float *)&v16, (float *)&v13, a5, a6, a7, a8, v11, v12);
  }
}

void sub_1B6441D94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10)
  {
    *(void *)&long long v24 = *(void *)a3;
    DWORD2(v24) = *(_DWORD *)(a3 + 8);
    int32x4_t v11 = *(int32x4_t *)a2;
    int32x4_t v12 = *(int32x4_t *)(a2 + 16);
    int8x16_t v14 = *(int8x16_t *)(a2 + 32);
    float32x4_t v13 = *(float32x4_t *)(a2 + 48);
    int8x16_t v15 = (int8x16_t)vtrn1q_s32(*(int32x4_t *)a2, v12);
    *(void *)&long long v16 = vextq_s8(v15, v15, 8uLL).u64[0];
    v15.i64[1] = v14.u32[0];
    HIDWORD(v24) = 1065353216;
    *(int32x2_t *)v12.i8 = vzip2_s32(*(int32x2_t *)v11.i8, *(int32x2_t *)v12.i8);
    v12.u64[1] = (unint64_t)vzip2_s32(*(int32x2_t *)v14.i8, 0);
    *((void *)&v16 + 1) = vextq_s8(v14, v14, 8uLL).u32[0];
    float32x4_t v17 = v13;
    v17.i32[3] = 1.0;
    v22[0] = (__int128)v15;
    v22[1] = (__int128)v12;
    v22[2] = v16;
    float32x4_t v23 = v17;
    float v18 = *(float *)(a1 + 12);
    if (v18 != 1.0)
    {
      float32x4_t v19 = vmulq_n_f32(v13, v18);
      v19.i32[3] = 1.0;
      float32x4_t v23 = v19;
    }
    float v20 = a9 * 1.02 * v18;
    v21.n128_u64[0] = 0;
    v21.n128_u32[2] = 0;
    v21.n128_f32[3] = v20;
    sub_1B642AC18(v10, v22, &v24, a4, a5, a6, a7, a8, v21);
  }
}

uint64_t sub_1B6441E64(uint64_t a1, long long *a2)
{
  v4[0] = xmmword_1B6E4F300;
  v4[1] = xmmword_1B6E4F320;
  long long v2 = *a2;
  v4[2] = xmmword_1B6E4F2E0;
  v4[3] = v2;
  return (*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)a1 + 32))(a1, v4);
}

uint64_t sub_1B6441ECC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3, a4, a8);
}

uint64_t sub_1B6441EF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, a2, a3, a5);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, a3, a4, a5);
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 16);

  return v10(a1, a4, a2, a5);
}

void sub_1B6441FD0(uint64_t a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10)
  {
    float v11 = *(float *)(a1 + 12);
    float32x4_t v12 = vmulq_n_f32(*a2, v11);
    float32x4_t v13 = vmlaq_n_f32(v12, vmulq_n_f32(*a3, a9), v11);
    uint64_t v14 = *(void *)a5;
    int v15 = *(_DWORD *)(a5 + 8);
    int v16 = 1065353216;
    sub_1B642AB40(v10, 0, (float *)&v14, a4, a5, a6, a7, a8, v12, v13);
  }
}

void sub_1B644203C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B6442070(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8) = a2;
  return result;
}

uint64_t sub_1B6442078(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_1B6442080(uint64_t a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4)
{
  unint64_t v6 = 0;
  v7.i64[0] = 0x3F0000003F000000;
  v7.i64[1] = 0x3F0000003F000000;
  float32x4_t v8 = vmulq_f32(vsubq_f32(*a3, *a2), v7);
  float32x4_t v9 = vmulq_f32(vaddq_f32(*a3, *a2), v7);
  v9.i32[3] = 0;
  long long v21 = xmmword_1B6E4F540;
  float v10 = v8.f32[2];
  float32x4_t v17 = v9;
  uint64_t v18 = v8.i64[0];
  do
  {
    uint64_t v11 = 0;
    float32x2_t v12 = (float32x2_t)v21;
    float v13 = *((float *)&v21 + 2);
    do
    {
      *(float32x2_t *)v14.f32 = vmul_f32(*(float32x2_t *)v8.f32, v12);
      *(float *)((char *)&v21 + v11) = -*(float *)((char *)&v21 + v11);
      v14.f32[2] = v10 * v13;
      float32x2_t v12 = (float32x2_t)v21;
      *(float32x2_t *)v15.f32 = vmul_f32(*(float32x2_t *)v8.f32, *(float32x2_t *)&v21);
      float v13 = *((float *)&v21 + 2);
      v15.f32[2] = v10 * *((float *)&v21 + 2);
      v14.i32[3] = 0;
      v15.i32[3] = 0;
      float32x4_t v19 = vaddq_f32(v15, v9);
      float32x4_t v20 = vaddq_f32(v14, v9);
      uint64_t result = (*(uint64_t (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v20, &v19, a4);
      float32x4_t v9 = v17;
      v8.i64[0] = v18;
      v11 += 4;
    }
    while (v11 != 12);
    long long v21 = xmmword_1B6E50990;
    if (v6 <= 2) {
      *((float *)&v21 + v6) = -*((float *)&v21 + v6);
    }
    ++v6;
  }
  while (v6 != 4);
  return result;
}

uint64_t sub_1B64421CC(uint64_t a1, float32x4_t *a2, float a3)
{
  float32x4_t v5 = a2[3];
  int8x16_t v6 = (int8x16_t)vmulq_f32((float32x4_t)LODWORD(a3), *a2);
  int8x16_t v7 = (int8x16_t)vmulq_f32((float32x4_t)LODWORD(a3), a2[1]);
  int8x16_t v8 = (int8x16_t)vmulq_f32((float32x4_t)LODWORD(a3), a2[2]);
  v8.i32[3] = 0;
  *(float32x2_t *)v9.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v6.i8, *(float32x2_t *)v7.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
  *(float32x2_t *)&v9.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)), 0);
  float32x4_t v21 = vaddq_f32(v5, v9);
  float32x4_t v22 = v5;
  long long v20 = xmmword_1B6E509A0;
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, long long *))(*(void *)a1 + 16))(a1, &v22, &v21, &v20);
  LODWORD(v10) = 0;
  *((float *)&v10 + 1) = a3;
  float32x4_t v11 = vmulq_f32((float32x4_t)v10, *a2);
  int8x16_t v12 = (int8x16_t)vmulq_f32((float32x4_t)v10, a2[1]);
  int8x16_t v13 = (int8x16_t)vmulq_f32((float32x4_t)v10, a2[2]);
  v13.i32[3] = 0;
  *(float32x2_t *)v11.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)v12.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v11, (int8x16_t)v11, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)));
  *(float32x2_t *)&v11.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL)), 0);
  long long v20 = xmmword_1B6E509B0;
  float32x4_t v21 = vaddq_f32(v11, v22);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, long long *))(*(void *)a1 + 16))(a1, &v22, &v21, &v20);
  v14.i64[0] = 0;
  v14.i64[1] = LODWORD(a3);
  float32x4_t v15 = vmulq_f32(v14, *a2);
  int8x16_t v16 = (int8x16_t)vmulq_f32(v14, a2[1]);
  int8x16_t v17 = (int8x16_t)vmulq_f32(v14, a2[2]);
  v17.i32[3] = 0;
  *(float32x2_t *)v15.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v15.f32, *(float32x2_t *)v16.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL)));
  *(float32x2_t *)&v15.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL)), 0);
  long long v20 = xmmword_1B6E509C0;
  float32x4_t v21 = vaddq_f32(v15, v22);
  return (*(uint64_t (**)(uint64_t, float32x4_t *, float32x4_t *, long long *))(*(void *)a1 + 16))(a1, &v22, &v21, &v20);
}

void sub_1B64423B4(uint64_t a1, float32x4_t *a2, int8x8_t *a3, int8x8_t *a4, uint64_t a5, int a6, float a7, float a8, float a9, float a10, float a11)
{
  float32x4_t v17 = *(float32x4_t *)a4->i8;
  *(int8x8_t *)v18.f32 = vext_s8(*a3, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a3->i8, *(int8x16_t *)a3->i8, 8uLL), 4uLL);
  *(int8x8_t *)&v18.u32[2] = *a3;
  *(int8x8_t *)v19.f32 = vext_s8(*a4, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL), 4uLL);
  *(int8x8_t *)&v19.u32[2] = *a4;
  int8x16_t v20 = (int8x16_t)vsubq_f32(vmulq_f32(*(float32x4_t *)a3->i8, v19), vmulq_f32(*(float32x4_t *)a4->i8, v18));
  v19.i64[0] = vextq_s8(v20, v20, 4uLL).u64[0];
  v19.i64[1] = v20.u32[0];
  float32x4_t v34 = v19;
  float v21 = a10 - a9;
  if ((int)(float)((float)(a10 - a9) / (float)(a11 * 0.017453)) <= 1) {
    int v22 = 1;
  }
  else {
    int v22 = (int)(float)((float)(a10 - a9) / (float)(a11 * 0.017453));
  }
  float32x4_t v32 = vmulq_n_f32(v17, a7);
  __float2 v23 = __sincosf_stret(a9);
  float32x4_t v24 = vmulq_n_f32(v32, v23.__cosval);
  v24.i32[3] = 0;
  float32x4_t v35 = vmulq_n_f32(v34, a8);
  float32x4_t v25 = vmulq_n_f32(v35, v23.__sinval);
  v25.i32[3] = 0;
  float32x4_t v40 = vaddq_f32(vaddq_f32(*a2, v24), v25);
  if (a6) {
    (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, a2, &v40, a5);
  }
  float v26 = a7;
  if (v22 >= 1)
  {
    int v27 = 0;
    float32x4_t v28 = v35;
    v28.i32[3] = 0;
    float32x4_t v36 = v28;
    do
    {
      ++v27;
      float32x4_t v38 = vmulq_n_f32(*(float32x4_t *)a4->i8, v26);
      __float2 v29 = __sincosf_stret((float)((float)(v21 * (float)v27) / (float)v22) + a9);
      float32x4_t v30 = vmulq_n_f32(v38, v29.__cosval);
      v30.i32[3] = 0;
      float32x4_t v31 = vmulq_n_f32(v36, v29.__sinval);
      v31.i32[3] = 0;
      float32x4_t v39 = vaddq_f32(vaddq_f32(*a2, v30), v31);
      (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v40, &v39, a5);
      float v26 = a7;
      float32x4_t v40 = v39;
    }
    while (v22 != v27);
  }
  if (a6) {
    (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, a2, &v40, a5);
  }
}

void sub_1B64425E0(uint64_t a1, float32x4_t *a2, float32x4_t *a3, int8x8_t *a4, uint64_t a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  float32x4_t v13 = *a3;
  float32x4_t v14 = vmulq_n_f32(*a3, a6);
  float32x4_t v16 = vsubq_f32(*a2, v14);
  v14.i32[3] = 0;
  float32x4_t v17 = vaddq_f32(*a2, v14);
  v16.i32[3] = 0;
  float32x4_t v67 = v16;
  float32x4_t v68 = v17;
  float v18 = a11 * 0.017453;
  *(int8x8_t *)v19.f32 = vext_s8(*(int8x8_t *)v13.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), 4uLL);
  v19.i64[1] = v13.i64[0];
  *(int8x8_t *)v20.f32 = vext_s8(*a4, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a4->i8, *(int8x16_t *)a4->i8, 8uLL), 4uLL);
  *(int8x8_t *)&v20.u32[2] = *a4;
  int8x16_t v21 = (int8x16_t)vsubq_f32(vmulq_f32(v13, v20), vmulq_f32(v19, *(float32x4_t *)a4->i8));
  v22.i64[0] = vextq_s8(v21, v21, 4uLL).u64[0];
  v22.i64[1] = v21.i64[0];
  BOOL v58 = a7 <= -1.5708;
  if (a7 > -1.5708) {
    float v23 = a7;
  }
  else {
    float v23 = v18 + -1.5708;
  }
  BOOL v59 = a8 >= 1.5708;
  if (a8 < 1.5708) {
    float v24 = a8;
  }
  else {
    float v24 = 1.5708 - v18;
  }
  if (v23 > v24)
  {
    BOOL v58 = 1;
    BOOL v59 = 1;
    float v24 = 1.5708 - v18;
    float v23 = v18 + -1.5708;
  }
  int v25 = 0;
  float32x4_t v26 = v22;
  v26.i32[3] = 0;
  float32x4_t v65 = v26;
  float v27 = v24 - v23;
  if ((int)(float)(v27 / v18) <= 1) {
    int v28 = 1;
  }
  else {
    int v28 = (int)(float)(v27 / v18);
  }
  BOOL v29 = a9 <= a10;
  BOOL v30 = a9 > a10;
  float v31 = 3.1416;
  if (a9 <= a10) {
    float v31 = a10;
  }
  float v32 = a10 - a9;
  if (v29) {
    float v33 = a9;
  }
  else {
    float v33 = v18 + -3.1416;
  }
  if (v32 >= 6.2832) {
    BOOL v30 = 1;
  }
  BOOL v62 = v30;
  int v34 = (int)(float)((float)(v31 - v33) / v18);
  if (v34 <= 1) {
    int v34 = 1;
  }
  float v35 = v27 / (float)v28;
  float v36 = (float)(v31 - v33) / (float)v34;
  uint64_t v37 = 16 * v34;
  float32x4_t v38 = &v69;
  float32x4_t v39 = &v70;
  int v56 = v28;
  while (2)
  {
    uint64_t v61 = v39;
    __float2 v40 = __sincosf_stret(v23 + (float)((float)v25 * v35));
    int v41 = 0;
    unint64_t v42 = 0;
    float v43 = v40.__cosval * a6;
    BOOL v44 = v25 == 0;
    BOOL v45 = v25 == v28;
    BOOL v46 = v25 == v28 && v58;
    if (v45) {
      BOOL v44 = 1;
    }
    BOOL v60 = v44;
    do
    {
      __float2 v47 = __sincosf_stret(v33 + (float)((float)v41 * v36));
      float32x4_t v48 = vmulq_n_f32(*(float32x4_t *)a4->i8, v43 * v47.__cosval);
      v48.i32[3] = 0;
      float32x4_t v49 = vmulq_n_f32(v65, v43 * v47.__sinval);
      v49.i32[3] = 0;
      float32x4_t v50 = vaddq_f32(vaddq_f32(*a2, v48), v49);
      float32x4_t v51 = vmulq_n_f32(*a3, v40.__sinval * a6);
      v51.i32[3] = 0;
      *(float32x4_t *)&v38[v42] = vaddq_f32(v50, v51);
      if (v25)
      {
        double v52 = (float32x4_t *)&v61[v42];
      }
      else
      {
        if (!v59) {
          goto LABEL_34;
        }
        double v52 = &v67;
      }
      (*(void (**)(uint64_t, float32x4_t *, char *, uint64_t))(*(void *)a1 + 16))(a1, v52, &v38[v42], a5);
LABEL_34:
      if (v42)
      {
        (*(void (**)(uint64_t, char *, char *, uint64_t))(*(void *)a1 + 16))(a1, &v38[v42 - 16], &v38[v42], a5);
        if (!v46) {
          goto LABEL_37;
        }
LABEL_36:
        (*(void (**)(uint64_t, float32x4_t *, char *, uint64_t))(*(void *)a1 + 16))(a1, &v68, &v38[v42], a5);
        goto LABEL_37;
      }
      long long v66 = *(_OWORD *)v38;
      if (v46) {
        goto LABEL_36;
      }
LABEL_37:
      if (v62)
      {
        if (v37 != v42) {
          goto LABEL_47;
        }
        float v53 = (float32x4_t *)&v66;
LABEL_46:
        (*(void (**)(uint64_t, float32x4_t *, char *, uint64_t))(*(void *)a1 + 16))(a1, v53, &v38[v42], a5);
        goto LABEL_47;
      }
      if (v42) {
        BOOL v54 = v37 == v42;
      }
      else {
        BOOL v54 = 1;
      }
      BOOL v55 = v60;
      if (!v54) {
        BOOL v55 = 0;
      }
      float v53 = a2;
      if (v55) {
        goto LABEL_46;
      }
LABEL_47:
      v42 += 16;
      ++v41;
    }
    while (v37 + 16 != v42);
    float32x4_t v39 = v38;
    float32x4_t v38 = v61;
    int v28 = v56;
    BOOL v45 = v25++ == v56;
    if (!v45) {
      continue;
    }
    break;
  }
}

uint64_t sub_1B64429DC(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  unsigned int v8 = a2[1];
  int v29 = *a2;
  LODWORD(v30) = v8;
  HIDWORD(v30) = a2[2];
  int v31 = 0;
  *(_DWORD *)float v27 = *a3;
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), v8);
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *))(*(void *)a1 + 16))(a1, &v29, v27);
  int v9 = a2[2];
  LODWORD(v30) = a2[1];
  HIDWORD(v30) = v9;
  int v31 = 0;
  uint64_t v10 = *(void *)a3;
  int v29 = *(void *)a3;
  *(void *)float v27 = v10;
  *(_DWORD *)&v27[8] = v9;
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  unsigned int v11 = a3[1];
  int v29 = *a3;
  LODWORD(v30) = v11;
  HIDWORD(v30) = a2[2];
  int v31 = 0;
  *(_DWORD *)float v27 = *a2;
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), v11);
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  int v12 = a2[2];
  LODWORD(v30) = a3[1];
  HIDWORD(v30) = v12;
  int v31 = 0;
  uint64_t v13 = *(void *)a2;
  int v29 = *(void *)a2;
  *(void *)float v27 = v13;
  *(_DWORD *)&v27[8] = v12;
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  int v29 = *a2;
  unint64_t v30 = *(void *)(a2 + 1);
  int v31 = 0;
  *(_DWORD *)float v27 = v29;
  *(_DWORD *)&v27[4] = v30;
  *(_DWORD *)&v27[8] = a3[2];
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  int v29 = *a3;
  unint64_t v30 = *(void *)(a2 + 1);
  int v31 = 0;
  *(_DWORD *)float v27 = v29;
  *(_DWORD *)&v27[4] = v30;
  *(_DWORD *)&v27[8] = a3[2];
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  int v14 = *a3;
  unsigned int v15 = a2[2];
  int v31 = 0;
  *(_DWORD *)float v27 = v14;
  uint64_t v16 = *(void *)(a3 + 1);
  int v29 = v14;
  unint64_t v30 = __PAIR64__(v15, v16);
  *(void *)&v27[4] = v16;
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  int v17 = *a2;
  unsigned int v18 = a2[2];
  int v31 = 0;
  *(_DWORD *)float v27 = v17;
  uint64_t v19 = *(void *)(a3 + 1);
  int v29 = v17;
  unint64_t v30 = __PAIR64__(v18, v19);
  *(void *)&v27[4] = v19;
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  unsigned int v20 = a2[1];
  int v29 = *a2;
  LODWORD(v30) = v20;
  HIDWORD(v30) = a3[2];
  int v31 = 0;
  *(_DWORD *)float v27 = *a3;
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), v20);
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  int v21 = a3[2];
  LODWORD(v30) = a2[1];
  HIDWORD(v30) = v21;
  int v31 = 0;
  uint64_t v22 = *(void *)a3;
  int v29 = *(void *)a3;
  *(void *)float v27 = v22;
  *(_DWORD *)&v27[8] = v21;
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  unsigned int v23 = a3[1];
  int v29 = *a3;
  LODWORD(v30) = v23;
  HIDWORD(v30) = a3[2];
  int v31 = 0;
  *(_DWORD *)float v27 = *a2;
  *(void *)&v27[4] = __PAIR64__(HIDWORD(v30), v23);
  int v28 = 0;
  (*(void (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
  int v24 = a3[2];
  LODWORD(v30) = a3[1];
  HIDWORD(v30) = v24;
  int v31 = 0;
  uint64_t v25 = *(void *)a2;
  int v29 = *(void *)a2;
  *(void *)float v27 = v25;
  *(_DWORD *)&v27[8] = v24;
  int v28 = 0;
  return (*(uint64_t (**)(uint64_t, int *, unsigned char *, uint64_t))(*(void *)a1 + 16))(a1, &v29, v27, a4);
}

uint64_t sub_1B6442E28(uint64_t a1, float32x4_t *a2, _DWORD *a3, float32x4_t *a4, uint64_t a5)
{
  float32x4_t v10 = *a2;
  unsigned __int32 v11 = a2->u32[2];
  float32x4_t v12 = *a2;
  v12.i32[2] = v11;
  float32x4_t v13 = a4[2];
  float32x4_t v14 = a4[3];
  int8x16_t v15 = (int8x16_t)vmulq_f32(v12, v13);
  v12.i32[3] = 0;
  float32x4_t v16 = *a4;
  float32x4_t v17 = a4[1];
  int8x16_t v18 = (int8x16_t)vmulq_f32(*a4, v12);
  float32x4_t v19 = vmulq_f32(v12, v17);
  v15.i32[3] = 0;
  unsigned int v20 = &a2->i32[1];
  *(float32x2_t *)v19.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v18.i8, *(float32x2_t *)v19.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL)));
  *(float32x2_t *)&v19.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v19, v14);
  v19.i32[0] = *a3;
  int v21 = a3 + 1;
  v19.i32[1] = v10.i32[1];
  uint64_t v22 = &a2->i32[2];
  v19.i64[1] = v11;
  float32x4_t v23 = vmulq_f32(v16, v19);
  int8x16_t v24 = (int8x16_t)vmulq_f32(v17, v19);
  int8x16_t v25 = (int8x16_t)vmulq_f32(v13, v19);
  v25.i32[3] = 0;
  *(float32x2_t *)v23.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v24.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v23, (int8x16_t)v23, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)));
  *(float32x2_t *)&v23.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v14, v23);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  __int32 v26 = a2->i32[2];
  float32x4_t v27 = *(float32x4_t *)a3;
  v27.i32[3] = 0;
  float32x4_t v28 = v27;
  v28.i32[1] = *v20;
  v28.i32[2] = v26;
  float32x4_t v29 = *a4;
  float32x4_t v30 = a4[1];
  float32x4_t v31 = vmulq_f32(*a4, v28);
  int8x16_t v32 = (int8x16_t)vmulq_f32(v30, v28);
  float32x4_t v33 = a4[2];
  float32x4_t v34 = a4[3];
  int8x16_t v35 = (int8x16_t)vmulq_f32(v28, v33);
  v35.i32[3] = 0;
  *(float32x2_t *)v31.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v31.f32, *(float32x2_t *)v32.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)));
  *(float32x2_t *)&v31.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL)), 0);
  v27.i32[1] = HIDWORD(*(void *)a3);
  float32x4_t v162 = vaddq_f32(v31, v34);
  v27.i32[2] = v26;
  float32x4_t v36 = vmulq_f32(v29, v27);
  int8x16_t v37 = (int8x16_t)vmulq_f32(v30, v27);
  int8x16_t v38 = (int8x16_t)vmulq_f32(v33, v27);
  v38.i32[3] = 0;
  *(float32x2_t *)v36.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v37.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL)));
  *(float32x2_t *)&v36.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v34, v36);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v39 = *(float32x4_t *)a3;
  __int32 v40 = a2->i32[2];
  v41.i32[0] = a2->i32[0];
  v41.i32[1] = HIDWORD(*(void *)a3);
  v39.i32[2] = v40;
  float32x4_t v42 = v39;
  v42.i32[3] = 0;
  float32x4_t v43 = a4[2];
  float32x4_t v44 = a4[3];
  int8x16_t v45 = (int8x16_t)vmulq_f32(v39, v43);
  float32x4_t v46 = *a4;
  float32x4_t v47 = a4[1];
  int8x16_t v48 = (int8x16_t)vmulq_f32(*a4, v42);
  float32x4_t v49 = vmulq_f32(v42, v47);
  v45.i32[3] = 0;
  *(float32x2_t *)v49.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v48.i8, *(float32x2_t *)v49.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL)));
  *(float32x2_t *)&v49.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v45.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v49, v44);
  v41.i32[2] = v40;
  float32x4_t v50 = vmulq_f32(v46, v41);
  int8x16_t v51 = (int8x16_t)vmulq_f32(v47, v41);
  int8x16_t v52 = (int8x16_t)vmulq_f32(v43, v41);
  v52.i32[3] = 0;
  *(float32x2_t *)v50.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v50.f32, *(float32x2_t *)v51.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL)));
  *(float32x2_t *)&v50.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v44, v50);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v53 = *a2;
  v53.i32[3] = 0;
  float32x4_t v54 = v53;
  v54.i32[1] = *v21;
  v54.i32[2] = a2->i64[1];
  float32x4_t v55 = a4[1];
  float32x4_t v56 = vmulq_f32(*a4, v54);
  int8x16_t v57 = (int8x16_t)vmulq_f32(v55, v54);
  float32x4_t v58 = a4[2];
  float32x4_t v59 = a4[3];
  int8x16_t v60 = (int8x16_t)vmulq_f32(v54, v58);
  v60.i32[3] = 0;
  *(float32x2_t *)v56.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v56.f32, *(float32x2_t *)v57.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)));
  *(float32x2_t *)&v56.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v60.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL)), 0);
  v53.i32[0] = (__int32)*a2;
  float32x4_t v61 = vmulq_f32(*a4, v53);
  int8x16_t v62 = (int8x16_t)vmulq_f32(v55, v53);
  int8x16_t v63 = (int8x16_t)vmulq_f32(v58, v53);
  v63.i32[3] = 0;
  *(float32x2_t *)v61.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v61.f32, *(float32x2_t *)v62.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v61, (int8x16_t)v61, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v62, v62, 8uLL)));
  *(float32x2_t *)&v61.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v63.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v59, v61);
  float32x4_t v162 = vaddq_f32(v56, v59);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v64 = *a2;
  v64.i32[3] = 0;
  float32x4_t v65 = v64;
  v65.i32[2] = a2->i64[1];
  float32x4_t v66 = a4[1];
  float32x4_t v67 = vmulq_f32(*a4, v65);
  int8x16_t v68 = (int8x16_t)vmulq_f32(v66, v65);
  float32x4_t v69 = a4[2];
  float32x4_t v70 = a4[3];
  int8x16_t v71 = (int8x16_t)vmulq_f32(v65, v69);
  v71.i32[3] = 0;
  *(float32x2_t *)v67.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v67.f32, *(float32x2_t *)v68.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v67, (int8x16_t)v67, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL)));
  *(float32x2_t *)&v67.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v71.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL)), 0);
  v64.i32[2] = a3[2];
  float32x4_t v72 = vmulq_f32(*a4, v64);
  int8x16_t v73 = (int8x16_t)vmulq_f32(v66, v64);
  int8x16_t v74 = (int8x16_t)vmulq_f32(v69, v64);
  v74.i32[3] = 0;
  *(float32x2_t *)v72.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v72.f32, *(float32x2_t *)v73.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v72, (int8x16_t)v72, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL)));
  *(float32x2_t *)&v72.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v70, v72);
  float32x4_t v162 = vaddq_f32(v67, v70);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v75 = *(float32x4_t *)a3;
  v75.i32[1] = *v20;
  v75.i32[3] = 0;
  float32x4_t v76 = v75;
  v76.i32[2] = *v22;
  float32x4_t v77 = a4[1];
  float32x4_t v78 = vmulq_f32(*a4, v76);
  int8x16_t v79 = (int8x16_t)vmulq_f32(v77, v76);
  float32x4_t v80 = a4[2];
  float32x4_t v81 = a4[3];
  int8x16_t v82 = (int8x16_t)vmulq_f32(v76, v80);
  v82.i32[3] = 0;
  *(float32x2_t *)v78.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v78.f32, *(float32x2_t *)v79.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v78, (int8x16_t)v78, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v79, v79, 8uLL)));
  *(float32x2_t *)&v78.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL)), 0);
  v75.i32[2] = *((void *)a3 + 1);
  float32x4_t v83 = vmulq_f32(*a4, v75);
  int8x16_t v84 = (int8x16_t)vmulq_f32(v77, v75);
  int8x16_t v85 = (int8x16_t)vmulq_f32(v80, v75);
  v85.i32[3] = 0;
  *(float32x2_t *)v83.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v83.f32, *(float32x2_t *)v84.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v83, (int8x16_t)v83, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v84, v84, 8uLL)));
  *(float32x2_t *)&v83.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v81, v83);
  float32x4_t v162 = vaddq_f32(v78, v81);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v86 = *(float32x4_t *)a3;
  v86.i32[3] = 0;
  float32x4_t v87 = v86;
  v87.i32[2] = *v22;
  float32x4_t v88 = a4[1];
  float32x4_t v89 = vmulq_f32(*a4, v87);
  int8x16_t v90 = (int8x16_t)vmulq_f32(v88, v87);
  float32x4_t v91 = a4[2];
  float32x4_t v92 = a4[3];
  int8x16_t v93 = (int8x16_t)vmulq_f32(v87, v91);
  v93.i32[3] = 0;
  *(float32x2_t *)v89.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v89.f32, *(float32x2_t *)v90.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v89, (int8x16_t)v89, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v90, v90, 8uLL)));
  *(float32x2_t *)&v89.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v93.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v93, v93, 8uLL)), 0);
  v86.i32[2] = *((void *)a3 + 1);
  float32x4_t v94 = vmulq_f32(*a4, v86);
  int8x16_t v95 = (int8x16_t)vmulq_f32(v88, v86);
  int8x16_t v96 = (int8x16_t)vmulq_f32(v91, v86);
  v96.i32[3] = 0;
  *(float32x2_t *)v94.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v94.f32, *(float32x2_t *)v95.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v94, (int8x16_t)v94, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v95, v95, 8uLL)));
  *(float32x2_t *)&v94.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v96.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v96, v96, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v92, v94);
  float32x4_t v162 = vaddq_f32(v89, v92);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v97 = *a2;
  v97.i32[1] = *v21;
  v97.i32[3] = 0;
  float32x4_t v98 = v97;
  v98.i32[2] = a2->i64[1];
  float32x4_t v99 = a4[1];
  float32x4_t v100 = vmulq_f32(*a4, v98);
  int8x16_t v101 = (int8x16_t)vmulq_f32(v99, v98);
  float32x4_t v102 = a4[2];
  float32x4_t v103 = a4[3];
  int8x16_t v104 = (int8x16_t)vmulq_f32(v98, v102);
  v104.i32[3] = 0;
  *(float32x2_t *)v100.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v100.f32, *(float32x2_t *)v101.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v100, (int8x16_t)v100, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v101, v101, 8uLL)));
  *(float32x2_t *)&v100.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v104.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v104, v104, 8uLL)), 0);
  v97.i32[2] = a3[2];
  float32x4_t v105 = vmulq_f32(*a4, v97);
  int8x16_t v106 = (int8x16_t)vmulq_f32(v99, v97);
  int8x16_t v107 = (int8x16_t)vmulq_f32(v102, v97);
  v107.i32[3] = 0;
  *(float32x2_t *)v105.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v105.f32, *(float32x2_t *)v106.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v105, (int8x16_t)v105, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v106, v106, 8uLL)));
  *(float32x2_t *)&v105.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v107.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v107, v107, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v103, v105);
  float32x4_t v162 = vaddq_f32(v100, v103);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v108 = *a2;
  __int32 v109 = a3[2];
  v110.i32[0] = *a3;
  v110.i32[1] = HIDWORD(a2->i64[0]);
  v108.i32[2] = v109;
  float32x4_t v111 = v108;
  v111.i32[3] = 0;
  float32x4_t v112 = a4[2];
  float32x4_t v113 = a4[3];
  int8x16_t v114 = (int8x16_t)vmulq_f32(v108, v112);
  float32x4_t v115 = *a4;
  float32x4_t v116 = a4[1];
  int8x16_t v117 = (int8x16_t)vmulq_f32(*a4, v111);
  float32x4_t v118 = vmulq_f32(v111, v116);
  v114.i32[3] = 0;
  *(float32x2_t *)v118.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v117.i8, *(float32x2_t *)v118.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v117, v117, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v118, (int8x16_t)v118, 8uLL)));
  *(float32x2_t *)&v118.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v114.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v114, v114, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v118, v113);
  v110.i32[2] = v109;
  float32x4_t v119 = vmulq_f32(v115, v110);
  int8x16_t v120 = (int8x16_t)vmulq_f32(v116, v110);
  int8x16_t v121 = (int8x16_t)vmulq_f32(v112, v110);
  v121.i32[3] = 0;
  *(float32x2_t *)v119.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v119.f32, *(float32x2_t *)v120.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL)));
  *(float32x2_t *)&v119.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v121.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v121, v121, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v113, v119);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v122 = *(float32x4_t *)a3;
  v122.i32[3] = 0;
  float32x4_t v123 = v122;
  v123.i32[1] = *v20;
  v123.i32[2] = *((void *)a3 + 1);
  float32x4_t v124 = a4[1];
  float32x4_t v125 = vmulq_f32(*a4, v123);
  int8x16_t v126 = (int8x16_t)vmulq_f32(v124, v123);
  float32x4_t v127 = a4[2];
  float32x4_t v128 = a4[3];
  int8x16_t v129 = (int8x16_t)vmulq_f32(v123, v127);
  v129.i32[3] = 0;
  *(float32x2_t *)v125.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v125.f32, *(float32x2_t *)v126.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v125, (int8x16_t)v125, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v126, v126, 8uLL)));
  *(float32x2_t *)&v125.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v129.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v129, v129, 8uLL)), 0);
  v122.i32[0] = *(_OWORD *)a3;
  float32x4_t v130 = vmulq_f32(*a4, v122);
  int8x16_t v131 = (int8x16_t)vmulq_f32(v124, v122);
  int8x16_t v132 = (int8x16_t)vmulq_f32(v127, v122);
  v132.i32[3] = 0;
  *(float32x2_t *)v130.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v130.f32, *(float32x2_t *)v131.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v130, (int8x16_t)v130, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v131, v131, 8uLL)));
  *(float32x2_t *)&v130.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v132.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v132, v132, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v128, v130);
  float32x4_t v162 = vaddq_f32(v125, v128);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  float32x4_t v133 = *(float32x4_t *)a3;
  __int32 v134 = a3[2];
  v135.i32[0] = a2->i32[0];
  v135.i32[1] = HIDWORD(*(void *)a3);
  v133.i32[2] = v134;
  float32x4_t v136 = v133;
  v136.i32[3] = 0;
  float32x4_t v137 = a4[2];
  float32x4_t v138 = a4[3];
  int8x16_t v139 = (int8x16_t)vmulq_f32(v133, v137);
  float32x4_t v140 = *a4;
  float32x4_t v141 = a4[1];
  int8x16_t v142 = (int8x16_t)vmulq_f32(*a4, v136);
  float32x4_t v143 = vmulq_f32(v136, v141);
  v139.i32[3] = 0;
  *(float32x2_t *)v143.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v142.i8, *(float32x2_t *)v143.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v142, v142, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v143, (int8x16_t)v143, 8uLL)));
  *(float32x2_t *)&v143.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v139.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v139, v139, 8uLL)), 0);
  float32x4_t v162 = vaddq_f32(v143, v138);
  v135.i32[2] = v134;
  float32x4_t v144 = vmulq_f32(v140, v135);
  int8x16_t v145 = (int8x16_t)vmulq_f32(v141, v135);
  int8x16_t v146 = (int8x16_t)vmulq_f32(v137, v135);
  v146.i32[3] = 0;
  *(float32x2_t *)v144.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v144.f32, *(float32x2_t *)v145.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v144, (int8x16_t)v144, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v145, v145, 8uLL)));
  *(float32x2_t *)&v144.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v146.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v146, v146, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v138, v144);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
  __int32 v147 = a3[2];
  float32x4_t v148 = *a2;
  v148.i32[3] = 0;
  float32x4_t v149 = v148;
  v149.i32[1] = *v21;
  v149.i32[2] = v147;
  float32x4_t v150 = *a4;
  float32x4_t v151 = a4[1];
  float32x4_t v152 = vmulq_f32(*a4, v149);
  int8x16_t v153 = (int8x16_t)vmulq_f32(v151, v149);
  float32x4_t v154 = a4[2];
  float32x4_t v155 = a4[3];
  int8x16_t v156 = (int8x16_t)vmulq_f32(v149, v154);
  v156.i32[3] = 0;
  *(float32x2_t *)v152.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v152.f32, *(float32x2_t *)v153.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v152, (int8x16_t)v152, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v153, v153, 8uLL)));
  *(float32x2_t *)&v152.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v156.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v156, v156, 8uLL)), 0);
  v148.i32[1] = HIDWORD(a2->i64[0]);
  float32x4_t v162 = vaddq_f32(v152, v155);
  v148.i32[2] = v147;
  float32x4_t v157 = vmulq_f32(v150, v148);
  int8x16_t v158 = (int8x16_t)vmulq_f32(v151, v148);
  int8x16_t v159 = (int8x16_t)vmulq_f32(v154, v148);
  v159.i32[3] = 0;
  *(float32x2_t *)v157.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v157.f32, *(float32x2_t *)v158.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v157, (int8x16_t)v157, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v158, v158, 8uLL)));
  *(float32x2_t *)&v157.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v159.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v159, v159, 8uLL)), 0);
  float32x4_t v161 = vaddq_f32(v155, v157);
  return (*(uint64_t (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v162, &v161, a5);
}

uint64_t sub_1B644385C(uint64_t a1, int a2, float32x4_t *a3, uint64_t a4, float32_t a5, float32_t a6)
{
  float32x4_t v68 = 0uLL;
  v68.f32[a2] = -a6;
  float32x4_t v67 = 0uLL;
  v67.f32[a2] = a6;
  float32x4_t v11 = a3[1];
  float32x4_t v63 = *a3;
  float32x4_t v64 = v11;
  float32x4_t v12 = vmulq_f32(v63, v68);
  int8x16_t v13 = (int8x16_t)vmulq_f32(v11, v68);
  int8x16_t v14 = (int8x16_t)vmulq_f32(a3[2], v68);
  v14.i32[3] = 0;
  *(float32x2_t *)v12.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)v13.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v12, (int8x16_t)v12, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL)));
  *(float32x2_t *)&v12.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)), 0);
  float32x4_t v15 = vaddq_f32(a3[3], v12);
  float32x4_t v65 = a3[2];
  float32x4_t v66 = v15;
  (*(void (**)(uint64_t, float32x4_t *, uint64_t, float32_t))(*(void *)a1 + 32))(a1, &v63, a4, a5);
  float32x4_t v16 = a3[1];
  float32x4_t v63 = *a3;
  float32x4_t v64 = v16;
  float32x4_t v17 = vmulq_f32(v63, v67);
  int8x16_t v18 = (int8x16_t)vmulq_f32(v16, v67);
  int8x16_t v19 = (int8x16_t)vmulq_f32(a3[2], v67);
  v19.i32[3] = 0;
  *(float32x2_t *)v17.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v17.f32, *(float32x2_t *)v18.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)));
  *(float32x2_t *)&v17.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL)), 0);
  float32x4_t v20 = vaddq_f32(a3[3], v17);
  float32x4_t v65 = a3[2];
  float32x4_t v66 = v20;
  (*(void (**)(uint64_t, float32x4_t *, uint64_t, float32_t))(*(void *)a1 + 32))(a1, &v63, a4, a5);
  int v21 = (a2 + 1) % 3;
  v68.f32[v21] = a5;
  v67.f32[v21] = a5;
  float32x4_t v22 = *a3;
  float32x4_t v23 = a3[1];
  float32x4_t v24 = vmulq_f32(*a3, v68);
  int8x16_t v25 = (int8x16_t)vmulq_f32(v68, v23);
  float32x4_t v26 = a3[2];
  float32x4_t v27 = a3[3];
  int8x16_t v28 = (int8x16_t)vmulq_f32(v68, v26);
  v28.i32[3] = 0;
  *(float32x2_t *)v24.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v24.f32, *(float32x2_t *)v25.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL)));
  *(float32x2_t *)&v24.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32(v27, v24);
  float32x4_t v29 = vmulq_f32(v22, v67);
  int8x16_t v30 = (int8x16_t)vmulq_f32(v23, v67);
  int8x16_t v31 = (int8x16_t)vmulq_f32(v26, v67);
  v31.i32[3] = 0;
  *(float32x2_t *)v29.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v29.f32, *(float32x2_t *)v30.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL)));
  *(float32x2_t *)&v29.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL)), 0);
  float32x4_t v61 = v27;
  float32x4_t v62 = vaddq_f32(v27, v29);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v63, &v62, a4);
  v68.f32[v21] = -a5;
  v67.f32[v21] = -a5;
  float32x4_t v32 = *a3;
  float32x4_t v33 = a3[1];
  float32x4_t v34 = vmulq_f32(*a3, v68);
  int8x16_t v35 = (int8x16_t)vmulq_f32(v68, v33);
  float32x4_t v36 = a3[2];
  int8x16_t v37 = (int8x16_t)vmulq_f32(v68, v36);
  v37.i32[3] = 0;
  *(float32x2_t *)v34.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v34.f32, *(float32x2_t *)v35.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v34, (int8x16_t)v34, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL)));
  *(float32x2_t *)&v34.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v37.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32(v61, v34);
  float32x4_t v38 = vmulq_f32(v32, v67);
  int8x16_t v39 = (int8x16_t)vmulq_f32(v33, v67);
  int8x16_t v40 = (int8x16_t)vmulq_f32(v36, v67);
  v40.i32[3] = 0;
  *(float32x2_t *)v38.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)v39.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL)));
  *(float32x2_t *)&v38.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL)), 0);
  float32x4_t v62 = vaddq_f32(v61, v38);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v63, &v62, a4);
  v68.i32[v21] = 0;
  v67.i32[v21] = 0;
  int v41 = (a2 + 2) % 3;
  v68.f32[v41] = a5;
  v67.f32[v41] = a5;
  float32x4_t v42 = *a3;
  float32x4_t v43 = a3[1];
  float32x4_t v44 = vmulq_f32(*a3, v68);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v68, v43);
  float32x4_t v46 = a3[2];
  int8x16_t v47 = (int8x16_t)vmulq_f32(v68, v46);
  v47.i32[3] = 0;
  *(float32x2_t *)v44.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v44.f32, *(float32x2_t *)v45.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)));
  *(float32x2_t *)&v44.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32(v61, v44);
  float32x4_t v48 = vmulq_f32(v42, v67);
  int8x16_t v49 = (int8x16_t)vmulq_f32(v43, v67);
  int8x16_t v50 = (int8x16_t)vmulq_f32(v46, v67);
  v50.i32[3] = 0;
  *(float32x2_t *)v48.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v48.f32, *(float32x2_t *)v49.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v48, (int8x16_t)v48, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL)));
  *(float32x2_t *)&v48.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)), 0);
  float32x4_t v62 = vaddq_f32(v61, v48);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v63, &v62, a4);
  v68.f32[v41] = -a5;
  v67.f32[v41] = -a5;
  float32x4_t v51 = *a3;
  float32x4_t v52 = a3[1];
  float32x4_t v53 = vmulq_f32(*a3, v68);
  int8x16_t v54 = (int8x16_t)vmulq_f32(v68, v52);
  float32x4_t v55 = a3[2];
  int8x16_t v56 = (int8x16_t)vmulq_f32(v68, v55);
  v56.i32[3] = 0;
  *(float32x2_t *)v53.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v53.f32, *(float32x2_t *)v54.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v53, (int8x16_t)v53, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)));
  *(float32x2_t *)&v53.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)), 0);
  float32x4_t v63 = vaddq_f32(v61, v53);
  float32x4_t v57 = vmulq_f32(v51, v67);
  int8x16_t v58 = (int8x16_t)vmulq_f32(v52, v67);
  int8x16_t v59 = (int8x16_t)vmulq_f32(v55, v67);
  v59.i32[3] = 0;
  *(float32x2_t *)v57.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v57.f32, *(float32x2_t *)v58.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v57, (int8x16_t)v57, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL)));
  *(float32x2_t *)&v57.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL)), 0);
  float32x4_t v62 = vaddq_f32(v61, v57);
  return (*(uint64_t (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v63, &v62, a4);
}

uint64_t sub_1B6443D40(uint64_t a1, int a2, float32x4_t *a3, uint64_t a4, float32_t a5, float32_t a6)
{
  float32x4_t v73 = 0uLL;
  v73.f32[a2] = a6;
  int v11 = (a2 + 1) % 3;
  float32x4_t v72 = 0uLL;
  v72.f32[v11] = a5;
  float32x4_t v12 = vaddq_f32(v73, v72);
  float32x4_t v60 = v72;
  float32x4_t v13 = a3[1];
  float32x4_t v14 = vmulq_f32(*a3, v12);
  int8x16_t v15 = (int8x16_t)vmulq_f32(v12, v13);
  float32x4_t v16 = a3[2];
  float32x4_t v17 = a3[3];
  int8x16_t v18 = (int8x16_t)vmulq_f32(v12, v16);
  v18.i32[3] = 0;
  *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v15.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)));
  *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)), 0);
  float32x4_t v62 = v73;
  float32x4_t v64 = vnegq_f32(v73);
  float32x4_t v66 = v17;
  float32x4_t v19 = vsubq_f32(v72, v73);
  float32x4_t v20 = vmulq_f32(*a3, v19);
  int8x16_t v21 = (int8x16_t)vmulq_f32(v13, v19);
  int8x16_t v22 = (int8x16_t)vmulq_f32(v16, v19);
  v22.i32[3] = 0;
  *(float32x2_t *)v20.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v21.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL)));
  *(float32x2_t *)&v20.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)), 0);
  float32x4_t v70 = vaddq_f32(v17, v20);
  float32x4_t v71 = vaddq_f32(v17, v14);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *))(*(void *)a1 + 16))(a1, &v71, &v70);
  float32x4_t v23 = vsubq_f32(v62, v60);
  float32x4_t v25 = a3[1];
  float32x4_t v24 = a3[2];
  int8x16_t v26 = (int8x16_t)vmulq_f32(v24, v23);
  v23.i32[3] = 0;
  int8x16_t v27 = (int8x16_t)vmulq_f32(*a3, v23);
  float32x4_t v28 = vmulq_f32(v25, v23);
  v26.i32[3] = 0;
  *(float32x2_t *)v28.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v27.i8, *(float32x2_t *)v28.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL)));
  *(float32x2_t *)&v28.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)), 0);
  float32x4_t v29 = vaddq_f32(v66, v28);
  float32x4_t v30 = vsubq_f32(v64, v60);
  int8x16_t v31 = (int8x16_t)vmulq_f32(v24, v30);
  v30.i32[3] = 0;
  int8x16_t v32 = (int8x16_t)vmulq_f32(*a3, v30);
  float32x4_t v33 = vmulq_f32(v25, v30);
  v31.i32[3] = 0;
  *(float32x2_t *)v33.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v32.i8, *(float32x2_t *)v33.f32), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 8uLL)));
  *(float32x2_t *)&v33.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL)), 0);
  float32x4_t v70 = vaddq_f32(v66, v33);
  float32x4_t v71 = v29;
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v71, &v70, a4);
  float32x4_t v71 = 0uLL;
  v71.i32[a2] = 1065353216;
  float32x4_t v70 = 0uLL;
  v70.i32[v11] = 1065353216;
  float32x4_t v65 = v73;
  float32x4_t v34 = *a3;
  float32x4_t v35 = a3[1];
  float32x4_t v36 = vmulq_f32(*a3, v73);
  int8x16_t v37 = (int8x16_t)vmulq_f32(v73, v35);
  float32x4_t v38 = a3[2];
  int8x16_t v39 = (int8x16_t)vmulq_f32(v73, v38);
  v39.i32[3] = 0;
  *(float32x2_t *)v36.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v37.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36, (int8x16_t)v36, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL)));
  *(float32x2_t *)&v36.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL)), 0);
  float32x4_t v40 = vsubq_f32(v66, v36);
  v40.i32[3] = 0;
  float32x4_t v69 = v40;
  float32x4_t v63 = v71;
  int8x16_t v41 = (int8x16_t)vmulq_f32(v34, v71);
  int8x16_t v42 = (int8x16_t)vmulq_f32(v35, v71);
  int8x16_t v43 = (int8x16_t)vmulq_f32(v38, v71);
  v43.i32[3] = 0;
  *(float32x2_t *)v41.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v41.i8, *(float32x2_t *)v42.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL)));
  v41.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL)), 0);
  float32x4_t v61 = v70;
  int8x16_t v44 = (int8x16_t)vmulq_f32(v34, v70);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v35, v70);
  int8x16_t v46 = (int8x16_t)vmulq_f32(v38, v70);
  v46.i32[3] = 0;
  *(float32x2_t *)v44.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v44.i8, *(float32x2_t *)v45.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)));
  v44.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v46.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v46, v46, 8uLL)), 0);
  int8x16_t v67 = v44;
  int8x16_t v68 = v41;
  (*(void (**)(uint64_t, float32x4_t *, int8x16_t *, int8x16_t *, uint64_t, void, float32_t, float32_t, double, float, float))(*(void *)a1 + 120))(a1, &v69, &v68, &v67, a4, 0, a5, a5, 0.0, 6.2832, 10.0);
  float32x4_t v47 = *a3;
  float32x4_t v48 = a3[1];
  float32x4_t v49 = vmulq_f32(v65, *a3);
  int8x16_t v50 = (int8x16_t)vmulq_f32(v65, v48);
  float32x4_t v51 = a3[2];
  int8x16_t v52 = (int8x16_t)vmulq_f32(v65, v51);
  v52.i32[3] = 0;
  *(float32x2_t *)v49.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v49.f32, *(float32x2_t *)v50.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)));
  *(float32x2_t *)&v49.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v52.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL)), 0);
  float32x4_t v69 = vaddq_f32(v66, v49);
  int8x16_t v53 = (int8x16_t)vmulq_f32(v63, v47);
  int8x16_t v54 = (int8x16_t)vmulq_f32(v63, v48);
  int8x16_t v55 = (int8x16_t)vmulq_f32(v63, v51);
  v55.i32[3] = 0;
  *(float32x2_t *)v53.i8 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)), vpadd_f32(*(float32x2_t *)v53.i8, *(float32x2_t *)v54.i8));
  v53.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)), 0);
  int8x16_t v56 = (int8x16_t)vmulq_f32(v61, v47);
  int8x16_t v57 = (int8x16_t)vmulq_f32(v61, v48);
  int8x16_t v58 = (int8x16_t)vmulq_f32(v61, v51);
  v58.i32[3] = 0;
  *(float32x2_t *)v56.i8 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)), vpadd_f32(*(float32x2_t *)v56.i8, *(float32x2_t *)v57.i8));
  v56.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v58.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL)), 0);
  int8x16_t v67 = v56;
  int8x16_t v68 = v53;
  return (*(uint64_t (**)(uint64_t, float32x4_t *, int8x16_t *, int8x16_t *, uint64_t, void, float32_t, float32_t, double, float, float))(*(void *)a1 + 120))(a1, &v69, &v68, &v67, a4, 0, a5, a5, 0.0, 6.2832, 10.0);
}

uint64_t sub_1B64441D0(uint64_t a1, int a2, float32x4_t *a3, uint64_t a4, float32_t a5, float a6)
{
  float32x4_t v81 = 0uLL;
  v81.f32[a2] = a6 * 0.5;
  int v11 = (a2 + 1) % 3;
  float32x4_t v80 = 0uLL;
  v80.f32[v11] = a5;
  float32x4_t v79 = 0uLL;
  v79.f32[(a2 + 2) % 3] = a5;
  float32x4_t v12 = *a3;
  float32x4_t v13 = a3[1];
  float32x4_t v14 = vmulq_f32(*a3, v81);
  int8x16_t v15 = (int8x16_t)vmulq_f32(v81, v13);
  float32x4_t v16 = a3[2];
  float32x4_t v17 = a3[3];
  int8x16_t v18 = (int8x16_t)vmulq_f32(v81, v16);
  v18.i32[3] = 0;
  *(float32x2_t *)v14.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v15.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL)));
  *(float32x2_t *)&v14.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)), 0);
  float32x4_t v78 = vaddq_f32(v17, v14);
  float32x4_t v71 = vnegq_f32(v81);
  float32x4_t v73 = v17;
  float32x4_t v67 = v81;
  float32x4_t v69 = v80;
  float32x4_t v19 = vsubq_f32(v80, v81);
  float32x4_t v20 = vmulq_f32(v12, v19);
  int8x16_t v21 = (int8x16_t)vmulq_f32(v13, v19);
  int8x16_t v22 = (int8x16_t)vmulq_f32(v16, v19);
  v22.i32[3] = 0;
  *(float32x2_t *)v20.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)v21.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL)));
  *(float32x2_t *)&v20.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32(v17, v20);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *))(*(void *)a1 + 16))(a1, &v78, &v77);
  float32x4_t v23 = *a3;
  float32x4_t v24 = a3[1];
  float32x4_t v25 = vmulq_f32(*a3, v67);
  int8x16_t v26 = (int8x16_t)vmulq_f32(v67, v24);
  float32x4_t v27 = a3[2];
  int8x16_t v28 = (int8x16_t)vmulq_f32(v67, v27);
  v28.i32[3] = 0;
  *(float32x2_t *)v25.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v25.f32, *(float32x2_t *)v26.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)));
  *(float32x2_t *)&v25.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), 0);
  float32x4_t v78 = vaddq_f32(v73, v25);
  float32x4_t v29 = vsubq_f32(v71, v69);
  int8x16_t v30 = (int8x16_t)vmulq_f32(v27, v29);
  v29.i32[3] = 0;
  float32x4_t v31 = vmulq_f32(v23, v29);
  int8x16_t v32 = (int8x16_t)vmulq_f32(v24, v29);
  v30.i32[3] = 0;
  *(float32x2_t *)v31.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v31.f32, *(float32x2_t *)v32.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)));
  *(float32x2_t *)&v31.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32(v73, v31);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v78, &v77, a4);
  float32x4_t v33 = *a3;
  float32x4_t v34 = a3[1];
  float32x4_t v35 = vmulq_f32(*a3, v81);
  int8x16_t v36 = (int8x16_t)vmulq_f32(v81, v34);
  float32x4_t v37 = a3[2];
  int8x16_t v38 = (int8x16_t)vmulq_f32(v81, v37);
  v38.i32[3] = 0;
  *(float32x2_t *)v35.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v35.f32, *(float32x2_t *)v36.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v35, (int8x16_t)v35, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL)));
  *(float32x2_t *)&v35.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL)), 0);
  float32x4_t v78 = vaddq_f32(v73, v35);
  float32x4_t v72 = vnegq_f32(v81);
  float32x4_t v68 = v81;
  float32x4_t v70 = v79;
  float32x4_t v39 = vsubq_f32(v79, v81);
  float32x4_t v40 = vmulq_f32(v33, v39);
  int8x16_t v41 = (int8x16_t)vmulq_f32(v34, v39);
  int8x16_t v42 = (int8x16_t)vmulq_f32(v37, v39);
  v42.i32[3] = 0;
  *(float32x2_t *)v40.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v40.f32, *(float32x2_t *)v41.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v40, (int8x16_t)v40, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL)));
  *(float32x2_t *)&v40.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32(v73, v40);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v78, &v77, a4);
  float32x4_t v43 = a3[1];
  float32x4_t v44 = vmulq_f32(*a3, v68);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v68, v43);
  float32x4_t v46 = a3[2];
  int8x16_t v47 = (int8x16_t)vmulq_f32(v68, v46);
  v47.i32[3] = 0;
  *(float32x2_t *)v44.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v44.f32, *(float32x2_t *)v45.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)));
  *(float32x2_t *)&v44.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL)), 0);
  float32x4_t v48 = vaddq_f32(v73, v44);
  float32x4_t v49 = vsubq_f32(v72, v70);
  int8x16_t v50 = (int8x16_t)vmulq_f32(v46, v49);
  v49.i32[3] = 0;
  float32x4_t v51 = vmulq_f32(*a3, v49);
  int8x16_t v52 = (int8x16_t)vmulq_f32(v43, v49);
  v50.i32[3] = 0;
  *(float32x2_t *)v51.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v51.f32, *(float32x2_t *)v52.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL)));
  *(float32x2_t *)&v51.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)), 0);
  float32x4_t v77 = vaddq_f32(v73, v51);
  float32x4_t v78 = v48;
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v78, &v77, a4);
  float32x4_t v78 = 0uLL;
  v78.i32[a2] = 1065353216;
  float32x4_t v77 = 0uLL;
  v77.i32[v11] = 1065353216;
  float32x4_t v53 = *a3;
  float32x4_t v54 = a3[1];
  float32x4_t v55 = vmulq_f32(*a3, v81);
  int8x16_t v56 = (int8x16_t)vmulq_f32(v81, v54);
  float32x4_t v57 = a3[2];
  int8x16_t v58 = (int8x16_t)vmulq_f32(v81, v57);
  v58.i32[3] = 0;
  *(float32x2_t *)v55.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v55.f32, *(float32x2_t *)v56.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v55, (int8x16_t)v55, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)));
  *(float32x2_t *)&v55.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v58.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL)), 0);
  float32x4_t v59 = vsubq_f32(v73, v55);
  v59.i32[3] = 0;
  float32x4_t v76 = v59;
  int8x16_t v60 = (int8x16_t)vmulq_f32(v53, v78);
  int8x16_t v61 = (int8x16_t)vmulq_f32(v54, v78);
  int8x16_t v62 = (int8x16_t)vmulq_f32(v57, v78);
  v62.i32[3] = 0;
  *(float32x2_t *)v60.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v60.i8, *(float32x2_t *)v61.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL)));
  v60.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v62.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v62, v62, 8uLL)), 0);
  int8x16_t v63 = (int8x16_t)vmulq_f32(v53, v77);
  int8x16_t v64 = (int8x16_t)vmulq_f32(v54, v77);
  int8x16_t v65 = (int8x16_t)vmulq_f32(v57, v77);
  v65.i32[3] = 0;
  *(float32x2_t *)v63.i8 = vadd_f32(vpadd_f32(*(float32x2_t *)v63.i8, *(float32x2_t *)v64.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL)));
  v63.u64[1] = (unint64_t)vpadd_f32(vpadd_f32(*(float32x2_t *)v65.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v65, v65, 8uLL)), 0);
  int8x16_t v74 = v63;
  int8x16_t v75 = v60;
  return (*(uint64_t (**)(uint64_t, float32x4_t *, int8x16_t *, int8x16_t *, uint64_t, void, float32_t, float32_t, double, float, float))(*(void *)a1 + 120))(a1, &v76, &v75, &v74, a4, 0, a5, a5, 0.0, 6.2832, 10.0);
}

uint64_t sub_1B6444704(uint64_t a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, float a5, float32x4_t a6)
{
  float32x4_t v9 = *a2;
  LODWORD(v10) = a2->i64[1];
  LODWORD(v11) = HIDWORD(a2->i64[0]);
  if (fabsf(v10) <= 0.70711)
  {
    float v16 = (float)(v11 * v11) + (float)(v9.f32[0] * v9.f32[0]);
    float v17 = 1.0 / sqrtf(v16);
    int8x16_t v18 = vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL);
    *(int32x2_t *)v18.i8 = vzip1_s32(*(int32x2_t *)v9.f32, *(int32x2_t *)v18.i8);
    int32x4_t v19 = (int32x4_t)v18;
    *(float *)&v19.i32[1] = -v11;
    *(float32x2_t *)v19.i8 = vmul_n_f32(*(float32x2_t *)v19.i8, v17);
    float32x4_t v15 = (float32x4_t)vrev64q_s32(v19).u64[0];
    *(float *)v18.i32 = -v10;
    *(float32x2_t *)a6.f32 = vmul_f32(*(float32x2_t *)v19.i8, *(float32x2_t *)v18.i8);
    a6.f32[2] = v16 * v17;
  }
  else
  {
    float v12 = (float)(v10 * v10) + (float)(v11 * v11);
    float v13 = 1.0 / sqrtf(v12);
    *(float *)&unsigned int v14 = v11 * v13;
    v15.i32[0] = 0;
    v15.f32[1] = -(float)(v10 * v13);
    v15.i64[1] = v14;
    a6.f32[0] = v12 * v13;
    a6.f32[1] = -(float)(v9.f32[0] * *(float *)&v14);
    a6.f32[2] = v9.f32[0] * v15.f32[1];
  }
  float32x4_t v20 = vmulq_n_f32(v9, a5);
  v20.i32[3] = 0;
  float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x42C80000u);
  float32x4_t v22 = vmulq_f32(v15, v21);
  v22.i32[3] = 0;
  float32x4_t v23 = vaddq_f32(v20, v22);
  float32x4_t v24 = vsubq_f32(v20, v22);
  float32x4_t v25 = a3[2];
  float32x4_t v26 = a3[3];
  int8x16_t v27 = (int8x16_t)vmulq_f32(v25, v24);
  v24.i32[3] = 0;
  float32x4_t v28 = vmulq_f32(a6, v21);
  v28.i32[3] = 0;
  float32x4_t v29 = vaddq_f32(v20, v28);
  float32x4_t v30 = vsubq_f32(v20, v28);
  float32x4_t v50 = v30;
  v30.i32[3] = 0;
  float32x4_t v48 = v29;
  float32x4_t v49 = v30;
  float32x4_t v31 = a3[1];
  float32x4_t v32 = vmulq_f32(*a3, v23);
  int8x16_t v33 = (int8x16_t)vmulq_f32(v31, v23);
  int8x16_t v34 = (int8x16_t)vmulq_f32(v25, v23);
  v34.i32[3] = 0;
  *(float32x2_t *)v32.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v32.f32, *(float32x2_t *)v33.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v32, (int8x16_t)v32, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL)));
  *(float32x2_t *)&v32.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL)), 0);
  float32x4_t v35 = vmulq_f32(*a3, v24);
  int8x16_t v36 = (int8x16_t)vmulq_f32(v31, v24);
  v27.i32[3] = 0;
  *(float32x2_t *)v35.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v35.f32, *(float32x2_t *)v36.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v35, (int8x16_t)v35, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL)));
  *(float32x2_t *)&v35.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL)), 0);
  float32x4_t v51 = vaddq_f32(v26, v35);
  float32x4_t v52 = vaddq_f32(v26, v32);
  (*(void (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v52, &v51, a4);
  float32x4_t v37 = *a3;
  float32x4_t v38 = a3[1];
  float32x4_t v39 = vmulq_f32(v48, *a3);
  int8x16_t v40 = (int8x16_t)vmulq_f32(v48, v38);
  float32x4_t v41 = a3[2];
  float32x4_t v42 = a3[3];
  int8x16_t v43 = (int8x16_t)vmulq_f32(v48, v41);
  v43.i32[3] = 0;
  *(float32x2_t *)v39.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v39.f32, *(float32x2_t *)v40.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v39, (int8x16_t)v39, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL)));
  *(float32x2_t *)&v39.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL)), 0);
  float32x4_t v52 = vaddq_f32(v39, v42);
  float32x4_t v44 = vmulq_f32(v37, v49);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v38, v49);
  int8x16_t v46 = (int8x16_t)vmulq_f32(v41, v50);
  v46.i32[3] = 0;
  *(float32x2_t *)v44.f32 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)), vpadd_f32(*(float32x2_t *)v44.f32, *(float32x2_t *)v45.i8));
  *(float32x2_t *)&v44.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v46.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v46, v46, 8uLL)), 0);
  float32x4_t v51 = vaddq_f32(v42, v44);
  return (*(uint64_t (**)(uint64_t, float32x4_t *, float32x4_t *, uint64_t))(*(void *)a1 + 16))(a1, &v52, &v51, a4);
}

double sub_1B64449AC(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  *(_DWORD *)(a1 + 8) = 1065353216;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = xmmword_1B6E50980;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1F0FB1B38;
  *(_OWORD *)(a1 + 64) = *a2;
  *(_OWORD *)(a1 + 80) = *a3;
  *(unsigned char *)(a1 + 168) = 1;
  *(void *)(a1 + 160) = 0;
  double result = 0.0;
  *(void *)(a1 + 148) = 0;
  *(unsigned char *)(a1 + 200) = 1;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 180) = 0;
  *(unsigned char *)(a1 + 232) = 1;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 212) = 0;
  *(unsigned char *)(a1 + 264) = 1;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 24) = -1;
  *(void *)(a1 + 40) = 0;
  return result;
}

void sub_1B6444A40(void *a1)
{
  *a1 = &unk_1F0FB1B38;
  uint64_t v2 = (uint64_t)(a1 + 18);
  sub_1B6441B40((uint64_t)(a1 + 30));
  sub_1B6441B40((uint64_t)(a1 + 26));
  sub_1B6441B40((uint64_t)(a1 + 22));
  sub_1B6441B40(v2);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6444AC4(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  BOOL v3 = (a1[4] & v2) != 0 && (*(void *)(a2 + 16) & a1[3]) != 0;
  return (a1[5] & v2) != 0 || v3;
}

float32_t sub_1B6444AFC(float32x4_t *a1, uint64_t a2, int a3)
{
  float32x4_t v5 = *(float32x4_t **)a2;
  a1[1].i64[0] = *(void *)a2;
  float32x4_t v6 = *(float32x4_t *)(a2 + 16);
  if (!a3)
  {
    int8x16_t v7 = (int8x16_t)vmulq_f32(v5[1], v6);
    int8x16_t v8 = (int8x16_t)vmulq_f32(v6, v5[2]);
    int8x16_t v9 = (int8x16_t)vmulq_f32(v6, v5[3]);
    v9.i32[3] = 0;
    *(float32x2_t *)v6.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)v8.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
    *(float32x2_t *)&v6.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)), 0);
  }
  a1[7] = v6;
  a1[8] = vaddq_f32(a1[4], vmulq_n_f32(vsubq_f32(a1[5], a1[4]), *(float *)(a2 + 32)));
  __int32 v10 = a1[6].i32[0];
  if (v10 == 1) {
    return 0.0;
  }
  if (!v10)
  {
    float32_t result = *(float *)(a2 + 32);
    a1->f32[2] = result;
    return result;
  }
  int v12 = a1[9].i32[1];
  if (v12 == a1[9].i32[2])
  {
    int v13 = v12 ? 2 * v12 : 1;
    if (v12 < v13)
    {
      if (v13)
      {
        uint64_t v14 = sub_1B6E073B8(8 * v13, 16);
        int v12 = a1[9].i32[1];
      }
      else
      {
        uint64_t v14 = 0;
      }
      if (v12 >= 1)
      {
        uint64_t v15 = 0;
        do
        {
          *(void *)(v14 + v15) = *(void *)(a1[10].i64[0] + v15);
          v15 += 8;
        }
        while (8 * v12 != v15);
      }
      uint64_t v16 = a1[10].i64[0];
      if (v16 && a1[10].i8[8])
      {
        sub_1B6E073C4(v16);
        int v12 = a1[9].i32[1];
      }
      a1[10].i8[8] = 1;
      a1[10].i64[0] = v14;
      a1[9].i32[2] = v13;
    }
  }
  *(void *)(a1[10].i64[0] + 8 * v12) = *(void *)a2;
  a1[9].i32[1] = v12 + 1;
  int v17 = a1[13].i32[1];
  if (v17 == a1[13].i32[2])
  {
    int v18 = v17 ? 2 * v17 : 1;
    if (v17 < v18)
    {
      if (v18)
      {
        uint64_t v19 = sub_1B6E073B8(16 * v18, 16);
        int v17 = a1[13].i32[1];
      }
      else
      {
        uint64_t v19 = 0;
      }
      if (v17 >= 1)
      {
        uint64_t v20 = 0;
        uint64_t v21 = 16 * v17;
        do
        {
          *(_OWORD *)(v19 + v20) = *(_OWORD *)(a1[14].i64[0] + v20);
          v20 += 16;
        }
        while (v21 != v20);
      }
      uint64_t v22 = a1[14].i64[0];
      if (v22 && a1[14].i8[8]) {
        sub_1B6E073C4(v22);
      }
      a1[14].i8[8] = 1;
      a1[14].i64[0] = v19;
      a1[13].i32[2] = v18;
      int v17 = a1[13].i32[1];
    }
  }
  *(float32x4_t *)(a1[14].i64[0] + 16 * v17) = a1[8];
  ++a1[13].i32[1];
  int v23 = a1[11].i32[1];
  if (v23 == a1[11].i32[2])
  {
    int v24 = v23 ? 2 * v23 : 1;
    if (v23 < v24)
    {
      if (v24)
      {
        uint64_t v25 = sub_1B6E073B8(16 * v24, 16);
        int v23 = a1[11].i32[1];
      }
      else
      {
        uint64_t v25 = 0;
      }
      if (v23 >= 1)
      {
        uint64_t v26 = 0;
        uint64_t v27 = 16 * v23;
        do
        {
          *(_OWORD *)(v25 + v26) = *(_OWORD *)(a1[12].i64[0] + v26);
          v26 += 16;
        }
        while (v27 != v26);
      }
      uint64_t v28 = a1[12].i64[0];
      if (v28 && a1[12].i8[8]) {
        sub_1B6E073C4(v28);
      }
      a1[12].i8[8] = 1;
      a1[12].i64[0] = v25;
      a1[11].i32[2] = v24;
      int v23 = a1[11].i32[1];
    }
  }
  *(float32x4_t *)(a1[12].i64[0] + 16 * v23) = a1[7];
  ++a1[11].i32[1];
  int v29 = a1[15].i32[1];
  if (v29 == a1[15].i32[2])
  {
    int v30 = v29 ? 2 * v29 : 1;
    if (v29 < v30)
    {
      if (v30)
      {
        uint64_t v31 = sub_1B6E073B8(4 * v30, 16);
        int v29 = a1[15].i32[1];
      }
      else
      {
        uint64_t v31 = 0;
      }
      uint64_t v32 = a1[16].i64[0];
      if (v29 < 1)
      {
        if (!v32)
        {
LABEL_68:
          a1[16].i8[8] = 1;
          a1[16].i64[0] = v31;
          a1[15].i32[2] = v30;
          goto LABEL_69;
        }
      }
      else
      {
        uint64_t v33 = v29;
        int8x16_t v34 = (_DWORD *)v31;
        float32x4_t v35 = (int *)a1[16].i64[0];
        do
        {
          int v36 = *v35++;
          *v34++ = v36;
          --v33;
        }
        while (v33);
      }
      if (a1[16].i8[8])
      {
        sub_1B6E073C4(v32);
        int v29 = a1[15].i32[1];
      }
      a1[16].i64[0] = 0;
      goto LABEL_68;
    }
  }
LABEL_69:
  *(_DWORD *)(a1[16].i64[0] + 4 * v29) = *(_DWORD *)(a2 + 32);
  a1[15].i32[1] = v29 + 1;
  return 0.999;
}

void sub_1B6444E64()
{
}

BOOL sub_1B6444E78(uint64_t a1, uint64_t a2)
{
  return (*(void *)(a1 + 40) & *(void *)(a2 + 8)) != 0 && (*(void *)(a2 + 16) & *(void *)(a1 + 32)) != 0;
}

float sub_1B6444EA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int8x16_t v7 = sub_1B64402F4(*(void *)(a3 + 16), *(void *)(a6 + 16), (double *)(a2 + 32), (double *)(a2 + 64), *(float *)(a2 + 80), 0.0);
  if (v7)
  {
    uint64_t v10 = (uint64_t)v7;
    float v11 = *(void **)(a1 + 48);
    if (!v11)
    {
      float v11 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], v8, 0, v9);
      *(void *)(a1 + 48) = v11;
    }
    objc_msgSend_addObject_(v11, v8, v10, v9);
  }
  return 0.999;
}

void sub_1B6444F18()
{
}

uint64_t sub_1B6444F2C(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  BOOL v3 = (a1[3] & v2) != 0 && (*(void *)(a2 + 16) & a1[2]) != 0;
  return (a1[4] & v2) != 0 || v3;
}

float sub_1B6444F64(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  float32x4_t v6 = *(float32x4_t **)a2;
  *(void *)(a1 + 88) = *(void *)a2;
  float32x4_t v7 = *(float32x4_t *)(a2 + 16);
  if (!a3)
  {
    int8x16_t v8 = (int8x16_t)vmulq_f32(v6[1], v7);
    int8x16_t v9 = (int8x16_t)vmulq_f32(v7, v6[2]);
    int8x16_t v10 = (int8x16_t)vmulq_f32(v7, v6[3]);
    v10.i32[3] = 0;
    *(float32x2_t *)v7.f32 = vadd_f32(vpadd_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)v9.i8), (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)));
    *(float32x2_t *)&v7.u32[2] = vpadd_f32(vpadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL)), 0);
  }
  *(float32x4_t *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 32);
  float v11 = *(float *)(a2 + 48);
  *(float *)(a1 + 8) = v11;
  int v12 = *(_DWORD *)(a1 + 80);
  if (v12)
  {
    if (v12 == 1)
    {
      return 0.0;
    }
    else
    {
      if (!*(void *)(a1 + 128))
      {
        *(void *)(a1 + 128) = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], (const char *)a2, 0, a4);
        float v11 = *(float *)(a1 + 8);
      }
      int v13 = sub_1B64402F4(*(void *)a2, 0, (double *)(a1 + 112), (double *)(a1 + 96), 0.0, v11);
      float v11 = 0.999;
      if (v13) {
        objc_msgSend_addObject_(*(void **)(a1 + 128), v14, (uint64_t)v13, v15);
      }
    }
  }
  return v11;
}

void sub_1B6445080()
{
}

uint64_t sub_1B6445094(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = *a2;
  if (*(_DWORD *)(*a3 + 264) == 4) {
    uint64_t v6 = *a3;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v5) {
    BOOL v7 = *(_DWORD *)(*a2 + 264) == 4;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v5 + 56))(v5, a3, a2);
  }
  if (v6) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v6 + 56))(v6, a2, a3);
  }
  return 0;
}

uint64_t sub_1B6445148(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = *a2;
  if (*(_DWORD *)(*a3 + 264) == 4) {
    uint64_t v8 = *a3;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v7) {
    BOOL v9 = *(_DWORD *)(*a2 + 264) == 4;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t *))(*(void *)v7 + 64))(v7, a3, a4, a2);
  }
  if (v8) {
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t *))(*(void *)v8 + 64))(v8, a2, a4, a3);
  }
  return 0;
}

uint64_t sub_1B644520C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  uint64_t v3 = *(unsigned int *)(a2 + 4);
  if ((int)v3 < 1)
  {
    *(_DWORD *)(a1 + 4) = v3;
  }
  else
  {
    uint64_t v5 = 8 * v3;
    uint64_t v6 = sub_1B6E073B8(8 * v3, 16);
    uint64_t v7 = v6;
    uint64_t v8 = *(unsigned int *)(a1 + 4);
    if ((int)v8 >= 1)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8 * v8;
      do
      {
        *(void *)(v6 + v9) = *(void *)(*(void *)(a1 + 16) + v9);
        v9 += 8;
      }
      while (v10 != v9);
    }
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11 && *(unsigned char *)(a1 + 24)) {
      sub_1B6E073C4(v11);
    }
    *(unsigned char *)(a1 + 24) = 1;
    *(void *)(a1 + 16) = v7;
    *(_DWORD *)(a1 + 8) = v3;
    uint64_t v12 = 0;
    do
    {
      *(void *)(*(void *)(a1 + 16) + v12) = 0;
      v12 += 8;
    }
    while (v5 != v12);
    uint64_t v13 = 0;
    uint64_t v14 = *(void *)(a1 + 16);
    *(_DWORD *)(a1 + 4) = v3;
    do
    {
      *(void *)(v14 + v13) = *(void *)(*(void *)(a2 + 16) + v13);
      v13 += 8;
    }
    while (v5 != v13);
  }
  return a1;
}

void sub_1B6445310(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  uint64_t v10 = *(void *)(a1 + 4152);
  os_signpost_id_t v11 = *(void *)(a1 + 4264);
  CFSetRef v12 = (const __CFSet *)sub_1B6453BC4(a2, @"kDeformerStackKey", 0);
  if (v12)
  {
    CFSetRef v13 = v12;
    uint64_t v14 = sub_1B63F2EE0();
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v15 = v14;
      if (os_signpost_enabled(v14))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1B6287000, v15, OS_SIGNPOST_INTERVAL_BEGIN, v11, "Deformers", "", buf, 2u);
      }
    }
    double v16 = CACurrentMediaTime();
    prof_beginFlame((uint64_t)"Skinning", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/AppleEngine/CFXEngineContext.m", 174);
    sub_1B63CC9A0(v13, (uint64_t)&unk_1F0FB5748);
    *(double *)(v10 + 136) = *(double *)(v10 + 136) + CACurrentMediaTime() - v16;
    prof_endFlame();
    int v17 = sub_1B63F2EE0();
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v18 = v17;
      if (os_signpost_enabled(v17))
      {
        *(_WORD *)uint64_t v19 = 0;
        _os_signpost_emit_with_name_impl(&dword_1B6287000, v18, OS_SIGNPOST_INTERVAL_END, v11, "Deformers", "", v19, 2u);
      }
    }
  }
}

uint64_t sub_1B6445480(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  return *(void *)(a1 + 4152);
}

uint64_t sub_1B64454CC(uint64_t a1)
{
  return *(void *)(a1 + 4264);
}

void sub_1B64454D4(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = sub_1B64A16A0((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    sub_1B65256D0(v10, a2, v11, v12, v13, v14, v15, v16, a9);
  }
}

void sub_1B6445520(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 212))
  {
    sub_1B63F2F54(0, @"Info: Reload Shaders", a3, a4, a5, a6, a7, a8, v19);
    sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", *(const void **)(a1 + 16), 0, 1u);
    objc_msgSend_emptyShaderCache(*(void **)(a1 + 224), v9, v10, v11);
    uint64_t v15 = objc_msgSend_resourceManager(*(void **)(a1 + 4160), v12, v13, v14);
    sub_1B653B980(v15, v16, v17, v18);
    *(unsigned char *)(a1 + 212) = 0;
  }
}

uint64_t sub_1B644558C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(void *)(a1 + 16);
}

void sub_1B64455D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v8 = *(void *)(a1 + 48);
    if (v8)
    {
      uint64_t v9 = sub_1B64A01D4(a2, a2, a3, a4, a5, a6, a7, a8);
      float32x4_t v10 = *(float32x4_t *)(v9 + 48);
      float32x4_t v12 = *(float32x4_t *)v9;
      float32x4_t v11 = *(float32x4_t *)(v9 + 16);
      float32x4_t v26 = *(float32x4_t *)(v9 + 32);
      float32x4_t v27 = v10;
      float32x4_t v24 = v12;
      float32x4_t v25 = v11;
      *(double *)v20.i64 = sub_1B649FE9C(v8, v13, v14, v15, v16, v17, v18, v19);
      if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v24, v20), (int8x16_t)vceqq_f32(v25, v21)), vandq_s8((int8x16_t)vceqq_f32(v26, v22), (int8x16_t)vceqq_f32(v27, v23)))) & 0x80000000) == 0)sub_1B64A2614(v8, (uint64_t)&v24); {
    }
      }
  }
}

uint64_t sub_1B6445668(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t result = *(void *)(a1 + 864);
  if (!result)
  {
    long long v35 = xmmword_1B6E50A90;
    long long v36 = unk_1B6E50AA0;
    long long v37 = xmmword_1B6E50AB0;
    long long v38 = unk_1B6E50AC0;
    *(_OWORD *)bytes = xmmword_1B6E50A70;
    long long v34 = unk_1B6E50A80;
    *(_OWORD *)int v30 = xmmword_1B6E50AD0;
    long long v31 = unk_1B6E50AE0;
    int v32 = 132612;
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 96);
    values = (void *)sub_1B641CF98(v4, 0, 8, 3, 1, v5, v6, v7);
    CFRelease(v4);
    CFDataRef v8 = CFDataCreate(v3, v30, 36);
    CFTypeRef cf = (CFTypeRef)sub_1B63D0314();
    sub_1B63D05D4((uint64_t)cf, 0, 12, v8, 1, v9, v10, v11);
    CFRelease(v8);
    char v27 = 0;
    float32x4_t v12 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFArrayRef v13 = CFArrayCreate(v3, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    CFArrayRef v14 = CFArrayCreate(v3, &cf, 1, v12);
    uint64_t v20 = sub_1B63DC55C(v13, v14, (uint64_t)&v27, v15, v16, v17, v18, v19);
    *(void *)(a1 + 864) = v20;
    sub_1B65834BC(v20, @"Environment cube", v21, v22, v23, v24, v25, v26);
    CFRelease(v14);
    CFRelease(v13);
    CFRelease(cf);
    return *(void *)(a1 + 864);
  }
  return result;
}

void sub_1B64457FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!sub_1B6475E50(a2, a2, a3, a4, a5, a6, a7, a8))
  {
    if (!a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v11, v12, v13, v14, v15, v16, (uint64_t)"context");
    }
    uint64_t v17 = *(void *)(a1 + 4160);
    if (v17)
    {
      uint64_t v18 = sub_1B6477464(a2, v10, v11, v12, v13, v14, v15, v16);
      if (v18 && (uint64_t v26 = v18, sub_1B6451C0C(v18, v19, v20, v21, v22, v23, v24, v25) - 4 >= 0xFFFFFFFD))
      {
        MEMORY[0x1F4181798](v17, sel_renderVideoBackground_engineContext_materialProperty_, v26, a1);
      }
      else
      {
        MEMORY[0x1F4181798](v17, sel_renderBackground_engineContext_passInstance_, a2, a1);
      }
    }
  }
}

uint64_t sub_1B6445900(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(void *)(a1 + 4160);
}

uint64_t sub_1B644594C(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B644597C()
{
  if (qword_1EB996E60 != -1) {
    dispatch_once_f(&qword_1EB996E60, &qword_1EB995450, (dispatch_function_t)sub_1B644594C);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995450, 0x10B0uLL);
  if (v0)
  {
    *(void *)(v0 + 16) = 0;
    *(void *)(v0 + 888) = 0x7FF0000000000000;
    *(_WORD *)(v0 + 217) = 1;
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)(v0 + 204) = _D0;
    sub_1B65F425C();
  }
  return 0;
}

void sub_1B6445B20(uint64_t a1, uint64_t a2, void *a3)
{
  prof_beginFlame((uint64_t)"CFXEngineContextLoadCustomRenderGraph", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/AppleEngine/CFXEngineContext.m", 451);
  sub_1B65F4878(*(void *)(a1 + 4184), a2, a3);

  prof_endFlame();
}

void sub_1B6445B88(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6445BA0(uint64_t a1)
{
  return *(void *)(a1 + 4184);
}

uint64_t sub_1B6445BA8(uint64_t a1)
{
  return sub_1B65F46C0(*(void *)(a1 + 4184));
}

void sub_1B6445BB0(uint64_t a1)
{
}

uint64_t sub_1B6445BB8(uint64_t a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
    if (cf) {
      goto LABEL_3;
    }
LABEL_5:
    CFTypeRef v10 = 0;
    goto LABEL_6;
  }
  if (!cf) {
    goto LABEL_5;
  }
LABEL_3:
  CFTypeRef v10 = CFRetain(cf);
LABEL_6:
  *(void *)(a1 + 4160) = v10;
  *(_DWORD *)(a1 + 4168) = objc_msgSend_features(cf, (const char *)cf, a3, a4);
  uint64_t result = objc_msgSend_stats(cf, v11, v12, v13);
  *(void *)(a1 + 4152) = result;
  return result;
}

void sub_1B6445C38(uint64_t *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFTypeRef v10 = (const void *)a1[2];
  if (v10 != a2)
  {
    if (v10)
    {
      sub_1B6445D60((uint64_t)a1, 0, a3, a4, a5, a6, a7, a8);
      sub_1B658F62C((unint64_t)a1, v11, v12, v13, v14, v15, v16, v17);
      sub_1B64B0D10(a1[2], (uint64_t)a1, v18, v19, v20, v21, v22, v23);
    }
    sub_1B63F69D4(a1[19]);
    sub_1B65126E8(a1[20]);
    int v30 = (const void *)a1[22];
    if (v30)
    {
      CFRelease(v30);
      a1[22] = 0;
    }
    long long v31 = (const void *)a1[2];
    if (v31 != a2)
    {
      if (v31)
      {
        CFRelease(v31);
        a1[2] = 0;
      }
      if (a2) {
        CFTypeRef v32 = CFRetain(a2);
      }
      else {
        CFTypeRef v32 = 0;
      }
      a1[2] = (uint64_t)v32;
    }
    if (a2)
    {
      sub_1B64B0B54((uint64_t)a2, (uint64_t)a1, v24, v25, v26, v27, v28, v29);
      sub_1B658F62C((unint64_t)a1, v33, v34, v35, v36, v37, v38, v39);
      uint64_t v47 = sub_1B64B393C((uint64_t)a2, v40, v41, v42, v43, v44, v45, v46);
      sub_1B6445EF0((uint64_t)a1, v47, v48, v49, v50, v51, v52, v53);
    }
    sub_1B6445F58((uint64_t)a1, 0, v24, v25, v26, v27, v28, v29);
    sub_1B658F5C8((unint64_t)a1, v54, v55, v56, v57, v58, v59, v60);
  }
}

uint64_t sub_1B6445D60(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  sub_1B6445F58(a1, 0, a3, a4, a5, a6, a7, a8);
  if (a2)
  {
    CFDictionaryRef v17 = sub_1B64A3B48((uint64_t)a2, v10, v11, v12, v13, v14, v15, v16);
    if (v17) {
      *((unsigned char *)v17 + 360) &= ~1u;
    }
  }
  uint64_t v18 = *(const void **)(a1 + 24);
  if (v18 != a2)
  {
    if (v18)
    {
      CFRelease(v18);
      *(void *)(a1 + 24) = 0;
    }
    if (a2) {
      CFTypeRef v19 = CFRetain(a2);
    }
    else {
      CFTypeRef v19 = 0;
    }
    *(void *)(a1 + 24) = v19;
  }
  if (a2)
  {
    uint64_t v20 = (float32x4_t *)sub_1B64A01D4((uint64_t)a2, v10, v11, v12, v13, v14, v15, v16);
    float32x4_t v21 = vmulq_f32(*v20, *v20);
    float32x4_t v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1)));
    v22.f32[0] = sqrtf(v22.f32[0]);
    float32x4_t v23 = vmulq_f32(v20[1], v20[1]);
    float32x4_t v24 = vmulq_f32(v20[2], v20[2]);
    v22.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]);
    v22.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0]);
    float32x4_t v25 = vabsq_f32(v22);
    *(float *)(a1 + 200) = 1.0 / fmaxf(fmaxf(v25.f32[0], v25.f32[2]), v25.f32[1]);
  }
  uint64_t v26 = *(void *)(a1 + 4184);

  return sub_1B65F46C0(v26);
}

CFTypeRef sub_1B6445E9C(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 176);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 176) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 176) = result;
  }
  return result;
}

double sub_1B6445EF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  *(void *)(a1 + 4272) = a2;
  uint64_t v10 = *(void *)(a1 + 4184);

  return sub_1B65F4834(v10, a2);
}

CFTypeRef sub_1B6445F58(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 40);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 40) = 0;
    }
    if (cf)
    {
      *(void *)(a1 + 40) = CFRetain(cf);
      uint64_t v18 = (float32x4_t *)sub_1B64A01D4((uint64_t)cf, v11, v12, v13, v14, v15, v16, v17);
      float32x4_t v19 = vmulq_f32(*v18, *v18);
      float32x4_t v20 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1)));
      v20.f32[0] = sqrtf(v20.f32[0]);
      float32x4_t v21 = vmulq_f32(v18[1], v18[1]);
      float32x4_t v22 = vmulq_f32(v18[2], v18[2]);
      v20.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0]);
      v20.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0]);
      float32x4_t v23 = vabsq_f32(v20);
      *(float *)(a1 + 200) = 1.0 / fmaxf(fmaxf(v23.f32[0], v23.f32[2]), v23.f32[1]);
    }
    else
    {
      *(void *)(a1 + 40) = 0;
    }
    uint64_t v24 = *(void *)(a1 + 4184);
    return (CFTypeRef)sub_1B65F46C0(v24);
  }
  return result;
}

uint64_t sub_1B6446078(uint64_t result)
{
  *(void *)(result + 888) = 0x7FF0000000000000;
  return result;
}

void sub_1B6446084(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"context");
  }
  double v11 = *(double *)(a1 + 888);
  if (v11 > a2) {
    double v11 = a2;
  }
  *(double *)(a1 + 888) = v11;
}

void sub_1B64460E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  double v9 = *(double *)(a1 + 904);
  if (v9 >= *(double *)(a1 + 888)) {
    double v9 = *(double *)(a1 + 888);
  }
  *(double *)(a1 + 888) = v9;
}

double sub_1B6446144(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(double *)(a1 + 888);
}

uint64_t sub_1B6446190(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  return *(void *)(a1 + 152);
}

uint64_t sub_1B64461DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  return *(void *)(a1 + 160);
}

uint64_t sub_1B6446228(uint64_t a1)
{
  return *(unsigned int *)(a1 + 184);
}

uint64_t sub_1B6446230(uint64_t result, int a2)
{
  *(_DWORD *)(result + 184) = a2;
  return result;
}

uint64_t sub_1B6446238(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 192);
  *(void *)(result + 192) = a2;
  if (((v2 ^ a2) & 0x100) != 0) {
    return sub_1B65F46C0(*(void *)(result + 4184));
  }
  return result;
}

uint64_t sub_1B6446254(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  uint64_t result = *(void *)(a1 + 128);
  if (result) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = a2 == 0;
  }
  if (!v11)
  {
    uint64_t result = sub_1B6428D18(a1);
    *(void *)(a1 + 128) = result;
  }
  return result;
}

float sub_1B64462BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(float *)(a1 + 200);
}

uint64_t sub_1B6446308(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(void *)(a1 + 40);
}

float32x4_t *sub_1B6446354(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  double v9 = *(float32x4_t **)(a1 + 48);
  if (!v9)
  {
    double v9 = (float32x4_t *)sub_1B64A0828();
    uint64_t v10 = (float32x4_t *)sub_1B6494ADC();
    sub_1B6494BF4(v10, 2, v11, v12, v13, v14, v15, v16);
    sub_1B6495D88(v10, 0xDEFA017DEFA017, v17, v18, v19, v20, v21, v22, v30);
    sub_1B64A39B4(v9, (const __CFDictionary *)v10, v23, v24, v25, v26, v27, v28);
    CFRelease(v10);
    *(void *)(a1 + 48) = v9;
  }
  return v9;
}

BOOL sub_1B64463F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"context");
  }
  BOOL result = 1;
  if ((sub_1B64B38A0(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8) & 1) == 0)
  {
    CFDictionaryRef v21 = sub_1B64464A0(a1, @"defaultLight", v15, v16, v17, v18, v19, v20);
    if (!v21 || !CFEqual(v21, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
      return 0;
    }
  }
  return result;
}

CFDictionaryRef sub_1B64464A0(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 832);
  if (result)
  {
    return (const __CFDictionary *)CFDictionaryGetValue(result, key);
  }
  return result;
}

uint64_t sub_1B6446518(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(void *)(a1 + 24);
}

const void *sub_1B6446564(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFDictionaryRef ValueAtIndex = (const void *)a1[3];
  if (!ValueAtIndex)
  {
    CFDictionaryRef ValueAtIndex = (const void *)a1[5];
    if (!ValueAtIndex)
    {
      uint64_t v10 = (__n128 *)a1[2];
      if (v10 && (uint64_t v11 = sub_1B64B1FBC(a1[2], a2, a3, a4, a5, a6, a7, a8)) != 0)
      {
        CFArrayRef v17 = sub_1B64A2A88(v11, @"kCameraKey", 1, v12, v13, v14, v15, v16);
        CFArrayRef v24 = v17;
        if (v17 && CFArrayGetCount(v17) >= 1)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v24, 0);
          sub_1B6445D60((uint64_t)a1, ValueAtIndex, v25, v26, v27, v28, v29, v30);
          if (!a1[3]) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v31, v32, v33, v34, v35, v36, (uint64_t)"context->_pointOfView");
          }
LABEL_19:
          CFRelease(v24);
          return ValueAtIndex;
        }
        CFDictionaryRef v37 = sub_1B64464A0((uint64_t)a1, @"defaultCamera", v18, v19, v20, v21, v22, v23);
        if (v37 && !CFEqual(v37, (CFTypeRef)*MEMORY[0x1E4F1CFD0]))
        {
          CFDictionaryRef ValueAtIndex = 0;
        }
        else
        {
          CFDictionaryRef ValueAtIndex = (const void *)a1[5];
          if (!ValueAtIndex)
          {
            CFDictionaryRef ValueAtIndex = (const void *)sub_1B63DF96C(v10, 0, v38, v39, v40, v41, v42, v43);
            if (ValueAtIndex)
            {
              sub_1B6445F58((uint64_t)a1, ValueAtIndex, v44, v45, v46, v47, v48, v49);
              CFRelease(ValueAtIndex);
            }
          }
        }
        if (v24) {
          goto LABEL_19;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return ValueAtIndex;
}

CFTypeRef sub_1B64466C4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 32);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 32) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 32) = result;
  }
  return result;
}

uint64_t sub_1B6446740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(void *)(a1 + 32);
}

const void *sub_1B644678C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFTypeRef result = (const void *)a1[4];
  if (!result)
  {
    return sub_1B6446564(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B6446800(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return a1 + 56;
}

void sub_1B644684C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  *(void *)(a1 + 120) = a2;
}

uint64_t sub_1B644689C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(void *)(a1 + 120);
}

uint64_t sub_1B64468E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  return *(void *)(a1 + 144);
}

uint64_t sub_1B6446934(uint64_t a1, void *key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFDictionaryRef v11 = *(const __CFDictionary **)(a1 + 832);
  if (v11)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v11, key);
    if (Value)
    {
      unsigned int valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      return valuePtr;
    }
  }
  return v8;
}

uint64_t sub_1B64469B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(unsigned int *)(a1 + 840);
}

void sub_1B6446A04(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  if (*(_DWORD *)(a1 + 840) != a2)
  {
    *(_DWORD *)(a1 + 840) = a2;
    *(unsigned char *)(a1 + 212) = 1;
    uint64_t v10 = *(void *)(a1 + 4184);
    sub_1B65F46C0(v10);
  }
}

uint64_t sub_1B6446A8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(unsigned int *)(a1 + 844);
}

void sub_1B6446AD8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  if (*(_DWORD *)(a1 + 844) != a2)
  {
    *(_DWORD *)(a1 + 844) = a2;
    *(unsigned char *)(a1 + 212) = 1;
    uint64_t v10 = *(void *)(a1 + 4184);
    sub_1B65F46C0(v10);
  }
}

uint64_t sub_1B6446B60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(unsigned __int8 *)(a1 + 549);
}

uint64_t sub_1B6446BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(unsigned __int8 *)(a1 + 550);
}

__n128 sub_1B6446BF8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  if (*(unsigned __int8 *)(a1 + 550) != a2)
  {
    *(unsigned char *)(a1 + 550) = a2;
    *(unsigned char *)(a1 + 549) = a2;
    if (a2)
    {
      *(unsigned char *)(a1 + 560) = *(unsigned char *)(a1 + 218);
      *(unsigned char *)(a1 + 561) = *(unsigned char *)(a1 + 548);
      *(unsigned char *)(a1 + 562) = *(unsigned char *)(a1 + 217);
      long long v11 = *(_OWORD *)(a1 + 1984);
      *(_OWORD *)(a1 + 576) = *(_OWORD *)(a1 + 1968);
      *(_OWORD *)(a1 + 592) = v11;
      long long v12 = *(_OWORD *)(a1 + 2016);
      *(_OWORD *)(a1 + 608) = *(_OWORD *)(a1 + 2000);
      *(_OWORD *)(a1 + 624) = v12;
      long long v13 = *(_OWORD *)(a1 + 944);
      long long v14 = *(_OWORD *)(a1 + 960);
      long long v15 = *(_OWORD *)(a1 + 992);
      *(_OWORD *)(a1 + 736) = *(_OWORD *)(a1 + 976);
      *(_OWORD *)(a1 + 752) = v15;
      *(_OWORD *)(a1 + 704) = v13;
      *(_OWORD *)(a1 + 720) = v14;
      long long v16 = *(_OWORD *)(a1 + 2048);
      *(_OWORD *)(a1 + 640) = *(_OWORD *)(a1 + 2032);
      *(_OWORD *)(a1 + 656) = v16;
      long long v17 = *(_OWORD *)(a1 + 2080);
      *(_OWORD *)(a1 + 672) = *(_OWORD *)(a1 + 2064);
      *(_OWORD *)(a1 + 688) = v17;
      long long v18 = *(_OWORD *)(a1 + 1056);
      *(_OWORD *)(a1 + 800) = *(_OWORD *)(a1 + 1040);
      *(_OWORD *)(a1 + 816) = v18;
      __n128 result = *(__n128 *)(a1 + 1008);
      long long v19 = *(_OWORD *)(a1 + 1024);
      *(__n128 *)(a1 + 768) = result;
      *(_OWORD *)(a1 + 784) = v19;
      *(unsigned char *)(a1 + 218) = 1;
      if ((*(unsigned char *)(a1 + 4169) & 0x20) != 0) {
        *(unsigned char *)(a1 + 548) = 1;
      }
      *(unsigned char *)(a1 + 217) = 2;
    }
    else
    {
      *(unsigned char *)(a1 + 218) = *(unsigned char *)(a1 + 560);
      if ((*(unsigned char *)(a1 + 4169) & 0x20) != 0) {
        *(unsigned char *)(a1 + 548) = *(unsigned char *)(a1 + 561);
      }
      long long v20 = *(_OWORD *)(a1 + 592);
      *(_OWORD *)(a1 + 1968) = *(_OWORD *)(a1 + 576);
      *(_OWORD *)(a1 + 1984) = v20;
      long long v21 = *(_OWORD *)(a1 + 624);
      *(_OWORD *)(a1 + 2000) = *(_OWORD *)(a1 + 608);
      *(_OWORD *)(a1 + 2016) = v21;
      long long v22 = *(_OWORD *)(a1 + 720);
      *(_OWORD *)(a1 + 944) = *(_OWORD *)(a1 + 704);
      *(_OWORD *)(a1 + 960) = v22;
      long long v23 = *(_OWORD *)(a1 + 752);
      *(_OWORD *)(a1 + 976) = *(_OWORD *)(a1 + 736);
      *(_OWORD *)(a1 + 992) = v23;
      long long v24 = *(_OWORD *)(a1 + 656);
      *(_OWORD *)(a1 + 2032) = *(_OWORD *)(a1 + 640);
      *(_OWORD *)(a1 + 2048) = v24;
      long long v25 = *(_OWORD *)(a1 + 688);
      *(_OWORD *)(a1 + 2064) = *(_OWORD *)(a1 + 672);
      *(_OWORD *)(a1 + 2080) = v25;
      long long v26 = *(_OWORD *)(a1 + 784);
      *(_OWORD *)(a1 + 1008) = *(_OWORD *)(a1 + 768);
      *(_OWORD *)(a1 + 1024) = v26;
      __n128 result = *(__n128 *)(a1 + 800);
      long long v27 = *(_OWORD *)(a1 + 816);
      *(__n128 *)(a1 + 1040) = result;
      *(unsigned char *)(a1 + 217) = *(unsigned char *)(a1 + 562);
      *(_OWORD *)(a1 + 1056) = v27;
    }
  }
  return result;
}

uint64_t sub_1B6446D64(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 218);
}

uint64_t sub_1B6446D6C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 548);
}

unint64_t sub_1B6446D74(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  if (a3 >= 0x10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"eye < CFXRenderingEyeMaxCount");
  }
  return a1 + ((uint64_t)a2 << 10) + ((unint64_t)v8 << 6) + 944;
}

uint64_t sub_1B6446DE4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 218) = a2;
  return result;
}

uint64_t sub_1B6446DEC(uint64_t result, char a2)
{
  if ((*(unsigned char *)(result + 4169) & 0x20) != 0) {
    *(unsigned char *)(result + 548) = a2;
  }
  return result;
}

uint64_t sub_1B6446E00(uint64_t result, char a2)
{
  *(unsigned char *)(result + 217) = a2;
  return result;
}

__n128 sub_1B6446E08(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  if (a4 >= 0x10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"eye < CFXRenderingEyeMaxCount");
  }
  __n128 result = *(__n128 *)a3;
  long long v13 = *(_OWORD *)(a3 + 16);
  long long v14 = *(_OWORD *)(a3 + 48);
  unint64_t v15 = a1 + ((uint64_t)a2 << 10) + ((unint64_t)v8 << 6);
  *(_OWORD *)(v15 + 976) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v15 + 992) = v14;
  *(__n128 *)(v15 + 944) = result;
  *(_OWORD *)(v15 + 960) = v13;
  return result;
}

__n128 sub_1B6446E88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 result)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 550))
  {
    long long v61 = *(_OWORD *)(a1 + 256);
    *(_OWORD *)(a1 + 272) = v61;
    uint64_t v10 = sub_1B6446564((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    memset(&v60, 0, sizeof(v60));
    sub_1B64A27C4((uint64_t)v10, (uint64_t)&v60, v11, v12, v13, v14, v15, v16);
    simd_float4x4 v64 = __invert_f4(v60);
    uint64_t v23 = 0;
    simd_float4x4 v60 = v64;
    v62[0].columns[0] = (simd_float4)xmmword_1B6E4F300;
    v62[0].columns[1] = (simd_float4)xmmword_1B6E4F320;
    memset(&v52, 0, 48);
    v62[0].columns[2] = (simd_float4)xmmword_1B6E509F0;
    do
    {
      v52.columns[v23] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E50A00, COERCE_FLOAT(*(_OWORD *)&v62[0].columns[v23])), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v62[0].columns[v23].f32, 1), (float32x4_t)xmmword_1B6E50A10, (float32x4_t)v62[0].columns[v23], 2);
      ++v23;
    }
    while (v23 != 3);
    uint64_t v24 = 0;
    v62[0].columns[0] = v52.columns[0];
    v62[0].columns[1] = v52.columns[1];
    v62[0].columns[2] = v52.columns[2];
    memset(&v52, 0, 48);
    do
    {
      v52.columns[v24] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(_OWORD *)&v62[0].columns[v24])), (float32x4_t)xmmword_1B6E50A20, *(float32x2_t *)v62[0].columns[v24].f32, 1), (float32x4_t)xmmword_1B6E4F2E0, (float32x4_t)v62[0].columns[v24], 2);
      ++v24;
    }
    while (v24 != 3);
    uint64_t v25 = 0;
    float32x4_t v26 = (float32x4_t)v52.columns[0];
    float32x4_t v27 = (float32x4_t)v52.columns[1];
    v26.i32[3] = 0;
    float32x4_t v28 = (float32x4_t)v52.columns[2];
    v27.i32[3] = 0;
    v28.i32[3] = 0;
    v62[0] = v64;
    memset(&v52, 0, sizeof(v52));
    do
    {
      v52.columns[v25] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v26, COERCE_FLOAT(*(_OWORD *)&v62[0].columns[v25])), v27, *(float32x2_t *)v62[0].columns[v25].f32, 1), v28, (float32x4_t)v62[0].columns[v25], 2), (float32x4_t)xmmword_1B6E4F370, (float32x4_t)v62[0].columns[v25], 3);
      ++v25;
    }
    while (v25 != 4);
    uint64_t v29 = 0;
    float32x4_t v30 = (float32x4_t)v52.columns[3];
    simd_float4x4 v60 = v52;
    v62[0].columns[0] = (simd_float4)xmmword_1B6E4F300;
    v62[0].columns[1] = (simd_float4)xmmword_1B6E4F320;
    v62[0].columns[2] = (simd_float4)xmmword_1B6E509F0;
    memset(&v52, 0, 48);
    do
    {
      v52.columns[v29] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E50A30, COERCE_FLOAT(*(_OWORD *)&v62[0].columns[v29])), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v62[0].columns[v29].f32, 1), (float32x4_t)xmmword_1B6E50A40, (float32x4_t)v62[0].columns[v29], 2);
      ++v29;
    }
    while (v29 != 3);
    uint64_t v31 = 0;
    v62[0].columns[0] = v52.columns[0];
    v62[0].columns[1] = v52.columns[1];
    v62[0].columns[2] = v52.columns[2];
    memset(&v52, 0, 48);
    do
    {
      v52.columns[v31] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(_OWORD *)&v62[0].columns[v31])), (float32x4_t)xmmword_1B6E50A20, *(float32x2_t *)v62[0].columns[v31].f32, 1), (float32x4_t)xmmword_1B6E4F2E0, (float32x4_t)v62[0].columns[v31], 2);
      ++v31;
    }
    while (v31 != 3);
    uint64_t v32 = 0;
    float32x4_t v33 = (float32x4_t)v52.columns[0];
    float32x4_t v34 = (float32x4_t)v52.columns[1];
    float32x4_t v35 = (float32x4_t)v52.columns[2];
    v33.i32[3] = 0;
    v34.i32[3] = 0;
    v35.i32[3] = 0;
    v62[0] = v64;
    memset(&v52, 0, sizeof(v52));
    do
    {
      v52.columns[v32] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, COERCE_FLOAT(*(_OWORD *)&v62[0].columns[v32])), v34, *(float32x2_t *)v62[0].columns[v32].f32, 1), v35, (float32x4_t)v62[0].columns[v32], 2), (float32x4_t)xmmword_1B6E4F370, (float32x4_t)v62[0].columns[v32], 3);
      ++v32;
    }
    while (v32 != 4);
    simd_float4 v36 = v52.columns[0];
    simd_float4 v37 = v52.columns[1];
    simd_float4 v38 = v52.columns[2];
    v60.columns[3] = (simd_float4)vaddq_f32(v30, (float32x4_t)xmmword_1B6E50A50);
    float32x4_t v39 = vaddq_f32((float32x4_t)v52.columns[3], (float32x4_t)xmmword_1B6E50A60);
    simd_float4 v40 = v60.columns[1];
    *(simd_float4 *)(a1 + 1968) = v60.columns[0];
    *(simd_float4 *)(a1 + 1984) = v40;
    simd_float4 v41 = v60.columns[3];
    *(simd_float4 *)(a1 + 2000) = v60.columns[2];
    *(simd_float4 *)(a1 + 2016) = v41;
    *(simd_float4 *)(a1 + 2032) = v36;
    *(simd_float4 *)(a1 + 2048) = v37;
    *(simd_float4 *)(a1 + 2064) = v38;
    *(float32x4_t *)(a1 + 2080) = v39;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v53 = 0u;
    memset(&v52, 0, sizeof(v52));
    sub_1B63E0460((uint64_t)v10, (uint64_t)&v52, v17, v18, v19, v20, v21, v22);
    uint64_t v48 = sub_1B649CD50((unsigned __int8 *)&v52, (uint64_t)&v61, v42, v43, v44, v45, v46, v47);
    __n128 result = *(__n128 *)v48;
    long long v49 = *((_OWORD *)v48 + 1);
    long long v50 = *((_OWORD *)v48 + 2);
    long long v51 = *((_OWORD *)v48 + 3);
    *(_OWORD *)(a1 + 976) = v50;
    *(_OWORD *)(a1 + 992) = v51;
    *(__n128 *)(a1 + 944) = result;
    *(_OWORD *)(a1 + 960) = v49;
    *(__n128 *)(a1 + 1008) = result;
    *(_OWORD *)(a1 + 1024) = v49;
    *(_OWORD *)(a1 + 1056) = v51;
    *(_OWORD *)(a1 + 1040) = v50;
  }
  return result;
}

__n128 sub_1B64471F4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"index < CFXRenderingEyeMaxCount");
  }
  return *(__n128 *)(a1 + 16 * a2 + 256);
}

void sub_1B644724C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (a2 >= 0x10)
  {
    __n128 v11 = a9;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"index < CFXRenderingEyeMaxCount");
    a9 = v11;
  }
  *(__n128 *)(a1 + 16 * a2 + 256) = a9;
}

void sub_1B64472AC(uint64_t a1, void *key, void *value, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)value, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFMutableArrayRef Mutable = *(__CFDictionary **)(a1 + 832);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(a1 + 832) = Mutable;
  }
  if (value)
  {
    CFDictionarySetValue(Mutable, key, value);
  }
  else
  {
    CFDictionaryRemoveValue(Mutable, key);
  }
}

void sub_1B6447368(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  *(unsigned char *)(a1 + 214) = a2;
}

void sub_1B64473B8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  *(unsigned char *)(a1 + 213) = a2 != 0;
}

uint64_t sub_1B6447410(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  return *(unsigned __int8 *)(a1 + 213);
}

void sub_1B644745C(uint64_t *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  sub_1B6445C38(a1, a2, a3, a4, a5, a6, a7, a8);
  if (a2)
  {
    if (!sub_1B64B1FBC((uint64_t)a2, v10, v11, v12, v13, v14, v15, v16)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v18, v19, v20, v21, v22, v23, (uint64_t)"root");
    }
    uint64_t v24 = sub_1B64B393C((uint64_t)a2, v17, v18, v19, v20, v21, v22, v23);
    sub_1B6445EF0((uint64_t)a1, v24, v25, v26, v27, v28, v29, v30);
    sub_1B65F46C0(a1[523]);
    sub_1B6595954(a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))sub_1B6447568, @"kCFXNotificationEngineContextInvalidatePasses", a2, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  else
  {
    sub_1B65959BC(a1, @"kCFXNotificationEngineContextInvalidatePasses", 0);
  }
}

uint64_t sub_1B6447568(int a1, uint64_t *a2, int a3, int a4, CFDictionaryRef theDict)
{
  if (!theDict
    || (CFNumberRef Value = CFDictionaryGetValue(theDict, @"kCameraEffectKey"),
        unsigned int v8 = CFDictionaryGetValue(theDict, @"kCameraKey"),
        (uint64_t result = (uint64_t)sub_1B6446564(a2, v9, v10, v11, v12, v13, v14, v15)) != 0)
    && (uint64_t result = (uint64_t)sub_1B64A3B48(result, v17, v18, v19, v20, v21, v22, v23)) != 0
    && ((v24 = result, !Value) || (uint64_t result = sub_1B649BC08((void *)result, (uint64_t)Value), result))
    && (v8 ? (BOOL v25 = v8 == (const void *)v24) : (BOOL v25 = 1), v25))
  {
    uint64_t v26 = a2[523];
    return sub_1B65F46C0(v26);
  }
  return result;
}

uint64_t sub_1B6447624(uint64_t a1, const char *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 224);
  if (!v4)
  {
    uint64_t v4 = objc_msgSend_generatorWithProfile_allowingHotReload_(VFXCommonProfileProgramGenerator, a2, 0, 0);
    *(void *)(a1 + 224) = v4;
  }

  return MEMORY[0x1F4181798](v4, sel_programWithHashCode_engineContext_trackedResource_introspectionDataPtr_, a2, a1);
}

uint64_t sub_1B64476A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  *(void *)(a1 + 224) = 0;

  return sub_1B6445D60(a1, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B6447708(uint64_t result, double a2)
{
  *(double *)(result + 896) = a2;
  return result;
}

uint64_t sub_1B6447710(uint64_t result, double a2)
{
  *(double *)(result + 904) = a2;
  return result;
}

double sub_1B6447718(uint64_t a1)
{
  return *(double *)(a1 + 904);
}

uint64_t sub_1B6447720(uint64_t result, double a2)
{
  *(double *)(result + 912) = a2;
  return result;
}

double sub_1B6447728(uint64_t a1)
{
  return *(double *)(a1 + 912);
}

uint64_t sub_1B6447730(uint64_t a1)
{
  return *(unsigned int *)(a1 + 920);
}

CFTypeRef sub_1B6447738(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 168);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 168) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 168) = result;
  }
  return result;
}

uint64_t sub_1B644778C(uint64_t a1)
{
  return *(void *)(a1 + 168);
}

uint64_t sub_1B6447794(uint64_t a1)
{
  if (!*(void *)(a1 + 856))
  {
    int v2 = (const void *)sub_1B6549D0C(0, 1, 1, 0, 2.0, -2.0, 0.0);
    uint64_t v10 = sub_1B63DF358((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
    *(void *)(a1 + 856) = v10;
    sub_1B65834BC(v10, @"Quad", v11, v12, v13, v14, v15, v16);
    if (v2) {
      CFRelease(v2);
    }
  }
  return *(void *)(a1 + 856);
}

uint64_t sub_1B6447804(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 240) = a2;
  *(void *)(result + 248) = a3;
  return result;
}

double sub_1B644780C(float32x4_t *a1)
{
  float32x4_t v1 = a1[15];
  uint64_t v2 = a1[1].i64[0];
  if (v2)
  {
    float32x4_t v26 = v1;
    uint64_t v3 = sub_1B64B27BC(v2, 0);
    if (v3 && (uint64_t v11 = v3, (v12 = (float32x4_t *)sub_1B6475E50(v3, v4, v5, v6, v7, v8, v9, v10)) != 0))
    {
      float32x4_t v25 = *v12;
      float v20 = sub_1B64763AC(v11, v13, v14, v15, v16, v17, v18, v19);
      if (v20 == 1.0)
      {
        float32x4_t v22 = v25;
      }
      else
      {
        float32x4_t v21 = vmulq_n_f32(v25, v20);
        v21.i32[3] = v25.i32[3];
        float32x4_t v22 = v21;
      }
      float32x4_t v23 = vmulq_laneq_f32(v22, v22, 3);
      v23.i32[3] = v22.i32[3];
      v1.i64[0] = vaddq_f32(v23, vmulq_n_f32(v26, 1.0 - v22.f32[3])).u64[0];
    }
    else
    {
      v1.i64[0] = v26.i64[0];
    }
  }
  return *(double *)v1.i64;
}

uint64_t sub_1B64478B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    uint64_t v10 = sub_1B64B27BC(result, 0);
    return v10 && sub_1B6475F88(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  return result;
}

void sub_1B6447920(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineContext");
  }
  *(unsigned char *)(a1 + 925) = 1;
  *(void *)(a1 + 928) = a2;
}

uint64_t sub_1B6447978(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 925);
}

uint64_t sub_1B6447980(uint64_t a1)
{
  return *(void *)(a1 + 928);
}

uint64_t sub_1B6447988(uint64_t a1, int a2)
{
  return a1 + ((uint64_t)a2 << 10) + 944;
}

__n128 sub_1B6447998(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1 + ((uint64_t)a2 << 10);
  __n128 result = *(__n128 *)a3;
  long long v5 = *(_OWORD *)(a3 + 16);
  long long v6 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(v3 + 976) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v3 + 992) = v6;
  *(__n128 *)(v3 + 944) = result;
  *(_OWORD *)(v3 + 960) = v5;
  return result;
}

uint64_t sub_1B64479B4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 216) = a2;
  return result;
}

uint64_t sub_1B64479BC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 216);
}

__n128 sub_1B64479C4(__n128 *a1)
{
  return a1[16];
}

__n128 *sub_1B64479CC(__n128 *result, __n128 a2)
{
  result[16] = a2;
  return result;
}

double sub_1B64479D4(uint64_t a1)
{
  return *(double *)(a1 + 528);
}

uint64_t sub_1B64479DC(uint64_t result, double a2)
{
  *(double *)(result + 528) = a2;
  return result;
}

uint64_t sub_1B64479E4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 544);
}

uint64_t sub_1B64479EC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 544) = a2;
  return result;
}

__n128 sub_1B64479F4(__n128 *a1)
{
  return a1[32];
}

__n128 *sub_1B64479FC(__n128 *result, __n128 a2)
{
  result[32] = a2;
  return result;
}

BOOL sub_1B6447A04(uint64_t a1, int a2)
{
  return (a2 & ~*(_DWORD *)(a1 + 4168)) == 0;
}

id sub_1B6447A14(uint64_t a1, const CFX::RG::Resource *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 4160))
  {
    uint64_t v8 = *(void *)(a1 + 4184);
    return sub_1B65F482C(v8, a2);
  }
  else
  {
    sub_1B63F2F54(16, @"Unreachable code: CFXEngineContextGetTextureFromHandle - no render context", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
}

id sub_1B6447A60(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 4160))
  {
    uint64_t v8 = *(void *)(a1 + 4184);
    return sub_1B65F46E0(v8, a2, a3, a4);
  }
  else
  {
    sub_1B63F2F54(16, @"Unreachable code: CFXEngineContextGetTextureWithName", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
}

uint64_t sub_1B6447AAC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = sub_1B64765F4(a2, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!v11) {
    uint64_t v11 = sub_1B643DF24();
  }
  *a3 = v11;
  uint64_t v19 = *(void **)(a1 + 4160);
  if (v19)
  {
    return objc_msgSend_textureForMaterialProperty_(v19, v12, a2, v14);
  }
  else
  {
    sub_1B63F2F54(16, @"Unreachable code: CFXEngineContextGetTextureForMaterialProperty", v13, v14, v15, v16, v17, v18, v21);
    return 0;
  }
}

uint64_t sub_1B6447B30(unsigned int a1)
{
  if (a1 > 7) {
    return 0;
  }
  else {
    return dword_1B6E50AF4[a1];
  }
}

void *sub_1B6447B50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(void **)(a1 + 4160);
  if (result) {
    return objc_msgSend_currentFrameIndex(result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_1B6447B70(uint64_t a1)
{
  return 8 * *(unsigned __int8 *)(a1 + 215);
}

uint64_t sub_1B6447B7C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 548)) {
    return 2;
  }
  else {
    return 1;
  }
}

CFTypeRef sub_1B6447B90(uint64_t a1, CFTypeRef cf, unsigned int a3)
{
  uint64_t v3 = a1 + 8 * a3;
  CFTypeRef result = *(CFTypeRef *)(v3 + 4024);
  if (result != cf)
  {
    long long v6 = (void *)(v3 + 4024);
    if (result)
    {
      CFRelease(result);
      *long long v6 = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *long long v6 = result;
  }
  return result;
}

uint64_t sub_1B6447BE8(uint64_t result, char a2)
{
  *(unsigned char *)(result + 4016) = a2;
  return result;
}

uint64_t sub_1B6447BF0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4016);
}

uint64_t sub_1B6447BF8(uint64_t result, float a2)
{
  if (a2 != 0.0) {
    *(float *)(result + 204) = a2;
  }
  return result;
}

float sub_1B6447C0C(uint64_t a1)
{
  return *(float *)(a1 + 204);
}

uint64_t sub_1B6447C14(uint64_t result, float a2)
{
  if (*(float *)(result + 208) != a2)
  {
    *(float *)(result + 208) = a2;
    return sub_1B65F46C0(*(void *)(result + 4184));
  }
  return result;
}

float sub_1B6447C30(uint64_t a1)
{
  return *(float *)(a1 + 208);
}

CFIndex sub_1B6447C38(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"context");
  }
  CFIndex result = a1[2];
  if (result)
  {
    uint64_t v10 = sub_1B64B2864(result, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v18 = sub_1B6453580(v10, v11, v12, v13, v14, v15, v16, v17);
    uint64_t v26 = sub_1B661BEE0(v18, v19, v20, v21, v22, v23, v24, v25);
    sub_1B63F6930(a1[19], v26);
    uint64_t v27 = a1[20];
    sub_1B6512640(v27, v26, v28, v29, v30, v31, v32, v33);
    return sub_1B6512780(v27, v10, v34, v35, v36, v37, v38, v39);
  }
  return result;
}

void sub_1B6447CEC(uint64_t a1)
{
  nullsub_1(*(void *)(a1 + 4184));
  uint64_t v5 = *(void *)(a1 + 4184);

  sub_1B65F4318(v5, v2, v3, v4);
}

uint64_t sub_1B6447D28(uint64_t result, char a2)
{
  *(unsigned char *)(result + 4172) = *(unsigned char *)(result + 4172) & 0xFE | a2;
  return result;
}

uint64_t sub_1B6447D40(uint64_t a1)
{
  return *(unsigned char *)(a1 + 4172) & 1;
}

uint64_t sub_1B6447D50(uint64_t result, int a2)
{
  *(_DWORD *)(result + 4176) = a2;
  return result;
}

uint64_t sub_1B6447D58(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4176);
}

uint64_t sub_1B6447D60(uint64_t result, char a2)
{
  *(unsigned char *)(result + 4180) = a2;
  return result;
}

uint64_t sub_1B6447D6C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4180);
}

double sub_1B6447D78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(float *)(a1 + 264) <= 0.0 || *(float *)(a1 + 268) <= 0.0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong viewport", a3, a4, a5, a6, a7, a8, (uint64_t)"viewport.z > 0 && viewport.w > 0");
  }
  *(void *)&double result = 1065353216;
  return result;
}

uint64_t sub_1B6447FBC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 4256) = *(unsigned char *)(result + 4256) & 0xFE | a2;
  return result;
}

uint64_t sub_1B6447FD4(uint64_t a1)
{
  return *(unsigned char *)(a1 + 4256) & 1;
}

float32x2_t sub_1B6447FE4(float32x2_t *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  float32x2_t result = 0;
  if ((a1[532].i8[0] & 1) != 0 && a1[33].f32[0] != 0.0 && a1[33].f32[1] != 0.0)
  {
    uint64_t v6 = objc_msgSend_currentFrameIndex(*(void **)&a1[520], a2, a3, a4, 0.0) + (int)a2;
    uint64_t v7 = v6 & 7;
    uint64_t v9 = -v6;
    BOOL v8 = v9 < 0;
    uint64_t v10 = v9 & 7;
    if (v8) {
      uint64_t v11 = v7;
    }
    else {
      uint64_t v11 = -v10;
    }
    return vdiv_f32(a1[v11 + 524], a1[33]);
  }
  return result;
}

uint64_t sub_1B644805C(uint64_t a1)
{
  return *(void *)(a1 + 176);
}

uint64_t sub_1B6448064(uint64_t result, char a2)
{
  *(unsigned char *)(result + 4280) = a2;
  return result;
}

uint64_t sub_1B6448070(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4280);
}

void sub_1B6448080(void *a1)
{
  if (a1)
  {
    sub_1B65F42D8(a1[523]);
    sub_1B658F62C((unint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
    sub_1B65959BC(a1, @"kCFXNotificationEngineContextInvalidatePasses", 0);
    uint64_t v15 = a1[2];
    if (v15) {
      sub_1B64B0D10(v15, (uint64_t)a1, v9, v10, v11, v12, v13, v14);
    }
    uint64_t v16 = (const void *)a1[16];
    if (v16)
    {
      CFRelease(v16);
      a1[16] = 0;
    }
    uint64_t v17 = (const void *)a1[17];
    if (v17)
    {
      CFRelease(v17);
      a1[17] = 0;
    }
    uint64_t v18 = (const void *)a1[2];
    if (v18)
    {
      CFRelease(v18);
      a1[2] = 0;
    }
    uint64_t v19 = (const void *)a1[3];
    if (v19)
    {
      CFRelease(v19);
      a1[3] = 0;
    }
    uint64_t v20 = (const void *)a1[4];
    if (v20)
    {
      CFRelease(v20);
      a1[4] = 0;
    }
    uint64_t v21 = (const void *)a1[5];
    if (v21)
    {
      CFRelease(v21);
      a1[5] = 0;
    }
    uint64_t v22 = (const void *)a1[104];
    if (v22)
    {
      CFRelease(v22);
      a1[104] = 0;
    }
    uint64_t v23 = (const void *)a1[6];
    if (v23)
    {
      CFRelease(v23);
      a1[6] = 0;
    }
    uint64_t v24 = (const void *)a1[107];
    if (v24)
    {
      CFRelease(v24);
      a1[107] = 0;
    }
    uint64_t v25 = (const void *)a1[22];
    if (v25)
    {
      CFRelease(v25);
      a1[22] = 0;
    }
    uint64_t v26 = (const void *)a1[520];
    if (v26)
    {
      CFRelease(v26);
      a1[520] = 0;
    }
    uint64_t v27 = (const void *)a1[21];
    if (v27)
    {
      CFRelease(v27);
      a1[21] = 0;
    }
    uint64_t v28 = (const void *)a1[19];
    if (v28)
    {
      CFRelease(v28);
      a1[19] = 0;
    }
    uint64_t v29 = (const void *)a1[20];
    if (v29)
    {
      CFRelease(v29);
      a1[20] = 0;
    }
    CStackAllocatorDestroy(a1[18]);
    uint64_t v30 = 0;
    uint64_t v31 = a1 + 503;
    do
    {
      uint64_t v32 = (const void *)v31[v30];
      if (v32)
      {
        CFRelease(v32);
        v31[v30] = 0;
      }
      ++v30;
    }
    while (v30 != 16);
    a1[519] = 0;
  }
}

CFStringRef sub_1B64481F8(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXEngineContext>");
}

CFStringRef sub_1B644822C(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXEngineContext>");
}

uint64_t sub_1B64488C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA7F0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v20 = a2;
    uint64_t v21 = a3;
    int v19 = __cxa_guard_acquire(&qword_1E9DDA7F0);
    uint64_t v8 = (void *)&unk_1E9DDA000;
    a2 = v20;
    a3 = v21;
    if (v19)
    {
      qword_1E9DDA7E8 = (uint64_t)sub_1B64494C8("CHROMATIC_TRANSFORM_COMPISTE_BLOOM_PASS", 0x27u);
      __cxa_guard_release(&qword_1E9DDA7F0);
      uint64_t v8 = (void *)&unk_1E9DDA000;
      a2 = v20;
      a3 = v21;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v8[253], 0);
  *(void *)a1 = &unk_1F0FB5040;
  long long v9 = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 376) = *(_OWORD *)(a5 + 16);
  *(_OWORD *)(a1 + 392) = v9;
  long long v10 = *(_OWORD *)(a5 + 48);
  long long v11 = *(_OWORD *)(a5 + 64);
  long long v12 = *(_OWORD *)(a5 + 80);
  *(void *)(a1 + 456) = *(void *)(a5 + 96);
  *(_OWORD *)(a1 + 424) = v11;
  *(_OWORD *)(a1 + 440) = v12;
  *(_OWORD *)(a1 + 408) = v10;
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 472) = 0;
  long long v13 = *(_OWORD *)(a5 + 24);
  long long v14 = *(_OWORD *)(a5 + 40);
  long long v15 = *(_OWORD *)(a5 + 56);
  long long v16 = *(_OWORD *)(a5 + 88);
  long long v22[3] = *(_OWORD *)(a5 + 72);
  v22[4] = v16;
  v22[1] = v14;
  v22[2] = v15;
  v22[0] = v13;
  uint64_t v17 = sub_1B63C7D8C(a4, (uint64_t)"CHROMATIC_TRANSFORM_COMPOSITE_BLOOM_OUTPUT", (uint64_t)v22);
  *(void *)(a1 + 488) = v17;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v17);
  return a1;
}

void sub_1B6448A00(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6448A14(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
  a1[58] = v5;
  if (!v5)
  {
    a1[58] = sub_1B6448AA4(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
    long long v13 = (void *)sub_1B6445900(a1[46], v6, v7, v8, v9, v10, v11, v12);
    uint64_t v17 = objc_msgSend_resourceManager(v13, v14, v15, v16);
    uint64_t v18 = a1[58];
    uint64_t v21 = objc_msgSend_newComputePipelineStateWithFunctionName_(v17, v19, @"chromatic_transform_composite_bloom", v20);
    uint64_t v22 = *(void **)(v18 + 16);
    if (v22 != (void *)v21)
    {
      uint64_t v23 = v21;
      if (v22) {

      }
      *(void *)(v18 + 16) = v23;
    }
  }
}

uint64_t sub_1B6448AA4(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B6448B2C(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v5 = *a3;
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 472));
  id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 480));
  id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 488));
  CFDictionaryRef v16 = sub_1B64A3B48(*(void *)(a1 + 376), v9, v10, v11, v12, v13, v14, v15);
  uint64_t v24 = sub_1B649ABF8((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23);
  if (v24) {
    float v32 = sub_1B6529330(v24, (uint64_t)v25, v26, v27, v28, v29, v30, v31);
  }
  else {
    float v32 = 0.0;
  }
  float v47 = v32;
  objc_msgSend_setBytes_length_atIndex_(v5, v25, (uint64_t)&v47, 4, 0);
  objc_msgSend_setTexture_atIndex_(v5, v33, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v34, (uint64_t)v7, 1);
  objc_msgSend_setTexture_atIndex_(v5, v35, (uint64_t)v8, 2);
  uint64_t v42 = *(void *)(a1 + 464);
  uint64_t v43 = *(void *)(v42 + 16);
  if (!v43)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v36, v37, v38, v39, v40, v41, (uint64_t)"_ptr != NULL");
    uint64_t v43 = *(void *)(v42 + 16);
  }
  uint64_t v44 = sub_1B653EFB8(v43);
  return objc_msgSend_dispatch_onTexture2D_(v5, v45, v44, (uint64_t)v8);
}

uint64_t sub_1B6448C40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  id v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA800, memory_order_acquire) & 1) == 0)
  {
    uint64_t v21 = a2;
    uint64_t v22 = a3;
    int v20 = __cxa_guard_acquire(&qword_1E9DDA800);
    id v8 = &unk_1E9DDA000;
    a2 = v21;
    a3 = v22;
    if (v20)
    {
      byte_1E9DDA7F8 = 1;
      __cxa_guard_release(&qword_1E9DDA800);
      id v8 = (unsigned char *)&unk_1E9DDA000;
      a2 = v21;
      a3 = v22;
    }
  }
  if (v8[2040]) {
    uint64_t v9 = 0x41EC325388DE9425;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v9, 0);
  *(void *)a1 = &unk_1F0FB4390;
  long long v10 = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 376) = *(_OWORD *)(a5 + 16);
  *(_OWORD *)(a1 + 392) = v10;
  long long v11 = *(_OWORD *)(a5 + 48);
  long long v12 = *(_OWORD *)(a5 + 64);
  long long v13 = *(_OWORD *)(a5 + 80);
  *(void *)(a1 + 456) = *(void *)(a5 + 96);
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 440) = v13;
  *(_OWORD *)(a1 + 408) = v11;
  *(void *)(a1 + 472) = 0;
  *(void *)(a1 + 480) = 0;
  long long v14 = *(_OWORD *)(a5 + 24);
  long long v15 = *(_OWORD *)(a5 + 40);
  long long v16 = *(_OWORD *)(a5 + 56);
  long long v17 = *(_OWORD *)(a5 + 88);
  v23[3] = *(_OWORD *)(a5 + 72);
  v23[4] = v17;
  v23[1] = v15;
  v23[2] = v16;
  v23[0] = v14;
  uint64_t v18 = sub_1B63C7D8C(a4, (uint64_t)"CHROMATIC_TRANSFORM_OUTPUT", (uint64_t)v23);
  *(void *)(a1 + 480) = v18;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v18);
  return a1;
}

void sub_1B6448D80(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6448D94(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10 = sub_1B64A3B48(a1[47], a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B649B170((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
  uint64_t v26 = v18;
  if (v18)
  {
    int v61 = sub_1B652BFEC(v18, v19, v20, v21, v22, v23, v24, v25);
    LODWORD(v26) = sub_1B652C4AC(v26, v27, v28, v29, v30, v31, v32, v33);
    uint64_t v34 = v61;
  }
  else
  {
    uint64_t v34 = 1;
    int v61 = 1;
  }
  char v60 = v26;
  unint64_t v35 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v36 = 0x9DDFEA08EB382D69
      * (v35 ^ ((0x9DDFEA08EB382D69 * (v35 ^ v34)) >> 47) ^ (0x9DDFEA08EB382D69 * (v35 ^ v34)));
  unint64_t v37 = 0x9DDFEA08EB382D69 * (v36 ^ (v36 >> 47));
  uint64_t v38 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v37 ^ ((0x9DDFEA08EB382D69 * (v37 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                             * (v37 ^ v26)))) ^ ((0x9DDFEA08EB382D69 * (v37 ^ ((0x9DDFEA08EB382D69 * (v37 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v37 ^ v26)))) >> 47));
  uint64_t v39 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v38);
  a1[58] = v39;
  if (!v39)
  {
    a1[58] = sub_1B6448F08(*(CFX::CrossFrameResourceManager **)(a2 + 32), v38);
    float v47 = (void *)sub_1B6445900(a1[46], v40, v41, v42, v43, v44, v45, v46);
    long long v51 = objc_msgSend_resourceManager(v47, v48, v49, v50);
    id v52 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v52, v53, (uint64_t)&v61, 29, @"sample_count");
    objc_msgSend_setConstantValue_type_withName_(v52, v54, (uint64_t)&v60, 53, @"mask_enabled");
    uint64_t v55 = a1[58];
    uint64_t v57 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v51, v56, @"chromatic_transform", (uint64_t)v52);
    long long v58 = *(void **)(v55 + 16);
    if (v58 != (void *)v57)
    {
      uint64_t v59 = v57;
      if (v58) {

      }
      *(void *)(v55 + 16) = v59;
    }
  }
}

uint64_t sub_1B6448F08(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B6448F90(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10 = *a3;
  CFDictionaryRef v11 = sub_1B64A3B48(*(void *)(a1 + 376), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v26 = (__n128 *)sub_1B649B170((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18);
  if (!v26) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v20, v21, v22, v23, v24, v25, (uint64_t)"chromaticTransform");
  }
  float v139 = sub_1B65299B8((uint64_t)v26, v19, v20, v21, v22, v23, v24, v25);
  float32x2_t v140 = vmul_n_f32(vmul_f32(COERCE_FLOAT32X2_T(sub_1B652C124((uint64_t)v26, v27, v28, v29, v30, v31, v32, v33)), (float32x2_t)0xC000000040000000), v139);
  double v34 = 1.0 - v139;
  float v42 = v34 + (float)(v139 * sub_1B6529E94((uint64_t)v26, v35, v36, v37, v38, v39, v40, v41));
  float v141 = v42;
  float v50 = (float)(sub_1B6529F38((uint64_t)v26, v43, v44, v45, v46, v47, v48, v49) / 180.0) * 3.14159265 * v139;
  float v142 = v50;
  float32x2_t v143 = vmul_n_f32(COERCE_FLOAT32X2_T(sub_1B652C1C8((uint64_t)v26, v51, v52, v53, v54, v55, v56, v57)), v139);
  float v65 = v34 + (float)(v139 * sub_1B652AE6C((uint64_t)v26, v58, v59, v60, v61, v62, v63, v64));
  float v144 = v65;
  float v73 = (float)(sub_1B652AF10((uint64_t)v26, v66, v67, v68, v69, v70, v71, v72) / 180.0) * 3.14159265 * v139;
  float v145 = v73;
  float32x2_t v146 = vmul_n_f32(COERCE_FLOAT32X2_T(sub_1B652C26C((uint64_t)v26, v74, v75, v76, v77, v78, v79, v80)), v139);
  __n128 v147 = sub_1B652B314(v26, v81, v82, v83, v84, v85, v86, v87);
  __n128 v148 = sub_1B652C310(v26, v88, v89, v90, v91, v92, v93, v94);
  __n128 v149 = sub_1B652B458(v26, v95, v96, v97, v98, v99, v100, v101);
  double v150 = sub_1B652C3B0((uint64_t)v26, v102, v103, v104, v105, v106, v107, v108);
  float v151 = sub_1B652A3C0((uint64_t)v26, v109, v110, v111, v112, v113, v114, v115);
  float v152 = sub_1B652A510((uint64_t)v26, v116, v117, v118, v119, v120, v121, v122);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 472));
  id v124 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 480));
  objc_msgSend_setBytes_length_atIndex_(v10, v125, (uint64_t)&v139, 112, 0);
  objc_msgSend_setTexture_atIndex_(v10, v126, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v10, v127, (uint64_t)v124, 1);
  uint64_t v134 = *(void *)(a1 + 464);
  uint64_t v135 = *(void *)(v134 + 16);
  if (!v135)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v128, v129, v130, v131, v132, v133, (uint64_t)"_ptr != NULL");
    uint64_t v135 = *(void *)(v134 + 16);
  }
  uint64_t v136 = sub_1B653EFB8(v135);
  return objc_msgSend_dispatch_onTexture2D_(v10, v137, v136, (uint64_t)v124);
}

uint64_t *sub_1B64491D8(CFX::RG *a1, CFX::RG::RenderGraphContext *a2, CFX::RG::RenderGraphBuilder **a3, CFX::RG::Resource *a4)
{
  long long v8 = *((_OWORD *)a3 + 8);
  v46[6] = *((_OWORD *)a3 + 7);
  v46[7] = v8;
  long long v9 = *((_OWORD *)a3 + 10);
  v46[8] = *((_OWORD *)a3 + 9);
  v46[9] = v9;
  long long v10 = *((_OWORD *)a3 + 4);
  v46[2] = *((_OWORD *)a3 + 3);
  v46[3] = v10;
  long long v11 = *((_OWORD *)a3 + 6);
  v46[4] = *((_OWORD *)a3 + 5);
  v46[5] = v11;
  long long v12 = *((_OWORD *)a3 + 2);
  v46[0] = *((_OWORD *)a3 + 1);
  v46[1] = v12;
  CFX::RG::TextureDescriptorReference::withSampleCount(v46, 1, (uint64_t)v45);
  uint64_t v14 = (const CFX::RG::Resource *)CFX::RG::copyIfNeeded(a1, a3[23], a4, (CFX::RG::Pass *)v45, 0, v13);
  uint64_t v15 = (long long *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, v14);
  long long v16 = v15[3];
  long long v42 = v15[2];
  long long v43 = v16;
  long long v44 = v15[4];
  long long v17 = v15[1];
  long long v40 = *v15;
  long long v41 = v17;
  if (a3[22])
  {
    uint64_t v18 = (long long *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, v14);
    long long v19 = v18[4];
    long long v38 = v18[3];
    long long v39 = v19;
    long long v20 = v18[1];
    long long v37 = v18[2];
    long long v35 = *v18;
    long long v36 = v20;
    uint64_t v28 = "ChromaticTransformCompositeBloomPass";
    long long v29 = *(_OWORD *)a3;
    long long v30 = v35;
    long long v31 = v20;
    long long v32 = v37;
    long long v33 = v38;
    long long v34 = v19;
    uint64_t v21 = (uint64_t *)sub_1B64493A0((uint64_t *)a1, (uint64_t *)a1, (uint64_t)&v28);
    v21[59] = (uint64_t)v14;
    CFX::RG::Pass::readFrom(v21, v14);
    uint64_t v22 = (CFX::RG::Resource *)*((void *)a3[22] + 93);
    v21[60] = (uint64_t)v22;
    CFX::RG::Pass::readFrom(v21, v22);
    CFX::RG::Pass::dependsOn(v21, a3[22]);
  }
  else
  {
    uint64_t v21 = 0;
  }
  uint64_t v28 = "ChromaticTransformPass";
  long long v23 = *(_OWORD *)a3;
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  long long v34 = v44;
  long long v29 = v23;
  long long v30 = v40;
  uint64_t v24 = (uint64_t *)sub_1B64493F8((uint64_t *)a1, (uint64_t *)a1, (uint64_t)&v28);
  uint64_t v25 = v24;
  if (a3[22])
  {
    uint64_t v26 = (CFX::RG::Resource *)v21[61];
    v24[59] = (uint64_t)v26;
    CFX::RG::Pass::readFrom(v24, v26);
    CFX::RG::Pass::dependsOn(v25, (CFX::RG::Pass *)v21);
  }
  else
  {
    v24[59] = (uint64_t)v14;
    CFX::RG::Pass::readFrom(v24, v14);
  }
  return v25;
}

uint64_t sub_1B64493A0(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6449724(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B64493F8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6449784(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6449454(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6449490(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B64494C8(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      unint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      float32x2_t result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B64495B4(void *a1)
{
  *a1 = &unk_1F0FB5020;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6449600(void *a1)
{
  *a1 = &unk_1F0FB5020;
  CFAllocatorRef v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B644966C(void *a1)
{
  *a1 = &unk_1F0FB4370;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B64496B8(void *a1)
{
  *a1 = &unk_1F0FB4370;
  CFAllocatorRef v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6449724(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1F0u, 8u);
  return sub_1B64488C4(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6449784(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1E8u, 8u);
  return sub_1B6448C40(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64497E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v27 = a2;
  *((void *)&v27 + 1) = a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA810, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = a2;
    int v22 = __cxa_guard_acquire(&qword_1E9DDA810);
    a2 = v24;
    if (v22)
    {
      qword_1E9DDA808 = (uint64_t)sub_1B644BD78("SSR_DEPTH_BACKFACE_PASS", 0x17u);
      __cxa_guard_release(&qword_1E9DDA810);
      a2 = v24;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, qword_1E9DDA808, 0);
  *(void *)a1 = &unk_1F0FB4240;
  long long v9 = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 24);
  *(_OWORD *)(a1 + 416) = v9;
  long long v10 = *(_OWORD *)(a5 + 56);
  long long v11 = *(_OWORD *)(a5 + 72);
  long long v12 = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a5 + 88);
  *(_OWORD *)(a1 + 480) = v12;
  *(_OWORD *)(a1 + 432) = v10;
  *(_OWORD *)(a1 + 448) = v11;
  long long v13 = *(_OWORD *)(a5 + 120);
  long long v14 = *(_OWORD *)(a5 + 136);
  long long v15 = *(_OWORD *)(a5 + 168);
  *(_OWORD *)(a1 + 528) = *(_OWORD *)(a5 + 152);
  *(_OWORD *)(a1 + 544) = v15;
  *(_OWORD *)(a1 + 496) = v13;
  *(_OWORD *)(a1 + 512) = v14;
  *(void *)(a1 + 560) = 0;
  *(void *)&long long v28 = *(void *)(a1 + 368);
  LOBYTE(v32) = 0;
  char v33 = 0;
  uint64_t v30 = 0;
  long long v29 = 0uLL;
  long long v34 = xmmword_1B6E4FC80;
  char v35 = *(unsigned char *)(a1 + 376);
  char v36 = 2;
  uint64_t v37 = 32;
  int v38 = 1;
  __int16 v39 = 1;
  *(void *)(a1 + 384) = sub_1B63F9384(v27, *((uint64_t *)&v27 + 1), (uint64_t *)&v27, (uint64_t *)&v28, &v29);
  long long v16 = v27;
  uint64_t v17 = *(void *)(a1 + 368);
  *(void *)&long long v29 = 0;
  WORD4(v29) = 0;
  BYTE10(v29) = 0;
  uint64_t v30 = 8;
  __int16 v31 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA810, memory_order_acquire) & 1) == 0)
  {
    long long v25 = v16;
    int v23 = __cxa_guard_acquire(&qword_1E9DDA810);
    long long v16 = v25;
    if (v23)
    {
      qword_1E9DDA808 = (uint64_t)sub_1B644BD78("SSR_DEPTH_BACKFACE_PASS", 0x17u);
      __cxa_guard_release(&qword_1E9DDA810);
      long long v16 = v25;
    }
  }
  uint64_t v32 = qword_1E9DDA808;
  long long v28 = v16;
  uint64_t v18 = sub_1B63C8330(&v28, 0x40u, 8u);
  sub_1B6460520(v18, v17, (uint64_t)&v29, *(void *)(a1 + 384));
  *(void *)(a1 + 392) = v19;
  CFX::RG::TextureDescriptorReference::withSampleCount((_OWORD *)(a5 + 24), 1, (uint64_t)v26);
  long long v20 = sub_1B63CFDE4(a4, (uint64_t)"BACKFACE_DEPTH", v26);
  *(void *)(a1 + 560) = v20;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v20, 0x200000002, -1);
  return a1;
}

void sub_1B6449A68(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6449A84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B65A8594(*(__n128 **)(a1 + 384), (const char *)a2, a3, a4);
  sub_1B65A88F8(*(void *)(a1 + 384), v6, v7, v8, v9, v10, v11, v12);
  sub_1B65A8D10(*(void *)(a1 + 384));
  long long v14 = *(uint64_t **)(a1 + 384);
  long long v15 = *(const char **)a2;
  uint64_t v16 = *(void *)(a2 + 8);

  sub_1B65A8F34(v14, v15, v16, v13);
}

void sub_1B6449AD8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B6449AE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  objc_msgSend_setCullMode_(*(void **)(v15 + 16), v16, 1, v17);
  objc_msgSend_setLockCullMode_(*(void **)(v15 + 16), v18, 1, v19);
  uint64_t v20 = *(void *)(a1 + 392);

  sub_1B6460C38(v20, a2, a3, 0);
}

uint64_t sub_1B6449B58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA820, memory_order_acquire) & 1) == 0)
  {
    uint64_t v20 = a2;
    uint64_t v21 = a3;
    int v19 = __cxa_guard_acquire(&qword_1E9DDA820);
    a2 = v20;
    a3 = v21;
    if (v19)
    {
      qword_1E9DDA818 = (uint64_t)sub_1B644BD78("SSR_DOWNSAMPLE_PASS", 0x13u);
      __cxa_guard_release(&qword_1E9DDA820);
      a2 = v20;
      a3 = v21;
    }
  }
  sub_1B653860C(a1, a2, a3, a5, qword_1E9DDA818, 0);
  *(void *)a1 = &unk_1F0FB3C58;
  memcpy((void *)(a1 + 376), a5 + 2, 0x150uLL);
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(void *)(a1 + 752) = 0;
  long long v36 = *(_OWORD *)(a1 + 384);
  uint64_t v8 = *(void *)(a1 + 400);
  long long v40 = *(_OWORD *)(a1 + 417);
  *(_OWORD *)long long v41 = *(_OWORD *)(a1 + 433);
  long long v9 = *(_OWORD *)(a1 + 465);
  long long v10 = *(_OWORD *)(a1 + 481);
  long long v11 = *(_OWORD *)(a1 + 497);
  uint64_t v48 = *(void *)(a1 + 532);
  uint64_t v12 = *(void *)(a1 + 448);
  *(_OWORD *)&v46[15] = *(_OWORD *)(a1 + 512);
  *(_OWORD *)uint64_t v46 = v11;
  long long v45 = v10;
  long long v44 = v9;
  int v49 = *(_DWORD *)(a1 + 540);
  *(float *)&long long v9 = 1.0 / (float)*(unsigned int *)(a1 + 704);
  uint64_t v37 = v8;
  uint64_t v38 = 115;
  char v39 = 1;
  *(void *)&v41[15] = v12;
  uint64_t v42 = 3;
  char v43 = 1;
  int v47 = v9;
  uint64_t v13 = sub_1B63CFDE4(a4, (uint64_t)"COLOR_DOWNSAMPLE", &v36);
  *(void *)(a1 + 744) = v13;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v13);
  *(void *)&v27[15] = *(void *)(a1 + 608);
  long long v22 = *(_OWORD *)(a1 + 544);
  long long v26 = *(_OWORD *)(a1 + 577);
  long long v14 = *(_OWORD *)(a1 + 625);
  uint64_t v15 = *(void *)(a1 + 560);
  *(_OWORD *)long long v27 = *(_OWORD *)(a1 + 593);
  *(_OWORD *)&v32[15] = *(_OWORD *)(a1 + 672);
  long long v30 = v14;
  *(_OWORD *)uint64_t v32 = *(_OWORD *)(a1 + 657);
  long long v31 = *(_OWORD *)(a1 + 641);
  uint64_t v34 = *(void *)(a1 + 692);
  int v35 = *(_DWORD *)(a1 + 700);
  float v16 = 1.0 / (float)*(unsigned int *)(a1 + 704);
  uint64_t v23 = v15;
  uint64_t v24 = 65;
  char v25 = 1;
  uint64_t v28 = 3;
  char v29 = 1;
  float v33 = v16;
  uint64_t v17 = sub_1B63CFDE4(a4, (uint64_t)"DEPTH_DOWNSAMPLE", &v22);
  *(void *)(a1 + 752) = v17;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v17);
  return a1;
}

void sub_1B6449DAC(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6449DC4(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned int *)(a1 + 704));
  uint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  uint64_t v7 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
  *(void *)(a1 + 712) = v7;
  if (!v7)
  {
    *(void *)(a1 + 712) = sub_1B6449EE4(*(CFX::CrossFrameResourceManager **)(a2 + 32), v6);
    uint64_t v15 = (void *)sub_1B6445900(*(void *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    int v19 = objc_msgSend_resourceManager(v15, v16, v17, v18);
    id v26 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v26, v20, a1 + 704, 29, @"SSRDownSample");
    uint64_t v21 = *(void *)(a1 + 712);
    uint64_t v23 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_(v19, v22, @"vfx_ssr_downsample_depth", (uint64_t)v26);
    uint64_t v24 = *(void **)(v21 + 16);
    if (v24 != (void *)v23)
    {
      uint64_t v25 = v23;
      if (v24) {

      }
      *(void *)(v21 + 16) = v25;
    }
  }
}

uint64_t sub_1B6449EE4(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B6449F6C(uint64_t a1, uint64_t a2, void **a3)
{
  unint64_t v5 = *a3;
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 720));
  id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 728));
  id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 736));
  id v9 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 744));
  id v10 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 752));
  objc_msgSend_setTexture_atIndex_(v5, v11, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v5, v12, (uint64_t)v7, 1);
  objc_msgSend_setTexture_atIndex_(v5, v13, (uint64_t)v8, 2);
  objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)v9, 3);
  objc_msgSend_setTexture_atIndex_(v5, v15, (uint64_t)v10, 4);
  uint64_t v23 = *(const void **)(a1 + 376);
  if (!v23) {
    uint64_t v23 = sub_1B6446564(*(uint64_t **)(a1 + 368), v16, v17, v18, v19, v20, v21, v22);
  }
  sub_1B63E0460((uint64_t)v23, (uint64_t)v63, v17, v18, v19, v20, v21, v22);
  v24.f32[0] = v65 * v64;
  __asm { FMOV            V3.2S, #1.0 }
  _D3.f32[0] = v65 - v64;
  v24.f32[1] = v65;
  float32x2_t v62 = vdiv_f32(_D3, v24);
  objc_msgSend_setBytes_length_atIndex_(v5, v30, (uint64_t)&v62, 8, 0);
  uint64_t v37 = *(void *)(a1 + 712);
  uint64_t v38 = *(void *)(v37 + 16);
  if (!v38)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v31, v32, v33, v34, v35, v36, (uint64_t)"_ptr != NULL");
    uint64_t v38 = *(void *)(v37 + 16);
  }
  char v39 = (void *)sub_1B653EFB8(v38);
  unint64_t v43 = objc_msgSend_threadExecutionWidth(v39, v40, v41, v42);
  unint64_t v47 = objc_msgSend_maxTotalThreadsPerThreadgroup(v39, v44, v45, v46) / v43;
  uint64_t v51 = objc_msgSend_width(v9, v48, v49, v50);
  uint64_t v55 = objc_msgSend_height(v9, v52, v53, v54);
  objc_msgSend_setComputePipelineState_(v5, v56, (uint64_t)v39, v57);
  v61[0] = v51;
  v61[1] = v55;
  v61[2] = 1;
  v60[0] = v43;
  v60[1] = v47;
  float32x4_t v60[2] = 1;
  return objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v5, v58, (uint64_t)v61, (uint64_t)v60);
}

uint64_t sub_1B644A130(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  id v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA830, memory_order_acquire) & 1) == 0)
  {
    uint64_t v29 = a2;
    uint64_t v30 = a3;
    int v28 = __cxa_guard_acquire(&qword_1E9DDA830);
    id v8 = &unk_1E9DDA000;
    a2 = v29;
    a3 = v30;
    if (v28)
    {
      byte_1E9DDA828 = 1;
      __cxa_guard_release(&qword_1E9DDA830);
      id v8 = (unsigned char *)&unk_1E9DDA000;
      a2 = v29;
      a3 = v30;
    }
  }
  if (v8[2088]) {
    uint64_t v9 = 0x1F324A86E1EC8E1BLL;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v9, 0);
  *(void *)a1 = &unk_1F0FB39D8;
  long long v10 = *(_OWORD *)(a5 + 24);
  long long v11 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 416) = v11;
  *(_OWORD *)(a1 + 384) = v10;
  long long v12 = *(_OWORD *)(a5 + 72);
  long long v13 = *(_OWORD *)(a5 + 88);
  long long v14 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 480) = v14;
  *(_OWORD *)(a1 + 432) = v12;
  *(_OWORD *)(a1 + 448) = v13;
  long long v15 = *(_OWORD *)(a5 + 136);
  long long v16 = *(_OWORD *)(a5 + 152);
  long long v17 = *(_OWORD *)(a5 + 184);
  *(_OWORD *)(a1 + 528) = *(_OWORD *)(a5 + 168);
  *(_OWORD *)(a1 + 544) = v17;
  *(_OWORD *)(a1 + 496) = v15;
  *(_OWORD *)(a1 + 512) = v16;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  long long v65 = *(_OWORD *)(a1 + 392);
  uint64_t v66 = *(void *)(a1 + 408);
  char v18 = *(unsigned char *)(a1 + 424);
  long long v19 = *(_OWORD *)(a1 + 473);
  long long v20 = *(_OWORD *)(a1 + 505);
  long long v63 = *(_OWORD *)(a1 + 489);
  v64[0] = v20;
  *(_OWORD *)((char *)v64 + 15) = *(_OWORD *)(a1 + 520);
  long long v21 = *(_OWORD *)(a1 + 441);
  long long v59 = *(_OWORD *)(a1 + 425);
  long long v60 = v21;
  long long v61 = *(_OWORD *)(a1 + 457);
  long long v62 = v19;
  int v58 = *(_DWORD *)(a1 + 548);
  uint64_t v57 = *(void *)(a1 + 540);
  float v22 = 1.0 / (float)*(unsigned int *)(a1 + 552);
  uint64_t v24 = *(void *)(a1 + 408);
  uint64_t v23 = *(void *)(a1 + 416);
  long long v44 = *(_OWORD *)(a1 + 392);
  uint64_t v45 = v24;
  uint64_t v46 = v23;
  char v47 = v18;
  long long v48 = *(_OWORD *)(a1 + 425);
  long long v49 = *(_OWORD *)(a1 + 441);
  *(_OWORD *)&v53[15] = *(_OWORD *)(a1 + 520);
  *(_OWORD *)uint64_t v53 = *(_OWORD *)(a1 + 505);
  long long v52 = *(_OWORD *)(a1 + 489);
  long long v51 = *(_OWORD *)(a1 + 473);
  long long v50 = *(_OWORD *)(a1 + 457);
  float v54 = v22;
  uint64_t v55 = *(void *)(a1 + 540);
  int v56 = *(_DWORD *)(a1 + 548);
  uint64_t v25 = sub_1B63CFDE4(a4, (uint64_t)"SSR", &v44);
  *(void *)(a1 + 592) = v25;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v25, 0x100000000, 0);
  long long v31 = v65;
  long long v38 = v62;
  long long v39 = v63;
  *(_OWORD *)long long v40 = v64[0];
  *(_OWORD *)&v40[15] = *(_OWORD *)((char *)v64 + 15);
  long long v35 = v59;
  long long v36 = v60;
  uint64_t v32 = v66;
  uint64_t v33 = 115;
  char v34 = 1;
  long long v37 = v61;
  float v41 = v22;
  uint64_t v42 = v57;
  int v43 = v58;
  id v26 = sub_1B63CFDE4(a4, (uint64_t)"LOBE_FOOTPRINT", &v31);
  *(void *)(a1 + 600) = v26;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v26, 0x100000000, 1);
  return a1;
}

void sub_1B644A420(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void *sub_1B644A434(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  long long v12 = (void *)sub_1B6445900(*(void *)(a1 + 368), v5, v6, v7, v8, v9, v10, v11);
  uint64_t v20 = sub_1B644558C(*(void *)(a1 + 368), v13, v14, v15, v16, v17, v18, v19);
  uint64_t v28 = *(void *)(CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 592))+ 16);
  uint64_t v29 = *(unsigned int *)(a1 + 552);
  int v62 = *(_DWORD *)(a1 + 552);
  if (v20) {
    BOOL v30 = sub_1B64B2AD0(v20, v21, v22, v23, v24, v25, v26, v27) > 0.0;
  }
  else {
    BOOL v30 = 0;
  }
  BOOL v61 = v30;
  unint64_t v31 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v4)));
  unint64_t v32 = 0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47));
  unint64_t v33 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v32 ^ ((0x9DDFEA08EB382D69 * (v32 ^ v29)) >> 47) ^ (0x9DDFEA08EB382D69 * (v32 ^ v29)))) ^ ((0x9DDFEA08EB382D69 * (v32 ^ ((0x9DDFEA08EB382D69 * (v32 ^ v29)) >> 47) ^ (0x9DDFEA08EB382D69 * (v32 ^ v29)))) >> 47));
  uint64_t v34 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v33 ^ ((0x9DDFEA08EB382D69 * (v33 ^ v30)) >> 47) ^ (0x9DDFEA08EB382D69 * (v33 ^ v30)))) ^ ((0x9DDFEA08EB382D69 * (v33 ^ ((0x9DDFEA08EB382D69 * (v33 ^ v30)) >> 47) ^ (0x9DDFEA08EB382D69 * (v33 ^ v30)))) >> 47));
  uint64_t v35 = CFX::CrossFrameResourceManager::get(a2[4], v34);
  *(void *)(a1 + 560) = v35;
  if (!v35)
  {
    *(void *)(a1 + 560) = sub_1B644A648(a2[4], v34);
    long long v39 = objc_msgSend_resourceManager(v12, v36, v37, v38);
    id v40 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v40, v41, (uint64_t)&v62, 29, @"SSRDownSample");
    objc_msgSend_setConstantValue_type_withName_(v40, v42, (uint64_t)&v61, 53, @"SSREnableFog");
    uint64_t v43 = *(void *)(a1 + 560);
    long long v44 = (void *)sub_1B653EFAC((uint64_t)v39);
    *((void *)&v55 + 1) = objc_msgSend_frameworkLibrary(v44, v45, v46, v47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0);
    uint64_t v56 = v28;
    uint64_t v57 = 115;
    *((void *)&v58 + 1) = v40;
    *((void *)&v59 + 1) = @"vfx_ssr_raytrace_vert";
    *(void *)&long long v60 = @"vfx_ssr_raytrace_frag";
    uint64_t v50 = objc_msgSend_newRenderPipelineStateWithDesc_(v39, v48, (uint64_t)&v54, v49);
    long long v51 = *(void **)(v43 + 16);
    if (v51 != (void *)v50)
    {
      uint64_t v52 = v50;
      if (v51) {

      }
      *(void *)(v43 + 16) = v52;
    }
  }
  float32x2_t result = sub_1B63BE410(v12, a2[4]);
  *(void *)(*(void *)(a1 + 560) + 24) = result;
  return result;
}

uint64_t sub_1B644A648(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

long long *sub_1B644A6D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 368), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v14 = objc_msgSend_renderEncoder(v10, v11, v12, v13);
  uint64_t v29 = sub_1B644558C(*(void *)(a1 + 368), v15, v16, v17, v18, v19, v20, v21);
  uint64_t v30 = *(void *)(a1 + 384);
  if (v30
    || (float32x2_t result = (long long *)sub_1B6446564(*(uint64_t **)(a1 + 368), v22, v23, v24, v25, v26, v27, v28),
        (uint64_t v30 = (uint64_t)result) != 0))
  {
    float32x2_t result = (long long *)sub_1B64A3B48(v30, v22, v23, v24, v25, v26, v27, v28);
    if (result)
    {
      sub_1B63E0460(v30, (uint64_t)v131, v32, v33, v34, v35, v36, v37);
      __n128 v130 = sub_1B64471F4(*(void *)(a1 + 368), 0, v38, v39, v40, v41, v42, v43);
      uint64_t v50 = sub_1B649CD50(v131, (uint64_t)&v130, v44, v45, v46, v47, v48, v49);
      simd_float4 v51 = *((simd_float4 *)v50 + 2);
      simd_float4 v52 = *((simd_float4 *)v50 + 3);
      simd_float4 v120 = *((simd_float4 *)v50 + 1);
      simd_float4 v121 = *(simd_float4 *)v50;
      v123[0] = *(_OWORD *)v50;
      v123[1] = v120;
      simd_float4 v118 = v52;
      simd_float4 v119 = v51;
      v123[2] = v51;
      v123[3] = v52;
      uint64_t v124 = v132;
      int v127 = sub_1B64B2E3C(v29, v53, v54, v55, v56, v57, v58, v59);
      float v126 = fmaxf(sub_1B64B2ED8(v29, v60, v61, v62, v63, v64, v65, v66), 0.0);
      float v125 = fmaxf(sub_1B64B2F7C(v29, v67, v68, v69, v70, v71, v72, v73), 1.0);
      sub_1B64462BC(*(void *)(a1 + 368), v74, v75, v76, v77, v78, v79, v80);
      sub_1B64B2CB8(v29, v81, v82, v83, v84, v85, v86, v87);
      long long v128 = v88;
      float32x2_t result = (long long *)sub_1B64B2C6C(v29, v89, v90, v91, v92, v93, v94, v95);
      long long v129 = *result;
      if (v127)
      {
        uint64_t v103 = *(void *)(a1 + 560);
        uint64_t v104 = *(void **)(v103 + 16);
        if (!v104)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v97, v98, v99, v100, v101, v102, (uint64_t)"_ptr != NULL");
          uint64_t v104 = *(void **)(v103 + 16);
        }
        uint64_t v105 = objc_msgSend_state(v104, v96, v97, v98);
        objc_msgSend_setRenderPipelineState_(*(void **)(v14 + 16), v106, v105, v107);
        v136.columns[1] = v120;
        v136.columns[0] = v121;
        v136.columns[3] = v118;
        v136.columns[2] = v119;
        simd_float4x4 v122 = __invert_f4(v136);
        uint64_t v133 = 0;
        uint64_t v134 = 0;
        uint64_t v135 = 0;
        sub_1B649F334(*(void *)(v14 + 24), &v122, 0x40uLL, &v133);
        objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v14 + 16), v108, v134, v135, 0);
        id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568));
        id v110 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 576));
        id v111 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 584));
        sub_1B63C6ED0(v14, Texture, 0, v112);
        sub_1B63C6ED0(v14, v111, 1, v113);
        sub_1B63C6ED0(v14, v110, 2, v114);
        sub_1B63C6ED0(v14, *(void **)(*(void *)(a1 + 560) + 24), 3, v115);
        uint64_t v133 = 0;
        uint64_t v134 = 0;
        uint64_t v135 = 0;
        sub_1B649F334(*(void *)(v14 + 24), v123, 0x80uLL, &v133);
        objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v14 + 16), v116, v134, v135, 0);
        return (long long *)sub_1B63F0064(v14, v117);
      }
    }
  }
  return result;
}

uint64_t sub_1B644A91C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA840, memory_order_acquire) & 1) == 0)
  {
    uint64_t v27 = a2;
    uint64_t v28 = a3;
    int v26 = __cxa_guard_acquire(&qword_1E9DDA840);
    uint64_t v8 = (void *)&unk_1E9DDA000;
    a2 = v27;
    a3 = v28;
    if (v26)
    {
      qword_1E9DDA838 = (uint64_t)sub_1B644BD78("SSR_BLUR_PASS", 0xDu);
      __cxa_guard_release(&qword_1E9DDA840);
      uint64_t v8 = (void *)&unk_1E9DDA000;
      a2 = v27;
      a3 = v28;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8[263], 0);
  *(void *)a1 = &unk_1F0FB3280;
  long long v9 = *(_OWORD *)(a5 + 24);
  long long v10 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 416) = v10;
  *(_OWORD *)(a1 + 384) = v9;
  long long v11 = *(_OWORD *)(a5 + 72);
  long long v12 = *(_OWORD *)(a5 + 88);
  long long v13 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 480) = v13;
  *(_OWORD *)(a1 + 432) = v11;
  *(_OWORD *)(a1 + 448) = v12;
  long long v14 = *(_OWORD *)(a5 + 136);
  long long v15 = *(_OWORD *)(a5 + 152);
  long long v16 = *(_OWORD *)(a5 + 168);
  *(void *)(a1 + 544) = *(void *)(a5 + 184);
  *(_OWORD *)(a1 + 512) = v15;
  *(_OWORD *)(a1 + 528) = v16;
  *(_OWORD *)(a1 + 496) = v14;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  long long v17 = *(_OWORD *)(a1 + 496);
  long long v42 = *(_OWORD *)(a1 + 480);
  long long v43 = v17;
  long long v44 = *(_OWORD *)(a1 + 512);
  long long v18 = *(_OWORD *)(a1 + 432);
  long long v38 = *(_OWORD *)(a1 + 416);
  long long v39 = v18;
  long long v19 = *(_OWORD *)(a1 + 464);
  long long v40 = *(_OWORD *)(a1 + 448);
  long long v41 = v19;
  long long v20 = *(_OWORD *)(a1 + 400);
  long long v36 = *(_OWORD *)(a1 + 384);
  long long v37 = v20;
  uint64_t v34 = *(void *)(a1 + 532);
  int v35 = *(_DWORD *)(a1 + 540);
  unsigned int v21 = *(_DWORD *)(a1 + 544);
  long long v33 = *(_OWORD *)(a1 + 8);
  uint64_t v22 = (char *)sub_1B63C8330(&v33, 0x12u, 1u);
  strlcpy(v22, "SSR BLUR OUTPUT ", 0x11uLL);
  if (*(unsigned char *)(a1 + 548)) {
    char v23 = 89;
  }
  else {
    char v23 = 88;
  }
  v22[16] = v23;
  v29[6] = v42;
  v29[7] = v43;
  v29[8] = v44;
  v29[0] = v36;
  v29[1] = v37;
  v29[2] = v38;
  v29[3] = v39;
  _OWORD v29[4] = v40;
  v29[5] = v41;
  float v30 = 1.0 / (float)v21;
  uint64_t v31 = v34;
  int v32 = v35;
  uint64_t v24 = sub_1B63CFDE4(a4, (uint64_t)v22, v29);
  *(void *)(a1 + 576) = v24;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v24, 0x100000000, 0);
  return a1;
}

void sub_1B644AB64(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B644AB7C(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = *(void *)(CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 576))+ 16);
  unint64_t v6 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v4)));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ *(unsigned __int8 *)(a1 + 548));
  uint64_t v9 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  uint64_t v10 = CFX::CrossFrameResourceManager::get(a2[4], v9);
  *(void *)(a1 + 552) = v10;
  if (!v10)
  {
    *(void *)(a1 + 552) = sub_1B644ACF8(a2[4], v9);
    long long v18 = (void *)sub_1B6445900(*(void *)(a1 + 368), v11, v12, v13, v14, v15, v16, v17);
    uint64_t v22 = objc_msgSend_resourceManager(v18, v19, v20, v21);
    char v23 = (void *)sub_1B653EFAC((uint64_t)v22);
    uint64_t v27 = objc_msgSend_frameworkLibrary(v23, v24, v25, v26);
    int v30 = *(unsigned __int8 *)(a1 + 548);
    uint64_t v31 = *(void *)(a1 + 552);
    memset(v36, 0, 32);
    int v32 = v30 ? @"vfx_ssr_blur_y" : @"vfx_ssr_blur_x";
    memset(&v36[2], 0, 64);
    uint64_t v37 = 0;
    uint64_t v38 = v27;
    uint64_t v39 = v5;
    long long v49 = 0uLL;
    long long v50 = 0uLL;
    long long v40 = 0uLL;
    long long v41 = 0uLL;
    long long v42 = 0uLL;
    long long v43 = 0uLL;
    long long v44 = 0uLL;
    long long v45 = 0uLL;
    long long v46 = 0uLL;
    long long v47 = 0uLL;
    long long v48 = 0uLL;
    simd_float4 v51 = @"vfx_draw_fullscreen_triangle_vertex";
    simd_float4 v52 = v32;
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    uint64_t v33 = objc_msgSend_newRenderPipelineStateWithDesc_(v22, v28, (uint64_t)v36, v29);
    uint64_t v34 = *(void **)(v31 + 16);
    if (v34 != (void *)v33)
    {
      uint64_t v35 = v33;
      if (v34) {

      }
      *(void *)(v31 + 16) = v35;
    }
  }
}

uint64_t sub_1B644ACF8(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B644AD80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 368), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v21 = objc_msgSend_renderEncoder(v10, v11, v12, v13);
  uint64_t v22 = *(void *)(a1 + 552);
  char v23 = *(void **)(v22 + 16);
  if (!v23)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
    char v23 = *(void **)(v22 + 16);
  }
  uint64_t v24 = objc_msgSend_state(v23, v14, v15, v16);
  objc_msgSend_setRenderPipelineState_(*(void **)(v21 + 16), v25, v24, v26);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  id v28 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568));
  sub_1B63C6ED0(v21, Texture, 0, v29);
  sub_1B63C6ED0(v21, v28, 1, v30);

  return sub_1B63F0064(v21, v31);
}

double sub_1B644AE54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA850, memory_order_acquire) & 1) == 0)
  {
    uint64_t v19 = a2;
    uint64_t v20 = a3;
    int v18 = __cxa_guard_acquire(&qword_1E9DDA850);
    unint64_t v7 = &unk_1E9DDA000;
    a2 = v19;
    a3 = v20;
    if (v18)
    {
      byte_1E9DDA848 = 1;
      __cxa_guard_release(&qword_1E9DDA850);
      unint64_t v7 = (unsigned char *)&unk_1E9DDA000;
      a2 = v19;
      a3 = v20;
    }
  }
  if (v7[2120]) {
    uint64_t v8 = 0x9E9C786127469E8FLL;
  }
  else {
    uint64_t v8 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8, 0);
  *(void *)a1 = &unk_1F0FB3A98;
  long long v9 = *(_OWORD *)(a5 + 24);
  long long v10 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 416) = v10;
  *(_OWORD *)(a1 + 384) = v9;
  long long v11 = *(_OWORD *)(a5 + 72);
  long long v12 = *(_OWORD *)(a5 + 88);
  long long v13 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 480) = v13;
  *(_OWORD *)(a1 + 432) = v11;
  *(_OWORD *)(a1 + 448) = v12;
  long long v14 = *(_OWORD *)(a5 + 136);
  long long v15 = *(_OWORD *)(a5 + 152);
  long long v16 = *(_OWORD *)(a5 + 168);
  *(void *)(a1 + 544) = *(void *)(a5 + 184);
  *(_OWORD *)(a1 + 512) = v15;
  *(_OWORD *)(a1 + 528) = v16;
  *(_OWORD *)(a1 + 496) = v14;
  double result = 0.0;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  return result;
}

void sub_1B644AF70(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = *(void *)(CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 560))+ 16);
  uint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v4)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v4)))) >> 47));
  uint64_t v7 = CFX::CrossFrameResourceManager::get(a2[4], v6);
  *(void *)(a1 + 552) = v7;
  if (!v7)
  {
    *(void *)(a1 + 552) = sub_1B644B0FC(a2[4], v6);
    long long v15 = (void *)sub_1B6445900(*(void *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    uint64_t v19 = objc_msgSend_resourceManager(v15, v16, v17, v18);
    id v20 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v20, v21, a1 + 544, 29, @"SSRDownSample");
    uint64_t v22 = (void *)sub_1B653EFAC((uint64_t)v19);
    uint64_t v26 = objc_msgSend_frameworkLibrary(v22, v23, v24, v25);
    uint64_t v27 = *(void *)(a1 + 552);
    memset(v33, 0, sizeof(v33));
    uint64_t v34 = 0;
    uint64_t v35 = v26;
    uint64_t v36 = v5;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    uint64_t v41 = 0;
    char v42 = 1;
    memset(v47, 0, sizeof(v47));
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    id v48 = v20;
    uint64_t v49 = 0;
    long long v50 = @"vfx_draw_fullscreen_triangle_vertex";
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    simd_float4 v51 = @"vfx_ssr_composite_frag";
    uint64_t v30 = objc_msgSend_newRenderPipelineStateWithDesc_(v19, v28, (uint64_t)v33, v29);
    uint64_t v31 = *(void **)(v27 + 16);
    if (v31 != (void *)v30)
    {
      uint64_t v32 = v30;
      if (v31) {

      }
      *(void *)(v27 + 16) = v32;
    }
  }
}

uint64_t sub_1B644B0FC(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B644B184(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 368), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v21 = objc_msgSend_renderEncoder(v10, v11, v12, v13);
  uint64_t v22 = *(void *)(a1 + 552);
  char v23 = *(void **)(v22 + 16);
  if (!v23)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
    char v23 = *(void **)(v22 + 16);
  }
  uint64_t v24 = objc_msgSend_state(v23, v14, v15, v16);
  objc_msgSend_setRenderPipelineState_(*(void **)(v21 + 16), v25, v24, v26);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568));
  id v28 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 576));
  id v29 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 584));
  id v30 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 592));
  sub_1B63C6ED0(v21, Texture, 0, v31);
  sub_1B63C6ED0(v21, v28, 1, v32);
  sub_1B63C6ED0(v21, v29, 2, v33);
  sub_1B63C6ED0(v21, v30, 3, v34);

  return sub_1B63F0064(v21, v35);
}

uint64_t *sub_1B644B2A0(uint64_t *a1, uint64_t *a2, CFX::RG::Pass *a3)
{
  uint64_t v6 = (long long *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[2]);
  long long v7 = v6[1];
  long long v212 = *v6;
  long long v213 = v7;
  long long v8 = v6[5];
  long long v10 = v6[2];
  long long v9 = v6[3];
  long long v216 = v6[4];
  long long v217 = v8;
  long long v214 = v10;
  long long v215 = v9;
  long long v11 = v6[9];
  long long v13 = v6[6];
  long long v12 = v6[7];
  long long v220 = v6[8];
  long long v221 = v11;
  long long v218 = v13;
  long long v219 = v12;
  CFX::RG::TextureDescriptorReference::withSampleCount(&v212, 1, (uint64_t)&v202);
  uint64_t v14 = (long long *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[3]);
  long long v15 = v14[1];
  long long v192 = *v14;
  long long v193 = v15;
  long long v16 = v14[5];
  long long v18 = v14[2];
  long long v17 = v14[3];
  long long v196 = v14[4];
  long long v197 = v16;
  long long v194 = v18;
  long long v195 = v17;
  long long v19 = v14[9];
  long long v21 = v14[6];
  long long v20 = v14[7];
  long long v200 = v14[8];
  long long v201 = v19;
  long long v198 = v21;
  long long v199 = v20;
  CFX::RG::TextureDescriptorReference::withSampleCount(&v192, 1, (uint64_t)&v182);
  uint64_t v22 = (_OWORD *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[4]);
  long long v23 = v22[1];
  v181[0] = *v22;
  v181[1] = v23;
  long long v24 = v22[5];
  long long v26 = v22[2];
  long long v25 = v22[3];
  v181[4] = v22[4];
  v181[5] = v24;
  v181[2] = v26;
  v181[3] = v25;
  long long v27 = v22[9];
  long long v29 = v22[6];
  long long v28 = v22[7];
  v181[8] = v22[8];
  v181[9] = v27;
  v181[6] = v29;
  v181[7] = v28;
  CFX::RG::TextureDescriptorReference::withSampleCount(v181, 1, (uint64_t)v180);
  long long v176 = v198;
  long long v177 = v199;
  long long v178 = v200;
  long long v179 = v201;
  long long v172 = v194;
  long long v173 = v195;
  long long v174 = v196;
  long long v175 = v197;
  long long v170 = v192;
  uint64_t v30 = *a2;
  v168[0] = "SSR backface depth";
  v168[1] = v30;
  __int16 v169 = 0;
  long long v171 = v193;
  uint64_t v67 = (CFX::RG::Pass *)sub_1B644BA94(a1, a1, (uint64_t)v168);
  v167[6] = v208;
  v167[7] = v209;
  v167[8] = v210;
  v167[9] = v211;
  v167[2] = v204;
  v167[3] = v205;
  v167[4] = v206;
  v167[5] = v207;
  v167[0] = v202;
  v167[1] = v203;
  uint64_t v31 = sub_1B63CFDE4(a1, (uint64_t)"SSR COLOR COPY", v167);
  *(void *)&long long v164 = a2[2];
  DWORD2(v164) = 0;
  uint64_t v68 = v31;
  float v165 = v31;
  uint64_t v166 = 0x100000000;
  CopyPass = (uint64_t *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy downsample color input", &v164);
  uint64_t v33 = (CFX::RG::Pass *)CopyPass;
  if (a3) {
    CFX::RG::Pass::dependsOn(CopyPass, a3);
  }
  v163[6] = v188;
  v163[7] = v189;
  v163[8] = v190;
  v163[9] = v191;
  v163[2] = v184;
  v163[3] = v185;
  v163[4] = v186;
  v163[5] = v187;
  v163[0] = v182;
  v163[1] = v183;
  uint64_t v34 = sub_1B63CFDE4(a1, (uint64_t)"DOWNSAMPLE DEPTH INPUT", v163);
  *(void *)&long long v160 = a2[3];
  DWORD2(v160) = 0;
  float32x4_t v161 = v34;
  uint64_t v162 = 0x100000000;
  uint64_t v35 = (uint64_t *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy downsample depth input", &v160);
  uint64_t v36 = (CFX::RG::Pass *)v35;
  if (a3) {
    CFX::RG::Pass::dependsOn(v35, a3);
  }
  long long v138 = *(_OWORD *)a2;
  long long v145 = v208;
  long long v146 = v209;
  long long v147 = v210;
  long long v148 = v211;
  long long v141 = v204;
  long long v142 = v205;
  long long v143 = v206;
  long long v144 = v207;
  long long v139 = v202;
  long long v140 = v203;
  long long v155 = v188;
  long long v156 = v189;
  long long v157 = v190;
  long long v158 = v191;
  long long v154 = v187;
  long long v151 = v184;
  long long v152 = v185;
  long long v153 = v186;
  long long v149 = v182;
  float32x4_t v137 = "SSR downsample";
  long long v150 = v183;
  int v159 = *((_DWORD *)a2 + 14);
  long long v37 = (uint64_t *)sub_1B644BAEC(a1, a1, (uint64_t *)&v137);
  v37[90] = (uint64_t)v68;
  CFX::RG::Pass::readFrom(v37, v68);
  v37[91] = (uint64_t)v34;
  CFX::RG::Pass::readFrom(v37, v34);
  long long v38 = (CFX::RG::Resource *)*((void *)v67 + 70);
  v37[92] = (uint64_t)v38;
  CFX::RG::Pass::readFrom(v37, v38);
  CFX::RG::Pass::dependsOn(v37, v67);
  CFX::RG::Pass::dependsOn(v37, v33);
  CFX::RG::Pass::dependsOn(v37, v36);
  v136[6] = v180[6];
  v136[7] = v180[7];
  v136[8] = v180[8];
  v136[9] = v180[9];
  v136[2] = v180[2];
  v136[3] = v180[3];
  v136[4] = v180[4];
  v136[5] = v180[5];
  v136[0] = v180[0];
  v136[1] = v180[1];
  long long v39 = sub_1B63CFDE4(a1, (uint64_t)"RAYTRACE NORMAL INPUT", v136);
  *(void *)&long long v133 = a2[4];
  DWORD2(v133) = 0;
  uint64_t v134 = v39;
  uint64_t v135 = 0x100000000;
  long long v40 = (uint64_t *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy raytrace normal input", &v133);
  uint64_t v41 = (CFX::RG::Pass *)v40;
  if (a3) {
    CFX::RG::Pass::dependsOn(v40, a3);
  }
  uint64_t v42 = *a2;
  uint64_t v43 = a2[1];
  v119[0] = "SSR raytrace";
  v119[1] = v42;
  __int16 v120 = 0;
  uint64_t v121 = v43;
  long long v128 = v208;
  long long v129 = v209;
  long long v130 = v210;
  long long v131 = v211;
  long long v124 = v204;
  long long v125 = v205;
  long long v126 = v206;
  long long v127 = v207;
  long long v122 = v202;
  long long v123 = v203;
  int v132 = *((_DWORD *)a2 + 14);
  long long v44 = (uint64_t *)sub_1B644BB44(a1, a1, (uint64_t)v119);
  long long v45 = (CFX::RG::Resource *)v37[93];
  v44[71] = (uint64_t)v45;
  CFX::RG::Pass::readFrom(v44, v45);
  long long v46 = (CFX::RG::Resource *)v37[94];
  v44[72] = (uint64_t)v46;
  CFX::RG::Pass::readFrom(v44, v46);
  v44[73] = (uint64_t)v39;
  CFX::RG::Pass::readFrom(v44, v39);
  CFX::RG::Pass::dependsOn(v44, (CFX::RG::Pass *)v37);
  CFX::RG::Pass::dependsOn(v44, v41);
  long long v113 = v208;
  long long v114 = v209;
  long long v115 = v210;
  long long v116 = v211;
  long long v109 = v204;
  long long v110 = v205;
  long long v111 = v206;
  long long v112 = v207;
  long long v107 = v202;
  uint64_t v47 = *a2;
  v105[0] = "SSR blur X";
  v105[1] = v47;
  __int16 v106 = 0;
  long long v108 = v203;
  int v117 = *((_DWORD *)a2 + 14);
  char v118 = 0;
  id v48 = (uint64_t *)sub_1B644BB9C(a1, a1, (uint64_t)v105);
  uint64_t v49 = (CFX::RG::Resource *)v44[74];
  v48[70] = (uint64_t)v49;
  CFX::RG::Pass::readFrom(v48, v49);
  long long v50 = (CFX::RG::Resource *)v44[75];
  v48[71] = (uint64_t)v50;
  CFX::RG::Pass::readFrom(v48, v50);
  long long v99 = v208;
  long long v100 = v209;
  long long v101 = v210;
  long long v102 = v211;
  long long v95 = v204;
  long long v96 = v205;
  long long v97 = v206;
  long long v98 = v207;
  long long v93 = v202;
  uint64_t v51 = *a2;
  v91[0] = "SSR blur Y";
  v91[1] = v51;
  __int16 v92 = 0;
  long long v94 = v203;
  int v103 = *((_DWORD *)a2 + 14);
  char v104 = 1;
  uint64_t v52 = (uint64_t *)sub_1B644BB9C(a1, a1, (uint64_t)v91);
  uint64_t v53 = (CFX::RG::Resource *)v48[72];
  v52[70] = (uint64_t)v53;
  CFX::RG::Pass::readFrom(v52, v53);
  uint64_t v54 = (CFX::RG::Resource *)v44[75];
  v52[71] = (uint64_t)v54;
  CFX::RG::Pass::readFrom(v52, v54);
  uint64_t v55 = (_OWORD *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[6]);
  CFX::RG::TextureDescriptorReference::withSampleCount(v55, 1, (uint64_t)v90);
  uint64_t v56 = sub_1B63CFDE4(a1, (uint64_t)"REFLECTANCE ROUGHNESS COPY", v90);
  *(void *)&long long v87 = a2[6];
  DWORD2(v87) = 0;
  long long v88 = v56;
  uint64_t v89 = 0x100000000;
  uint64_t v57 = (uint64_t *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy reflectance roughness input", &v87);
  if (a3) {
    CFX::RG::Pass::dependsOn(v57, a3);
  }
  uint64_t v58 = (_OWORD *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[5]);
  CFX::RG::TextureDescriptorReference::withSampleCount(v58, 1, (uint64_t)v86);
  uint64_t v59 = sub_1B63CFDE4(a1, (uint64_t)"RADIANCE COPY", v86);
  *(void *)&long long v83 = a2[5];
  DWORD2(v83) = 0;
  uint64_t v84 = v59;
  uint64_t v85 = 0x100000000;
  uint64_t v60 = (uint64_t *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy radiance input", &v83);
  if (a3) {
    CFX::RG::Pass::dependsOn(v60, a3);
  }
  long long v78 = v218;
  long long v79 = v219;
  long long v80 = v220;
  long long v81 = v221;
  long long v74 = v214;
  long long v75 = v215;
  long long v76 = v216;
  long long v77 = v217;
  long long v72 = v212;
  uint64_t v61 = *a2;
  v70[0] = "SSR composite";
  v70[1] = v61;
  __int16 v71 = 0;
  long long v73 = v213;
  int v82 = *((_DWORD *)a2 + 14);
  uint64_t v62 = (uint64_t *)sub_1B644BBF4(a1, (uint64_t)a1, (uint64_t)v70);
  uint64_t v63 = (_OWORD *)CFX::RG::Resource::constTextureDesc((CFX::RG::Resource *)a2[2]);
  CFX::RG::TextureDescriptorReference::withSampleCount(v63, 1, (uint64_t)v69);
  uint64_t v64 = sub_1B63CFDE4(a1, (uint64_t)"SSR Composite output", v69);
  v62[70] = (uint64_t)v64;
  CFX::RG::Pass::renderTo((uint64_t)v62, (uint64_t)v64, 0x100000000, 0);
  a2[8] = (uint64_t)v64;
  v62[71] = (uint64_t)v68;
  CFX::RG::Pass::readFrom(v62, v68);
  v62[72] = (uint64_t)v59;
  CFX::RG::Pass::readFrom(v62, v59);
  v62[73] = (uint64_t)v56;
  CFX::RG::Pass::readFrom(v62, v56);
  uint64_t v65 = (CFX::RG::Resource *)v52[72];
  v62[74] = (uint64_t)v65;
  CFX::RG::Pass::readFrom(v62, v65);
  if (a3) {
    CFX::RG::Pass::dependsOn(v62, a3);
  }
  CFX::RG::Pass::dependsOn(v62, (CFX::RG::Pass *)v52);
  return v62;
}

uint64_t sub_1B644BA94(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B644C144(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B644BAEC(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B644C1A4(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B644BB44(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B644C204(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B644BB9C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B644C264(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B644BBF4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v8[0] = *a1;
  v8[1] = v5;
  sub_1B644C2C4(v8[0], v5, v8, a2, a3);
  v8[0] = v6;
  sub_1B63C88CC(a1 + 18, v8);
  return v8[0];
}

void sub_1B644BC50(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B644BC8C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B644BCC8(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B644BD04(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B644BD40(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B644BD78(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      unint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      double result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B644BE64(void *a1)
{
  *a1 = &unk_1F0FB3C38;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B644BEB0(void *a1)
{
  *a1 = &unk_1F0FB3C38;
  CFAllocatorRef v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B644BF1C(void *a1)
{
  *a1 = &unk_1F0FB39B8;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B644BF68(void *a1)
{
  *a1 = &unk_1F0FB39B8;
  CFAllocatorRef v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B644BFD4(void *a1)
{
  *a1 = &unk_1F0FB3260;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B644C020(void *a1)
{
  *a1 = &unk_1F0FB3260;
  CFAllocatorRef v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B644C08C(void *a1)
{
  *a1 = &unk_1F0FB3A78;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B644C0D8(void *a1)
{
  *a1 = &unk_1F0FB3A78;
  CFAllocatorRef v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B644C144(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x238u, 8u);
  return sub_1B64497E4(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B644C1A4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x2F8u, 8u);
  return sub_1B6449B58(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B644C204(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x260u, 8u);
  return sub_1B644A130(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B644C264(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x248u, 8u);
  return sub_1B644A91C(v8, *a3, a3[1], a4, a5);
}

double sub_1B644C2C4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v7 = sub_1B63C8330(v10, 0x258u, 8u);
  return sub_1B644AE54(v7, *a3, a3[1], v8, a5);
}

uint64_t sub_1B644C4D0(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4)
{
  if (!CFEqual(cf1, @"kCFXNotificationProfileWillDie")) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong notification sent", v6, v7, v8, v9, v10, v11, (uint64_t)"CFEqual(name, kCFXNotificationProfileWillDie)");
  }

  return MEMORY[0x1F4181798](a2, sel_releaseProgramForResource_, a4, v7);
}

uint64_t sub_1B644C548(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](a2, sel_releaseProgramForResource_, a4, a4);
}

void sub_1B644C6A4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B644CA88(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 1)
  {
    uint64_t v8 = a3;
    uint64_t v9 = (uint64_t *)a2;
    do
    {
      CFDictionaryRef v11 = (const __CFDictionary *)sub_1B6603D54(*v9, a2, a3, a4, a5, a6, a7, a8);
      if (v11) {
        CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)sub_1B644CAF4, a1);
      }
      ++v9;
      --v8;
    }
    while (v8);
  }
}

void sub_1B644CAF4(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t sub_1B644CB08(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 1)
  {
    LOWORD(v10) = 0;
  }
  else
  {
    uint64_t v8 = a2;
    int v10 = 0;
    do
    {
      uint64_t v11 = *a1++;
      v10 |= sub_1B6604094(v11, a2, a3, a4, a5, a6, a7, a8);
      --v8;
    }
    while (v8);
  }
  return (__int16)v10;
}

__CFString *sub_1B644CB60(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 0:
      uint64_t v8 = off_1E6141898;
      goto LABEL_20;
    case 1:
      uint64_t v8 = off_1E61418A0;
      goto LABEL_20;
    case 2:
      uint64_t v8 = off_1E61418A8;
      goto LABEL_20;
    case 3:
      uint64_t v8 = off_1E61418B0;
      goto LABEL_20;
    case 4:
      uint64_t v8 = off_1E61418B8;
      goto LABEL_20;
    case 5:
      uint64_t v8 = off_1E61418C0;
      goto LABEL_20;
    case 6:
      uint64_t v8 = off_1E61418C8;
      goto LABEL_20;
    case 7:
      uint64_t v8 = off_1E61418D0;
      goto LABEL_20;
    case 8:
      uint64_t v8 = off_1E61418D8;
      goto LABEL_20;
    case 9:
      uint64_t v8 = off_1E61418E0;
      goto LABEL_20;
    case 10:
      uint64_t v8 = off_1E61418E8;
      goto LABEL_20;
    case 11:
      uint64_t v8 = off_1E61418F8;
      goto LABEL_20;
    case 12:
      uint64_t v8 = off_1E6141900;
      goto LABEL_20;
    case 13:
      uint64_t v8 = off_1E6141908;
      goto LABEL_20;
    case 14:
      uint64_t v8 = off_1E6141910;
      goto LABEL_20;
    case 15:
      uint64_t v8 = off_1E6141918;
      goto LABEL_20;
    case 16:
      uint64_t v8 = off_1E61418F0;
LABEL_20:
      double result = *v8;
      break;
    default:
      sub_1B63F2F54(16, @"Error: unknown material property type", a3, a4, a5, a6, a7, a8, vars0);
      double result = 0;
      break;
  }
  return result;
}

uint64_t sub_1B644CCC8(int a1, int a2)
{
  if (qword_1E9DDA860 != -1) {
    dispatch_once(&qword_1E9DDA860, &unk_1F0FB5768);
  }
  return *((void *)&unk_1E9DDA868 + 8 * (uint64_t)a1 + a2);
}

void sub_1B644CD28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  uint64_t v9 = &qword_1E9DDA888;
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    uint64_t v11 = sub_1B644CB60((char)v8, a2, a3, a4, a5, a6, a7, a8);
    *(v9 - 4) = (uint64_t)v11;
    MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(v10, 0, v11);
    CFStringUppercase(MutableCopy, 0);
    *(v9 - 3) = (uint64_t)CFStringCreateWithFormat(v10, 0, @"USE_%@", MutableCopy);
    *(v9 - 2) = (uint64_t)CFStringCreateWithFormat(v10, 0, @"USE_%@_COLOR", MutableCopy);
    *(v9 - 1) = (uint64_t)CFStringCreateWithFormat(v10, 0, @"USE_%@_INTENSITY", MutableCopy);
    *uint64_t v9 = (uint64_t)CFStringCreateWithFormat(v10, 0, @"USE_%@_TEXTURE_COMPONENT", MutableCopy);
    v9[1] = (uint64_t)CFStringCreateWithFormat(v10, 0, @"USE_%@TEXCOORD", MutableCopy);
    void v9[2] = (uint64_t)CFStringCreateWithFormat(v10, 0, @"USE_%@_MAP", MutableCopy);
    v9[3] = (uint64_t)CFStringCreateWithFormat(v10, 0, @"USE_%@_CUBEMAP", MutableCopy);
    CFRelease(MutableCopy);
    ++v8;
    v9 += 8;
  }
  while (v8 != 17);
}

uint64_t sub_1B644CEA0(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t v9 = objc_msgSend__handle(a2, (const char *)a2, (uint64_t)a3, a4);
  long long v10 = *(_OWORD *)(a1 + 48);
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v13 = *(_DWORD *)(a1 + 16);
  int v14 = *(_DWORD *)(a1 + 20);
  int v15 = *(_DWORD *)(a1 + 24);
  int v16 = *(_DWORD *)(a1 + 32);
  int v17 = *(_DWORD *)(a1 + 36);
  int v18 = *(_DWORD *)(a1 + 40);
  v36[0] = *(_DWORD *)a1;
  v36[1] = v13;
  v36[2] = v16;
  v36[3] = 0;
  v36[4] = v11;
  v36[5] = v14;
  _OWORD v36[6] = v17;
  v36[7] = 0;
  v36[8] = v12;
  v36[9] = v15;
  v36[10] = v18;
  v36[11] = 0;
  uint64_t v37 = v10;
  int v38 = DWORD2(v10);
  int v39 = 0;
  if (a3)
  {
    uint64_t v19 = objc_msgSend__handle(a3, v6, v7, v8);
    long long v20 = *(_OWORD *)(a1 + 112);
    int v21 = *(_DWORD *)(a1 + 68);
    int v22 = *(_DWORD *)(a1 + 72);
    int v23 = *(_DWORD *)(a1 + 80);
    int v24 = *(_DWORD *)(a1 + 84);
    int v25 = *(_DWORD *)(a1 + 88);
    int v26 = *(_DWORD *)(a1 + 96);
    int v27 = *(_DWORD *)(a1 + 100);
    int v28 = *(_DWORD *)(a1 + 104);
    v32[0] = *(_DWORD *)(a1 + 64);
    v32[1] = v23;
    v32[2] = v26;
    v32[3] = 0;
    v32[4] = v21;
    v32[5] = v24;
    v32[6] = v27;
    v32[7] = 0;
    v32[8] = v22;
    v32[9] = v25;
    v32[10] = v28;
    v32[11] = 0;
    uint64_t v33 = v20;
    int v34 = DWORD2(v20);
    int v35 = 0;
    uint64_t v29 = sub_1B6E073B8(704, 16);
    sub_1B6DF6D18(v29, v9, v19, v36, v32);
    int v30 = *(_DWORD *)(a1 + 136);
    *(void *)(v29 + 512) = *(void *)(a1 + 128);
    *(_DWORD *)(v29 + 520) = v30;
    *(void *)(v29 + 496) = 0x3E99999A3F000000;
    *(_DWORD *)(v29 + 504) = 1065353216;
    *(unsigned char *)(v29 + 592) = 1;
  }
  else
  {
    uint64_t v29 = sub_1B6E073B8(704, 16);
    sub_1B6DF6DC0(v29, v9, v36);
  }
  return v29;
}

void sub_1B644D06C(_Unwind_Exception *a1)
{
  sub_1B6E073C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B644D444(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__twistHandle(*(void **)(a1 + 96), a2, a3, a4);
  if (result)
  {
    long long v6 = *(_OWORD *)(a1 + 80);
    int v7 = *(_DWORD *)(a1 + 36);
    int v8 = *(_DWORD *)(a1 + 40);
    int v9 = *(_DWORD *)(a1 + 48);
    int v10 = *(_DWORD *)(a1 + 52);
    int v11 = *(_DWORD *)(a1 + 56);
    int v12 = *(_DWORD *)(a1 + 64);
    int v13 = *(_DWORD *)(a1 + 68);
    int v14 = *(_DWORD *)(a1 + 72);
    v28[0] = *(_DWORD *)(a1 + 32);
    v28[1] = v9;
    v28[2] = v12;
    v28[3] = 0;
    v28[4] = v7;
    v28[5] = v10;
    v28[6] = v13;
    v28[7] = 0;
    v28[8] = v8;
    v28[9] = v11;
    v28[10] = v14;
    v28[11] = 0;
    uint64_t v29 = v6;
    int v30 = DWORD2(v6);
    int v31 = 0;
    long long v15 = *(_OWORD *)(*(void *)(a1 + 96) + 160);
    int v16 = *(_DWORD *)(*(void *)(a1 + 96) + 116);
    int v17 = *(_DWORD *)(*(void *)(a1 + 96) + 120);
    int v18 = *(_DWORD *)(*(void *)(a1 + 96) + 128);
    int v19 = *(_DWORD *)(*(void *)(a1 + 96) + 132);
    int v20 = *(_DWORD *)(*(void *)(a1 + 96) + 136);
    int v21 = *(_DWORD *)(*(void *)(a1 + 96) + 144);
    int v22 = *(_DWORD *)(*(void *)(a1 + 96) + 148);
    int v23 = *(_DWORD *)(*(void *)(a1 + 96) + 152);
    v24[0] = *(_DWORD *)(*(void *)(a1 + 96) + 112);
    v24[1] = v18;
    void v24[2] = v21;
    v24[3] = 0;
    v24[4] = v16;
    v24[5] = v19;
    v24[6] = v22;
    v24[7] = 0;
    v24[8] = v17;
    v24[9] = v20;
    _OWORD v24[10] = v23;
    v24[11] = 0;
    int v26 = DWORD2(v15);
    uint64_t v25 = v15;
    int v27 = 0;
    return (*(uint64_t (**)(uint64_t, _DWORD *, _DWORD *))(*(void *)result + 88))(result, v28, v24);
  }
  return result;
}

uint64_t sub_1B644D624(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend__twistHandle(*(void **)(a1 + 96), a2, a3, a4);
  if (result)
  {
    long long v6 = *(_OWORD *)(*(void *)(a1 + 96) + 96);
    int v7 = *(_DWORD *)(*(void *)(a1 + 96) + 52);
    int v8 = *(_DWORD *)(*(void *)(a1 + 96) + 56);
    int v9 = *(_DWORD *)(*(void *)(a1 + 96) + 64);
    int v10 = *(_DWORD *)(*(void *)(a1 + 96) + 68);
    int v11 = *(_DWORD *)(*(void *)(a1 + 96) + 72);
    int v12 = *(_DWORD *)(*(void *)(a1 + 96) + 80);
    int v13 = *(_DWORD *)(*(void *)(a1 + 96) + 84);
    int v14 = *(_DWORD *)(*(void *)(a1 + 96) + 88);
    v28[0] = *(_DWORD *)(*(void *)(a1 + 96) + 48);
    v28[1] = v9;
    v28[2] = v12;
    v28[3] = 0;
    v28[4] = v7;
    v28[5] = v10;
    v28[6] = v13;
    v28[7] = 0;
    v28[8] = v8;
    v28[9] = v11;
    v28[10] = v14;
    v28[11] = 0;
    uint64_t v29 = v6;
    int v30 = DWORD2(v6);
    int v31 = 0;
    long long v15 = *(_OWORD *)(a1 + 80);
    int v16 = *(_DWORD *)(a1 + 36);
    int v17 = *(_DWORD *)(a1 + 40);
    int v18 = *(_DWORD *)(a1 + 48);
    int v19 = *(_DWORD *)(a1 + 52);
    int v20 = *(_DWORD *)(a1 + 56);
    int v21 = *(_DWORD *)(a1 + 64);
    int v22 = *(_DWORD *)(a1 + 68);
    int v23 = *(_DWORD *)(a1 + 72);
    v24[0] = *(_DWORD *)(a1 + 32);
    v24[1] = v18;
    void v24[2] = v21;
    v24[3] = 0;
    v24[4] = v16;
    v24[5] = v19;
    v24[6] = v22;
    v24[7] = 0;
    v24[8] = v17;
    v24[9] = v20;
    _OWORD v24[10] = v23;
    v24[11] = 0;
    int v26 = DWORD2(v15);
    uint64_t v25 = v15;
    int v27 = 0;
    return (*(uint64_t (**)(uint64_t, _DWORD *, _DWORD *))(*(void *)result + 88))(result, v28, v24);
  }
  return result;
}

double sub_1B644D7EC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__twistHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    uint64_t v7 = *(void *)(a1 + 32) + 48;
    *(_DWORD *)(v5 + 512) = *(_DWORD *)(a1 + 40);
    *(void *)(v5 + 516) = *(void *)(v7 + 132);
    double result = 0.000000381469873;
    *(void *)(v5 + 496) = 0x3E99999A3F000000;
    *(_DWORD *)(v5 + 504) = 1065353216;
  }
  return result;
}

double sub_1B644D900(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__twistHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    int v7 = *(_DWORD *)(a1 + 40);
    int v8 = *(_DWORD *)(*(void *)(a1 + 32) + 184);
    *(_DWORD *)(v5 + 512) = *(_DWORD *)(*(void *)(a1 + 32) + 176);
    *(_DWORD *)(v5 + 516) = v7;
    *(_DWORD *)(v5 + 520) = v8;
    double result = 0.000000381469873;
    *(void *)(v5 + 496) = 0x3E99999A3F000000;
    *(_DWORD *)(v5 + 504) = 1065353216;
  }
  return result;
}

double sub_1B644DA18(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend__twistHandle(*(void **)(a1 + 32), a2, a3, a4);
  if (v5)
  {
    int v7 = *(_DWORD *)(a1 + 40);
    *(void *)(v5 + 512) = *(void *)(*(void *)(a1 + 32) + 176);
    *(_DWORD *)(v5 + 520) = v7;
    double result = 0.000000381469873;
    *(void *)(v5 + 496) = 0x3E99999A3F000000;
    *(_DWORD *)(v5 + 504) = 1065353216;
  }
  return result;
}

uint64_t sub_1B644DDE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFX::CrossFrameResourceManager *a5, uint64_t a6)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDACB0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v36 = a2;
    int v35 = __cxa_guard_acquire(&qword_1E9DDACB0);
    a2 = v36;
    if (v35)
    {
      byte_1E9DDACA8 = 1;
      __cxa_guard_release(&qword_1E9DDACB0);
      a2 = v36;
    }
  }
  if (byte_1E9DDACA8) {
    uint64_t v10 = 0x8C1DCF5E2BFD8933;
  }
  else {
    uint64_t v10 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a6, v10, 0);
  *(void *)a1 = &unk_1F0FB3508;
  *(_OWORD *)(a1 + 384) = *(_OWORD *)(a6 + 24);
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  int v11 = *(CFX::RG::Resource **)(a6 + 24);
  uint64_t v12 = CFX::RG::Resource::textureDesc(v11);
  if (!*(unsigned char *)(v12 + 80)) {
    *(unsigned char *)(v12 + 80) = 1;
  }
  *(void *)(v12 + 72) = 1;
  uint64_t v13 = *(void *)(a6 + 32);
  unint64_t v14 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v15 = CFX::CrossFrameResourceManager::get(a5, v14);
  int v16 = (uint64_t *)(a1 + 400);
  *(void *)(a1 + 400) = v15;
  if (!v15)
  {
    unint64_t v17 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    *(void *)(a1 + 400) = sub_1B644E178(a5, v17);
    uint64_t v25 = (void *)sub_1B6445900(*(void *)(a1 + 368), v18, v19, v20, v21, v22, v23, v24);
    *(unsigned char *)(*v16 + 32) = *(unsigned char *)(*v16 + 32) & 0xFD | (objc_msgSend_features(v25, v26, v27, v28) >> 10) & 2;
    CFX::RG::TextureDescriptorReference::finalColor((uint64_t)v38);
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v38, MTLPixelFormatRGBA16Float, (uint64_t)v39);
    uint64_t v29 = (CFX::RG::Resource *)malloc_type_malloc(0xE0uLL, 0xD5346062uLL);
    *(void *)&long long v30 = -1;
    *((void *)&v30 + 1) = -1;
    *((_OWORD *)v29 + 12) = v30;
    *((_OWORD *)v29 + 13) = v30;
    *((_OWORD *)v29 + 10) = v30;
    *((_OWORD *)v29 + 11) = v30;
    *((_OWORD *)v29 + 8) = v30;
    *((_OWORD *)v29 + 9) = v30;
    *((_OWORD *)v29 + 6) = v30;
    *((_OWORD *)v29 + 7) = v30;
    *((_OWORD *)v29 + 4) = v30;
    *((_OWORD *)v29 + 5) = v30;
    *((_OWORD *)v29 + 2) = v30;
    *((_OWORD *)v29 + 3) = v30;
    *(_OWORD *)uint64_t v29 = v30;
    *((_OWORD *)v29 + 1) = v30;
    long long v40 = v39[0];
    long long v41 = v39[1];
    long long v44 = v39[4];
    long long v45 = v39[5];
    long long v42 = v39[2];
    long long v43 = v39[3];
    long long v48 = v39[8];
    long long v49 = v39[9];
    long long v46 = v39[6];
    long long v47 = v39[7];
    CFX::RG::Resource::Resource((uint64_t)v29, (uint64_t)"pingPongTex", (uint64_t)&v40, 2);
    sub_1B644E78C((CFX::RG::Resource **)(*v16 + 16), v29);
    uint64_t v15 = *v16;
    if ((*(unsigned char *)(*v16 + 32) & 2) == 0)
    {
      CFX::RG::TextureDescriptorReference::finalColor((uint64_t)v38);
      CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v38, MTLPixelFormatRGBA16Float, (uint64_t)v37);
      int v31 = (CFX::RG::Resource *)malloc_type_malloc(0xE0uLL, 0xD5346062uLL);
      *(void *)&long long v32 = -1;
      *((void *)&v32 + 1) = -1;
      *((_OWORD *)v31 + 12) = v32;
      *((_OWORD *)v31 + 13) = v32;
      *((_OWORD *)v31 + 10) = v32;
      *((_OWORD *)v31 + 11) = v32;
      *((_OWORD *)v31 + 8) = v32;
      *((_OWORD *)v31 + 9) = v32;
      *((_OWORD *)v31 + 6) = v32;
      *((_OWORD *)v31 + 7) = v32;
      *((_OWORD *)v31 + 4) = v32;
      *((_OWORD *)v31 + 5) = v32;
      *((_OWORD *)v31 + 2) = v32;
      *((_OWORD *)v31 + 3) = v32;
      *(_OWORD *)int v31 = v32;
      *((_OWORD *)v31 + 1) = v32;
      long long v40 = v37[0];
      long long v41 = v37[1];
      long long v44 = v37[4];
      long long v45 = v37[5];
      long long v42 = v37[2];
      long long v43 = v37[3];
      long long v48 = v37[8];
      long long v49 = v37[9];
      long long v46 = v37[6];
      long long v47 = v37[7];
      CFX::RG::Resource::Resource((uint64_t)v31, (uint64_t)"pingPongTex", (uint64_t)&v40, 2);
      sub_1B644E78C((CFX::RG::Resource **)(*v16 + 24), v31);
      uint64_t v15 = *v16;
    }
  }
  if ((*(unsigned char *)(v15 + 32) & 2) != 0)
  {
    *(unsigned char *)(v15 + 32) &= ~1u;
    if (sub_1B6447D58(*(void *)(a1 + 368))) {
      uint64_t v33 = 0x100000001;
    }
    else {
      uint64_t v33 = 0x100000002;
    }
    CFX::RG::Pass::renderTo(a1, *(void *)(*(void *)(a1 + 400) + 8 * (*(unsigned char *)(*(void *)(a1 + 400) + 32) & 1) + 16), v33, 0);
  }
  else
  {
    *(unsigned char *)(*(void *)(a1 + 400) + 32) = (*(unsigned char *)(*(void *)(a1 + 400) + 32) & 0xFE | sub_1B6447D58(*(void *)(a1 + 368)) & 1) ^ 1;
    CFX::RG::Pass::renderTo(a1, *(void *)(*(void *)(a1 + 400) + 8 * (*(unsigned char *)(*(void *)(a1 + 400) + 32) & 1) + 16), 0x100000000, 0);
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, v11);
  if (sub_1B6447D6C(*(void *)(a1 + 368))) {
    CFX::RG::Pass::renderTo(a1, v13, 0x100000000, 1);
  }
  return a1;
}

void sub_1B644E148(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B644E178(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B644E20C(uint64_t a1, CFX::CrossFrameResourceManager **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 368), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  char v11 = *(unsigned char *)(*(void *)(a1 + 400) + 32);
  uint64_t v12 = *(void *)(CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 392))+ 16);
  unint64_t v13 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v14 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v13 ^ ((0x9DDFEA08EB382D69 * (v13 ^ v12)) >> 47) ^ (0x9DDFEA08EB382D69 * (v13 ^ v12)))) ^ ((0x9DDFEA08EB382D69 * (v13 ^ ((0x9DDFEA08EB382D69 * (v13 ^ v12)) >> 47) ^ (0x9DDFEA08EB382D69 * (v13 ^ v12)))) >> 47));
  uint64_t v15 = CFX::CrossFrameResourceManager::get(a2[4], v14);
  *(void *)(a1 + 408) = v15;
  if (!v15)
  {
    *(void *)(a1 + 408) = sub_1B644E418(a2[4], v14);
    uint64_t v19 = objc_msgSend_resourceManager(v10, v16, v17, v18);
    uint64_t v20 = *(void *)(a1 + 408);
    memset(v51, 0, sizeof(v51));
    uint64_t v52 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    uint64_t v67 = 0;
    uint64_t v21 = (void *)sub_1B653EFAC((uint64_t)v19);
    uint64_t v53 = objc_msgSend_frameworkLibrary(v21, v22, v23, v24);
    *(void *)&long long v54 = 115;
    uint64_t v27 = @"vfx_jittering_color_attachment";
    if ((v11 & 2) == 0) {
      uint64_t v27 = @"vfx_jittering_texture";
    }
    *((void *)&v65 + 1) = @"vfx_draw_fullscreen_triangle_vertex";
    *(void *)&long long v66 = v27;
    uint64_t v28 = objc_msgSend_newRenderPipelineStateWithDesc_(v19, v25, (uint64_t)v51, v26);
    uint64_t v29 = *(void **)(v20 + 24);
    if (v29 != (void *)v28)
    {
      uint64_t v30 = v28;
      if (v29) {

      }
      *(void *)(v20 + 24) = v30;
    }
    uint64_t v31 = *(void *)(a1 + 408);
    long long v32 = (void *)sub_1B653EFAC((uint64_t)v19);
    *((void *)&v46 + 1) = objc_msgSend_frameworkLibrary(v32, v33, v34, v35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0);
    uint64_t v47 = 115;
    int v38 = @"vfx_jittering_color_attachment_drawable";
    uint64_t v48 = v12;
    if ((v11 & 2) == 0) {
      int v38 = @"vfx_jittering_texture_drawable";
    }
    *((void *)&v49 + 1) = @"vfx_draw_fullscreen_triangle_vertex";
    *(void *)&long long v50 = v38;
    uint64_t v39 = objc_msgSend_newRenderPipelineStateWithDesc_(v19, v36, (uint64_t)&v45, v37);
    long long v40 = *(void **)(v31 + 16);
    if (v40 != (void *)v39)
    {
      uint64_t v41 = v39;
      if (v40) {

      }
      *(void *)(v31 + 16) = v41;
    }
  }
  long long v42 = a2[4];
  unint64_t v43 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  return sub_1B644E178(v42, v43);
}

uint64_t sub_1B644E418(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B644E4A0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B645DE7C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  char v11 = (const CFX::RG::Resource *)a1[48];
  int v12 = sub_1B6447D6C(a1[46]);
  uint64_t v20 = a1[51];
  if (v12)
  {
    uint64_t v23 = *(void **)(v20 + 16);
    uint64_t v22 = (void **)(v20 + 16);
    uint64_t v21 = v23;
    if (v23) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t v52 = *(void **)(v20 + 24);
  uint64_t v22 = (void **)(v20 + 24);
  uint64_t v21 = v52;
  if (!v52)
  {
LABEL_3:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v14, v15, v16, v17, v18, v19, (uint64_t)"_ptr != NULL");
    uint64_t v21 = *v22;
  }
LABEL_4:
  uint64_t v24 = objc_msgSend_state(v21, v13, v14, v15);
  objc_msgSend_setRenderPipelineState_(*(void **)(v10 + 16), v25, v24, v26);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v11);
  sub_1B63C6ED0(v10, Texture, 0, v28);
  uint64_t v29 = a1[50];
  if ((*(unsigned char *)(v29 + 32) & 2) == 0)
  {
    id v30 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v29 + 8 * ((*(unsigned char *)(v29 + 32) & 1) == 0) + 16));
    sub_1B63C6ED0(v10, v30, 1, v31);
  }
  int v32 = sub_1B6447D58(a1[46]);
  unsigned int v40 = v32 + 1;
  if (v32 == -1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Count should be > 0", v33, v34, v35, v36, v37, v38, (uint64_t)"count > 0");
  }
  *(float *)v39.i32 = (float)v40;
  float32x2_t v41 = (float32x2_t)vdup_lane_s32(v39, 0);
  __asm { FMOV            V2.2S, #-1.0 }
  LODWORD(v47) = vadd_f32((float32x2_t)v39, _D2).u32[0];
  __asm { FMOV            V2.2S, #1.0 }
  HIDWORD(v47) = vdiv_f32(_D2, v41).i32[1];
  uint64_t v53 = v47;
  long long v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  sub_1B649F334(*(void *)(v10 + 24), &v53, 8uLL, &v54);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v10 + 16), v49, v55, v56, 0);
  return sub_1B63C6F54(v10, v50);
}

uint64_t sub_1B644E60C(uint64_t *a1, CFX::CrossFrameResourceManager *a2, uint64_t a3)
{
  return sub_1B644E61C(a1, (uint64_t)a1, a2, a3);
}

uint64_t sub_1B644E61C(uint64_t *a1, uint64_t a2, CFX::CrossFrameResourceManager *a3, uint64_t a4)
{
  uint64_t v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B644E89C(v9[0], v7, v9, a2, a3, a4);
  sub_1B63C88CC(a1 + 18, v9);
  return v9[0];
}

void sub_1B644E67C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B644E6B4(void *a1)
{
  *a1 = &unk_1F0FB34C8;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B644E710(void *a1)
{
  *a1 = &unk_1F0FB34C8;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B644E78C(CFX::RG::Resource **a1, CFX::RG::Resource *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    CFX::RG::Resource::~Resource(v3);
    free(v4);
  }
}

void *sub_1B644E7CC(void *a1)
{
  *a1 = &unk_1F0FB34E8;
  uint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  return a1;
}

void sub_1B644E824(void *a1)
{
  *a1 = &unk_1F0FB34E8;
  uint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B644E89C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, CFX::CrossFrameResourceManager *a5, uint64_t a6)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v9 = sub_1B63C8330(v12, 0x1A0u, 8u);
  return sub_1B644DDE0(v9, *a3, a3[1], v10, a5, a6);
}

void sub_1B644E8FC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"description");
  }
  uint64_t v10 = 0;
  if (a2) {
    char v11 = 8;
  }
  else {
    char v11 = 0;
  }
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a1 + 80) & 0xF7 | v11;
  if (a2) {
    char v12 = 4;
  }
  else {
    char v12 = 0;
  }
  do
  {
    *(unsigned char *)(a1 + 11 + v10) = *(unsigned char *)(a1 + 11 + v10) & 0xFB | v12;
    v10 += 8;
  }
  while (v10 != 64);
  *(unsigned char *)(a1 + 75) = *(unsigned char *)(a1 + 75) & 0xFB | v12;
}

uint64_t sub_1B644E9A0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFStringRef v4 = (const __CFString *)j__objc_msgSend_lowercaseString(a1, a2, a3, a4);
  if (CFEqual(v4, @"rgba")) {
    return 2;
  }
  if (CFStringHasPrefix(v4, @"rgba"))
  {
    if (CFStringHasPrefix(v4, @"rgba8"))
    {
      if (CFEqual(v4, @"rgba8unorm") || CFEqual(v4, @"rgba8")) {
        return 28;
      }
      if (CFEqual(v4, @"rgba8snorm") || CFEqual(v4, @"rgba8s")) {
        return 29;
      }
      if (CFEqual(v4, @"rgba8uint") || CFEqual(v4, @"rgba8ui")) {
        return 30;
      }
      if (CFEqual(v4, @"rgba8sint") || CFEqual(v4, @"rgba8i")) {
        return 31;
      }
    }
    else if (CFStringHasPrefix(v4, @"rgba16"))
    {
      if (CFEqual(v4, @"rgba16unorm") || CFEqual(v4, @"rgba16")) {
        return 32;
      }
      if (CFEqual(v4, @"rgba16snorm") || CFEqual(v4, @"rgba16s")) {
        return 33;
      }
      if (CFEqual(v4, @"rgba16uint") || CFEqual(v4, @"rgba16ui")) {
        return 34;
      }
      if (CFEqual(v4, @"rgba16sint") || CFEqual(v4, @"rgba16i")) {
        return 35;
      }
      if (CFEqual(v4, @"rgba16float") || CFEqual(v4, @"rgba16f")) {
        return 36;
      }
    }
    else if (CFStringHasPrefix(v4, @"rgba32"))
    {
      if (CFEqual(v4, @"rgba32uint") || CFEqual(v4, @"rgba32ui")) {
        return 37;
      }
      if (CFEqual(v4, @"rgba32sint") || CFEqual(v4, @"rgba32i")) {
        return 38;
      }
      if (CFEqual(v4, @"rgba32float") || CFEqual(v4, @"rgba32f")) {
        return 39;
      }
    }
  }
  else if (CFStringHasPrefix(v4, @"rg"))
  {
    if (CFStringHasPrefix(v4, @"rg8"))
    {
      if (CFEqual(v4, @"rg8unorm") || CFEqual(v4, @"rg8")) {
        return 15;
      }
      if (CFEqual(v4, @"rg8snorm") || CFEqual(v4, @"rg8s")) {
        return 16;
      }
      if (CFEqual(v4, @"rg8uint") || CFEqual(v4, @"rg8ui")) {
        return 17;
      }
      if (CFEqual(v4, @"rg8sint") || CFEqual(v4, @"rg8i")) {
        return 18;
      }
    }
    else if (CFStringHasPrefix(v4, @"rg16"))
    {
      if (CFEqual(v4, @"rg16unorm") || CFEqual(v4, @"rg16")) {
        return 19;
      }
      if (CFEqual(v4, @"rg16snorm") || CFEqual(v4, @"rg16s")) {
        return 20;
      }
      if (CFEqual(v4, @"rg16uint") || CFEqual(v4, @"rg16ui")) {
        return 21;
      }
      if (CFEqual(v4, @"rg16sint") || CFEqual(v4, @"rg16i")) {
        return 22;
      }
      if (CFEqual(v4, @"rg16float") || CFEqual(v4, @"rg16f")) {
        return 23;
      }
    }
    else if (CFStringHasPrefix(v4, @"rg32"))
    {
      if (CFEqual(v4, @"rg32uint") || CFEqual(v4, @"rg32ui")) {
        return 24;
      }
      if (CFEqual(v4, @"rg32sint") || CFEqual(v4, @"rg32i")) {
        return 25;
      }
      if (CFEqual(v4, @"rg32float") || CFEqual(v4, @"rg32f")) {
        return 26;
      }
    }
  }
  else if (CFStringHasPrefix(v4, @"r"))
  {
    if (CFStringHasPrefix(v4, @"r8"))
    {
      if (CFEqual(v4, @"r8unorm") || CFEqual(v4, @"r8")) {
        return 3;
      }
      if (CFEqual(v4, @"r8snorm") || CFEqual(v4, @"r8s")) {
        return 4;
      }
      if (CFEqual(v4, @"r8uint") || CFEqual(v4, @"r8ui")) {
        return 5;
      }
      if (CFEqual(v4, @"r8sint") || CFEqual(v4, @"r8i")) {
        return 6;
      }
    }
    else if (CFStringHasPrefix(v4, @"r16"))
    {
      if (CFEqual(v4, @"r16unorm") || CFEqual(v4, @"r16")) {
        return 7;
      }
      if (CFEqual(v4, @"r16snorm") || CFEqual(v4, @"r16s")) {
        return 8;
      }
      if (CFEqual(v4, @"r16uint") || CFEqual(v4, @"r16ui")) {
        return 9;
      }
      if (CFEqual(v4, @"r16sint") || CFEqual(v4, @"r16i")) {
        return 10;
      }
      if (CFEqual(v4, @"r16float") || CFEqual(v4, @"r16f")) {
        return 11;
      }
    }
    else if (CFStringHasPrefix(v4, @"r32"))
    {
      if (CFEqual(v4, @"r32uint") || CFEqual(v4, @"r32ui")) {
        return 12;
      }
      if (CFEqual(v4, @"r32sint") || CFEqual(v4, @"r32i")) {
        return 13;
      }
      if (CFEqual(v4, @"r32float") || CFEqual(v4, @"r32f")) {
        return 14;
      }
    }
  }
  if (CFEqual(v4, @"bgra8unorm") || CFEqual(v4, @"bgra8")) {
    return 27;
  }
  if (!CFStringHasPrefix(v4, @"depth")) {
    goto LABEL_145;
  }
  if (CFEqual(v4, @"depth16unorm") || CFEqual(v4, @"depth16")) {
    return 40;
  }
  if (CFEqual(v4, @"depth24unorm") || CFEqual(v4, @"depth24")) {
    return 41;
  }
  if (CFEqual(v4, @"depth32float") || CFEqual(v4, @"depth32f")) {
    return 42;
  }
  if (CFEqual(v4, @"depth24unorm_stencil8")) {
    return 44;
  }
  if (CFEqual(v4, @"depth32float_stencil8")) {
    return 45;
  }
LABEL_145:
  if (CFEqual(v4, @"stencil8")) {
    return 43;
  }
  return 0;
}

__CFString *sub_1B644F2B4(int a1)
{
  if ((a1 - 1) > 0x2C) {
    return 0;
  }
  else {
    return off_1E6142018[(char)(a1 - 1)];
  }
}

uint64_t sub_1B644F2DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_1B644F328((void **)a1, a2, a3, a4, a5, a6, a7, a8);
  return a1;
}

void sub_1B644F30C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B644F328(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v112 = sub_1B64ACF7C(a2, 1, a3, a4, a5, a6, a7, a8);
  uint64_t v106 = a2;
  CFArrayRef v105 = sub_1B64ABD08(a2, v10, v11, v12, v13, v14, v15, v16);
  if ((uint64_t)v105 >= 1)
  {
    CFIndex v22 = 0;
    uint64_t v102 = (uint64_t)(a1 + 2);
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    char v104 = a1;
    while (1)
    {
      uint64_t v23 = sub_1B64ABD78(v106, v22, 1, v17, v18, v19, v20, v21);
      unsigned int v31 = sub_1B63D0C08((uint64_t)v23, v24, v25, v26, v27, v28, v29, v30);
      uint64_t v32 = sub_1B63D11E8((uint64_t)v23);
      if (v31 > 5 || ((1 << v31) & 0x23) == 0 || v32 == 0) {
        return;
      }
      uint64_t v35 = v32;
      uint64_t v36 = 3 * v32;
      uint64_t v37 = 12 * v32;
      long long v116 = (UInt8 *)malloc_type_malloc(12 * v32, 0xC565B4A9uLL);
      uint64_t v38 = 16 * v36;
      bytes = (UInt8 *)malloc_type_malloc(v38, 0x7D0DAC3AuLL);
      v119[0] = 0;
      CFDataRef v39 = (const __CFData *)sub_1B63D0F38((uint64_t)v23, v119);
      CFIndex v107 = v22;
      CFIndex v108 = v37;
      if (v119[0] == 4)
      {
        BytePtr = CFDataGetBytePtr(v39);
        long long v110 = 0;
        long long v111 = 0;
      }
      else if (v119[0] == 2)
      {
        long long v110 = CFDataGetBytePtr(v39);
        long long v111 = 0;
        BytePtr = 0;
      }
      else
      {
        long long v111 = v119[0] == 1 ? CFDataGetBytePtr(v39) : 0;
        BytePtr = 0;
        long long v110 = 0;
      }
      if (v35 >= 1) {
        break;
      }
LABEL_39:
      uint64_t v71 = -[VFXMesh __createCFObject]_0();
      CFDataRef v72 = CFDataCreate(allocator, bytes, v38);
      long long v76 = (const void *)sub_1B641CF98(v72, 0, 3 * v35, 4, 1, v73, v74, v75);
      CFRelease(v72);
      sub_1B64AC000(v71, v76, 0, 0, v77, v78, v79, v80);
      CFRelease(v76);
      uint64_t v81 = sub_1B63D0314();
      sub_1B63D04D0(v81, 0, v82, v83, v84, v85, v86, v87);
      CFDataRef v88 = CFDataCreate(allocator, v116, v108);
      sub_1B63D0E24(v81, v35, v88, 4);
      CFRelease(v88);
      uint64_t v90 = (uint64_t *)v104[1];
      unint64_t v89 = (unint64_t)v104[2];
      if ((unint64_t)v90 >= v89)
      {
        uint64_t v93 = ((char *)v90 - (unsigned char *)*v104) >> 4;
        unint64_t v94 = v93 + 1;
        if ((unint64_t)(v93 + 1) >> 60) {
          abort();
        }
        uint64_t v95 = v89 - (void)*v104;
        if (v95 >> 3 > v94) {
          unint64_t v94 = v95 >> 3;
        }
        if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v96 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v96 = v94;
        }
        if (v96) {
          long long v97 = (char *)sub_1B6427C8C(v102, v96);
        }
        else {
          long long v97 = 0;
        }
        long long v98 = (uint64_t *)&v97[16 * v93];
        *long long v98 = v71;
        v98[1] = v81;
        long long v100 = (char *)*v104;
        long long v99 = (char *)v104[1];
        long long v101 = v98;
        if (v99 == *v104)
        {
          CFIndex v92 = v107;
        }
        else
        {
          CFIndex v92 = v107;
          do
          {
            *((_OWORD *)v101 - 1) = *((_OWORD *)v99 - 1);
            v101 -= 2;
            v99 -= 16;
          }
          while (v99 != v100);
          long long v99 = (char *)*v104;
        }
        uint64_t v91 = v98 + 2;
        *char v104 = v101;
        v104[1] = v98 + 2;
        v104[2] = &v97[16 * v96];
        if (v99) {
          operator delete(v99);
        }
      }
      else
      {
        *uint64_t v90 = v71;
        v90[1] = v81;
        uint64_t v91 = v90 + 2;
        CFIndex v92 = v107;
      }
      v104[1] = v91;
      free(v116);
      free(bytes);
      CFIndex v22 = v92 + 1;
      if ((const __CFArray *)v22 == v105) {
        return;
      }
    }
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    unsigned int v48 = 6;
    unsigned int v49 = 1;
    unsigned int v50 = 2;
    uint64_t v114 = v35;
    unsigned int v113 = v31;
    while (1)
    {
      if (v31 == 5)
      {
        uint64_t v51 = 0;
        uint64_t v52 = (2 * v47) | 1;
        uint64_t v53 = 2 * v47 + 2;
      }
      else if (v31 == 1)
      {
        uint64_t v54 = 2 * v47;
        if (v47)
        {
          uint64_t v52 = v54 | 1;
          uint64_t v53 = v54 + 2;
        }
        else
        {
          uint64_t v52 = v54 + 2;
          uint64_t v53 = v54 | 1;
        }
        uint64_t v51 = v47;
      }
      else if (v31)
      {
        uint64_t v51 = 0;
        uint64_t v52 = 0;
        uint64_t v53 = 0;
      }
      else
      {
        uint64_t v51 = 3 * v47;
        uint64_t v52 = v46 + 1;
        uint64_t v53 = v46 + 2;
      }
      switch(v119[0])
      {
        case 4:
          uint64_t v51 = *(unsigned int *)&BytePtr[4 * v51];
          uint64_t v117 = *(unsigned int *)&BytePtr[4 * v52];
          uint64_t v55 = *(unsigned int *)&BytePtr[4 * v53];
          break;
        case 2:
          uint64_t v51 = *(unsigned __int16 *)&v110[2 * v51];
          uint64_t v117 = *(unsigned __int16 *)&v110[2 * v52];
          uint64_t v55 = *(unsigned __int16 *)&v110[2 * v53];
          break;
        case 1:
          uint64_t v51 = v111[v51];
          uint64_t v117 = v111[v52];
          uint64_t v55 = v111[v53];
          break;
        default:
          uint64_t v118 = v53;
          uint64_t v117 = v52;
          goto LABEL_38;
      }
      uint64_t v118 = v55;
LABEL_38:
      *(double *)&bytes[4 * v48 - 24] = sub_1B641E208((uint64_t)v112, v51, v40, v41, v42, v43, v44, v45);
      *(_DWORD *)&bytes[4 * v48 - 16] = v56;
      *(float *)&bytes[4 * v48 - 12] = (float)(v46 % 3);
      *(_DWORD *)&v116[4 * v46] = v46;
      *(double *)&bytes[4 * v48 - 8] = sub_1B641E208((uint64_t)v112, v117, v57, v58, v59, v60, v61, v62);
      *(_DWORD *)&bytes[4 * v48] = v63;
      *(float *)&bytes[4 * v48 + 4] = (float)(v46 + 1 - 3 * (v49 / 3));
      *(_DWORD *)&v116[4 * (v46 + 1)] = v46 + 1;
      *(double *)&bytes[4 * v48 + 8] = sub_1B641E208((uint64_t)v112, v118, v64, v65, v66, v67, v68, v69);
      *(_DWORD *)&bytes[4 * v48 + 16] = v70;
      *(float *)&bytes[4 * v48 + 20] = (float)(v46 + 2 - 3 * (v50 / 3));
      *(_DWORD *)&v116[4 * (v46 + 2)] = v46 + 2;
      ++v47;
      v48 += 12;
      v49 += 3;
      v50 += 3;
      v46 += 3;
      uint64_t v35 = v114;
      unsigned int v31 = v113;
      if (v114 == v47) {
        goto LABEL_39;
      }
    }
  }
}

uint64_t *sub_1B644F848(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    do
    {
      CFStringRef v4 = *(const void **)(v2 + 8);
      CFRelease(*(CFTypeRef *)v2);
      CFRelease(v4);
      v2 += 16;
    }
    while (v2 != v3);
    uint64_t v2 = *a1;
  }
  if (v2)
  {
    a1[1] = v2;
    operator delete((void *)v2);
  }
  return a1;
}

void sub_1B644F8B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1B644F8CC(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a1 + 24) = a6;
  double result = (void *)sub_1B6445900(a2, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v16 = result;
    objc_msgSend_pushDebugGroup_(result, v14, @"VFX - Draw wireframe", v15);
    uint64_t v20 = *(uint64_t **)a1;
    uint64_t v21 = *(uint64_t **)(a1 + 8);
    if (*(uint64_t **)a1 != v21)
    {
      do
      {
        uint64_t v22 = *v20;
        uint64_t v23 = v20[1];
        v20 += 2;
        long long v29 = a4[2];
        long long v30 = a4[3];
        long long v27 = *a4;
        long long v28 = a4[1];
        uint64_t v24 = sub_1B64E35DC();
        LOBYTE(v26) = 1;
        objc_msgSend_renderMesh_meshElement_withProgram_engineContext_transform_color_rasterizerStates_blendState_texture_depthBias_(v16, v25, v22, v23, a3, a2, a5, 0, *(double *)&v27, *(double *)&v28, *(double *)&v29, *(double *)&v30, v24, 0, v26);
      }
      while (v20 != v21);
    }
    return objc_msgSend_popDebugGroup(v16, v17, v18, v19);
  }
  return result;
}

void sub_1B644F9E0(uint64_t a1, unint64_t a2)
{
}

uint64_t sub_1B644FB18(uint64_t a1, unint64_t a2)
{
  unint64_t v8 = a2;
  uint64_t v2 = *(void **)(a1 + 32);
  if (!v2) {
    goto LABEL_12;
  }
  uint64_t v3 = (void *)(a1 + 32);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      long long v6 = v2;
    }
    else {
      long long v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 == (void *)(a1 + 32) || v3[4] > a2) {
LABEL_12:
  }
    operator new();
  return v3[5];
}

void sub_1B644FBE4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x1020C4016EE4530);
  _Unwind_Resume(a1);
}

uint64_t sub_1B644FC08(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  uint64_t v10 = a1[1];
  if (*a1 != v10)
  {
    do
    {
      uint64_t v13 = *v9++;
      sub_1B644F8CC(*(void *)v13, a2, a3, (long long *)(v13 + 32), v13 + 16, (uint64_t)a1[6], a7, a8);
      MEMORY[0x1BA9B6D80](v13, 0x1020C406DF670C8);
    }
    while (v9 != v10);
    uint64_t v9 = *a1;
  }
  a1[1] = v9;
  a1[6] = (uint64_t *)((char *)a1[6] + 1);

  return sub_1B644FCB4((uint64_t)a1);
}

uint64_t sub_1B644FCB4(uint64_t result)
{
  uint64_t v1 = (uint64_t **)(result + 24);
  uint64_t v2 = *(uint64_t **)(result + 24);
  uint64_t v3 = (uint64_t *)(result + 32);
  if (v2 != (uint64_t *)(result + 32))
  {
    uint64_t v4 = result;
    do
    {
      BOOL v5 = (uint64_t *)v2[5];
      if (v5[3] >= *(void *)(v4 + 48) - 100)
      {
        unint64_t v8 = (uint64_t *)v2[1];
        if (v8)
        {
          do
          {
            long long v6 = v8;
            unint64_t v8 = (uint64_t *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            long long v6 = (uint64_t *)v2[2];
            BOOL v9 = *v6 == (void)v2;
            uint64_t v2 = v6;
          }
          while (!v9);
        }
      }
      else
      {
        long long v6 = sub_1B64500F8(v1, v2);
        operator delete(v2);
        uint64_t v7 = sub_1B644F848(v5);
        double result = MEMORY[0x1BA9B6D80](v7, 0x1020C4016EE4530);
      }
      uint64_t v2 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

void sub_1B644FD88()
{
}

uint64_t sub_1B644FDC8(uint64_t result)
{
  if (result)
  {
    sub_1B644FE08(result);
    JUMPOUT(0x1BA9B6D80);
  }
  return result;
}

uint64_t sub_1B644FE08(uint64_t a1)
{
  sub_1B643670C(a1 + 24, *(void **)(a1 + 32));
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_1B644FE48(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  long long v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        long long v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      long long v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    BOOL v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    void v11[5] = 0;
    sub_1B644FF08(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *sub_1B644FF08(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  BOOL v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  double result = sub_1B644FF60(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1B644FF60(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            BOOL v9 = (uint64_t **)a2[2];
          }
          else
          {
            BOOL v9 = (uint64_t **)v2[1];
            unint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              void v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            uint64_t v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *BOOL v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), BOOL v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *BOOL v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t *sub_1B64500F8(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  int v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1B645016C(v6, a2);
  return v3;
}

uint64_t *sub_1B645016C(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  int v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *int v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0;
      double result = (uint64_t *)v2;
    }
    else
    {
      uint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *uint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      double result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *uint64_t v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        double result = v7;
      }
      uint64_t v7 = *(uint64_t **)(*v7 + 8);
    }
    uint64_t v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      uint64_t v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *uint64_t v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        uint64_t v7[2] = (uint64_t)v15;
        uint64_t v16 = v7;
      }
      else
      {
        uint64_t v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      void v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }
    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    uint64_t v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      double result = v7;
    }
    uint64_t v7 = *(uint64_t **)v12;
  }
  uint64_t v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  uint64_t v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    uint64_t v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *uint64_t v20 = (uint64_t)v7;
    uint64_t v7[2] = (uint64_t)v20;
    uint64_t v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  void v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t sub_1B64504F0()
{
  if (qword_1EB995468 != -1) {
    dispatch_once(&qword_1EB995468, &unk_1F0FB5788);
  }
  return qword_1EB995470;
}

void sub_1B6450534()
{
  if (!qword_1EB995470)
  {
    qword_1EB995470 = sub_1B63C8D10(&qword_1EB995470);
    qword_1EB981988 = (uint64_t)sub_1B6451330;
  }
}

uint64_t sub_1B645058C()
{
  if (qword_1EB995468 != -1) {
    dispatch_once(&qword_1EB995468, &unk_1F0FB5788);
  }
  uint64_t result = sub_1B63C8D44(qword_1EB995470, 0x98uLL);
  if (result)
  {
    *(unsigned char *)(result + 64) |= 1u;
    *(void *)(result + 80) = 0;
    *(void *)(result + 88) = 0;
  }
  return result;
}

CFHashCode sub_1B64505EC(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfileHashCode");
  }
  CFHashCode result = CFHash(cf);
  unint64_t v11 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * result) ^ ((0x9DDFEA08EB382D69 * result) >> 47));
  *(void *)(a1 + 152) = 0x9DDFEA08EB382D69 * (v11 ^ (v11 >> 47));
  return result;
}

uint64_t sub_1B6450668(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

void *sub_1B6450670(const void *a1, const void *a2)
{
  uint64_t v4 = (void *)sub_1B645058C();
  int v5 = (const void *)v4[10];
  if (v5 != a1)
  {
    if (v5)
    {
      CFRelease(v5);
      v4[10] = 0;
    }
    if (a1) {
      CFTypeRef v6 = CFRetain(a1);
    }
    else {
      CFTypeRef v6 = 0;
    }
    v4[10] = v6;
  }
  uint64_t v7 = (const void *)v4[11];
  if (v7 != a2)
  {
    if (v7)
    {
      CFRelease(v7);
      v4[11] = 0;
    }
    if (a2) {
      CFTypeRef v8 = CFRetain(a2);
    }
    else {
      CFTypeRef v8 = 0;
    }
    v4[11] = v8;
  }
  uint64_t v9 = (const void *)v4[12];
  if (v9)
  {
    CFRelease(v9);
    v4[12] = 0;
  }
  uint64_t v10 = (const void *)v4[13];
  if (v10)
  {
    CFRelease(v10);
    v4[13] = 0;
  }
  unint64_t v11 = (const void *)v4[14];
  if (v11)
  {
    CFRelease(v11);
    v4[14] = 0;
  }
  uint64_t v12 = (const void *)v4[15];
  if (v12)
  {
    CFRelease(v12);
    v4[15] = 0;
  }
  uint64_t v13 = (const void *)v4[18];
  if (v13)
  {
    CFRelease(v13);
    v4[18] = 0;
  }
  sub_1B6450760(v4);
  return v4;
}

CFHashCode sub_1B6450760(void *a1)
{
  uint64_t v2 = (const void *)a1[18];
  if (v2) {
    unint64_t v3 = 0x9DDFEA08EB382D69 * CFHash(v2);
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = (const void *)a1[10];
  if (v4) {
    CFHashCode v5 = CFHash(v4);
  }
  else {
    CFHashCode v5 = 0;
  }
  CFHashCode result = a1[11];
  if (result) {
    CFHashCode result = CFHash((CFTypeRef)result);
  }
  unint64_t v7 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47))) >> 47));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v7)));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  a1[19] = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v9 ^ ((0x9DDFEA08EB382D69 * (result ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (result ^ v9)))) ^ ((0x9DDFEA08EB382D69 * (v9 ^ ((0x9DDFEA08EB382D69 * (result ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (result ^ v9)))) >> 47));
  return result;
}

void *sub_1B6450820(const void *a1, const void *a2, const void *a3)
{
  CFTypeRef v6 = (void *)sub_1B645058C();
  unint64_t v7 = (const void *)v6[10];
  if (v7 != a1)
  {
    if (v7)
    {
      CFRelease(v7);
      v6[10] = 0;
    }
    if (a1) {
      CFTypeRef v8 = CFRetain(a1);
    }
    else {
      CFTypeRef v8 = 0;
    }
    v6[10] = v8;
  }
  unint64_t v9 = (const void *)v6[11];
  if (v9 != a2)
  {
    if (v9)
    {
      CFRelease(v9);
      v6[11] = 0;
    }
    if (a2) {
      CFTypeRef v10 = CFRetain(a2);
    }
    else {
      CFTypeRef v10 = 0;
    }
    v6[11] = v10;
  }
  unint64_t v11 = (const void *)v6[12];
  if (v11)
  {
    CFRelease(v11);
    v6[12] = 0;
  }
  uint64_t v12 = (const void *)v6[13];
  if (v12)
  {
    CFRelease(v12);
    v6[13] = 0;
  }
  uint64_t v13 = (const void *)v6[14];
  if (v13)
  {
    CFRelease(v13);
    v6[14] = 0;
  }
  uint64_t v14 = (const void *)v6[15];
  if (v14)
  {
    CFRelease(v14);
    v6[15] = 0;
  }
  uint64_t v15 = (const void *)v6[18];
  if (v15 != a3)
  {
    if (v15)
    {
      CFRelease(v15);
      v6[18] = 0;
    }
    if (a3) {
      CFTypeRef v16 = CFRetain(a3);
    }
    else {
      CFTypeRef v16 = 0;
    }
    v6[18] = v16;
  }
  sub_1B6450760(v6);
  return v6;
}

uint64_t sub_1B6450934(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, int a7, int a8)
{
  uint64_t v16 = sub_1B645058C();
  uint64_t v17 = *(const void **)(v16 + 80);
  if (v17 != a1)
  {
    if (v17)
    {
      CFRelease(v17);
      *(void *)(v16 + 80) = 0;
    }
    if (a1) {
      CFTypeRef v18 = CFRetain(a1);
    }
    else {
      CFTypeRef v18 = 0;
    }
    *(void *)(v16 + 80) = v18;
  }
  uint64_t v19 = *(const void **)(v16 + 88);
  if (v19 != a2)
  {
    if (v19)
    {
      CFRelease(v19);
      *(void *)(v16 + 88) = 0;
    }
    if (a2) {
      CFTypeRef v20 = CFRetain(a2);
    }
    else {
      CFTypeRef v20 = 0;
    }
    *(void *)(v16 + 88) = v20;
  }
  BOOL v21 = *(const void **)(v16 + 96);
  if (v21 != a3)
  {
    if (v21)
    {
      CFRelease(v21);
      *(void *)(v16 + 96) = 0;
    }
    if (a3) {
      CFTypeRef v22 = CFRetain(a3);
    }
    else {
      CFTypeRef v22 = 0;
    }
    *(void *)(v16 + 96) = v22;
  }
  uint64_t v23 = *(const void **)(v16 + 104);
  if (v23 != a4)
  {
    if (v23)
    {
      CFRelease(v23);
      *(void *)(v16 + 104) = 0;
    }
    if (a4) {
      CFTypeRef v24 = CFRetain(a4);
    }
    else {
      CFTypeRef v24 = 0;
    }
    *(void *)(v16 + 104) = v24;
  }
  uint64_t v25 = *(const void **)(v16 + 112);
  if (v25 != a5)
  {
    if (v25)
    {
      CFRelease(v25);
      *(void *)(v16 + 112) = 0;
    }
    if (a5) {
      CFTypeRef v26 = CFRetain(a5);
    }
    else {
      CFTypeRef v26 = 0;
    }
    *(void *)(v16 + 112) = v26;
  }
  uint64_t v27 = *(const void **)(v16 + 120);
  if (v27 != a6)
  {
    if (v27)
    {
      CFRelease(v27);
      *(void *)(v16 + 120) = 0;
    }
    if (a6) {
      CFTypeRef v28 = CFRetain(a6);
    }
    else {
      CFTypeRef v28 = 0;
    }
    *(void *)(v16 + 120) = v28;
  }
  long long v29 = *(const void **)(v16 + 144);
  if (v29)
  {
    CFRelease(v29);
    *(void *)(v16 + 144) = 0;
  }
  *(_DWORD *)(v16 + 160) = a7;
  if (a8) {
    sub_1B6450ADC((void *)v16);
  }
  return v16;
}

void sub_1B6450ADC(void *a1)
{
  uint64_t v10 = 0;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x4800000000;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v16 = 0;
  uint64_t v13 = a1;
  uint64_t v2 = (const void *)a1[10];
  if (v2) {
    uint64_t v2 = (const void *)CFHash(v2);
  }
  *(void *)&long long v14 = v2;
  unint64_t v3 = (const void *)a1[11];
  if (v3) {
    unint64_t v3 = (const void *)CFHash(v3);
  }
  *((void *)&v14 + 1) = v3;
  uint64_t v4 = (const void *)a1[12];
  if (v4) {
    uint64_t v4 = (const void *)CFHash(v4);
  }
  long long v15 = (unint64_t)v4;
  CFHashCode v5 = (const void *)a1[18];
  if (v5) {
    CFHashCode v5 = (const void *)CFHash(v5);
  }
  uint64_t v16 = v5;
  CFDictionaryRef v6 = (const __CFDictionary *)a1[14];
  if (v6)
  {
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    uint64_t v9[2] = sub_1B645134C;
    v9[3] = &unk_1E61421A8;
    v9[4] = &v10;
    sub_1B63CCADC(v6, (uint64_t)v9);
  }
  uint64_t v7 = 0;
  unint64_t v8 = 0x3EDF6BA1375BCBF0;
  do
  {
    unint64_t v8 = 0xC6A4A7935BD1E995
       * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v11[v7 + 3]) ^ ((0xC6A4A7935BD1E995 * v11[v7 + 3]) >> 47))) ^ v8);
    ++v7;
  }
  while (v7 != 6);
  a1[19] = (0xC6A4A7935BD1E995 * (v8 ^ (v8 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v8 ^ (v8 >> 47))) >> 47);
  _Block_object_dispose(&v10, 8);
}

uint64_t sub_1B6450C34(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(void *)(a1 + 8 * a2 + 80);
}

CFHashCode sub_1B6450C88(void *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  uint64_t v10 = (const void *)a1[12];
  if (v10)
  {
    CFRelease(v10);
    a1[12] = 0;
  }
  CFTypeRef v11 = (CFTypeRef)a1[18];
  if (v11 != cf)
  {
    if (v11)
    {
      CFRelease(v11);
      a1[18] = 0;
    }
    if (cf) {
      CFTypeRef v12 = CFRetain(cf);
    }
    else {
      CFTypeRef v12 = 0;
    }
    a1[18] = v12;
  }

  return sub_1B6450760(a1);
}

CFTypeRef sub_1B6450D28(uint64_t a1, int a2, CFTypeRef cf, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)cf, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  uint64_t v11 = a1 + 8 * a2;
  CFTypeRef v14 = *(CFTypeRef *)(v11 + 80);
  uint64_t v13 = (void *)(v11 + 80);
  CFTypeRef result = v14;
  if (v14 != cf)
  {
    if (result)
    {
      CFRelease(result);
      *uint64_t v13 = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *uint64_t v13 = result;
  }
  return result;
}

uint64_t sub_1B6450DB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(void *)(a1 + 96);
}

uint64_t sub_1B6450E00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(void *)(a1 + 104);
}

uint64_t sub_1B6450E4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(void *)(a1 + 112);
}

uint64_t sub_1B6450E98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(void *)(a1 + 120);
}

uint64_t sub_1B6450EE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(unsigned int *)(a1 + 160);
}

uint64_t sub_1B6450F30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(void *)(a1 + 128);
}

uint64_t sub_1B6450F7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return *(void *)(a1 + 136);
}

void sub_1B6450FC8(uint64_t a1, void *key, void *value)
{
  CFMutableArrayRef Mutable = *(__CFDictionary **)(a1 + 136);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(a1 + 136) = Mutable;
  }
  if (value)
  {
    CFDictionarySetValue(Mutable, key, value);
  }
  else
  {
    CFDictionaryRemoveValue(Mutable, key);
  }
}

uint64_t sub_1B6451064(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

uint64_t sub_1B645106C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  return (*(unsigned __int8 *)(a1 + 64) >> 1) & 1;
}

void sub_1B64510BC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"program");
  }
  if (a2) {
    char v10 = 2;
  }
  else {
    char v10 = 0;
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 64) & 0xFD | v10;
}

uint64_t sub_1B6451124(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"programDelegate");
  }
  return a1 + 16;
}

uint64_t sub_1B6451170(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"programDelegate");
  }
  return *(void *)(a1 + 32);
}

id sub_1B64511C0(void *a1)
{
  uint64_t v2 = 0;
  unsigned int valuePtr = a1;
  char v3 = 1;
  do
  {
    char v4 = v3;
    CFHashCode v5 = (const void *)a1[v2 + 10];
    if (v5) {
      CFRelease(v5);
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  CFDictionaryRef v6 = (const void *)a1[17];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[12];
  if (v7)
  {
    CFRelease(v7);
    a1[12] = 0;
  }
  unint64_t v8 = (const void *)a1[13];
  if (v8)
  {
    CFRelease(v8);
    a1[13] = 0;
  }
  unint64_t v9 = (const void *)a1[14];
  if (v9)
  {
    CFRelease(v9);
    a1[14] = 0;
  }
  char v10 = (const void *)a1[15];
  if (v10)
  {
    CFRelease(v10);
    a1[15] = 0;
  }
  uint64_t v11 = (const void *)a1[16];
  if (v11)
  {
    CFRelease(v11);
    a1[16] = 0;
  }
  CFTypeRef v12 = (const void *)a1[18];
  if (v12)
  {
    CFRelease(v12);
    a1[18] = 0;
  }
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kCFXNotificationProgramWillDie", v13, 0, 1u);
  CFRelease(v13);
  uint64_t v22 = (uint64_t)valuePtr;
  if (valuePtr[9])
  {
    CFRelease((CFTypeRef)valuePtr[9]);
    uint64_t v22 = (uint64_t)valuePtr;
    valuePtr[9] = 0;
  }
  return sub_1B658325C(v22, v15, v16, v17, v18, v19, v20, v21);
}

CFStringRef sub_1B64512E0(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
}

CFMutableArrayRef sub_1B6451330()
{
  return CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
}

CFHashCode sub_1B645134C(uint64_t a1, CFTypeRef cf, const void *a3)
{
  CFHashCode v5 = CFHash(cf);
  CFHashCode result = CFHash(a3);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v8 = 0x9DDFEA08EB382D69
     * (*(void *)(v7 + 56) ^ ((0x9DDFEA08EB382D69 * (*(void *)(v7 + 56) ^ v5)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                             * (*(void *)(v7 + 56) ^ v5)));
  *(void *)(v7 + 56) = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v10 = *(void *)(v9 + 56);
  *(void *)(v9 + 56) = 0x9DDFEA08EB382D69
                       * ((0x9DDFEA08EB382D69
                         * (v10 ^ ((0x9DDFEA08EB382D69 * (v10 ^ result)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                   * (v10 ^ result)))) ^ ((0x9DDFEA08EB382D69 * (v10 ^ ((0x9DDFEA08EB382D69 * (v10 ^ result)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ result)))) >> 47));
  return result;
}

double sub_1B64513F4@<D0>(_OWORD *a1@<X8>)
{
  *a1 = xmmword_1B6E50BC0;
  *(void *)&double result = 4294902016;
  *(_OWORD *)((char *)a1 + 12) = *(long long *)((char *)&xmmword_1B6E50BC0 + 12);
  return result;
}

unint64_t sub_1B6451410(int *a1)
{
  uint64x2_t v1 = (uint64x2_t)vdupq_n_s64(a1[5] | ((unint64_t)(*((unsigned __int16 *)a1 + 12) | (*((unsigned __int8 *)a1 + 26) << 16)) << 32));
  int8x16_t v2 = vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v1, (uint64x2_t)xmmword_1B6E50B80), (int8x16_t)xmmword_1B6E50BB0), vandq_s8((int8x16_t)vshlq_u64(v1, (uint64x2_t)xmmword_1B6E50B90), (int8x16_t)xmmword_1B6E50BA0));
  return *((unsigned __int8 *)a1 + 8) | (2 * *((unsigned __int8 *)a1 + 9)) | (4 * *((unsigned __int8 *)a1 + 10)) | (32 * *((unsigned __int8 *)a1 + 11)) | ((unint64_t)*((unsigned __int8 *)a1 + 12) << 6) | *a1 | ((((unint64_t)*(unsigned int *)((char *)a1 + 13) >> 5) & 0x7FFF8 | *(int *)((char *)a1 + 13) | ((unint64_t)*(_WORD *)((char *)a1 + 17) << 19) | (*(unsigned __int16 *)((char *)a1 + 17) << 14) & 0x3FC00000 | (*((unsigned __int8 *)a1 + 19) << 25) & 0x7FFFFFFE000000) << 9) | ((unint64_t)(vorr_s8(*(int8x8_t *)v2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL)).u32[0] | a1[5]) << 37);
}

uint64_t sub_1B64514E4(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B6451514(uint64_t a1)
{
  if (qword_1EB995650 != -1) {
    dispatch_once(&qword_1EB995650, &unk_1F0FB57A8);
  }
  if (!*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 10) = 1;
  }
  if (*(unsigned char *)(a1 + 11))
  {
    if (*(unsigned char *)(a1 + 12)) {
      goto LABEL_10;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 13) = 16776961;
    *(unsigned char *)(a1 + 12) = 0;
  }
  *(_DWORD *)(a1 + 23) = 0;
  *(_DWORD *)(a1 + 20) = 16776961;
LABEL_10:
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB986168);
  if (qword_1EB996E78 != -1) {
    dispatch_once_f(&qword_1EB996E78, &qword_1EB995658, (dispatch_function_t)sub_1B64514E4);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1EB995658, 0x20uLL);
  long long v3 = *(_OWORD *)(a1 + 12);
  *(_OWORD *)(v2 + 16) = *(_OWORD *)a1;
  *(_OWORD *)(v2 + 28) = v3;
  CFNumberRef Value = CFSetGetValue((CFSetRef)qword_1EB995F98, (const void *)v2);
  if (Value)
  {
    uint64_t v5 = (uint64_t)Value;
    CFRetain(Value);
    sub_1B64516BC((CFTypeRef)v2);
    uint64_t v2 = v5;
  }
  else
  {
    CFSetSetValue((CFMutableSetRef)qword_1EB995F98, (const void *)v2);
    *(unsigned char *)(v2 + 44) = 1;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB986168);
  return v2;
}

CFMutableSetRef sub_1B6451664()
{
  long long v0 = *(_OWORD *)(MEMORY[0x1E4F1D548] + 16);
  *(_OWORD *)&v2.version = *MEMORY[0x1E4F1D548];
  *(_OWORD *)&v2.release = v0;
  *(_OWORD *)&v2.equal = *(_OWORD *)(MEMORY[0x1E4F1D548] + 32);
  v2.retain = 0;
  v2.release = 0;
  CFMutableSetRef result = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &v2);
  qword_1EB995F98 = (uint64_t)result;
  return result;
}

void sub_1B64516BC(CFTypeRef cf)
{
  if (cf)
  {
    if (*((unsigned char *)cf + 44))
    {
      os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB986168);
      CFRelease(cf);
      os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB986168);
    }
    else
    {
      CFRelease(cf);
    }
  }
}

__n128 sub_1B6451740@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a2, a3, a4, a5, a6, a7, (uint64_t)"states");
  }
  *(_OWORD *)a8 = *(_OWORD *)(a1 + 16);
  __n128 result = *(__n128 *)(a1 + 28);
  *(__n128 *)(a8 + 12) = result;
  return result;
}

uint64_t sub_1B645179C()
{
  uint64_t result = qword_1E9DDACB8;
  if (!qword_1E9DDACB8)
  {
    v1[0] = xmmword_1B6E50BC0;
    *(_OWORD *)((char *)v1 + 12) = *(long long *)((char *)&xmmword_1B6E50BC0 + 12);
    uint64_t result = sub_1B6451514((uint64_t)v1);
    qword_1E9DDACB8 = result;
  }
  return result;
}

void sub_1B64517F4(unsigned char *a1)
{
  if (a1[44])
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)&unk_1EB986168)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Calling CFXRasterizerStatesCFFinalize outside of CFXReleaseRasterizerStates probably direct call to CFRelease", v2, v3, v4, v5, v6, v7, (uint64_t)"!vfx_mutex_trylock(&s_RasterizerStatesRegistryLock)");
    }
    if (!CFSetContainsValue((CFSetRef)qword_1EB995F98, a1)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. RasterizerStates should be in the registry", v8, v9, v10, v11, v12, v13, (uint64_t)"CFSetContainsValue(s_RasterizerStatesRegistry, cf)");
    }
    CFSetRemoveValue((CFMutableSetRef)qword_1EB995F98, a1);
    sub_1B6595A0C(@"kCFXNotificationRasterizerStatesDidDie", a1, 0, 1u);
  }
}

BOOL sub_1B64518C4(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 16) == *(void *)(a2 + 16)
      && *(void *)(a1 + 24) == *(void *)(a2 + 24)
      && *(void *)(a1 + 32) == *(void *)(a2 + 32)
      && *(_DWORD *)(a1 + 40) == (unint64_t)*(unsigned int *)(a2 + 40);
}

unint64_t sub_1B64518F4(uint64_t a1)
{
  return sub_1B6451410((int *)(a1 + 16));
}

CFStringRef sub_1B6451900(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXRasterizerStates %p> ZRead:%d ZWrite:%d ZFunc:%d cull:%d fill:%d", a1, *(unsigned __int8 *)(a1 + 24), *(unsigned __int8 *)(a1 + 25), *(unsigned __int8 *)(a1 + 26), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

uint64_t sub_1B6451958(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B6451988(char a1)
{
  if (qword_1E9DDACC8 != -1) {
    dispatch_once_f(&qword_1E9DDACC8, &qword_1E9DDACC0, (dispatch_function_t)sub_1B6451958);
  }
  uint64_t v8 = sub_1B63C8D44(qword_1E9DDACC0, 0x30uLL);
  if (!v8) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v2, v3, v4, v5, v6, v7, (uint64_t)"t");
  }
  *(unsigned char *)(v8 + 56) = a1;
  return v8;
}

uint64_t sub_1B6451A24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"imageProxy");
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 16);
  if (!v11) {
    return 0;
  }
  uint64_t result = v11(a3, a2, *(void *)(a1 + 48));
  if (result) {
    *(void *)(result + 88) = a1;
  }
  return result;
}

uint64_t sub_1B6451AA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"imageProxy");
  }
  return *(void *)(a1 + 48);
}

uint64_t sub_1B6451AF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"imageProxy");
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t))(a1 + 32);
  if (!v9) {
    return 1;
  }
  uint64_t v10 = *(void *)(a1 + 48);

  return v9(v10);
}

uint64_t sub_1B6451B68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"imageProxy");
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40);
  if (!v12)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, 0, a6, a7, a8, (uint64_t)"imageProxy->_callbacks.getCaptureDeviceInfo");
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40);
  }
  uint64_t v13 = *(void *)(a1 + 48);

  return v12(v13, a2, a3, a4);
}

uint64_t sub_1B6451C0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"imageProxy");
  }
  return *(unsigned __int8 *)(a1 + 56);
}

CFTypeRef sub_1B6451C58(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"imageProxy");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 48);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 48) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 48) = result;
    *(unsigned char *)(a1 + 56) = v8;
  }
  return result;
}

__n128 sub_1B6451CE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"imageProxy");
  }
  __n128 result = *(__n128 *)a2;
  long long v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 32) = v11;
  return result;
}

uint64_t sub_1B6451D38(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B6451D68()
{
  if (qword_1E9DDACD8 != -1) {
    dispatch_once_f(&qword_1E9DDACD8, &qword_1E9DDACD0, (dispatch_function_t)sub_1B6451D38);
  }
  uint64_t v6 = sub_1B63C8D44(qword_1E9DDACD0, 0x50uLL);
  if (!v6) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v0, v1, v2, v3, v4, v5, (uint64_t)"t");
  }
  return v6;
}

uint64_t sub_1B6451DFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"t");
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 64);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 80);

  return v12(a2, v13, a3, a4);
}

CFTypeRef sub_1B6451E98(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureProxy");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 80);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 80) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 80) = result;
  }
  return result;
}

uint64_t sub_1B6451F14(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

void sub_1B6451F1C(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"textureProxy");
  }
  uint64_t v10 = (_OWORD *)(a1 + 64);
  if (a2)
  {
    *uint64_t v10 = *a2;
  }
  else
  {
    *(void *)uint64_t v10 = 0;
    *(void *)(a1 + 72) = 0;
  }
}

void sub_1B6451F84(uint64_t a1)
{
  uint64_t valuePtr = a1;
  CFNumberRef v1 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"kCFXNotificationImageProxyWillDie", v1, 0, 1u);
  CFRelease(v1);
  uint64_t v3 = *(const void **)(valuePtr + 48);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(valuePtr + 48) = 0;
  }
}

CFStringRef sub_1B6452000(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXImageProxy>");
}

CFStringRef sub_1B6452034(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXImageProxy>");
}

void sub_1B645206C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 80);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 80) = 0;
  }
}

CFStringRef sub_1B645209C(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXTextureProxy>");
}

CFStringRef sub_1B64520D0(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXTextureProxy>");
}

uint64_t vfx_attribute_memory(uint64_t result, task_t a2)
{
  if (!*(unsigned char *)(result + 20))
  {
    if (a2)
    {
      uint64_t v2 = result;
      CFTypeRef result = *(unsigned int *)(result + 16);
      if (result)
      {
        if (mach_memory_entry_ownership(result, a2, 4, 0)) {
          sub_1B6B34168(16);
        }
        CFTypeRef result = mach_port_deallocate(*MEMORY[0x1E4F14960], *(_DWORD *)(v2 + 16));
        *(_DWORD *)(v2 + 16) = 0;
      }
    }
  }
  return result;
}

uint64_t sub_1B6452170(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t *sub_1B64521A0(uint64_t a1)
{
  if (qword_1E9DDACE8 != -1) {
    dispatch_once_f(&qword_1E9DDACE8, &qword_1E9DDACE0, (dispatch_function_t)sub_1B6452170);
  }
  uint64_t v2 = (uint64_t *)sub_1B63C8D44(qword_1E9DDACE0, 0x80uLL);
  v2[5] = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  v2[12] = (uint64_t)sub_1B661AE84();
  v2[2] = a1;
  if (v2[3])
  {
    sub_1B63F2F54(0, @"Warning: Warning _lightNodes not NULL in CFXEnginePipelineSetup", v3, v4, v5, v6, v7, v8, v19);
    uint64_t v9 = (const void *)v2[3];
    if (v9)
    {
      CFRelease(v9);
      v2[3] = 0;
    }
  }
  sub_1B6595954(v2, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))sub_1B64534D4, @"kCFXNotificationNodeWillDie", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  if (!v2[4])
  {
    uint64_t v10 = (unsigned char *)sub_1B6585380(v2[2]);
    v2[4] = (uint64_t)v10;
    sub_1B65858A4(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  return v2;
}

void sub_1B64522AC(uint64_t a1, void *a2, void *cf1, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, a4, a5, a6, a7, a8, (uint64_t)"attribute");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"attribute");
  }
  if (CFEqual(cf1, @"model")
    || CFEqual(cf1, @"kCameraKey")
    || CFEqual(cf1, @"kLightKey")
    || CFEqual(cf1, @"kDeformerStackKey"))
  {
    CFRetain(a2);
    if (CFEqual(cf1, @"model"))
    {
LABEL_18:
      if (CFEqual(cf1, @"model") || CFEqual(cf1, @"kLightKey"))
      {
        if (CFEqual(cf1, @"model"))
        {
          char v51 = 0;
        }
        else if (CFEqual(cf1, @"kLightKey"))
        {
          char v51 = 3;
        }
        else
        {
          sub_1B63F2F54(16, @"Unreachable code: Unsupported node attribute '%@'", v45, v46, v47, v48, v49, v50, (uint64_t)cf1);
          char v51 = -1;
        }
        int v52 = sub_1B64A0374((uint64_t)a2, v44, v45, v46, v47, v48, v49, v50);
        if (!v52 || ((1 << v51) & v52) != 0)
        {
          uint64_t v60 = *(void *)(a4 + 8);
          uint64_t v61 = sub_1B63F4F54(a2, v53, v54, v55, v56, v57, v58, v59);
          if (v61 == sub_1B644558C(v60, v62, v63, v64, v65, v66, v67, v68)
            && !sub_1B64A3178((uint64_t)a2, v69, v70, v71, v72, v73, v74, v75))
          {
            sub_1B645251C(a1, v60, (uint64_t)a2, v76, v77, v78, v79, v80);
          }
        }
      }
      CFRelease(a2);
      return;
    }
    uint64_t v31 = (uint64_t)sub_1B6583734((uint64_t)a2, cf1, v18, v19, v20, v21, v22, v23);
    if (!v31)
    {
      if (!CFEqual(cf1, @"kDeformerStackKey"))
      {
        if (sub_1B649F390((uint64_t)a2, v32, v33, v34, v35, v36, v37, v38)) {
          goto LABEL_18;
        }
        goto LABEL_17;
      }
      uint64_t v31 = sub_1B649F5A8((uint64_t)a2, v32, v33, v34, v35, v36, v37, v38);
    }
    if (sub_1B649F390((uint64_t)a2, v24, v25, v26, v27, v28, v29, v30))
    {
      if (!v31) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
    if (v31)
    {
      sub_1B645375C(a1, a2, cf1, v39, v40, v41, v42, v43);
      goto LABEL_18;
    }
LABEL_17:
    sub_1B645398C(a1, a2, cf1, v39, v40, v41, v42, v43);
    goto LABEL_18;
  }
}

void sub_1B645251C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(unsigned int *)(a3 + 228);
  if (v11)
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      uint64_t v13 = (_WORD *)sub_1B661BFA4(*(void *)(a1 + 96), *(void *)(a3 + 224), i, a4, a5, a6, a7, a8);
      sub_1B645383C(a1, v13, v14, v15, v16, v17, v18, v19);
    }
  }
  uint64_t v20 = *(_WORD **)(a3 + 232);
  if (v20)
  {
    uint64_t v21 = (unsigned __int16)*v20;
    if (*v20)
    {
      uint64_t v22 = 0;
      do
      {
        uint64_t v23 = *(void *)(a3 + 232) + 12 * v22;
        uint64_t v24 = *(unsigned int *)(v23 + 16);
        if (v24)
        {
          uint64_t v25 = 0;
          unint64_t v26 = *(unsigned int *)(v23 + 12) | (unint64_t)(v24 << 32);
          do
          {
            uint64_t v27 = (_WORD *)sub_1B661BFA4(*(void *)(a1 + 96), v26, v25, a4, a5, a6, a7, a8);
            if (v27) {
              sub_1B645383C(a1, v27, a3, a4, a5, a6, a7, a8);
            }
            ++v25;
          }
          while (v24 != v25);
        }
        ++v22;
      }
      while (v22 != v21);
    }
  }
  sub_1B661BCD8(a1, a3, a3, a4, a5, a6, a7, a8);
  if ((sub_1B649F390(a3, v28, v29, v30, v31, v32, v33, v34) & 1) == 0)
  {
    uint64_t v42 = sub_1B64A0374(a3, v35, v36, v37, v38, v39, v40, v41);
    if (v42)
    {
      sub_1B6453A80(a1, a2, a3, v42, v43, v44, v45, v46);
    }
  }
}

uint64_t sub_1B6452668(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  sub_1B661AF20(*(void *)(a1 + 96), a2, a3, a4, a5, a6, a7, a8);
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = sub_1B6452704;
    v18[3] = &unk_1E61421E8;
    v18[4] = a2;
    int v19 = v8;
    return sub_1B64B0E00(result, (uint64_t)v18, v11, v12, v13, v14, v15, v16);
  }
  return result;
}

void *sub_1B6452704(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B6446190(a2, a2, a3, a4, a5, a6, a7, a8);
  sub_1B63F6D34(v10, *(unsigned int **)(a1 + 32), *(unsigned int *)(a1 + 40), v11, v12, v13, v14, v15);
  uint64_t v23 = sub_1B64461DC(a2, v16, v17, v18, v19, v20, v21, v22);
  uint64_t v30 = *(unsigned int **)(a1 + 32);

  return sub_1B6512CCC(v23, v30, v24, v25, v26, v27, v28, v29);
}

uint64_t sub_1B6452758(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return sub_1B64B0E00(result, (uint64_t)&unk_1F0FB57C8, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B6452770(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B6446190(a2, a2, a3, a4, a5, a6, a7, a8);
  sub_1B63F69D4(v9);
  uint64_t v17 = sub_1B64461DC(a2, v10, v11, v12, v13, v14, v15, v16);

  return sub_1B65126E8(v17);
}

uint64_t sub_1B64527B4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  uint64_t v8 = a1[1];
  uint64_t result = sub_1B644558C(v8, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v17 = result;
    for (int i = 0; i != 4; ++i)
    {
      uint64_t result = sub_1B64B36FC(v17, i, v11, v12, v13, v14, v15, v16);
      if (result)
      {
        v19[0] = MEMORY[0x1E4F143A8];
        v19[1] = 3221225472;
        v19[2] = sub_1B645287C;
        v19[3] = &unk_1E6142228;
        v19[4] = v9;
        v19[5] = v8;
        uint64_t result = sub_1B64A18A4(result, (uint64_t)v19);
      }
    }
  }
  return result;
}

uint64_t sub_1B645287C(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B64528B8(*(void *)(a1 + 32), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  sub_1B64529BC(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, v10, v11, v12, v13, v14);
  return 0;
}

void sub_1B64528B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(unsigned int *)(a2 + 228);
  if (v10)
  {
    for (uint64_t i = 0; i != v10; ++i)
    {
      uint64_t v12 = (_WORD *)sub_1B661BFA4(*(void *)(a1 + 96), *(void *)(a2 + 224), i, a4, a5, a6, a7, a8);
      sub_1B645383C(a1, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  uint64_t v19 = *(_WORD **)(a2 + 232);
  if (v19)
  {
    uint64_t v20 = (unsigned __int16)*v19;
    if (*v19)
    {
      uint64_t v21 = 0;
      do
      {
        uint64_t v22 = *(void *)(a2 + 232) + 12 * v21;
        uint64_t v23 = *(unsigned int *)(v22 + 16);
        if (v23)
        {
          uint64_t v24 = 0;
          unint64_t v25 = *(unsigned int *)(v22 + 12) | (unint64_t)(v23 << 32);
          do
          {
            uint64_t v26 = (_WORD *)sub_1B661BFA4(*(void *)(a1 + 96), v25, v24, a4, a5, a6, a7, a8);
            if (v26) {
              sub_1B645383C(a1, v26, a3, a4, a5, a6, a7, a8);
            }
            ++v24;
          }
          while (v23 != v24);
        }
        ++v21;
      }
      while (v21 != v20);
    }
  }
  sub_1B6453904(a1, (const void *)a2, a3, a4, a5, a6, a7, a8);

  sub_1B661BCD8(a1, a2, v27, v28, v29, v30, v31, v32);
}

uint64_t sub_1B64529BC(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B64A3178((uint64_t)a3, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if ((result & 1) == 0 && !a3[57])
  {
    uint64_t result = sub_1B64A0374((uint64_t)a3, v12, v13, v14, v15, v16, v17, v18);
    if (result)
    {
      sub_1B6453A80(a1, a2, (uint64_t)a3, result, v19, v20, v21, v22);
      return sub_1B6453688(a1, a3, v23, v24, v25, v26, v27, v28);
    }
  }
  return result;
}

void sub_1B6452A48(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B644558C(a1[1], a2, a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    CFDictionaryRef v17 = (const __CFDictionary *)sub_1B64B1100(v9, v10, v11, v12, v13, v14, v15, v16);
    if (v17)
    {
      CFDictionaryApplyFunction(v17, (CFDictionaryApplierFunction)sub_1B6452AAC, a1);
    }
  }
}

CFDictionaryRef sub_1B6452AAC(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef result = sub_1B64A04D4((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v19 = a3;
    uint64_t v17 = *a3;
    uint64_t v18 = v19[1];
    sub_1B64528B8(v17, (uint64_t)a1, v11, v12, v13, v14, v15, v16);
    return (const __CFDictionary *)sub_1B64529BC(v17, v18, a1, v20, v21, v22, v23, v24);
  }
  return result;
}

void sub_1B6452B1C(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a2;
  uint64_t v11 = *a3;
  uint64_t v12 = a3[1];
  if (a2 == 1)
  {
    if ((a2 & 0x40000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    sub_1B64528B8(v11, (uint64_t)a1, (uint64_t)a3, a4, a5, a6, a7, a8);
    sub_1B64529BC(v11, v12, a1, v13, v14, v15, v16, v17);
    if ((v9 & 0x80000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. wrong notification type", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"notifications._eventType == kCFXNotificationEventType_Node");
  if ((v9 & 0x40000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v9 & 0x80000) == 0) {
    goto LABEL_10;
  }
LABEL_7:
  uint64_t v18 = sub_1B63F4F54(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (sub_1B64A3BCC((uint64_t)a1)) {
    sub_1B6445F58(a3[1], 0, v20, v21, v22, v23, v24, v25);
  }
  if (v18 != sub_1B644558C(a3[1], v19, v20, v21, v22, v23, v24, v25))
  {
LABEL_10:
    if ((v9 & 0x1F000) == 0) {
      goto LABEL_16;
    }
    if ((v9 & 0x1000) != 0)
    {
      sub_1B64522AC(v11, a1, @"model", (uint64_t)a3, a5, a6, a7, a8);
      if ((v9 & 0x2000) == 0)
      {
LABEL_13:
        if ((v9 & 0x4000) == 0) {
          goto LABEL_14;
        }
        goto LABEL_23;
      }
    }
    else if ((v9 & 0x2000) == 0)
    {
      goto LABEL_13;
    }
    sub_1B64522AC(v11, a1, @"kCameraKey", (uint64_t)a3, a5, a6, a7, a8);
    sub_1B6445F58(a3[1], 0, v27, v28, v29, v30, v31, v32);
    if ((v9 & 0x4000) == 0)
    {
LABEL_14:
      if ((v9 & 0x10000) == 0) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
LABEL_23:
    sub_1B64522AC(v11, a1, @"kLightKey", (uint64_t)a3, a5, a6, a7, a8);
    if ((v9 & 0x10000) == 0)
    {
LABEL_16:
      uint64_t v26 = (v9 >> 9) & 4 | (v9 >> 7) & 8;
      if (v26)
      {
        sub_1B6452D0C(v11, (uint64_t)a1, v26, a4, a5, a6, a7, a8);
      }
      return;
    }
LABEL_15:
    sub_1B64522AC(v11, a1, @"kDeformerStackKey", (uint64_t)a3, a5, a6, a7, a8);
    goto LABEL_16;
  }

  sub_1B64529BC(v11, v12, a1, a4, a5, a6, a7, a8);
}

uint64_t sub_1B6452D0C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a2 + 228);
  if (v8)
  {
    uint64_t v10 = result;
    uint64_t v11 = 0;
    uint64_t v12 = *(void *)(result + 96);
    unint64_t v13 = *(unsigned int *)(a2 + 224) | (unint64_t)(v8 << 32);
    do
    {
      uint64_t v14 = sub_1B661BFA4(v12, v13, v11, a4, a5, a6, a7, a8);
      CFDictionaryRef result = sub_1B6452668(v10, v14, a3, v15, v16, v17, v18, v19);
      ++v11;
    }
    while (v8 != v11);
  }
  return result;
}

void sub_1B6452D84(void *key, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  context[2] = *MEMORY[0x1E4F143B8];
  if (a2 == 2)
  {
    if ((a2 & 0x200) != 0)
    {
      CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)a3 + 40), key);
      if (Value)
      {
        CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Value);
        context[0] = a3;
        context[1] = key;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)sub_1B6452E64, context);
        CFRelease(Copy);
      }
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong notification type", a3, a4, a5, a6, a7, a8, (uint64_t)"notifications._eventType == kCFXNotificationEventType_Material");
  }
}

uint64_t sub_1B6452E64(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"value");
  }
  uint64_t v10 = *a2;
  if (!*a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineIterationContext");
  }
  uint64_t v11 = (float32x4_t *)sub_1B63F1678(a1);
  if (v11)
  {
    uint64_t v19 = (uint64_t)v11;
    sub_1B649F73C(v11, v12, v13, v14, v15, v16, v17, v18);
    uint64_t v27 = sub_1B644558C(v10[1], v20, v21, v22, v23, v24, v25, v26);
    if (v27)
    {
      uint64_t v30 = sub_1B64B28FC(v27, v28, v29, v14, v15, v16, v17, v18);
      sub_1B66268A8(v30, v19, v31, v32, v33, v34, v35, v36);
    }
  }
  uint64_t v37 = *v10;

  return sub_1B6452668(v37, a1, 27, v14, v15, v16, v17, v18);
}

void sub_1B6452F24(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a2;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  long long v20 = *a3;
  if (a2 == 3)
  {
    if ((a2 & 0x400) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong notification type", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"notifications._eventType == kCFXNotificationEventType_Geometry");
    if ((v8 & 0x400) == 0)
    {
LABEL_3:
      if ((v8 & 0x800) == 0) {
        return;
      }
      goto LABEL_4;
    }
  }
  long long v21 = xmmword_1F0FBAC28;
  uint64_t v22 = qword_1F0FBAC38;
  *(void *)&long long v23 = v20;
  *((void *)&v23 + 1) = a1;
  uint64_t v15 = sub_1B64B1FBC(*(void *)(v20 + 16), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  sub_1B63F3570(v15, (uint64_t (**)(uint64_t, uint64_t))&v21, 0, (uint64_t)&v23, v16, v17, v18, v19);
  if ((v8 & 0x800) == 0) {
    return;
  }
LABEL_4:
  long long v21 = xmmword_1F0FBAC40;
  uint64_t v22 = qword_1F0FBAC50;
  long long v23 = v20;
  uint64_t v24 = a1;
  uint64_t v10 = sub_1B64B1FBC(*(void *)(v20 + 16), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  sub_1B63F3570(v10, (uint64_t (**)(uint64_t, uint64_t))&v21, 0, (uint64_t)&v23, v11, v12, v13, v14);
}

uint64_t sub_1B6453040(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  if (sub_1B649F5F4(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) == v10) {
    sub_1B6452D0C(v9, a1, 3, v11, v12, v13, v14, v15);
  }
  return 0;
}

uint64_t sub_1B645308C(_DWORD *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  uint64_t v11 = a2[2];
  if (sub_1B649F5F4((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) == v11)
  {
    sub_1B64528B8(v9, (uint64_t)a1, v12, v13, v14, v15, v16, v17);
    sub_1B64529BC(v9, v10, a1, v18, v19, v20, v21, v22);
  }
  return 0;
}

void sub_1B64530E8(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a2;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  long long v10 = *a3;
  if (a2 != 4)
  {
    long long v16 = *a3;
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong notification type", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"notifications._eventType == kCFXNotificationEventType_Light");
    long long v10 = v16;
  }
  if ((v8 & 0x200) != 0)
  {
    long long v17 = xmmword_1F0FBAC58;
    uint64_t v18 = qword_1F0FBAC68;
    long long v19 = v10;
    uint64_t v20 = a1;
    uint64_t v11 = sub_1B64B1FBC(*(void *)(v10 + 16), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    sub_1B63F3570(v11, (uint64_t (**)(uint64_t, uint64_t))&v17, 0, (uint64_t)&v19, v12, v13, v14, v15);
  }
}

uint64_t sub_1B64531B4(float32x4_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  CFDictionaryRef v11 = (const __CFDictionary *)a2[2];
  if (sub_1B649F640((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) == v11)
  {
    if (sub_1B6496680((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18) == 5
      && sub_1B6496EF8((uint64_t)v11, v19, v20, v21, v22, v23, v24, v25))
    {
      sub_1B649F73C(a1, v26, v20, v21, v22, v23, v24, v25);
    }
    sub_1B64528B8(v9, (uint64_t)a1, v20, v21, v22, v23, v24, v25);
    sub_1B64529BC(v9, v10, a1, v27, v28, v29, v30, v31);
  }
  return 0;
}

void sub_1B6453234(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"engineIterationContext");
  }
  uint64_t v9 = *a1;
  if (!*a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
  }
  uint64_t v10 = *(void *)(v9 + 32);
  if (v10) {
    int v11 = sub_1B6585B30(*(void *)(v9 + 32));
  }
  else {
    int v11 = 0;
  }
  uint64_t v12 = sub_1B6446518(a1[1], a2, a3, a4, a5, a6, a7, a8);
  if (v12) {
    sub_1B64A3B48(v12, v13, v14, v15, v16, v17, v18, v19);
  }
  int v27 = sub_1B64B2AD0(*(void *)(v9 + 16), v13, v14, v15, v16, v17, v18, v19) > 0.0;
  int v28 = *(unsigned __int8 *)(v9 + 104);
  if (v28 != v27) {
    *(unsigned char *)(v9 + 104) = v27;
  }
  int v29 = sub_1B64B381C(*(void *)(v9 + 16), v20, v21, v22, v23, v24, v25, v26);
  if (*(unsigned __int8 *)(v9 + 105) != v29)
  {
    *(unsigned char *)(v9 + 105) = v29;
    CFDictionaryRef v53 = (const __CFDictionary *)sub_1B64B28B0(*(void *)(v9 + 16), v30, v31, v32, v33, v34, v35, v36);
    if (v53) {
      sub_1B63BFE78(v53, (uint64_t *)a1[1], v9 + 112, v54, v55, v56, v57, v58);
    }
    goto LABEL_27;
  }
  CFDictionaryRef v37 = (const __CFDictionary *)sub_1B64B28B0(*(void *)(v9 + 16), v30, v31, v32, v33, v34, v35, v36);
  if (!v37)
  {
    if (v28 == v27) {
      goto LABEL_16;
    }
LABEL_27:
    sub_1B661C040(*(void *)(v9 + 96), (uint64_t)sub_1B64534C0, v9);
    if (!v10) {
      return;
    }
    goto LABEL_17;
  }
  char v45 = sub_1B63BFE78(v37, (uint64_t *)a1[1], v9 + 112, v40, v41, v42, v43, v44);
  if (v28 != v27 || (v45 & 1) != 0) {
    goto LABEL_27;
  }
LABEL_16:
  if (!v10) {
    return;
  }
LABEL_17:
  sub_1B6585A60(v10, v38, v39, v40, v41, v42, v43, v44);
  if (v11)
  {
    sub_1B64527B4(a1, v46, v47, v48, v49, v50, v51, v52);
  }
  else
  {
    uint64_t v59 = (const void *)sub_1B64A06D4();
    sub_1B6585ADC(v10, v59, (void (__cdecl *)(const void *, const void *, void *))sub_1B6452B1C, a1);
    uint64_t v60 = (const void *)sub_1B63CD970();
    sub_1B6585ADC(v10, v60, (void (__cdecl *)(const void *, const void *, void *))sub_1B6452F24, a1);
    uint64_t v61 = (const void *)sub_1B64AEBD0();
    sub_1B6585ADC(v10, v61, (void (__cdecl *)(const void *, const void *, void *))sub_1B6452D84, a1);
    uint64_t v62 = (const void *)sub_1B6494820();
    sub_1B6585ADC(v10, v62, (void (__cdecl *)(const void *, const void *, void *))sub_1B64530E8, a1);
    sub_1B6452A48(a1, v63, v64, v65, v66, v67, v68, v69);
  }
}

uint64_t sub_1B6453474(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
  }
  return *(void *)(a1 + 32);
}

uint64_t sub_1B64534C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B6452668(a2, a1, 16, a4, a5, a6, a7, a8);
}

void sub_1B64534D4(uint64_t a1, uint64_t a2, __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  context[2] = *MEMORY[0x1E4F143B8];
  if (@"kCFXNotificationNodeWillDie" != a3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong notification sent", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"name == kCFXNotificationNodeWillDie");
  }
  context[0] = a2;
  context[1] = a4;
  CFDictionaryRef v10 = *(const __CFDictionary **)(a2 + 24);
  if (v10) {
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)sub_1B6453D54, context);
  }
}

uint64_t sub_1B6453580(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
  }
  return *(void *)(a1 + 96);
}

void sub_1B64535CC(uint64_t a1, _WORD *a2)
{
  if ((a2[40] & 7) != 4)
  {
    uint64_t v4 = (const void *)sub_1B63F1710((uint64_t)a2);
    if (v4)
    {
      uint64_t v5 = v4;
      CFSetRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v4);
      if (!Value)
      {
        CFSetRef Value = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v5, Value);
        CFRelease(Value);
      }
      CFSetAddValue((CFMutableSetRef)Value, a2);
    }
  }
}

uint64_t sub_1B6453688(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  if (sub_1B649F640((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8)) {
    sub_1B645375C(a1, a2, @"kLightKey", v12, v13, v14, v15, v16);
  }
  if (sub_1B64A3B48((uint64_t)a2, v10, v11, v12, v13, v14, v15, v16)) {
    sub_1B645375C(a1, a2, @"kCameraKey", v19, v20, v21, v22, v23);
  }
  uint64_t result = sub_1B649F5A8((uint64_t)a2, v17, v18, v19, v20, v21, v22, v23);
  if (result)
  {
    return sub_1B645375C(a1, a2, @"kDeformerStackKey", v25, v26, v27, v28, v29);
  }
  return result;
}

BOOL sub_1B645375C(uint64_t a1, const void *a2, void *key, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_8:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (key) {
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
  if (!a2) {
    goto LABEL_8;
  }
LABEL_3:
  if (key) {
    goto LABEL_4;
  }
LABEL_9:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_4:
  CFSetRef v11 = (const __CFSet *)sub_1B6453BCC(a1, key, 1, 0);
  int v12 = CFSetContainsValue(v11, a2);
  if (!v12) {
    CFSetAddValue(v11, a2);
  }
  return v12 == 0;
}

void sub_1B645383C(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"rendererElement");
  }
  if ((a2[40] & 7) != 4)
  {
    uint64_t v10 = (const void *)sub_1B63F1710((uint64_t)a2);
    if (v10)
    {
      CFSetRef v11 = v10;
      CFSetRef Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v10);
      if (Value)
      {
        CFSetRef v13 = Value;
        CFSetRemoveValue(Value, a2);
        if (!CFSetGetCount(v13))
        {
          uint64_t v14 = *(__CFDictionary **)(a1 + 40);
          CFDictionaryRemoveValue(v14, v11);
        }
      }
    }
  }
}

uint64_t sub_1B6453904(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  sub_1B645398C(a1, a2, @"kCameraKey", a4, a5, a6, a7, a8);

  return sub_1B645398C(a1, a2, @"kDeformerStackKey", v10, v11, v12, v13, v14);
}

uint64_t sub_1B645398C(uint64_t a1, const void *a2, void *key, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_9:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (key) {
      goto LABEL_4;
    }
    goto LABEL_10;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
  if (!a2) {
    goto LABEL_9;
  }
LABEL_3:
  if (key) {
    goto LABEL_4;
  }
LABEL_10:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)key, a4, a5, a6, a7, a8, (uint64_t)"key");
LABEL_4:
  uint64_t result = (uint64_t)sub_1B6453BCC(a1, key, 0, 0);
  if (result)
  {
    CFSetRef v12 = (const __CFSet *)result;
    if (CFSetGetCount((CFSetRef)result) < 1)
    {
      return 0;
    }
    else
    {
      uint64_t result = CFSetContainsValue(v12, a2);
      if (result)
      {
        CFSetRemoveValue(v12, a2);
        return 1;
      }
    }
  }
  return result;
}

void sub_1B6453A80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = sub_1B661B124(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v10 != 0xFFFFFFFF)
  {
    unint64_t v17 = v10;
    unint64_t v18 = HIDWORD(v10);
    if (HIDWORD(v10))
    {
      uint64_t v19 = 0;
      *(void *)(a3 + 224) = v10;
      do
      {
        uint64_t v20 = (_WORD *)sub_1B661BFA4(*(void *)(a1 + 96), *(void *)(a3 + 224), v19, v12, v13, v14, v15, v16);
        sub_1B64535CC(a1, v20);
        ++v19;
      }
      while (v18 != v19);
    }
    else
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. no render elements have been created", v11, v12, v13, v14, v15, v16, (uint64_t)"span.count > 0");
      *(void *)(a3 + 224) = v17;
    }
    if (sub_1B649F94C(a3))
    {
      uint64_t v28 = sub_1B649F5F4(a3, v21, v22, v23, v24, v25, v26, v27);
      if (v28)
      {
        CFArrayRef v36 = (const __CFArray *)sub_1B63CE0D8(v28, v29, v30, v31, v32, v33, v34, v35);
        CFIndex Count = CFArrayGetCount(v36);
        if (Count >= 1)
        {
          CFIndex v43 = Count;
          for (uint64_t i = 0; i != v43; ++i)
          {
            uint64_t v45 = *(void *)(a3 + 232) + 12 * i;
            uint64_t v46 = *(unsigned int *)(v45 + 16);
            if (v46)
            {
              uint64_t v47 = 0;
              unint64_t v48 = *(unsigned int *)(v45 + 12) | (unint64_t)(v46 << 32);
              do
              {
                uint64_t v49 = (_WORD *)sub_1B661BFA4(*(void *)(a1 + 96), v48, v47, v38, v39, v40, v41, v42);
                if (v49) {
                  sub_1B64535CC(a1, v49);
                }
                ++v47;
              }
              while (v46 != v47);
            }
          }
        }
      }
    }
  }
}

const void *sub_1B6453BC4(uint64_t a1, void *a2, int a3)
{
  return sub_1B6453BCC(a1, a2, a3, 1);
}

const void *sub_1B6453BCC(uint64_t a1, void *key, int a3, int a4)
{
  CFDictionaryRef Mutable = *(const __CFDictionary **)(a1 + 24);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)(a1 + 24) = Mutable;
  }
  CFSetRef Value = CFDictionaryGetValue(Mutable, key);
  if (Value) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = a3 == 0;
  }
  if (!v10)
  {
    CFSetRef Value = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), key, Value);
    CFRelease(Value);
  }
  if (Value) {
    BOOL v11 = a4 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11 && CFEqual(key, @"kDeformerStackKey"))
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    uint64_t v17 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = sub_1B6454938;
    v13[3] = &unk_1E6142278;
    v13[4] = &v14;
    void v13[5] = Value;
    sub_1B63CC9A0((const __CFSet *)Value, (uint64_t)v13);
    if (v15[3]) {
      CFSetRef Value = (const void *)v15[3];
    }
    _Block_object_dispose(&v14, 8);
  }
  return Value;
}

void sub_1B6453D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6453D54(void *key, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B645398C(*(void *)a3, *(const void **)(a3 + 8), key, a4, a5, a6, a7, a8);
}

void sub_1B6453D64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"pipeline");
  }
  uint64_t v9 = *(__CFDictionary **)(a1 + 40);
  if (v9) {
    CFDictionaryRemoveAllValues(v9);
  }
  sub_1B661BE18(*(uint64_t **)(a1 + 96), a2, a3, a4, a5, a6, a7, a8);
  BOOL v10 = *(const void **)(a1 + 24);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 24) = 0;
  }
}

void sub_1B6453DD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, const char **a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v15 = sub_1B6445900(a3, a2, a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8);
  if (v15)
  {
    uint64_t v23 = (void *)v15;
    uint64_t v31 = sub_1B6446190(a3, v16, v17, v18, v19, v20, v21, v22);
    if (a2)
    {
      uint64_t CurrentPassMaterial = sub_1B63F1680(a1, a2, v25, v26, v27, v28, v29, v30);
    }
    else
    {
      if ((*(_WORD *)(a1 + 80) & 0x400) != 0 || !objc_msgSend_getCurrentPassMaterial(v23, v24, v25, v26))
      {
        uint64_t v33 = *(void *)(a1 + 32);
        goto LABEL_24;
      }
      uint64_t CurrentPassMaterial = objc_msgSend_getCurrentPassMaterial(v23, v24, v25, v26);
    }
    uint64_t v33 = CurrentPassMaterial;
LABEL_24:
    uint64_t CurrentPassHash = objc_msgSend_getCurrentPassHash(v23, v24, v25, v26);
    uint64_t v46 = sub_1B63F6BFC(v31, (char *)a1, a2, CurrentPassHash);
    if (!v33 || (uint64_t v34 = (const char *)v46, sub_1B64AFA68(v33, v36, v37, v38, v39, v40, v41, v42)))
    {
      if (!a2 || (uint64_t v43 = sub_1B65F6BF8(a2, v36, v37, v38, v39, v40, v41, v42)) == 0)
      {
        uint64_t v44 = *(void *)(a1 + 40);
        if (v33 && !v44) {
          uint64_t v44 = sub_1B64AFA68(v33, v36, v37, v38, v39, v40, v41, v42);
        }
        if (!v44)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v37, v38, v39, v40, v41, v42, (uint64_t)"renderGraph");
          return;
        }
        goto LABEL_32;
      }
LABEL_33:
      uint64_t v34 = 0;
      if (!a4)
      {
LABEL_35:
        if (a6) {
          *a6 = v43;
        }
        if (a5) {
          *a5 = v34;
        }
        return;
      }
LABEL_34:
      *a4 = v33;
      goto LABEL_35;
    }
LABEL_43:
    if (!sub_1B64AF43C(v33, v36, v37, v38, v39, v40, v41, v42)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v49, v50, v51, v52, v53, v54, (uint64_t)"commonProfile");
    }
    uint64_t v43 = sub_1B6447624(a3, v34);
    if (!a4) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  if (a2 && sub_1B65F8D04(a2, v16, v17, v18, v19, v20, v21, v22)) {
    uint64_t v34 = (const char *)sub_1B65F8D58(a3, a2, (char *)a1, v18, v19, v20, v21, v22);
  }
  else {
    uint64_t v34 = 0;
  }
  uint64_t v35 = sub_1B63F1680(a1, a2, v17, v18, v19, v20, v21, v22);
  uint64_t v33 = v35;
  if (v35 && !sub_1B64AFA68(v35, v36, v37, v38, v39, v40, v41, v42))
  {
    if (!v34)
    {
      uint64_t v47 = sub_1B6446190(a3, v36, v37, v38, v39, v40, v41, v42);
      unsigned int v48 = sub_1B6446D64(a3);
      uint64_t v34 = (const char *)sub_1B63F6BFC(v47, (char *)a1, a2, v48);
    }
    goto LABEL_43;
  }
  if (a2)
  {
    uint64_t v43 = sub_1B65F6BF8(a2, v36, v37, v38, v39, v40, v41, v42);
    if (v43) {
      goto LABEL_33;
    }
  }
  uint64_t v44 = *(void *)(a1 + 40);
  if (v33 && !v44) {
    uint64_t v44 = sub_1B64AFA68(v33, v36, v37, v38, v39, v40, v41, v42);
  }
  if (v44)
  {
LABEL_32:
    uint64_t v43 = sub_1B6516134(v44, v36, v37, v38, v39, v40, v41, v42);
    goto LABEL_33;
  }

  sub_1B63F2F54(16, @"Error: unexpected renderer element with no material/renderGraph/program", v37, v38, v39, v40, v41, v42, a9);
}

uint64_t sub_1B6454048(uint64_t result)
{
  *(unsigned char *)(result + 108) = 1;
  return result;
}

void sub_1B6454054(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
LABEL_3:
  *(unsigned char *)(a1 + 88) = 1;
  CFDictionaryRef Mutable = *(__CFSet **)(a1 + 80);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
    *(void *)(a1 + 80) = Mutable;
  }

  CFSetAddValue(Mutable, value);
}

void sub_1B6454100(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
LABEL_3:
  *(unsigned char *)(a1 + 88) = 1;
  CFDictionaryRef Mutable = *(__CFSet **)(a1 + 72);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
    *(void *)(a1 + 72) = Mutable;
  }

  CFSetAddValue(Mutable, value);
}

void sub_1B64541AC(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
LABEL_3:
  *(unsigned char *)(a1 + 88) = 1;
  BOOL v10 = *(__CFSet **)(a1 + 64);
  if (v10) {
    CFSetRemoveValue(v10, value);
  }
  CFDictionaryRef Mutable = *(__CFSet **)(a1 + 56);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
    *(void *)(a1 + 56) = Mutable;
  }
  CFSetAddValue(Mutable, value);
  sub_1B6454100(a1, value, v12, v13, v14, v15, v16, v17);

  sub_1B6454054(a1, value, v18, v19, v20, v21, v22, v23);
}

void sub_1B6454280(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
LABEL_3:
  *(unsigned char *)(a1 + 88) = 1;
  BOOL v10 = *(__CFSet **)(a1 + 56);
  if (v10) {
    CFSetRemoveValue(v10, value);
  }
  BOOL v11 = *(__CFSet **)(a1 + 72);
  if (v11) {
    CFSetRemoveValue(v11, value);
  }
  uint64_t v12 = *(__CFSet **)(a1 + 80);
  if (v12) {
    CFSetRemoveValue(v12, value);
  }
  CFDictionaryRef Mutable = *(__CFSet **)(a1 + 64);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
    *(void *)(a1 + 64) = Mutable;
  }

  CFSetAddValue(Mutable, value);
}

void sub_1B645435C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void context[3] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
  }
  if (*(unsigned char *)(a1 + 88))
  {
    *(unsigned char *)(a1 + 88) = 0;
    uint64_t v9 = *(void *)(a1 + 16);
    context[0] = a1;
    context[1] = sub_1B64B2054(v9, a2, a3, a4, a5, a6, a7, a8);
    context[2] = v9;
    CFSetRef v10 = *(const __CFSet **)(a1 + 64);
    if (v10)
    {
      CFSetApplyFunction(v10, (CFSetApplierFunction)sub_1B64544C0, context);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 64));
    }
    CFSetRef v11 = *(const __CFSet **)(a1 + 56);
    if (v11)
    {
      CFSetApplyFunction(v11, (CFSetApplierFunction)sub_1B6454564, context);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 56));
    }
    CFSetRef v12 = *(const __CFSet **)(a1 + 72);
    if (v12)
    {
      CFSetApplyFunction(v12, (CFSetApplierFunction)sub_1B64545F0, context);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 72));
    }
    CFSetRef v13 = *(const __CFSet **)(a1 + 80);
    if (v13)
    {
      CFSetApplyFunction(v13, (CFSetApplierFunction)sub_1B64546C4, context);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 80));
    }
    CFDictionaryRef v14 = *(const __CFDictionary **)(a1 + 48);
    if (v14)
    {
      int v21 = 0;
      CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)sub_1B6454764, &v21);
      sub_1B64B1500(v9, v21, v15, v16, v17, v18, v19, v20);
    }
  }
}

void sub_1B64544C0(void *key, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *a2;
  CFDictionaryRef v11 = *(const __CFDictionary **)(*a2 + 48);
  if (v11)
  {
    uint64_t v12 = a2[1];
    CFSetRef Value = CFDictionaryGetValue(v11, key);
    if (Value)
    {
      CFDictionaryRef v14 = Value;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v10 + 48), key);
      MEMORY[0x1F4181798](v12, sel_destroyObject_, v14, v15);
      return;
    }
    uint64_t v16 = @"Error: _applyDeleteEntities - can't find entity";
  }
  else
  {
    uint64_t v16 = @"Error: _applyDeleteEntities - registry does not exist";
  }

  sub_1B63F2F54(16, (uint64_t)v16, a3, a4, a5, a6, a7, a8, a9);
}

void sub_1B6454564(void *key, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (void *)a2[1];
  CFDictionaryRef Mutable = *(const __CFDictionary **)(*a2 + 48);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], 0);
    *(void *)(v4 + 48) = Mutable;
  }
  if (CFDictionaryGetValue(Mutable, key)) {
    sub_1B63F2F54(16, @"Error: _applyNewEntityForNode - node already has an entity", v7, v8, v9, v10, v11, v12, v15);
  }
  CFSetRef v13 = (const void *)objc_msgSend_newObject(v3, v6, v7, v8);
  CFDictionaryRef v14 = *(__CFDictionary **)(v4 + 48);

  CFDictionarySetValue(v14, key, v13);
}

void sub_1B64545F0(void *key, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFDictionaryRef v10 = *(const __CFDictionary **)(*a2 + 48);
  if (v10)
  {
    uint64_t v11 = a2[1];
    CFSetRef Value = CFDictionaryGetValue(v10, key);
    if (Value)
    {
      uint64_t v20 = Value;
      CFDictionaryRef v21 = sub_1B64A4A00((uint64_t)key, v13, v14, v15, v16, v17, v18, v19);
      if (v21)
      {
        uint64_t v29 = sub_1B65D35F0((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28);
        MEMORY[0x1F4181798](v11, sel_updateForceField_of_, v29, v20);
      }
    }
    else
    {
      sub_1B63F2F54(16, @"Error: _applyUpdateComponentForNode - can't find entity for node %@", v14, v15, v16, v17, v18, v19, (uint64_t)key);
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: _applyUpdateComponentForNode - entity registry doesn't exist", a3, a4, a5, a6, a7, a8, a9);
  }
}

CFDictionaryRef sub_1B64546C4(const void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *a2;
  uint64_t v9 = a2[1];
  uint64_t v11 = a2[2];
  if (sub_1B64A3964((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8)) {
    sub_1B65E4EEC(v11, (uint64_t)a1, v13, v14, v15, v16, v17, v18, v29);
  }
  sub_1B64A44A8((uint64_t)a1, v12, v13, v14, v15, v16, v17, v18);
  CFDictionaryRef result = *(const __CFDictionary **)(v10 + 48);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, a1);
    if (result)
    {
      CFDictionaryRef v27 = result;
      CFDictionaryRef result = (const __CFDictionary *)sub_1B64A01D4((uint64_t)a1, v20, v21, v22, v23, v24, v25, v26);
      if (result)
      {
        return (const __CFDictionary *)MEMORY[0x1F4181798](v9, sel_updateWorldTransform_of_, v27, v28);
      }
    }
  }
  return result;
}

uint64_t sub_1B6454764(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B64A4888(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (result) {
    ++*a3;
  }
  return result;
}

CFDictionaryRef sub_1B6454798(uint64_t a1, const void *a2)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 48);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

void sub_1B64547BC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"enginePipeline");
  }
  sub_1B65959BC(a1, @"kCFXNotificationNodeWillDie", 0);
  uint64_t v16 = (unsigned char *)a1[4];
  if (v16)
  {
    sub_1B65859DC(v16, v9, v10, v11, v12, v13, v14, v15);
    uint64_t v17 = (const void *)a1[4];
    if (v17)
    {
      CFRelease(v17);
      a1[4] = 0;
    }
  }
  uint64_t v18 = (const void *)a1[3];
  if (v18)
  {
    CFRelease(v18);
    a1[3] = 0;
  }
  uint64_t v19 = (const void *)a1[5];
  if (v19)
  {
    CFRelease(v19);
    a1[5] = 0;
  }
  uint64_t v20 = (const void *)a1[12];
  if (v20)
  {
    CFRelease(v20);
    a1[12] = 0;
  }
  uint64_t v21 = (const void *)a1[7];
  if (v21)
  {
    CFRelease(v21);
    a1[7] = 0;
  }
  uint64_t v22 = (const void *)a1[9];
  if (v22)
  {
    CFRelease(v22);
    a1[9] = 0;
  }
  uint64_t v23 = (const void *)a1[8];
  if (v23)
  {
    CFRelease(v23);
    a1[8] = 0;
  }
  uint64_t v24 = (const void *)a1[10];
  if (v24)
  {
    CFRelease(v24);
    a1[10] = 0;
  }
  uint64_t v25 = (const void *)a1[6];
  if (v25)
  {
    CFRelease(v25);
    a1[6] = 0;
  }
}

CFStringRef sub_1B64548B8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXEnginePipeline %p>", a1);
}

CFStringRef sub_1B64548F8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXEnginePipeline %p>", a1);
}

void sub_1B6454938(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = sub_1B649F5A8(a2, a2, a3, a4, a5, a6, a7, a8);
  if (!v15) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"deformers");
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = sub_1B64549E4;
  v16[3] = &unk_1E6142250;
  long long v17 = *(_OWORD *)(a1 + 32);
  sub_1B65E2034(v15, (uint64_t)v16);
}

void sub_1B64549E4(uint64_t a1, int a2, void *value)
{
  uint64_t v5 = *(__CFSet **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (!v5)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFSetCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFSetRef *)(a1 + 40));
    CFAutorelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    uint64_t v5 = *(__CFSet **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }

  CFSetAddValue(v5, value);
}

uint64_t sub_1B6454A6C(uint64_t a1, unsigned int a2)
{
  return a1 + 16 * a2;
}

BOOL sub_1B6454A74(_OWORD *a1, long long *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  long long v3 = *a1;
  long long v4 = a1[1];
  uint64_t v16 = *(void *)a1;
  int v17 = DWORD2(v3);
  int v18 = 1065353216;
  uint64_t v19 = v4;
  int v20 = DWORD2(v4);
  int v21 = 1065353216;
  long long v5 = a1[2];
  uint64_t v22 = *((void *)a1 + 4);
  int v23 = DWORD2(v5);
  int v24 = 1065353216;
  long long v6 = *a2;
  uint64_t v25 = *(void *)a2;
  int v26 = DWORD2(v6);
  int v27 = 1065353216;
  BOOL v13 = sub_1B64846F8((uint64_t)&v16, 4u, 3, a3);
  if (!v13) {
    sub_1B63F2F54(0, @"Warning: CFXTriangle3BarycentricCoordinates: unable to solve the equation", v7, v8, v9, v10, v11, v12, v15);
  }
  return v13;
}

BOOL sub_1B6454B48(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v2 = vsubq_f32(a1[1], *a1);
  float32x4_t v3 = vsubq_f32(a1[2], *a1);
  float32x4_t v4 = vsubq_f32(*a2, *a1);
  float32x4_t v5 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL);
  float32x4_t v6 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL);
  float32x4_t v7 = vnegq_f32(v3);
  float32x4_t v8 = vmlaq_f32(vmulq_f32(v6, v7), v4, v5);
  float32x4_t v9 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL);
  float32x4_t v10 = vmulq_f32(vmlaq_f32(vmulq_f32(v9, v7), v2, v5), v8);
  if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), v10)).f32[0] < 0.0)return 0; {
  float32x4_t v11 = vnegq_f32(v2);
  }
  float32x4_t v12 = vmlaq_f32(vmulq_f32(v6, v11), v4, v9);
  float32x4_t v13 = vmlaq_f32(vmulq_f32(v5, v11), v3, v9);
  float32x4_t v14 = vmulq_f32(v13, v12);
  if (vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), v14)).f32[0] < 0.0)return 0; {
  BOOL result = 0;
  }
  float32x4_t v16 = vmulq_f32(v13, v13);
  float v17 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), v16)).f32[0]);
  float32x4_t v18 = vmulq_f32(v8, v8);
  float v19 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), v18)).f32[0])/ v17;
  if (v19 <= 1.0)
  {
    float32x4_t v20 = vmulq_f32(v12, v12);
    float v21 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), v20)).f32[0])/ v17;
    if (v21 <= 1.0) {
      return (float)(v19 + v21) <= 1.0;
    }
  }
  return result;
}

uint64_t sub_1B6454C5C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 92) & 3;
}

__n128 sub_1B6454C68(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  *(_DWORD *)(a1 + 92) = 8;
  return result;
}

__n128 sub_1B6454C84(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1[92] & 8) == 0) {
    sub_1B6454CBC((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(__n128 *)a1;
}

__n128 sub_1B6454CBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 92);
  if ((v9 & 4) == 0)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _updateMatrix - no valid rep", a3, a4, a5, a6, a7, a8, (uint64_t)"_affineValid(t)");
    int v9 = *(_DWORD *)(a1 + 92);
  }
  if ((v9 & 8) != 0)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _updateMatrix - already valid", a3, a4, a5, a6, a7, a8, (uint64_t)"!_matrixValid(t)");
    int v9 = *(_DWORD *)(a1 + 92);
  }
  int v10 = v9 & 3;
  if (v10 == 2)
  {
    float32x4_t v12 = *(float32x4_t *)(a1 + 64);
    float32x4_t v13 = vmulq_f32(v12, v12);
    v13.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u64[0];
    float32x4_t v14 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0);
    v14.i32[3] = 0;
    float32x4_t v15 = vrsqrteq_f32(v14);
    float32x4_t v16 = vmulq_f32(v15, vrsqrtsq_f32(v14, vmulq_f32(v15, v15)));
    int8x16_t v17 = (int8x16_t)vmulq_f32(v16, vrsqrtsq_f32(v14, vmulq_f32(v16, v16)));
    int32x4_t v18 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v13.f32[0] != 0.0)), 0x1FuLL));
    v18.i32[3] = 0;
    __asm { FMOV            V3.4S, #1.0 }
    float32x4_t v48 = vmulq_f32(v12, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v18), v17, _Q3));
    __float2 v24 = __sincosf_stret(vmuls_lane_f32(0.5, v12, 3));
    float32x4_t v11 = vmulq_n_f32(v48, v24.__sinval);
    v11.i32[3] = LODWORD(v24.__cosval);
  }
  else if (v10)
  {
    v25.i64[0] = 0x3F0000003F000000;
    v25.i64[1] = 0x3F0000003F000000;
    simd_float4 v26 = (simd_float4)vmulq_f32(*(float32x4_t *)(a1 + 64), v25);
    v26.i32[3] = 0;
    simd_float4 x = v26;
    simd_float4 v49 = _simd_cos_f4(v26);
    _Q0 = _simd_sin_f4(x);
    _Q7 = v49;
    float v29 = vmuls_lane_f32(v49.f32[1], (float32x4_t)v49, 2);
    float v30 = vmuls_lane_f32(_Q0.f32[1], (float32x4_t)_Q0, 2);
    v11.f32[0] = vmlas_n_f32(-(float)(v49.f32[0] * v30), v29, _Q0.f32[0]);
    _S4 = vmuls_lane_f32(v49.f32[0], *(float32x2_t *)_Q0.f32, 1);
    __asm { FMLA            S5, S4, V7.S[2] }
    _S4 = vmuls_lane_f32(_Q7.f32[0], *(float32x2_t *)_Q7.f32, 1);
    __asm { FMLA            S6, S4, V0.S[2] }
    v11.i32[1] = _S5;
    v11.i64[1] = __PAIR64__(COERCE_UNSIGNED_INT(vmlas_n_f32(v30 * _Q0.f32[0], v29, v49.f32[0])), _S6);
  }
  else
  {
    float32x4_t v11 = *(float32x4_t *)(a1 + 64);
  }
  __n128 result = *(__n128 *)(a1 + 80);
  float32x4_t v36 = vabsq_f32((float32x4_t)result);
  v36.i32[3] = 0;
  v37.i64[0] = 0x8000000080000000;
  v37.i64[1] = 0x8000000080000000;
  float32x4_t v38 = (float32x4_t)vorrq_s8((int8x16_t)(*(_OWORD *)&vmaxnmq_f32(v36, (float32x4_t)xmmword_1B6E4FCD0) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)), vandq_s8((int8x16_t)result, v37));
  float32x4_t v39 = vmulq_f32(v11, v11);
  float32x4_t v40 = vmulq_laneq_f32(v11, v11, 3);
  float v41 = vmulq_lane_f32(v11, *(float32x2_t *)v11.f32, 1).f32[0];
  float32x4_t v42 = vaddq_f32(v38, v38);
  v39.f32[0] = 0.5 - v39.f32[0];
  float32x2_t v43 = vmul_laneq_f32(*(float32x2_t *)v11.f32, v11, 2);
  v44.i32[3] = 0;
  v45.i32[3] = 0;
  v45.f32[0] = (float)(0.5 - v39.f32[1]) - v39.f32[2];
  v45.f32[1] = v41 + v40.f32[2];
  v45.f32[2] = v43.f32[0] - v40.f32[1];
  v44.f32[0] = v41 - v40.f32[2];
  v44.f32[1] = v39.f32[0] - v39.f32[2];
  v44.f32[2] = v43.f32[1] + v40.f32[0];
  *(int32x2_t *)v40.f32 = vrev64_s32(*(int32x2_t *)v40.f32);
  v46.i32[0] = vadd_f32(v43, *(float32x2_t *)v40.f32).u32[0];
  v46.i32[1] = vsub_f32(v43, *(float32x2_t *)&v40).i32[1];
  v46.f32[2] = v39.f32[0] - v39.f32[1];
  v46.i32[3] = 0;
  *(float32x4_t *)a1 = vmulq_n_f32(v45, v42.f32[0]);
  *(float32x4_t *)(a1 + 16) = vmulq_lane_f32(v44, *(float32x2_t *)v42.f32, 1);
  *(float32x4_t *)(a1 + 32) = vmulq_laneq_f32(v46, v42, 2);
  *(_DWORD *)(a1 + 60) = 1065353216;
  *(_DWORD *)(a1 + 92) = result.n128_u32[3] | 8;
  return result;
}

uint64_t sub_1B6454F20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 92) & 8) == 0) {
    sub_1B6454CBC(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  return a1;
}

double sub_1B6454F54(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v9 = a1[5].i32[3];
  if ((v9 & 4) == 0)
  {
    sub_1B64550A8(a1, a2, a3, a4, a5, a6, a7, a8);
    __int32 v9 = a1[5].i32[3];
  }
  int v10 = v9 & 3;
  if (v10 == 2)
  {
    float32x4_t v12 = a1[4];
    float32x4_t v13 = vmulq_f32(v12, v12);
    v13.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u64[0];
    float32x4_t v14 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0);
    v14.i32[3] = 0;
    float32x4_t v15 = vrsqrteq_f32(v14);
    float32x4_t v16 = vmulq_f32(v15, vrsqrtsq_f32(v14, vmulq_f32(v15, v15)));
    int8x16_t v17 = (int8x16_t)vmulq_f32(v16, vrsqrtsq_f32(v14, vmulq_f32(v16, v16)));
    int32x4_t v18 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v13.f32[0] != 0.0)), 0x1FuLL));
    v18.i32[3] = 0;
    __asm { FMOV            V3.4S, #1.0 }
    v11.i64[0] = vmulq_n_f32(vmulq_f32(v12, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v18), v17, _Q3)), __sincosf_stret(vmuls_lane_f32(0.5, v12, 3)).__sinval).u64[0];
  }
  else if (v10)
  {
    v24.i64[0] = 0x3F0000003F000000;
    v24.i64[1] = 0x3F0000003F000000;
    simd_float4 v25 = (simd_float4)vmulq_f32(a1[4], v24);
    v25.i32[3] = 0;
    simd_float4 x = v25;
    simd_float4 v34 = _simd_cos_f4(v25);
    _Q1 = _simd_sin_f4(x);
    _Q7 = v34;
    v11.f32[0] = vmlas_n_f32(-(float)(v34.f32[0] * vmuls_lane_f32(_Q1.f32[1], (float32x4_t)_Q1, 2)), vmuls_lane_f32(v34.f32[1], (float32x4_t)v34, 2), _Q1.f32[0]);
    _S4 = vmuls_lane_f32(v34.f32[0], *(float32x2_t *)_Q1.f32, 1);
    __asm { FMLA            S5, S4, V7.S[2] }
    _S4 = vmuls_lane_f32(_Q7.f32[0], *(float32x2_t *)_Q7.f32, 1);
    __asm { FMLA            S6, S4, V1.S[2] }
    v11.i32[1] = _S5;
  }
  else
  {
    float32x4_t v11 = a1[4];
  }
  return *(double *)v11.i64;
}

float32x4_t sub_1B64550A8(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v9 = a1[5].i32[3];
  if ((v9 & 8) == 0)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _updateAffine - no valid rep", a3, a4, a5, a6, a7, a8, (uint64_t)"_matrixValid(t)");
    __int32 v9 = a1[5].i32[3];
  }
  if ((v9 & 4) != 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _updateAffine - already valid", a3, a4, a5, a6, a7, a8, (uint64_t)"!_affineValid(t)");
  }
  float32x4_t v10 = *a1;
  float32x4_t v11 = a1[1];
  float32x4_t v12 = a1[2];
  float32x4_t v13 = vmulq_f32(v10, v10);
  float32x4_t v14 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1)));
  v14.f32[0] = sqrtf(v14.f32[0]);
  float32x4_t v15 = vmulq_f32(v11, v11);
  float32x4_t v16 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2);
  float32x4_t v17 = vmulq_f32(v12, v12);
  v14.i32[1] = sqrtf(vaddq_f32(v16, vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0]);
  v14.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0]);
  a1[5] = v14;
  int32x4_t v18 = vzip2q_s32((int32x4_t)v13, (int32x4_t)v17);
  float32x4_t v19 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v13, (int32x4_t)v17), (int32x4_t)v15);
  float32x4_t v20 = (float32x4_t)vtrn2q_s32((int32x4_t)v13, (int32x4_t)v15);
  v20.i32[2] = v17.i32[1];
  float32x4_t v21 = vaddq_f32((float32x4_t)vzip1q_s32(v18, (int32x4_t)v16), vaddq_f32(v19, v20));
  v20.i64[0] = 0x80000000800000;
  v20.i64[1] = 0x80000000800000;
  int8x16_t v22 = (int8x16_t)vcgeq_f32(v20, v21);
  v21.i32[3] = 0;
  float32x4_t v23 = vrsqrteq_f32(v21);
  float32x4_t v24 = vmulq_f32(v23, vrsqrtsq_f32(v21, vmulq_f32(v23, v23)));
  int32x4_t v25 = (int32x4_t)v22;
  v25.i32[3] = 0;
  float32x4_t v26 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v25), (int8x16_t)v21, (int8x16_t)vmulq_f32(v24, vrsqrtsq_f32(v21, vmulq_f32(v24, v24))));
  float32x4_t v27 = vmulq_n_f32(v10, v26.f32[0]);
  float32x4_t v28 = vmulq_lane_f32(v11, *(float32x2_t *)v26.f32, 1);
  float32x4_t v29 = vmulq_laneq_f32(v12, v26, 2);
  int8x16_t v30 = (int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29);
  int8x16_t v31 = (int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28);
  int32x4_t v32 = (int32x4_t)v27;
  if (v22.i32[0])
  {
    int8x16_t v33 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v30, (int8x16_t)v29, 0xCuLL), vnegq_f32(v28)), v29, (float32x4_t)vextq_s8(v31, (int8x16_t)v28, 0xCuLL));
    int32x4_t v32 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), v33, 0xCuLL);
  }
  int8x16_t v34 = (int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27);
  float32x4_t v35 = v28;
  if (v22.i32[1])
  {
    int8x16_t v36 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v34, (int8x16_t)v27, 0xCuLL), vnegq_f32(v29)), v27, (float32x4_t)vextq_s8(v30, (int8x16_t)v29, 0xCuLL));
    float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36, (int32x4_t)v36), v36, 0xCuLL);
  }
  if (v22.i32[2])
  {
    int8x16_t v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v31, (int8x16_t)v28, 0xCuLL), vnegq_f32(v27)), v28, (float32x4_t)vextq_s8(v34, (int8x16_t)v27, 0xCuLL));
    float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL);
  }
  float v37 = (float)(*(float *)v32.i32 + v35.f32[1]) + v29.f32[2];
  if (v37 > 0.0)
  {
    float32x4_t v38 = (float32x4_t)vzip2q_s32((int32x4_t)v35, vuzp1q_s32((int32x4_t)v35, (int32x4_t)v29));
    v38.i32[2] = v32.i32[1];
    float v39 = sqrtf(v37 + 1.0);
    float32x4_t v40 = (float32x4_t)vtrn2q_s32((int32x4_t)v29, vzip2q_s32((int32x4_t)v29, v32));
    v40.i32[2] = v35.i32[0];
    float32x4_t v42 = vsubq_f32(v38, v40);
    v38.f32[3] = v39;
    v40.f32[3] = v39;
    float32x4_t v41 = vmulq_f32(v38, v40);
    v42.i32[3] = v41.i32[3];
LABEL_22:
    v41.f32[0] = 0.5 / v39;
    float32x4_t v52 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 0);
    goto LABEL_23;
  }
  if (*(float *)v32.i32 < v35.f32[1] || *(float *)v32.i32 < v29.f32[2])
  {
    if (v35.f32[1] <= v29.f32[2])
    {
      float v39 = sqrtf((float)((float)(v29.f32[2] + 1.0) - *(float *)v32.i32) - v35.f32[1]);
      *(float32x2_t *)v42.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v32, (int32x4_t)v35), *(float32x2_t *)v29.f32);
      float32x2_t v53 = (float32x2_t)__PAIR64__(v32.u32[1], LODWORD(v39));
      float32x2_t v54 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v35.f32, 0);
      *(float32x2_t *)v41.f32 = vsub_f32(*(float32x2_t *)v32.i8, v54);
      v54.f32[0] = v39;
      v54.i32[0] = vmul_f32(v53, v54).u32[0];
      v54.i32[1] = v41.i32[1];
      *(float32x2_t *)&v42.u32[2] = v54;
      goto LABEL_22;
    }
    float v46 = sqrtf((float)((float)(v35.f32[1] + 1.0) - *(float *)v32.i32) - v29.f32[2]);
    *(int32x2_t *)v22.i8 = vdup_laneq_s32((int32x4_t)v35, 2);
    int8x16_t v44 = v22;
    *(float *)v44.i32 = v46;
    v44.i32[0] = vmul_f32(*(float32x2_t *)v44.i8, (float32x2_t)__PAIR64__(v29.u32[1], LODWORD(v46))).u32[0];
    v44.i32[1] = vadd_f32(*(float32x2_t *)&v22, *(float32x2_t *)&v29).i32[1];
    int8x16_t v45 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.i8, 1), v35);
    int32x2_t v51 = (int32x2_t)vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32(v32, 2)).u64[0];
    float32x4_t v52 = (float32x4_t)vextq_s8(vextq_s8(v45, v45, 4uLL), v44, 0xCuLL);
    v52.i32[3] = v51.i32[0];
  }
  else
  {
    float v46 = sqrtf((float)((float)(*(float *)v32.i32 + 1.0) - v35.f32[1]) - v29.f32[2]);
    float32x2_t v47 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v35.f32, 0);
    float32x2_t v48 = vadd_f32(*(float32x2_t *)v32.i8, v47);
    v47.f32[0] = v46;
    v52.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v32.u32[1], LODWORD(v46)), v47).u32[0];
    v52.i32[1] = v48.i32[1];
    float32x2_t v49 = (float32x2_t)vzip2q_s32(v32, (int32x4_t)v35).u64[0];
    LODWORD(v50) = vadd_f32(v49, *(float32x2_t *)v29.f32).u32[0];
    int32x2_t v51 = (int32x2_t)vsub_f32(v49, *(float32x2_t *)v29.f32);
    HIDWORD(v50) = v51.i32[1];
    v52.i64[1] = v50;
  }
  *(float *)v51.i32 = 0.5 / v46;
  float32x4_t v42 = (float32x4_t)vdupq_lane_s32(v51, 0);
LABEL_23:
  float32x4_t result = vmulq_f32(v42, v52);
  a1[4] = result;
  a1[5].i32[3] = 4;
  return result;
}

void sub_1B64553BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  int v10 = *(_DWORD *)(a1 + 92);
  if ((v10 & 4) == 0)
  {
    __n128 v11 = a9;
    sub_1B6455410((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    a9 = v11;
    int v10 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v10 & 0xFFFFFFF4;
  *(__n128 *)(a1 + 64) = a9;
}

__n128 sub_1B6455410(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v9 = a1[5].i32[3];
  if ((v9 & 8) == 0)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _updateAffineScale - no valid rep", a3, a4, a5, a6, a7, a8, (uint64_t)"_matrixValid(t)");
    __int32 v9 = a1[5].i32[3];
  }
  if ((v9 & 4) != 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _updateAffineScale - already valid", a3, a4, a5, a6, a7, a8, (uint64_t)"!_affineValid(t)");
  }
  float32x4_t v10 = vmulq_f32(*a1, *a1);
  float32x4_t v13 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1)));
  float32x4_t v11 = vmulq_f32(a1[1], a1[1]);
  v13.f32[0] = sqrtf(v13.f32[0]);
  float32x4_t v12 = vmulq_f32(a1[2], a1[2]);
  v13.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  v13.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]);
  a1[5] = v13;
  a1[5].i32[3] = -1;
  result.n128_u64[0] = v13.i64[0];
  result.n128_u32[2] = v13.u32[2];
  return result;
}

__n128 sub_1B64554E4(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v9 = a1[5].i32[3];
  if ((v9 & 4) == 0)
  {
    sub_1B64550A8(a1, a2, a3, a4, a5, a6, a7, a8);
    __int32 v9 = a1[5].i32[3];
  }
  DWORD2(v15) = 0;
  *(void *)&long long v15 = 0;
  int v10 = v9 & 3;
  if (v10 == 2)
  {
    sub_1B6474EA4(a1[4]);
    long long v15 = v13;
LABEL_8:
    float32x4_t v12 = &v15;
    return (__n128)*v12;
  }
  if (v10 == 1)
  {
    float32x4_t v12 = (long long *)&a1[4];
    return (__n128)*v12;
  }
  if (v10) {
    goto LABEL_8;
  }
  float32x4_t v11 = a1 + 4;
  float32x4_t v12 = &v15;
  sub_1B63F8EE0(v11, &v15);
  return (__n128)*v12;
}

void sub_1B6455570(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  int v10 = *(_DWORD *)(a1 + 92);
  if ((v10 & 4) == 0)
  {
    __n128 v11 = a9;
    sub_1B6455410((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    a9 = v11;
    int v10 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v10 & 0xFFFFFFF4 | 1;
  *(__n128 *)(a1 + 64) = a9;
}

void sub_1B64555C8(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v9 = a1[5].i32[3];
  if ((v9 & 4) == 0)
  {
    sub_1B64550A8(a1, a2, a3, a4, a5, a6, a7, a8);
    __int32 v9 = a1[5].i32[3];
  }
  float32x4_t v10 = 0uLL;
  float32x4_t v12 = 0u;
  int v11 = v9 & 3;
  if (v11 != 2)
  {
    if (v11 == 1)
    {
      *(double *)v10.i64 = sub_1B6474DB0(a1[4]);
    }
    else if (!v11)
    {
      sub_1B63F89FC(a1 + 4, &v12);
      float32x4_t v10 = v12;
    }
    a1[4] = v10;
    a1[5].i32[3] = a1[5].i32[3] & 0xFFFFFFFC | 2;
  }
}

void sub_1B645565C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  int v10 = *(_DWORD *)(a1 + 92);
  if ((v10 & 4) == 0)
  {
    __n128 v11 = a9;
    sub_1B6455410((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    a9 = v11;
    int v10 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v10 & 0xFFFFFFF4 | 2;
  *(__n128 *)(a1 + 64) = a9;
}

__n128 sub_1B64556B4(__n128 *a1)
{
  return a1[3];
}

__n128 sub_1B64556BC(__n128 *a1, __n128 result)
{
  result.n128_u32[3] = 1.0;
  a1[3] = result;
  return result;
}

__n128 sub_1B64556CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 92) & 4) == 0) {
    sub_1B64550A8((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(__n128 *)(a1 + 80);
}

void sub_1B6455700(float32x4_t *a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __n128 v9 = a2;
  unsigned int v11 = a1[5].u32[3];
  if ((v11 & 4) == 0)
  {
    if ((v11 & 8) == 0)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. _updateAffineRotation - no valid rep", a4, a5, a6, a7, a8, a9, (uint64_t)"_matrixValid(t)");
      __n128 v9 = a2;
      if ((a1[5].i8[12] & 4) != 0)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. _updateAffineRotation - already valid", v12, v13, v14, v15, v16, v17, (uint64_t)"!_affineValid(t)");
        __n128 v9 = a2;
      }
    }
    float32x4_t v18 = a1[1];
    float32x4_t v19 = a1[2];
    int32x4_t v20 = (int32x4_t)vmulq_f32(*a1, *a1);
    int32x4_t v21 = (int32x4_t)vmulq_f32(v18, v18);
    int32x4_t v22 = (int32x4_t)vmulq_f32(v19, v19);
    int32x4_t v23 = vzip2q_s32(v20, v22);
    float32x4_t v24 = (float32x4_t)vzip1q_s32(vzip1q_s32(v20, v22), v21);
    float32x4_t v25 = (float32x4_t)vtrn2q_s32(v20, v21);
    v25.i32[2] = v22.i32[1];
    float32x4_t v26 = vaddq_f32((float32x4_t)vzip1q_s32(v23, vdupq_laneq_s32(v21, 2)), vaddq_f32(v24, v25));
    v25.i64[0] = 0x80000000800000;
    v25.i64[1] = 0x80000000800000;
    int8x16_t v27 = (int8x16_t)vcgeq_f32(v25, v26);
    v26.i32[3] = 0;
    float32x4_t v28 = vrsqrteq_f32(v26);
    float32x4_t v29 = vmulq_f32(v28, vrsqrtsq_f32(v26, vmulq_f32(v28, v28)));
    int32x4_t v30 = (int32x4_t)v27;
    v30.i32[3] = 0;
    float32x4_t v31 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v30), (int8x16_t)v26, (int8x16_t)vmulq_f32(v29, vrsqrtsq_f32(v26, vmulq_f32(v29, v29))));
    float32x4_t v32 = vmulq_n_f32(*a1, v31.f32[0]);
    float32x4_t v33 = vmulq_lane_f32(v18, *(float32x2_t *)v31.f32, 1);
    float32x4_t v34 = vmulq_laneq_f32(v19, v31, 2);
    int8x16_t v35 = (int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34);
    int8x16_t v36 = (int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33);
    int32x4_t v37 = (int32x4_t)v32;
    if (v27.i32[0])
    {
      int8x16_t v38 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v35, (int8x16_t)v34, 0xCuLL), vnegq_f32(v33)), v34, (float32x4_t)vextq_s8(v36, (int8x16_t)v33, 0xCuLL));
      int32x4_t v37 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v38, (int32x4_t)v38), v38, 0xCuLL);
    }
    int8x16_t v39 = (int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32);
    float32x4_t v40 = v33;
    if (v27.i32[1])
    {
      int8x16_t v41 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v39, (int8x16_t)v32, 0xCuLL), vnegq_f32(v34)), v32, (float32x4_t)vextq_s8(v35, (int8x16_t)v34, 0xCuLL));
      float32x4_t v40 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), v41, 0xCuLL);
    }
    if (v27.i32[2])
    {
      int8x16_t v27 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v36, (int8x16_t)v33, 0xCuLL), vnegq_f32(v32)), v33, (float32x4_t)vextq_s8(v39, (int8x16_t)v32, 0xCuLL));
      float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), v27, 0xCuLL);
    }
    float v42 = (float)(*(float *)v37.i32 + v40.f32[1]) + v34.f32[2];
    if (v42 > 0.0)
    {
      float32x4_t v43 = (float32x4_t)vzip2q_s32((int32x4_t)v40, vuzp1q_s32((int32x4_t)v40, (int32x4_t)v34));
      v43.i32[2] = v37.i32[1];
      float v44 = sqrtf(v42 + 1.0);
      float32x4_t v45 = (float32x4_t)vtrn2q_s32((int32x4_t)v34, vzip2q_s32((int32x4_t)v34, v37));
      v45.i32[2] = v40.i32[0];
      float32x4_t v47 = vsubq_f32(v43, v45);
      v43.f32[3] = v44;
      v45.f32[3] = v44;
      float32x4_t v46 = vmulq_f32(v43, v45);
      v47.i32[3] = v46.i32[3];
LABEL_22:
      v46.f32[0] = 0.5 / v44;
      float32x4_t v57 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 0);
      goto LABEL_23;
    }
    if (*(float *)v37.i32 < v40.f32[1] || *(float *)v37.i32 < v34.f32[2])
    {
      if (v40.f32[1] <= v34.f32[2])
      {
        float v44 = sqrtf((float)((float)(v34.f32[2] + 1.0) - *(float *)v37.i32) - v40.f32[1]);
        *(float32x2_t *)v47.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v37, (int32x4_t)v40), *(float32x2_t *)v34.f32);
        float32x2_t v58 = (float32x2_t)__PAIR64__(v37.u32[1], LODWORD(v44));
        float32x2_t v59 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.f32, 0);
        *(float32x2_t *)v46.f32 = vsub_f32(*(float32x2_t *)v37.i8, v59);
        v59.f32[0] = v44;
        v59.i32[0] = vmul_f32(v58, v59).u32[0];
        v59.i32[1] = v46.i32[1];
        *(float32x2_t *)&v47.u32[2] = v59;
        goto LABEL_22;
      }
      float v51 = sqrtf((float)((float)(v40.f32[1] + 1.0) - *(float *)v37.i32) - v34.f32[2]);
      *(int32x2_t *)v27.i8 = vdup_laneq_s32((int32x4_t)v40, 2);
      int8x16_t v49 = v27;
      *(float *)v49.i32 = v51;
      v49.i32[0] = vmul_f32(*(float32x2_t *)v49.i8, (float32x2_t)__PAIR64__(v34.u32[1], LODWORD(v51))).u32[0];
      v49.i32[1] = vadd_f32(*(float32x2_t *)&v27, *(float32x2_t *)&v34).i32[1];
      int8x16_t v50 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 1), v40);
      int32x2_t v56 = (int32x2_t)vsubq_f32(v34, (float32x4_t)vdupq_laneq_s32(v37, 2)).u64[0];
      float32x4_t v57 = (float32x4_t)vextq_s8(vextq_s8(v50, v50, 4uLL), v49, 0xCuLL);
      v57.i32[3] = v56.i32[0];
    }
    else
    {
      float v51 = sqrtf((float)((float)(*(float *)v37.i32 + 1.0) - v40.f32[1]) - v34.f32[2]);
      float32x2_t v52 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.f32, 0);
      float32x2_t v53 = vadd_f32(*(float32x2_t *)v37.i8, v52);
      v52.f32[0] = v51;
      v57.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v37.u32[1], LODWORD(v51)), v52).u32[0];
      v57.i32[1] = v53.i32[1];
      float32x2_t v54 = (float32x2_t)vzip2q_s32(v37, (int32x4_t)v40).u64[0];
      LODWORD(v55) = vadd_f32(v54, *(float32x2_t *)v34.f32).u32[0];
      int32x2_t v56 = (int32x2_t)vsub_f32(v54, *(float32x2_t *)v34.f32);
      HIDWORD(v55) = v56.i32[1];
      v57.i64[1] = v55;
    }
    *(float *)v56.i32 = 0.5 / v51;
    float32x4_t v47 = (float32x4_t)vdupq_lane_s32(v56, 0);
LABEL_23:
    a1[4] = vmulq_f32(v57, v47);
    unsigned int v11 = a1[5].i32[3] & 0xFFFFFFF8 | 4;
  }
  a1[5].i32[3] = v11 & 0xFFFFFFF7;
  a1[5].i32[2] = v9.n128_i32[2];
  a1[5].i64[0] = v9.n128_u64[0];
}

double sub_1B64559FC(uint64_t a1)
{
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 92) & 0xFFFFFFF3 | 8;
  *(_OWORD *)a1 = xmmword_1B6E4F300;
  *(_OWORD *)(a1 + 16) = xmmword_1B6E4F320;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1B6E4F2E0;
  *(_OWORD *)(a1 + 48) = xmmword_1B6E4F370;
  return result;
}

void sub_1B6455A38(uint64_t a1, void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v9 = a5;
  int v10 = a4;
  if (a5 >= 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTransformGetValue offset out of bounds", a3, a4, a5, a6, a7, a8, (uint64_t)"offset < 4");
  }
  switch(v10)
  {
    case 3:
      v14.n128_f64[0] = sub_1B6454F54((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_11;
    case 4:
      sub_1B64555C8((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_11;
    case 5:
      __n128 v14 = sub_1B64554E4((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_11;
    case 6:
      __n128 v14 = *(__n128 *)(a1 + 48);
      goto LABEL_11;
    case 7:
      if ((*(unsigned char *)(a1 + 92) & 4) == 0) {
        sub_1B64550A8((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      }
      __n128 v14 = *(__n128 *)(a1 + 80);
LABEL_11:
      v18[0] = v14;
      goto LABEL_12;
    case 8:
      if ((*(unsigned char *)(a1 + 92) & 8) == 0) {
        sub_1B6454CBC(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      }
      long long v15 = *(_OWORD *)(a1 + 16);
      long long v16 = *(_OWORD *)(a1 + 32);
      long long v17 = *(_OWORD *)(a1 + 48);
      v18[0] = *(_OWORD *)a1;
      v18[1] = v15;
      v18[2] = v16;
      v18[3] = v17;
LABEL_12:
      memcpy(a2, (char *)v18 + 4 * v9, a3);
      break;
    default:
      sub_1B63F2F54(16, @"Error: CFXTransformGetValue - unexpected semantic", a3, a4, a5, a6, a7, a8, a9);
      break;
  }
}

void sub_1B6455B98(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  if (a3 != 4)
  {
    if (a3 == 16)
    {
      long long v11 = *a2;
      goto LABEL_11;
    }
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTransformSetValue unexpected size", a3, a4, a5, a6, a7, a8, (uint64_t)"size == sizeof(float)");
  }
  *(double *)&long long v11 = sub_1B6454F54((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  switch(v8)
  {
    case 0u:
      LODWORD(v11) = *(_DWORD *)a2;
      break;
    case 1u:
      DWORD1(v11) = *(_DWORD *)a2;
      break;
    case 2u:
      DWORD2(v11) = *(_DWORD *)a2;
      break;
    case 3u:
      HIDWORD(v11) = *(_DWORD *)a2;
      break;
    default:
      long long v13 = v11;
      sub_1B63F2F54(16, @"Error: CFXTransformSetValue unexptected component index %d", a3, a4, a5, a6, a7, a8, v8);
      long long v11 = v13;
      break;
  }
LABEL_11:
  int v12 = *(_DWORD *)(a1 + 92);
  if ((v12 & 4) == 0)
  {
    long long v14 = v11;
    sub_1B6455410((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    long long v11 = v14;
    int v12 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v12 & 0xFFFFFFF4;
  *(_OWORD *)(a1 + 64) = v11;
}

void sub_1B6455CB0(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  if (a3 != 4)
  {
    if (a3 == 16)
    {
      long long v11 = *a2;
      goto LABEL_11;
    }
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTransformSetValue unexpected size", a3, a4, a5, a6, a7, a8, (uint64_t)"size == sizeof(float)");
  }
  sub_1B64555C8((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  switch(v8)
  {
    case 0u:
      LODWORD(v11) = *(_DWORD *)a2;
      break;
    case 1u:
      DWORD1(v11) = *(_DWORD *)a2;
      break;
    case 2u:
      DWORD2(v11) = *(_DWORD *)a2;
      break;
    case 3u:
      HIDWORD(v11) = *(_DWORD *)a2;
      break;
    default:
      long long v13 = v11;
      sub_1B63F2F54(16, @"Error: CFXTransformSetValue unexptected component index %d", a3, a4, a5, a6, a7, a8, v8);
      long long v11 = v13;
      break;
  }
LABEL_11:
  int v12 = *(_DWORD *)(a1 + 92);
  if ((v12 & 4) == 0)
  {
    long long v14 = v11;
    sub_1B6455410((float32x4_t *)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    long long v11 = v14;
    int v12 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v12 & 0xFFFFFFF4 | 2;
  *(_OWORD *)(a1 + 64) = v11;
}

void sub_1B6455DCC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (a3 >= 0xC)
  {
    a9.n128_u64[0] = *(void *)a2;
    a9.n128_u32[2] = *(_DWORD *)(a2 + 8);
    int v11 = *(_DWORD *)(a1 + 92);
    if ((v11 & 4) == 0)
    {
      __n128 v23 = a9;
      sub_1B6455410((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8);
      a9 = v23;
      int v11 = *(_DWORD *)(a1 + 92);
    }
    *(_DWORD *)(a1 + 92) = v11 & 0xFFFFFFF4 | 1;
    *(__n128 *)(a1 + 64) = a9;
    return;
  }
  unsigned int v12 = a4;
  if (a3 != 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTransformSetValue unexpected size", a3, a4, a5, a6, a7, a8, (uint64_t)"size == sizeof(float)");
  }
  __n128 v20 = sub_1B64554E4((float32x4_t *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (v12 == 2)
  {
    v21.n128_u64[0] = v20.n128_u64[0];
    v21.n128_u32[2] = *(_DWORD *)a2;
  }
  else
  {
    if (v12 == 1)
    {
      v21.n128_u32[0] = v20.n128_u32[0];
      v21.n128_u32[1] = *(_DWORD *)a2;
    }
    else
    {
      if (v12)
      {
        __n128 v24 = v20;
        sub_1B63F2F54(16, @"Error: CFXTransformSetValue unexptected component index %d", v14, v15, v16, v17, v18, v19, v12);
        __n128 v21 = v24;
        goto LABEL_16;
      }
      v21.n128_u32[0] = *(_DWORD *)a2;
      v21.n128_u32[1] = v20.n128_u32[1];
    }
    v21.n128_u32[2] = v20.n128_u32[2];
  }
  v21.n128_u32[3] = v20.n128_u32[3];
LABEL_16:
  int v22 = *(_DWORD *)(a1 + 92);
  if ((v22 & 4) == 0)
  {
    __n128 v25 = v21;
    sub_1B6455410((float32x4_t *)a1, v13, v14, v15, v16, v17, v18, v19);
    __n128 v21 = v25;
    int v22 = *(_DWORD *)(a1 + 92);
  }
  *(_DWORD *)(a1 + 92) = v22 & 0xFFFFFFF4 | 1;
  *(__n128 *)(a1 + 64) = v21;
}

__n128 sub_1B6455F08(__n128 *a1, unsigned __int32 *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0xC)
  {
    unsigned int v12 = a4;
    if (a3 != 4) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTransformSetValue unexpected size", a3, a4, a5, a6, a7, a8, (uint64_t)"size == sizeof(float)");
    }
    __n128 v13 = a1[3];
    if (v12 == 2)
    {
      v13.n128_u32[2] = *a2;
      __n128 result = v13;
    }
    else
    {
      if (v12 == 1)
      {
        __n128 result = a1[3];
        result.n128_u32[1] = *a2;
      }
      else
      {
        if (v12)
        {
          __n128 v14 = a1[3];
          sub_1B63F2F54(16, @"Error: CFXTransformSetValue unexptected component index %d", a3, a4, a5, a6, a7, a8, v12);
          __n128 result = v14;
          goto LABEL_13;
        }
        result.n128_u32[0] = *a2;
        result.n128_u32[1] = HIDWORD(a1[3].n128_u64[0]);
      }
      result.n128_u32[2] = a1[3].n128_u64[1];
    }
LABEL_13:
    unsigned __int32 v10 = 1.0;
    goto LABEL_14;
  }
  result.n128_u64[0] = *(void *)a2;
  unsigned __int32 v10 = 1.0;
  result.n128_u32[2] = a2[2];
LABEL_14:
  result.n128_u32[3] = v10;
  a1[3] = result;
  return result;
}

void sub_1B6455FEC(float32x4_t *a1, __int32 *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (a3 < 0xC)
  {
    unsigned int v11 = a4;
    if (a3 != 4) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTransformSetValue unexpected size", a3, a4, a5, a6, a7, a8, (uint64_t)"size == sizeof(float)");
    }
    if ((a1[5].i8[12] & 4) == 0) {
      sub_1B64550A8(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    }
    if (v11 == 2)
    {
      a1[5].i32[2] = *a2;
    }
    else if (v11 == 1)
    {
      a1[5].i32[1] = *a2;
    }
    else if (v11)
    {
      sub_1B63F2F54(16, @"Error: CFXTransformSetValue unexptected component index %d", a3, a4, a5, a6, a7, a8, v11);
    }
    else
    {
      a1[5].i32[0] = *a2;
    }
    a1[5].i32[3] &= ~8u;
  }
  else
  {
    a9.n128_u64[0] = *(void *)a2;
    a9.n128_u32[2] = a2[2];
    sub_1B6455700(a1, a9, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
}

_OWORD *sub_1B64560F0(_OWORD *result, _OWORD *a2, size_t a3, unsigned int a4)
{
  long long v4 = result;
  if (a3 == 96)
  {
    long long v8 = a2[1];
    *__n128 result = *a2;
    result[1] = v8;
    long long v9 = a2[2];
    long long v10 = a2[3];
    long long v11 = a2[5];
    result[4] = a2[4];
    result[5] = v11;
    result[2] = v9;
    result[3] = v10;
  }
  else
  {
    if (a3 == 64)
    {
      long long v5 = a2[1];
      long long v6 = a2[2];
      long long v7 = a2[3];
      *__n128 result = *a2;
      result[1] = v5;
      result[2] = v6;
      result[3] = v7;
    }
    else
    {
      __n128 result = memcpy((char *)result + 4 * a4, a2, a3);
    }
    *((_DWORD *)v4 + 23) = 8;
  }
  return result;
}

void sub_1B6456160(__n128 *a1, long long *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, uint64_t a10)
{
  int v11 = a4;
  if (a5 >= 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTransformSetValue offset out of bounds", a3, a4, a5, a6, a7, a8, (uint64_t)"offset < 4");
  }
  switch(v11)
  {
    case 3:
      sub_1B6455B98((uint64_t)a1, a2, a3, a5, a5, a6, a7, a8);
      break;
    case 4:
      sub_1B6455CB0((uint64_t)a1, a2, a3, a5, a5, a6, a7, a8);
      break;
    case 5:
      sub_1B6455DCC((uint64_t)a1, (uint64_t)a2, a3, a5, a5, a6, a7, a8, a9);
      break;
    case 6:
      sub_1B6455F08(a1, (unsigned __int32 *)a2, a3, a5, a5, a6, a7, a8);
      break;
    case 7:
      sub_1B6455FEC((float32x4_t *)a1, (__int32 *)a2, a3, a5, a5, a6, a7, a8, a9);
      break;
    case 8:
      sub_1B64560F0(a1, a2, a3, a5);
      break;
    default:
      sub_1B63F2F54(16, @"Error: CFXTransformSetValue - unexpected semantic", a3, a4, a5, a6, a7, a8, a10);
      break;
  }
}

uint64_t sub_1B645642C(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB3658;

  sub_1B644E78C((CFX::RG::Resource **)(a1 + 24), 0);
  return a1;
}

void sub_1B6456480(_Unwind_Exception *a1)
{
  sub_1B644E78C((CFX::RG::Resource **)(v1 + 24), 0);
  _Unwind_Resume(a1);
}

void sub_1B645649C(uint64_t a1)
{
  sub_1B645642C(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B64564D4(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a5;
  *(void *)&v38[0] = "BackBufferPass";
  *((void *)&v38[0] + 1) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDACF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDACF8))
  {
    byte_1E9DDACF0 = 1;
    __cxa_guard_release(&qword_1E9DDACF8);
  }
  if (byte_1E9DDACF0) {
    uint64_t v11 = 0x2940D000AB344474;
  }
  else {
    uint64_t v11 = 0;
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)v38, v11, 0);
  *(void *)a1 = &unk_1F0FB3678;
  uint64_t v12 = a5[2];
  *(_OWORD *)(a1 + 376) = *(_OWORD *)a5;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 392) = v12;
  int8x16_t v35 = (void *)sub_1B6445900(*(void *)(a1 + 368), v13, v14, v15, v16, v17, v18, v19);
  objc_msgSend_resourceManager(v35, v20, v21, v22);
  __n128 v23 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[1]);
  uint64_t v37 = *v23;
  uint64_t v36 = v23[1];
  uint64_t v40 = *(void *)(v23 + 2);
  int v41 = *((_DWORD *)v23 + 3);
  uint64_t v24 = *((void *)v23 + 2);
  long long v25 = *(_OWORD *)(v23 + 20);
  v38[0] = *(_OWORD *)(v23 + 12);
  v38[1] = v25;
  v38[2] = *(_OWORD *)(v23 + 28);
  uint64_t v39 = *((void *)v23 + 9);
  unint64_t v26 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v27 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v26 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v24)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v24)))) ^ ((0x9DDFEA08EB382D69 * (v26 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v24)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v24)))) >> 47)));
  *(void *)(a1 + 400) = v27;
  if (!v27) {
    operator new();
  }
  unint64_t v28 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v29 = 0x9DDFEA08EB382D69
      * (v28 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v37)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v37)));
  unint64_t v30 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47))) ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47))) ^ v36)));
  unint64_t v31 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47))) ^ v24)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47))) ^ v24)));
  unint64_t v32 = 0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47));
  uint64_t v33 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v32 ^ ((0x9DDFEA08EB382D69 * (*(void *)(a1 + 392) ^ v32)) >> 47) ^ (0x9DDFEA08EB382D69* (*(void *)(a1 + 392) ^ v32)))) ^ ((0x9DDFEA08EB382D69 * (v32 ^ ((0x9DDFEA08EB382D69 * (*(void *)(a1 + 392) ^ v32)) >> 47) ^ (0x9DDFEA08EB382D69 * (*(void *)(a1 + 392) ^ v32)))) >> 47)));
  *(void *)(a1 + 408) = v33;
  if (!v33) {
    operator new();
  }
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(v33 + 24));
  return a1;
}

void sub_1B6456A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,id a39)
{
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(&a39);
  CFX::RG::Pass::~Pass(v39);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6456A78(uint64_t a1)
{
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 408) + 16);
}

uint64_t sub_1B6456A8C(uint64_t result, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(result + 400) + 16))
  {
    uint64_t v3 = result;
    long long v4 = *a3;
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(result + 416));
    uint64_t v6 = *(void *)(*(void *)(v3 + 408) + 16);
    objc_msgSend_setTexture_atIndex_(v4, v7, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v4, v8, v6, 1);
    uint64_t v15 = *(void *)(v3 + 400);
    uint64_t v16 = *(void *)(v15 + 16);
    if (!v16)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v9, v10, v11, v12, v13, v14, (uint64_t)"_ptr != NULL");
      uint64_t v16 = *(void *)(v15 + 16);
    }
    uint64_t v18 = sub_1B653EFB8(v16);
    return objc_msgSend_dispatch_onTexture2D_(v4, v17, v18, v6);
  }
  return result;
}

uint64_t *sub_1B6456B60(uint64_t *this, CFX::RG::Resource *a2)
{
  this[52] = (uint64_t)a2;
  return CFX::RG::Pass::readFrom(this, a2);
}

uint64_t sub_1B6456B68(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 408) + 24);
}

uint64_t sub_1B6456B74(CFX::RG::RenderGraphContext *a1, uint64_t *a2)
{
  long long v4 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a1);

  return sub_1B6456BB4(v4, (CFX::CrossFrameResourceManager **)a1, a2);
}

uint64_t sub_1B6456BB4(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6456DB0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6456C10(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6456C48(void *a1)
{
  *a1 = &unk_1F0FB3638;
  float32x4_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6456C94(void *a1)
{
  *a1 = &unk_1F0FB3638;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

_OWORD *sub_1B6456D00(uint64_t *a1, long long *a2, unsigned __int8 *a3)
{
  uint64_t v6 = malloc_type_malloc(0xE0uLL, 0xD5346062uLL);
  *(void *)&long long v7 = -1;
  *((void *)&v7 + 1) = -1;
  *uint64_t v6 = v7;
  v6[1] = v7;
  v6[2] = v7;
  v6[3] = v7;
  v6[4] = v7;
  v6[5] = v7;
  v6[6] = v7;
  v6[7] = v7;
  v6[8] = v7;
  v6[9] = v7;
  v6[10] = v7;
  v6[11] = v7;
  v6[12] = v7;
  v6[13] = v7;
  uint64_t v8 = *a1;
  CFX::RG::ExternalResourceDesc::ExternalResourceDesc((uint64_t)v10, a2);
  CFX::RG::Resource::Resource(v6, v8, v10, *a3);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v10);
  return v6;
}

void sub_1B6456D9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
}

uint64_t sub_1B6456DB0(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A8u, 8u);
  return sub_1B64564D4(v8, *a3, a3[1], a4, a5);
}

__n128 sub_1B6456E10(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  *a1 = *a2;
  __n128 result = *a3;
  a1[1] = *a3;
  return result;
}

float32x4_t sub_1B6456E24(float32x4_t *a1, float32x4_t *a2)
{
  *a1 = *a2;
  float32x4_t v2 = vsubq_f32(a2[1], *a2);
  int32x4_t v3 = (int32x4_t)vmulq_f32(v2, v2);
  v3.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v3, 2), vadd_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1))).u32[0];
  float32x2_t v4 = vrsqrte_f32((float32x2_t)v3.u32[0]);
  float32x2_t v5 = vmul_f32(v4, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v4, v4)));
  float32x4_t result = vmulq_n_f32(v2, vmul_f32(v5, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v5, v5))).f32[0]);
  a1[1] = result;
  return result;
}

uint64_t sub_1B6456E74(uint64_t a1)
{
  return a1 + 16;
}

uint64_t sub_1B6456E7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F0FB51E0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 368) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = a2;
  uint64_t v9 = sub_1B644558C(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 24) = v9;
  uint64_t v17 = sub_1B64B28FC(v9, v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 32) = v17;
  *(_WORD *)(a1 + 40) = 15;
  sub_1B6624920(v17, 0xFu);
  return a1;
}

uint64_t sub_1B6456F14(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB51E0;
  sub_1B6624994(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 40));
  return a1;
}

void sub_1B6456F60(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB51E0;
  sub_1B6624994(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 40));

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6456FCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFX::CrossFrameResourceManager *a5, uint64_t *a6)
{
  uint64_t v11 = *a6;
  v68[0] = (uint64_t)"DDGIPass";
  v68[1] = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAD08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDAD08))
  {
    byte_1E9DDAD00 = 1;
    __cxa_guard_release(&qword_1E9DDAD08);
  }
  if (byte_1E9DDAD00) {
    uint64_t v12 = 0x31E4B56277654EABLL;
  }
  else {
    uint64_t v12 = 0;
  }
  sub_1B653860C(a1, a2, a3, v68, v12, 0);
  *(void *)a1 = &unk_1F0FB5220;
  memcpy((void *)(a1 + 384), a6, 0x150uLL);
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  __n128 v20 = (void *)sub_1B6445900(*(void *)(a1 + 368), v13, v14, v15, v16, v17, v18, v19);
  *(void *)(a1 + 736) = v20;
  *(void *)(a1 + 744) = objc_msgSend_resourceManager(v20, v21, v22, v23);
  unint64_t v24 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v25 = CFX::CrossFrameResourceManager::get(a5, v24);
  *(void *)(a1 + 720) = v25;
  if (!v25)
  {
    CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    v68[0] = *(void *)(a1 + 368);
    sub_1B6457894();
  }
  uint64_t v33 = sub_1B644558C(*(void *)(a1 + 368), v26, v27, v28, v29, v30, v31, v32);
  uint64_t v41 = sub_1B64B28FC(v33, v34, v35, v36, v37, v38, v39, v40);
  if (sub_1B6446564(*(uint64_t **)(a1 + 368), v42, v43, v44, v45, v46, v47, v48))
  {
    uint64_t v49 = sub_1B64B2810(v33, 0);
    BOOL v71 = v49 != 0;
    unsigned int v70 = 0;
    unsigned int v50 = sub_1B6626FAC(v41);
    BOOL v69 = 0;
    unsigned int v70 = v50;
    BOOL v69 = sub_1B6626FBC(v41) != 0;
    unint64_t v51 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    unint64_t v52 = 0x9DDFEA08EB382D69
        * (v51 ^ ((0x9DDFEA08EB382D69 * (v51 ^ v49)) >> 47) ^ (0x9DDFEA08EB382D69 * (v51 ^ v49)));
    unint64_t v53 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
    unint64_t v54 = 0x9DDFEA08EB382D69 * (v53 ^ *((unsigned __int8 *)a6 + 304));
    unint64_t v55 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v53 ^ (v54 >> 47) ^ v54)) ^ ((0x9DDFEA08EB382D69 * (v53 ^ (v54 >> 47) ^ v54)) >> 47));
    unint64_t v56 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v70)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v70)))) ^ ((0x9DDFEA08EB382D69 * (v55 ^ ((0x9DDFEA08EB382D69 * (v55 ^ v70)) >> 47) ^ (0x9DDFEA08EB382D69 * (v55 ^ v70)))) >> 47));
    unint64_t v57 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v56 ^ ((0x9DDFEA08EB382D69 * (v56 ^ v69)) >> 47) ^ (0x9DDFEA08EB382D69 * (v56 ^ v69)))) ^ ((0x9DDFEA08EB382D69 * (v56 ^ ((0x9DDFEA08EB382D69 * (v56 ^ v69)) >> 47) ^ (0x9DDFEA08EB382D69 * (v56 ^ v69)))) >> 47));
    unint64_t v58 = 0x9DDFEA08EB382D69 * (v57 ^ COERCE_UNSIGNED_INT64(*((float *)a6 + 53)));
    unint64_t v59 = (0x9DDFEA08EB382D69 * (v57 ^ (v58 >> 47) ^ v58)) ^ ((0x9DDFEA08EB382D69 * (v57 ^ (v58 >> 47) ^ v58)) >> 47);
    long long v60 = *((_OWORD *)a6 + 14);
    unint64_t v61 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * v59) ^ ((0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v59) ^ (int)v60)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v59) ^ (int)v60)));
    unint64_t v62 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v61 ^ (v61 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v61 ^ (v61 >> 47))) ^ SDWORD1(v60))) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v61 ^ (v61 >> 47))) ^ SDWORD1(v60))));
    unint64_t v63 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ SDWORD2(v60))) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ SDWORD2(v60))));
    unint64_t v64 = 0x9DDFEA08EB382D69 * (v63 ^ (v63 >> 47));
    unint64_t v65 = 0x9DDFEA08EB382D69 * (v64 ^ *((unsigned int *)a6 + 52));
    uint64_t v66 = CFX::CrossFrameResourceManager::get(a5, 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v64 ^ (v65 >> 47) ^ v65)) ^ ((0x9DDFEA08EB382D69 * (v64 ^ (v65 >> 47) ^ v65)) >> 47)));
    *(void *)(a1 + 728) = v66;
    if (!v66) {
      operator new();
    }
    CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(v66 + 8 * (*(unsigned char *)(v66 + 96) == 0) + 56));
    CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 728) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 728) + 96) + 56));
    if (*((unsigned char *)a6 + 304))
    {
      CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 728) + 8 * (*(unsigned char *)(*(void *)(a1 + 728) + 96) == 0) + 72));
      CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 728) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 728) + 96) + 72));
    }
  }
  return a1;
}

void sub_1B6457838(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6457894()
{
}

void sub_1B64578FC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A1C40565862A5);
  _Unwind_Resume(a1);
}

void sub_1B6457924(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(*(void *)(a1 + 728) + 16)) {
    return;
  }
  uint64_t v10 = *a3;
  uint64_t v11 = sub_1B644558C(*(void *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = sub_1B6446564(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  if (!v19 || !sub_1B64A3B48((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26)) {
    return;
  }
  uint64_t v34 = sub_1B6446564(*(uint64_t **)(a1 + 368), v27, v28, v29, v30, v31, v32, v33);
  sub_1B63E0460((uint64_t)v34, (uint64_t)v221, v35, v36, v37, v38, v39, v40);
  uint64_t v41 = (long long *)sub_1B6447988(*(void *)(a1 + 368), 1);
  long long v205 = v41[1];
  long long v206 = *v41;
  long long v203 = v41[3];
  long long v204 = v41[2];
  __n128 v220 = sub_1B64471F4(*(void *)(a1 + 368), 0, v42, v43, v44, v45, v46, v47);
  uint64_t v55 = sub_1B64B28FC(v11, v48, v49, v50, v51, v52, v53, v54);
  sub_1B6626AF8(v55, *(void *)(a1 + 368));
  unint64_t v56 = *(_OWORD **)(a1 + 720);
  v56[3] = v206;
  v56[4] = v205;
  v56[5] = v204;
  v56[6] = v203;
  *(simd_float4x4 *)(*(void *)(a1 + 720) + 112) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 720) + 48));
  unint64_t v63 = sub_1B649CD50(v221, (uint64_t)&v220, v57, v58, v59, v60, v61, v62);
  uint64_t v64 = 0;
  long long v65 = *((_OWORD *)v63 + 1);
  long long v66 = *((_OWORD *)v63 + 2);
  long long v67 = *((_OWORD *)v63 + 3);
  uint64_t v68 = *(_OWORD **)(a1 + 720);
  v68[11] = *(_OWORD *)v63;
  v68[12] = v65;
  v68[13] = v66;
  v68[14] = v67;
  BOOL v69 = *(float32x4_t **)(a1 + 720);
  float32x4_t v70 = v69[11];
  float32x4_t v71 = v69[12];
  float32x4_t v72 = v69[13];
  float32x4_t v73 = v69[14];
  float32x4_t v74 = v69[4];
  float32x4_t v75 = v69[5];
  float32x4_t v76 = v69[6];
  v222[0] = v69[3];
  v222[1] = v74;
  v222[2] = v75;
  v222[3] = v76;
  do
  {
    v223.columns[v64] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v70, COERCE_FLOAT(v222[v64])), v71, *(float32x2_t *)&v222[v64], 1), v72, (float32x4_t)v222[v64], 2), v73, (float32x4_t)v222[v64], 3);
    ++v64;
  }
  while (v64 != 4);
  *(simd_float4x4 *)(*(void *)(a1 + 720) + 240) = __invert_f4(v223);
  uint64_t v77 = *(void *)(a1 + 720);
  *(_DWORD *)(v77 + 312) = *(_DWORD *)(v77 + 368);
  *(_DWORD *)(v77 + 304) = *(_DWORD *)(a1 + 692);
  *(_OWORD *)(v77 + 320) = *(_OWORD *)(a1 + 656);
  *(_OWORD *)(*(void *)(a1 + 720) + 336) = *(_OWORD *)(a1 + 672);
  uint64_t v78 = sub_1B64B2810(v11, 0);
  if (v78) {
    float v86 = sub_1B64763AC(v78, (uint64_t)v79, v80, v81, v82, v83, v84, v85);
  }
  else {
    float v86 = 0.0;
  }
  uint64_t v87 = *(void *)(a1 + 720);
  *(float *)(v87 + 352) = v86;
  objc_msgSend_setBytes_length_atIndex_(v10, v79, v87 + 48, 320, 8);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 728)+ 8 * *(unsigned __int8 *)(*(void *)(a1 + 728) + 96)+ 56));
  id v90 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 728)+ 8 * (*(unsigned char *)(*(void *)(a1 + 728) + 96) == 0)+ 56));
  if (!*(unsigned char *)(a1 + 688))
  {
    id v207 = 0;
    goto LABEL_13;
  }
  id v207 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 728)+ 8 * *(unsigned __int8 *)(*(void *)(a1 + 728) + 96)+ 72));
  if (!*(unsigned char *)(a1 + 688))
  {
LABEL_13:
    id v91 = 0;
    goto LABEL_14;
  }
  id v91 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 728)+ 8 * (*(unsigned char *)(*(void *)(a1 + 728) + 96) == 0)+ 72));
LABEL_14:
  objc_msgSend_setTexture_atIndex_(v10, v89, (uint64_t)v90, 0);
  objc_msgSend_setTexture_atIndex_(v10, v92, (uint64_t)v91, 1);
  uint64_t v93 = sub_1B64B2810(v11, 0);
  if (v93)
  {
    uint64_t v96 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 736), v94, v93, v95);
    objc_msgSend_setTexture_atIndex_(v10, v97, v96, 6);
  }
  uint64_t v98 = sub_1B6626EB4(v55);
  objc_msgSend_useHeap_(v10, v99, v98, v100);
  uint64_t v101 = sub_1B6626EC4(v55);
  objc_msgSend_setBuffer_offset_atIndex_(v10, v102, v101, 0, 0);
  uint64_t v103 = sub_1B6626EBC(v55);
  objc_msgSend_setAccelerationStructure_atBufferIndex_(v10, v104, v103, 1);
  if (sub_1B6626FAC(v55))
  {
    uint64_t v105 = sub_1B6626ECC(v55);
    objc_msgSend_setBuffer_offset_atIndex_(v10, v106, v105, 0, 3);
  }
  if (sub_1B6626FBC(v55))
  {
    uint64_t v113 = *(void *)(a1 + 728);
    uint64_t v114 = *(void *)(v113 + 16);
    if (!v114)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v107, v108, v109, v110, v111, v112, (uint64_t)"_ptr != NULL");
      uint64_t v114 = *(void *)(v113 + 16);
    }
    long long v115 = (void *)sub_1B653EFB8(v114);
    long long v116 = sub_1B6626EE4(v55, v115);
    objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v10, v117, (uint64_t)v116, 4);
  }
  else
  {
    long long v116 = 0;
  }
  uint64_t v118 = sub_1B6626ED4(v55);
  unsigned int v122 = sub_1B6626FCC(v55, v119, v120, v121);
  objc_msgSend_useResources_count_usage_(v10, v123, v118, v122, 1);
  uint64_t v130 = *(void *)(a1 + 728);
  uint64_t v131 = *(void *)(v130 + 88);
  if (!v131)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", 0, v125, v126, v127, v128, v129, (uint64_t)"_ptr != NULL");
    uint64_t v131 = *(void *)(v130 + 88);
  }
  objc_msgSend_setBuffer_offset_atIndex_(v10, v124, v131, 0, 2);
  unsigned int v138 = *(_DWORD *)(a1 + 608) * *(_DWORD *)(a1 + 612) * *(_DWORD *)(a1 + 616) * *(_DWORD *)(a1 + 592);
  uint64_t v139 = *(void *)(a1 + 728);
  uint64_t v140 = *(void *)(v139 + 16);
  if (!v140)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v132, v133, v134, v135, v136, v137, (uint64_t)"_ptr != NULL");
    uint64_t v140 = *(void *)(v139 + 16);
  }
  long long v141 = (void *)sub_1B653EFB8(v140);
  unint64_t v145 = objc_msgSend_threadExecutionWidth(v141, v142, v143, v144);
  objc_msgSend_setComputePipelineState_(v10, v146, (uint64_t)v141, v147);
  unint64_t v218 = (v145 + v138 - 1) / v145;
  int64x2_t v219 = vdupq_n_s64(1uLL);
  unint64_t v216 = v145;
  int64x2_t v217 = v219;
  objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v10, v148, (uint64_t)&v218, (uint64_t)&v216);

  objc_msgSend_setTexture_atIndex_(v10, v149, (uint64_t)Texture, 10);
  objc_msgSend_setTexture_atIndex_(v10, v150, (uint64_t)v90, 11);
  uint64_t v157 = *(void *)(a1 + 728);
  uint64_t v158 = *(void *)(v157 + 24);
  if (!v158)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v151, v152, v153, v154, v155, v156, (uint64_t)"_ptr != NULL");
    uint64_t v158 = *(void *)(v157 + 24);
  }
  uint64_t v159 = sub_1B653EFB8(v158);
  objc_msgSend_dispatch_onTexture2D_(v10, v160, v159, (uint64_t)Texture);
  uint64_t v167 = *(void *)(a1 + 728);
  uint64_t v168 = *(void *)(v167 + 32);
  if (!v168)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v161, v162, v163, v164, v165, v166, (uint64_t)"_ptr != NULL");
    uint64_t v168 = *(void *)(v167 + 32);
  }
  uint64_t v169 = sub_1B653EFB8(v168);
  objc_msgSend_setComputePipelineState_(v10, v170, v169, v171);
  uint64_t v172 = *(int *)(a1 + 616);
  uint64_t v173 = *(void *)(a1 + 608);
  *(void *)&long long v174 = (int)v173;
  *((void *)&v174 + 1) = SHIDWORD(v173);
  long long v214 = v174;
  uint64_t v215 = v172;
  long long v212 = xmmword_1B6E50BE0;
  uint64_t v213 = 1;
  objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v10, v175, (uint64_t)&v214, (uint64_t)&v212);
  if (*(unsigned char *)(a1 + 688))
  {
    objc_msgSend_setTexture_atIndex_(v10, v176, (uint64_t)v207, 10);
    objc_msgSend_setTexture_atIndex_(v10, v177, (uint64_t)v91, 11);
    uint64_t v184 = *(void *)(a1 + 728);
    uint64_t v185 = *(void *)(v184 + 40);
    if (!v185)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v178, v179, v180, v181, v182, v183, (uint64_t)"_ptr != NULL");
      uint64_t v185 = *(void *)(v184 + 40);
    }
    uint64_t v186 = sub_1B653EFB8(v185);
    objc_msgSend_dispatch_onTexture2D_(v10, v187, v186, (uint64_t)v207);
    uint64_t v194 = *(void *)(a1 + 728);
    uint64_t v195 = *(void *)(v194 + 48);
    if (!v195)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v188, v189, v190, v191, v192, v193, (uint64_t)"_ptr != NULL");
      uint64_t v195 = *(void *)(v194 + 48);
    }
    uint64_t v196 = sub_1B653EFB8(v195);
    objc_msgSend_setComputePipelineState_(v10, v197, v196, v198);
    uint64_t v199 = *(int *)(a1 + 616);
    uint64_t v200 = *(void *)(a1 + 608);
    *(void *)&long long v201 = (int)v200;
    *((void *)&v201 + 1) = SHIDWORD(v200);
    long long v210 = v201;
    uint64_t v211 = v199;
    long long v208 = xmmword_1B6E50BF0;
    uint64_t v209 = 1;
    objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(v10, v202, (uint64_t)&v210, (uint64_t)&v208);
  }
  ++*(_DWORD *)(*(void *)(a1 + 720) + 368);
  sub_1B6626E64(v55);
  *(unsigned char *)(*(void *)(a1 + 728) + 96) ^= 1u;
}

uint64_t sub_1B6457FB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  v27[0] = (uint64_t)"DDGIDebugPass";
  v27[1] = v8;
  uint64_t v9 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAD18, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = a2;
    uint64_t v25 = a3;
    int v23 = __cxa_guard_acquire(&qword_1E9DDAD18);
    uint64_t v9 = (void *)&unk_1E9DDA000;
    a2 = v24;
    a3 = v25;
    if (v23)
    {
      qword_1E9DDAD10 = sub_1B6458A24((unint64_t)"DDGI_DEBUG_PASS", 0xFu);
      __cxa_guard_release(&qword_1E9DDAD18);
      uint64_t v9 = (void *)&unk_1E9DDA000;
      a2 = v24;
      a3 = v25;
    }
  }
  sub_1B653860C(a1, a2, a3, v27, v9[418], 0);
  *(void *)a1 = &unk_1F0FB3478;
  memcpy((void *)(a1 + 384), a5, 0x150uLL);
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  uint64_t v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 784) = v17;
  *(void *)(a1 + 792) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  CFX::RG::TextureDescriptorReference::withSampleCount(a5 + 1, 1, (uint64_t)v26);
  uint64_t v21 = sub_1B63CFDE4(a4, (uint64_t)"DDGI Debug output", v26);
  *(void *)(a1 + 728) = v21;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v21);
  return a1;
}

void sub_1B64580F4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6458108(uint64_t a1, uint64_t a2)
{
  int v28 = 4;
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  long long v5 = *(_OWORD *)(a1 + 608);
  double v6 = (double)(unint64_t)COERCE_FLOAT(*(_OWORD *)(a1 + 656));
  double v7 = (double)(unint64_t)COERCE_FLOAT(HIDWORD(*(void *)(a1 + 656)));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned __int8 *)(a1 + 712));
  unint64_t v9 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v8 >> 47) ^ v8)) >> 47));
  unint64_t v10 = 0x9DDFEA08EB382D69 * (v9 ^ *(unsigned __int8 *)(a1 + 688));
  unint64_t v11 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
  unint64_t v12 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v11 ^ ((0x9DDFEA08EB382D69 * (v11 ^ (int)v5)) >> 47) ^ (0x9DDFEA08EB382D69 * (v11 ^ (int)v5)))) ^ ((0x9DDFEA08EB382D69 * (v11 ^ ((0x9DDFEA08EB382D69 * (v11 ^ (int)v5)) >> 47) ^ (0x9DDFEA08EB382D69 * (v11 ^ (int)v5)))) >> 47));
  unint64_t v13 = 0x9DDFEA08EB382D69
      * (v12 ^ ((0x9DDFEA08EB382D69 * (v12 ^ SDWORD1(v5))) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ SDWORD1(v5))));
  unint64_t v14 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47))) ^ SDWORD2(v5))) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47))) ^ SDWORD2(v5))));
  unint64_t v15 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v14 ^ (v14 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v14 ^ (v14 >> 47))) ^ *(void *)&v6)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v14 ^ (v14 >> 47))) ^ *(void *)&v6)));
  unint64_t v16 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47))) ^ *(void *)&v7)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47))) ^ *(void *)&v7)));
  unint64_t v17 = 0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47));
  unint64_t v18 = 0x9DDFEA08EB382D69
      * (v17 ^ COERCE_UNSIGNED_INT64((double)(unint64_t)COERCE_FLOAT(*(void *)(a1 + 664))));
  unint64_t v19 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  unint64_t v20 = 0x9DDFEA08EB382D69
      * (v19 ^ ((0x9DDFEA08EB382D69
               * (v19 ^ COERCE_UNSIGNED_INT64((double)(unint64_t)COERCE_FLOAT(*(_OWORD *)(a1 + 672))))) >> 47) ^ (0x9DDFEA08EB382D69 * (v19 ^ COERCE_UNSIGNED_INT64((double)(unint64_t)COERCE_FLOAT(*(_OWORD *)(a1 + 672))))));
  unint64_t v21 = 0x9DDFEA08EB382D69 * (v20 ^ (v20 >> 47));
  unint64_t v22 = 0x9DDFEA08EB382D69
      * (v21 ^ COERCE_UNSIGNED_INT64((double)(unint64_t)COERCE_FLOAT(HIDWORD(*(void *)(a1 + 672)))));
  unint64_t v23 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) ^ ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) >> 47));
  unint64_t v24 = 0x9DDFEA08EB382D69
      * (v23 ^ COERCE_UNSIGNED_INT64((double)(unint64_t)COERCE_FLOAT(*(void *)(a1 + 680))));
  uint64_t result = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69 * (v23 ^ (v24 >> 47) ^ v24)) ^ ((0x9DDFEA08EB382D69 * (v23 ^ (v24 >> 47) ^ v24)) >> 47)));
  *(void *)(a1 + 720) = result;
  if (!result)
  {
    float v26 = fmaxf(fmaxf(*(float *)(a1 + 656), *(float *)(a1 + 660)), *(float *)(a1 + 664)) * 0.05;
    float v27 = v26;
    operator new();
  }
  return result;
}

uint64_t sub_1B6458468(uint64_t result, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(result + 720) + 16))
  {
    uint64_t v9 = result;
    unint64_t v10 = *a3;
    unint64_t v11 = sub_1B6446564(*(uint64_t **)(result + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    sub_1B63E0460((uint64_t)v11, (uint64_t)v67, v12, v13, v14, v15, v16, v17);
    unint64_t v18 = (simd_float4 *)sub_1B6447988(*(void *)(v9 + 368), 1);
    simd_float4 v64 = v18[1];
    simd_float4 v65 = *v18;
    simd_float4 v62 = v18[3];
    simd_float4 v63 = v18[2];
    __n128 v66 = sub_1B64471F4(*(void *)(v9 + 368), 0, v19, v20, v21, v22, v23, v24);
    memset(&v76, 0, sizeof(v76));
    v81.columns[1] = v64;
    v81.columns[0] = v65;
    v70[0] = v65;
    v70[1] = v64;
    v81.columns[3] = v62;
    v81.columns[2] = v63;
    void v70[2] = v63;
    v70[3] = v62;
    simd_float4x4 v71 = __invert_f4(v81);
    uint64_t v31 = sub_1B649CD50(v67, (uint64_t)&v66, v25, v26, v27, v28, v29, v30);
    uint64_t v32 = 0;
    float32x4_t v33 = *(float32x4_t *)v31;
    float32x4_t v34 = *((float32x4_t *)v31 + 1);
    float32x4_t v35 = *((float32x4_t *)v31 + 2);
    float32x4_t v36 = *((float32x4_t *)v31 + 3);
    float32x4_t v72 = *(float32x4_t *)v31;
    float32x4_t v73 = v34;
    float32x4_t v74 = v35;
    float32x4_t v75 = v36;
    v68[0] = v65;
    v68[1] = v64;
    uint64_t v68[2] = v63;
    v68[3] = v62;
    do
    {
      v69.columns[v32] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, COERCE_FLOAT(v68[v32])), v34, *(float32x2_t *)&v68[v32], 1), v35, (float32x4_t)v68[v32], 2), v36, (float32x4_t)v68[v32], 3);
      ++v32;
    }
    while (v32 != 4);
    simd_float4x4 v76 = __invert_f4(v69);
    int v77 = *(_DWORD *)(v9 + 692);
    long long v37 = *(_OWORD *)(v9 + 672);
    long long v78 = *(_OWORD *)(v9 + 656);
    long long v79 = v37;
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 728));
    id v39 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 752));
    id v40 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 760));
    id v41 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 768));
    id v42 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 776));
    id v44 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 736));
    if (*(unsigned char *)(v9 + 688)) {
      id v45 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v9 + 744));
    }
    else {
      id v45 = 0;
    }
    objc_msgSend_setBytes_length_atIndex_(v10, v43, (uint64_t)v70, 320, 8);
    objc_msgSend_setTexture_atIndex_(v10, v46, (uint64_t)v39, 0);
    objc_msgSend_setTexture_atIndex_(v10, v47, (uint64_t)v42, 1);
    objc_msgSend_setTexture_atIndex_(v10, v48, (uint64_t)v40, 2);
    objc_msgSend_setTexture_atIndex_(v10, v49, (uint64_t)v41, 4);
    objc_msgSend_setTexture_atIndex_(v10, v50, (uint64_t)v44, 5);
    if (*(unsigned char *)(v9 + 688)) {
      objc_msgSend_setTexture_atIndex_(v10, v51, (uint64_t)v45, 6);
    }
    objc_msgSend_setTexture_atIndex_(v10, v51, (uint64_t)Texture, 7);
    uint64_t v58 = *(void *)(v9 + 720);
    uint64_t v59 = *(void *)(v58 + 16);
    if (!v59)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v52, v53, v54, v55, v56, v57, (uint64_t)"_ptr != NULL");
      uint64_t v59 = *(void *)(v58 + 16);
    }
    uint64_t v60 = sub_1B653EFB8(v59);
    return objc_msgSend_dispatch_onTexture2D_(v10, v61, v60, (uint64_t)Texture);
  }
  return result;
}

uint64_t *sub_1B6458730(uint64_t a1, CFX::RG::Resource *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)(a1 + 752) = a2;
  *(void *)(a1 + 776) = a3;
  *(void *)(a1 + 760) = a4;
  *(void *)(a1 + 768) = a5;
  *(void *)(a1 + 736) = a6;
  *(void *)(a1 + 744) = a7;
  CFX::RG::Pass::readFrom((uint64_t *)a1, a2);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 776));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 760));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 768));
  unint64_t v8 = *(CFX::RG::Resource **)(a1 + 736);

  return CFX::RG::Pass::readFrom((uint64_t *)a1, v8);
}

uint64_t *sub_1B64587A8(uint64_t *a1, CFX::CrossFrameResourceManager *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (*(unsigned char *)(a3 + 312))
  {
    uint64_t v12 = sub_1B644558C(*(void *)a3, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    uint64_t v20 = sub_1B64B1FBC(v12, v13, v14, v15, v16, v17, v18, v19);
    if (sub_1B649FB70(v20, &v36, 0, v21, v22, v23, v24, v25))
    {
      v26.i32[3] = v37.i32[3];
      float32x4_t v27 = vsubq_f32(v36, v37);
      float32x4_t v28 = vsubq_f32(vaddq_f32(v36, v37), v27);
      *(float32x2_t *)v26.f32 = vcvt_f32_s32(*(int32x2_t *)(a3 + 224));
      v26.f32[2] = (float)*(int *)(a3 + 232);
      float32x4_t v29 = vdivq_f32(v28, v26);
      v30.i64[0] = 0x3F0000003F000000;
      v30.i64[1] = 0x3F0000003F000000;
      a9 = (__n128)vsubq_f32(v28, v29);
      *(__n128 *)(a3 + 240) = a9;
      *(float32x4_t *)(a3 + 256) = vmlaq_f32(v27, v30, v29);
    }
  }
  a9.n128_u64[0] = (unint64_t)vdiv_f32(*(float32x2_t *)(a3 + 240), vcvt_f32_s32(vadd_s32(*(int32x2_t *)(a3 + 224), (int32x2_t)-1)));
  a9.n128_f32[2] = *(float *)(a3 + 248) / (float)(*(_DWORD *)(a3 + 232) - 1);
  long long v31 = *(_OWORD *)(a3 + 256);
  *(__n128 *)(a3 + 272) = a9;
  *(_OWORD *)(a3 + 288) = v31;
  uint64_t v32 = (CFX::RG::Pass *)sub_1B64588F8(a1, (uint64_t)a1, a2, (uint64_t *)a3);
  *(void *)(a3 + 200) = *(void *)(*((void *)v32 + 91)
                                    + 8 * *(unsigned __int8 *)(*((void *)v32 + 91) + 96)
                                    + 56);
  if (*(unsigned char *)(a3 + 313))
  {
    float32x4_t v33 = (uint64_t *)sub_1B6458954(a1, a1, (uint64_t *)a3);
    uint64_t v34 = *((void *)v32 + 91) + 8 * *(unsigned __int8 *)(*((void *)v32 + 91) + 96);
    sub_1B6458730((uint64_t)v33, *(CFX::RG::Resource **)(a3 + 168), *(void *)(a3 + 176), *(void *)(a3 + 184), *(void *)(a3 + 192), *(void *)(v34 + 56), *(void *)(v34 + 72));
    CFX::RG::Pass::dependsOn(v33, v32);
    *(void *)(a3 + 320) = v33[91];
    return v33;
  }
  return (uint64_t *)v32;
}

uint64_t sub_1B64588F8(uint64_t *a1, uint64_t a2, CFX::CrossFrameResourceManager *a3, uint64_t *a4)
{
  uint64_t v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B6458D30(v9[0], v7, v9, a2, a3, a4);
  sub_1B63C88CC(a1 + 18, v9);
  return v9[0];
}

uint64_t sub_1B6458954(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6458D90(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B64589B0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B64589EC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unint64_t sub_1B6458A24(unint64_t result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995
       * ((0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * *(void *)result) ^ ((0xC6A4A7935BD1E995 * *(void *)result) >> 47))) ^ (0xC6A4A7935BD1E995 * a2));
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_9;
      case 2u:
        goto LABEL_8;
      case 3u:
        goto LABEL_7;
      case 4u:
        goto LABEL_6;
      case 5u:
        goto LABEL_5;
      case 6u:
        goto LABEL_4;
      case 7u:
        v2 ^= (unint64_t)*(unsigned __int8 *)(result + 14) << 48;
LABEL_4:
        v2 ^= (unint64_t)*(unsigned __int8 *)(result + 13) << 40;
LABEL_5:
        v2 ^= (unint64_t)*(unsigned __int8 *)(result + 12) << 32;
LABEL_6:
        v2 ^= (unint64_t)*(unsigned __int8 *)(result + 11) << 24;
LABEL_7:
        v2 ^= (unint64_t)*(unsigned __int8 *)(result + 10) << 16;
LABEL_8:
        v2 ^= (unint64_t)*(unsigned __int8 *)(result + 9) << 8;
LABEL_9:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *(unsigned __int8 *)(result + 8));
        break;
      default:
        return (0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47);
    }
    return (0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47);
  }
  return result;
}

void sub_1B6458AF4(void *a1)
{
  sub_1B6458B2C(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6458B2C(void *a1)
{
  *a1 = &unk_1F0FB5200;
  unint64_t v2 = (void *)a1[11];
  if (v2) {

  }
  for (uint64_t i = 10; i != 8; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);
  do
    sub_1B644E78C((CFX::RG::Resource **)&a1[i--], 0);
  while (i != 6);
  unint64_t v4 = (void *)a1[6];
  if (v4) {

  }
  uint64_t v5 = (void *)a1[5];
  if (v5) {

  }
  double v6 = (void *)a1[4];
  if (v6) {

  }
  uint64_t v7 = (void *)a1[3];
  if (v7) {

  }
  unint64_t v8 = (void *)a1[2];
  if (v8) {

  }
  return a1;
}

double sub_1B6458BE8(uint64_t *a1, uint64_t a2, char *a3)
{
  double v6 = malloc_type_malloc(0xE0uLL, 0xD5346062uLL);
  *(void *)&long long v7 = -1;
  *((void *)&v7 + 1) = -1;
  *double v6 = v7;
  v6[1] = v7;
  v6[2] = v7;
  v6[3] = v7;
  v6[4] = v7;
  v6[5] = v7;
  v6[6] = v7;
  v6[7] = v7;
  v6[8] = v7;
  v6[9] = v7;
  v6[10] = v7;
  v6[11] = v7;
  v6[12] = v7;
  v6[13] = v7;
  uint64_t v8 = *a1;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v10, a2);
  *(void *)&double result = CFX::RG::Resource::Resource((uint64_t)v6, v8, (uint64_t)v10, *a3).n128_u64[0];
  return result;
}

void *sub_1B6458C78(void *a1)
{
  *a1 = &unk_1F0FB3458;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6458CC4(void *a1)
{
  *a1 = &unk_1F0FB3458;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6458D30(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, CFX::CrossFrameResourceManager *a5, uint64_t *a6)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v9 = sub_1B63C8330(v12, 0x2F0u, 0x10u);
  return sub_1B6456FCC(v9, *a3, a3[1], v10, a5, a6);
}

uint64_t sub_1B6458D90(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x320u, 0x10u);
  return sub_1B6457FB0(v8, *a3, a3[1], a4, a5);
}

void sub_1B6458DF0(void **a1, _OWORD *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  long long v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a1) >> 4;
    if ((unint64_t)(v9 + 1) >> 60) {
      abort();
    }
    uint64_t v10 = v5 - (void)*a1;
    uint64_t v11 = v10 >> 3;
    if (v10 >> 3 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      uint64_t v13 = (char *)sub_1B6427C8C(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[16 * v9];
    uint64_t v15 = &v13[16 * v12];
    *(_OWORD *)uint64_t v14 = *a2;
    uint64_t v8 = v14 + 16;
    uint64_t v17 = (char *)*a1;
    uint64_t v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        long long v18 = *((_OWORD *)v16 - 1);
        v16 -= 16;
        *((_OWORD *)v14 - 1) = v18;
        v14 -= 16;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *long long v7 = *a2;
    uint64_t v8 = v7 + 1;
  }
  a1[1] = v8;
}

void sub_1B6458ECC(void *a1, _OWORD *a2)
{
  unint64_t v6 = a1[5];
  uint64_t v4 = (uint64_t)(a1 + 5);
  unint64_t v5 = v6;
  long long v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = a1[3];
    uint64_t v10 = ((uint64_t)v7 - v9) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      abort();
    }
    uint64_t v12 = v5 - v9;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      uint64_t v14 = (char *)sub_1B6427C8C(v4, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[16 * v10];
    uint64_t v16 = &v14[16 * v13];
    *(_OWORD *)uint64_t v15 = *a2;
    uint64_t v8 = v15 + 16;
    long long v18 = (char *)a1[3];
    uint64_t v17 = (char *)a1[4];
    if (v17 != v18)
    {
      do
      {
        *((_OWORD *)v15 - 1) = *((_OWORD *)v17 - 1);
        v15 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)a1[3];
    }
    a1[3] = v15;
    a1[4] = v8;
    a1[5] = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    *long long v7 = *a2;
    uint64_t v8 = v7 + 1;
  }
  a1[4] = v8;
}

void sub_1B6458FB8(uint64_t a1, __int16 a2)
{
  uint64_t v3 = a1 + 64;
  unint64_t v4 = *(void *)(a1 + 64);
  __int16 v5 = *(_WORD *)(a1 + 72) + a2;
  unint64_t v6 = *(char **)(a1 + 56);
  if ((unint64_t)v6 >= v4)
  {
    uint64_t v8 = *(char **)(a1 + 48);
    uint64_t v9 = v6 - v8;
    if (v6 - v8 <= -3) {
      abort();
    }
    uint64_t v10 = v9 >> 1;
    unint64_t v11 = v4 - (void)v8;
    if (v11 <= (v9 >> 1) + 1) {
      unint64_t v12 = v10 + 1;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v11 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v13 = v12;
    }
    if (v13)
    {
      uint64_t v14 = (char *)sub_1B645A9E0(v3, v13);
      uint64_t v8 = *(char **)(a1 + 48);
      unint64_t v6 = *(char **)(a1 + 56);
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[2 * v10];
    uint64_t v16 = &v14[2 * v13];
    *(_WORD *)uint64_t v15 = v5;
    long long v7 = v15 + 2;
    while (v6 != v8)
    {
      __int16 v17 = *((_WORD *)v6 - 1);
      v6 -= 2;
      *((_WORD *)v15 - 1) = v17;
      v15 -= 2;
    }
    *(void *)(a1 + 48) = v15;
    *(void *)(a1 + 56) = v7;
    *(void *)(a1 + 64) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(_WORD *)unint64_t v6 = v5;
    long long v7 = v6 + 2;
  }
  *(void *)(a1 + 56) = v7;
}

void sub_1B6459094(void *a1, unsigned int a2)
{
  sub_1B6427B4C((uint64_t)a1, ((uint64_t)(a1[1] - *a1) >> 4) + a2);
  unint64_t v4 = ((uint64_t)(a1[4] - a1[3]) >> 4) + a2;

  sub_1B64590F0((uint64_t)(a1 + 3), v4);
}

void sub_1B64590F0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    sub_1B645AA14((void **)a1, a2 - v2);
  }
}

void sub_1B6459120(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 2 * a2;
    }
  }
  else
  {
    sub_1B645AB30((char **)a1, a2 - v2);
  }
}

void *sub_1B6459150(uint64_t *a1, const char *a2)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = objc_msgSend_meshSourceWithVertices_count_(VFXMeshSource, a2, *a1, (a1[1] - *a1) >> 4);
  uint64_t v5 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v4, a1[6], a1[7] - a1[6]);
  uint64_t v8 = objc_msgSend_meshElementWithData_primitiveType_primitiveCount_bytesPerIndex_(VFXMeshElement, v6, v5, 2, (unint64_t)((a1[7] - a1[6]) >> 1) >> 1, 2);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  if (v9 == v10)
  {
    uint64_t v32 = v3;
    uint64_t v15 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v7, (uint64_t)&v32, 1);
    uint64_t v31 = v8;
    uint64_t v17 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v19, (uint64_t)&v31, 1);
  }
  else
  {
    uint64_t v11 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v7, v9, v10 - v9);
    uint64_t v13 = objc_msgSend_meshSourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride_(VFXMeshSource, v12, v11, @"kGeometrySourceSemanticColor", (a1[4] - a1[3]) >> 4, 1, 4, 4, 0, 0);
    v34[0] = v3;
    v34[1] = v13;
    uint64_t v15 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v14, (uint64_t)v34, 2);
    uint64_t v33 = v8;
    uint64_t v17 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v16, (uint64_t)&v33, 1);
  }
  uint64_t v20 = objc_msgSend_meshWithSources_elements_(VFXMesh, v18, v15, v17);
  uint64_t v23 = objc_msgSend_modelWithMesh_(VFXModel, v21, v20, v22);
  float32x4_t v27 = objc_msgSend_material(v23, v24, v25, v26);
  objc_msgSend_setShadingModel_(v27, v28, 2, v29);
  return v23;
}

void *sub_1B64592FC(uint64_t *a1, const char *a2)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = objc_msgSend_meshSourceWithVertices_count_(VFXMeshSource, a2, *a1, (a1[1] - *a1) >> 4);
  uint64_t v5 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v4, a1[6], a1[7] - a1[6]);
  uint64_t v8 = objc_msgSend_meshElementWithData_primitiveType_primitiveCount_bytesPerIndex_(VFXMeshElement, v6, v5, 0, ((a1[7] - a1[6]) >> 1) / 3uLL, 2);
  uint64_t v9 = a1[3];
  uint64_t v10 = a1[4];
  if (v9 == v10)
  {
    uint64_t v32 = v3;
    uint64_t v15 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v7, (uint64_t)&v32, 1);
    uint64_t v31 = v8;
    uint64_t v17 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v19, (uint64_t)&v31, 1);
  }
  else
  {
    uint64_t v11 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v7, v9, v10 - v9);
    uint64_t v13 = objc_msgSend_meshSourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride_(VFXMeshSource, v12, v11, @"kGeometrySourceSemanticColor", (a1[4] - a1[3]) >> 4, 1, 4, 4, 0, 0);
    v34[0] = v3;
    v34[1] = v13;
    uint64_t v15 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v14, (uint64_t)v34, 2);
    uint64_t v33 = v8;
    uint64_t v17 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x1E4F1C978], v16, (uint64_t)&v33, 1);
  }
  uint64_t v20 = objc_msgSend_meshWithSources_elements_(VFXMesh, v18, v15, v17);
  uint64_t v23 = objc_msgSend_modelWithMesh_(VFXModel, v21, v20, v22);
  float32x4_t v27 = objc_msgSend_material(v23, v24, v25, v26);
  objc_msgSend_setShadingModel_(v27, v28, 2, v29);
  return v23;
}

void *sub_1B64594B4()
{
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  long long v10 = xmmword_1B6E50C00;
  sub_1B6459620((uint64_t)&v11, (float32x4_t *)&v10, &xmmword_1B6E50700, (float32x4_t)xmmword_1B6E50C10);
  long long v8 = xmmword_1B6E50C30;
  long long v9 = xmmword_1B6E50C20;
  *(void *)&long long v0 = 0xBF000000BF000000;
  *((void *)&v0 + 1) = 0xBF000000BF000000;
  long long v6 = v0;
  long long v7 = xmmword_1B6E50C40;
  long long v5 = 0u;
  sub_1B6459764((uint64_t)&v11, &v5, &v9, &v8, &v7, &v6, &xmmword_1B6E50720);
  long long v5 = xmmword_1B6E50C50;
  sub_1B6459850((uint64_t)&v11, (float32x4_t *)&v5, &xmmword_1B6E50720, MEMORY[0x1E4F149A0], 0.5, 0.5);
  long long v4 = xmmword_1B6E50C60;
  sub_1B6459850((uint64_t)&v11, (float32x4_t *)&v4, &xmmword_1B6E50720, MEMORY[0x1E4F149A0], 0.5, 0.5);
  unint64_t v2 = sub_1B6459150((uint64_t *)&v11, v1);
  if ((void)v14)
  {
    *((void *)&v14 + 1) = v14;
    operator delete((void *)v14);
  }
  if (*((void *)&v12 + 1))
  {
    *(void *)&long long v13 = *((void *)&v12 + 1);
    operator delete(*((void **)&v12 + 1));
  }
  if ((void)v11)
  {
    *((void *)&v11 + 1) = v11;
    operator delete((void *)v11);
  }
  return v2;
}

void sub_1B6459600(_Unwind_Exception *a1)
{
  sub_1B640A148(v1 - 96);
  _Unwind_Resume(a1);
}

void sub_1B6459620(uint64_t a1, float32x4_t *a2, _OWORD *a3, float32x4_t a4)
{
  uint64_t v6 = 0;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v7;
  a4.i32[3] = 0;
  float32x4_t v8 = vsubq_f32(*a2, a4);
  int8x16_t v9 = (int8x16_t)vaddq_f32(a4, a4);
  float32x4_t v10 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 3);
  v10.i32[0] = v9.i32[0];
  float32x4_t v16 = v8;
  float32x4_t v17 = vaddq_f32(v10, v8);
  float32x4_t v18 = vaddq_f32((float32x4_t)vextq_s8(v9, (int8x16_t)vuzp2q_s32((int32x4_t)v9, (int32x4_t)v9), 0xCuLL), v8);
  float32x4_t v19 = vaddq_f32(v10, v18);
  int8x16_t v11 = (int8x16_t)vzip2q_s32((int32x4_t)v9, (int32x4_t)v9);
  float32x4_t v12 = (float32x4_t)vextq_s8(v11, v11, 8uLL);
  float32x4_t v20 = vaddq_f32(v12, v8);
  float32x4_t v21 = vaddq_f32(v12, v17);
  float32x4_t v22 = vaddq_f32(v12, v18);
  float32x4_t v23 = vaddq_f32(v12, v19);
  do
  {
    long long v15 = *(long long *)((char *)&v16 + v6);
    sub_1B6458DF0((void **)a1, &v15);
    sub_1B6458ECC((void *)a1, a3);
    v6 += 16;
  }
  while (v6 != 128);
  for (uint64_t i = 0; i != 24; ++i)
    sub_1B6458FB8(a1, word_1B6E50CA0[i]);
  uint64_t v14 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v14;
}

void sub_1B6459764(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, _OWORD *a5, _OWORD *a6, _OWORD *a7)
{
  uint64_t v13 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v13;
  sub_1B6458DF0((void **)a1, a2);
  sub_1B6458DF0((void **)a1, a3);
  sub_1B6458DF0((void **)a1, a4);
  sub_1B6458DF0((void **)a1, a5);
  sub_1B6458DF0((void **)a1, a6);
  int v14 = 5;
  do
  {
    sub_1B6458ECC((void *)a1, a7);
    --v14;
  }
  while (v14);
  for (uint64_t i = 0; i != 16; ++i)
    sub_1B6458FB8(a1, word_1B6E50CD0[i]);
  uint64_t v16 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v16;
}

uint64_t sub_1B6459850(uint64_t a1, float32x4_t *a2, _OWORD *a3, float32x4_t *a4, float a5, float a6)
{
  uint64_t v11 = a1 + 48;
  uint64_t v12 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v12;
  sub_1B6459094((void *)a1, 0x18u);
  int v13 = 0;
  double v14 = 0.0;
  do
  {
    float v15 = v14 * 6.28318531 / 12.0;
    __float2 v16 = __sincosf_stret(v15);
    float32x4_t v17 = a4[1];
    float32x4_t v18 = a4[2];
    float32x4_t v19 = a4[3];
    float32x4_t v20 = vaddq_f32(vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*a4, a6), v17, v16.__sinval * a5), v18, v16.__cosval * a5), (float32x4_t)0, v19), *a2);
    *(float32x4_t *)(*(void *)a1 + 16 * (v13 + *(_DWORD *)(a1 + 72))) = vaddq_f32(vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*a4, -a6), v17, v16.__sinval * a5), v18, v16.__cosval * a5), (float32x4_t)0, v19), *a2);
    *(float32x4_t *)(*(void *)a1 + 16 * (v13 + *(_DWORD *)(a1 + 72) + 12)) = v20;
    *(_OWORD *)(*(void *)(a1 + 24) + 16 * (v13 + *(_DWORD *)(a1 + 72))) = *a3;
    *(_OWORD *)(*(void *)(a1 + 24) + 16 * (v13 + *(_DWORD *)(a1 + 72) + 12)) = *a3;
    double v14 = v14 + 1.0;
    ++v13;
  }
  while (v13 != 12);
  sub_1B6459120(v11, ((uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1) + 72);
  int v21 = 0;
  __int16 v22 = 0;
  int v23 = *(_DWORD *)(a1 + 72);
  int v24 = *(_DWORD *)(a1 + 76);
  uint64_t v25 = *(void *)(a1 + 48);
  do
  {
    __int16 v26 = v23 + v22;
    int v27 = v24 + v21;
    *(_WORD *)(v25 + 2 * (v24 + v21)) = v23 + v22;
    if (v21 == 66) {
      __int16 v28 = 0;
    }
    else {
      __int16 v28 = v22 + 1;
    }
    *(_WORD *)(v25 + 2 * (v27 + 1)) = v23 + v28;
    ++v22;
    *(_WORD *)(v25 + 2 * (v27 + 2)) = v26 + 12;
    uint64_t result = (v27 + 3);
    *(_WORD *)(v25 + 2 * result) = v23 + 12 + v28;
    *(_WORD *)(v25 + 2 * (v27 + 4)) = v26;
    *(_WORD *)(v25 + 2 * (v27 + 5)) = v26 + 12;
    v21 += 6;
  }
  while (v21 != 72);
  unint64_t v30 = (unint64_t)(*(void *)(a1 + 56) - v25) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v30;
  return result;
}

void *sub_1B6459A58()
{
  *(_OWORD *)__p = 0u;
  long long v7 = 0u;
  *(_OWORD *)long long v4 = 0u;
  long long v5 = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  sub_1B6459AF0((uint64_t)v3, &xmmword_1B6E50720);
  uint64_t v1 = sub_1B6459150((uint64_t *)v3, v0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v4[1])
  {
    *(void **)&long long v5 = v4[1];
    operator delete(v4[1]);
  }
  if (v3[0])
  {
    v3[1] = v3[0];
    operator delete(v3[0]);
  }
  return v1;
}

void sub_1B6459ADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B6459AF0(uint64_t a1, _OWORD *a2)
{
  long long v13 = 0uLL;
  long long v11 = xmmword_1B6E50C80;
  long long v12 = xmmword_1B6E50C70;
  __asm { FMOV            V1.4S, #-1.0 }
  long long v9 = xmmword_1B6E50C90;
  long long v10 = _Q1;
  sub_1B645A398(a1, &v13, &v12, a2, a2);
  sub_1B645A398(a1, &v13, &v11, a2, a2);
  sub_1B645A398(a1, &v13, &v9, a2, a2);
  sub_1B645A398(a1, &v13, &v10, a2, a2);
  sub_1B645A444(a1, &v12, &v11, &v9, &v10, a2);
}

void *sub_1B6459BBC()
{
  *(_OWORD *)__p = 0u;
  long long v13 = 0u;
  *(_OWORD *)long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = xmmword_1B6E4F340;
  *(_OWORD *)long long v9 = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  sub_1B6459620((uint64_t)v9, (float32x4_t *)&v8, &xmmword_1B6E50720, _Q0);
  uint64_t v6 = sub_1B6459150((uint64_t *)v9, v5);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v10[1])
  {
    *(void **)&long long v11 = v10[1];
    operator delete(v10[1]);
  }
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }
  return v6;
}

void sub_1B6459C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1B640A148((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1B6459C68()
{
  *(_OWORD *)__p = 0u;
  long long v12 = 0u;
  *(_OWORD *)long long v9 = 0u;
  long long v10 = 0u;
  *(_OWORD *)long long v8 = 0u;
  long long v15 = xmmword_1B6E50C80;
  long long v16 = xmmword_1B6E50C70;
  __asm { FMOV            V0.4S, #-1.0 }
  long long v14 = _Q0;
  long long v13 = xmmword_1B6E50C90;
  sub_1B645A444((uint64_t)v8, &v16, &v15, &v13, &v14, &xmmword_1B6E50720);
  uint64_t v6 = sub_1B6459150((uint64_t *)v8, v5);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v9[1])
  {
    *(void **)&long long v10 = v9[1];
    operator delete(v9[1]);
  }
  if (v8[0])
  {
    v8[1] = v8[0];
    operator delete(v8[0]);
  }
  return v6;
}

void sub_1B6459D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1B6459D38()
{
  *(_OWORD *)__p = 0u;
  long long v12 = 0u;
  *(_OWORD *)long long v9 = 0u;
  long long v10 = 0u;
  *(_OWORD *)long long v8 = 0u;
  long long v15 = xmmword_1B6E50C80;
  long long v16 = xmmword_1B6E50C70;
  __asm { FMOV            V0.4S, #-1.0 }
  long long v14 = _Q0;
  long long v13 = xmmword_1B6E50C90;
  sub_1B645A444((uint64_t)v8, &v16, &v15, &v13, &v14, &xmmword_1B6E506F0);
  uint64_t v6 = sub_1B6459150((uint64_t *)v8, v5);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v9[1])
  {
    *(void **)&long long v10 = v9[1];
    operator delete(v9[1]);
  }
  if (v8[0])
  {
    v8[1] = v8[0];
    operator delete(v8[0]);
  }
  return v6;
}

void sub_1B6459DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1B6459E08()
{
  *(_OWORD *)__p = 0u;
  long long v7 = 0u;
  *(_OWORD *)long long v4 = 0u;
  long long v5 = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  long long v8 = 0u;
  sub_1B645A04C((uint64_t)v3, (float32x2_t *)&v8, 1u);
  uint64_t v1 = sub_1B6459150((uint64_t *)v3, v0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v4[1])
  {
    *(void **)&long long v5 = v4[1];
    operator delete(v4[1]);
  }
  if (v3[0])
  {
    v3[1] = v3[0];
    operator delete(v3[0]);
  }
  return v1;
}

void sub_1B6459EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B6459EB8(uint64_t a1, unsigned int a2)
{
  long long v2 = 0u;
  sub_1B645A04C(a1, (float32x2_t *)&v2, a2);
}

void sub_1B6459EF0(uint64_t a1, float32x2_t *a2, _OWORD *a3, int32x2_t a4)
{
  uint64_t v7 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v7;
  float32x2_t v8 = (float32x2_t)vdup_lane_s32(a4, 0);
  double v9 = 0.0;
  int v10 = 24;
  do
  {
    float v11 = v9 * 6.28318531 / 23.0;
    __float2 v12 = __sincosf_stret(v11);
    *(float32x2_t *)&long long v13 = vmla_f32(*a2, (float32x2_t)__PAIR64__(LODWORD(v12.__sinval), LODWORD(v12.__cosval)), v8);
    *((float *)&v13 + 2) = a2[1].f32[0] + 0.0;
    long long v17 = v13;
    sub_1B6458DF0((void **)a1, &v17);
    sub_1B6458ECC((void *)a1, a3);
    double v9 = v9 + 1.0;
    --v10;
  }
  while (v10);
  for (int i = 1; i != 25; ++i)
  {
    sub_1B6458FB8(a1, i - 1);
    if (i == 24) {
      __int16 v15 = 0;
    }
    else {
      __int16 v15 = i;
    }
    sub_1B6458FB8(a1, v15);
  }
  uint64_t v16 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v16;
}

void sub_1B645A01C(uint64_t a1, _OWORD *a2, int32x2_t a3)
{
  long long v3 = 0u;
  sub_1B6459EF0(a1, (float32x2_t *)&v3, a2, a3);
}

void sub_1B645A04C(uint64_t a1, float32x2_t *a2, unsigned int a3)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v6;
  uint64_t v7 = 48 * a3;
  MEMORY[0x1F4188790](a1, a2);
  float32x2_t v8 = &v57[-16 * v7];
  uint64_t v10 = (32 * v9);
  *(double *)&long long v14 = MEMORY[0x1F4188790](v11, v12);
  __int16 v15 = (__int16 *)&v57[-2 * v10];
  if (v16)
  {
    uint64_t v59 = v13;
    int v17 = 0;
    int v58 = 2 * a3;
    double v62 = (double)(a3 + 1);
    float v19 = a2->f32[0];
    float v18 = a2->f32[1];
    float v60 = *((float *)&v14 + 1);
    float v61 = v18;
    float v20 = a2[1].f32[0];
    long long v63 = v14;
    float v21 = *((float *)&v14 + 2);
    __int16 v22 = &v57[-16 * v7];
    do
    {
      float v23 = (double)++v17 * 3.14159265 / v62;
      __float2 v24 = __sincosf_stret(v23);
      uint64_t v25 = 0;
      float v26 = *(float *)&v63 * v24.__sinval;
      *(float *)&long long v27 = v61 + (float)(v60 * v24.__cosval);
      long long v64 = v27;
      float v28 = 0.0;
      do
      {
        __float2 v29 = __sincosf_stret(v28);
        *(float *)&long long v30 = v19 + (float)(v26 * v29.__cosval);
        DWORD1(v30) = v64;
        *((float *)&v30 + 2) = v20 + (float)((float)(v21 * v24.__sinval) * v29.__sinval);
        *(_OWORD *)&v22[v25] = v30;
        float v28 = v28 + 0.2618;
        v25 += 16;
      }
      while (v25 != 384);
      v22 += 384;
    }
    while (v17 != a3);
    int v31 = 0;
    double v32 = 0.0;
    do
    {
      float v33 = v32 * 3.14159265 / (double)a3;
      __float2 v34 = __sincosf_stret(v33);
      uint64_t v35 = 0;
      long long v36 = v63;
      *(float *)&long long v36 = *(float *)&v63 * v34.__cosval;
      long long v64 = v36;
      float v37 = 0.0;
      do
      {
        __float2 v38 = __sincosf_stret(v37);
        *(float32x2_t *)&long long v39 = vmla_f32(*a2, (float32x2_t)__PAIR64__(LODWORD(v38.__sinval), LODWORD(v38.__cosval)), *(float32x2_t *)&v64);
        *((float *)&v39 + 2) = a2[1].f32[0] + (float)((float)(v21 * v34.__sinval) * v38.__cosval);
        *(_OWORD *)&v22[v35] = v39;
        float v37 = v37 + 0.2618;
        v35 += 16;
      }
      while (v35 != 384);
      v22 += 384;
      double v32 = v32 + 1.0;
      ++v31;
    }
    while (v31 != a3);
    id v40 = v59;
    int v41 = v58;
    if (v58)
    {
      int v42 = 0;
      unsigned int v43 = 0;
      v44.i64[0] = 0x100000001;
      v44.i64[1] = 0x100000001;
      v45.i64[0] = 0x1800000018;
      v45.i64[1] = 0x1800000018;
      v46.i64[0] = 0x800000008;
      v46.i64[1] = 0x800000008;
      uint64_t v47 = &v57[-2 * v10];
      do
      {
        uint64_t v48 = 0;
        int32x4_t v49 = vdupq_n_s32(v43);
        int32x4_t v50 = (int32x4_t)xmmword_1B6E4B1A0;
        int32x4_t v51 = (int32x4_t)xmmword_1B6E4B190;
        do
        {
          uint64_t v52 = (__int16 *)&v47[v48];
          v66.val[0] = vuzp1q_s16((int16x8_t)vaddq_s32(v50, v49), (int16x8_t)vaddq_s32(v51, v49));
          int8x16_t v53 = (int8x16_t)vaddq_s32(v51, v44);
          int8x16_t v54 = (int8x16_t)vaddq_s32(v50, v44);
          v66.val[1] = vuzp1q_s16((int16x8_t)vaddq_s32((int32x4_t)vbicq_s8(v54, (int8x16_t)vceqq_s32((int32x4_t)v54, v45)), v49), (int16x8_t)vaddq_s32((int32x4_t)vbicq_s8(v53, (int8x16_t)vceqq_s32((int32x4_t)v53, v45)), v49));
          vst2q_s16(v52, v66);
          int32x4_t v50 = vaddq_s32(v50, v46);
          int32x4_t v51 = vaddq_s32(v51, v46);
          v48 += 32;
        }
        while (v48 != 96);
        v43 += 24;
        ++v42;
        v47 += 96;
      }
      while (v42 != v41);
    }
    if (v7)
    {
      do
      {
        sub_1B6458DF0((void **)a1, v8);
        sub_1B6458ECC((void *)a1, v40);
        ++v8;
        --v7;
      }
      while (v7);
    }
    if (v10)
    {
      do
      {
        __int16 v55 = *v15++;
        sub_1B6458FB8(a1, v55);
        --v10;
      }
      while (v10);
    }
  }
  uint64_t v56 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v56;
}

void sub_1B645A398(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, _OWORD *a5)
{
  uint64_t v9 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v9;
  sub_1B6458DF0((void **)a1, a2);
  sub_1B6458DF0((void **)a1, a3);
  sub_1B6458ECC((void *)a1, a4);
  sub_1B6458ECC((void *)a1, a5);
  sub_1B6458FB8(a1, 0);
  sub_1B6458FB8(a1, 1);
  uint64_t v10 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v10;
}

void sub_1B645A444(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, _OWORD *a5, _OWORD *a6)
{
  uint64_t v12 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v12;
  sub_1B645A398(a1, a2, a3, a6, a6);
  sub_1B645A398(a1, a3, a4, a6, a6);
  sub_1B645A398(a1, a4, a5, a6, a6);
  sub_1B645A398(a1, a5, a2, a6, a6);
  uint64_t v13 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v13;
}

void sub_1B645A514(uint64_t a1, float32x4_t *a2, float32x2_t *a3, _OWORD *a4, float a5, float a6)
{
  uint64_t v10 = a1 + 48;
  uint64_t v11 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v11;
  sub_1B6459094((void *)a1, 0x33u);
  int v12 = 0;
  float32x4_t v13 = *a2;
  float32x4_t v28 = *a2;
  v13.i32[0] = (__int32)a3[1];
  v14.i32[0] = 1.0;
  v15.i64[0] = 0x8000000080000000;
  v15.i64[1] = 0x8000000080000000;
  v15.i32[0] = vbslq_s8(v15, v14, (int8x16_t)v13).i32[0];
  float v16 = COERCE_FLOAT(HIDWORD(*(unint64_t *)a3)) / (float)(fabsf(v13.f32[0]) + 1.0);
  float v17 = vmuls_lane_f32(v16, *a3, 1);
  v18.f32[0] = -(float)(COERCE_FLOAT(*(_OWORD *)a3->f32) * v16);
  v13.f32[0] = v13.f32[0] + (float)(*(float *)v15.i32 * v17);
  v13.f32[1] = *(float *)v15.i32 * v18.f32[0];
  v13.f32[2] = -COERCE_FLOAT(*(_OWORD *)a3->f32);
  v18.f32[1] = 1.0 - v17;
  v18.i32[2] = vmuls_lane_f32(-*(float *)v15.i32, *a3, 1);
  float32x4_t v31 = vmulq_n_f32(v13, a6);
  float32x4_t v33 = vmlaq_n_f32(*a2, *(float32x4_t *)a3->f32, a5);
  float32x4_t v30 = vmulq_n_f32(v18, a6);
  float v19 = 0.0;
  do
  {
    __float2 v20 = __sincosf_stret(v19);
    *(float32x4_t *)(*(void *)a1 + 16 * (v12 + *(_DWORD *)(a1 + 72))) = vmlaq_n_f32(vmlaq_n_f32(v33, v31, v20.__cosval), v30, v20.__sinval);
    *(_OWORD *)(*(void *)(a1 + 24) + 16 * (v12 + *(_DWORD *)(a1 + 72))) = *a4;
    ++v12;
    float v19 = v19 + 0.12566;
  }
  while (v12 != 50);
  *(float32x4_t *)(*(void *)a1 + 16 * (*(_DWORD *)(a1 + 72) + 50)) = v28;
  *(_OWORD *)(*(void *)(a1 + 24) + 16 * (*(_DWORD *)(a1 + 72) + 50)) = *a4;
  sub_1B6459120(v10, ((uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1) + 108);
  int v21 = *(_DWORD *)(a1 + 72);
  unsigned int v22 = *(_DWORD *)(a1 + 76);
  uint64_t v23 = *(void *)(a1 + 48);
  int v24 = 1;
  unsigned int v25 = v22;
  do
  {
    *(_WORD *)(v23 + 2 * v25) = v21 + v24 - 1;
    if (v24 == 50) {
      __int16 v26 = 0;
    }
    else {
      __int16 v26 = v24;
    }
    *(_WORD *)(v23 + 2 * (v25 + 1)) = v21 + v26;
    v25 += 2;
    ++v24;
  }
  while (v24 != 51);
  *(_WORD *)(v23 + 2 * (v22 + 100)) = v21 + 50;
  *(_WORD *)(v23 + 2 * (v22 + 101)) = v21;
  *(_WORD *)(v23 + 2 * (v22 + 102)) = v21 + 50;
  *(_WORD *)(v23 + 2 * (v22 + 103)) = v21 + 12;
  *(_WORD *)(v23 + 2 * (v22 + 104)) = v21 + 50;
  *(_WORD *)(v23 + 2 * (v22 + 105)) = v21 + 25;
  *(_WORD *)(v23 + 2 * (v22 + 106)) = v21 + 50;
  *(_WORD *)(v23 + 2 * (v22 + 107)) = v21 + 37;
  unint64_t v27 = (unint64_t)(*(void *)(a1 + 56) - v23) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v27;
}

void sub_1B645A758(uint64_t a1, _OWORD *a2)
{
  long long v4 = (void *)(a1 + 48);
  uint64_t v5 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v5;
  sub_1B6459094((void *)a1, 0x25u);
  sub_1B6459120((uint64_t)v4, ((uint64_t)(*(void *)(a1 + 56) - *v4) >> 1) + 180);
  unsigned __int16 v6 = 0;
  int v7 = 5;
  int v8 = 2;
  __asm
  {
    FMOV            V10.2S, #5.0
    FMOV            V0.4S, #0.75
  }
  uint64_t v38 = *((void *)&_Q0 + 1);
  float64x2_t v39 = (float64x2_t)vdupq_n_s64(0x3F847AE140000000uLL);
  do
  {
    unsigned int v15 = v6;
    __double2 v17 = __sincos_stret(((double)v15 + (double)v15) * 3.14159265 / 12.0);
    v16.f64[0] = v17.__cosval;
    int v18 = *(_DWORD *)(a1 + 72);
    __int16 v19 = v8 + v18;
    unsigned int v20 = v8 + v18 - 2;
    unsigned int v21 = v7 + *(_DWORD *)(a1 + 76);
    uint64_t v22 = *(void *)(a1 + 48);
    *(_WORD *)(v22 + 2 * (v21 - 5)) = v8 + v18 - 2;
    if (v6 == 11) {
      __int16 v23 = -36;
    }
    else {
      __int16 v23 = 0;
    }
    __int16 v24 = v8 + v23 + v18;
    __int16 v25 = v24 + 2;
    *(_WORD *)(v22 + 2 * (v21 - 4)) = v24 + 2;
    *(_WORD *)(v22 + 2 * (v21 - 3)) = v19 - 1;
    *(_WORD *)(v22 + 2 * (v21 - 2)) = v20;
    *(_WORD *)(v22 + 2 * (v21 - 1)) = v24 + 1;
    *(_WORD *)(v22 + 2 * v21) = v24 + 2;
    *(_WORD *)(v22 + 2 * (v21 + 1)) = v19 - 1;
    v24 += 3;
    *(_WORD *)(v22 + 2 * (v21 + 2)) = v24;
    *(_WORD *)(v22 + 2 * (v21 + 3)) = v19;
    *(_WORD *)(v22 + 2 * (v21 + 4)) = v19 - 1;
    *(_WORD *)(v22 + 2 * (v21 + 5)) = v25;
    *(_WORD *)(v22 + 2 * (v21 + 6)) = v24;
    v16.f64[1] = v17.__sinval;
    float64x2_t v26 = vmulq_f64(v16, v39);
    *(float32x2_t *)&v26.f64[0] = vcvt_f32_f64(v26);
    *(float64x2_t *)(*(void *)a1 + 16 * v20) = v26;
    *(float32x2_t *)&v16.f64[0] = vmul_f32(*(float32x2_t *)&v26.f64[0], _D10);
    LODWORD(v16.f64[1]) = 0.75;
    *((void *)&v27 + 1) = v38;
    *(float64_t *)&long long v27 = v26.f64[0];
    *(_OWORD *)(*(void *)a1 + 16 * (v8 + *(_DWORD *)(a1 + 72) - 1)) = v27;
    *(float64x2_t *)(*(void *)a1 + 16 * (v8 + *(_DWORD *)(a1 + 72))) = v16;
    ++v6;
    v7 += 12;
    v8 += 3;
  }
  while (v15 < 0xB);
  int v28 = 0;
  int v30 = *(_DWORD *)(a1 + 72);
  int v29 = *(_DWORD *)(a1 + 76);
  unsigned int v31 = v30 + 36;
  uint64_t v32 = *(void *)(a1 + 48);
  int v33 = v30 + 32;
  do
  {
    int v34 = v29 + v28;
    *(_WORD *)(v32 + 2 * (v29 + v28 + 144)) = v31;
    if (v28 == 33) {
      __int16 v35 = 36;
    }
    else {
      __int16 v35 = 0;
    }
    *(_WORD *)(v32 + 2 * (v34 + 145)) = v35 + v33;
    *(_WORD *)(v32 + 2 * (v34 + 146)) = v33 + 3;
    v33 -= 3;
    v28 += 3;
  }
  while (v28 != 36);
  int v36 = 0;
  *(_OWORD *)(*(void *)a1 + 16 * v31) = xmmword_1B6E4F2E0;
  do
  {
    *(_OWORD *)(*(void *)(a1 + 24) + 16 * (v36 + *(_DWORD *)(a1 + 72))) = *a2;
    ++v36;
  }
  while (v36 != 37);
  uint64_t v37 = (*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 1;
  *(_DWORD *)(a1 + 72) = (*(void *)(a1 + 8) - *(void *)a1) >> 4;
  *(_DWORD *)(a1 + 76) = v37;
}

void *sub_1B645A9E0(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_1B63C8620();
  }
  return operator new(2 * a2);
}

void sub_1B645AA14(void **a1, unint64_t a2)
{
  unsigned __int16 v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      float32x4_t v13 = (char *)sub_1B6427C8C(v4, v12);
    }
    else {
      float32x4_t v13 = 0;
    }
    int8x16_t v14 = &v13[16 * v10];
    unsigned int v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    float64x2_t v16 = &v14[16 * a2];
    int v18 = (char *)*a1;
    __double2 v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      __double2 v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void sub_1B645AB30(char **a1, unint64_t a2)
{
  unsigned __int16 v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    uint64_t v10 = a2 + (v9 >> 1);
    if (v10 < 0) {
      abort();
    }
    uint64_t v11 = v9 >> 1;
    unint64_t v12 = v5 - v8;
    if (v12 > v10) {
      uint64_t v10 = v12;
    }
    if (v12 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v13 = v10;
    }
    if (v13)
    {
      int8x16_t v14 = (char *)sub_1B645A9E0(v4, v13);
      uint64_t v8 = *a1;
      int v7 = a1[1];
    }
    else
    {
      int8x16_t v14 = 0;
    }
    unsigned int v15 = &v14[2 * v11];
    float64x2_t v16 = &v14[2 * v13];
    bzero(v15, 2 * a2);
    __double2 v17 = &v15[2 * a2];
    while (v7 != v8)
    {
      __int16 v18 = *((_WORD *)v7 - 1);
      v7 -= 2;
      *((_WORD *)v15 - 1) = v18;
      v15 -= 2;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t sub_1B645DA10(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_delegate(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v7 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](v5, sel_cameraInertiaWillStartForController_, v7, v6);
}

uint64_t sub_1B645DA4C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  CACurrentMediaTime();

  return MEMORY[0x1F4181798](v1, sel__updateInertiaAtTime_, v2, v3);
}

uint64_t sub_1B645DA84(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_delegate(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v7 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](v5, sel_cameraInertiaDidEndForController_, v7, v6);
}

__n128 sub_1B645DCC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = 0;
  uint64_t v8 = *a4;
  memset(v12, 0, sizeof(v12));
  long long v13 = 0u;
  BYTE12(v13) = 1;
  BYTE14(v13) = 1;
  uint64_t v14 = 0;
  do
  {
    uint64_t v9 = &v12[v7];
    *uint64_t v9 = 0;
    v9[1] = 0;
    uint64_t v9[2] = 0;
    v9[3] = 0x3FF0000000000000;
    v7 += 2;
  }
  while (v7 != 16);
  BYTE3(v14) = 1;
  BYTE5(v14) = 1;
  HIBYTE(v14) = 1;
  uint64_t v10 = CFX::RG::Pass::Pass(a1, a2, a3, v8, v12, a5, a6);
  *(void *)uint64_t v10 = &unk_1F0FB3038;
  __n128 result = *(__n128 *)a4;
  *(void *)(v10 + 376) = a4[2];
  *(__n128 *)(v10 + 360) = result;
  return result;
}

uint64_t sub_1B645DD98(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  uint64_t v4 = v3[270];
  uint64_t v5 = v3[271];
  uint64_t v6 = v3[272];
  uint64_t v7 = v3[273];
  *(unsigned char *)(a2 + 32) = v3[269] != 0;
  uint64_t v11 = objc_msgSend_frontFacingWinding(*(void **)(a2 + 16), v8, v9, v10);
  uint64_t v14 = v11;
  if (*(unsigned char *)(a2 + 32)) {
    uint64_t v14 = *((void *)&xmmword_1B6E50D30 + v11);
  }
  objc_msgSend_setFrontFacingWinding_(*(void **)(a2 + 16), v12, v14, v13);
  if (*(unsigned char *)(a2 + 32)) {
    uint64_t v4 = *((void *)&xmmword_1B6E50D30 + v4);
  }
  objc_msgSend_setFrontFacingWinding_(*(void **)(a2 + 16), v15, v4, v16);
  objc_msgSend_setTriangleFillMode_(*(void **)(a2 + 16), v17, v5, v18);
  objc_msgSend_setDepthClipMode_(*(void **)(a2 + 16), v19, v6, v20);
  __int16 v23 = *(void **)(a2 + 16);

  return objc_msgSend_setCullMode_(v23, v21, v7, v22);
}

uint64_t sub_1B645DE7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (void *)sub_1B6445900(*(void *)(a1 + 368), a2, a3, a4, a5, a6, a7, a8);

  return objc_msgSend_renderEncoder(v8, v9, v10, v11);
}

uint64_t *sub_1B645DEA8(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  switch(a3)
  {
    case 2:
      uint64_t v11 = a4 + 8;
      unint64_t v12 = *(void **)(a4 + 16);
      uint64_t v13 = (void *)sub_1B6445900(result[46], a2, a3, a4, a5, a6, a7, a8);
      uint64_t v17 = objc_msgSend_renderEncoder(v13, v14, v15, v16);
      int v21 = objc_msgSend_renderTargetArrayLength(v12, v18, v19, v20);
      if (*((unsigned char *)v9 + 376) != 1)
      {
        if (!*((unsigned char *)v9 + 376))
        {
          if (*(unsigned char *)(v17 + 4) != 1)
          {
            *(unsigned char *)(v17 + 4) = 1;
            objc_msgSend_setVertexAmplificationCount_viewMappings_(*(void **)(v17 + 16), v22, 1, 0);
          }
          goto LABEL_22;
        }
        int v30 = @"Unreachable code: Not implemented";
        goto LABEL_21;
      }
      int v29 = *((unsigned __int8 *)v9 + 377);
      if (v29 == 1)
      {
        *(_DWORD *)uint64_t v17 = v21;
      }
      else
      {
        if (v29 != 2)
        {
          int v30 = @"Unreachable code: Layered rendering is lacking a multiple output vertex streams generator";
LABEL_21:
          sub_1B63F2F54(16, (uint64_t)v30, v23, v24, v25, v26, v27, v28, v32);
          goto LABEL_22;
        }
        sub_1B645E088(v17, (const char *)v21, 1, v24, v25, v26, v27, v28);
      }
LABEL_22:
      sub_1B645DD98((uint64_t)v9, v17);
      unsigned int v31 = *(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 56);
      return (uint64_t *)v31(v9, a2, v11);
    case 1:
      uint64_t v10 = *(uint64_t (**)(void))(*result + 48);
      return (uint64_t *)v10();
    case 0:
      uint64_t v10 = *(uint64_t (**)(void))(*result + 40);
      return (uint64_t *)v10();
  }
  return result;
}

uint64_t sub_1B645E088(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*(unsigned __int8 *)(result + 4) == a2) {
    return result;
  }
  unsigned int v8 = a2;
  uint64_t v9 = result;
  *(unsigned char *)(result + 4) = (_BYTE)a2;
  if (a2 > 1)
  {
    if (a3 == 2)
    {
      long long v11 = xmmword_1B6E4F270;
    }
    else
    {
      if (a3 != 1)
      {
        sub_1B63F2F54(16, @"Unreachable code: Vertex amplification shouldn't be active", a3, a4, a5, a6, a7, a8, v12);
        return objc_msgSend_setVertexAmplificationCount_viewMappings_(*(void **)(v9 + 16), a2, v8, (uint64_t)&v12);
      }
      long long v11 = xmmword_1B6E50D20;
    }
    long long v12 = v11;
    return objc_msgSend_setVertexAmplificationCount_viewMappings_(*(void **)(v9 + 16), a2, v8, (uint64_t)&v12);
  }
  uint64_t v10 = *(void **)(result + 16);

  return objc_msgSend_setVertexAmplificationCount_viewMappings_(v10, a2, 1, 0);
}

void sub_1B645E18C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B645E434(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateContraintAndAddToWorld_, *(void *)(*(void *)(a1 + 32) + 8), a4);
}

uint64_t sub_1B645E4F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__updateContraintAndAddToWorld_, *(void *)(*(void *)(a1 + 32) + 8), a4);
}

uint64_t sub_1B645F028(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB3DD8;

  *(void *)(a1 + 16) = 0;
  return a1;
}

void sub_1B645F074(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB3DD8;

  *(void *)(a1 + 16) = 0;

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B645F0E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, const void *a6)
{
  uint64_t v9 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAD28, memory_order_acquire) & 1) == 0)
  {
    uint64_t v13 = a2;
    uint64_t v14 = a3;
    int v12 = __cxa_guard_acquire(&qword_1E9DDAD28);
    uint64_t v9 = &unk_1E9DDA000;
    a2 = v13;
    a3 = v14;
    if (v12)
    {
      byte_1E9DDAD20 = 1;
      __cxa_guard_release(&qword_1E9DDAD28);
      uint64_t v9 = (unsigned char *)&unk_1E9DDA000;
      a2 = v13;
      a3 = v14;
    }
  }
  if (v9[3360]) {
    uint64_t v10 = 0x1A7B0322067A52BCLL;
  }
  else {
    uint64_t v10 = 0;
  }
  CFX::RG::Pass::Pass(a1, a2, a3, (uint64_t)"MetalFXUpscalePass", 1, v10, 0);
  *(void *)a1 = &unk_1F0FB3DF8;
  memcpy((void *)(a1 + 360), a6, 0x2A0uLL);
  *(void *)(a1 + 1032) = 0;
  *(void *)(a1 + 1048) = 0;
  *(void *)(a1 + 1040) = 0;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(a1 + 368), MTLPixelFormatRGBA16Float, (uint64_t)v15);
  *(void *)(a1 + 1056) = sub_1B63CFDE4(a4, (uint64_t)"MetalFXUpscalePassOutput", v15);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 1008));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 1016));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 1024));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 1056));
  return a1;
}

void sub_1B645F230(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B645F244(uint64_t a1, CFX::CrossFrameResourceManager **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 360), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 1040) = v10;
  *(void *)(a1 + 1048) = objc_msgSend_resourceManager(v10, v11, v12, v13);
  CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 1056));
  uint64_t v14 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 1008));
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  uint64_t v17 = *((void *)v14 + 2);
  uint64_t v18 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 1016));
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  uint64_t v21 = *((void *)v18 + 2);
  uint64_t v22 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 1024));
  uint64_t v23 = *v22;
  uint64_t v36 = v22[1];
  uint64_t v24 = *((void *)v22 + 2);
  unint64_t v25 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v26 = 0x9DDFEA08EB382D69
      * (v25 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v15)));
  unint64_t v27 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47))) ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47))) ^ v16)));
  unint64_t v28 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47))) ^ v17)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47))) ^ v17)));
  unint64_t v29 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v28 ^ (v28 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v28 ^ (v28 >> 47))) ^ v19)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v28 ^ (v28 >> 47))) ^ v19)));
  unint64_t v30 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47))) ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47))) ^ v20)));
  unint64_t v31 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47))) ^ v21)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47))) ^ v21)));
  unint64_t v32 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47))) ^ v23)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47))) ^ v23)));
  unint64_t v33 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v32 ^ (v32 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v32 ^ (v32 >> 47))) ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v32 ^ (v32 >> 47))) ^ v36)));
  unint64_t v34 = 0x9DDFEA08EB382D69 * (v33 ^ (v33 >> 47));
  uint64_t result = CFX::CrossFrameResourceManager::get(a2[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ v24)) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ v24)))) ^ ((0x9DDFEA08EB382D69 * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ v24)) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ v24)))) >> 47)));
  *(void *)(a1 + 1032) = result;
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t sub_1B645F528(uint64_t a1, CFX::GPUResourceManager **a2, uint64_t a3)
{
  id Texture = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 1008));
  id v7 = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 1016));
  id v8 = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 1024));
  id v9 = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 1056));
  objc_msgSend_setColorTexture_(*(void **)(*(void *)(a1 + 1032) + 16), v10, (uint64_t)Texture, v11);
  objc_msgSend_setDepthTexture_(*(void **)(*(void *)(a1 + 1032) + 16), v12, (uint64_t)v7, v13);
  objc_msgSend_setMotionTexture_(*(void **)(*(void *)(a1 + 1032) + 16), v14, (uint64_t)v8, v15);
  objc_msgSend_setOutputTexture_(*(void **)(*(void *)(a1 + 1032) + 16), v16, (uint64_t)v9, v17);
  float32x2_t v51 = sub_1B6447FE4(*(float32x2_t **)(a1 + 360), 0, v18, v19);
  double v23 = 0.5;
  double v24 = 0.5
      - (float)((float)(unint64_t)objc_msgSend_inputWidth(*(void **)(*(void *)(a1 + 1032) + 16), v20, v21, v22)* v51.f32[0])* 0.5;
  *(float *)&double v24 = v24;
  objc_msgSend_setJitterOffsetX_(*(void **)(*(void *)(a1 + 1032) + 16), v25, v26, v27, v24);
  double v31 = 0.5
      - vmuls_lane_f32((float)(unint64_t)objc_msgSend_inputHeight(*(void **)(*(void *)(a1 + 1032) + 16), v28, v29, v30), v51, 1)* 0.5;
  *(float *)&double v31 = v31;
  *(float *)&double v31 = -*(float *)&v31;
  objc_msgSend_setJitterOffsetY_(*(void **)(*(void *)(a1 + 1032) + 16), v32, v33, v34, v31);
  __int16 v35 = (_WORD *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 1024));
  LOWORD(v36) = *v35;
  *(float *)&double v37 = (float)v36;
  LOWORD(v23) = v35[1];
  objc_msgSend_setMotionVectorScaleX_(*(void **)(*(void *)(a1 + 1032) + 16), v38, v39, v40, v37);
  *(float *)&double v41 = (float)LODWORD(v23);
  objc_msgSend_setMotionVectorScaleY_(*(void **)(*(void *)(a1 + 1032) + 16), v42, v43, v44, v41);
  objc_msgSend_setDepthReversed_(*(void **)(*(void *)(a1 + 1032) + 16), v45, 1, v46);
  uint64_t v48 = *(void *)(*(void *)(a1 + 1032) + 16);
  uint64_t v49 = *(void *)(a3 + 16);

  return MEMORY[0x1F4181798](v48, sel_encodeToCommandBuffer_, v49, v47);
}

uint64_t sub_1B645F6DC(uint64_t result, CFX::GPUResourceManager **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 == 2) {
    return sub_1B645F528(result, a2, a4 + 8);
  }
  if (a3 == 1) {
    return sub_1B645F244(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B645F6FC(uint64_t a1)
{
  return *(void *)(a1 + 1056);
}

uint64_t sub_1B645F704(uint64_t *a1, uint64_t a2, const void *a3)
{
  return sub_1B645F714(a1, a1, a2, a3);
}

uint64_t sub_1B645F714(uint64_t *a1, uint64_t *a2, uint64_t a3, const void *a4)
{
  uint64_t v7 = a1[1];
  v9[0] = *a1;
  v9[1] = v7;
  v9[0] = sub_1B645F7AC(v9[0], v7, v9, a2, a3, a4);
  sub_1B63C88CC(a1 + 18, v9);
  return v9[0];
}

void sub_1B645F774(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B645F7AC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, const void *a6)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v9 = sub_1B63C8330(v12, 0x428u, 8u);
  return sub_1B645F0E0(v9, *a3, a3[1], a4, v10, a6);
}

void sub_1B645F96C(uint64_t a1, uint64_t a2)
{
}

void sub_1B645F97C(uint64_t a1)
{
}

uint64_t sub_1B645F988(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 16) = 1;
  return objc_msgSend_update(*(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2, a3, a4);
}

void sub_1B645FAD8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 32)) {
    dispatch_resume(*(dispatch_object_t *)(v1 + 48));
  }
}

intptr_t sub_1B645FAF0(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_1B645FDC0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_update(*(void **)(a1 + 32), a2, a3, a4);
}

void sub_1B645FDC8(uint64_t a1)
{
}

void sub_1B645FE64(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 32))
  {
    dispatch_suspend(*(dispatch_object_t *)(v1 + 48));
    *(unsigned char *)(*(void *)(a1 + 32) + 32) = 1;
  }
}

void sub_1B645FF24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 32))
  {
    uint64_t v3 = *(NSObject **)(v1 + 48);
    dispatch_time_t v4 = dispatch_time(0, 100000000);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 32) + 48));
    *(unsigned char *)(*(void *)(a1 + 32) + 32) = 0;
  }
}

__n128 sub_1B645FF8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 *a5)
{
  uint64_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAD38, memory_order_acquire) & 1) == 0)
  {
    uint64_t v11 = a2;
    uint64_t v12 = a3;
    int v10 = __cxa_guard_acquire(&qword_1E9DDAD38);
    uint64_t v7 = &unk_1E9DDA000;
    a2 = v11;
    a3 = v12;
    if (v10)
    {
      byte_1E9DDAD30 = 1;
      __cxa_guard_release(&qword_1E9DDAD38);
      uint64_t v7 = (unsigned char *)&unk_1E9DDA000;
      a2 = v11;
      a3 = v12;
    }
  }
  if (v7[3376]) {
    uint64_t v8 = 0x6E138DDE28F25A91;
  }
  else {
    uint64_t v8 = 0;
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)a5, v8, 0);
  *(void *)a1 = &unk_1F0FB3FA0;
  __n128 result = a5[1];
  *(__n128 *)(a1 + 376) = result;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 392) = 0;
  return result;
}

void sub_1B6460064(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  prof_beginFlame((uint64_t)"DebugCopyStereoPass", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/DebugCopyStereoPass.mm", 22);
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), v4, v5, v6, v7, v8, v9, v10);
  uint64_t v15 = objc_msgSend_resourceManager(v11, v12, v13, v14);
  unint64_t v16 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v17 = CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 408));
  unint64_t v18 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v16 ^ ((0x9DDFEA08EB382D69 * (*(void *)(v17 + 16) ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                 * (*(void *)(v17 + 16) ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v16 ^ ((0x9DDFEA08EB382D69 * (*(void *)(v17 + 16) ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (*(void *)(v17 + 16) ^ v16)))) >> 47));
  unint64_t v19 = 0x9DDFEA08EB382D69 * (v18 ^ *(unsigned __int8 *)(v17 + 9));
  uint64_t v20 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v18 ^ (v19 >> 47) ^ v19)) ^ ((0x9DDFEA08EB382D69 * (v18 ^ (v19 >> 47) ^ v19)) >> 47));
  uint64_t v21 = CFX::CrossFrameResourceManager::get(a2[4], v20);
  *(void *)(a1 + 392) = v21;
  if (!v21)
  {
    uint64_t v22 = sub_1B64601A0(a2[4], v20);
    *(void *)(a1 + 392) = v22;
    uint64_t v25 = objc_msgSend_newComputePipelineStateWithFunctionName_(v15, v23, @"debug_copy_stereo", v24);
    uint64_t v26 = *(void **)(v22 + 16);
    if (v26 != (void *)v25)
    {
      if (v26) {

      }
      *(void *)(v22 + 16) = v25;
    }
  }

  prof_endFlame();
}

void sub_1B6460184(_Unwind_Exception *a1)
{
}

uint64_t sub_1B64601A0(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B6460228(uint64_t a1, uint64_t a2, void **a3)
{
  prof_beginFlame((uint64_t)"DebugCopyStereoPass", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/DebugCopyStereoPass.mm", 46);
  uint64_t v6 = *a3;
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400));
  id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 408));
  objc_msgSend_setTexture_atIndex_(v6, v9, (uint64_t)Texture, 0);
  objc_msgSend_setTexture_atIndex_(v6, v10, (uint64_t)v8, 1);
  uint64_t v17 = *(void *)(a1 + 392);
  uint64_t v18 = *(void *)(v17 + 16);
  if (!v18)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v11, v12, v13, v14, v15, v16, (uint64_t)"_ptr != NULL");
    uint64_t v18 = *(void *)(v17 + 16);
  }
  uint64_t v19 = sub_1B653EFB8(v18);
  objc_msgSend_dispatch_onTexture2D_(v6, v20, v19, (uint64_t)v8);

  prof_endFlame();
}

void sub_1B646030C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1B6460320(uint64_t *a1, unint64_t a2, unint64_t a3, __n128 *a4)
{
  v9[0].n128_u64[0] = a3;
  v9[0].n128_u64[1] = a2;
  v9[1] = *a4;
  uint64_t v5 = (uint64_t *)sub_1B6460384(a1, (uint64_t)a1, v9);
  uint64_t v6 = (CFX::RG::Resource *)a4->n128_u64[0];
  v5[50] = a4->n128_u64[0];
  CFX::RG::Pass::readFrom(v5, v6);
  uint64_t v7 = (CFX::RG::Resource *)a4->n128_u64[1];
  v5[51] = (uint64_t)v7;
  CFX::RG::Pass::writeTo(v5, v7);
  return v5;
}

uint64_t sub_1B6460384(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v5 = a1[1];
  v8[0] = *a1;
  v8[1] = v5;
  sub_1B64604D0(v8[0], v5, v8, a2, a3);
  v8[0] = v6;
  sub_1B63C88CC(a1 + 18, v8);
  return v8[0];
}

void sub_1B64603E0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6460418(void *a1)
{
  *a1 = &unk_1F0FB3F80;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6460464(void *a1)
{
  *a1 = &unk_1F0FB3F80;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

double sub_1B64604D0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, __n128 *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v7 = sub_1B63C8330(v10, 0x1A0u, 8u);
  *(void *)&double result = sub_1B645FF8C(v7, *a3, a3[1], v8, a5).n128_u64[0];
  return result;
}

__n128 sub_1B6460520(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = a2;
  __n128 result = *(__n128 *)a3;
  uint64_t v5 = *(void *)(a3 + 32);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a3 + 16);
  *(__n128 *)(a1 + 8) = result;
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = a4;
  return result;
}

uint64_t sub_1B6460540(uint64_t a1)
{
  return sub_1B6450668(*(void *)(a1 + 56));
}

void sub_1B6460548(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  v116[1] = *MEMORY[0x1E4F143B8];
  unsigned int v8 = sub_1B6447B50(*(void *)a1, a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"computeProgramHashCodes", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/SceneRenderer.mm", 80, v8 | 0x300000000);
  uint64_t v16 = sub_1B644558C(*(void *)a1, v9, v10, v11, v12, v13, v14, v15);
  uint64_t v24 = sub_1B64B2864(v16, v17, v18, v19, v20, v21, v22, v23);
  uint64_t v32 = sub_1B6453580(v24, v25, v26, v27, v28, v29, v30, v31);
  uint64_t v40 = (int32x4_t *)sub_1B64B28B0(v16, v33, v34, v35, v36, v37, v38, v39);
  uint64_t v48 = sub_1B6446190(*(void *)a1, v41, v42, v43, v44, v45, v46, v47);
  unsigned int v56 = sub_1B661BEE0(v32, v49, v50, v51, v52, v53, v54, v55);
  sub_1B63F6930(v48, v56);
  sub_1B646084C(a1);
  if (*(unsigned char *)(a1 + 24)) {
    unsigned int v112 = sub_1B63C1998(v40, *(void *)a1, v57, v58, v59, v60, v61, v62);
  }
  else {
    unsigned int v112 = 0;
  }
  for (unint64_t i = 0; ; ++i)
  {
    long long v64 = (unsigned char *)sub_1B6451064(*(void *)(a1 + 56));
    if (i >= sub_1B661F650(v64, v65, v66, v67, v68, v69, v70, v71)) {
      break;
    }
    uint64_t v72 = *(void *)(a1 + 56);
    if (v112)
    {
      uint64_t v73 = sub_1B6451064(v72);
      sub_1B63C1B8C((uint64_t)v40, v73 + (i << 6) + 8208, *(void *)a1, v74, v75, v76, v77, v78);
      uint64_t v115 = 0;
      memset(v114, 0, sizeof(v114));
      sub_1B63C1DEC((uint64_t)v40, *(uint64_t **)a1, (uint64_t)v114);
      int v113 = 0;
      if (sub_1B63C1DC8((uint64_t)v40, v116, &v113))
      {
        sub_1B63C220C((uint64_t)v40, (uint64_t)v116, v79, v80, v81, v82, v83, v84);
        unsigned __int8 v90 = sub_1B63C2058((uint64_t)v40, (uint64_t)v116, (_OWORD *)((char *)v114 + 4), v85, v86, v87, v88, v89);
        LOWORD(v114[0]) = v114[0] & 0xC03F | (v90 << 6);
      }
      id v91 = *(unsigned int **)(sub_1B6451064(*(void *)(a1 + 56)) + 16 * i + 12816);
      uint64_t v98 = *(unsigned int *)(sub_1B6451064(*(void *)(a1 + 56)) + 16 * i + 12824);
      if (v98)
      {
        do
        {
          unsigned int v99 = *v91++;
          unint64_t v4 = v4 & 0xFFFFFFFF00000000 | v99;
          uint64_t v100 = sub_1B661BF3C(v32, v4, v92, v93, v94, v95, v96, v97);
          __int16 v101 = *(_WORD *)(v100 + 80);
          if ((v101 & 0x40) != 0) {
            *(_WORD *)(v100 + 80) = (16 * LOWORD(v114[0])) & 0x380 | v101 & 0xFC7F;
          }
          sub_1B6460930(a1, (uint64_t)a2, v100, v48, (unsigned __int16 *)v114);
          --v98;
        }
        while (v98);
      }
      sub_1B63C22BC((uint64_t)v40);
    }
    else
    {
      uint64_t v102 = *(unsigned int **)(sub_1B6451064(v72) + 16 * i + 12816);
      uint64_t v109 = *(unsigned int *)(sub_1B6451064(*(void *)(a1 + 56)) + 16 * i + 12824);
      if (v109)
      {
        do
        {
          unsigned int v110 = *v102++;
          unint64_t v5 = v5 & 0xFFFFFFFF00000000 | v110;
          uint64_t v111 = sub_1B661BF3C(v32, v5, v103, v104, v105, v106, v107, v108);
          sub_1B6460930(a1, (uint64_t)a2, v111, v48, 0);
          --v109;
        }
        while (v109);
      }
    }
  }
  prof_endFlame();
}

void sub_1B64607FC(_Unwind_Exception *a1)
{
}

uint64_t sub_1B646084C(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int16 *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 56);
  if (*(unsigned char *)(v3 + 112))
  {
    unint64_t v4 = (unint64_t)*(unsigned __int8 *)(sub_1B6451064(v3) + 12560) << 16;
    uint64_t v3 = *(void *)(a1 + 56);
  }
  else
  {
    unint64_t v4 = 0x10000;
  }
  uint64_t result = sub_1B6451064(v3);
  unint64_t v6 = 0xC6A4A7935BD1E995
     * (((v4 | v2) & 0xFFFFFFFF87FFFFFFLL | ((((unint64_t)((8 * (*(unsigned char *)(result + 12563) & 3)) & 0x9F | (32 * (*(unsigned char *)(a1 + 18) & 3u))) >> 3) & 0xF) << 27)) ^ 0x1A929E4D6F47A654);
  unint64_t v7 = 0xC6A4A7935BD1E995 * (v6 ^ (v6 >> 47));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (*(void *)(a1 + 40) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v7 ^ ((v8 ^ v7) >> 47) ^ v8);
  *(void *)(a1 + 48) = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
  return result;
}

void sub_1B6460930(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5)
{
  unsigned int v10 = sub_1B6447B50(*(void *)a1, (const char *)a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"computeProgramHashCodeForRendererElement", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/SceneRenderer.mm", 175, v10 | 0x300000000);
  if (!sub_1B63F1400(a3) && (*(void *)(a3 + 16) || *(void *)(a3 + 24)))
  {
    uint64_t v41 = *(void **)(a3 + 8);
    uint64_t v11 = sub_1B63F6BFC(a4, (char *)a3, 0, *(void *)(a1 + 48));
    if (!v11 || !sub_1B659DC10((uint64_t)v41, v11, a5, v12, v13, v14, v15, v16))
    {
      uint64_t v40 = sub_1B63F1730(a3);
      uint64_t v39 = sub_1B63F1750(a3);
      uint64_t v38 = (__n128 *)sub_1B63F16EC(a3);
      uint64_t v23 = sub_1B63F1710(a3);
      uint64_t v24 = *(void *)(a3 + 8);
      if (v24)
      {
        if ((*(unsigned char *)(v24 + 221) & 0x10) != 0)
        {
          uint64_t v25 = *(void *)(a3 + 40);
          if (v25) {
            sub_1B65160A8(v25, v24, v17, v18, v19, v20, v21, v22);
          }
        }
      }
      uint64_t v37 = *(unsigned __int16 *)(a1 + 16);
      uint64_t v26 = *(void *)(a1 + 56);
      if (*(unsigned char *)(v26 + 112))
      {
        unint64_t v27 = (unint64_t)*(unsigned __int8 *)(sub_1B6451064(v26) + 12560) << 16;
        uint64_t v26 = *(void *)(a1 + 56);
      }
      else
      {
        unint64_t v27 = 0x10000;
      }
      unsigned int v28 = *(unsigned __int16 *)(a3 + 80);
      char v30 = *(unsigned char *)(sub_1B6451064(v26) + 12563);
      char v31 = *(unsigned char *)(a1 + 18);
      if (*(void *)(a1 + 8))
      {
        a5 = 0;
        uint64_t v23 = *(void *)(a1 + 8);
      }
      else if (sub_1B6460B50(a1, a3))
      {
        uint64_t v23 = sub_1B63BEF38(*(CFX::CrossFrameResourceManager **)(a2 + 32));
        a5 = 0;
      }
      uint64_t v32 = (const void *)sub_1B659DD34(v41, v38, v40, (uint64_t)v39, a5, v23, v27 | v37 | ((unint64_t)((v28 >> 11) & 7 | (8 * (v30 & 3)) & 0x9F | (32 * (v31 & 3))) << 24), v29);
      sub_1B63F6DC8(a4, (unsigned int *)a3, v32, *(void *)(a1 + 48), v33, v34, v35, v36);
      if (v32) {
        CFRelease(v32);
      }
    }
  }

  prof_endFlame();
}

void sub_1B6460B24(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6460B50(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1B63F1710(a2);
  if ((*(unsigned char *)(a1 + 24) & 8) == 0) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t result = sub_1B63F16E0(a2);
  if (!result) {
    return result;
  }
  if (*(unsigned char *)(*(void *)(a1 + 56) + 112) || sub_1B64AF648(v5, v7, v8, v9, v10, v11, v12, v13) >= 0.0) {
    return 0;
  }
  uint64_t v14 = sub_1B63F16EC(a2);
  uint64_t v21 = v14;
  if (!v5)
  {
    if (!v14) {
      return 1;
    }
    unsigned int v30 = sub_1B6584A30(v14, 0, v15, v16, v17, v18, v19, v20);
    return v30 ^ 1;
  }
  unsigned __int8 v29 = sub_1B6584A30(v5, 0, v15, v16, v17, v18, v19, v20);
  uint64_t result = 0;
  if (v29) {
    return result;
  }
  if (v21)
  {
    unsigned int v30 = sub_1B6584A30(v21, 0, v23, v24, v25, v26, v27, v28);
    if (v30) {
      return v30 ^ 1;
    }
  }
  uint64_t v31 = sub_1B64AF43C(v5, v22, v23, v24, v25, v26, v27, v28);
  uint64_t v37 = sub_1B6475290(v31, 16, 0, v32, v33, v34, v35, v36);
  return !v37 || !sub_1B6475F88(v37, v38, v39, v40, v41, v42, v43, v44);
}

void sub_1B6460C38(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 v4 = a4;
  unsigned int v7 = sub_1B6447B50(*(void *)a1, a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"render", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/SceneRenderer.mm", 259, v7 | 0x300000000);
  uint64_t v8 = *(unsigned __int8 *)(a3 + 17);
  uint64_t v9 = *(void *)(a1 + 56);
  if (*(unsigned char *)(v9 + 112))
  {
    unsigned int v10 = *(unsigned __int8 *)(sub_1B6451064(v9) + 12560);
    uint64_t v9 = *(void *)(a1 + 56);
  }
  else
  {
    unsigned int v10 = 1;
  }
  uint64_t v11 = *(unsigned __int8 *)(sub_1B6451064(v9) + 12563);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 18);
  uint64_t v13 = *(unsigned __int8 *)(a1 + 33);
  uint64_t v21 = sub_1B644558C(*(void *)a1, v14, v15, v16, v17, v18, v19, v20);
  unsigned __int8 v29 = (const void *)sub_1B64B1FBC(v21, v22, v23, v24, v25, v26, v27, v28);
  CFRetain(v29);
  CFTypeRef cf = v29;
  uint64_t v37 = (void *)sub_1B6445900(*(void *)a1, v30, v31, v32, v33, v34, v35, v36);
  objc_msgSend_setRenderPassParameters_(v37, v38, (v11 << 16) | (v12 << 24) | (v13 << 32) | ((unint64_t)v10 << 8) | v8, v39);
  objc_msgSend_setCurrentPassHash_(v37, v40, *(void *)(a1 + 48), v41);
  objc_msgSend_setCurrentPassMaterial_(v37, v42, *(void *)(a1 + 8), v43);
  uint64_t v51 = *(void *)(a1 + 56);
  if ((*(unsigned char *)(v51 + 120) & 4) == 0)
  {
    if (*(unsigned char *)(v51 + 113) == 2)
    {
      if (*(unsigned char *)(v51 + 80))
      {
        float32x4_t v52 = *(float32x4_t *)(v51 + 64);
        uint64_t v53 = *(void **)a3;
        v85[0] = vcvtq_f64_f32(*(float32x2_t *)v52.f32);
        v85[1] = vcvt_hight_f64_f32(v52);
        v85[2] = xmmword_1B6E500C0;
        objc_msgSend_setViewport_(v53, v44, (uint64_t)v85, v46);
      }
    }
    else
    {
      unint64_t v76 = 0;
      for (uint64_t i = 11288; ; i += 16)
      {
        unint64_t v78 = *(unsigned char *)(v51 + 112) ? *(unsigned __int8 *)(sub_1B6451064(v51) + 12560) : 1;
        if (v76 >= v78) {
          break;
        }
        uint64_t v79 = (float32x2_t *)(sub_1B6451064(*(void *)(a1 + 56)) + i);
        uint64_t v80 = *(void **)a3;
        float64x2_t v81 = vcvtq_f64_f32(*v79);
        v86[0] = vcvtq_f64_f32(v79[-1]);
        v86[1] = v81;
        v86[2] = xmmword_1B6E500C0;
        objc_msgSend_setViewport_(v80, v82, (uint64_t)v86, v83);
        ++v76;
        uint64_t v51 = *(void *)(a1 + 56);
      }
    }
  }
  if (!sub_1B64B2864(v21, (uint64_t)v44, v45, v46, v47, v48, v49, v50)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v54, v55, v56, v57, v58, v59, (uint64_t)"enginePipeline");
  }
  uint64_t v60 = *(void *)a1;
  uint64_t v61 = sub_1B6451064(*(void *)(a1 + 56));
  sub_1B6447998(v60, 0, v61 + ((unint64_t)HIBYTE(v4) << 6) + 9232);
  uint64_t v62 = *(void *)a1;
  uint64_t v63 = sub_1B6451064(*(void *)(a1 + 56));
  sub_1B6447998(v62, 1, v63 + ((unint64_t)HIBYTE(v4) << 6) + 8208);
  sub_1B6460F1C(a1, v4);
  uint64_t v67 = sub_1B644805C(*(void *)a1);
  if (v67)
  {
    int canRecycleParticleBuffers = *(unsigned char *)(a1 + 33) != 0;
    if (*(unsigned char *)(*(void *)(a1 + 56) + 113) != 2) {
      int canRecycleParticleBuffers = objc_msgSend_canRecycleParticleBuffers(v37, v64, v65, v66);
    }
    if (canRecycleParticleBuffers)
    {
      uint64_t v69 = (char *)objc_msgSend_currentCommandBuffer(v37, v64, v65, v66);
      sub_1B6511F94(v67, v69, v70, v71, v72, v73, v74, v75);
    }
  }
  CFRelease(cf);
  prof_endFlame();
}

void sub_1B6460EE4(_Unwind_Exception *a1)
{
}

void sub_1B6460F1C(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  __int16 v3 = v2;
  uint64_t v5 = v4;
  uint64_t v12 = sub_1B644558C(*v4, v2, v6, v7, v8, v9, v10, v11);
  uint64_t v20 = sub_1B64B2864(v12, v13, v14, v15, v16, v17, v18, v19);
  uint64_t v28 = (void *)sub_1B6445900(*v5, v21, v22, v23, v24, v25, v26, v27);
  bzero(v80, 0x33F0uLL);
  uint64_t v29 = v5[7];
  char v30 = *(unsigned char *)(v29 + 112);
  if (v30)
  {
    char v31 = *(unsigned char *)(sub_1B6451064(v29) + 12560);
    uint64_t v29 = v5[7];
    char v30 = *(unsigned char *)(v29 + 112);
  }
  else
  {
    char v31 = 1;
  }
  v80[24] = v31;
  v80[25] = HIBYTE(v3);
  v80[26] = (*(unsigned char *)(v29 + 120) & 4) != 0;
  v80[27] = v30;
  v80[28] = *((unsigned char *)v5 + 18);
  __int16 v82 = *((_WORD *)v5 + 8);
  uint64_t v32 = (const void *)sub_1B6451064(v29);
  memcpy(v81, v32, sizeof(v81));
  if ((v5[3] & 2) != 0)
  {
    uint64_t v40 = sub_1B64B27BC(v12, 0);
    if (v40) {
      sub_1B64457FC(*v5, v40, (uint64_t)v80, v35, v36, v37, v38, v39);
    }
  }
  uint64_t v41 = sub_1B6445480(*v5, v33, v34, v35, v36, v37, v38, v39);
  uint64_t v42 = 16 * v3;
  size_t v43 = *(unsigned int *)(sub_1B6451064(v5[7]) + v42 + 12824);
  uint64_t v50 = *(void **)(sub_1B6451064(v5[7]) + v42 + 12816);
  if (!v50) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v44, v45, v46, v47, v48, v49, (uint64_t)"visibleElements");
  }
  double v51 = CACurrentMediaTime();
  prof_beginFlame((uint64_t)"sync and sort", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/SceneRenderer.mm", 366);
  uint64_t v59 = (void *)sub_1B64461DC(*v5, v52, v53, v54, v55, v56, v57, v58);
  sub_1B65128B4((uint64_t)v59, (uint64_t *)*v5, (uint64_t)v50, v43, v5[6], v60, v61, v62);
  sub_1B65126F4(v59, *v5, v50, v43);
  *(double *)(v41 + 152) = *(double *)(v41 + 152) + CACurrentMediaTime() - v51;
  prof_endFlame();
  if (sub_1B6447730(*v5))
  {
    uint64_t v70 = sub_1B6445480(*v5, v63, v64, v65, v66, v67, v68, v69);
    unsigned int v71 = sub_1B6447730(*v5) + ~*(_DWORD *)(v70 + 12);
    if (v43 >= v71) {
      size_t v43 = v71;
    }
    else {
      size_t v43 = v43;
    }
  }
  double v72 = CACurrentMediaTime();
  prof_beginFlame((uint64_t)"process rendererElements", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/SceneRenderer.mm", 386);
  uint64_t v73 = *v5;
  v76[0] = v20;
  v76[1] = v73;
  char v77 = v5[3] & 1;
  uint64_t v74 = v5[6];
  BOOL v78 = (*(unsigned char *)(v5[7] + 120) & 2) != 0;
  v76[2] = v80;
  v76[3] = 0;
  char v79 = *((unsigned char *)v5 + 33);
  _OWORD v76[4] = v74;
  v76[5] = 0;
  objc_msgSend_processRendererElements_count_engineIterationContext_(v28, v75, (uint64_t)v50, v43, v76);
  *(double *)(v41 + 152) = *(double *)(v41 + 152) + CACurrentMediaTime() - v72;
  prof_endFlame();
}

uint64_t sub_1B64611C0(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

void *sub_1B64611F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"objcConstraint");
  }
  if (qword_1E9DDAD48 != -1) {
    dispatch_once_f(&qword_1E9DDAD48, &qword_1E9DDAD40, (dispatch_function_t)sub_1B64611C0);
  }
  uint64_t result = (void *)sub_1B63C8D44(qword_1E9DDAD40, 0x18uLL);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  return result;
}

uint64_t sub_1B6461298(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"delegate");
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 24);
  if (!v11) {
    return 1;
  }
  uint64_t v12 = *(void *)(a1 + 16);

  return v11(v12, a2, a3);
}

void sub_1B646132C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"delegate");
  }
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(a1 + 16);
    v11(v12, a2, a3);
  }
}

CFStringRef sub_1B64613C4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAvoidOccluderConstraintDelegate %p>", a1);
}

CFStringRef sub_1B6461404(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXAvoidOccluderConstraintDelegate %p>", a1);
}

uint64_t sub_1B6461444(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B6461474()
{
  if (qword_1E9DDAD50 != -1) {
    dispatch_once_f(&qword_1E9DDAD50, &qword_1EB995F30, (dispatch_function_t)sub_1B6461444);
  }
  return qword_1EB995F30;
}

double sub_1B64614C8(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1);
  float32x4_t v5 = vsubq_f32(a3, a1);
  float32x4_t v6 = vsubq_f32(a4, a1);
  float32x4_t v7 = vmulq_f32(v4, v6);
  float32x4_t v8 = vmulq_f32(v5, v6);
  float32x4_t v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1)));
  float32x4_t v10 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1)));
  if (v9.f32[0] <= 0.0)
  {
    unint64_t v11 = a1.i64[0];
    if (v10.f32[0] <= 0.0) {
      return *(double *)&v11;
    }
  }
  float32x4_t v12 = vsubq_f32(a4, a2);
  float32x4_t v13 = vmulq_f32(v4, v12);
  float32x4_t v14 = vmulq_f32(v5, v12);
  float32x4_t v15 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1)));
  float32x4_t v16 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1)));
  if (v15.f32[0] >= 0.0)
  {
    unint64_t v11 = a2.i64[0];
    if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v15, v16))).u8[0] & 1) == 0) {
      return *(double *)&v11;
    }
  }
  float v18 = (float)(v9.f32[0] * v16.f32[0]) - (float)(v15.f32[0] * v10.f32[0]);
  if (v15.f32[0] <= 0.0 && v9.f32[0] >= 0.0 && v18 <= 0.0)
  {
    *(void *)&double result = vmlaq_n_f32(a1, v4, vdivq_f32(v9, vsubq_f32(v9, v15)).f32[0]).u64[0];
    return result;
  }
  float32x4_t v19 = vsubq_f32(a4, a3);
  float32x4_t v20 = vmulq_f32(v4, v19);
  float32x4_t v21 = vmulq_f32(v5, v19);
  float32x4_t v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1)));
  float32x4_t v23 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1)));
  if (v23.f32[0] >= 0.0)
  {
    unint64_t v11 = a3.i64[0];
    if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v23, v22))).u8[0] & 1) == 0) {
      return *(double *)&v11;
    }
  }
  float v24 = (float)(v22.f32[0] * v10.f32[0]) - (float)(v9.f32[0] * v23.f32[0]);
  if (v23.f32[0] <= 0.0 && v24 <= 0.0 && v10.f32[0] >= 0.0)
  {
    LODWORD(v25) = vdivq_f32(v10, vsubq_f32(v10, v23)).u32[0];
LABEL_20:
    *(void *)&double result = vmlaq_n_f32(a1, v5, v25).u64[0];
    return result;
  }
  float v26 = (float)(v15.f32[0] * v23.f32[0]) - (float)(v22.f32[0] * v16.f32[0]);
  if (v26 > 0.0 || (float32x4_t v27 = vsubq_f32(v16, v15), v27.f32[0] < 0.0) || (v28 = vsubq_f32(v22, v23), v28.f32[0] < 0.0))
  {
    float v29 = 1.0 / (float)(v18 + (float)(v26 + v24));
    float v30 = v24 * v29;
    float v25 = v18 * v29;
    a1 = vmlaq_n_f32(a1, v4, v30);
    goto LABEL_20;
  }
  *(void *)&double result = vmlaq_n_f32(a2, vsubq_f32(a3, a2), vdivq_f32(v27, vaddq_f32(v27, v28)).f32[0]).u64[0];
  return result;
}

void sub_1B6461670(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, float a5, double a6)
{
  float32x4_t v8 = *a1;
  float32x4_t v7 = a1[1];
  float32x4_t v9 = vsubq_f32(v7, *a1);
  float32x4_t v10 = a1[2];
  float32x4_t v11 = vsubq_f32(v10, *a1);
  float32x4_t v12 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), vnegq_f32(v9)), v11, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL));
  int32x4_t v13 = (int32x4_t)vmulq_f32(v12, v12);
  v13.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), *(float32x2_t *)v13.i8)).u32[0];
  *(float32x2_t *)v11.f32 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  *(float32x2_t *)v11.f32 = vmul_f32(*(float32x2_t *)v11.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)v11.f32)));
  float32x4_t v14 = vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL), vmul_f32(*(float32x2_t *)v11.f32, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)v11.f32))).f32[0]);
  float32x4_t v15 = vmulq_f32(*a1, v14);
  float32x4_t v16 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1)));
  float32x4_t v17 = *a2;
  float32x4_t v18 = vmulq_f32(*a2, v14);
  float32x4_t v19 = vmulq_f32(v14, vnegq_f32(v14));
  float32x2_t v20 = (float32x2_t)vdivq_f32(vsubq_f32(v16, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1)))), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1)))).u64[0];
  if (v20.f32[0] >= 0.0)
  {
    if (v20.f32[0] <= *(float *)&a6)
    {
      float v39 = *(float *)&a6;
      float32x4_t v29 = vmlsq_lane_f32(v17, v14, v20, 0);
    }
    else
    {
      float32x4_t v25 = vmlsq_lane_f32(v17, v14, *(float32x2_t *)&a6, 0);
      float32x4_t v26 = vmulq_f32(v14, v25);
      float32x4_t v27 = vmulq_f32(v14, *a3);
      float v28 = (float)(v16.f32[0]
                  - vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0])/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0];
      if (v28 < 0.0) {
        return;
      }
      float v39 = *(float *)&a6;
      float32x4_t v29 = vmlaq_n_f32(v25, *a3, v28);
    }
    float32x4_t v38 = v29;
    float32x4_t v42 = v29;
    v40[2] = v10;
    float32x4_t v41 = v29;
    v40[0] = v8;
    v40[1] = v7;
    BOOL v30 = sub_1B6454B48(v40, &v42);
    float32x4_t v31 = v38;
    if (!v30)
    {
      *(double *)v31.i64 = sub_1B64614C8(*a1, a1[1], a1[2], v42);
      float32x4_t v41 = v31;
    }
    float32x4_t v32 = vsubq_f32(*a2, v31);
    float32x4_t v33 = vmulq_f32(v32, v32);
    v33.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0]);
    float32x4_t v34 = vmulq_f32(v32, vnegq_f32(*a3));
    v34.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0];
    float v35 = -(float)((float)((float)((float)-v34.f32[0] * v34.f32[0]) + (float)(v33.f32[0] * v33.f32[0]))
                 - (float)(v39 * v39));
    float v36 = v34.f32[0] - sqrtf(v35);
    if (v35 < 0.0) {
      float v36 = -1.0;
    }
    if (v36 >= 0.0 && v36 <= a5) {
      (*(void (**)(uint64_t, float32x4_t *, float32x4_t *))(a4 + 16))(a4, a1, &v41);
    }
  }
}

float32x4_t sub_1B6461894(float32x4_t *a1, double a2, float32x4_t a3, float32x4_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v8 = LODWORD(a2);
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  *(float *)&a2 = *(float *)&a2 + 0.001;
  int32x4_t v11 = vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  v11.i32[3] = 0;
  float32x4_t v39 = (float32x4_t)v11;
  while (1)
  {
    float32x4_t v12 = vmulq_f32(a4, a4);
    LODWORD(v13) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u32[0];
    float v14 = sqrtf(v13);
    if (v14 < 0.001) {
      break;
    }
    uint64_t v62 = 0;
    uint64_t v63 = &v62;
    uint64_t v64 = 0x2000000000;
    char v65 = 0;
    uint64_t v58 = 0;
    uint64_t v59 = (float *)&v58;
    uint64_t v60 = 0x2000000000;
    int v61 = 2139095039;
    uint64_t v66 = 0;
    uint64_t v67 = (float32x4_t *)&v66;
    float32x4_t v15 = a3;
    v15.i32[3] = 1.0;
    uint64_t v68 = 0x3000000000;
    float v16 = v13;
    float32x2_t v17 = vrsqrte_f32((float32x2_t)LODWORD(v13));
    float32x2_t v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)LODWORD(v16), vmul_f32(v17, v17)));
    float32x4_t v19 = vmulq_n_f32(a4, vmul_f32(v18, vrsqrts_f32((float32x2_t)LODWORD(v16), vmul_f32(v18, v18))).f32[0]);
    float32x4_t v20 = vaddq_f32(a4, a3);
    float32x4_t v40 = v20;
    v20.i32[3] = 1.0;
    float32x4_t v21 = vminnmq_f32(vsubq_f32(v15, v39), vsubq_f32(v20, v39));
    float32x4_t v22 = vmaxnmq_f32(vaddq_f32(v39, v15), vaddq_f32(v39, v20));
    v15.i64[0] = 0x3F0000003F000000;
    v15.i64[1] = 0x3F0000003F000000;
    float32x4_t v23 = vmulq_f32(vaddq_f32(v21, v22), v15);
    float32x4_t v24 = vmulq_f32(vsubq_f32(v22, v21), v15);
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    a1[13] = v23;
    a1[14] = v24;
    a1[11].i64[0] = a1[10].i64[1];
    uint64_t v57 = 0;
    memset(v56, 0, sizeof(v56));
    v44[0] = MEMORY[0x1E4F143A8];
    v44[1] = 0x40000000;
    v44[2] = sub_1B6461BEC;
    void v44[3] = &unk_1E61423D8;
    float32x4_t v45 = v23;
    float32x4_t v46 = v24;
    uint64_t v52 = a7;
    uint64_t v53 = a1;
    float32x4_t v47 = a3;
    float32x4_t v48 = v19;
    float32x4_t v41 = v19;
    float v54 = v14;
    int v55 = v8;
    uint64_t v49 = &v62;
    uint64_t v50 = &v58;
    double v51 = &v66;
    float32x4_t v42 = a4;
    float32x4_t v43 = a3;
    sub_1B65C4C3C((uint64_t)v44, (uint64_t)v56);
    *(void *)&v56[0] = a1[10].i64[0];
    sub_1B65C5D14(a6, (uint64_t)v56);
    int v25 = *((unsigned __int8 *)v63 + 24);
    if (*((unsigned char *)v63 + 24))
    {
      float32x4_t v26 = v67[2];
      float v27 = v59[6];
      float32x4_t v28 = vsubq_f32(vmlaq_n_f32(v43, v41, v27), v26);
      int32x4_t v29 = (int32x4_t)vmulq_f32(v28, v28);
      v29.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v29, 2), vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.i8, 1))).u32[0];
      float32x2_t v30 = vrsqrte_f32((float32x2_t)v29.u32[0]);
      float32x2_t v31 = vmul_f32(v30, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(v30, v30)));
      float32x4_t v32 = vmulq_n_f32(v28, vmul_f32(v31, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(v31, v31))).f32[0]);
      float32x4_t v33 = vmulq_f32(v26, v32);
      float32x4_t v34 = vmlaq_n_f32(v43, v41, v14 + -0.001);
      float32x4_t v35 = vmulq_f32(v34, v32);
      float32x4_t v36 = vmulq_f32(v32, v32);
      float32x4_t v42 = vsubq_f32(vmlaq_n_f32(v34, v32, (float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0]- vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).f32[0])/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]), v26);
      float32x4_t v43 = vmlaq_n_f32(v43, v41, v27 + -0.001);
    }
    else
    {
      float32x4_t v38 = v40;
    }
    _Block_object_dispose(&v66, 8);
    _Block_object_dispose(&v58, 8);
    _Block_object_dispose(&v62, 8);
    a4 = v42;
    a3 = v43;
    if (!v25) {
      return v38;
    }
  }
  return a3;
}

void sub_1B6461BEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 1)
  {
    uint64_t v10 = 0;
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3727C5ACu);
    do
    {
      uint64_t v12 = *(void *)(a2 + 8 * v10);
      uint64_t v13 = *(void *)(a1 + 120);
      if (v12 != v13 && !sub_1B64A33A4(*(void *)(a2 + 8 * v10), v13, a3, a4, a5, a6, a7, a8))
      {
        uint64_t v15 = sub_1B649F5F4(v12, v14, a3, a4, a5, a6, a7, a8);
        CFTypeRef v23 = sub_1B63CE23C(v15, v16, v17, v18, v19, v20, v21, v22);
        uint64_t v31 = sub_1B64A01D4(v12, v24, v25, v26, v27, v28, v29, v30);
        v42.columns[0] = *(simd_float4 *)v31;
        float32x4_t v39 = vmulq_f32((float32x4_t)v42.columns[0], (float32x4_t)v42.columns[0]);
        v42.columns[2] = *(simd_float4 *)(v31 + 32);
        v39.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]);
        v42.columns[1] = (simd_float4)vmulq_f32(*(float32x4_t *)(v31 + 16), *(float32x4_t *)(v31 + 16));
        float32x4_t v40 = vmulq_f32((float32x4_t)v42.columns[2], (float32x4_t)v42.columns[2]);
        int32x2_t v41 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).u64[0];
        *(float *)v41.i32 = sqrtf(*(float *)v41.i32);
        v39.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42.columns[1], 2), vaddq_f32((float32x4_t)v42.columns[1], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.columns[1].f32, 1))).f32[0]);
        *(int32x2_t *)v42.columns[1].f32 = vcgt_f32(v11, vabd_f32(*(float32x2_t *)v39.f32, (float32x2_t)vdup_lane_s32(v41, 0)));
        long long v94 = *(_OWORD *)(v31 + 16);
        simd_float4 v95 = *(simd_float4 *)v31;
        simd_float4 v92 = v42.columns[2];
        long long v93 = *(_OWORD *)(v31 + 48);
        if ((vpmin_u32(*(uint32x2_t *)v42.columns[1].f32, *(uint32x2_t *)v42.columns[1].f32).u32[0] & 0x80000000) != 0)
        {
          v42.columns[1] = *(simd_float4 *)(v31 + 16);
          v42.columns[3] = *(simd_float4 *)(v31 + 48);
          simd_float4x4 v128 = __invert_f4(v42);
          int32x4_t v81 = *(int32x4_t *)(a1 + 48);
          v128.columns[3] = (simd_float4)vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v128.columns[3], (float32x4_t)v128.columns[2], *(float32x4_t *)(a1 + 32), 2), (float32x4_t)v128.columns[1], *(float32x2_t *)(a1 + 32), 1), (float32x4_t)v128.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 32)));
          v128.columns[3].i32[3] = HIDWORD(*(_OWORD *)(a1 + 32));
          float32x4_t v82 = (float32x4_t)v81;
          v82.i32[1] = v81.i32[0];
          v82.i32[2] = v81.i32[0];
          v117[0] = MEMORY[0x1E4F143A8];
          v117[1] = 0x40000000;
          v117[2] = sub_1B6461F9C;
          v117[3] = &unk_1E6142360;
          simd_float4 v118 = v95;
          long long v119 = v94;
          v128.columns[1] = (simd_float4)vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v81.i8, 1), v81), vabsq_f32((float32x4_t)v128.columns[1])), v82, vabsq_f32((float32x4_t)v128.columns[0])), (float32x4_t)vzip2q_s32(vtrn1q_s32(v81, v81), v81), vabsq_f32((float32x4_t)v128.columns[2]));
          simd_float4 v120 = v92;
          long long v121 = v93;
          uint64_t v83 = *(void *)(a1 + 128);
          v128.columns[2] = *(simd_float4 *)(a1 + 80);
          long long v122 = *(_OWORD *)(a1 + 64);
          simd_float4 v123 = v128.columns[2];
          uint64_t v127 = *(void *)(a1 + 136);
          long long v124 = *(_OWORD *)(a1 + 96);
          uint64_t v84 = *(void *)(a1 + 112);
          uint64_t v126 = v83;
          uint64_t v125 = v84;
          sub_1B64ADD0C((uint64_t)v23, (uint64_t)v117, (float32x4_t)v128.columns[3], (float32x4_t)v128.columns[1], v85, v86, v87, v88, v89, v90);
        }
        else
        {
          CFArrayRef v43 = sub_1B64ABD08((uint64_t)v23, v32, v33, v34, v35, v36, v37, v38);
          if (v43)
          {
            uint64_t v44 = (uint64_t)v43;
            float32x4_t v45 = sub_1B64ACF7C((uint64_t)v23, 0, a3, a4, a5, a6, a7, a8);
            if (sub_1B641D8A0((uint64_t)v45, v46, v47, v48, v49, v50, v51, v52))
            {
              uint64_t v60 = sub_1B641D478((uint64_t)v45, v53, a3, a4, a5, a6, a7, a8);
              uint64_t v62 = v61;
              if ((v61 & 0xFF00000000) != 0x800000000) {
                sub_1B63F2F54(17, @"Assertion '%s' failed.  - Only vector3 type is supported.", v54, v55, v56, v57, v58, v59, (uint64_t)"vertices.type == kCFXBaseTypeVector3");
              }
              uint64_t v63 = sub_1B64ACE9C((uint64_t)v23, 0, 0, v55, v56, v57, v58, v59);
              if (v44 >= 1)
              {
                uint64_t v64 = v63;
                for (CFIndex i = 0; i != v44; ++i)
                {
                  uint64_t v66 = sub_1B64ABD78((uint64_t)v23, i, 0, a4, a5, a6, a7, a8);
                  uint64_t v116 = 0;
                  long long v114 = 0u;
                  long long v115 = 0u;
                  long long v113 = 0u;
                  sub_1B63D11F0((uint64_t)v66, v64, v67, v68, v69, v70, v71, v72, (uint64_t)&v113);
                  if ((BYTE10(v114) & 0xFA) != 0)
                  {
                    sub_1B63F2F54(0, @"Warning: Slider can only process triangles.", v73, v74, v75, v76, v77, v78, v91);
                  }
                  else
                  {
                    v111[0] = v113;
                    v111[1] = v114;
                    v111[2] = v115;
                    uint64_t v112 = v116;
                    v97[0] = MEMORY[0x1E4F143A8];
                    v97[1] = 0x40000000;
                    v97[2] = sub_1B6462560;
                    v97[3] = &unk_1E61423B0;
                    int v109 = v62 - 1;
                    simd_float4 v98 = v95;
                    long long v99 = v94;
                    simd_float4 v100 = v92;
                    long long v101 = v93;
                    uint64_t v79 = *(void *)(a1 + 128);
                    uint64_t v107 = v62;
                    uint64_t v108 = v79;
                    long long v80 = *(_OWORD *)(a1 + 80);
                    long long v102 = *(_OWORD *)(a1 + 64);
                    long long v103 = v80;
                    uint64_t v110 = *(void *)(a1 + 136);
                    long long v104 = *(_OWORD *)(a1 + 96);
                    uint64_t v105 = *(void *)(a1 + 112);
                    uint64_t v106 = v60;
                    sub_1B63D1BEC((uint64_t *)v111, (uint64_t)v97, v73, v74, v75, v76, v77, v78);
                  }
                }
              }
            }
          }
        }
      }
      ++v10;
    }
    while (v10 != a3);
  }
}

uint64_t sub_1B6461F9C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = 0;
    float32x4_t v6 = (float32x4_t *)(a1 + 96);
    float32x4_t v7 = (float32x4_t *)(a1 + 112);
    uint64_t v8 = a3;
    do
    {
      float32x4_t v9 = *(float32x4_t *)(a2 + 16 * (3 * v5));
      float32x4_t v10 = *(float32x4_t *)(a2 + 16 * (3 * v5 + 1));
      float32x4_t v11 = *(float32x4_t *)(a2 + 16 * (3 * v5 + 2));
      float32x4_t v12 = *(float32x4_t *)(a1 + 32);
      float32x4_t v13 = *(float32x4_t *)(a1 + 48);
      float32x4_t v14 = *(float32x4_t *)(a1 + 64);
      float32x4_t v15 = *(float32x4_t *)(a1 + 80);
      float32x4_t v42 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v15, v14, v9, 2), v13, *(float32x2_t *)v9.f32, 1), v12, v9.f32[0]);
      float32x4_t v43 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v15, v14, v10, 2), v13, *(float32x2_t *)v10.f32, 1), v12, v10.f32[0]);
      float32x4_t v44 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v15, v14, v11, 2), v13, *(float32x2_t *)v11.f32, 1), v12, v11.f32[0]);
      uint64_t v16 = *(void **)(a1 + 152);
      if (v16[16])
      {
        uint64_t v17 = (float32x4_t *)v16[31];
        unint64_t v18 = v16[32];
        if ((unint64_t)v17 >= v18)
        {
          uint64_t v22 = v16[30];
          unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v17 - v22) >> 4);
          unint64_t v24 = v23 + 1;
          if (v23 + 1 > 0x555555555555555) {
            abort();
          }
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - v22) >> 4);
          if (2 * v25 > v24) {
            unint64_t v24 = 2 * v25;
          }
          if (v25 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v26 = 0x555555555555555;
          }
          else {
            unint64_t v26 = v24;
          }
          if (v26) {
            uint64_t v27 = (char *)sub_1B6463DE8((uint64_t)(v16 + 32), v26);
          }
          else {
            uint64_t v27 = 0;
          }
          uint64_t v28 = (float32x4_t *)&v27[48 * v23];
          float32x4_t v29 = v42;
          v10.i32[1] = v43.i32[1];
          float32x4_t v30 = v44;
          v28[1] = v43;
          v28[2] = v30;
          *uint64_t v28 = v29;
          uint64_t v32 = (float32x4_t *)v16[30];
          uint64_t v31 = (float32x4_t *)v16[31];
          uint64_t v33 = v28;
          if (v31 != v32)
          {
            do
            {
              float32x4_t v34 = v31[-3];
              float32x4_t v10 = v31[-2];
              float32x4_t v35 = v31[-1];
              v33[-2] = v10;
              v33[-1] = v35;
              v33[-3] = v34;
              v33 -= 3;
              v31 -= 3;
            }
            while (v31 != v32);
            uint64_t v31 = (float32x4_t *)v16[30];
          }
          f32 = (_OWORD *)v28[3].f32;
          v16[30] = v33;
          v16[31] = v28 + 3;
          v16[32] = &v27[48 * v26];
          if (v31) {
            operator delete(v31);
          }
        }
        else
        {
          float32x4_t v19 = v42;
          v10.i32[1] = v43.i32[1];
          float32x4_t v20 = v44;
          v17[1] = v43;
          v17[2] = v20;
          *uint64_t v17 = v19;
          f32 = (_OWORD *)v17[3].f32;
        }
        v16[31] = f32;
        uint64_t v16 = *(void **)(a1 + 152);
      }
      float v36 = *(float *)(a1 + 160);
      v10.i32[0] = *(_DWORD *)(a1 + 164);
      v38[0] = MEMORY[0x1E4F143A8];
      v38[1] = 0x40000000;
      v38[2] = sub_1B64621EC;
      _OWORD v38[3] = &unk_1E6142338;
      long long v39 = *(_OWORD *)(a1 + 128);
      uint64_t v40 = *(void *)(a1 + 144);
      int32x2_t v41 = v16;
      sub_1B6461670(&v42, v6, v7, (uint64_t)v38, v36, *(double *)v10.i64);
      ++v5;
    }
    while (v5 != v8);
  }
  return 0;
}

void sub_1B64621EC(void *a1, long long *a2, _OWORD *a3, float a4)
{
  uint64_t v6 = *(void *)(a1[5] + 8);
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24) || (float v7 = *(float *)(v6 + 24), v7 > a4))
  {
    *(float *)(v6 + 24) = a4;
    *(_OWORD *)(*(void *)(a1[6] + 8) + 32) = *a3;
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
    uint64_t v8 = a1[7];
    if (!*(void *)(v8 + 128)) {
      return;
    }
    *(void *)(v8 + 248) -= 48;
    float32x4_t v9 = (void *)a1[7];
    float32x4_t v10 = (_OWORD *)v9[34];
    unint64_t v11 = v9[35];
    if ((unint64_t)v10 >= v11)
    {
      uint64_t v27 = v9[33];
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v10 - v27) >> 4);
      unint64_t v29 = v28 + 1;
      if (v28 + 1 > 0x555555555555555) {
        goto LABEL_55;
      }
      unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v27) >> 4);
      if (2 * v30 > v29) {
        unint64_t v29 = 2 * v30;
      }
      if (v30 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v31 = 0x555555555555555;
      }
      else {
        unint64_t v31 = v29;
      }
      if (v31) {
        uint64_t v32 = (char *)sub_1B6463DE8((uint64_t)(v9 + 35), v31);
      }
      else {
        uint64_t v32 = 0;
      }
      uint64_t v33 = &v32[48 * v28];
      float32x4_t v34 = &v32[48 * v31];
      long long v35 = *a2;
      long long v36 = a2[2];
      *((_OWORD *)v33 + 1) = a2[1];
      *((_OWORD *)v33 + 2) = v36;
      *(_OWORD *)uint64_t v33 = v35;
      float32x4_t v14 = v33 + 48;
      uint64_t v38 = (char *)v9[33];
      uint64_t v37 = (char *)v9[34];
      if (v37 != v38)
      {
        do
        {
          long long v39 = *((_OWORD *)v37 - 3);
          long long v40 = *((_OWORD *)v37 - 1);
          *((_OWORD *)v33 - 2) = *((_OWORD *)v37 - 2);
          *((_OWORD *)v33 - 1) = v40;
          *((_OWORD *)v33 - 3) = v39;
          v33 -= 48;
          v37 -= 48;
        }
        while (v37 != v38);
        uint64_t v37 = (char *)v9[33];
      }
      v9[33] = v33;
      v9[34] = v14;
      v9[35] = v34;
      if (v37) {
        operator delete(v37);
      }
    }
    else
    {
      long long v12 = *a2;
      long long v13 = a2[2];
      v10[1] = a2[1];
      void v10[2] = v13;
      *float32x4_t v10 = v12;
      float32x4_t v14 = v10 + 3;
    }
    v9[34] = v14;
    unint64_t v18 = (void *)a1[7];
    float32x4_t v19 = (_OWORD *)v18[22];
    unint64_t v41 = v18[23];
    if ((unint64_t)v19 < v41) {
      goto LABEL_34;
    }
    uint64_t v45 = v18[21];
    unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v45) >> 4);
    unint64_t v47 = v46 + 1;
    if (v46 + 1 <= 0x555555555555555)
    {
      unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v41 - v45) >> 4);
      if (2 * v48 > v47) {
        unint64_t v47 = 2 * v48;
      }
      if (v48 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v49 = 0x555555555555555;
      }
      else {
        unint64_t v49 = v47;
      }
      if (v49) {
        uint64_t v50 = (char *)sub_1B6463DE8((uint64_t)(v18 + 23), v49);
      }
      else {
        uint64_t v50 = 0;
      }
      uint64_t v51 = &v50[48 * v46];
      uint64_t v52 = &v50[48 * v49];
      long long v53 = *a2;
      long long v54 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v54;
      *(_OWORD *)uint64_t v51 = v53;
      float32x4_t v44 = v51 + 48;
      uint64_t v56 = (char *)v18[21];
      uint64_t v55 = (char *)v18[22];
      if (v55 == v56) {
        goto LABEL_51;
      }
      do
      {
        long long v57 = *((_OWORD *)v55 - 3);
        long long v58 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v58;
        *((_OWORD *)v51 - 3) = v57;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v56);
LABEL_50:
      uint64_t v55 = (char *)v18[21];
LABEL_51:
      v18[21] = v51;
      v18[22] = v44;
      v18[23] = v52;
      if (v55) {
        operator delete(v55);
      }
      goto LABEL_53;
    }
LABEL_55:
    abort();
  }
  float v15 = v7 + -0.001;
  float v16 = v7 + 0.001;
  if (v15 < a4 && v16 > a4)
  {
    unint64_t v18 = (void *)a1[7];
    float32x4_t v19 = (_OWORD *)v18[22];
    unint64_t v20 = v18[23];
    if ((unint64_t)v19 < v20)
    {
LABEL_34:
      long long v42 = *a2;
      long long v43 = a2[2];
      v19[1] = a2[1];
      v19[2] = v43;
      *float32x4_t v19 = v42;
      float32x4_t v44 = v19 + 3;
LABEL_53:
      v18[22] = v44;
      return;
    }
    uint64_t v21 = v18[21];
    unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v21) >> 4);
    unint64_t v23 = v22 + 1;
    if (v22 + 1 <= 0x555555555555555)
    {
      unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v21) >> 4);
      if (2 * v24 > v23) {
        unint64_t v23 = 2 * v24;
      }
      if (v24 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v25 = 0x555555555555555;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25) {
        unint64_t v26 = (char *)sub_1B6463DE8((uint64_t)(v18 + 23), v25);
      }
      else {
        unint64_t v26 = 0;
      }
      uint64_t v51 = &v26[48 * v22];
      uint64_t v52 = &v26[48 * v25];
      long long v59 = *a2;
      long long v60 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v60;
      *(_OWORD *)uint64_t v51 = v59;
      float32x4_t v44 = v51 + 48;
      uint64_t v61 = (char *)v18[21];
      uint64_t v55 = (char *)v18[22];
      if (v55 == v61) {
        goto LABEL_51;
      }
      do
      {
        long long v62 = *((_OWORD *)v55 - 3);
        long long v63 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v63;
        *((_OWORD *)v51 - 3) = v62;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v61);
      goto LABEL_50;
    }
    goto LABEL_55;
  }
}

void sub_1B6462560(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 <= 2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected vertex count", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"vertexCountPerPolygon >= 3");
  }
  uint64_t v10 = *(void *)(a1 + 152);
  int v11 = *(unsigned __int8 *)(a1 + 165);
  unsigned int v12 = *(_DWORD *)(a1 + 176);
  unsigned int v13 = *a3;
  if (v12 < *a3) {
    unsigned int v13 = *(_DWORD *)(a1 + 176);
  }
  float32x4_t v14 = (float *)(v10 + v13 * v11);
  float v15 = *v14;
  float v16 = v14[1];
  float v17 = v14[2];
  if (v12 >= a3[1]) {
    unsigned int v18 = a3[1];
  }
  else {
    unsigned int v18 = *(_DWORD *)(a1 + 176);
  }
  float32x4_t v19 = (float *)(v10 + v18 * v11);
  if (v12 >= a3[2]) {
    unsigned int v12 = a3[2];
  }
  float32x4_t v20 = *(float32x4_t *)(a1 + 32);
  float32x4_t v21 = *(float32x4_t *)(a1 + 48);
  float32x4_t v22 = *(float32x4_t *)(a1 + 64);
  float32x4_t v23 = *(float32x4_t *)(a1 + 80);
  float32x4_t v24 = vaddq_f32(v23, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v15), v21, v16), v22, v17));
  float32x4_t v25 = vaddq_f32(v23, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, *v19), v21, v19[1]), v22, v19[2]));
  float32x4_t v26 = vaddq_f32(v23, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, *(float *)(v10 + v12 * v11)), v21, *(float *)(v10 + v12 * v11 + 4)), v22, *(float *)(v10 + v12 * v11 + 8)));
  float32x4_t v52 = v24;
  float32x4_t v53 = v25;
  float32x4_t v54 = v26;
  uint64_t v27 = *(void **)(a1 + 168);
  if (v27[16])
  {
    unint64_t v28 = (float32x4_t *)v27[31];
    unint64_t v29 = v27[32];
    if ((unint64_t)v28 >= v29)
    {
      uint64_t v33 = v27[30];
      unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v28 - v33) >> 4);
      unint64_t v35 = v34 + 1;
      if (v34 + 1 > 0x555555555555555) {
        abort();
      }
      unint64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v29 - v33) >> 4);
      if (2 * v36 > v35) {
        unint64_t v35 = 2 * v36;
      }
      if (v36 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v37 = 0x555555555555555;
      }
      else {
        unint64_t v37 = v35;
      }
      if (v37) {
        uint64_t v38 = (char *)sub_1B6463DE8((uint64_t)(v27 + 32), v37);
      }
      else {
        uint64_t v38 = 0;
      }
      long long v39 = (float32x4_t *)&v38[48 * v34];
      long long v40 = &v38[48 * v37];
      float32x4_t v41 = v52;
      v25.i32[1] = v53.i32[1];
      float32x4_t v42 = v54;
      v39[1] = v53;
      v39[2] = v42;
      *long long v39 = v41;
      f32 = (_OWORD *)v39[3].f32;
      float32x4_t v44 = (float32x4_t *)v27[30];
      long long v43 = (float32x4_t *)v27[31];
      if (v43 != v44)
      {
        do
        {
          float32x4_t v45 = v43[-3];
          float32x4_t v25 = v43[-2];
          float32x4_t v46 = v43[-1];
          v39[-2] = v25;
          v39[-1] = v46;
          v39[-3] = v45;
          v39 -= 3;
          v43 -= 3;
        }
        while (v43 != v44);
        long long v43 = (float32x4_t *)v27[30];
      }
      v27[30] = v39;
      v27[31] = f32;
      v27[32] = v40;
      if (v43) {
        operator delete(v43);
      }
    }
    else
    {
      float32x4_t v30 = v52;
      v25.i32[1] = v53.i32[1];
      float32x4_t v31 = v54;
      v28[1] = v53;
      v28[2] = v31;
      *unint64_t v28 = v30;
      f32 = (_OWORD *)v28[3].f32;
    }
    v27[31] = f32;
    uint64_t v27 = *(void **)(a1 + 168);
  }
  float v47 = *(float *)(a1 + 180);
  v25.i32[0] = *(_DWORD *)(a1 + 184);
  v48[0] = MEMORY[0x1E4F143A8];
  v48[1] = 0x40000000;
  v48[2] = sub_1B64627C8;
  v48[3] = &unk_1E6142388;
  long long v49 = *(_OWORD *)(a1 + 128);
  uint64_t v50 = *(void *)(a1 + 144);
  uint64_t v51 = v27;
  sub_1B6461670(&v52, (float32x4_t *)(a1 + 96), (float32x4_t *)(a1 + 112), (uint64_t)v48, v47, *(double *)v25.i64);
}

void sub_1B64627C8(void *a1, long long *a2, _OWORD *a3, float a4)
{
  uint64_t v6 = *(void *)(a1[5] + 8);
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24) || (float v7 = *(float *)(v6 + 24), v7 > a4))
  {
    *(float *)(v6 + 24) = a4;
    *(_OWORD *)(*(void *)(a1[6] + 8) + 32) = *a3;
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
    uint64_t v8 = a1[7];
    if (!*(void *)(v8 + 128)) {
      return;
    }
    *(void *)(v8 + 248) -= 48;
    float32x4_t v9 = (void *)a1[7];
    uint64_t v10 = (_OWORD *)v9[34];
    unint64_t v11 = v9[35];
    if ((unint64_t)v10 >= v11)
    {
      uint64_t v27 = v9[33];
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v10 - v27) >> 4);
      unint64_t v29 = v28 + 1;
      if (v28 + 1 > 0x555555555555555) {
        goto LABEL_55;
      }
      unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v27) >> 4);
      if (2 * v30 > v29) {
        unint64_t v29 = 2 * v30;
      }
      if (v30 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v31 = 0x555555555555555;
      }
      else {
        unint64_t v31 = v29;
      }
      if (v31) {
        uint64_t v32 = (char *)sub_1B6463DE8((uint64_t)(v9 + 35), v31);
      }
      else {
        uint64_t v32 = 0;
      }
      uint64_t v33 = &v32[48 * v28];
      unint64_t v34 = &v32[48 * v31];
      long long v35 = *a2;
      long long v36 = a2[2];
      *((_OWORD *)v33 + 1) = a2[1];
      *((_OWORD *)v33 + 2) = v36;
      *(_OWORD *)uint64_t v33 = v35;
      float32x4_t v14 = v33 + 48;
      uint64_t v38 = (char *)v9[33];
      unint64_t v37 = (char *)v9[34];
      if (v37 != v38)
      {
        do
        {
          long long v39 = *((_OWORD *)v37 - 3);
          long long v40 = *((_OWORD *)v37 - 1);
          *((_OWORD *)v33 - 2) = *((_OWORD *)v37 - 2);
          *((_OWORD *)v33 - 1) = v40;
          *((_OWORD *)v33 - 3) = v39;
          v33 -= 48;
          v37 -= 48;
        }
        while (v37 != v38);
        unint64_t v37 = (char *)v9[33];
      }
      v9[33] = v33;
      v9[34] = v14;
      v9[35] = v34;
      if (v37) {
        operator delete(v37);
      }
    }
    else
    {
      long long v12 = *a2;
      long long v13 = a2[2];
      v10[1] = a2[1];
      void v10[2] = v13;
      *uint64_t v10 = v12;
      float32x4_t v14 = v10 + 3;
    }
    v9[34] = v14;
    unsigned int v18 = (void *)a1[7];
    float32x4_t v19 = (_OWORD *)v18[22];
    unint64_t v41 = v18[23];
    if ((unint64_t)v19 < v41) {
      goto LABEL_34;
    }
    uint64_t v45 = v18[21];
    unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v45) >> 4);
    unint64_t v47 = v46 + 1;
    if (v46 + 1 <= 0x555555555555555)
    {
      unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v41 - v45) >> 4);
      if (2 * v48 > v47) {
        unint64_t v47 = 2 * v48;
      }
      if (v48 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v49 = 0x555555555555555;
      }
      else {
        unint64_t v49 = v47;
      }
      if (v49) {
        uint64_t v50 = (char *)sub_1B6463DE8((uint64_t)(v18 + 23), v49);
      }
      else {
        uint64_t v50 = 0;
      }
      uint64_t v51 = &v50[48 * v46];
      float32x4_t v52 = &v50[48 * v49];
      long long v53 = *a2;
      long long v54 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v54;
      *(_OWORD *)uint64_t v51 = v53;
      float32x4_t v44 = v51 + 48;
      uint64_t v56 = (char *)v18[21];
      uint64_t v55 = (char *)v18[22];
      if (v55 == v56) {
        goto LABEL_51;
      }
      do
      {
        long long v57 = *((_OWORD *)v55 - 3);
        long long v58 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v58;
        *((_OWORD *)v51 - 3) = v57;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v56);
LABEL_50:
      uint64_t v55 = (char *)v18[21];
LABEL_51:
      v18[21] = v51;
      v18[22] = v44;
      v18[23] = v52;
      if (v55) {
        operator delete(v55);
      }
      goto LABEL_53;
    }
LABEL_55:
    abort();
  }
  float v15 = v7 + -0.001;
  float v16 = v7 + 0.001;
  if (v15 < a4 && v16 > a4)
  {
    unsigned int v18 = (void *)a1[7];
    float32x4_t v19 = (_OWORD *)v18[22];
    unint64_t v20 = v18[23];
    if ((unint64_t)v19 < v20)
    {
LABEL_34:
      long long v42 = *a2;
      long long v43 = a2[2];
      v19[1] = a2[1];
      v19[2] = v43;
      *float32x4_t v19 = v42;
      float32x4_t v44 = v19 + 3;
LABEL_53:
      v18[22] = v44;
      return;
    }
    uint64_t v21 = v18[21];
    unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v19 - v21) >> 4);
    unint64_t v23 = v22 + 1;
    if (v22 + 1 <= 0x555555555555555)
    {
      unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v21) >> 4);
      if (2 * v24 > v23) {
        unint64_t v23 = 2 * v24;
      }
      if (v24 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v25 = 0x555555555555555;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25) {
        float32x4_t v26 = (char *)sub_1B6463DE8((uint64_t)(v18 + 23), v25);
      }
      else {
        float32x4_t v26 = 0;
      }
      uint64_t v51 = &v26[48 * v22];
      float32x4_t v52 = &v26[48 * v25];
      long long v59 = *a2;
      long long v60 = a2[2];
      *((_OWORD *)v51 + 1) = a2[1];
      *((_OWORD *)v51 + 2) = v60;
      *(_OWORD *)uint64_t v51 = v59;
      float32x4_t v44 = v51 + 48;
      uint64_t v61 = (char *)v18[21];
      uint64_t v55 = (char *)v18[22];
      if (v55 == v61) {
        goto LABEL_51;
      }
      do
      {
        long long v62 = *((_OWORD *)v55 - 3);
        long long v63 = *((_OWORD *)v55 - 1);
        *((_OWORD *)v51 - 2) = *((_OWORD *)v55 - 2);
        *((_OWORD *)v51 - 1) = v63;
        *((_OWORD *)v51 - 3) = v62;
        v51 -= 48;
        v55 -= 48;
      }
      while (v55 != v61);
      goto LABEL_50;
    }
    goto LABEL_55;
  }
}

uint64_t sub_1B6462B3C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  unint64_t v11 = *(float32x4_t **)(a2 + 16);
  v95.i32[2] = 0;
  v95.i64[0] = 0;
  sub_1B64A1EC8((uint64_t)a3, (__n128 *)&v95, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = sub_1B63F4F54(a3, v12, v13, v14, v15, v16, v17, v18);
  if (v19)
  {
    uint64_t v27 = *(float32x4_t **)(a2 + 56);
    uint64_t v28 = sub_1B64B2994(v19, v20, v21, v22, v23, v24, v25, v26);
    uint64_t v36 = sub_1B64A01D4((uint64_t)a3, v29, v30, v31, v32, v33, v34, v35);
    float32x4_t v38 = *(float32x4_t *)(v36 + 16);
    float32x4_t v39 = *(float32x4_t *)(v36 + 32);
    float32x4_t v40 = vmulq_f32(*(float32x4_t *)v36, *(float32x4_t *)v36);
    float32x4_t v41 = vmulq_f32(v38, v38);
    float32x4_t v42 = vmulq_f32(v39, v39);
    v40.f32[0] = fmaxf(fmaxf(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0]), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0])), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0]));
    float32x4_t v43 = v11[9];
    HIDWORD(v47) = v95.i32[1];
    float32x4_t v44 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v36 + 48), v39, v43, 2), v38, *(float32x2_t *)v43.f32, 1), *(float32x4_t *)v36, v43.f32[0]), v95);
    float32x4_t v45 = vaddq_f32(*v27, v44);
    float32x4_t v92 = v44;
    float32x4_t v46 = vaddq_f32(v95, v44);
    *(float *)&double v47 = vmuls_lane_f32(v40.f32[0], v43, 3);
    float32x4_t v48 = v46;
    v48.i32[3] = LODWORD(v47);
    v11[12] = v48;
    if (v11[8].i64[0])
    {
      v11[15].i64[1] = v11[15].i64[0];
      v11[17].i64[0] = v11[16].i64[1];
    }
    float32x4_t v93 = vsubq_f32(sub_1B6461894(v11, v47, v45, vsubq_f32(v46, v45), v37, v28, (uint64_t)a3), v92);
    *uint64_t v27 = v93;
    uint64_t v56 = sub_1B64A1E7C((uint64_t)a3, v49, v50, v51, v52, v53, v54, v55);
    if (v56)
    {
      simd_float4x4 v64 = *(simd_float4x4 *)sub_1B64A01D4(v56, v57, v58, v59, v60, v61, v62, v63);
    }
    else
    {
      v64.columns[0] = (simd_float4)xmmword_1B6E4F300;
      v64.columns[1] = (simd_float4)xmmword_1B6E4F320;
      v64.columns[2] = (simd_float4)xmmword_1B6E4F2E0;
      v64.columns[3] = (simd_float4)xmmword_1B6E4F370;
    }
    simd_float4x4 v96 = __invert_f4(v64);
    float32x4_t v94 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v96.columns[3], (float32x4_t)v96.columns[2], v93, 2), (float32x4_t)v96.columns[1], *(float32x2_t *)v93.f32, 1), (float32x4_t)v96.columns[0], v93.f32[0]);
    uint64_t v72 = (const void *)sub_1B660F878(a4, v65, v66, v67, v68, v69, v70, v71);
    long long v80 = (void *)sub_1B660F8C4(a4, v73, v74, v75, v76, v77, v78, v79);
    size_t v88 = sub_1B63CA534(8, v81, v82, v83, v84, v85, v86, v87);
    sub_1B63F4524(v72, v80, &v94, v88, 6, 0, v89, v90);
  }
  return 1;
}

void sub_1B6462D34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v66[0] = xmmword_1B6E4F300;
  v66[1] = xmmword_1B6E4F320;
  v66[2] = xmmword_1B6E4F2E0;
  v66[3] = xmmword_1B6E4F370;
  long long v65 = xmmword_1B6E4F390;
  sub_1B642AC18(a2, v66, &v65, a4, a5, a6, a7, a8, *(__n128 *)(a1 + 192));
  long long v64 = xmmword_1B6E4F3A0;
  sub_1B642B7D4(a2, (float32x4_t *)(a1 + 208), (uint64_t)v66, (float *)&v64, v10, v11, v12, v13);
  uint64_t v19 = *(float32x4_t **)(a1 + 240);
  uint64_t v20 = *(float32x4_t **)(a1 + 248);
  long long v63 = xmmword_1B6E4F390;
  while (v19 != v20)
  {
    sub_1B642AB40(a2, 0, (float *)&v63, v14, v15, v16, v17, v18, *v19, v19[1]);
    sub_1B642AB40(a2, 0, (float *)&v63, v21, v22, v23, v24, v25, v19[1], v19[2]);
    float32x4_t v26 = v19[2];
    float32x4_t v27 = *v19;
    v19 += 3;
    sub_1B642AB40(a2, 0, (float *)&v63, v28, v29, v30, v31, v32, v26, v27);
  }
  uint64_t v33 = *(float32x4_t **)(a1 + 168);
  uint64_t v34 = *(float32x4_t **)(a1 + 176);
  long long v62 = xmmword_1B6E4F3A0;
  while (v33 != v34)
  {
    sub_1B642AB40(a2, 0, (float *)&v62, v14, v15, v16, v17, v18, *v33, v33[1]);
    sub_1B642AB40(a2, 0, (float *)&v62, v35, v36, v37, v38, v39, v33[1], v33[2]);
    float32x4_t v40 = v33[2];
    float32x4_t v41 = *v33;
    v33 += 3;
    sub_1B642AB40(a2, 0, (float *)&v62, v42, v43, v44, v45, v46, v40, v41);
  }
  float32x4_t v48 = *(float32x4_t **)(a1 + 264);
  double v47 = *(float32x4_t **)(a1 + 272);
  long long v61 = xmmword_1B6E4F360;
  while (v48 != v47)
  {
    sub_1B642AB40(a2, 0, (float *)&v61, v14, v15, v16, v17, v18, *v48, v48[1]);
    sub_1B642AB40(a2, 0, (float *)&v61, v49, v50, v51, v52, v53, v48[1], v48[2]);
    float32x4_t v54 = v48[2];
    float32x4_t v55 = *v48;
    v48 += 3;
    sub_1B642AB40(a2, 0, (float *)&v61, v56, v57, v58, v59, v60, v54, v55);
  }
}

uint64_t sub_1B6462EE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v11.n128_u32[2] = 0;
  v11.n128_u64[0] = 0;
  sub_1B64A1EC8(a3, &v11, a3, a4, a5, a6, a7, a8);
  float32x4_t v9 = (__n128 *)malloc_type_calloc(1uLL, 0x10uLL, 0x1000040451B5BE8uLL);
  *(void *)(a2 + 56) = v9;
  *float32x4_t v9 = v11;
  return 1;
}

__CFString *sub_1B6462F4C()
{
  return @"transform";
}

uint64_t sub_1B6462F5C()
{
  if (qword_1E9DDAD50 != -1) {
    dispatch_once_f(&qword_1E9DDAD50, &qword_1EB995F30, (dispatch_function_t)sub_1B6461444);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995F30, 0x110uLL);
  sub_1B66056B0(v0);
  *(void *)(v0 + 160) = -1;
  *(_DWORD *)(v0 + 156) = 1065353216;
  *(void *)(v0 + 80) = sub_1B6462EE4;
  *(void *)(v0 + 88) = sub_1B6462B3C;
  *(void *)(v0 + 96) = sub_1B6462F4C;
  *(void *)(v0 + 112) = sub_1B6462D34;
  return v0;
}

void sub_1B646301C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"c");
  }
  *(void *)(a1 + 160) = a2;
}

void sub_1B646306C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"c");
  }
  *(float *)(a1 + 156) = a2;
}

__n128 sub_1B64630C4(__n128 *a1, __n128 result, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    __n128 v10 = result;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"c");
    double result = v10;
  }
  result.n128_u32[3] = a1[9].n128_u32[3];
  a1[9] = result;
  return result;
}

uint64_t sub_1B6463120(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B6463150()
{
  if (qword_1E9DDAD58 != -1) {
    dispatch_once_f(&qword_1E9DDAD58, &qword_1EB995F40, (dispatch_function_t)sub_1B6463120);
  }
  return qword_1EB995F40;
}

CFTypeRef sub_1B64631A4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"c");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 144);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 144) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 144) = result;
  }
  return result;
}

CFTypeRef sub_1B6463220(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"c");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 136);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 136) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 136) = result;
  }
  return result;
}

void sub_1B646329C(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"c");
  }
  float v11 = 0.0001;
  if (a2 >= 0.0001) {
    float v11 = a2;
  }
  *(float *)(a1 + 168) = v11;
}

BOOL sub_1B6463310(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"controller");
  }
  uint64_t v11 = sub_1B63F4F54(a3, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!v11) {
    return 0;
  }
  uint64_t v19 = sub_1B64B2994(v11, v12, v13, v14, v15, v16, v17, v18);
  uint64_t v20 = *(void *)(a2 + 16);
  uint64_t v21 = *(void *)(v20 + 136);
  uint64_t v99 = v21;
  BOOL v22 = v21 != 0;
  if (v21)
  {
    uint64_t v23 = v19;
    uint64_t v96 = 0xA00000000;
    uint64_t v97 = (unint64_t *)v98;
    v95[0] = 0;
    v95[1] = v95;
    v95[2] = 0x2000000000;
    v95[3] = &v96;
    if (*(unsigned char *)(v20 + 152))
    {
      sub_1B6463628((uint64_t)&v96, v21);
      sub_1B6463628((uint64_t)&v96, (uint64_t)a3);
    }
    else
    {
      sub_1B63D4868((uint64_t)&v96, &v99);
      *(void *)&v83[0] = a3;
      sub_1B63D4868((uint64_t)&v96, v83);
    }
    unint64_t v24 = 126 - 2 * __clz(v96);
    if (v96) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = 0;
    }
    sub_1B6463F08((uint64_t)v97, &v97[v96], (uint64_t)v83, v25, 1);
    v94.i32[2] = 0;
    v94.i64[0] = 0;
    sub_1B64A1EC8((uint64_t)a3, (__n128 *)&v94, v26, v27, v28, v29, v30, v31);
    v93.i32[2] = 0;
    v93.i64[0] = 0;
    sub_1B64A1EC8(v99, (__n128 *)&v93, v32, v33, v34, v35, v36, v37);
    float32x4_t v38 = vsubq_f32(v94, v93);
    float32x4_t v39 = vmulq_f32(v38, v38);
    v39.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).u64[0];
    v39.f32[0] = sqrtf(v39.f32[0]);
    float32x4_t v40 = vdivq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0));
    __asm { FMOV            V2.4S, #1.0 }
    float32x4_t v73 = v40;
    uint64_t v89 = 0;
    uint64_t v90 = (float *)&v89;
    uint64_t v91 = 0x2000000000;
    int v92 = 2139095039;
    uint64_t v85 = 0;
    uint64_t v86 = &v85;
    uint64_t v87 = 0x2000000000;
    char v88 = 0;
    uint64_t v84 = 0;
    memset(v83, 0, sizeof(v83));
    v75[0] = MEMORY[0x1E4F143A8];
    v75[1] = 0x40000000;
    v75[2] = sub_1B64636B0;
    v75[3] = &unk_1E6142428;
    uint64_t v78 = &v85;
    uint64_t v79 = &v89;
    float32x4_t v76 = v93;
    float32x4_t v77 = v94;
    long long v80 = v95;
    uint64_t v81 = v20;
    uint64_t v82 = a3;
    sub_1B65C4C3C((uint64_t)v75, (uint64_t)v83);
    *(void *)&v83[0] = *(void *)(v20 + 160);
    sub_1B65C5818(v23, (uint64_t)v83);
    if (*((unsigned char *)v86 + 24))
    {
      float32x4_t v74 = vmlaq_n_f32(v93, v73, v90[6] - *(float *)(v20 + 168));
      uint64_t v53 = (const void *)sub_1B660F878(a4, v46, v47, v48, v49, v50, v51, v52);
      long long v61 = (void *)sub_1B660F8C4(a4, v54, v55, v56, v57, v58, v59, v60);
      size_t v69 = sub_1B63CA534(8, v62, v63, v64, v65, v66, v67, v68);
      sub_1B63F4524(v53, v61, &v74, v69, 6, 0, v70, v71);
    }
    _Block_object_dispose(&v85, 8);
    _Block_object_dispose(&v89, 8);
    _Block_object_dispose(v95, 8);
    if (HIDWORD(v96) && v97 != (unint64_t *)v98) {
      free(v97);
    }
  }
  return v22;
}

uint64_t sub_1B6463628(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  sub_1B63D4868(a1, &v5);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = sub_1B6464A50;
  v4[3] = &unk_1E6142448;
  _OWORD v4[4] = a1;
  return sub_1B64A18A4(v5, (uint64_t)v4);
}

void sub_1B64636B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 1)
  {
    uint64_t v128 = v13;
    uint64_t v129 = v12;
    uint64_t v130 = v11;
    uint64_t v131 = v10;
    uint64_t v132 = v8;
    uint64_t v133 = v9;
    uint64_t v14 = a3;
    uint64_t v15 = a2;
    uint64_t v17 = 0;
    BOOL v18 = *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) != 0;
    float v19 = *(float *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
    do
    {
      unint64_t v20 = *(void *)(v15 + 8 * v17);
      uint64_t v21 = *(unsigned int **)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
      unint64_t v22 = *v21;
      if (!v22) {
        goto LABEL_30;
      }
      uint64_t v23 = (unint64_t *)*((void *)v21 + 1);
      unint64_t v24 = &v23[v22];
      do
      {
        unint64_t v25 = v22 >> 1;
        uint64_t v26 = &v23[v22 >> 1];
        unint64_t v28 = *v26;
        uint64_t v27 = v26 + 1;
        v22 += ~(v22 >> 1);
        if (v28 < v20) {
          uint64_t v23 = v27;
        }
        else {
          unint64_t v22 = v25;
        }
      }
      while (v22);
      if (v23 == v24 || v20 < *v23)
      {
LABEL_30:
        uint64_t v29 = sub_1B649F5F4(*(void *)(v15 + 8 * v17), a2, a3, a4, a5, a6, a7, a8);
        uint64_t v37 = (simd_float4x4 *)sub_1B64A01D4(v20, v30, v31, v32, v33, v34, v35, v36);
        simd_float4x4 v134 = *v37;
        float32x4_t v101 = (float32x4_t)v37->columns[0];
        float32x4_t v102 = (float32x4_t)v134.columns[1];
        float32x4_t v103 = (float32x4_t)v134.columns[2];
        simd_float4x4 v135 = __invert_f4(*v37);
        float32x4_t v108 = (float32x4_t)v135.columns[0];
        float32x4_t v110 = (float32x4_t)v135.columns[3];
        float32x4_t v104 = *(float32x4_t *)(a1 + 32);
        float32x4_t v105 = (float32x4_t)v135.columns[2];
        float32x4_t v106 = *(float32x4_t *)(a1 + 48);
        float32x4_t v107 = (float32x4_t)v135.columns[1];
        CFTypeRef v45 = sub_1B63CE23C(v29, v38, v39, v40, v41, v42, v43, v44);
        CFArrayRef v53 = sub_1B64ABD08((uint64_t)v45, v46, v47, v48, v49, v50, v51, v52);
        if (v53)
        {
          uint64_t v54 = (uint64_t)v53;
          uint64_t v55 = sub_1B64ACF7C((uint64_t)v45, 0, a3, a4, a5, a6, a7, a8);
          if (sub_1B641D8A0((uint64_t)v55, v56, v57, v58, v59, v60, v61, v62))
          {
            BOOL v100 = v18;
            uint64_t v112 = sub_1B641D478((uint64_t)v55, a2, a3, a4, a5, a6, a7, a8);
            uint64_t v64 = v63;
            uint64_t v70 = sub_1B64ACE9C((uint64_t)v45, 0, 0, v65, v66, v67, v68, v69);
            if ((v64 & 0xFF00000000) != 0x800000000) {
              sub_1B63F2F54(17, @"Assertion '%s' failed.  - Only vector3 type is supported.", a3, a4, a5, a6, a7, a8, (uint64_t)"positions.type == kCFXBaseTypeVector3");
            }
            if (v54 >= 1)
            {
              CFIndex v71 = 0;
              float32x4_t v72 = vmulq_f32(v101, v101);
              float32x4_t v73 = vmulq_f32(v102, v102);
              float32x4_t v74 = vmulq_f32(v103, v103);
              float v75 = fmaxf(fmaxf(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 2), vaddq_f32(v72, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.f32, 1))).f32[0]), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v74, 2), vaddq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v74.f32, 1))).f32[0])), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 2), vaddq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.f32, 1))).f32[0]));
              float32x4_t v76 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v110, v105, v104, 2), v107, *(float32x2_t *)v104.f32, 1), v108, v104.f32[0]);
              float32x4_t v77 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v110, v105, v106, 2), v107, *(float32x2_t *)v106.f32, 1), v108, v106.f32[0]);
              float32x4_t v78 = vsubq_f32(v77, v76);
              int32x4_t v79 = (int32x4_t)vmulq_f32(v78, v78);
              v79.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v79, 2), vadd_f32(*(float32x2_t *)v79.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v79.i8, 1))).u32[0];
              *(float32x2_t *)v74.f32 = vrsqrte_f32((float32x2_t)v79.u32[0]);
              *(float32x2_t *)v74.f32 = vmul_f32(*(float32x2_t *)v74.f32, vrsqrts_f32((float32x2_t)v79.u32[0], vmul_f32(*(float32x2_t *)v74.f32, *(float32x2_t *)v74.f32)));
              float32x4_t v109 = vmulq_n_f32(v78, vmul_f32(*(float32x2_t *)v74.f32, vrsqrts_f32((float32x2_t)v79.u32[0], vmul_f32(*(float32x2_t *)v74.f32, *(float32x2_t *)v74.f32))).f32[0]);
              float32x4_t v111 = v76;
              float32x4_t v80 = vsubq_f32(v76, v77);
              float32x4_t v81 = vmulq_f32(v80, v80);
              float v82 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2), vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1))).f32[0]);
              do
              {
                uint64_t v83 = sub_1B64ABD78((uint64_t)v45, v71, 0, a4, a5, a6, a7, a8);
                uint64_t v127 = 0;
                long long v125 = 0u;
                long long v126 = 0u;
                long long v124 = 0u;
                sub_1B63D11F0((uint64_t)v83, v70, v84, v85, v86, v87, v88, v89, (uint64_t)&v124);
                if ((BYTE10(v125) & 0xFA) != 0)
                {
                  sub_1B63F2F54(0, @"Warning: Occluder can only process triangles.", v90, v91, v92, v93, v94, v95, v97);
                }
                else
                {
                  v122[0] = v124;
                  v122[1] = v125;
                  v122[2] = v126;
                  uint64_t v123 = v127;
                  v113[0] = MEMORY[0x1E4F143A8];
                  v113[1] = 0x40000000;
                  v113[2] = sub_1B6463ADC;
                  v113[3] = &unk_1E6142400;
                  uint64_t v117 = v112;
                  uint64_t v118 = v64;
                  int v119 = v64 - 1;
                  float32x4_t v114 = v111;
                  float32x4_t v115 = v109;
                  float v120 = v82;
                  float v121 = v75;
                  int8x16_t v116 = vextq_s8(*(int8x16_t *)(a1 + 64), *(int8x16_t *)(a1 + 64), 8uLL);
                  sub_1B63D1BEC((uint64_t *)v122, (uint64_t)v113, v90, v91, v92, v93, v94, v95);
                }
                ++v71;
              }
              while (v54 != v71);
            }
            uint64_t v15 = a2;
            uint64_t v14 = a3;
            if (*(float *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) < v19)
            {
              uint64_t v96 = *(void *)(*(void *)(a1 + 88) + 144);
              if (v96)
              {
                if (sub_1B6461298(v96, v20, *(void *)(a1 + 96), a4, a5, a6, a7, a8))
                {
                  sub_1B646132C(*(void *)(*(void *)(a1 + 88) + 144), v20, *(void *)(a1 + 96), a4, a5, a6, a7, a8);
                }
                else
                {
                  *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = v100;
                  *(float *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = v19;
                }
              }
            }
            BOOL v18 = *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) != 0;
            float v19 = *(float *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
          }
        }
      }
      ++v17;
    }
    while (v17 != v14);
  }
}

float32_t sub_1B6463ADC(float32x4_t *a1, uint64_t a2, __int32 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 <= 2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected vertex count", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"vertexCountPerPolygon >= 3");
  }
  uint64_t v10 = a1[5].i64[0];
  int v11 = a1[5].u8[13];
  unsigned __int32 v12 = a1[6].u32[0];
  __int32 v13 = *a3;
  if (v12 < *a3) {
    __int32 v13 = a1[6].i32[0];
  }
  uint64_t v14 = v10 + (v13 * v11);
  v15.i64[0] = *(void *)v14;
  v15.i32[2] = *(_DWORD *)(v14 + 8);
  v15.i32[3] = 1.0;
  if (v12 >= a3[1]) {
    __int32 v16 = a3[1];
  }
  else {
    __int32 v16 = a1[6].i32[0];
  }
  uint64_t v17 = v10 + (v16 * v11);
  v18.i64[0] = *(void *)v17;
  v18.i32[2] = *(_DWORD *)(v17 + 8);
  v18.i32[3] = 1.0;
  if (v12 >= a3[2]) {
    unsigned __int32 v12 = a3[2];
  }
  uint64_t v19 = v10 + v12 * v11;
  v20.i64[0] = *(void *)v19;
  v20.i32[2] = *(_DWORD *)(v19 + 8);
  v20.i32[3] = 1.0;
  float32x4_t v21 = vsubq_f32(v18, v15);
  float32x4_t v22 = vsubq_f32(v20, v15);
  float32x4_t v23 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), vnegq_f32(v21)), v22, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL));
  int32x4_t v24 = (int32x4_t)vmulq_f32(v23, v23);
  v24.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v24.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v24, 2), *(float32x2_t *)v24.i8)).u32[0];
  *(float32x2_t *)v22.f32 = vrsqrte_f32((float32x2_t)v24.u32[0]);
  *(float32x2_t *)v22.f32 = vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v24.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32)));
  float32x4_t v25 = vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), vmul_f32(*(float32x2_t *)v22.f32, vrsqrts_f32((float32x2_t)v24.u32[0], vmul_f32(*(float32x2_t *)v22.f32, *(float32x2_t *)v22.f32))).f32[0]);
  float32x4_t v26 = vmulq_f32(v15, v25);
  float32x4_t v27 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1)));
  float32x4_t v28 = a1[2];
  float32x4_t v29 = a1[3];
  float32x4_t v30 = vmulq_f32(v28, v25);
  float32x4_t v31 = vmulq_f32(v29, v25);
  float v32 = vdivq_f32(vsubq_f32(v27, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1)))), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1)))).f32[0];
  if (v32 > 0.0 && v32 < a1[6].f32[1])
  {
    float32x4_t v36 = vmlaq_n_f32(v28, v29, v32);
    v35[0] = v15;
    v35[1] = v18;
    v35[2] = v20;
    v15.f32[0] = v32 * a1[6].f32[2];
    if (v15.f32[0] < *(float *)(*(void *)(a1[4].i64[0] + 8) + 24))
    {
      float v34 = v32;
      if (sub_1B6454B48(v35, &v36))
      {
        *(unsigned char *)(*(void *)(a1[4].i64[1] + 8) + 24) = 1;
        v15.f32[0] = v34 * a1[6].f32[2];
        *(_DWORD *)(*(void *)(a1[4].i64[0] + 8) + 24) = v15.i32[0];
      }
    }
  }
  return v15.f32[0];
}

__CFString *sub_1B6463CC0()
{
  return @"transform";
}

uint64_t sub_1B6463CD0()
{
  if (qword_1E9DDAD58 != -1) {
    dispatch_once_f(&qword_1E9DDAD58, &qword_1EB995F40, (dispatch_function_t)sub_1B6463120);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995F40, 0xA0uLL);
  sub_1B66056B0(v0);
  *(void *)(v0 + 160) = 1;
  *(_DWORD *)(v0 + 168) = 925353388;
  *(unsigned char *)(v0 + 152) = 1;
  *(void *)(v0 + 88) = sub_1B6463310;
  *(void *)(v0 + 96) = sub_1B6463CC0;
  return v0;
}

CFStringRef sub_1B6463D80(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXConstraintAcceleration>");
}

CFStringRef sub_1B6463DB4(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXConstraintAcceleration>");
}

void *sub_1B6463DE8(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    sub_1B63C8620();
  }
  return operator new(48 * a2);
}

void sub_1B6463E34(uint64_t a1)
{
  CFAllocatorRef v2 = *(const void **)(a1 + 136);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 136) = 0;
  }
  __int16 v3 = *(const void **)(a1 + 144);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 144) = 0;
  }

  sub_1B66055EC(a1);
}

CFStringRef sub_1B6463E88(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXConstraintAvoidOccluder %p>", a1);
}

CFStringRef sub_1B6463EC8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXConstraintAvoidOccluder %p>", a1);
}

uint64_t sub_1B6463F08(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = (unint64_t *)result;
LABEL_2:
  int v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v22 = *(a2 - 1);
          unint64_t v23 = *v11;
          if (v22 < *v11)
          {
            *int v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          CFTypeRef result = sub_1B6464304(v11, v11 + 1, a2 - 1);
          break;
        case 4uLL:
          CFTypeRef result = sub_1B6464680(v11, v11 + 1, v11 + 2, a2 - 1);
          break;
        case 5uLL:
          CFTypeRef result = sub_1B6464704(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)sub_1B64647AC(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x401)
    {
      sub_1B6464304(v11, &v11[v15 >> 1], a2 - 1);
      sub_1B6464304(v11 + 1, v17 - 1, a2 - 2);
      sub_1B6464304(v11 + 2, &v11[v16 + 1], a2 - 3);
      sub_1B6464304(v17 - 1, v17, &v11[v16 + 1]);
      unint64_t v18 = *v11;
      *int v11 = *v17;
      *uint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_1B6464304(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(v11 - 1) >= *v11)
    {
      CFTypeRef result = (uint64_t)sub_1B646438C(v11, (uint64_t *)a2);
      int v11 = (unint64_t *)result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = sub_1B646443C(v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = sub_1B64644F0(v11, v19);
    int v11 = v19 + 1;
    CFTypeRef result = sub_1B64644F0(v19 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      CFTypeRef result = sub_1B6463F08(v10, v19, a3, -v13, a5 & 1);
      int v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  int32x4_t v24 = v11 + 1;
  BOOL v26 = v11 == a2 || v24 == a2;
  if (a5)
  {
    if (!v26)
    {
      uint64_t v27 = 0;
      float32x4_t v28 = v11;
      do
      {
        unint64_t v30 = *v28;
        unint64_t v29 = v28[1];
        float32x4_t v28 = v24;
        if (v29 < v30)
        {
          uint64_t v31 = v27;
          while (1)
          {
            *(unint64_t *)((char *)v11 + v31 + 8) = v30;
            if (!v31) {
              break;
            }
            unint64_t v30 = *(unint64_t *)((char *)v11 + v31 - 8);
            v31 -= 8;
            if (v29 >= v30)
            {
              float v32 = (unint64_t *)((char *)v11 + v31 + 8);
              goto LABEL_50;
            }
          }
          float v32 = v11;
LABEL_50:
          unint64_t *v32 = v29;
        }
        int32x4_t v24 = v28 + 1;
        v27 += 8;
      }
      while (v28 + 1 != a2);
    }
  }
  else if (!v26)
  {
    do
    {
      unint64_t v34 = *v10;
      unint64_t v33 = v10[1];
      uint64_t v10 = v24;
      if (v33 < v34)
      {
        do
        {
          *int32x4_t v24 = v34;
          unint64_t v34 = *(v24 - 2);
          --v24;
        }
        while (v33 < v34);
        *int32x4_t v24 = v33;
      }
      int32x4_t v24 = v10 + 1;
    }
    while (v10 + 1 != a2);
  }
  return result;
}

uint64_t sub_1B6464304(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a1;
  unint64_t v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    unint64_t v6 = *a1;
    if (*a2 >= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

unint64_t *sub_1B646438C(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2 = *a1;
  if (*a1 >= *(a2 - 1))
  {
    unint64_t v5 = (uint64_t *)(a1 + 1);
    do
    {
      unint64_t v3 = (unint64_t *)v5;
      if (v5 >= a2) {
        break;
      }
      ++v5;
    }
    while (v2 >= *v3);
  }
  else
  {
    unint64_t v3 = a1;
    do
    {
      unint64_t v4 = v3[1];
      ++v3;
    }
    while (v2 >= v4);
  }
  if (v3 < (unint64_t *)a2)
  {
    do
      unint64_t v6 = *--a2;
    while (v2 < v6);
  }
  if (v3 < (unint64_t *)a2)
  {
    unint64_t v7 = *v3;
    unint64_t v8 = *a2;
    do
    {
      *unint64_t v3 = v8;
      *a2 = v7;
      do
      {
        unint64_t v9 = v3[1];
        ++v3;
        unint64_t v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        unint64_t v10 = *--a2;
        unint64_t v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < (unint64_t *)a2);
  }
  if (v3 - 1 != a1) {
    *a1 = *(v3 - 1);
  }
  *(v3 - 1) = v2;
  return v3;
}

unint64_t *sub_1B646443C(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = *a1;
  do
    unint64_t v4 = a1[++v2];
  while (v4 < v3);
  unint64_t v5 = &a1[v2];
  unint64_t v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      unint64_t v8 = *--a2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
      unint64_t v7 = *--a2;
    while (v7 >= v3);
  }
  if (v5 < a2)
  {
    unint64_t v9 = *a2;
    unint64_t v10 = &a1[v2];
    int v11 = a2;
    do
    {
      *unint64_t v10 = v9;
      *int v11 = v4;
      do
      {
        unint64_t v12 = v10[1];
        ++v10;
        unint64_t v4 = v12;
      }
      while (v12 < v3);
      do
      {
        unint64_t v13 = *--v11;
        unint64_t v9 = v13;
      }
      while (v13 >= v3);
    }
    while (v10 < v11);
    unint64_t v6 = v10 - 1;
  }
  if (v6 != a1) {
    *a1 = *v6;
  }
  *unint64_t v6 = v3;
  return v6;
}

BOOL sub_1B64644F0(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(a2 - 1);
      unint64_t v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1B6464304(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1B6464680(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1B6464704(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unint64_t v8 = a1 + 2;
      sub_1B6464304(a1, a1 + 1, a1 + 2);
      unint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    unint64_t v13 = *v8;
    if (*v9 < *v8)
    {
      uint64_t v14 = v11;
      while (1)
      {
        *(unint64_t *)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 8;
        if (v14 == 8) {
          break;
        }
        unint64_t v13 = *(unint64_t *)((char *)a1 + v14 - 16);
        v14 -= 8;
        if (v12 >= v13)
        {
          unint64_t v16 = (unint64_t *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      unint64_t v16 = a1;
LABEL_12:
      *unint64_t v16 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    unint64_t v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1B6464680(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result = sub_1B6464304(a1, a2, a3);
  unint64_t v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    unint64_t v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      unint64_t v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t sub_1B6464704(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result = sub_1B6464680(a1, a2, a3, a4);
  unint64_t v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    unint64_t v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      unint64_t v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        unint64_t v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

unint64_t *sub_1B64647AC(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    unint64_t v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unint64_t v12 = &a1[v10];
      do
      {
        sub_1B646498C((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    unint64_t v13 = v6;
    if (v6 != a3)
    {
      unint64_t v14 = v6;
      do
      {
        unint64_t v15 = *v14;
        if (*v14 < *a1)
        {
          *unint64_t v14 = *a1;
          *a1 = v15;
          sub_1B646498C((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      unint64_t v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      do
      {
        uint64_t v17 = 0;
        unint64_t v18 = *a1;
        uint64_t v19 = a1;
        do
        {
          char v20 = &v19[v17 + 1];
          uint64_t v21 = (2 * v17) | 1;
          uint64_t v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            unint64_t v22 = *v20;
            uint64_t v17 = v21;
          }
          else
          {
            unint64_t v22 = *v20;
            if (*v20 >= v20[1])
            {
              uint64_t v17 = v21;
            }
            else
            {
              unint64_t v22 = v20[1];
              ++v20;
            }
          }
          *uint64_t v19 = v22;
          uint64_t v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *char v20 = v18;
        }
        else
        {
          *char v20 = *v6;
          *unint64_t v6 = v18;
          uint64_t v23 = (char *)v20 - (char *)a1 + 8;
          if (v23 >= 9)
          {
            unint64_t v24 = (((unint64_t)v23 >> 3) - 2) >> 1;
            float32x4_t v25 = &a1[v24];
            unint64_t v26 = *v25;
            unint64_t v27 = *v20;
            if (*v25 < *v20)
            {
              do
              {
                *char v20 = v26;
                char v20 = v25;
                if (!v24) {
                  break;
                }
                unint64_t v24 = (v24 - 1) >> 1;
                float32x4_t v25 = &a1[v24];
                unint64_t v26 = *v25;
              }
              while (*v25 < v27);
              *char v20 = v27;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1B646498C(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (unint64_t *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        unint64_t v10 = *v8;
      }
      else
      {
        unint64_t v10 = *v8;
        if (*v8 < v8[1])
        {
          unint64_t v10 = v8[1];
          ++v8;
          uint64_t v7 = v9;
        }
      }
      unint64_t v11 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v12 = (2 * v7) | 1;
          uint64_t v8 = (unint64_t *)(result + 8 * v12);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            unint64_t v10 = *v8;
            uint64_t v7 = v12;
          }
          else
          {
            unint64_t v10 = *v8;
            if (*v8 >= v8[1])
            {
              uint64_t v7 = v12;
            }
            else
            {
              unint64_t v10 = v8[1];
              ++v8;
            }
          }
        }
        while (v10 >= v11);
        *a4 = v11;
      }
    }
  }
  return result;
}

uint64_t sub_1B6464A50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a2;
  if (a2 && sub_1B649FF9C(a2, a2, a3, a4, a5, a6, a7, a8)) {
    sub_1B63D4868(*(void *)(a1 + 32), &v10);
  }
  return 0;
}

id sub_1B6464A9C(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 1) == 0 && sub_1B643ADCC((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v9 = sub_1B643AD48(a1, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v10 = sub_1B6464A9C(v9, 1);
    CFRelease(v9);
    return (id)v10;
  }
  if (sub_1B643BE9C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8) == 2)
  {
    sub_1B63F2F54(16, @"Error: CFXImageToMDLTexture not supported for image 3D", v12, v13, v14, v15, v16, v17, v46);
    return 0;
  }
  unint64_t v18 = (CGContext *)sub_1B643BBE4((uint64_t)a1, 1, v12, v13, v14, v15, v16, v17);
  if (!v18) {
    return 0;
  }
  uint64_t v19 = v18;
  Data = CGBitmapContextGetData(v18);
  double v48 = sub_1B643A59C((uint64_t)a1, v21, v22, v23, v24, v25, v26, v27);
  size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(v19);
  size_t BitsPerPixel = CGBitmapContextGetBitsPerPixel(v19);
  if (BitsPerComponent != 8)
  {
    CFRelease(v19);
    return 0;
  }
  size_t v30 = BitsPerPixel >> 3;
  id v31 = objc_alloc(MEMORY[0x1E4F35C38]);
  float v32 = (void *)MEMORY[0x1E4F1C9B8];
  size_t BytesPerRow = CGBitmapContextGetBytesPerRow(v19);
  uint64_t v35 = objc_msgSend_dataWithBytes_length_(v32, v34, (uint64_t)Data, (unint64_t)vmuls_lane_f32((float)BytesPerRow, *(float32x2_t *)&v48, 1));
  size_t v36 = CGBitmapContextGetBytesPerRow(v19);
  BOOL v47 = sub_1B643BE9C((uint64_t)a1, v37, v38, v39, v40, v41, v42, v43) == 3;
  isCube = objc_msgSend_initWithData_topLeftOrigin_name_dimensions_rowStride_channelCount_channelEncoding_isCube_(v31, v44, v35, 1, 0, v36, v30, 1, COERCE_DOUBLE(vcvt_s32_f32(*(float32x2_t *)&v48)), v47);
  CFRelease(v19);

  return isCube;
}

uint64_t sub_1B6464C54(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int64_t v5 = (CGImage *)objc_msgSend_imageFromTexture(a1, a2, a3, a4);
  uint64_t v6 = sub_1B643AD04(v5);
  if (objc_msgSend_isCube(a1, v7, v8, v9))
  {
    sub_1B643C038(v6);
    if (!sub_1B643ADCC(v6, v10, v11, v12, v13, v14, v15, v16)) {
      sub_1B63F2F54(0, @"Warning: Failed to create cubemap from Model I/O texture", v17, v18, v19, v20, v21, v22, v24);
    }
  }
  return v6;
}

uint64_t sub_1B6464CF8(void *a1, char *a2, uint64_t a3, uint64_t a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_transform(a1, a2, a3, a4))
  {
    uint64_t v13 = objc_msgSend_transform(a1, v10, v11, v12);
    objc_msgSend_matrix(v13, v14, v15, v16);
    uint64_t v17 = 0;
    v52[0] = v18;
    v52[1] = v19;
    v52[2] = v20;
    v52[3] = v21;
    do
    {
      v53[v17] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a5, COERCE_FLOAT(v52[v17])), (float32x4_t)a6, *(float32x2_t *)&v52[v17], 1), (float32x4_t)a7, (float32x4_t)v52[v17], 2), (float32x4_t)a8, (float32x4_t)v52[v17], 3);
      ++v17;
    }
    while (v17 != 4);
    a5 = (__n128)v53[0];
    a6 = (__n128)v53[1];
    a7 = (__n128)v53[2];
    a8 = (__n128)v53[3];
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v25 = objc_alloc(MEMORY[0x1E4F35C48]);
    unint64_t v29 = objc_msgSend_initWithMatrix_(v25, v26, v27, v28, a5.n128_f64[0], a6.n128_f64[0], a7.n128_f64[0], a8.n128_f64[0]);
    objc_msgSend_setTransform_(a1, v30, (uint64_t)v29, v31);

    return objc_msgSend_addObject_(a2, v32, (uint64_t)a1, v33);
  }
  else
  {
    uint64_t result = objc_msgSend_children(a1, v22, v23, v24);
    if (result)
    {
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      uint64_t v38 = objc_msgSend_children(a1, v35, v36, v37);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v38, v39, (uint64_t)&v48, (uint64_t)v54, 16);
      if (result)
      {
        uint64_t v40 = result;
        uint64_t v41 = *(void *)v49;
        do
        {
          uint64_t v42 = 0;
          do
          {
            if (*(void *)v49 != v41) {
              objc_enumerationMutation(v38);
            }
            sub_1B6464CF8(*(void *)(*((void *)&v48 + 1) + 8 * v42++), a2, a5, a6, a7, a8);
          }
          while (v40 != v42);
          uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v38, v43, (uint64_t)&v48, (uint64_t)v54, 16);
          uint64_t v40 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

char *sub_1B6464F04(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  __n128 v14 = *(__n128 *)(MEMORY[0x1E4F149A0] + 16);
  __n128 v15 = *(__n128 *)MEMORY[0x1E4F149A0];
  __n128 v12 = *(__n128 *)(MEMORY[0x1E4F149A0] + 48);
  __n128 v13 = *(__n128 *)(MEMORY[0x1E4F149A0] + 32);
  uint64_t v2 = (char *)objc_opt_new();
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v4 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v3, (uint64_t)&v16, (uint64_t)v20, 16);
  if (v4)
  {
    uint64_t v7 = v4;
    uint64_t v8 = *(void *)v17;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v17 != v8) {
          objc_enumerationMutation(a1);
        }
        sub_1B6464CF8(*(void **)(*((void *)&v16 + 1) + 8 * v9++), v2, v5, v6, v15, v14, v13, v12);
      }
      while (v7 != v9);
      uint64_t v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v10, (uint64_t)&v16, (uint64_t)v20, 16);
    }
    while (v7);
  }
  return v2;
}

uint64_t sub_1B6465028(void *a1, char *a2, uint64_t a3, uint64_t a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_transform(a1, a2, a3, a4))
  {
    __n128 v13 = objc_msgSend_transform(a1, v10, v11, v12);
    objc_msgSend_matrix(v13, v14, v15, v16);
    uint64_t v17 = 0;
    v52[0] = v18;
    v52[1] = v19;
    v52[2] = v20;
    v52[3] = v21;
    do
    {
      v53[v17] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a5, COERCE_FLOAT(v52[v17])), (float32x4_t)a6, *(float32x2_t *)&v52[v17], 1), (float32x4_t)a7, (float32x4_t)v52[v17], 2), (float32x4_t)a8, (float32x4_t)v52[v17], 3);
      ++v17;
    }
    while (v17 != 4);
    a5 = (__n128)v53[0];
    a6 = (__n128)v53[1];
    a7 = (__n128)v53[2];
    a8 = (__n128)v53[3];
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v25 = objc_alloc(MEMORY[0x1E4F35C48]);
    unint64_t v29 = objc_msgSend_initWithMatrix_(v25, v26, v27, v28, a5.n128_f64[0], a6.n128_f64[0], a7.n128_f64[0], a8.n128_f64[0]);
    objc_msgSend_setTransform_(a1, v30, (uint64_t)v29, v31);

    return objc_msgSend_addObject_(a2, v32, (uint64_t)a1, v33);
  }
  else
  {
    uint64_t result = objc_msgSend_children(a1, v22, v23, v24);
    if (result)
    {
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      uint64_t v38 = objc_msgSend_children(a1, v35, v36, v37);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v38, v39, (uint64_t)&v48, (uint64_t)v54, 16);
      if (result)
      {
        uint64_t v40 = result;
        uint64_t v41 = *(void *)v49;
        do
        {
          uint64_t v42 = 0;
          do
          {
            if (*(void *)v49 != v41) {
              objc_enumerationMutation(v38);
            }
            sub_1B6465028(*(void *)(*((void *)&v48 + 1) + 8 * v42++), a2, a5, a6, a7, a8);
          }
          while (v40 != v42);
          uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v38, v43, (uint64_t)&v48, (uint64_t)v54, 16);
          uint64_t v40 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

char *sub_1B6465234(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  __n128 v14 = *(__n128 *)(MEMORY[0x1E4F149A0] + 16);
  __n128 v15 = *(__n128 *)MEMORY[0x1E4F149A0];
  __n128 v12 = *(__n128 *)(MEMORY[0x1E4F149A0] + 48);
  __n128 v13 = *(__n128 *)(MEMORY[0x1E4F149A0] + 32);
  uint64_t v2 = (char *)objc_opt_new();
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v4 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v3, (uint64_t)&v16, (uint64_t)v20, 16);
  if (v4)
  {
    uint64_t v7 = v4;
    uint64_t v8 = *(void *)v17;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v17 != v8) {
          objc_enumerationMutation(a1);
        }
        sub_1B6465028(*(void **)(*((void *)&v16 + 1) + 8 * v9++), v2, v5, v6, v15, v14, v13, v12);
      }
      while (v7 != v9);
      uint64_t v7 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v10, (uint64_t)&v16, (uint64_t)v20, 16);
    }
    while (v7);
  }
  return v2;
}

BOOL sub_1B6465358(void *a1, char *a2, void *a3, uint64_t a4)
{
  v67[2] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = objc_msgSend_objectForKeyedSubscript_(a3, a2, @"kSceneSourcePreserveOriginalTopology", a4);
  if (v7) {
    uint64_t v11 = objc_msgSend_BOOLValue(v7, v8, v9, v10);
  }
  else {
    uint64_t v11 = sub_1B62C9214();
  }
  uint64_t v14 = v11;
  if (objc_msgSend_instancesRespondToSelector_(MEMORY[0x1E4F35BB0], v12, (uint64_t)sel_initThroughSCNKitBridgeWithURL_options_error_, v13))
  {
    v66[0] = *MEMORY[0x1E4F35B40];
    v66[1] = @"kMDLAssetDefaultUSDColorSpace";
    v67[0] = objc_msgSend_numberWithBool_(NSNumber, v15, v14, v16);
    v67[1] = sub_1B63C94EC();
    uint64_t v18 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v17, (uint64_t)v67, (uint64_t)v66, 2);
    id v19 = objc_alloc(MEMORY[0x1E4F35BB0]);
    uint64_t inited = objc_msgSend_initThroughSCNKitBridgeWithURL_options_error_(v19, v20, (uint64_t)a2, v18, 0);
  }
  else
  {
    id v24 = objc_alloc(MEMORY[0x1E4F35BB0]);
    uint64_t inited = objc_msgSend_initThroughSCNKitBridgeWithURL_preserveTopology_error_(v24, v25, (uint64_t)a2, v14, 0);
  }
  uint64_t v26 = (void *)inited;
  uint64_t v27 = objc_msgSend_valueForKey_(a3, v22, @"VFXWorldLoaderLoadTexturesInCPUMemory", v23);
  if (objc_msgSend_BOOLValue(v27, v28, v29, v30))
  {
    unint64_t v34 = objc_msgSend_pathExtension(a2, v31, v32, v33);
    uint64_t v38 = objc_msgSend_lowercaseString(v34, v35, v36, v37);
    if (objc_msgSend_isEqualToString_(v38, v39, @"usdz", v40)) {
      objc_msgSend_loadTextures(v26, v31, v32, v33);
    }
  }
  uint64_t v41 = objc_msgSend_currentThread(MEMORY[0x1E4F29060], v31, v32, v33);
  CFTypeRef v45 = objc_msgSend_threadDictionary(v41, v42, v43, v44);
  uint64_t v49 = objc_msgSend_resolver(v26, v46, v47, v48);
  objc_msgSend_setValue_forKey_(v45, v50, v49, @"VFX_MDLCurrentAssetResolver");
  if (v26)
  {
    uint64_t v54 = objc_msgSend_dictionary(MEMORY[0x1E4F1CA60], v51, v52, v53);
    objc_msgSend_loadMDLAsset_options_context_(a1, v55, (uint64_t)v26, (uint64_t)a3, v54);
    uint64_t v59 = objc_msgSend_currentThread(MEMORY[0x1E4F29060], v56, v57, v58);
    uint64_t v63 = objc_msgSend_threadDictionary(v59, v60, v61, v62);
    objc_msgSend_setValue_forKey_(v63, v64, 0, @"VFX_MDLCurrentAssetResolver");
  }
  return v26 != 0;
}

id VFXNodesToMDLAsset(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id result = objc_alloc_init(MEMORY[0x1E4F35BB0]);
  if (result)
  {
    uint64_t v4 = result;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t v5 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v3, (uint64_t)&v14, (uint64_t)v18, 16);
    if (v5)
    {
      uint64_t v8 = v5;
      uint64_t v9 = *(void *)v15;
      do
      {
        uint64_t v10 = 0;
        do
        {
          if (*(void *)v15 != v9) {
            objc_enumerationMutation(a1);
          }
          uint64_t v11 = objc_msgSend_objectWithVFXNode_(MEMORY[0x1E4F35BF8], v6, *(void *)(*((void *)&v14 + 1) + 8 * v10), v7);
          objc_msgSend_addObject_(v4, v12, v11, v13);
          ++v10;
        }
        while (v8 != v10);
        uint64_t v8 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v6, (uint64_t)&v14, (uint64_t)v18, 16);
      }
      while (v8);
    }
    return v4;
  }
  return result;
}

id sub_1B6465664(void *a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = objc_msgSend_jointPaths(a1, a2, a3, a4);
  uint64_t v6 = objc_opt_new();
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v8 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v7, (uint64_t)&v22, (uint64_t)v26, 16);
  if (v8)
  {
    uint64_t v11 = v8;
    uint64_t v12 = *(void *)v23;
    while (2)
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v23 != v12) {
          objc_enumerationMutation(v5);
        }
        uint64_t v14 = *(void *)(*((void *)&v22 + 1) + 8 * i);
        uint64_t v15 = objc_msgSend_objectForKeyedSubscript_(a2, v9, v14, v10);
        if (!v15)
        {
          NSLog(&cfstr_WhileCreatingV.isa, v14);
          objc_msgSend_removeAllObjects(v6, v18, v19, v20);
          return v6;
        }
        objc_msgSend_addObject_(v6, v16, v15, v17);
      }
      uint64_t v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v9, (uint64_t)&v22, (uint64_t)v26, 16);
      if (v11) {
        continue;
      }
      break;
    }
  }
  return v6;
}

id sub_1B64657A4(void *a1)
{
  uint64_t v2 = objc_opt_new();
  uint64_t v6 = objc_msgSend_jointBindTransforms(a1, v3, v4, v5);
  uint64_t v10 = objc_msgSend_bytes(v6, v7, v8, v9);
  uint64_t v14 = objc_msgSend_jointBindTransforms(a1, v11, v12, v13);
  unint64_t v18 = objc_msgSend_length(v14, v15, v16, v17);
  objc_msgSend_meshBindTransform(a1, v19, v20, v21);
  long long v38 = v23;
  long long v39 = v22;
  long long v36 = v25;
  long long v37 = v24;
  if (v18 >= 0x40)
  {
    uint64_t v26 = 0;
    unint64_t v27 = v18 >> 6;
    do
    {
      simd_float4x4 v46 = __invert_f4(*(simd_float4x4 *)(v10 + (v26 << 6)));
      uint64_t v31 = 0;
      v40[0] = v39;
      v40[1] = v38;
      v40[2] = v37;
      float32x4_t v40[3] = v36;
      do
      {
        *(long long *)((char *)&v41 + v31 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v46.columns[0], COERCE_FLOAT(v40[v31])), (float32x4_t)v46.columns[1], *(float32x2_t *)&v40[v31], 1), (float32x4_t)v46.columns[2], (float32x4_t)v40[v31], 2), (float32x4_t)v46.columns[3], (float32x4_t)v40[v31], 3);
        ++v31;
      }
      while (v31 != 4);
      uint64_t v32 = objc_msgSend_valueWithVFXMatrix4_(MEMORY[0x1E4F29238], v28, v29, v30, *(double *)&v41, *(double *)&v42, *(double *)&v43, *(double *)&v44);
      objc_msgSend_addObject_(v2, v33, v32, v34);
      ++v26;
    }
    while (v26 != v27);
  }

  return v2;
}

void *sub_1B64658CC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v5 = *(double **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v6 = v4 - *(void *)a2;
  if (v4 == *(void *)a2) {
    return 0;
  }
  double v7 = *v5;
  double v8 = *(double *)(v4 - 8) - *v5;
  if (v8 < 2.22044605e-16) {
    return 0;
  }
  unint64_t v13 = v6 >> 3;
  uint64_t v14 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], (const char *)a2, v6 >> 3, a4);
  uint64_t v20 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], v15, v13, v16);
  uint64_t v21 = 0;
  if (v13 <= 1) {
    uint64_t v22 = 1;
  }
  else {
    uint64_t v22 = v13;
  }
  do
  {
    uint64_t v23 = objc_msgSend_numberWithDouble_(NSNumber, v17, v18, v19, (*(double *)(*(void *)a2 + 8 * v21) - v7) / v8);
    LODWORD(v24) = *(_DWORD *)(*a3 + 4 * v21);
    uint64_t v28 = objc_msgSend_numberWithFloat_(NSNumber, v25, v26, v27, v24);
    objc_msgSend_addObject_(v14, v29, v23, v30);
    objc_msgSend_addObject_(v20, v31, v28, v32);
    ++v21;
  }
  while (v22 != v21);
  uint64_t v9 = objc_msgSend_animationWithKeyPath_(MEMORY[0x1E4F39BD8], v17, a1, v19);
  objc_msgSend_setValues_(v9, v33, (uint64_t)v20, v34);
  objc_msgSend_setKeyTimes_(v9, v35, (uint64_t)v14, v36);
  objc_msgSend_setDuration_(v9, v37, v38, v39, v8);
  objc_msgSend_setBeginTime_(v9, v40, v41, v42, v7);
  objc_msgSend_setAdditive_(v9, v43, 0, v44);
  objc_msgSend_setRemovedOnCompletion_(v9, v45, 0, v46);
  return v9;
}

id sub_1B6465A34(void *a1)
{
  uint64_t v2 = objc_opt_new();
  unint64_t v3 = objc_opt_new();
  double v7 = objc_msgSend_shapeSetTargetCounts(a1, v4, v5, v6);
  uint64_t v11 = objc_msgSend_count(v7, v8, v9, v10);
  uint64_t v15 = objc_msgSend_targetShapes(a1, v12, v13, v14);
  uint64_t v19 = objc_msgSend_count(v15, v16, v17, v18);
  if (v19)
  {
    uint64_t v23 = v19;
    for (uint64_t i = 0; i != v23; ++i)
    {
      long long v25 = objc_msgSend_targetShapes(a1, v20, v21, v22);
      uint64_t v28 = objc_msgSend_objectAtIndexedSubscript_(v25, v26, i, v27);
      uint64_t v31 = objc_msgSend_modelWithMDLMesh_(VFXModel, v29, (uint64_t)v28, v30);
      uint64_t v35 = objc_msgSend_name(v28, v32, v33, v34);
      objc_msgSend_setName_(v31, v36, v35, v37);
      objc_msgSend_setEdgeCreasesSource_(v31, v38, 0, v39);
      objc_msgSend_setEdgeCreasesElement_(v31, v40, 0, v41);
      uint64_t v45 = objc_msgSend_mesh(v31, v42, v43, v44);
      objc_msgSend_addObject_(v3, v46, v45, v47);
    }
  }
  if (v11)
  {
    uint64_t v131 = (uint64_t)v3;
    id v48 = objc_alloc(MEMORY[0x1E4F1CA48]);
    uint64_t v54 = objc_msgSend_initWithCapacity_(v48, v49, 0, v50);
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    do
    {
      uint64_t v57 = objc_msgSend_shapeSetTargetCounts(a1, v51, v52, v53);
      uint64_t v60 = objc_msgSend_objectAtIndexedSubscript_(v57, v58, v55, v59);
      uint64_t v64 = objc_msgSend_unsignedIntegerValue(v60, v61, v62, v63);
      uint64_t v65 = v64 - 1;
      if (v64 != 1)
      {
        uint64_t v66 = v65 + v56;
        do
        {
          uint64_t v67 = objc_msgSend_shapeSetTargetWeights(a1, v51, v52, v53);
          uint64_t v70 = objc_msgSend_objectAtIndexedSubscript_(v67, v68, v56, v69);
          objc_msgSend_addObject_(v54, v71, (uint64_t)v70, v72);
          objc_msgSend_floatValue(v70, v73, v74, v75);
          if (v76 >= 1.0)
          {
            objc_msgSend_floatValue(v70, v51, v52, v53);
            sub_1B63F2F54(17, @"Assertion '%s' failed. Found in-between morph target with influence weight of %f", v77, v78, v79, v80, v81, v82, (uint64_t)"influenceWeightNumber.floatValue < 1.f");
          }
          ++v56;
          --v65;
        }
        while (v65);
        uint64_t v56 = v66;
      }
      ++v56;
      ++v55;
    }
    while (v55 != v11);
    uint64_t v83 = objc_msgSend_shapeSetTargetCounts(a1, v51, v52, v53);
    unint64_t v3 = (void *)v131;
    objc_msgSend_setTargets_withInBetweenTargetCounts_inBetweenWeights_(v2, v84, v131, v83, v54);
  }
  else
  {
    objc_msgSend_setTargets_(v2, v20, (uint64_t)v3, v22);
  }
  uint64_t v88 = objc_msgSend_weights(a1, v85, v86, v87);
  unint64_t v92 = objc_msgSend_elementCount(v88, v89, v90, v91);
  uint64_t v133 = 0;
  uint64_t v134 = 0;
  __p = 0;
  if (v92)
  {
    unint64_t v96 = v92;
    sub_1B646FFA4(&__p, v92);
    uint64_t v97 = (char *)v133;
    bzero(v133, 4 * v96);
    uint64_t v133 = &v97[4 * v96];
  }
  simd_float4 v98 = objc_msgSend_keyTimes(v88, v93, v94, v95);
  if (objc_msgSend_count(v98, v99, v100, v101))
  {
    float32x4_t v105 = __p;
    uint64_t v106 = objc_msgSend_elementCount(v88, v102, v103, v104);
    float32x4_t v110 = objc_msgSend_keyTimes(v88, v107, v108, v109);
    long long v113 = objc_msgSend_objectAtIndexedSubscript_(v110, v111, 0, v112);
    objc_msgSend_doubleValue(v113, v114, v115, v116);
    objc_msgSend_getFloatArray_maxCount_atTime_(v88, v117, (uint64_t)v105, v106);
  }
  uint64_t v118 = v3;
  long long v122 = objc_opt_new();
  long long v124 = __p;
  long long v125 = v133;
  if (__p != v133)
  {
    do
    {
      LODWORD(v123) = *v124;
      uint64_t v126 = objc_msgSend_numberWithFloat_(NSNumber, v119, v120, v121, v123);
      objc_msgSend_addObject_(v122, v127, v126, v128);
      ++v124;
    }
    while (v124 != v125);
  }
  objc_msgSend_setWeights_(v2, v119, (uint64_t)v122, v121);

  id v129 = v2;
  if (__p)
  {
    uint64_t v133 = __p;
    operator delete(__p);
  }
  return v129;
}

void sub_1B6465D44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B6465D68(void *a1, void *a2, void *a3, uint64_t a4)
{
  if (objc_msgSend_morpher(a2, (const char *)a2, (uint64_t)a3, a4))
  {
    double v8 = objc_msgSend_weights(a1, v5, v6, v7);
    if (objc_msgSend_isAnimated(v8, v9, v10, v11))
    {
      uint64_t v15 = objc_msgSend_timeSampleCount(v8, v12, v13, v14);
      uint64_t v20 = objc_msgSend_elementCount(v8, v16, v17, v18);
      uint64_t v66 = 0;
      uint64_t v67 = 0;
      uint64_t v68 = 0;
      if (v15)
      {
        sub_1B646FFE4(&v66, v15);
        uint64_t v21 = (char *)v67;
        bzero(v67, 8 * v15);
        uint64_t v67 = &v21[8 * v15];
        objc_msgSend_getTimes_maxCount_(v8, v22, (uint64_t)v66, v15);
      }
      else
      {
        objc_msgSend_getTimes_maxCount_(v8, v19, 0, 0);
      }
      uint64_t v25 = v20 * v15;
      uint64_t v63 = 0;
      uint64_t v64 = 0;
      uint64_t v65 = 0;
      if (v20 * v15)
      {
        sub_1B646FFA4(&v63, v20 * v15);
        uint64_t v26 = (char *)v64;
        bzero(v64, 4 * v25);
        uint64_t v64 = &v26[4 * v25];
      }
      if (v20) {
        objc_msgSend_getFloatArray_maxCount_(v8, v23, (uint64_t)v63, v20 * v15);
      }
      __p = 0;
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      if (v15)
      {
        sub_1B646FFA4(&__p, v15);
        uint64_t v27 = (char *)v61;
        bzero(v61, 4 * v15);
        uint64_t v61 = &v27[4 * v15];
      }
      if (v20)
      {
        uint64_t v28 = 0;
        for (uint64_t i = 0; i != v20; ++i)
        {
          if (v15)
          {
            uint64_t v30 = __p;
            uint64_t v31 = (char *)v63 + v28;
            uint64_t v32 = v15;
            do
            {
              *v30++ = *v31;
              v31 += v20;
              --v32;
            }
            while (v32);
          }
          uint64_t v33 = objc_msgSend_stringWithFormat_(NSString, v23, @"morpher.weights[%d]", v24, i);
          uint64_t v35 = sub_1B64658CC(v33, (uint64_t)&v66, &__p, v34);
          uint64_t v37 = v35;
          if (v35)
          {
            objc_msgSend_duration(v35, v23, v36, v24);
            if (v38 != 0.0)
            {
              uint64_t v39 = objc_msgSend_valueForKey_(a3, v23, @"kSceneSourceAnimationLoadingMode", v24);
              uint64_t v44 = v39;
              if (v39)
              {
                int isEqualToString = objc_msgSend_isEqualToString_(v39, v40, @"playRepeatedly", v42);
                LODWORD(v49) = 2139095040;
                if (!isEqualToString) {
                  *(float *)&double v49 = 0.0;
                }
                objc_msgSend_setRepeatCount_(v37, v46, v47, v48, v49);
                uint64_t v52 = objc_msgSend_isEqualToString_(v44, v50, @"playRepeatedly", v51) ^ 1;
                objc_msgSend_setRemovedOnCompletion_(v37, v53, v52, v54);
              }
              else
              {
                LODWORD(v43) = 2139095040;
                objc_msgSend_setRepeatCount_(v37, v40, v41, v42, v43);
                objc_msgSend_setRemovedOnCompletion_(v37, v56, 0, v57);
              }
              objc_msgSend_addAnimation_forKey_(a2, v55, (uint64_t)v37, 0);
            }
          }
          v28 += 4;
        }
      }
      if (__p)
      {
        uint64_t v61 = __p;
        operator delete(__p);
      }
      if (v63)
      {
        uint64_t v64 = v63;
        operator delete(v63);
      }
      if (v66)
      {
        uint64_t v67 = v66;
        operator delete(v66);
      }
    }
  }
}

void sub_1B6466004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B6466BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59)
{
}

void sub_1B6466C1C(void *a1, char *a2, uint64_t a3, void *a4, uint64_t **a5)
{
  uint64_t v5 = (void *)a3;
  uint64_t v229 = *MEMORY[0x1E4F143B8];
  long long v210 = 0u;
  long long v211 = 0u;
  long long v212 = 0u;
  long long v213 = 0u;
  uint64_t v7 = objc_msgSend_children(a1, a2, a3, (uint64_t)a4);
  uint64_t v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v7, v8, (uint64_t)&v210, (uint64_t)v226, 16);
  if (v11)
  {
    uint64_t v12 = *(void *)v211;
    do
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v211 != v12) {
          objc_enumerationMutation(v7);
        }
        sub_1B6466C1C(*(void *)(*((void *)&v210 + 1) + 8 * i), a2, v5, a4, a5);
      }
      uint64_t v11 = objc_msgSend_countByEnumeratingWithState_objects_count_(v7, v14, (uint64_t)&v210, (uint64_t)v226, 16);
    }
    while (v11);
  }
  uint64_t v18 = objc_msgSend_componentConformingToProtocol_(a1, v9, (uint64_t)&unk_1F1080AB8, v10);
  if (v18)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v19 = (void *)v18;
    }
    else {
      uint64_t v19 = 0;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  uint64_t v23 = (uint64_t *)sub_1B6470220(a1, v15, v16, v17);
  uint64_t v209 = v23;
  if (v23)
  {
    uint64_t v24 = objc_opt_new();
    __p = 0;
    id v207 = 0;
    uint64_t v208 = 0;
    sub_1B6470290(a1, MEMORY[0x1E4F149A0], v24, &__p);
    if (objc_msgSend_count(v24, v25, v26, v27))
    {
      uint64_t v190 = sub_1B6470540(a5, &v209)[1];
      uint64_t v28 = (void *)MEMORY[0x1E4F1CA48];
      uint64_t v32 = objc_msgSend_jointPaths(v23, v29, v30, v31);
      uint64_t v36 = objc_msgSend_count(v32, v33, v34, v35);
      uint64_t v191 = objc_msgSend_arrayWithCapacity_(v28, v37, v36, v38);
      uint64_t v42 = (uint64_t *)objc_msgSend_skeleton(v19, v39, v40, v41);
      float32x4_t v222 = v42;
      double v43 = (void **)sub_1B6470540(a5, &v222);
      if (objc_msgSend_jointPaths(v19, v44, v45, v46)) {
        uint64_t v50 = objc_msgSend_jointPaths(v19, v47, v48, v49);
      }
      else {
        uint64_t v50 = objc_msgSend_jointPaths(v42, v47, v48, v49);
      }
      uint64_t v52 = v50;
      long long v220 = 0u;
      long long v221 = 0u;
      long long v218 = 0u;
      long long v219 = 0u;
      uint64_t v55 = objc_msgSend_countByEnumeratingWithState_objects_count_(v50, v51, (uint64_t)&v218, (uint64_t)v228, 16);
      obuint64_t j = v24;
      uint64_t v188 = v19;
      uint64_t v186 = v5;
      uint64_t v56 = 0;
      if (v55)
      {
        uint64_t v57 = *(void *)v219;
        do
        {
          for (uint64_t j = 0; j != v55; ++j)
          {
            if (*(void *)v219 != v57) {
              objc_enumerationMutation(v52);
            }
            uint64_t v59 = *(void *)(*((void *)&v218 + 1) + 8 * j);
            uint64_t v61 = objc_msgSend_objectForKeyedSubscript_(*v43, v53, v59, v54);
            if (v61)
            {
              objc_msgSend_addObject_(v191, v60, v61, v62);
            }
            else
            {
              if (!v56)
              {
                id v63 = objc_alloc(MEMORY[0x1E4F1CA48]);
                uint64_t v67 = objc_msgSend_count(v52, v64, v65, v66);
                uint64_t v56 = objc_msgSend_initWithCapacity_(v63, v68, v67, v69);
              }
              objc_msgSend_addObject_(v56, v60, v59, v62);
            }
          }
          uint64_t v55 = objc_msgSend_countByEnumeratingWithState_objects_count_(v52, v53, (uint64_t)&v218, (uint64_t)v228, 16);
        }
        while (v55);
        if (v56)
        {
          uint64_t v5 = v186;
          uint64_t v24 = obj;
          uint64_t v19 = v188;
          if (objc_msgSend_count(v56, v53, v70, v54))
          {
            long long v216 = 0u;
            long long v217 = 0u;
            long long v214 = 0u;
            long long v215 = 0u;
            uint64_t v72 = objc_msgSend_countByEnumeratingWithState_objects_count_(v56, v71, (uint64_t)&v214, (uint64_t)v227, 16);
            if (v72)
            {
              uint64_t v73 = *(void *)v215;
              do
              {
                for (uint64_t k = 0; k != v72; ++k)
                {
                  if (*(void *)v215 != v73) {
                    objc_enumerationMutation(v56);
                  }
                  NSLog(&cfstr_BadJointPathDe.isa, *(void *)(*((void *)&v214 + 1) + 8 * k));
                }
                uint64_t v72 = objc_msgSend_countByEnumeratingWithState_objects_count_(v56, v75, (uint64_t)&v214, (uint64_t)v227, 16);
              }
              while (v72);
            }
          }
        }
        else
        {
          uint64_t v5 = v186;
          uint64_t v24 = obj;
          uint64_t v19 = v188;
        }
      }

      uint64_t v79 = sub_1B6470610(v19, v76, v77, v78);
      long long v204 = 0u;
      long long v205 = 0u;
      long long v202 = 0u;
      long long v203 = 0u;
      uint64_t v84 = objc_msgSend_countByEnumeratingWithState_objects_count_(v24, v80, (uint64_t)&v202, (uint64_t)v225, 16);
      if (v84)
      {
        uint64_t v85 = *(void *)v203;
        do
        {
          for (uint64_t m = 0; m != v84; ++m)
          {
            if (*(void *)v203 != v85) {
              objc_enumerationMutation(obj);
            }
            uint64_t v87 = *(void **)(*((void *)&v202 + 1) + 8 * m);
            uint64_t v88 = objc_msgSend_path(v87, v81, v82, v83);
            uint64_t v91 = objc_msgSend_objectForKeyedSubscript_(a2, v89, v88, v90);
            uint64_t v95 = objc_msgSend_model(v91, v92, v93, v94);
            uint64_t v99 = objc_msgSend_mesh(v95, v96, v97, v98);
            uint64_t v103 = sub_1B646B964(v87, v100, v101, v102);
            uint64_t v107 = sub_1B646BA10(v87, v104, v105, v106);
            uint64_t v109 = objc_msgSend_skinnerWithBaseMesh_bones_boneInverseBindTransforms_boneWeights_boneIndices_(VFXSkinner, v108, v99, (uint64_t)v191, v79, v103, v107);
            uint64_t v112 = objc_msgSend_componentConformingToProtocol_(v87, v110, (uint64_t)&unk_1F1080AB8, v111);
            if (v87 != a1 && (uint64_t v116 = (void *)v112) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
            {
              objc_msgSend_geometryBindTransform(v116, v113, v114, v115);
              double v117 = sub_1B647080C(v228);
              objc_msgSend_setBaseMeshBindTransform_(v109, v118, v119, v120, v117);
            }
            else
            {
              if (v188) {
                objc_msgSend_geometryBindTransform(v188, v113, v114, v115);
              }
              else {
                memset(v228, 0, sizeof(v228));
              }
              double v123 = sub_1B647080C(v228);
              objc_msgSend_setBaseMeshBindTransform_(v109, v124, v125, v126, v123);
            }
            objc_msgSend_setSkeleton_(v109, v121, (uint64_t)v190, v122);
            objc_msgSend_setSkinner_(v91, v127, (uint64_t)v109, v128);
          }
          uint64_t v24 = obj;
          uint64_t v84 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v81, (uint64_t)&v202, (uint64_t)v225, 16);
        }
        while (v84);
        uint64_t v5 = v186;
        uint64_t v19 = v188;
      }
    }
    else
    {
      uint64_t v190 = 0;
    }

    if (__p)
    {
      id v207 = __p;
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v190 = 0;
  }
  if (v19)
  {
    id v129 = objc_msgSend_jointAnimation(v19, v20, v21, v22);
    if (v129)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        if (!v190)
        {
          uint64_t v133 = objc_msgSend_path(a1, v130, v131, v132);
          uint64_t v190 = (uint64_t *)objc_msgSend_objectForKeyedSubscript_(a2, v134, v133, v135);
        }
        uint64_t v136 = objc_msgSend_name(v129, v130, v131, v132);
        uint64_t v142 = objc_msgSend_objectForKeyedSubscript_(a4, v137, v136, v138);
        if (v142)
        {
          uint64_t v143 = objc_msgSend_name(v129, v139, v140, v141);
          objc_msgSend_addAnimation_forKey_(v190, v144, v142, v143);
          char v145 = 1;
        }
        else
        {
          char v145 = 0;
        }
        long long v200 = 0u;
        long long v201 = 0u;
        long long v198 = 0u;
        long long v199 = 0u;
        long long v146 = objc_msgSend_animations(v5, v139, v140, v141);
        uint64_t v149 = objc_msgSend_countByEnumeratingWithState_objects_count_(v146, v147, (uint64_t)&v198, (uint64_t)v224, 16);
        if (v149)
        {
          uint64_t v150 = *(void *)v199;
          do
          {
            for (uint64_t n = 0; n != v149; ++n)
            {
              if (*(void *)v199 != v150) {
                objc_enumerationMutation(v146);
              }
              uint64_t v152 = *(void **)(*((void *)&v198 + 1) + 8 * n);
              if (v152 != v129)
              {
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  uint64_t v155 = (void *)sub_1B6470840(v129, v148, v153, v154);
                  uint64_t v159 = sub_1B6470840(v152, v156, v157, v158);
                  if (v155)
                  {
                    if (v159)
                    {
                      if (objc_msgSend_isEqualToString_(v155, v148, v159, v160))
                      {
                        uint64_t v163 = objc_msgSend_name(v152, v148, v161, v162);
                        uint64_t v168 = objc_msgSend_objectForKeyedSubscript_(a4, v164, v163, v165);
                        if (v168)
                        {
                          uint64_t v169 = objc_msgSend_name(v152, v148, v166, v167);
                          objc_msgSend_addAnimation_forKey_(v190, v170, v168, v169);
                          char v145 = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
            uint64_t v149 = objc_msgSend_countByEnumeratingWithState_objects_count_(v146, v148, (uint64_t)&v198, (uint64_t)v224, 16);
          }
          while (v149);
        }
        uint64_t v171 = v209;
        if (v209)
        {
          if (v145)
          {
            uint64_t v172 = (void **)sub_1B6470540(a5, &v209);
            long long v196 = 0u;
            long long v197 = 0u;
            long long v194 = 0u;
            long long v195 = 0u;
            long long v176 = objc_msgSend_jointPaths(v171, v173, v174, v175);
            uint64_t v180 = objc_msgSend_countByEnumeratingWithState_objects_count_(v176, v177, (uint64_t)&v194, (uint64_t)v223, 16);
            if (v180)
            {
              uint64_t v181 = *(void *)v195;
              uint64_t v182 = (double *)MEMORY[0x1E4F149A0];
              do
              {
                for (iuint64_t i = 0; ii != v180; ++ii)
                {
                  if (*(void *)v195 != v181) {
                    objc_enumerationMutation(v176);
                  }
                  uint64_t v184 = objc_msgSend_objectForKeyedSubscript_(*v172, v178, *(void *)(*((void *)&v194 + 1) + 8 * ii), v179);
                  if (v184) {
                    objc_msgSend_setTransform_(v184, v178, v185, v179, *v182, v182[2], v182[4], v182[6]);
                  }
                }
                uint64_t v180 = objc_msgSend_countByEnumeratingWithState_objects_count_(v176, v178, (uint64_t)&v194, (uint64_t)v223, 16);
              }
              while (v180);
            }
          }
        }
      }
    }
  }
}

void sub_1B64673D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B646748C(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  if (!a3 || !objc_msgSend_rootNode(a3, a2, (uint64_t)a3, a4)) {
    return 0;
  }
  uint64_t v9 = objc_msgSend_rootNode(a3, v6, v7, v8);

  return MEMORY[0x1F4181798](a1, sel_assetWithVFXNode_, v9, v10);
}

uint64_t sub_1B64674F0(uint64_t a1, const char *a2, void *a3, uint64_t a4)
{
  if (!a3 || !objc_msgSend_rootNode(a3, a2, (uint64_t)a3, a4)) {
    return 0;
  }
  uint64_t v10 = objc_msgSend_rootNode(a3, v7, v8, v9);

  return MEMORY[0x1F4181798](a1, sel_assetWithVFXNode_bufferAllocator_, v10, a4);
}

uint64_t sub_1B6467568(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    return MEMORY[0x1F4181798](a1, sel_assetWithVFXNode_bufferAllocator_, a3, 0);
  }
  else {
    return 0;
  }
}

id sub_1B646757C(objc_class *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    return 0;
  }
  id v6 = [a1 alloc];
  uint64_t v9 = objc_msgSend_initWithBufferAllocator_(v6, v7, a4, v8);
  uint64_t v11 = objc_msgSend_objectWithVFXNode_bufferAllocator_(MEMORY[0x1E4F35BF8], v10, a3, a4);
  objc_msgSend_addObject_(v9, v12, v11, v13);

  return v9;
}

uint64_t sub_1B64675F8(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_objectWithVFXNode_bufferAllocator_(a1, a2, a3, 0);
}

id sub_1B6467600(objc_class *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  id v6 = objc_alloc_init(a1);
  uint64_t v7 = objc_opt_new();
  objc_msgSend_setTransform_(v6, v8, (uint64_t)v7, v9);

  objc_msgSend_transform(a3, v10, v11, v12);
  double v70 = v14;
  double v71 = v13;
  double v68 = v16;
  double v69 = v15;
  uint64_t v20 = objc_msgSend_transform(v6, v17, v18, v19);
  objc_msgSend_setMatrix_(v20, v21, v22, v23, v71, v70, v69, v68);
  uint64_t v27 = objc_msgSend_name(a3, v24, v25, v26);
  objc_msgSend_setName_(v6, v28, v27, v29);
  objc_setAssociatedObject(v6, @"VFXMDLAssociatedObject", a3, (void *)0x301);
  objc_setAssociatedObject(a3, @"VFXMDLAssociatedObject", v6, 0);
  uint64_t v33 = objc_msgSend_camera(a3, v30, v31, v32);
  if (v33)
  {
    uint64_t v37 = objc_msgSend_cameraWithVFXCamera_(MEMORY[0x1E4F35BB8], v34, v33, v36);
    objc_msgSend_addChild_(v6, v38, v37, v39);
  }
  uint64_t v40 = objc_msgSend_light(a3, v34, v35, v36);
  if (v40)
  {
    uint64_t v44 = (uint64_t)v40;
    if (objc_msgSend_type(v40, v41, v42, v43) == 4) {
      uint64_t v47 = objc_msgSend_lightProbeWithVFXLight_node_(MEMORY[0x1E4F35BC8], v45, v44, (uint64_t)a3);
    }
    else {
      uint64_t v47 = objc_msgSend_lightWithVFXLight_(MEMORY[0x1E4F35BC0], v45, v44, v46);
    }
    objc_msgSend_addChild_(v6, v48, v47, v49);
  }
  uint64_t v50 = objc_msgSend_model(a3, v41, v42, v43);
  if (v50)
  {
    uint64_t v54 = objc_msgSend_meshWithVFXModel_bufferAllocator_(MEMORY[0x1E4F35BE0], v51, v50, a4);
    objc_msgSend_addChild_(v6, v55, v54, v56);
  }
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  uint64_t v57 = objc_msgSend_childNodes(a3, v51, v52, v53);
  uint64_t v59 = objc_msgSend_countByEnumeratingWithState_objects_count_(v57, v58, (uint64_t)&v72, (uint64_t)v76, 16);
  if (v59)
  {
    uint64_t v61 = v59;
    uint64_t v62 = *(void *)v73;
    do
    {
      uint64_t v63 = 0;
      do
      {
        if (*(void *)v73 != v62) {
          objc_enumerationMutation(v57);
        }
        uint64_t v64 = objc_msgSend_objectWithVFXNode_bufferAllocator_(MEMORY[0x1E4F35BF8], v60, *(void *)(*((void *)&v72 + 1) + 8 * v63), a4);
        objc_msgSend_addChild_(v6, v65, v64, v66);
        ++v63;
      }
      while (v61 != v63);
      uint64_t v61 = objc_msgSend_countByEnumeratingWithState_objects_count_(v57, v60, (uint64_t)&v72, (uint64_t)v76, 16);
    }
    while (v61);
  }
  return v6;
}

void sub_1B646784C()
{
}

id sub_1B6467E74(void *a1, uint64_t a2, char **a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
  id v7 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  if (objc_msgSend_count(a1, v8, v9, v10))
  {
    char v13 = 0;
    int v14 = 0;
    unint64_t v15 = 0;
    do
    {
      double v16 = objc_msgSend_objectAtIndexedSubscript_(a1, v11, v15, v12);
      if (objc_msgSend_indicesChannelCount(v16, v17, v18, v19) >= 2)
      {
        *a5 = objc_msgSend_indicesChannelCount(v16, v20, v21, v22);
        char v13 = 1;
      }
      uint64_t v23 = objc_msgSend_data(v16, v20, v21, v22);
      unint64_t v27 = objc_msgSend_length(v23, v24, v25, v26);
      v14 += v27 / objc_msgSend_bytesPerIndex(v16, v28, v29, v30);
      ++v15;
    }
    while (v15 < objc_msgSend_count(a1, v31, v32, v33));
    if (v13)
    {
      int v100 = -1;
      sub_1B64680DC(a3, v14, &v100);
      if (objc_msgSend_count(a1, v34, v35, v36))
      {
        uint64_t v39 = objc_msgSend_objectAtIndexedSubscript_(a1, v37, 0, v38);
        objc_msgSend_hasInterleavedIndicesChannels(v39, v40, v41, v42);
        unint64_t v46 = objc_msgSend_indicesChannelCount(v39, v43, v44, v45);
        unint64_t v50 = objc_msgSend_bytesPerIndex(v39, v47, v48, v49);
        uint64_t v54 = objc_msgSend_primitiveCount(v39, v51, v52, v53);
        uint64_t v58 = objc_msgSend_data(v39, v55, v56, v57);
        objc_msgSend_bytes(v58, v59, v60, v61);
        uint64_t v65 = objc_msgSend_data(v39, v62, v63, v64);
        unint64_t v69 = objc_msgSend_length(v65, v66, v67, v68);
        if (objc_msgSend_primitiveType(v39, v70, v71, v72) == 1 || objc_msgSend_primitiveType(v39, v73, v74, v75) != 4)
        {
          uint64_t v94 = objc_msgSend_data(v39, v73, v74, v75);
          objc_msgSend_bytes(v94, v95, v96, v97);
        }
        else
        {
          uint64_t v76 = v54 * v50;
          uint64_t v77 = objc_msgSend_data(v39, v73, v74, v75);
          uint64_t v81 = objc_msgSend_data(v39, v78, v79, v80);
          uint64_t v85 = objc_msgSend_length(v81, v82, v83, v84);
          uint64_t v87 = objc_msgSend_subdataWithRange_(v77, v86, v76, v85 - v76);
          objc_msgSend_bytes(v87, v88, v89, v90);
          unint64_t v69 = objc_msgSend_length(v87, v91, v92, v93);
        }
        malloc_type_malloc((v69 / v50) / v46 * v50, 0xC11D35D3uLL);
        sub_1B646784C();
      }
    }
  }
  return v7;
}

char *sub_1B64680DC(char **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  id result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 2)
  {
    char v13 = a1[1];
    unint64_t v14 = (v13 - result) >> 2;
    if (v14 >= a2) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = (v13 - result) >> 2;
    }
    if (v15)
    {
      double v16 = result;
      do
      {
        *(_DWORD *)double v16 = *a3;
        v16 += 4;
        --v15;
      }
      while (v15);
    }
    if (a2 <= v14)
    {
      a1[1] = &result[4 * a2];
    }
    else
    {
      uint64_t v17 = &v13[4 * (a2 - v14)];
      uint64_t v18 = 4 * a2 - 4 * v14;
      do
      {
        *(_DWORD *)char v13 = *a3;
        v13 += 4;
        v18 -= 4;
      }
      while (v18);
      a1[1] = v17;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 >> 62) {
      abort();
    }
    uint64_t v8 = v6 >> 1;
    if (v6 >> 1 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    id result = sub_1B646FFA4(a1, v9);
    uint64_t v10 = a1[1];
    uint64_t v11 = &v10[4 * a2];
    uint64_t v12 = 4 * a2;
    do
    {
      *(_DWORD *)uint64_t v10 = *a3;
      v10 += 4;
      v12 -= 4;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

uint64_t sub_1B64681EC(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_meshWithVFXModel_bufferAllocator_(a1, a2, a3, 0);
}

uint64_t sub_1B64681F4(void *a1, const char *a2, void *a3, void *a4, int a5, int a6, int a7, char *a8)
{
  int v44 = (int)a2;
  int v11 = objc_msgSend_dataStride(a1, a2, (uint64_t)a3, (uint64_t)a4);
  uint64_t result = objc_msgSend_dataOffset(a1, v12, v13, v14);
  uint64_t v19 = (int)result;
  int v41 = a6;
  if (a6 >= 1)
  {
    uint64_t v20 = 0;
    int v21 = v44 - 1;
    uint64_t v22 = a8;
    do
    {
      if (v44) {
        int v23 = *(_DWORD *)(*a3 + 4 * v21);
      }
      else {
        int v23 = v20;
      }
      uint64_t v24 = objc_msgSend_data(a1, v16, v17, v18);
      uint64_t v28 = objc_msgSend_bytes(v24, v25, v26, v27);
      uint64_t result = (uint64_t)memcpy(v22, (const void *)(v28 + v19 + (v23 * v11)), v11);
      ++v20;
      v22 += v11;
      v21 += a5;
    }
    while (v41 != v20);
  }
  if (a7 >= 1)
  {
    uint64_t v29 = a7;
    uint64_t v30 = &a8[v11 * (uint64_t)v41];
    uint64_t v31 = 4 * v44;
    uint64_t v32 = 4 * (a5 + 1);
    do
    {
      int v33 = *(_DWORD *)(*a4 + v31);
      uint64_t v34 = objc_msgSend_data(a1, v16, v17, v18);
      uint64_t v38 = objc_msgSend_bytes(v34, v35, v36, v37);
      uint64_t result = (uint64_t)memcpy(v30, (const void *)(v38 + v19 + (v33 * v11)), v11);
      v30 += v11;
      v31 += v32;
      --v29;
    }
    while (v29);
  }
  return result;
}

id sub_1B6468350(objc_class *a1, uint64_t a2, void *a3, uint64_t a4)
{
  v680 = a1;
  uint64_t v747 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = objc_opt_class();
  id value = a3;
  if ((objc_msgSend_isMemberOfClass_(a3, v6, v5, v7) & 1) == 0) {
    objc_msgSend_flush(VFXTransaction, v8, v9, v10);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAD68, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDAD68))
  {
    qword_1E9DDAD60 = objc_opt_new();
    __cxa_guard_release(&qword_1E9DDAD68);
  }
  uint64_t v11 = qword_1E9DDAD60;
  if (a4) {
    uint64_t v11 = a4;
  }
  v706 = (void *)v11;
  v741 = 0;
  __p = 0;
  v742 = 0;
  v738 = 0;
  v737 = 0;
  v739 = 0;
  v735 = 0;
  v734 = 0;
  v736 = 0;
  v731 = 0;
  v732 = 0;
  v733 = 0;
  v683 = objc_msgSend_mesh(a3, v8, v9, v10);
  uint64_t v15 = objc_msgSend_meshSources(v683, v12, v13, v14);
  uint64_t v19 = objc_msgSend_modelSourceChannels(a3, v16, v17, v18);
  unint64_t v26 = objc_msgSend_count(v19, v20, v21, v22);
  if (v26)
  {
    unint64_t v27 = 0;
    int v705 = 0;
    while (v27 < objc_msgSend_count(v15, (const char *)v23, v24, v25) && v27 < v26)
    {
      uint64_t v30 = objc_msgSend_objectAtIndexedSubscript_(v15, v28, v27, v29);
      uint64_t v34 = objc_msgSend_modelSourceChannels(a3, v31, v32, v33);
      uint64_t v37 = objc_msgSend_objectAtIndexedSubscript_(v34, v35, v27, v36);
      int v41 = objc_msgSend_unsignedIntegerValue(v37, v38, v39, v40);
      uint64_t v45 = objc_msgSend_semantic(v30, v42, v43, v44);
      if (objc_msgSend_isEqualToString_(v45, v46, @"kGeometrySourceSemanticPosition", v47))
      {
        uint64_t v48 = v741;
        if (v741 >= v742)
        {
          uint64_t v55 = (char *)__p;
          uint64_t v56 = (v741 - (unsigned char *)__p) >> 2;
          unint64_t v57 = v56 + 1;
          if ((unint64_t)(v56 + 1) >> 62) {
            goto LABEL_203;
          }
          uint64_t v58 = v742 - (unsigned char *)__p;
          if ((v742 - (unsigned char *)__p) >> 1 > v57) {
            unint64_t v57 = v58 >> 1;
          }
          if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v23 = v57;
          }
          if (v23)
          {
            uint64_t v59 = (char *)sub_1B64282E0((uint64_t)&v742, v23);
            uint64_t v48 = v741;
            uint64_t v55 = (char *)__p;
          }
          else
          {
            uint64_t v59 = 0;
          }
          uint64_t v75 = &v59[4 * v56];
          *(_DWORD *)uint64_t v75 = v41;
          uint64_t v49 = v75 + 4;
          while (v48 != v55)
          {
            int v76 = *((_DWORD *)v48 - 1);
            v48 -= 4;
            *((_DWORD *)v75 - 1) = v76;
            v75 -= 4;
          }
          __p = v75;
          v741 = v49;
          v742 = &v59[4 * v23];
          if (v55) {
            operator delete(v55);
          }
        }
        else
        {
          *(_DWORD *)v741 = v41;
          uint64_t v49 = v48 + 4;
        }
        v741 = v49;
      }
      else
      {
        unint64_t v50 = objc_msgSend_semantic(v30, (const char *)v23, v24, v25);
        if (objc_msgSend_isEqualToString_(v50, v51, @"kGeometrySourceSemanticNormal", v52))
        {
          uint64_t v53 = v738;
          if (v738 >= v739)
          {
            uint64_t v65 = (char *)v737;
            uint64_t v66 = (v738 - (unsigned char *)v737) >> 2;
            unint64_t v67 = v66 + 1;
            if ((unint64_t)(v66 + 1) >> 62) {
              goto LABEL_203;
            }
            uint64_t v68 = v739 - (unsigned char *)v737;
            if ((v739 - (unsigned char *)v737) >> 1 > v67) {
              unint64_t v67 = v68 >> 1;
            }
            if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v23 = v67;
            }
            if (v23)
            {
              unint64_t v69 = (char *)sub_1B64282E0((uint64_t)&v739, v23);
              uint64_t v53 = v738;
              uint64_t v65 = (char *)v737;
            }
            else
            {
              unint64_t v69 = 0;
            }
            uint64_t v82 = &v69[4 * v66];
            *(_DWORD *)uint64_t v82 = v41;
            uint64_t v54 = v82 + 4;
            while (v53 != v65)
            {
              int v83 = *((_DWORD *)v53 - 1);
              v53 -= 4;
              *((_DWORD *)v82 - 1) = v83;
              v82 -= 4;
            }
            v737 = v82;
            v738 = v54;
            v739 = &v69[4 * v23];
            if (v65) {
              operator delete(v65);
            }
          }
          else
          {
            *(_DWORD *)v738 = v41;
            uint64_t v54 = v53 + 4;
          }
          v738 = v54;
        }
        else
        {
          uint64_t v60 = objc_msgSend_semantic(v30, (const char *)v23, v24, v25);
          if (objc_msgSend_isEqualToString_(v60, v61, @"kGeometrySourceSemanticTexcoord", v62))
          {
            uint64_t v63 = v735;
            if (v735 >= v736)
            {
              uint64_t v77 = (char *)v734;
              uint64_t v78 = (v735 - (unsigned char *)v734) >> 2;
              unint64_t v79 = v78 + 1;
              if ((unint64_t)(v78 + 1) >> 62) {
                goto LABEL_203;
              }
              uint64_t v80 = v736 - (unsigned char *)v734;
              if ((v736 - (unsigned char *)v734) >> 1 > v79) {
                unint64_t v79 = v80 >> 1;
              }
              if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v23 = v79;
              }
              if (v23)
              {
                uint64_t v81 = (char *)sub_1B64282E0((uint64_t)&v736, v23);
                uint64_t v63 = v735;
                uint64_t v77 = (char *)v734;
              }
              else
              {
                uint64_t v81 = 0;
              }
              uint64_t v89 = &v81[4 * v78];
              *(_DWORD *)uint64_t v89 = v41;
              uint64_t v64 = v89 + 4;
              while (v63 != v77)
              {
                int v90 = *((_DWORD *)v63 - 1);
                v63 -= 4;
                *((_DWORD *)v89 - 1) = v90;
                v89 -= 4;
              }
              v734 = v89;
              v735 = v64;
              v736 = &v81[4 * v23];
              if (v77) {
                operator delete(v77);
              }
            }
            else
            {
              *(_DWORD *)v735 = v41;
              uint64_t v64 = v63 + 4;
            }
            v735 = v64;
          }
          else
          {
            double v70 = objc_msgSend_semantic(v30, (const char *)v23, v24, v25);
            if (objc_msgSend_isEqualToString_(v70, v71, @"kGeometrySourceSemanticColor", v72))
            {
              long long v73 = v732;
              if (v732 >= v733)
              {
                uint64_t v84 = (char *)v731;
                uint64_t v85 = (v732 - (unsigned char *)v731) >> 2;
                unint64_t v86 = v85 + 1;
                if ((unint64_t)(v85 + 1) >> 62) {
LABEL_203:
                }
                  abort();
                uint64_t v87 = v733 - (unsigned char *)v731;
                if ((v733 - (unsigned char *)v731) >> 1 > v86) {
                  unint64_t v86 = v87 >> 1;
                }
                if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v23 = v86;
                }
                if (v23)
                {
                  uint64_t v88 = (char *)sub_1B64282E0((uint64_t)&v733, v23);
                  uint64_t v84 = (char *)v731;
                  long long v73 = v732;
                }
                else
                {
                  uint64_t v88 = 0;
                }
                uint64_t v91 = &v88[4 * v85];
                *(_DWORD *)uint64_t v91 = v41;
                uint64_t v74 = v91 + 4;
                while (v73 != v84)
                {
                  int v92 = *((_DWORD *)v73 - 1);
                  v73 -= 4;
                  *((_DWORD *)v91 - 1) = v92;
                  v91 -= 4;
                }
                v731 = v91;
                v732 = v74;
                v733 = &v88[4 * v23];
                if (v84) {
                  operator delete(v84);
                }
              }
              else
              {
                *(_DWORD *)v732 = v41;
                uint64_t v74 = v73 + 4;
              }
              v732 = v74;
            }
          }
        }
      }
      if (!(v41 | v705)) {
        int v705 = objc_msgSend_vectorCount(v30, (const char *)v23, v24, v25);
      }
      ++v27;
    }
    if (v741 == __p)
    {
LABEL_88:
      id v95 = 0;
      goto LABEL_194;
    }
  }
  else
  {
    uint64_t v93 = objc_msgSend_indexOfObjectPassingTest_(v15, (const char *)v23, (uint64_t)&unk_1F0FB5808, v25);
    int v94 = v93;
    if (v93 == 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_88;
    }
    uint64_t v96 = (v741 - (unsigned char *)__p) >> 2;
    unint64_t v97 = v96 + 1;
    if ((unint64_t)(v96 + 1) >> 62) {
      abort();
    }
    uint64_t v98 = v742 - (unsigned char *)__p;
    if ((v742 - (unsigned char *)__p) >> 1 > v97) {
      unint64_t v97 = v98 >> 1;
    }
    if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v99 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v99 = v97;
    }
    if (v99) {
      int v100 = (char *)sub_1B64282E0((uint64_t)&v742, v99);
    }
    else {
      int v100 = 0;
    }
    uint64_t v101 = &v100[4 * v96];
    *(_DWORD *)uint64_t v101 = v94;
    __p = v101;
    v742 = &v100[4 * v99];
    int v705 = 0;
    v741 = v101 + 4;
  }
  id v102 = objc_alloc_init(MEMORY[0x1E4F35C68]);
  v707 = objc_opt_new();
  uint64_t v105 = objc_msgSend_modelSourcesForSemantic_(value, v103, @"kGeometrySourceSemanticPosition", v104);
  uint64_t v108 = objc_msgSend_objectAtIndexedSubscript_(v105, v106, 0, v107);
  uint64_t v703 = objc_msgSend_vectorCount(v108, v109, v110, v111);
  v728 = 0;
  v729 = 0;
  uint64_t v730 = 0;
  *(_DWORD *)&v725[8] = 0;
  uint64_t v726 = 0;
  uint64_t v727 = 0;
  uint64_t v115 = objc_msgSend_meshElements(v683, v112, v113, v114);
  uint64_t v118 = objc_msgSend_objectAtIndexedSubscript_(v115, v116, 0, v117);
  *(void *)v725 = objc_msgSend_indicesChannelCount(v118, v119, v120, v121);
  uint64_t v125 = objc_msgSend_meshElements(v683, v122, v123, v124);
  id v126 = sub_1B6467E74(v125, v705, (char **)&v728, (uint64_t)&v725[4], v725);
  uint64_t v708 = objc_msgSend_count(v126, v127, v128, v129);
  if (v708)
  {
    uint64_t v703 = v705 + (((v726 - *(void *)&v725[4]) >> 2) / (unint64_t)(*(int *)v725 + 1));
    unint64_t v704 = ((v726 - *(void *)&v725[4]) >> 2) / (unint64_t)(*(int *)v725 + 1);
  }
  else
  {
    LODWORD(v704) = 0;
  }
  long long v723 = 0u;
  long long v724 = 0u;
  long long v721 = 0u;
  long long v722 = 0u;
  uint64_t v134 = objc_msgSend_countByEnumeratingWithState_objects_count_(v105, v130, (uint64_t)&v721, (uint64_t)v746, 16);
  v681 = v126;
  if (!v134)
  {
    int v135 = 0;
    goto LABEL_118;
  }
  obuint64_t j = v105;
  int v135 = 0;
  uint64_t v136 = 0;
  uint64_t v699 = *(void *)v722;
  uint64_t v137 = *MEMORY[0x1E4F35B90];
  int v693 = *(_DWORD *)v725;
  do
  {
    for (uint64_t i = 0; i != v134; ++i)
    {
      if (*(void *)v722 != v699) {
        objc_enumerationMutation(obj);
      }
      uint64_t v139 = *(void **)(*((void *)&v721 + 1) + 8 * i);
      uint64_t v140 = v137;
      if (v136)
      {
        uint64_t v679 = v136;
        uint64_t v140 = objc_msgSend_stringWithFormat_(NSString, v131, @"blendShape%d", v133);
      }
      uint64_t v141 = objc_msgSend_attributes(v102, v131, v132, v133);
      uint64_t v144 = objc_msgSend_objectAtIndexedSubscript_(v141, v142, v135, v143);
      objc_msgSend_setName_(v144, v145, v140, v146);
      uint64_t v150 = objc_msgSend_attributes(v102, v147, v148, v149);
      uint64_t v153 = objc_msgSend_objectAtIndexedSubscript_(v150, v151, v135, v152);
      objc_msgSend_setFormat_(v153, v154, 786435, v155);
      uint64_t v159 = objc_msgSend_attributes(v102, v156, v157, v158);
      uint64_t v162 = objc_msgSend_objectAtIndexedSubscript_(v159, v160, v135, v161);
      objc_msgSend_setBufferIndex_(v162, v163, v135, v164);
      if (v708)
      {
        uint64_t v168 = objc_msgSend_newBuffer_type_(v706, v165, 12 * v703, 1);
        uint64_t v169 = (const char *)*((unsigned int *)__p + (int)v136);
        uint64_t v173 = objc_msgSend_map(v168, v170, v171, v172);
        long long v177 = (char *)objc_msgSend_bytes(v173, v174, v175, v176);
        sub_1B64681F4(v139, v169, &v728, &v725[4], v693, v705, v704, v177);
        uint64_t v181 = objc_msgSend_attributes(v102, v178, v179, v180);
        uint64_t v184 = objc_msgSend_objectAtIndexedSubscript_(v181, v182, v135, v183);
        objc_msgSend_setOffset_(v184, v185, 0, v186);
        uint64_t v190 = objc_msgSend_layouts(v102, v187, v188, v189);
        uint64_t v193 = objc_msgSend_objectAtIndexedSubscript_(v190, v191, v135, v192);
        objc_msgSend_setStride_(v193, v194, 12, v195);
      }
      else
      {
        if (objc_msgSend_vectorCount(v139, v165, v166, v167) != v703) {
          continue;
        }
        uint64_t v198 = objc_msgSend_dataOffset(v139, v131, v132, v133);
        long long v202 = objc_msgSend_attributes(v102, v199, v200, v201);
        long long v205 = objc_msgSend_objectAtIndexedSubscript_(v202, v203, v135, v204);
        objc_msgSend_setOffset_(v205, v206, v198, v207);
        uint64_t v211 = objc_msgSend_dataStride(v139, v208, v209, v210);
        long long v215 = objc_msgSend_layouts(v102, v212, v213, v214);
        long long v218 = objc_msgSend_objectAtIndexedSubscript_(v215, v216, v135, v217);
        objc_msgSend_setStride_(v218, v219, v211, v220);
        uint64_t v224 = objc_msgSend_data(v139, v221, v222, v223);
        uint64_t v168 = objc_msgSend_newBufferWithData_type_(v706, v225, v224, 1);
      }
      objc_msgSend_addObject_(v707, v196, (uint64_t)v168, v197);

      ++v135;
      uint64_t v136 = (v136 + 1);
    }
    uint64_t v134 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v131, (uint64_t)&v721, (uint64_t)v746, 16);
  }
  while (v134);
LABEL_118:
  float32x4_t v226 = objc_msgSend_modelSourcesForSemantic_(value, v131, @"kGeometrySourceSemanticNormal", v133);
  long long v719 = 0u;
  long long v720 = 0u;
  long long v717 = 0u;
  long long v718 = 0u;
  uint64_t v231 = objc_msgSend_countByEnumeratingWithState_objects_count_(v226, v227, (uint64_t)&v717, (uint64_t)v745, 16);
  if (v231)
  {
    id obja = v226;
    uint64_t v232 = 0;
    uint64_t v700 = *(void *)v718;
    uint64_t v233 = *MEMORY[0x1E4F35B80];
    int v694 = *(_DWORD *)v725;
    do
    {
      for (uint64_t j = 0; j != v231; ++j)
      {
        if (*(void *)v718 != v700) {
          objc_enumerationMutation(obja);
        }
        float32x4_t v235 = *(void **)(*((void *)&v717 + 1) + 8 * j);
        uint64_t v236 = v233;
        if (v232)
        {
          uint64_t v679 = v232;
          uint64_t v236 = objc_msgSend_stringWithFormat_(NSString, v228, @"normal%d", v230);
        }
        float32x4_t v237 = objc_msgSend_attributes(v102, v228, v229, v230);
        float32x4_t v240 = objc_msgSend_objectAtIndexedSubscript_(v237, v238, v135, v239);
        objc_msgSend_setName_(v240, v241, v236, v242);
        v246 = objc_msgSend_attributes(v102, v243, v244, v245);
        v249 = objc_msgSend_objectAtIndexedSubscript_(v246, v247, v135, v248);
        objc_msgSend_setFormat_(v249, v250, 786435, v251);
        v255 = objc_msgSend_attributes(v102, v252, v253, v254);
        v258 = objc_msgSend_objectAtIndexedSubscript_(v255, v256, v135, v257);
        objc_msgSend_setBufferIndex_(v258, v259, v135, v260);
        if (v708)
        {
          v264 = objc_msgSend_newBuffer_type_(v706, v261, 12 * v703, 1);
          v265 = (const char *)*((unsigned int *)v737 + (int)v232);
          v269 = objc_msgSend_map(v264, v266, v267, v268);
          v273 = (char *)objc_msgSend_bytes(v269, v270, v271, v272);
          sub_1B64681F4(v235, v265, &v728, &v725[4], v694, v705, v704, v273);
          v277 = objc_msgSend_attributes(v102, v274, v275, v276);
          v280 = objc_msgSend_objectAtIndexedSubscript_(v277, v278, v135, v279);
          objc_msgSend_setOffset_(v280, v281, 0, v282);
          v286 = objc_msgSend_layouts(v102, v283, v284, v285);
          v289 = objc_msgSend_objectAtIndexedSubscript_(v286, v287, v135, v288);
          objc_msgSend_setStride_(v289, v290, 12, v291);
        }
        else
        {
          if (objc_msgSend_vectorCount(v235, v261, v262, v263) != v703) {
            continue;
          }
          uint64_t v294 = objc_msgSend_dataOffset(v235, v228, v229, v230);
          v298 = objc_msgSend_attributes(v102, v295, v296, v297);
          v301 = objc_msgSend_objectAtIndexedSubscript_(v298, v299, v135, v300);
          objc_msgSend_setOffset_(v301, v302, v294, v303);
          uint64_t v307 = objc_msgSend_dataStride(v235, v304, v305, v306);
          v311 = objc_msgSend_layouts(v102, v308, v309, v310);
          v314 = objc_msgSend_objectAtIndexedSubscript_(v311, v312, v135, v313);
          objc_msgSend_setStride_(v314, v315, v307, v316);
          uint64_t v320 = objc_msgSend_data(v235, v317, v318, v319);
          v264 = objc_msgSend_newBufferWithData_type_(v706, v321, v320, 1);
        }
        objc_msgSend_addObject_(v707, v292, (uint64_t)v264, v293);

        ++v135;
        uint64_t v232 = (v232 + 1);
      }
      uint64_t v231 = objc_msgSend_countByEnumeratingWithState_objects_count_(obja, v228, (uint64_t)&v717, (uint64_t)v745, 16);
    }
    while (v231);
  }
  if (!objc_msgSend_firstMaterial(value, v228, v229, v230)) {
    goto LABEL_136;
  }
  Material = objc_msgSend_firstMaterial(value, v322, v323, v324);
  v329 = objc_msgSend_multiply(Material, v326, v327, v328);
  objc_msgSend_contents(v329, v330, v331, v332);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    || (v333 = objc_msgSend_firstMaterial(value, v322, v323, v324),
        v337 = objc_msgSend_multiply(v333, v334, v335, v336),
        objc_msgSend_contents(v337, v338, v339, v340),
        objc_opt_class(),
        (objc_opt_isKindOfClass() & 1) != 0))
  {
    v341 = objc_msgSend_firstMaterial(value, v322, v323, v324);
    v345 = objc_msgSend_multiply(v341, v342, v343, v344);
    uint64_t v697 = objc_msgSend_mappingChannel(v345, v346, v347, v348);
  }
  else
  {
LABEL_136:
    uint64_t v697 = -1;
  }
  if (!objc_msgSend_firstMaterial(value, v322, v323, v324)) {
    goto LABEL_141;
  }
  v352 = objc_msgSend_firstMaterial(value, v349, v350, v351);
  v356 = objc_msgSend_selfIllumination(v352, v353, v354, v355);
  objc_msgSend_contents(v356, v357, v358, v359);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    || (v361 = objc_msgSend_firstMaterial(value, v349, v360, v351),
        v365 = objc_msgSend_selfIllumination(v361, v362, v363, v364),
        objc_msgSend_contents(v365, v366, v367, v368),
        objc_opt_class(),
        (objc_opt_isKindOfClass() & 1) != 0))
  {
    v369 = objc_msgSend_firstMaterial(value, v349, v360, v351);
    v373 = objc_msgSend_selfIllumination(v369, v370, v371, v372);
    uint64_t v695 = objc_msgSend_mappingChannel(v373, v374, v375, v376);
  }
  else
  {
LABEL_141:
    uint64_t v695 = -1;
  }
  v377 = objc_msgSend_modelSourcesForSemantic_(value, v349, @"kGeometrySourceSemanticTexcoord", v351);
  long long v715 = 0u;
  long long v716 = 0u;
  long long v713 = 0u;
  long long v714 = 0u;
  uint64_t v379 = objc_msgSend_countByEnumeratingWithState_objects_count_(v377, v378, (uint64_t)&v713, (uint64_t)v744, 16);
  if (!v379)
  {
    int v384 = v135;
    goto LABEL_170;
  }
  id v685 = v377;
  uint64_t v383 = 0;
  id objb = *(id *)v714;
  uint64_t v689 = *MEMORY[0x1E4F35BA0];
  uint64_t v688 = *MEMORY[0x1E4F35B48];
  uint64_t v687 = *MEMORY[0x1E4F35B78];
  int v686 = *(_DWORD *)v725;
  int v384 = v135;
  while (2)
  {
    uint64_t v701 = v379;
    uint64_t v385 = 0;
    while (2)
    {
      if (*(id *)v714 != objb) {
        objc_enumerationMutation(v685);
      }
      v386 = *(void **)(*((void *)&v713 + 1) + 8 * v385);
      uint64_t v387 = v689;
      if (v383)
      {
        uint64_t v679 = v383;
        uint64_t v387 = objc_msgSend_stringWithFormat_(NSString, v380, @"textureCoordinate%d", v382);
      }
      uint64_t v388 = v688;
      if (v697 != (int)v383) {
        uint64_t v388 = v387;
      }
      if (v695 == (int)v383) {
        uint64_t v389 = v687;
      }
      else {
        uint64_t v389 = v388;
      }
      v390 = objc_msgSend_attributes(v102, v380, v381, v382);
      v393 = objc_msgSend_objectAtIndexedSubscript_(v390, v391, v384, v392);
      objc_msgSend_setName_(v393, v394, v389, v395);
      v399 = objc_msgSend_attributes(v102, v396, v397, v398);
      v402 = objc_msgSend_objectAtIndexedSubscript_(v399, v400, v384, v401);
      objc_msgSend_setFormat_(v402, v403, 786434, v404);
      v408 = objc_msgSend_attributes(v102, v405, v406, v407);
      v411 = objc_msgSend_objectAtIndexedSubscript_(v408, v409, v384, v410);
      objc_msgSend_setBufferIndex_(v411, v412, v384, v413);
      if (v708)
      {
        v417 = objc_msgSend_newBuffer_type_(v706, v414, 8 * v703, 1);
        v418 = (const char *)*((unsigned int *)v734 + (int)v383);
        v422 = objc_msgSend_map(v417, v419, v420, v421);
        v426 = (char *)objc_msgSend_bytes(v422, v423, v424, v425);
        sub_1B64681F4(v386, v418, &v728, &v725[4], v686, v705, v704, v426);
        v430 = objc_msgSend_attributes(v102, v427, v428, v429);
        v433 = objc_msgSend_objectAtIndexedSubscript_(v430, v431, v384, v432);
        objc_msgSend_setOffset_(v433, v434, 0, v435);
        v439 = objc_msgSend_layouts(v102, v436, v437, v438);
        v442 = objc_msgSend_objectAtIndexedSubscript_(v439, v440, v384, v441);
        objc_msgSend_setStride_(v442, v443, 8, v444);
        goto LABEL_158;
      }
      if (objc_msgSend_vectorCount(v386, v414, v415, v416) == v703)
      {
        uint64_t v448 = objc_msgSend_dataOffset(v386, v380, v381, v382);
        v452 = objc_msgSend_attributes(v102, v449, v450, v451);
        v455 = objc_msgSend_objectAtIndexedSubscript_(v452, v453, v384, v454);
        objc_msgSend_setOffset_(v455, v456, v448, v457);
        uint64_t v461 = objc_msgSend_dataStride(v386, v458, v459, v460);
        v465 = objc_msgSend_layouts(v102, v462, v463, v464);
        v468 = objc_msgSend_objectAtIndexedSubscript_(v465, v466, v384, v467);
        objc_msgSend_setStride_(v468, v469, v461, v470);
        uint64_t v474 = objc_msgSend_data(v386, v471, v472, v473);
        v417 = objc_msgSend_newBufferWithData_type_(v706, v475, v474, 1);
LABEL_158:
        v476 = objc_msgSend_map(v417, v445, v446, v447);
        if (objc_msgSend_bytes(v476, v477, v478, v479))
        {
          v483 = objc_msgSend_attributes(v102, v480, v481, v482);
          v486 = objc_msgSend_objectAtIndexedSubscript_(v483, v484, v384, v485);
          uint64_t v490 = objc_msgSend_format(v486, v487, v488, v489);
          v494 = objc_msgSend_map(v417, v491, v492, v493);
          uint64_t v498 = objc_msgSend_bytes(v494, v495, v496, v497);
          uint64_t v502 = objc_msgSend_offset(v486, v499, v500, v501);
          v506 = objc_msgSend_layouts(v102, v503, v504, v505);
          uint64_t v510 = objc_msgSend_bufferIndex(v486, v507, v508, v509);
          v513 = objc_msgSend_objectAtIndexedSubscript_(v506, v511, v510, v512);
          uint64_t v517 = objc_msgSend_stride(v513, v514, v515, v516);
          if (v490 == 786434)
          {
            if (v703)
            {
              v523 = (float *)(v498 + v502 + 4);
              uint64_t v524 = v703;
              do
              {
                float *v523 = 1.0 - *v523;
                v523 = (float *)((char *)v523 + v517);
                --v524;
              }
              while (v524);
            }
          }
          else
          {
            sub_1B63F2F54(0, @"Warning: Warning: unable to flip non-float2 texture coordinates, skipping\n", v518, v482, v519, v520, v521, v522, v679);
          }
        }
        objc_msgSend_addObject_(v707, v480, (uint64_t)v417, v482);

        ++v384;
        uint64_t v383 = (v383 + 1);
      }
      if (++v385 != v701) {
        continue;
      }
      break;
    }
    uint64_t v379 = objc_msgSend_countByEnumeratingWithState_objects_count_(v685, v380, (uint64_t)&v713, (uint64_t)v744, 16);
    if (v379) {
      continue;
    }
    break;
  }
LABEL_170:
  long long v711 = 0u;
  long long v712 = 0u;
  long long v709 = 0u;
  long long v710 = 0u;
  id v696 = (id)objc_msgSend_modelSourcesForSemantic_(value, v380, @"kGeometrySourceSemanticColor", v382);
  uint64_t v529 = objc_msgSend_countByEnumeratingWithState_objects_count_(v696, v525, (uint64_t)&v709, (uint64_t)v743, 16);
  if (v529)
  {
    LODWORD(v530) = 0;
    uint64_t v702 = *(void *)v710;
    uint64_t v531 = *MEMORY[0x1E4F35B60];
    int v698 = *(_DWORD *)v725;
    int v532 = v384;
    do
    {
      uint64_t v533 = 0;
      uint64_t v534 = v532;
      uint64_t v530 = (int)v530;
      do
      {
        if (*(void *)v710 != v702) {
          objc_enumerationMutation(v696);
        }
        v535 = *(void **)(*((void *)&v709 + 1) + 8 * v533);
        uint64_t v536 = v531;
        if (v530) {
          uint64_t v536 = objc_msgSend_stringWithFormat_(NSString, v526, @"color%d", v528, v530, v680);
        }
        v537 = objc_msgSend_attributes(v102, v526, v527, v528);
        v540 = objc_msgSend_objectAtIndexedSubscript_(v537, v538, v534 + v533, v539);
        objc_msgSend_setName_(v540, v541, v536, v542);
        uint64_t v546 = objc_msgSend_componentsPerVector(v535, v543, v544, v545);
        v550 = objc_msgSend_attributes(v102, v547, v548, v549);
        v553 = objc_msgSend_objectAtIndexedSubscript_(v550, v551, v534 + v533, v552);
        objc_msgSend_setFormat_(v553, v554, v546 | 0xC0000, v555);
        v559 = objc_msgSend_attributes(v102, v556, v557, v558);
        v562 = objc_msgSend_objectAtIndexedSubscript_(v559, v560, v534 + v533, v561);
        objc_msgSend_setBufferIndex_(v562, v563, v534 + v533, v564);
        if (v708)
        {
          uint64_t v568 = objc_msgSend_dataStride(v535, v565, v566, v567);
          v570 = objc_msgSend_newBuffer_type_(v706, v569, v568 * v703, 1);
          v571 = (const char *)*((unsigned int *)v731 + v530);
          v575 = objc_msgSend_map(v570, v572, v573, v574);
          v579 = (char *)objc_msgSend_bytes(v575, v576, v577, v578);
          sub_1B64681F4(v535, v571, &v728, &v725[4], v698, v705, v704, v579);
          v583 = objc_msgSend_attributes(v102, v580, v581, v582);
          v586 = objc_msgSend_objectAtIndexedSubscript_(v583, v584, v534 + v533, v585);
          objc_msgSend_setOffset_(v586, v587, 0, v588);
          uint64_t v592 = objc_msgSend_dataStride(v535, v589, v590, v591);
          v596 = objc_msgSend_layouts(v102, v593, v594, v595);
          v599 = objc_msgSend_objectAtIndexedSubscript_(v596, v597, v534 + v533, v598);
          objc_msgSend_setStride_(v599, v600, v592, v601);
        }
        else
        {
          uint64_t v604 = objc_msgSend_dataOffset(v535, v565, v566, v567);
          v608 = objc_msgSend_attributes(v102, v605, v606, v607);
          v611 = objc_msgSend_objectAtIndexedSubscript_(v608, v609, v534 + v533, v610);
          objc_msgSend_setOffset_(v611, v612, v604, v613);
          uint64_t v617 = objc_msgSend_dataStride(v535, v614, v615, v616);
          v621 = objc_msgSend_layouts(v102, v618, v619, v620);
          v624 = objc_msgSend_objectAtIndexedSubscript_(v621, v622, v534 + v533, v623);
          objc_msgSend_setStride_(v624, v625, v617, v626);
          uint64_t v630 = objc_msgSend_data(v535, v627, v628, v629);
          v570 = objc_msgSend_newBufferWithData_type_(v706, v631, v630, 1);
        }
        objc_msgSend_addObject_(v707, v602, (uint64_t)v570, v603);

        ++v530;
        ++v533;
      }
      while (v529 != v533);
      uint64_t v529 = objc_msgSend_countByEnumeratingWithState_objects_count_(v696, v526, (uint64_t)&v709, (uint64_t)v743, 16);
      int v532 = v534 + v533;
    }
    while (v529);
  }
  v729 = v728;
  uint64_t v726 = *(void *)&v725[4];
  v632 = objc_opt_new();
  uint64_t v636 = objc_msgSend_meshElementCount(v683, v633, v634, v635);
  v640 = objc_msgSend_materials(value, v637, v638, v639);
  uint64_t v644 = objc_msgSend_count(v640, v641, v642, v643);
  if (v636)
  {
    unint64_t v647 = v644;
    for (unint64_t k = 0; k != v636; ++k)
    {
      uint64_t v651 = objc_msgSend_meshElementAtIndex_(v683, v645, k, v646);
      v652 = (void *)MEMORY[0x1E4F35C28];
      if (v708)
      {
        uint64_t v653 = objc_msgSend_objectAtIndexedSubscript_(v681, v649, k, v650);
        uint64_t v655 = objc_msgSend_submeshWithUniquedIndexData_andVFXModelElement_bufferAllocator_(v652, v654, v653, v651, a4);
      }
      else
      {
        uint64_t v655 = objc_msgSend_submeshWithVFXModelElement_bufferAllocator_positionSourceChannel_(MEMORY[0x1E4F35C28], v649, v651, a4, *(int *)__p);
      }
      v658 = (void *)v655;
      objc_msgSend_addObject_(v632, v656, v655, v657);
      if (v647)
      {
        v660 = objc_msgSend_materials(value, v645, v659, v646);
        uint64_t v663 = objc_msgSend_objectAtIndexedSubscript_(v660, v661, k % v647, v662);
        uint64_t v666 = objc_msgSend_materialWithVFXMaterial_(MEMORY[0x1E4F35BD0], v664, v663, v665);
        objc_msgSend_setMaterial_(v658, v667, v666, v668);
      }
    }
  }
  id v669 = [v680 alloc];
  v671 = objc_msgSend_initWithVertexBuffers_vertexCount_descriptor_submeshes_(v669, v670, (uint64_t)v707, v703, v102, v632);

  uint64_t v675 = objc_msgSend_name(value, v672, v673, v674);
  objc_msgSend_setName_(v671, v676, v675, v677);
  objc_setAssociatedObject(v671, @"VFXMDLAssociatedObject", value, (void *)0x301);
  id v95 = v671;
  if (*(void *)&v725[4])
  {
    uint64_t v726 = *(void *)&v725[4];
    operator delete(*(void **)&v725[4]);
  }
  if (v728)
  {
    v729 = v728;
    operator delete(v728);
  }
LABEL_194:
  if (v731)
  {
    v732 = (char *)v731;
    operator delete(v731);
  }
  if (v734)
  {
    v735 = (char *)v734;
    operator delete(v734);
  }
  if (v737)
  {
    v738 = (char *)v737;
    operator delete(v737);
  }
  if (__p)
  {
    v741 = (char *)__p;
    operator delete(__p);
  }
  return v95;
}

void sub_1B646974C(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6469890(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_semantic(a2, (const char *)a2, a3, a4);

  return objc_msgSend_isEqualToString_(v4, v5, @"kGeometrySourceSemanticPosition", v6);
}

id sub_1B64698C8(void *a1, const char *a2, uint64_t a3)
{
  unint64_t v3 = objc_msgSend_newSubmeshWithVFXModelElement_bufferAllocator_(a1, a2, a3, 0);

  return v3;
}

id sub_1B64698F4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_newSubmeshWithVFXModelElement_bufferAllocator_(a1, a2, a3, a4);

  return v4;
}

id sub_1B646991C(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_newSubmeshWithVFXModelElement_bufferAllocator_positionSourceChannel_(a1, a2, a3, a4);

  return v4;
}

id sub_1B6469944(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_newSubmeshWithUniquedIndexData_andVFXModelElement_bufferAllocator_(a1, a2, a3, a4);

  return v4;
}

uint64_t sub_1B646996C(objc_class *a1, const char *a2, void *a3, unint64_t a4, int a5, unint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10, void *a11, unint64_t a12, uint64_t a13)
{
  unint64_t v20 = a12;
  uint64_t v21 = objc_msgSend_bytes(a3, a2, (uint64_t)a3, a4);
  if (a6 >= 2 && a5)
  {
    uint64_t v25 = v21;
    unint64_t v26 = a8 * a6;
    unint64_t v27 = objc_msgSend_dataWithLength_(MEMORY[0x1E4F1CA58], v22, a4 / a6, v24);
    uint64_t v31 = objc_msgSend_mutableBytes(v27, v28, v29, v30);
    if (a8 * a6 <= a4)
    {
      uint64_t v33 = 0;
      if (a4 / v26 <= 1) {
        uint64_t v34 = 1;
      }
      else {
        uint64_t v34 = a4 / v26;
      }
      do
      {
        switch(a8)
        {
          case 1uLL:
            *(unsigned char *)(v31 + v33) = *(unsigned char *)(v25 + a7);
            break;
          case 2uLL:
            *(_WORD *)(v31 + 2 * v33) = *(_WORD *)(v25 + 2 * a7);
            break;
          case 4uLL:
            *(_DWORD *)(v31 + 4 * v33) = *(_DWORD *)(v25 + 4 * a7);
            break;
          case 8uLL:
            *(void *)(v31 + 8 * v33) = *(void *)(v25 + 8 * a7);
            break;
          default:
            break;
        }
        ++v33;
        a7 += a6;
      }
      while (v34 != v33);
    }
    uint64_t v35 = objc_msgSend_newBufferWithData_type_(a11, v32, (uint64_t)v27, 2);
  }
  else
  {
    unint64_t v36 = objc_msgSend_length(a3, v22, v23, v24);
    uint64_t v38 = objc_msgSend_subdataWithRange_(a3, v37, v36 / a6 * a7, v36 / a6);
    uint64_t v35 = objc_msgSend_newBufferWithData_type_(a11, v39, v38, 2);
  }
  uint64_t v40 = (void *)v35;
  id v44 = [a1 alloc];
  if (!a12) {
    unint64_t v20 = objc_msgSend_length(v40, v41, v42, v43) / a8;
  }
  uint64_t v45 = objc_msgSend_initWithName_indexBuffer_indexCount_indexType_geometryType_material_topology_(v44, v41, (uint64_t)&stru_1F0FCDBB0, (uint64_t)v40, v20, a9, a10, 0, a13);

  return v45;
}

uint64_t sub_1B6469B48(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_newSubmeshWithVFXModelElement_bufferAllocator_positionSourceChannel_(a1, a2, a3, a4, 0);
}

uint64_t sub_1B6469B50(objc_class *a1, const char *a2, uint64_t a3, void *a4, void *a5)
{
  unint64_t v9 = objc_msgSend_bytesPerIndex(a4, a2, a3, (uint64_t)a4);
  uint64_t v14 = objc_msgSend_primitiveCount(a4, v10, v11, v12);
  if (qword_1E9DDAD78 != -1) {
    dispatch_once(&qword_1E9DDAD78, &unk_1F0FB60C8);
  }
  if (a5) {
    uint64_t v15 = objc_msgSend_newBufferWithData_type_(a5, v13, a3, 2);
  }
  else {
    uint64_t v15 = objc_msgSend_newBufferWithData_type_((void *)qword_1E9DDAD70, v13, a3, 2);
  }
  uint64_t v19 = (void *)v15;
  uint64_t v20 = objc_msgSend_bytesPerIndex(a4, v16, v17, v18);
  uint64_t v24 = 32;
  if (v20 == 2) {
    uint64_t v24 = 16;
  }
  if (v20 == 1) {
    uint64_t v25 = 8;
  }
  else {
    uint64_t v25 = v24;
  }
  if (objc_msgSend_primitiveType(a4, v21, v22, v23) == 1)
  {
    uint64_t v29 = objc_msgSend_primitiveCount(a4, v26, v27, v28) + 2;
    id v30 = [a1 alloc];
    uint64_t v32 = objc_msgSend_initWithName_indexBuffer_indexCount_indexType_geometryType_material_topology_(v30, v31, (uint64_t)&stru_1F0FCDBB0, (uint64_t)v19, v29, v25, 3, 0, 0);
LABEL_28:
    uint64_t v64 = v32;
    goto LABEL_29;
  }
  if (objc_msgSend_primitiveType(a4, v26, v27, v28) != 4)
  {
    unint64_t v65 = objc_msgSend_primitiveType(a4, v33, v34, v35);
    if (v65 > 3)
    {
      uint64_t v70 = 0;
      uint64_t v69 = 1;
    }
    else
    {
      uint64_t v69 = qword_1B6E50D80[v65];
      uint64_t v70 = qword_1B6E50DA0[v65];
    }
    uint64_t v71 = objc_msgSend_primitiveCount(a4, v66, v67, v68) * v69;
    id v72 = [a1 alloc];
    uint64_t v32 = objc_msgSend_initWithName_indexBuffer_indexCount_indexType_geometryType_material_topology_(v72, v73, (uint64_t)&stru_1F0FCDBB0, (uint64_t)v19, v71, v25, v70, 0, 0);
    goto LABEL_28;
  }
  unint64_t v36 = objc_msgSend_data(a4, v33, v34, v35);
  uint64_t v40 = objc_msgSend_bytes(v36, v37, v38, v39);
  uint64_t v43 = objc_msgSend_dataWithLength_(MEMORY[0x1E4F1CA58], v41, 8 * v14, v42);
  uint64_t v47 = objc_msgSend_mutableBytes(v43, v44, v45, v46);
  if (v14 >= 1)
  {
    for (uint64_t i = 0; i != v14; ++i)
    {
      switch(v9)
      {
        case 1uLL:
          LOBYTE(v49) = *(unsigned char *)(v40 + i);
          goto LABEL_21;
        case 2uLL:
          LOWORD(v49) = *(_WORD *)(v40 + 2 * i);
          goto LABEL_21;
        case 4uLL:
          LODWORD(v49) = *(_DWORD *)(v40 + 4 * i);
          goto LABEL_21;
        case 8uLL:
          uint64_t v49 = *(void *)(v40 + 8 * i);
LABEL_21:
          *(unsigned char *)(v47 + i) = v49;
          break;
        default:
          continue;
      }
    }
  }
  id v50 = objc_alloc_init(MEMORY[0x1E4F35C30]);
  id v51 = objc_alloc(MEMORY[0x1E4F35BF0]);
  uint64_t v53 = objc_msgSend_initWithType_data_(v51, v52, 2, (uint64_t)v43);
  objc_msgSend_setFaceCount_(v50, v54, v14, v55);
  objc_msgSend_setFaceTopology_(v50, v56, v53, v57);
  id v58 = [a1 alloc];
  unint64_t v62 = objc_msgSend_length(v19, v59, v60, v61);
  uint64_t v64 = objc_msgSend_initWithName_indexBuffer_indexCount_indexType_geometryType_material_topology_(v58, v63, (uint64_t)&stru_1F0FCDBB0, (uint64_t)v19, v62 / v9, v25, 5, 0, v50);

  uint64_t v19 = (void *)v53;
LABEL_29:

  return v64;
}

uint64_t sub_1B6469E30()
{
  uint64_t result = objc_opt_new();
  qword_1E9DDAD70 = result;
  return result;
}

uint64_t sub_1B6469E58(void *a1, const char *a2, void *a3, uint64_t a4, uint64_t a5)
{
  unsigned int hasInterleavedIndicesChannels = objc_msgSend_hasInterleavedIndicesChannels(a3, a2, (uint64_t)a3, a4);
  uint64_t v102 = objc_msgSend_indicesChannelCount(a3, v9, v10, v11);
  uint64_t v15 = objc_msgSend_bytesPerIndex(a3, v12, v13, v14);
  uint64_t v19 = objc_msgSend_primitiveCount(a3, v16, v17, v18);
  uint64_t v23 = objc_msgSend_data(a3, v20, v21, v22);
  uint64_t v30 = objc_msgSend_length(v23, v24, v25, v26);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAD88, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDAD88))
  {
    qword_1E9DDAD80 = objc_opt_new();
    __cxa_guard_release(&qword_1E9DDAD88);
  }
  if (a4) {
    uint64_t v31 = a4;
  }
  else {
    uint64_t v31 = qword_1E9DDAD80;
  }
  uint64_t v32 = objc_msgSend_bytesPerIndex(a3, v27, v28, v29);
  uint64_t v36 = 32;
  if (v32 == 2) {
    uint64_t v36 = 16;
  }
  if (v32 == 1) {
    uint64_t v37 = 8;
  }
  else {
    uint64_t v37 = v36;
  }
  if (objc_msgSend_primitiveType(a3, v33, v34, v35) == 1)
  {
    uint64_t v41 = objc_msgSend_primitiveCount(a3, v38, v39, v40) + 2;
    uint64_t v45 = objc_msgSend_data(a3, v42, v43, v44);
    return objc_msgSend_newSubmeshWithGeometryData_indexBufferLength_interleaved_channelCount_channelIdx_bytesPerIndex_indexType_geometryType_allocator_indexCount_topology_(a1, v46, v45, v30, hasInterleavedIndicesChannels, v102, a5, v15, v37, 3, v31, v41, 0);
  }
  else if (objc_msgSend_primitiveType(a3, v38, v39, v40) == 4)
  {
    uint64_t v101 = a5;
    id v51 = objc_msgSend_data(a3, v48, v49, v50);
    uint64_t v55 = objc_msgSend_bytes(v51, v52, v53, v54);
    id v58 = objc_msgSend_dataWithLength_(MEMORY[0x1E4F1CA58], v56, v19, v57);
    uint64_t v62 = objc_msgSend_mutableBytes(v58, v59, v60, v61);
    if (v19 >= 1)
    {
      for (uint64_t i = 0; i != v19; ++i)
      {
        switch(v15)
        {
          case 1:
            LOBYTE(v67) = *(unsigned char *)(v55 + i);
            goto LABEL_20;
          case 2:
            LOWORD(v67) = *(_WORD *)(v55 + 2 * i);
            goto LABEL_20;
          case 4:
            LODWORD(v67) = *(_DWORD *)(v55 + 4 * i);
            goto LABEL_20;
          case 8:
            uint64_t v67 = *(void *)(v55 + 8 * i);
LABEL_20:
            *(unsigned char *)(v62 + i) = v67;
            break;
          default:
            continue;
        }
      }
    }
    uint64_t v68 = objc_msgSend_data(a3, v63, v64, v65);
    id v72 = objc_msgSend_data(a3, v69, v70, v71);
    uint64_t v76 = objc_msgSend_length(v72, v73, v74, v75);
    uint64_t v78 = objc_msgSend_subdataWithRange_(v68, v77, v19 * v15, v76 - v19 * v15);
    id v79 = objc_alloc_init(MEMORY[0x1E4F35C30]);
    id v80 = objc_alloc(MEMORY[0x1E4F35BF0]);
    uint64_t v82 = objc_msgSend_initWithType_data_(v80, v81, 2, (uint64_t)v58);
    objc_msgSend_setFaceCount_(v79, v83, v19, v84);
    objc_msgSend_setFaceTopology_(v79, v85, (uint64_t)v82, v86);
    uint64_t v88 = objc_msgSend_newSubmeshWithGeometryData_indexBufferLength_interleaved_channelCount_channelIdx_bytesPerIndex_indexType_geometryType_allocator_indexCount_topology_(a1, v87, v78, v30, hasInterleavedIndicesChannels, v102, v101, v15, v37, 5, v31, 0, v79);

    return v88;
  }
  else
  {
    unint64_t v89 = objc_msgSend_primitiveType(a3, v48, v49, v50);
    if (v89 > 3)
    {
      uint64_t v94 = 0;
      uint64_t v93 = 1;
    }
    else
    {
      uint64_t v93 = qword_1B6E50D80[v89];
      uint64_t v94 = qword_1B6E50DA0[v89];
    }
    uint64_t v95 = objc_msgSend_primitiveCount(a3, v90, v91, v92) * v93;
    uint64_t v99 = objc_msgSend_data(a3, v96, v97, v98);
    return objc_msgSend_newSubmeshWithGeometryData_indexBufferLength_interleaved_channelCount_channelIdx_bytesPerIndex_indexType_geometryType_allocator_indexCount_topology_(a1, v100, v99, v30, hasInterleavedIndicesChannels, v102, a5, v15, v37, v94, v31, v95, 0);
  }
}

void sub_1B646A164(_Unwind_Exception *a1)
{
}

id sub_1B646A19C(objc_class *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = objc_opt_new();
  id v6 = [a1 alloc];
  uint64_t v10 = objc_msgSend_name(a3, v7, v8, v9);
  uint64_t v12 = objc_msgSend_initWithName_scatteringFunction_(v6, v11, v10, (uint64_t)v5);

  uint64_t v16 = objc_msgSend_name(a3, v13, v14, v15);
  objc_msgSend_setName_(v12, v17, v16, v18);
  objc_setAssociatedObject(v12, @"VFXMDLAssociatedObject", a3, (void *)0x301);
  objc_setAssociatedObject(a3, @"VFXMDLAssociatedObject", v12, 0);
  uint64_t v22 = objc_msgSend_emission(a3, v19, v20, v21);
  sub_1B646A3B4(v12, (const char *)@"emission", v22, 13);
  uint64_t v26 = objc_msgSend_diffuse(a3, v23, v24, v25);
  sub_1B646A3B4(v12, (const char *)@"baseColor", v26, 0);
  uint64_t v30 = objc_msgSend_specular(a3, v27, v28, v29);
  sub_1B646A3B4(v12, (const char *)@"specular", v30, 3);
  uint64_t v34 = objc_msgSend_reflective(a3, v31, v32, v33);
  sub_1B646A3B4(v12, (const char *)@"reflective", v34, 32769);
  uint64_t v38 = objc_msgSend_transparent(a3, v35, v36, v37);
  sub_1B646A3B4(v12, (const char *)@"opacity", v38, 15);
  uint64_t v42 = objc_msgSend_metalness(a3, v39, v40, v41);
  sub_1B646A3B4(v12, (const char *)@"metallic", v42, 2);
  uint64_t v46 = objc_msgSend_roughness(a3, v43, v44, v45);
  sub_1B646A3B4(v12, (const char *)@"roughness", v46, 6);
  uint64_t v50 = objc_msgSend_ambientOcclusion(a3, v47, v48, v49);
  sub_1B646A3B4(v12, (const char *)@"ambientOcclusion", v50, 22);
  uint64_t v54 = objc_msgSend_displacement(a3, v51, v52, v53);
  sub_1B646A3B4(v12, (const char *)@"displacement", v54, 20);
  id v58 = objc_msgSend_normal(a3, v55, v56, v57);
  sub_1B646A3B4(v12, (const char *)@"normal", v58, 19);
  if (objc_msgSend_isDoubleSided(a3, v59, v60, v61)) {
    objc_msgSend_setMaterialFace_(v12, v62, 2, v63);
  }

  return v12;
}

void sub_1B646A3B4(void *a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t v10 = objc_msgSend_propertyNamed_(a1, a2, (uint64_t)a2, a4);
  id v123 = (id)v10;
  if (!v10)
  {
    id v11 = objc_alloc(MEMORY[0x1E4F35BD8]);
    id v123 = (id)objc_msgSend_initWithName_semantic_(v11, v12, (uint64_t)a2, a4);
  }
  objc_msgSend_contents(a3, v7, v8, v9);
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v17 = objc_msgSend_contents(a3, v14, v15, v16);
  if (isKindOfClass)
  {
    objc_msgSend_vfx_colorComponentsForModelIO(v17, v18, v19, v20);
    float32x4_t v121 = v23;
    v23.i32[0] = v23.i32[3];
    if (v23.f32[3] == 1.0)
    {
      objc_msgSend_setType_(v123, v21, 7, v22, *(double *)v23.i64);
      objc_msgSend_intensity(a3, v24, v25, v26);
      objc_msgSend_setFloat3Value_(v123, v28, v29, v30, *(double *)vmulq_n_f32(v121, v27).i64);
    }
    else
    {
      objc_msgSend_setType_(v123, v21, 8, v22, *(double *)v23.i64);
      objc_msgSend_intensity(a3, v72, v73, v74);
      objc_msgSend_setFloat4Value_(v123, v76, v77, v78, *(double *)vmulq_n_f32(v121, v75).i64);
    }
  }
  else
  {
    objc_opt_class();
    char v31 = objc_opt_isKindOfClass();
    uint64_t v35 = objc_msgSend_contents(a3, v32, v33, v34);
    uint64_t v38 = (void *)v35;
    if (v31)
    {
      if (v35)
      {
        objc_msgSend_setType_(v123, v36, 5, v37);
        objc_msgSend_intensity(a3, v39, v40, v41);
        float v43 = v42;
        objc_msgSend_floatValue(v38, v44, v45, v46);
        *(float *)&double v48 = v43 * v47;
        objc_msgSend_setFloatValue_(v123, v49, v50, v51, v48);
      }
    }
    else
    {
      objc_opt_class();
      char v52 = objc_opt_isKindOfClass();
      uint64_t v56 = objc_msgSend_contents(a3, v53, v54, v55);
      if (v52)
      {
        uint64_t v60 = objc_msgSend_pathExtension(v56, v57, v58, v59);
        if (!objc_msgSend_isEqualToString_(v60, v61, @"usdz", v62))
        {
          objc_msgSend_setType_(v123, v63, 2, v65);
          uint64_t v69 = objc_msgSend_contents(a3, v66, v67, v68);
          objc_msgSend_setURLValue_(v123, v70, v69, v71);
          goto LABEL_18;
        }
      }
      else
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          objc_msgSend_setType_(v123, v63, 1, v65);
          uint64_t v82 = objc_msgSend_contents(a3, v79, v80, v81);
          objc_msgSend_setStringValue_(v123, v83, v82, v84);
          goto LABEL_18;
        }
      }
      CFXImageRef = (_DWORD *)objc_msgSend_getCFXImageRef(a3, v63, v64, v65);
      if (CFXImageRef)
      {
        id v92 = sub_1B6464A9C(CFXImageRef, 0, v86, v87, v88, v89, v90, v91);
        objc_msgSend_contentsTransform(a3, v93, v94, v95);
        v124[0] = v96;
        v124[1] = v97;
        v124[2] = v98;
        v124[3] = v99;
        double v100 = sub_1B6470988((uint64_t)v124);
        if (v92)
        {
          double v118 = v100;
          double v119 = v101;
          double v120 = v102;
          double v122 = v103;
          id v104 = objc_alloc(MEMORY[0x1E4F35C48]);
          uint64_t v108 = objc_msgSend_initWithMatrix_(v104, v105, v106, v107, v118, v119, v120, v122);
          id v109 = objc_alloc_init(MEMORY[0x1E4F35C40]);
          objc_msgSend_setTransform_(v109, v110, (uint64_t)v108, v111);
          objc_msgSend_setTexture_(v109, v112, (uint64_t)v92, v113);
          objc_msgSend_setType_(v123, v114, 3, v115);
          objc_msgSend_setTextureSamplerValue_(v123, v116, (uint64_t)v109, v117);
        }
      }
    }
  }
LABEL_18:
  if (!v10 && v123)
  {
  }
}

uint64_t sub_1B646A6A4()
{
  return 0;
}

id sub_1B646A6AC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = objc_alloc_init(MEMORY[0x1E4F35C08]);
  objc_setAssociatedObject(v4, @"VFXMDLAssociatedObject", a3, (void *)0x301);
  objc_msgSend_setColorSpace_(v4, v5, *MEMORY[0x1E4F1DC98], v6);
  objc_msgSend_color(a3, v7, v8, v9);
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v14 = objc_msgSend_color(a3, v11, v12, v13);
  uint64_t v17 = (uint64_t)v14;
  if (isKindOfClass) {
    uint64_t v17 = objc_msgSend_CGColor(v14, v15, (uint64_t)v14, v16);
  }
  objc_msgSend_setColor_(v4, v15, v17, v16);
  objc_msgSend_setAttenuationStartDistance_(v4, v18, v19, v20, 0.0);
  objc_msgSend_attenuationDistance(a3, v21, v22, v23);
  objc_msgSend_setAttenuationEndDistance_(v4, v24, v25, v26);
  LODWORD(v27) = 2.0;
  objc_msgSend_setAttenuationFalloffExponent_(v4, v28, v29, v30, v27);
  objc_msgSend_spotInnerAngle(a3, v31, v32, v33);
  objc_msgSend_setInnerConeAngle_(v4, v34, v35, v36);
  objc_msgSend_spotOuterAngle(a3, v37, v38, v39);
  objc_msgSend_setOuterConeAngle_(v4, v40, v41, v42);
  if (objc_msgSend_type(a3, v43, v44, v45))
  {
    if (objc_msgSend_type(a3, v46, v47, v48) == 3)
    {
      objc_msgSend_setLightType_(v4, v49, 3, v51);
    }
    else if (objc_msgSend_type(a3, v49, v50, v51) == 2)
    {
      objc_msgSend_setLightType_(v4, v52, 2, v54);
    }
    else if (objc_msgSend_type(a3, v52, v53, v54) == 1)
    {
      objc_msgSend_setLightType_(v4, v55, 4, v56);
    }
  }
  else
  {
    objc_msgSend_setLightType_(v4, v46, 1, v48);
  }

  return v4;
}

id sub_1B646A814(objc_class *a1, uint64_t a2, void *a3)
{
  id v4 = objc_alloc_init(a1);
  objc_setAssociatedObject(v4, @"VFXMDLAssociatedObject", a3, (void *)0x301);
  objc_msgSend_focusDistance(a3, v5, v6, v7);
  objc_msgSend_setFocusDistance_(v4, v8, v9, v10);
  objc_msgSend_sensorHeight(a3, v11, v12, v13);
  objc_msgSend_setSensorVerticalAperture_(v4, v14, v15, v16);
  uint64_t v20 = objc_msgSend_depthOfField(a3, v17, v18, v19);
  uint64_t v24 = objc_msgSend_apertureBladeCount(v20, v21, v22, v23);
  objc_msgSend_setApertureBladeCount_(v4, v25, v24, v26);
  objc_msgSend_fieldOfView(a3, v27, v28, v29);
  objc_msgSend_setFieldOfView_(v4, v30, v31, v32);
  objc_msgSend_zNear(a3, v33, v34, v35);
  objc_msgSend_setNearVisibilityDistance_(v4, v36, v37, v38);
  objc_msgSend_zFar(a3, v39, v40, v41);
  objc_msgSend_setFarVisibilityDistance_(v4, v42, v43, v44);
  uint64_t v48 = objc_msgSend_depthOfField(a3, v45, v46, v47);
  objc_msgSend_fStop(v48, v49, v50, v51);
  objc_msgSend_setFStop_(v4, v52, v53, v54);
  unsigned int v58 = objc_msgSend_usesOrthographicProjection(a3, v55, v56, v57);
  objc_msgSend_setProjection_(v4, v59, v58, v60);

  return v4;
}

uint64_t **sub_1B646B4A4(void *a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v84 = a3;
  uint64_t v85 = a1;
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  double v100 = a2;
  id v4 = objc_opt_new();
  uint64_t v8 = objc_msgSend_jointPaths(a2, v5, v6, v7);
  uint64_t v12 = objc_msgSend_count(v8, v9, v10, v11);
  unsigned int v13 = v12;
  uint64_t v14 = v12;
  double v16 = MEMORY[0x1F4188790](v12, v15);
  uint64_t v20 = objc_msgSend_jointRestTransforms(a2, v17, v18, v19, v16);
  uint64_t v86 = &v82 - 8 * v14;
  if (objc_msgSend_getFloat4x4Array_maxCount_(v20, v21, (uint64_t)v86, v14) < (unint64_t)v13)
  {
    uint64_t v25 = (_OWORD *)MEMORY[0x1E4F149A0];
    uint64_t v26 = v86;
    do
    {
      long long v27 = v25[1];
      *(_OWORD *)uint64_t v26 = *v25;
      *((_OWORD *)v26 + 1) = v27;
      long long v28 = v25[3];
      *((_OWORD *)v26 + 2) = v25[2];
      *((_OWORD *)v26 + 3) = v28;
      v26 += 8;
      --v14;
    }
    while (v14);
  }
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  int v83 = a2;
  uint64_t v87 = objc_msgSend_jointPaths(a2, v22, v23, v24);
  uint64_t v30 = objc_msgSend_countByEnumeratingWithState_objects_count_(v87, v29, (uint64_t)&v96, (uint64_t)v103, 16);
  if (v30)
  {
    uint64_t v34 = v30;
    int v35 = 0;
    uint64_t v36 = *(void *)v97;
    do
    {
      for (uint64_t i = 0; i != v34; ++i)
      {
        if (*(void *)v97 != v36) {
          objc_enumerationMutation(v87);
        }
        uint64_t v38 = *(void **)(*((void *)&v96 + 1) + 8 * i);
        uint64_t v39 = objc_msgSend_rangeOfString_options_(v38, v31, @"/", 4);
        uint64_t v41 = (uint64_t)v38;
        if (v39 != 0x7FFFFFFFFFFFFFFFLL) {
          uint64_t v41 = objc_msgSend_substringFromIndex_(v38, v31, v39 + 1, v40);
        }
        if (v41)
        {
          uint64_t v42 = objc_opt_new();
          objc_msgSend_setName_(v42, v43, v41, v44);
          if (v42)
          {
            objc_msgSend_setObject_forKeyedSubscript_(v4, v31, (uint64_t)v42, (uint64_t)v38);
            objc_msgSend_setTransform_(v42, v45, v46, v47, *(double *)&v86[8 * (unint64_t)(v35 + i)], *(double *)&v86[8 * (unint64_t)(v35 + i) + 2], *(double *)&v86[8 * (unint64_t)(v35 + i) + 4], *(double *)&v86[8 * (unint64_t)(v35 + i) + 6]);
          }
        }
      }
      uint64_t v34 = objc_msgSend_countByEnumeratingWithState_objects_count_(v87, v31, (uint64_t)&v96, (uint64_t)v103, 16);
      v35 += i;
    }
    while (v34);
  }
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  uint64_t v48 = objc_msgSend_jointPaths(v83, v31, v32, v33);
  uint64_t v50 = objc_msgSend_countByEnumeratingWithState_objects_count_(v48, v49, (uint64_t)&v92, (uint64_t)v102, 16);
  if (v50)
  {
    uint64_t v52 = v50;
    uint64_t v53 = *(void *)v93;
    do
    {
      uint64_t v54 = 0;
      do
      {
        if (*(void *)v93 != v53) {
          objc_enumerationMutation(v48);
        }
        uint64_t v55 = *(void **)(*((void *)&v92 + 1) + 8 * v54);
        uint64_t v56 = objc_msgSend_rangeOfString_options_(v55, v51, @"/", 4);
        if (v56) {
          BOOL v58 = v56 == 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          BOOL v58 = 1;
        }
        if (!v58)
        {
          uint64_t v59 = objc_msgSend_substringToIndex_(v55, v51, v56, v57);
          if (v59)
          {
            uint64_t v61 = v59;
            if (objc_msgSend_valueForKey_(v4, v51, v59, v60))
            {
              uint64_t v63 = objc_msgSend_objectForKeyedSubscript_(v4, v51, v61, v62);
              uint64_t v66 = objc_msgSend_objectForKeyedSubscript_(v4, v64, (uint64_t)v55, v65);
              objc_msgSend_addChildNode_(v63, v67, v66, v68);
            }
          }
        }
        ++v54;
      }
      while (v52 != v54);
      uint64_t v69 = objc_msgSend_countByEnumeratingWithState_objects_count_(v48, v51, (uint64_t)&v92, (uint64_t)v102, 16);
      uint64_t v52 = v69;
    }
    while (v69);
  }
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  uint64_t v70 = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v51, (uint64_t)&v88, (uint64_t)v101, 16);
  uint64_t v73 = v85;
  if (v70)
  {
    uint64_t v74 = v70;
    uint64_t v75 = *(void *)v89;
    do
    {
      for (uint64_t j = 0; j != v74; ++j)
      {
        if (*(void *)v89 != v75) {
          objc_enumerationMutation(v4);
        }
        uint64_t v77 = objc_msgSend_objectForKeyedSubscript_(v4, v71, *(void *)(*((void *)&v88 + 1) + 8 * j), v72);
        if (!objc_msgSend_parentNode(v77, v78, v79, v80)) {
          objc_msgSend_addChildNode_(v73, v71, (uint64_t)v77, v72);
        }
      }
      uint64_t v74 = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v71, (uint64_t)&v88, (uint64_t)v101, 16);
    }
    while (v74);
  }
  uint64_t result = sub_1B6470540(v84, &v100);
  *uint64_t result = (uint64_t *)v4;
  result[1] = (uint64_t *)v73;
  return result;
}

uint64_t sub_1B646B964(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_vertexCount(a1, a2, a3, a4);
  uint64_t v8 = objc_msgSend_vertexAttributeDataForAttributeNamed_(a1, v6, *MEMORY[0x1E4F35B70], v7);
  uint64_t v12 = objc_msgSend_dataStart(v8, v9, v10, v11);
  uint64_t v16 = objc_msgSend_format(v8, v13, v14, v15) & 0xFFF;
  uint64_t v18 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v17, v12, 4 * v16 * v5);
  return objc_msgSend_meshSourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride_(VFXMeshSource, v19, v18, @"kGeometrySourceSemanticBoneWeights", v5, 1, v16, 4, 0, 4 * v16);
}

uint64_t sub_1B646BA10(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_vertexCount(a1, a2, a3, a4);
  uint64_t v8 = objc_msgSend_vertexAttributeDataForAttributeNamed_(a1, v6, *MEMORY[0x1E4F35B68], v7);
  uint64_t v12 = objc_msgSend_dataStart(v8, v9, v10, v11);
  uint64_t v16 = objc_msgSend_format(v8, v13, v14, v15) & 0xFFF;
  uint64_t v18 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v17, v12, 2 * v16 * v5);
  return objc_msgSend_meshSourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride_(VFXMeshSource, v19, v18, @"kGeometrySourceSemanticBoneIndices", v5, 0, v16, 2, 0, 2 * v16);
}

uint64_t sub_1B646BC5C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v4 = *(void **)(a1 + 32);
  uint64_t v5 = NSString;
  uint64_t v6 = objc_msgSend_name(a2, (const char *)a2, a3, a4);
  uint64_t v10 = objc_msgSend_UUID(MEMORY[0x1E4F29128], v7, v8, v9);
  uint64_t v14 = objc_msgSend_UUIDString(v10, v11, v12, v13);
  uint64_t v18 = objc_msgSend_stringWithFormat_(v5, v15, @"AO_%@_%@.png", v16, v6, v14);

  return objc_msgSend_stringByAppendingPathComponent_(v4, v17, v18, v19);
}

void sub_1B646BCDC(uint64_t a1, const char *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  v32[0] = 0;
  v32[1] = v32;
  v32[2] = 0x3052000000;
  v32[3] = sub_1B646C044;
  v32[4] = sub_1B646C054;
  v32[5] = 0;
  v31[0] = 0;
  v31[1] = v31;
  v31[2] = 0x3052000000;
  v31[3] = sub_1B646C044;
  v31[4] = sub_1B646C054;
  v31[5] = 0;
  v30[0] = 0;
  v30[1] = v30;
  v30[2] = 0x3052000000;
  v30[3] = sub_1B646C044;
  v30[4] = sub_1B646C054;
  void v30[5] = 0;
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = sub_1B646C060;
  v29[3] = &unk_1E61424C8;
  _OWORD v29[4] = v32;
  v29[5] = v31;
  v29[6] = v30;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  unint64_t v3 = *(void **)(a1 + 32);
  uint64_t v5 = objc_msgSend_countByEnumeratingWithState_objects_count_(v3, a2, (uint64_t)&v25, (uint64_t)v33, 16);
  if (v5)
  {
    uint64_t v8 = *(void *)v26;
    uint64_t v9 = *MEMORY[0x1E4F35B60];
    uint64_t v10 = *MEMORY[0x1E4F35B48];
    uint64_t v11 = *MEMORY[0x1E4F35B78];
    char v12 = 1;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v26 != v8) {
          objc_enumerationMutation(v3);
        }
        uint64_t v14 = *(void **)(*((void *)&v25 + 1) + 8 * i);
        if (*(unsigned char *)(a1 + 96))
        {
          LODWORD(v6) = *(_DWORD *)(a1 + 88);
          LODWORD(v7) = *(_DWORD *)(a1 + 92);
          uint64_t v15 = *(void *)(a1 + 40);
          if (*(unsigned char *)(a1 + 97)) {
            char AmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed = objc_msgSend_generateAmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed_(v14, v4, v15, v9, v6, v7);
          }
          else {
            char AmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed = objc_msgSend_generateAmbientOcclusionTextureWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed_materialPropertyNamed_(v14, v4, v15, v10, @"aoTexture", v6, v7);
          }
        }
        else if (*(unsigned char *)(a1 + 97))
        {
          char AmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed = objc_msgSend_generateLightMapVertexColorsWithLightsToConsider_objectsToConsider_vertexAttributeNamed_(v14, v4, *(void *)(a1 + 48), *(void *)(a1 + 40), v9);
        }
        else
        {
          LODWORD(v6) = *(_DWORD *)(a1 + 88);
          char AmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed = objc_msgSend_generateLightMapTextureWithQuality_lightsToConsider_objectsToConsider_vertexAttributeNamed_materialPropertyNamed_(v14, v4, *(void *)(a1 + 48), *(void *)(a1 + 40), v11, @"lightmapTexture", v6);
        }
        v12 &= AmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed;
      }
      uint64_t v5 = objc_msgSend_countByEnumeratingWithState_objects_count_(v3, v4, (uint64_t)&v25, (uint64_t)v33, 16);
    }
    while (v5);
  }
  else
  {
    char v12 = 1;
  }
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  v18[2] = sub_1B646C08C;
  v18[3] = &unk_1E61424F0;
  char v23 = v12;
  uint64_t v17 = *(void *)(a1 + 56);
  char v24 = *(unsigned char *)(a1 + 96);
  _OWORD v18[4] = v17;
  void v18[5] = v29;
  long long v19 = *(_OWORD *)(a1 + 64);
  uint64_t v21 = v31;
  uint64_t v22 = v32;
  uint64_t v20 = *(void *)(a1 + 80);
  dispatch_async(MEMORY[0x1E4F14428], v18);
  _Block_object_dispose(v30, 8);
  _Block_object_dispose(v31, 8);
  _Block_object_dispose(v32, 8);
}

void sub_1B646C008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

void sub_1B646C044(uint64_t a1, uint64_t a2)
{
}

void sub_1B646C054(uint64_t a1)
{
}

void *sub_1B646C060(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    *(void *)(*(void *)(result[4] + 8) + 40) = a2;
    *(void *)(*(void *)(result[5] + 8) + 40) = a3;
    *(void *)(*(void *)(result[6] + 8) + 40) = a4;
  }
  return result;
}

uint64_t sub_1B646C08C(uint64_t a1, const char *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 88))
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    unint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = objc_msgSend_countByEnumeratingWithState_objects_count_(v3, a2, (uint64_t)&v15, (uint64_t)v19, 16);
    if (v4)
    {
      uint64_t v6 = v4;
      uint64_t v7 = *(void *)v16;
      uint64_t v8 = *MEMORY[0x1E4F35B48];
      uint64_t v9 = *MEMORY[0x1E4F35B78];
      do
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (*(void *)v16 != v7) {
            objc_enumerationMutation(v3);
          }
          uint64_t v11 = *(void **)(*((void *)&v15 + 1) + 8 * i);
          uint64_t v12 = *(void *)(a1 + 40);
          uint64_t v13 = *(void *)(a1 + 48);
          if (*(unsigned char *)(a1 + 89)) {
            objc_msgSend__updateAssociatedVFXNodeWithGeometrySetter_texturePathProvider_vertexAttributeNamed_materialPropertyNamed_(v11, v5, v12, v13, v8, @"aoTexture");
          }
          else {
            objc_msgSend__updateAssociatedVFXNodeWithGeometrySetter_texturePathProvider_vertexAttributeNamed_materialPropertyNamed_(v11, v5, v12, v13, v9, @"lightmapTexture");
          }
          (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
        }
        uint64_t v6 = objc_msgSend_countByEnumeratingWithState_objects_count_(v3, v5, (uint64_t)&v15, (uint64_t)v19, 16);
      }
      while (v6);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 64) + 16))();
}

void sub_1B646C950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B646CB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, char a14, void *a15)
{
}

uint64_t sub_1B646CBBC(void *a1, char *a2, uint64_t **a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_topology(a1, a2, (uint64_t)a3, a4);
  if (result)
  {
    uint64_t v11 = objc_msgSend_topology(a1, v8, v9, v10);
    if (objc_msgSend_edgeCreases(v11, v12, v13, v14))
    {
      long long v18 = objc_msgSend_topology(a1, v15, v16, v17);
      if (objc_msgSend_edgeCreaseIndices(v18, v19, v20, v21))
      {
        uint64_t v22 = objc_msgSend_topology(a1, v15, v16, v17);
        long long v26 = objc_msgSend_edgeCreaseIndices(v22, v23, v24, v25);
        uint64_t v30 = objc_msgSend_map(v26, v27, v28, v29);
        uint64_t v34 = objc_msgSend_bytes(v30, v31, v32, v33);
        uint64_t v38 = objc_msgSend_topology(a1, v35, v36, v37);
        uint64_t v42 = objc_msgSend_edgeCreases(v38, v39, v40, v41);
        uint64_t v46 = objc_msgSend_map(v42, v43, v44, v45);
        uint64_t v50 = (int *)objc_msgSend_bytes(v46, v47, v48, v49);
        uint64_t v54 = objc_msgSend_topology(a1, v51, v52, v53);
        int v58 = objc_msgSend_edgeCreaseCount(v54, v55, v56, v57);
        if (v58 >= 1)
        {
          uint64_t v59 = v58;
          uint64_t v60 = (unsigned int *)(v34 + 4);
          do
          {
            unint64_t v114 = *v60 | ((unint64_t)*(v60 - 1) << 32);
            int v61 = *v50++;
            uint64_t v115 = &v114;
            *((_DWORD *)sub_1B6470CBC((uint64_t **)a2, &v114, (uint64_t)&unk_1B6E4FDF8, &v115) + 10) = v61;
            v60 += 2;
            --v59;
          }
          while (v59);
        }
      }
    }
    uint64_t v62 = objc_msgSend_topology(a1, v15, v16, v17);
    uint64_t result = objc_msgSend_vertexCreases(v62, v63, v64, v65);
    if (result)
    {
      uint64_t v69 = objc_msgSend_topology(a1, v66, v67, v68);
      uint64_t result = objc_msgSend_vertexCreaseIndices(v69, v70, v71, v72);
      if (result)
      {
        uint64_t v76 = objc_msgSend_topology(a1, v73, v74, v75);
        uint64_t v80 = objc_msgSend_vertexCreaseIndices(v76, v77, v78, v79);
        uint64_t v84 = objc_msgSend_map(v80, v81, v82, v83);
        long long v88 = (unint64_t *)objc_msgSend_bytes(v84, v85, v86, v87);
        long long v92 = objc_msgSend_topology(a1, v89, v90, v91);
        long long v96 = objc_msgSend_vertexCreases(v92, v93, v94, v95);
        double v100 = objc_msgSend_map(v96, v97, v98, v99);
        uint64_t v104 = (int *)objc_msgSend_bytes(v100, v101, v102, v103);
        uint64_t v108 = objc_msgSend_topology(a1, v105, v106, v107);
        uint64_t result = objc_msgSend_vertexCreaseCount(v108, v109, v110, v111);
        if ((int)result >= 1)
        {
          uint64_t v112 = result;
          do
          {
            int v113 = *v104++;
            uint64_t v115 = v88;
            uint64_t result = (uint64_t)sub_1B6470D80(a3, (unsigned int *)v88, (uint64_t)&unk_1B6E4FDF8, (unsigned int **)&v115);
            *(_DWORD *)(result + 32) = v113;
            long long v88 = (unint64_t *)((char *)v88 + 4);
            --v112;
          }
          while (v112);
        }
      }
    }
  }
  return result;
}

unint64_t sub_1B646CD68(void *a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (void *)a4;
  uint64_t v5 = a2;
  uint64_t v6 = objc_msgSend_vertexDescriptor(a3, a2, (uint64_t)a3, a4);
  uint64_t v10 = objc_msgSend_attributes(v6, v7, v8, v9);
  unint64_t result = objc_msgSend_count(v10, v11, v12, v13);
  if (result)
  {
    unint64_t v18 = 0;
    int v19 = 0;
    int v20 = 0;
    uint64_t v21 = *MEMORY[0x1E4F35B90];
    uint64_t v22 = *MEMORY[0x1E4F35B80];
    uint64_t v23 = *MEMORY[0x1E4F35B68];
    uint64_t v73 = *MEMORY[0x1E4F35B70];
    uint64_t v70 = *MEMORY[0x1E4F35B60];
    do
    {
      uint64_t v24 = objc_msgSend_attributes(v6, v15, v16, v17);
      long long v27 = objc_msgSend_objectAtIndexedSubscript_(v24, v25, v18, v26);
      if (objc_msgSend_format(v27, v28, v29, v30))
      {
        uint64_t v34 = objc_msgSend_name(v27, v31, v32, v33);
        int v37 = objc_msgSend_containsString_(v34, v35, v21, v36);
        if (v20 & v37)
        {
          int v20 = 1;
        }
        else
        {
          v20 |= v37;
          uint64_t v38 = objc_msgSend_name(v27, v31, v32, v33);
          int v41 = objc_msgSend_containsString_(v38, v39, v22, v40);
          if (v19 & v41)
          {
            int v19 = 1;
          }
          else
          {
            v19 |= v41;
            uint64_t v42 = objc_msgSend_name(v27, v31, v32, v33);
            if ((objc_msgSend_containsString_(v42, v43, v23, v44) & 1) == 0)
            {
              uint64_t v45 = objc_msgSend_name(v27, v31, v32, v33);
              if ((objc_msgSend_containsString_(v45, v46, v73, v47) & 1) == 0)
              {
                uint64_t v48 = objc_msgSend_name(v27, v31, v32, v33);
                if ((objc_msgSend_hasSuffix_(v48, v49, @"UVi", v50) & 1) == 0)
                {
                  uint64_t v69 = (char *)v5;
                  uint64_t v51 = v4;
                  uint64_t v52 = objc_msgSend_name(v27, v31, v32, v33);
                  if (objc_msgSend_containsString_(v52, v53, v70, v54)
                    && (uint64_t v56 = objc_msgSend_objectForKeyedSubscript_(v4, v31, @"kSceneSourceUSDIgnoreVertexColors", v55), objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)&& (objc_msgSend_BOOLValue(v56, v31, v57, v58) & 1) != 0|| (v59 = objc_msgSend_geometrySourceWithMDLVertexAttribute_mesh_(VFXMeshSource, v31, (uint64_t)v27, (uint64_t)a3)) == 0)
                  {
                    uint64_t v4 = v51;
                    uint64_t v5 = v69;
                  }
                  else
                  {
                    objc_msgSend_addObject_(a1, v31, v59, v33);
                    uint64_t v62 = objc_msgSend_numberWithUnsignedInteger_(NSNumber, v60, v18, v61);
                    objc_msgSend_addObject_(v69, v63, v62, v64);
                    uint64_t v4 = v51;
                    uint64_t v5 = v69;
                  }
                }
              }
            }
          }
        }
      }
      ++v18;
      uint64_t v65 = objc_msgSend_attributes(v6, v31, v32, v33);
      unint64_t result = objc_msgSend_count(v65, v66, v67, v68);
    }
    while (v18 < result);
  }
  return result;
}

uint64_t sub_1B646CF8C(uint64_t result, uint64_t a2, void *a3, uint64_t a4)
{
  if (*(void *)(a2 + 16))
  {
    uint64_t v6 = (void *)result;
    uint64_t v7 = objc_msgSend_vertexDescriptor(a3, (const char *)a2, (uint64_t)a3, a4);
    uint64_t v17 = objc_msgSend_attributeNamed_(v7, v8, *MEMORY[0x1E4F35B90], v9);
    if (!v17) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v11, v12, v13, v14, v15, v16, (uint64_t)"positionAttribute");
    }
    unint64_t v18 = objc_msgSend_vertexBuffers(a3, v10, v11, v12);
    uint64_t v22 = objc_msgSend_bufferIndex(v17, v19, v20, v21);
    uint64_t v25 = objc_msgSend_objectAtIndexedSubscript_(v18, v23, v22, v24);
    unint64_t v29 = objc_msgSend_length(v25, v26, v27, v28);
    uint64_t v33 = objc_msgSend_vertexDescriptor(a3, v30, v31, v32);
    int v37 = objc_msgSend_layouts(v33, v34, v35, v36);
    uint64_t v41 = objc_msgSend_bufferIndex(v17, v38, v39, v40);
    uint64_t v44 = objc_msgSend_objectAtIndexedSubscript_(v37, v42, v41, v43);
    unint64_t v48 = v29 / objc_msgSend_stride(v44, v45, v46, v47);
    uint64_t v51 = objc_msgSend_dataWithLength_(MEMORY[0x1E4F1CA58], v49, 4 * v48, v50);
    objc_msgSend_setLength_(v51, v52, 4 * v48, v53);
    uint64_t v57 = objc_msgSend_mutableBytes(v51, v54, v55, v56);
    bzero(v57, 4 * v48);
    uint64_t v61 = *(void **)a2;
    uint64_t v60 = (void *)(a2 + 8);
    uint64_t v59 = v61;
    if (v61 != v60)
    {
      do
      {
        *((_DWORD *)v57 + *((unsigned int *)v59 + 7)) = *((_DWORD *)v59 + 8);
        uint64_t v62 = (void *)v59[1];
        if (v62)
        {
          do
          {
            uint64_t v63 = v62;
            uint64_t v62 = (void *)*v62;
          }
          while (v62);
        }
        else
        {
          do
          {
            uint64_t v63 = (void *)v59[2];
            BOOL v64 = *v63 == (void)v59;
            uint64_t v59 = v63;
          }
          while (!v64);
        }
        uint64_t v59 = v63;
      }
      while (v63 != v60);
    }
    unint64_t result = objc_msgSend_meshSourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride_(VFXMeshSource, v58, (uint64_t)v51, @"kGeometrySourceSemanticVertexCrease", v48, 1, 1, 4, 0, 4);
    if (result)
    {
      return objc_msgSend_addObject_(v6, v65, result, v66);
    }
  }
  return result;
}

uint64_t sub_1B646D150(uint64_t result, char *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 16);
  if (v4)
  {
    uint64_t v7 = (void *)result;
    uint64_t v8 = 4 * v4;
    uint64_t v9 = objc_msgSend_dataWithLength_(MEMORY[0x1E4F1CA58], a2, 4 * v4, a4);
    objc_msgSend_setLength_(v9, v10, v8, v11);
    uint64_t v15 = objc_msgSend_mutableBytes(v9, v12, v13, v14);
    uint64_t v16 = 8 * v7[2];
    int v19 = objc_msgSend_dataWithLength_(MEMORY[0x1E4F1CA58], v17, v16, v18);
    objc_msgSend_setLength_(v19, v20, v16, v21);
    uint64_t v25 = objc_msgSend_mutableBytes(v19, v22, v23, v24);
    uint64_t v27 = (void *)*v7;
    if ((void *)*v7 != v7 + 1)
    {
      unsigned int v28 = 0;
      do
      {
        uint64_t v29 = v27[4];
        *(_DWORD *)(v25 + 8 * v28) = HIDWORD(v29);
        *(_DWORD *)(v25 + 4 * ((2 * v28) | 1)) = v29;
        *(_DWORD *)(v15 + 4 * v28) = *((_DWORD *)v27 + 10);
        uint64_t v30 = (void *)v27[1];
        if (v30)
        {
          do
          {
            uint64_t v31 = v30;
            uint64_t v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v31 = (void *)v27[2];
            BOOL v32 = *v31 == (void)v27;
            uint64_t v27 = v31;
          }
          while (!v32);
        }
        ++v28;
        uint64_t v27 = v31;
      }
      while (v31 != v7 + 1);
    }
    *(void *)a2 = objc_msgSend_meshSourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride_(VFXMeshSource, v26, (uint64_t)v9, @"kGeometrySourceSemanticEdgeCrease", v7[2], 1, 1, 4, 0, 4);
    unint64_t result = objc_msgSend_meshElementWithData_primitiveType_primitiveCount_bytesPerIndex_(VFXMeshElement, v33, (uint64_t)v19, 2, v7[2], 4);
    *a3 = result;
  }
  return result;
}

void sub_1B646D7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,void *a34,uint64_t a35,char a36,void *a37)
{
}

uint64_t sub_1B646DCE0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (!objc_msgSend_faceIndexing(a1, a2, a3, a4)) {
    return 0;
  }
  if (objc_msgSend_geometryType(a1, v5, v6, v7) != 5) {
    return 0;
  }
  uint64_t v11 = objc_msgSend_topology(a1, v8, v9, v10);
  if (!objc_msgSend_faceTopology(v11, v12, v13, v14)) {
    return 0;
  }
  uint64_t v18 = objc_msgSend_indexBuffer(a1, v15, v16, v17);
  if (!objc_msgSend_length(v18, v19, v20, v21)) {
    return 0;
  }
  unint64_t v28 = (unint64_t)objc_msgSend_indexType(a1, v22, v23, v24) >> 3;
  switch(v28)
  {
    case 4uLL:
      return sub_1B646E478(a1, v25, v26, v27);
    case 2uLL:
      return sub_1B646E120(a1, v25, v26, v27);
    case 1uLL:
      return sub_1B646DDC0(a1, v25, v26, v27);
    default:
      return 0;
  }
}

uint64_t sub_1B646DDC0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_topology(a1, a2, a3, a4);
  uint64_t v9 = objc_msgSend_faceTopology(v5, v6, v7, v8);
  uint64_t v13 = objc_msgSend_map(v9, v10, v11, v12);
  uint64_t v17 = objc_msgSend_bytes(v13, v14, v15, v16);
  if (!v17) {
    return 0;
  }
  uint64_t v21 = v17;
  uint64_t v22 = objc_msgSend_indexBuffer(a1, v18, v19, v20);
  uint64_t v26 = objc_msgSend_map(v22, v23, v24, v25);
  uint64_t v30 = objc_msgSend_bytes(v26, v27, v28, v29);
  if (!v30) {
    return 0;
  }
  uint64_t v34 = v30;
  uint64_t v35 = objc_msgSend_topology(a1, v31, v32, v33);
  uint64_t v39 = objc_msgSend_faceCount(v35, v36, v37, v38);
  uint64_t v43 = objc_msgSend_indexBuffer(a1, v40, v41, v42);
  uint64_t v47 = objc_msgSend_length(v43, v44, v45, v46);
  __p = 0;
  uint64_t v107 = 0;
  uint64_t v108 = 0;
  sub_1B6470E40((unint64_t *)&__p, v47 + v39);
  uint64_t v104 = v39;
  if (v39)
  {
    uint64_t v49 = 0;
    uint64_t v50 = v107;
    do
    {
      char v51 = *(unsigned char *)(v21 + v49);
      if (v50 >= v108)
      {
        unint64_t v53 = (unint64_t)__p;
        int64_t v54 = v50 - (unsigned char *)__p;
        uint64_t v55 = v50 - (unsigned char *)__p + 1;
        if (v55 < 0) {
          abort();
        }
        unint64_t v56 = v108 - (unsigned char *)__p;
        if (2 * (v108 - (unsigned char *)__p) > (unint64_t)v55) {
          uint64_t v55 = 2 * v56;
        }
        if (v56 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v57 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v57 = v55;
        }
        if (v57) {
          uint64_t v58 = (char *)operator new(v57);
        }
        else {
          uint64_t v58 = 0;
        }
        uint64_t v59 = &v58[v54];
        uint64_t v60 = &v58[v54];
        *uint64_t v60 = v51;
        uint64_t v52 = v60 + 1;
        if (v50 != (char *)v53)
        {
          uint64_t v61 = &v50[~v53];
          do
          {
            char v62 = *--v50;
            (v61--)[(void)v58] = v62;
          }
          while (v50 != (char *)v53);
          uint64_t v50 = (char *)__p;
          uint64_t v59 = v58;
        }
        __p = v59;
        uint64_t v107 = v52;
        uint64_t v108 = &v58[v57];
        if (v50) {
          operator delete(v50);
        }
        uint64_t v39 = v104;
      }
      else
      {
        *uint64_t v50 = v51;
        uint64_t v52 = v50 + 1;
      }
      uint64_t v107 = v52;
      ++v49;
      uint64_t v50 = v52;
    }
    while (v49 != v39);
  }
  if (v47)
  {
    uint64_t v63 = 0;
    BOOL v64 = v107;
    do
    {
      if (v64 >= v108)
      {
        unint64_t v66 = (unint64_t)__p;
        int64_t v67 = v64 - (unsigned char *)__p;
        uint64_t v68 = v64 - (unsigned char *)__p + 1;
        if (v68 < 0) {
          abort();
        }
        unint64_t v69 = v108 - (unsigned char *)__p;
        if (2 * (v108 - (unsigned char *)__p) > (unint64_t)v68) {
          uint64_t v68 = 2 * v69;
        }
        if (v69 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v70 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v70 = v68;
        }
        if (v70) {
          uint64_t v71 = (char *)operator new(v70);
        }
        else {
          uint64_t v71 = 0;
        }
        uint64_t v72 = &v71[v67];
        v71[v67] = *(unsigned char *)(v34 + v63);
        uint64_t v65 = (uint64_t)&v71[v67 + 1];
        if (v64 != (char *)v66)
        {
          uint64_t v73 = &v64[~v66];
          do
          {
            char v74 = *--v64;
            (v73--)[(void)v71] = v74;
          }
          while (v64 != (char *)v66);
          BOOL v64 = (char *)__p;
          uint64_t v72 = v71;
        }
        __p = v72;
        uint64_t v107 = &v71[v67 + 1];
        uint64_t v108 = &v71[v70];
        if (v64) {
          operator delete(v64);
        }
      }
      else
      {
        *BOOL v64 = *(unsigned char *)(v34 + v63);
        uint64_t v65 = (uint64_t)(v64 + 1);
      }
      uint64_t v107 = (char *)v65;
      ++v63;
      BOOL v64 = (char *)v65;
    }
    while (v63 != v47);
  }
  else
  {
    uint64_t v65 = (uint64_t)v107;
  }
  uint64_t v79 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], v48, (uint64_t)__p, v65 - (void)__p, v104);
  unint64_t v80 = 0;
  for (unint64_t i = 0; ; ++i)
  {
    uint64_t v82 = objc_msgSend_faceIndexing(a1, v76, v77, v78);
    if (i >= objc_msgSend_count(v82, v83, v84, v85)) {
      break;
    }
    long long v89 = objc_msgSend_faceIndexing(a1, v86, v87, v88);
    long long v92 = objc_msgSend_objectAtIndexedSubscript_(v89, v90, i, v91);
    if (v80 < objc_msgSend_unsignedIntValue(v92, v93, v94, v95))
    {
      long long v96 = objc_msgSend_faceIndexing(a1, v76, v77, v78);
      uint64_t v99 = objc_msgSend_objectAtIndexedSubscript_(v96, v97, i, v98);
      unint64_t v80 = objc_msgSend_unsignedIntValue(v99, v100, v101, v102);
    }
  }
  uint64_t v75 = objc_msgSend_meshElementWithData_primitiveType_primitiveCount_indicesChannelCount_interleavedIndicesChannels_bytesPerIndex_(VFXMeshElement, v86, v79, 4, v105, v80 + 1, 1, 1);
  if (__p)
  {
    uint64_t v107 = (char *)__p;
    operator delete(__p);
  }
  return v75;
}

void sub_1B646E0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B646E120(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_topology(a1, a2, a3, a4);
  uint64_t v9 = objc_msgSend_faceTopology(v5, v6, v7, v8);
  uint64_t v13 = objc_msgSend_map(v9, v10, v11, v12);
  uint64_t v17 = objc_msgSend_bytes(v13, v14, v15, v16);
  if (!v17) {
    return 0;
  }
  uint64_t v21 = v17;
  uint64_t v22 = objc_msgSend_indexBuffer(a1, v18, v19, v20);
  uint64_t v26 = objc_msgSend_map(v22, v23, v24, v25);
  uint64_t v30 = objc_msgSend_bytes(v26, v27, v28, v29);
  if (!v30) {
    return 0;
  }
  uint64_t v34 = v30;
  uint64_t v35 = objc_msgSend_topology(a1, v31, v32, v33);
  uint64_t v39 = objc_msgSend_faceCount(v35, v36, v37, v38);
  uint64_t v43 = objc_msgSend_indexBuffer(a1, v40, v41, v42);
  __p = 0;
  uint64_t v101 = 0;
  uint64_t v102 = 0;
  unint64_t v99 = objc_msgSend_length(v43, v44, v45, v46);
  sub_1B6470EF8(&__p, v39 + (v99 >> 1));
  if (v39)
  {
    uint64_t v48 = 0;
    uint64_t v49 = v101;
    do
    {
      __int16 v50 = *(unsigned __int8 *)(v21 + v48);
      if (v49 >= v102)
      {
        uint64_t v52 = (char *)__p;
        uint64_t v53 = v49 - (unsigned char *)__p;
        if (v49 - (unsigned char *)__p <= -3) {
          abort();
        }
        uint64_t v54 = v53 >> 1;
        if (v102 - (unsigned char *)__p <= (unint64_t)((v53 >> 1) + 1)) {
          uint64_t v55 = v54 + 1;
        }
        else {
          uint64_t v55 = v102 - (unsigned char *)__p;
        }
        if ((unint64_t)(v102 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v47 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v47 = v55;
        }
        if (v47)
        {
          unint64_t v56 = (char *)sub_1B645A9E0((uint64_t)&v102, v47);
          uint64_t v52 = (char *)__p;
          uint64_t v49 = v101;
        }
        else
        {
          unint64_t v56 = 0;
        }
        size_t v57 = &v56[2 * v54];
        *(_WORD *)size_t v57 = v50;
        char v51 = v57 + 2;
        while (v49 != v52)
        {
          __int16 v58 = *((_WORD *)v49 - 1);
          v49 -= 2;
          *((_WORD *)v57 - 1) = v58;
          v57 -= 2;
        }
        __p = v57;
        uint64_t v101 = v51;
        uint64_t v102 = &v56[2 * v47];
        if (v52) {
          operator delete(v52);
        }
      }
      else
      {
        *(_WORD *)uint64_t v49 = v50;
        char v51 = v49 + 2;
      }
      uint64_t v101 = v51;
      ++v48;
      uint64_t v49 = v51;
    }
    while (v48 != v39);
  }
  if (v99 > 1)
  {
    uint64_t v61 = 0;
    if (v99 >> 1 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v99 >> 1;
    }
    uint64_t v63 = v101;
    do
    {
      if (v63 >= v102)
      {
        BOOL v64 = (char *)__p;
        uint64_t v65 = v63 - (unsigned char *)__p;
        if (v63 - (unsigned char *)__p <= -3) {
          abort();
        }
        uint64_t v66 = v65 >> 1;
        if (v102 - (unsigned char *)__p <= (unint64_t)((v65 >> 1) + 1)) {
          uint64_t v67 = v66 + 1;
        }
        else {
          uint64_t v67 = v102 - (unsigned char *)__p;
        }
        if ((unint64_t)(v102 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v47 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v47 = v67;
        }
        if (v47)
        {
          uint64_t v68 = (char *)sub_1B645A9E0((uint64_t)&v102, v47);
          BOOL v64 = (char *)__p;
          uint64_t v63 = v101;
        }
        else
        {
          uint64_t v68 = 0;
        }
        unint64_t v69 = &v68[2 * v66];
        *(_WORD *)unint64_t v69 = *(_WORD *)(v34 + 2 * v61);
        uint64_t v59 = v69 + 2;
        while (v63 != v64)
        {
          __int16 v70 = *((_WORD *)v63 - 1);
          v63 -= 2;
          *((_WORD *)v69 - 1) = v70;
          v69 -= 2;
        }
        __p = v69;
        uint64_t v101 = v59;
        uint64_t v102 = &v68[2 * v47];
        if (v64) {
          operator delete(v64);
        }
      }
      else
      {
        *(_WORD *)uint64_t v63 = *(_WORD *)(v34 + 2 * v61);
        uint64_t v59 = v63 + 2;
      }
      uint64_t v101 = v59;
      ++v61;
      uint64_t v63 = v59;
    }
    while (v61 != v62);
  }
  else
  {
    uint64_t v59 = v101;
  }
  uint64_t v74 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], (const char *)v47, (uint64_t)__p, v59 - (unsigned char *)__p, v99);
  unint64_t v75 = 0;
  for (unint64_t i = 0; ; ++i)
  {
    uint64_t v77 = objc_msgSend_faceIndexing(a1, v71, v72, v73);
    if (i >= objc_msgSend_count(v77, v78, v79, v80)) {
      break;
    }
    uint64_t v84 = objc_msgSend_faceIndexing(a1, v81, v82, v83);
    uint64_t v87 = objc_msgSend_objectAtIndexedSubscript_(v84, v85, i, v86);
    if (v75 < objc_msgSend_unsignedIntValue(v87, v88, v89, v90))
    {
      uint64_t v91 = objc_msgSend_faceIndexing(a1, v71, v72, v73);
      uint64_t v94 = objc_msgSend_objectAtIndexedSubscript_(v91, v92, i, v93);
      unint64_t v75 = objc_msgSend_unsignedIntValue(v94, v95, v96, v97);
    }
  }
  uint64_t v60 = objc_msgSend_meshElementWithData_primitiveType_primitiveCount_indicesChannelCount_interleavedIndicesChannels_bytesPerIndex_(VFXMeshElement, v81, v74, 4, v39, v75 + 1, 1, 2);
  if (__p)
  {
    uint64_t v101 = (char *)__p;
    operator delete(__p);
  }
  return v60;
}

void sub_1B646E440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B646E478(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_topology(a1, a2, a3, a4);
  uint64_t v9 = objc_msgSend_faceTopology(v5, v6, v7, v8);
  uint64_t v13 = objc_msgSend_map(v9, v10, v11, v12);
  uint64_t v17 = objc_msgSend_bytes(v13, v14, v15, v16);
  if (!v17) {
    return 0;
  }
  uint64_t v21 = v17;
  uint64_t v22 = objc_msgSend_indexBuffer(a1, v18, v19, v20);
  uint64_t v26 = objc_msgSend_map(v22, v23, v24, v25);
  uint64_t v30 = objc_msgSend_bytes(v26, v27, v28, v29);
  if (!v30) {
    return 0;
  }
  uint64_t v34 = v30;
  uint64_t v35 = objc_msgSend_topology(a1, v31, v32, v33);
  uint64_t v39 = objc_msgSend_faceCount(v35, v36, v37, v38);
  uint64_t v43 = objc_msgSend_indexBuffer(a1, v40, v41, v42);
  __p = 0;
  uint64_t v101 = 0;
  uint64_t v102 = 0;
  unint64_t v99 = objc_msgSend_length(v43, v44, v45, v46);
  sub_1B6427A50(&__p, v39 + (v99 >> 2));
  if (v39)
  {
    uint64_t v48 = 0;
    uint64_t v49 = v101;
    do
    {
      int v50 = *(unsigned __int8 *)(v21 + v48);
      if (v49 >= v102)
      {
        uint64_t v52 = (char *)__p;
        uint64_t v53 = (v49 - (unsigned char *)__p) >> 2;
        unint64_t v54 = v53 + 1;
        if ((unint64_t)(v53 + 1) >> 62) {
          abort();
        }
        uint64_t v55 = v102 - (unsigned char *)__p;
        if ((v102 - (unsigned char *)__p) >> 1 > v54) {
          unint64_t v54 = v55 >> 1;
        }
        if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v47 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v47 = v54;
        }
        if (v47)
        {
          unint64_t v56 = (char *)sub_1B64282E0((uint64_t)&v102, v47);
          uint64_t v52 = (char *)__p;
          uint64_t v49 = v101;
        }
        else
        {
          unint64_t v56 = 0;
        }
        size_t v57 = &v56[4 * v53];
        *(_DWORD *)size_t v57 = v50;
        char v51 = v57 + 4;
        while (v49 != v52)
        {
          int v58 = *((_DWORD *)v49 - 1);
          v49 -= 4;
          *((_DWORD *)v57 - 1) = v58;
          v57 -= 4;
        }
        __p = v57;
        uint64_t v101 = v51;
        uint64_t v102 = &v56[4 * v47];
        if (v52) {
          operator delete(v52);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v49 = v50;
        char v51 = v49 + 4;
      }
      uint64_t v101 = v51;
      ++v48;
      uint64_t v49 = v51;
    }
    while (v48 != v39);
  }
  if (v99 > 3)
  {
    uint64_t v61 = 0;
    if (v99 >> 2 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v99 >> 2;
    }
    uint64_t v63 = v101;
    do
    {
      if (v63 >= v102)
      {
        BOOL v64 = (char *)__p;
        uint64_t v65 = (v63 - (unsigned char *)__p) >> 2;
        unint64_t v66 = v65 + 1;
        if ((unint64_t)(v65 + 1) >> 62) {
          abort();
        }
        uint64_t v67 = v102 - (unsigned char *)__p;
        if ((v102 - (unsigned char *)__p) >> 1 > v66) {
          unint64_t v66 = v67 >> 1;
        }
        if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v47 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v47 = v66;
        }
        if (v47)
        {
          uint64_t v68 = (char *)sub_1B64282E0((uint64_t)&v102, v47);
          BOOL v64 = (char *)__p;
          uint64_t v63 = v101;
        }
        else
        {
          uint64_t v68 = 0;
        }
        unint64_t v69 = &v68[4 * v65];
        *(_DWORD *)unint64_t v69 = *(_DWORD *)(v34 + 4 * v61);
        uint64_t v59 = v69 + 4;
        while (v63 != v64)
        {
          int v70 = *((_DWORD *)v63 - 1);
          v63 -= 4;
          *((_DWORD *)v69 - 1) = v70;
          v69 -= 4;
        }
        __p = v69;
        uint64_t v101 = v59;
        uint64_t v102 = &v68[4 * v47];
        if (v64) {
          operator delete(v64);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v63 = *(_DWORD *)(v34 + 4 * v61);
        uint64_t v59 = v63 + 4;
      }
      uint64_t v101 = v59;
      ++v61;
      uint64_t v63 = v59;
    }
    while (v61 != v62);
  }
  else
  {
    uint64_t v59 = v101;
  }
  uint64_t v74 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E4F1C9B8], (const char *)v47, (uint64_t)__p, v59 - (unsigned char *)__p, v99);
  unint64_t v75 = 0;
  for (unint64_t i = 0; ; ++i)
  {
    uint64_t v77 = objc_msgSend_faceIndexing(a1, v71, v72, v73);
    if (i >= objc_msgSend_count(v77, v78, v79, v80)) {
      break;
    }
    uint64_t v84 = objc_msgSend_faceIndexing(a1, v81, v82, v83);
    uint64_t v87 = objc_msgSend_objectAtIndexedSubscript_(v84, v85, i, v86);
    if (v75 < objc_msgSend_unsignedIntValue(v87, v88, v89, v90))
    {
      uint64_t v91 = objc_msgSend_faceIndexing(a1, v71, v72, v73);
      uint64_t v94 = objc_msgSend_objectAtIndexedSubscript_(v91, v92, i, v93);
      unint64_t v75 = objc_msgSend_unsignedIntValue(v94, v95, v96, v97);
    }
  }
  uint64_t v60 = objc_msgSend_meshElementWithData_primitiveType_primitiveCount_indicesChannelCount_interleavedIndicesChannels_bytesPerIndex_(VFXMeshElement, v81, v74, 4, v39, v75 + 1, 1, 4);
  if (__p)
  {
    uint64_t v101 = (char *)__p;
    operator delete(__p);
  }
  return v60;
}

void sub_1B646E7A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1B646F084(void *result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!result) {
    return result;
  }
  int v6 = a4;
  uint64_t v7 = result;
  uint64_t v8 = objc_msgSend_propertyWithSemantic_(a2, (const char *)a2, a3, a4);
  if (objc_msgSend_type(v8, v9, v10, v11) == 2 && objc_msgSend_URLValue(v8, v12, v13, v14))
  {
    uint64_t v15 = objc_msgSend_URLValue(v8, v12, v13, v14);
LABEL_32:
    objc_msgSend_setContents_(v7, v16, v15, v17);
    goto LABEL_33;
  }
  if (objc_msgSend_type(v8, v12, v13, v14) == 1 && objc_msgSend_stringValue(v8, v18, v19, v20))
  {
    if (!objc_msgSend_URLValue(v8, v18, v19, v20))
    {
      uint64_t v133 = objc_msgSend_stringValue(v8, v21, v22, v23);
      if (!objc_msgSend_length(v133, v134, v135, v136)) {
        goto LABEL_33;
      }
      uint64_t v15 = objc_msgSend_stringValue(v8, v84, v85, v86);
      goto LABEL_32;
    }
    uint64_t v24 = objc_msgSend_URLValue(v8, v21, v22, v23);
    uint64_t v28 = objc_msgSend_path(v24, v25, v26, v27);
    if (objc_msgSend_stringValue(v8, v29, v30, v31)
      && (uint64_t v35 = objc_msgSend_pathExtension(v28, v32, v33, v34),
          objc_msgSend_isEqualToString_(v35, v36, @"usdz", v37))
      && (uint64_t v38 = objc_msgSend_currentThread(MEMORY[0x1E4F29060], v32, v33, v34),
          uint64_t v42 = objc_msgSend_threadDictionary(v38, v39, v40, v41),
          (uint64_t v45 = objc_msgSend_valueForKey_(v42, v43, @"VFX_MDLCurrentAssetResolver", v44)) != 0)
      && (uint64_t v46 = (void *)v45, (objc_opt_respondsToSelector() & 1) != 0)
      && (uint64_t v47 = objc_msgSend_stringValue(v8, v32, v33, v34),
          int v50 = objc_msgSend_resolveInsideArchiveWithAssetNamed_(v46, v48, v47, v49),
          (unint64_t)objc_msgSend_count(v50, v51, v52, v53) >= 2))
    {
      uint64_t v54 = objc_msgSend_fileURLWithPath_(MEMORY[0x1E4F1CB10], v32, (uint64_t)v28, v34);
      id v55 = objc_alloc(MEMORY[0x1E4F29088]);
      size_t v57 = objc_msgSend_initWithURL_resolvingAgainstBaseURL_(v55, v56, v54, 0);
      int v58 = NSString;
      uint64_t v61 = objc_msgSend_objectAtIndexedSubscript_(v50, v59, 0, v60);
      uint64_t v65 = objc_msgSend_intValue(v61, v62, v63, v64);
      uint64_t v68 = objc_msgSend_objectAtIndexedSubscript_(v50, v66, 1, v67);
      uint64_t v72 = objc_msgSend_intValue(v68, v69, v70, v71);
      uint64_t v75 = objc_msgSend_stringWithFormat_(v58, v73, @"offset=%d&size=%d", v74, v65, v72);
      objc_msgSend_setQuery_(v57, v76, v75, v77);
      uint64_t v81 = objc_msgSend_URL(v57, v78, v79, v80);
      objc_msgSend_setContents_(v7, v82, v81, v83);
    }
    else
    {
      uint64_t v110 = objc_msgSend_stringValue(v8, v32, v33, v34);
      uint64_t v114 = objc_msgSend_URLValue(v8, v111, v112, v113);
      objc_msgSend__setImagePath_withResolvedURL_(v7, v115, v110, v114);
    }
  }
  else if (objc_msgSend_type(v8, v18, v19, v20) == 3)
  {
    if (objc_msgSend_textureSamplerValue(v8, v87, v88, v89))
    {
      uint64_t v90 = objc_msgSend_textureSamplerValue(v8, v84, v85, v86);
      if (objc_msgSend_texture(v90, v91, v92, v93))
      {
        uint64_t v94 = objc_msgSend_textureSamplerValue(v8, v84, v85, v86);
        uint64_t v98 = objc_msgSend_texture(v94, v95, v96, v97);
        objc_msgSend_setContents_(v7, v99, v98, v100);
        goto LABEL_35;
      }
    }
  }
  else
  {
    if (objc_msgSend_type(v8, v87, v88, v89) == 8)
    {
      objc_msgSend_float4Value(v8, v101, v102, v103);
      uint64_t v15 = objc_msgSend_vfx_colorWithModelIORed_green_blue_alpha_options_(MEMORY[0x1E4FB1618], v108, a5, v109, v107, v104, v105, v106);
      goto LABEL_32;
    }
    if (objc_msgSend_type(v8, v101, v102, v103) == 7)
    {
      objc_msgSend_float3Value(v8, v116, v117, v118);
      long long v242 = v119;
      id v123 = objc_msgSend_propertyName(v7, v120, v121, v122);
      if (objc_msgSend_isEqualToString_(v123, v124, @"emission", v125)
        && *(float *)&v242 == 1.0
        && *((float *)&v242 + 1) == 1.0
        && *((float *)&v242 + 2) == 1.0)
      {
        sub_1B63F2F54(0, @"Warning: ignoring white emission color from ModelIO", v127, v128, v129, v130, v131, v132, v241);
        goto LABEL_33;
      }
      uint64_t v15 = objc_msgSend_vfx_colorWithModelIORed_green_blue_alpha_options_(MEMORY[0x1E4FB1618], v126, a5, v128, *(float *)&v242, *((float *)&v242 + 1), *((float *)&v242 + 2), 1.0);
      goto LABEL_32;
    }
    if (objc_msgSend_type(v8, v116, v117, v118) == 5)
    {
      objc_msgSend_floatValue(v8, v137, v138, v139);
      uint64_t v15 = objc_msgSend_numberWithFloat_(NSNumber, v140, v141, v142);
      goto LABEL_32;
    }
    if (objc_msgSend_type(v8, v137, v138, v139) == 4)
    {
      float32x4_t v237 = (void *)MEMORY[0x1E4FB1618];
      uint64_t v238 = objc_msgSend_color(v8, v84, v85, v86);
      uint64_t v15 = objc_msgSend_colorWithCGColor_(v237, v239, v238, v240);
      goto LABEL_32;
    }
  }
LABEL_33:
  if (v6)
  {
    objc_msgSend_setWrapS_(v7, v84, 2, v86);
    objc_msgSend_setWrapT_(v7, v143, 2, v144);
  }
LABEL_35:
  unint64_t result = objc_msgSend_textureSamplerValue(v8, v84, v85, v86);
  if (result)
  {
    uint64_t v148 = objc_msgSend_textureSamplerValue(v8, v145, v146, v147);
    unsigned int v152 = objc_msgSend_textureComponents(v148, v149, v150, v151);
    objc_msgSend_setTextureComponents_(v7, v153, __rbit32(v152) >> 28, v154);
    uint64_t v158 = objc_msgSend_textureSamplerValue(v8, v155, v156, v157);
    uint64_t v162 = objc_msgSend_mappingChannel(v158, v159, v160, v161);
    objc_msgSend_setMappingChannel_(v7, v163, v162, v164);
    uint64_t v168 = objc_msgSend_textureSamplerValue(v8, v165, v166, v167);
    if (objc_msgSend_transform(v168, v169, v170, v171))
    {
      uint64_t v175 = objc_msgSend_textureSamplerValue(v8, v172, v173, v174);
      uint64_t v179 = objc_msgSend_transform(v175, v176, v177, v178);
      objc_msgSend_matrix(v179, v180, v181, v182);
      uint64_t v187 = 0;
      int8x16_t v189 = (int8x16_t)vmulq_f32(v188, v188);
      int32x2_t v190 = (int32x2_t)vextq_s8(v189, v189, 8uLL).u64[0];
      *(float *)v190.i32 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v189.i8, (float32x2_t)v190)));
      int8x16_t v192 = (int8x16_t)vmulq_f32(v191, v191);
      int32x2_t v193 = (int32x2_t)vextq_s8(v192, v192, 8uLL).u64[0];
      *(float *)v193.i32 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v192.i8, (float32x2_t)v193)));
      int8x16_t v194 = (int8x16_t)vmulq_f32(v186, v186);
      int32x2_t v195 = (int32x2_t)vextq_s8(v194, v194, 8uLL).u64[0];
      *(float *)v195.i32 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v194.i8, (float32x2_t)v195)));
      float32x4_t v196 = vdivq_f32(v188, (float32x4_t)vdupq_lane_s32(v190, 0));
      float32x4_t v197 = vdivq_f32(v191, (float32x4_t)vdupq_lane_s32(v193, 0));
      float32x4_t v198 = *(float32x4_t *)MEMORY[0x1E4F149A0];
      float32x4_t v199 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 16);
      float32x4_t v200 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 32);
      float32x4_t v201 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48);
      LODWORD(v203) = v202.i32[0];
      DWORD1(v203) = vnegq_f32(v202).i32[1];
      *((void *)&v203 + 1) = __PAIR64__(1.0, v202.u32[2]);
      long long v243 = *MEMORY[0x1E4F149A0];
      float32x4_t v244 = v199;
      float32x4_t v245 = v200;
      long long v246 = v203;
      do
      {
        *(long long *)((char *)&v247 + v187) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v198, COERCE_FLOAT(*(long long *)((char *)&v243 + v187))), v199, *(float32x2_t *)((char *)&v243 + v187), 1), v200, *(float32x4_t *)((char *)&v243 + v187), 2), (float32x4_t)xmmword_1B6E50D70, *(float32x4_t *)((char *)&v243 + v187), 3);
        v187 += 16;
      }
      while (v187 != 64);
      uint64_t v204 = 0;
      float32x4_t v205 = vdivq_f32(v186, (float32x4_t)vdupq_lane_s32(v195, 0));
      v196.i32[1] = vnegq_f32(v196).i32[1];
      v197.f32[0] = -v197.f32[0];
      long long v243 = v247;
      float32x4_t v244 = v248;
      float32x4_t v245 = v249;
      long long v246 = v250;
      do
      {
        *(long long *)((char *)&v247 + v204) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v196, COERCE_FLOAT(*(long long *)((char *)&v243 + v204))), v197, *(float32x2_t *)((char *)&v243 + v204), 1), v205, *(float32x4_t *)((char *)&v243 + v204), 2), v201, *(float32x4_t *)((char *)&v243 + v204), 3);
        v204 += 16;
      }
      while (v204 != 64);
      uint64_t v206 = 0;
      v207.i32[0] = 0;
      v207.i64[1] = 0;
      v207.i32[1] = v193.i32[0];
      v208.i64[0] = 0;
      v208.i64[1] = v195.u32[0];
      long long v243 = v247;
      float32x4_t v244 = v248;
      float32x4_t v245 = v249;
      long long v246 = v250;
      do
      {
        *(long long *)((char *)&v247 + v206) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v190.u32[0], COERCE_FLOAT(*(long long *)((char *)&v243 + v206))), v207, *(float32x2_t *)((char *)&v243 + v206), 1), v208, *(float32x4_t *)((char *)&v243 + v206), 2), (float32x4_t)xmmword_1B6E4F370, *(float32x4_t *)((char *)&v243 + v206), 3);
        v206 += 16;
      }
      while (v206 != 64);
      uint64_t v209 = 0;
      long long v243 = v247;
      float32x4_t v244 = v248;
      float32x4_t v245 = v249;
      long long v246 = v250;
      do
      {
        *(long long *)((char *)&v247 + v209) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v198, COERCE_FLOAT(*(long long *)((char *)&v243 + v209))), v199, *(float32x2_t *)((char *)&v243 + v209), 1), v200, *(float32x4_t *)((char *)&v243 + v209), 2), (float32x4_t)xmmword_1B6E4F3A0, *(float32x4_t *)((char *)&v243 + v209), 3);
        v209 += 16;
      }
      while (v209 != 64);
      objc_msgSend_setContentsTransform_(v7, v183, v184, v185, *(double *)&v247, *(double *)v248.i64, *(double *)v249.i64, *(double *)&v250);
    }
    uint64_t v210 = objc_msgSend_textureSamplerValue(v8, v172, v173, v174);
    unint64_t result = objc_msgSend_hardwareFilter(v210, v211, v212, v213);
    if (result)
    {
      uint64_t v217 = result;
      unint64_t v218 = objc_msgSend_sWrapMode(result, v214, v215, v216);
      if (v218 <= 2) {
        objc_msgSend_setWrapS_(v7, v219, qword_1B6E50DC0[v218], v221);
      }
      unint64_t v222 = objc_msgSend_tWrapMode(v217, v219, v220, v221);
      if (v222 <= 2) {
        objc_msgSend_setWrapT_(v7, v223, qword_1B6E50DC0[v222], v225);
      }
      uint64_t v226 = objc_msgSend_minFilter(v217, v223, v224, v225);
      if (v226)
      {
        if (v226 == 1) {
          objc_msgSend_setMinificationFilter_(v7, v227, 2, v229);
        }
      }
      else
      {
        objc_msgSend_setMinificationFilter_(v7, v227, 1, v229);
      }
      uint64_t v230 = objc_msgSend_magFilter(v217, v227, v228, v229);
      if (v230)
      {
        if (v230 == 1) {
          objc_msgSend_setMagnificationFilter_(v7, v231, 2, v233);
        }
      }
      else
      {
        objc_msgSend_setMagnificationFilter_(v7, v231, 1, v233);
      }
      unint64_t result = objc_msgSend_mipFilter(v217, v231, v232, v233);
      if (result)
      {
        if (result != (void *)1) {
          return result;
        }
        uint64_t v236 = 2;
      }
      else
      {
        uint64_t v236 = 1;
      }
      return objc_msgSend_setMipFilter_(v7, v234, v236, v235);
    }
  }
  return result;
}

uint64_t sub_1B646FB2C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v134 = *MEMORY[0x1E4F143B8];
  id AssociatedObject = objc_getAssociatedObject(a1, @"VFXMDLAssociatedObject");
  if (AssociatedObject)
  {
    uint64_t v11 = AssociatedObject;
    long long v128 = 0u;
    long long v129 = 0u;
    long long v126 = 0u;
    long long v127 = 0u;
    obuint64_t j = (id)objc_msgSend_children(a1, v8, v9, v10);
    uint64_t v13 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v12, (uint64_t)&v126, (uint64_t)v133, 16);
    if (v13)
    {
      uint64_t v14 = v13;
      char v15 = 0;
      uint64_t v16 = *(void *)v127;
      unint64_t v17 = 0x1E4F1C000uLL;
      uint64_t v105 = a3;
      uint64_t v104 = *(void *)v127;
      do
      {
        uint64_t v18 = 0;
        uint64_t v106 = v14;
        do
        {
          if (*(void *)v127 != v16) {
            objc_enumerationMutation(obj);
          }
          uint64_t v19 = *(void **)(*((void *)&v126 + 1) + 8 * v18);
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v108 = v18;
            if (v15) {
              sub_1B63F2F54(16, @"Error: a MDLObject has more than 1 child mesh - not supported", v21, v22, v23, v24, v25, v26, v102);
            }
            uint64_t v27 = objc_msgSend_model(v11, v20, v21, v22);
            id v31 = (id)objc_msgSend_materials(v27, v28, v29, v30);
            uint64_t v34 = objc_msgSend_modelWithMDLMesh_(VFXModel, v32, (uint64_t)v19, v33);
            uint64_t v109 = v31;
            uint64_t v110 = objc_msgSend_array(*(void **)(v17 + 2632), v35, v36, v37);
            uint64_t v38 = *(void **)(v17 + 2632);
            uint64_t v42 = objc_msgSend_count(v31, v39, v40, v41);
            uint64_t v45 = objc_msgSend_arrayWithCapacity_(v38, v43, v42, v44);
            long long v122 = 0u;
            long long v123 = 0u;
            long long v124 = 0u;
            long long v125 = 0u;
            uint64_t v49 = objc_msgSend_submeshes(v19, v46, v47, v48);
            uint64_t v51 = objc_msgSend_countByEnumeratingWithState_objects_count_(v49, v50, (uint64_t)&v122, (uint64_t)v132, 16);
            if (v51)
            {
              uint64_t v55 = v51;
              uint64_t v56 = *(void *)v123;
              do
              {
                for (uint64_t i = 0; i != v55; ++i)
                {
                  if (*(void *)v123 != v56) {
                    objc_enumerationMutation(v49);
                  }
                  int v58 = *(void **)(*((void *)&v122 + 1) + 8 * i);
                  if (objc_msgSend_material(v58, v52, v53, v54) && objc_msgSend_indexCount(v58, v52, v53, v54))
                  {
                    uint64_t v59 = objc_msgSend_material(v58, v52, v53, v54);
                    objc_msgSend_addObject_(v45, v60, v59, v61);
                  }
                }
                uint64_t v55 = objc_msgSend_countByEnumeratingWithState_objects_count_(v49, v52, (uint64_t)&v122, (uint64_t)v132, 16);
              }
              while (v55);
            }
            uint64_t v62 = *(void **)(v17 + 2632);
            uint64_t v63 = objc_msgSend_count(v109, v52, v53, v54);
            unint64_t v66 = objc_msgSend_arrayWithCapacity_(v62, v64, v63, v65);
            id v67 = objc_alloc(MEMORY[0x1E4F28E78]);
            uint64_t v70 = objc_msgSend_initWithString_(v67, v68, (uint64_t)&stru_1F0FCDBB0, v69);
            long long v118 = 0u;
            long long v119 = 0u;
            long long v120 = 0u;
            long long v121 = 0u;
            uint64_t v72 = objc_msgSend_countByEnumeratingWithState_objects_count_(v45, v71, (uint64_t)&v118, (uint64_t)v131, 16);
            if (v72)
            {
              uint64_t v73 = v72;
              uint64_t v74 = *(void *)v119;
              do
              {
                for (uint64_t j = 0; j != v73; ++j)
                {
                  if (*(void *)v119 != v74) {
                    objc_enumerationMutation(v45);
                  }
                  uint64_t v76 = *(void **)(*((void *)&v118 + 1) + 8 * j);
                  id v77 = objc_getAssociatedObject(v76, @"VFXMDLAssociatedObject");
                  if (v77)
                  {
                    uint64_t v85 = objc_msgSend_copy(v77, v78, v79, v80);
                    uint64_t v102 = (uint64_t)v70;
                    uint64_t v87 = objc_msgSend__integrateModelKitComputedMaps_withGeometry_node_texturePathProvider_vertexAttributeNamed_materialPropertyNamed_filePath_(v85, v86, (uint64_t)v76, (uint64_t)v34, v11, a4, a5, a6);
                    if (v87) {
                      objc_msgSend_addObject_(v110, v88, v87, v89);
                    }
                    objc_msgSend_addObject_(v66, v88, (uint64_t)v85, v89);
                  }
                  else
                  {
                    sub_1B63F2F54(16, @"Error: failed to find MKMaterial corresponding VFXMaterial", v79, v80, v81, v82, v83, v84, v102);
                  }
                }
                uint64_t v73 = objc_msgSend_countByEnumeratingWithState_objects_count_(v45, v90, (uint64_t)&v118, (uint64_t)v131, 16);
              }
              while (v73);
            }

            objc_msgSend_setMaterials_(v34, v91, (uint64_t)v66, v92);
            a3 = v105;
            if (v105) {
              (*(void (**)(uint64_t, void *, void *, void *))(v105 + 16))(v105, v11, v34, v110);
            }
            else {
              objc_msgSend_setModel_(v11, v93, (uint64_t)v34, v94);
            }
            uint64_t v14 = v106;
            uint64_t v16 = v104;
            unint64_t v17 = 0x1E4F1C000;
            uint64_t v18 = v108;

            char v15 = 1;
          }
          ++v18;
        }
        while (v18 != v14);
        uint64_t v14 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v20, (uint64_t)&v126, (uint64_t)v133, 16);
      }
      while (v14);
    }
  }
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  uint64_t v95 = objc_msgSend_children(a1, v8, v9, v10);
  uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v95, v96, (uint64_t)&v114, (uint64_t)v130, 16);
  if (result)
  {
    uint64_t v99 = result;
    uint64_t v100 = *(void *)v115;
    do
    {
      uint64_t v101 = 0;
      do
      {
        if (*(void *)v115 != v100) {
          objc_enumerationMutation(v95);
        }
        objc_msgSend__updateAssociatedVFXNodeWithGeometrySetter_texturePathProvider_vertexAttributeNamed_materialPropertyNamed_(*(void **)(*((void *)&v114 + 1) + 8 * v101++), v98, a3, a4, a5, a6);
      }
      while (v99 != v101);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v95, v98, (uint64_t)&v114, (uint64_t)v130, 16);
      uint64_t v99 = result;
    }
    while (result);
  }
  return result;
}

char *sub_1B646FFA4(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  uint64_t result = (char *)sub_1B64282E0((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

char *sub_1B646FFE4(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)sub_1B64285D4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *sub_1B6470024(void *a1, const char *a2, uint64_t a3, uint64_t a4, double a5, double a6)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (void *)MEMORY[0x1E4F1CA48];
  uint64_t v10 = objc_msgSend_count(a1, a2, a3, a4);
  uint64_t v13 = objc_msgSend_arrayWithCapacity_(v9, v11, v10, v12);
  unint64_t v17 = objc_msgSend_count(a1, v14, v15, v16);
  if (a6 != 0.0 && v17 > 1)
  {
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v25 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v18, (uint64_t)&v40, (uint64_t)v44, 16);
    if (v25)
    {
      uint64_t v29 = v25;
      uint64_t v30 = *(void *)v41;
      do
      {
        uint64_t v31 = 0;
        do
        {
          if (*(void *)v41 != v30) {
            objc_enumerationMutation(a1);
          }
          objc_msgSend_doubleValue(*(void **)(*((void *)&v40 + 1) + 8 * v31), v26, v27, v28);
          uint64_t v36 = objc_msgSend_numberWithDouble_(NSNumber, v33, v34, v35, (v32 - a5) / a6);
          objc_msgSend_addObject_(v13, v37, v36, v38);
          ++v31;
        }
        while (v29 != v31);
        uint64_t v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v26, (uint64_t)&v40, (uint64_t)v44, 16);
      }
      while (v29);
    }
  }
  else
  {
    uint64_t v22 = objc_msgSend_numberWithDouble_(NSNumber, v18, v19, v20, 0.0);
    objc_msgSend_addObject_(v13, v23, v22, v24);
  }
  return v13;
}

void *sub_1B6470194(uint64_t a1, const char *a2, int a3, uint64_t a4)
{
  int v4 = a4;
  int v6 = (int)a2;
  uint64_t v11 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], a2, (int)a2, a4);
  if (v6 >= 1)
  {
    uint64_t v12 = 16 * a3;
    uint64_t v13 = (double *)(a1 + 16 * v4);
    do
    {
      uint64_t v14 = objc_msgSend_valueWithVFXFloat3_(MEMORY[0x1E4F29238], v8, v9, v10, *v13);
      objc_msgSend_addObject_(v11, v15, v14, v16);
      uint64_t v13 = (double *)((char *)v13 + v12);
      --v6;
    }
    while (v6);
  }
  return v11;
}

uint64_t sub_1B6470220(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_componentConformingToProtocol_(a1, a2, (uint64_t)&unk_1F1080AB8, a4);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (void *)v4;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return objc_msgSend_skeleton(v5, v6, v7, v8);
}

uint64_t sub_1B6470290(void *a1, float32x4_t *a2, void *a3, void **a4)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (objc_msgSend_transform(a1, (const char *)a2, (uint64_t)a3, (uint64_t)a4))
  {
    float32x4_t v55 = *a2;
    float32x4_t v56 = a2[1];
    float32x4_t v53 = a2[3];
    float32x4_t v54 = a2[2];
    uint64_t v11 = objc_msgSend_transform(a1, v8, v9, v10);
    objc_msgSend_matrix(v11, v12, v13, v14);
    uint64_t v15 = 0;
    v61[0] = v16;
    v61[1] = v17;
    v61[2] = v18;
    void v61[3] = v19;
    do
    {
      *(float32x4_t *)((char *)&v62 + v15 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v55, COERCE_FLOAT(v61[v15])), v56, *(float32x2_t *)&v61[v15], 1), v54, (float32x4_t)v61[v15], 2), v53, (float32x4_t)v61[v15], 3);
      ++v15;
    }
    while (v15 != 4);
  }
  else
  {
    float32x4_t v20 = a2[1];
    float32x4_t v62 = *a2;
    float32x4_t v63 = v20;
    float32x4_t v21 = a2[3];
    float32x4_t v64 = a2[2];
    float32x4_t v65 = v21;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend_addObject_(a3, (const char *)v22, (uint64_t)a1, v24);
    unint64_t v25 = (unint64_t)a4[2];
    uint64_t v26 = (float32x4_t *)a4[1];
    if ((unint64_t)v26 >= v25)
    {
      uint64_t v30 = ((char *)v26 - (unsigned char *)*a4) >> 6;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 58) {
        abort();
      }
      uint64_t v32 = v25 - (void)*a4;
      if (v32 >> 5 > v31) {
        unint64_t v31 = v32 >> 5;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFC0) {
        unint64_t v22 = 0x3FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v31;
      }
      if (v22) {
        uint64_t v33 = (char *)sub_1B6470904((uint64_t)(a4 + 2), v22);
      }
      else {
        uint64_t v33 = 0;
      }
      uint64_t v34 = (float32x4_t *)&v33[64 * v30];
      uint64_t v35 = &v33[64 * v22];
      float32x4_t v36 = v63;
      *uint64_t v34 = v62;
      v34[1] = v36;
      float32x4_t v37 = v65;
      v34[2] = v64;
      void v34[3] = v37;
      f32 = (_OWORD *)v34[4].f32;
      uint64_t v39 = (char *)*a4;
      uint64_t v38 = (float32x4_t *)a4[1];
      if (v38 != *a4)
      {
        do
        {
          float32x4_t v40 = v38[-4];
          float32x4_t v41 = v38[-3];
          float32x4_t v42 = v38[-1];
          v34[-2] = v38[-2];
          v34[-1] = v42;
          v34[-4] = v40;
          v34[-3] = v41;
          v34 -= 4;
          v38 -= 4;
        }
        while (v38 != (float32x4_t *)v39);
        uint64_t v38 = (float32x4_t *)*a4;
      }
      *a4 = v34;
      a4[1] = f32;
      a4[2] = v35;
      if (v38) {
        operator delete(v38);
      }
    }
    else
    {
      float32x4_t v27 = v63;
      float32x4_t *v26 = v62;
      v26[1] = v27;
      float32x4_t v28 = v65;
      v26[2] = v64;
      v26[3] = v28;
      f32 = (_OWORD *)v26[4].f32;
    }
    a4[1] = f32;
  }
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v43 = objc_msgSend_children(a1, (const char *)v22, v23, v24);
  uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v43, v44, (uint64_t)&v57, (uint64_t)v66, 16);
  uint64_t v49 = result;
  if (result)
  {
    uint64_t v50 = *(void *)v58;
    do
    {
      uint64_t v51 = 0;
      do
      {
        if (*(void *)v58 != v50) {
          objc_enumerationMutation(v43);
        }
        uint64_t v52 = *(void **)(*((void *)&v57 + 1) + 8 * v51);
        if (!sub_1B6470220(v52, v46, v47, v48)) {
          sub_1B6470290(v52, &v62, a3, a4);
        }
        ++v51;
      }
      while (v49 != v51);
      uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v43, v46, (uint64_t)&v57, (uint64_t)v66, 16);
      uint64_t v49 = result;
    }
    while (result);
  }
  return result;
}

uint64_t **sub_1B6470540(uint64_t **a1, uint64_t **a2)
{
  uint64_t v4 = a1 + 1;
  unint64_t v3 = a1[1];
  uint64_t v5 = *a2;
  if (v3)
  {
    while (1)
    {
      while (1)
      {
        int v6 = (uint64_t **)v3;
        unint64_t v7 = v3[4];
        if ((unint64_t)v5 >= v7) {
          break;
        }
        unint64_t v3 = *v6;
        uint64_t v4 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= (unint64_t)v5) {
        break;
      }
      unint64_t v3 = v6[1];
      if (!v3)
      {
        uint64_t v4 = v6 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v6 = a1 + 1;
LABEL_9:
    uint64_t v8 = (uint64_t *)v6;
    int v6 = (uint64_t **)operator new(0x38uLL);
    v6[5] = 0;
    v6[6] = 0;
    v6[4] = v5;
    *int v6 = 0;
    v6[1] = 0;
    v6[2] = v8;
    *uint64_t v4 = (uint64_t *)v6;
    uint64_t v9 = (uint64_t *)**a1;
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v4;
    }
    sub_1B644FF60(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6 + 5;
}

void *sub_1B6470610(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_skeleton(a1, a2, a3, a4);
  uint64_t v9 = objc_msgSend_jointBindTransforms(v5, v6, v7, v8);
  uint64_t v13 = objc_msgSend_elementCount(v9, v10, v11, v12);
  uint64_t v17 = objc_msgSend_jointPaths(a1, v14, v15, v16);
  uint64_t v19 = v17;
  if (v17)
  {
    uint64_t v17 = objc_opt_new();
    float32x4_t v21 = (void *)v17;
    if (v13)
    {
      for (uint64_t i = 0; i != v13; ++i)
      {
        uint64_t v23 = objc_msgSend_numberWithUnsignedInt_(NSNumber, v18, i, v20);
        float32x4_t v27 = objc_msgSend_jointPaths(v5, v24, v25, v26);
        uint64_t v30 = objc_msgSend_objectAtIndexedSubscript_(v27, v28, i, v29);
        uint64_t v17 = objc_msgSend_setObject_forKeyedSubscript_(v21, v31, v23, v30);
      }
    }
  }
  else
  {
    float32x4_t v21 = 0;
  }
  double v32 = MEMORY[0x1F4188790](v17, v18);
  float32x4_t v36 = objc_msgSend_jointBindTransforms(v5, v33, v34, v35, v32);
  objc_msgSend_getDouble4x4Array_maxCount_(v36, v37, (unint64_t)(&v69 - 16 * v13) & 0xFFFFFFFFFFFFFFE0, v13);
  if (v19)
  {
    float32x4_t v41 = objc_msgSend_jointPaths(a1, v38, v39, v40);
    uint64_t v13 = objc_msgSend_count(v41, v42, v43, v44);
  }
  uint64_t v48 = objc_msgSend_arrayWithCapacity_(MEMORY[0x1E4F1CA48], v38, v13, v40);
  if (v13)
  {
    for (uint64_t j = 0; j != v13; ++j)
    {
      if (v19)
      {
        uint64_t v50 = objc_msgSend_jointPaths(a1, v45, v46, v47);
        uint64_t v53 = objc_msgSend_objectAtIndexedSubscript_(v50, v51, j, v52);
        float32x4_t v56 = objc_msgSend_objectForKeyedSubscript_(v21, v54, v53, v55);
        objc_msgSend_unsignedLongValue(v56, v57, v58, v59);
      }
      __invert_d4();
      long long v60 = (void *)MEMORY[0x1E4F29238];
      double v61 = sub_1B647080C(&v70);
      uint64_t v65 = objc_msgSend_valueWithVFXMatrix4_(v60, v62, v63, v64, v61);
      objc_msgSend_addObject_(v48, v66, v65, v67);
    }
  }
  if (v21) {

  }
  return v48;
}

double sub_1B647080C(float64x2_t *a1)
{
  *(void *)&double result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a1), a1[1]).u64[0];
  return result;
}

uint64_t sub_1B6470840(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_jointPaths(a1, a2, a3, a4);
  if (!objc_msgSend_count(v5, v6, v7, v8)) {
    return 0;
  }
  uint64_t v12 = objc_msgSend_jointPaths(a1, v9, v10, v11);
  uint64_t v15 = objc_msgSend_objectAtIndexedSubscript_(v12, v13, 0, v14);
  uint64_t v19 = v15;
  if (!v15) {
    return (uint64_t)v19;
  }
  if (!objc_msgSend_length(v15, v16, v17, v18)) {
    return 0;
  }
  unint64_t v22 = objc_msgSend_substringToIndex_(v19, v20, 1, v21);
  if (objc_msgSend_isEqualToString_(v22, v23, @"/", v24)) {
    uint64_t v19 = objc_msgSend_substringFromIndex_(v19, v25, 1, v26);
  }
  uint64_t v27 = objc_msgSend_rangeOfString_(v19, v25, @"/", v26);
  if (v27 == 0x7FFFFFFFFFFFFFFFLL) {
    return (uint64_t)v19;
  }

  return objc_msgSend_substringToIndex_(v19, v28, v27, v29);
}

void *sub_1B6470904(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58) {
    sub_1B63C8620();
  }
  return operator new(a2 << 6);
}

void sub_1B647093C(void *a1)
{
  if (a1)
  {
    sub_1B647093C(*a1);
    sub_1B647093C(a1[1]);
    operator delete(a1);
  }
}

double sub_1B6470988(uint64_t a1)
{
  uint64_t v1 = 0;
  float32x4_t v2 = *(float32x4_t *)MEMORY[0x1E4F149A0];
  float32x4_t v3 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 16);
  float32x4_t v4 = *(float32x4_t *)(a1 + 16);
  int8x16_t v5 = (int8x16_t)vmulq_f32(*(float32x4_t *)a1, *(float32x4_t *)a1);
  *(float32x2_t *)v5.i8 = vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
  int8x16_t v6 = (int8x16_t)vmulq_f32(v4, v4);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x2_t v7 = (int32x2_t)vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v6.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v5.i8, *(int32x2_t *)v6.i8)));
  float32x4_t v8 = *(float32x4_t *)(a1 + 32);
  long long v9 = *(_OWORD *)(a1 + 48);
  float32x4_t v10 = vmulq_f32(v8, v8);
  float32x2_t v11 = (float32x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL).u64[0];
  v11.f32[0] = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v10.f32, v11)));
  *(int32x2_t *)v10.f32 = v7;
  v10.i64[1] = __PAIR64__(1.0, v11.u32[0]);
  __asm { FMOV            V5.4S, #1.0 }
  float32x4_t v17 = vdivq_f32(_Q5, v10);
  v18.i64[0] = 0;
  v18.i64[1] = v17.u32[2];
  float32x4_t v19 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 32);
  int32x4_t v20 = *(int32x4_t *)(MEMORY[0x1E4F149A0] + 48);
  float32x4_t v21 = vdivq_f32(*(float32x4_t *)a1, (float32x4_t)vdupq_lane_s32(v7, 0));
  int32x4_t v22 = (int32x4_t)vdivq_f32(v4, (float32x4_t)vdupq_lane_s32(v7, 1));
  int32x4_t v23 = (int32x4_t)vdivq_f32(v8, (float32x4_t)vdupq_lane_s32((int32x2_t)v11, 0));
  int32x4_t v24 = vzip1q_s32((int32x4_t)v21, v23);
  int32x4_t v25 = vzip2q_s32((int32x4_t)v21, v23);
  int32x4_t v26 = vzip1q_s32(v22, v20);
  int32x4_t v27 = vzip2q_s32(v22, v20);
  float32x4_t v28 = (float32x4_t)vzip1q_s32(v24, v26);
  float32x4_t v29 = (float32x4_t)vzip1q_s32(v25, v27);
  float32x4_t v41 = v8;
  long long v42 = v9;
  do
  {
    *(long long *)((char *)&v43 + v1) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v2, COERCE_FLOAT(*(long long *)((char *)&v39 + v1))), v3, *(float32x2_t *)((char *)&v39 + v1), 1), v19, *(float32x4_t *)((char *)&v39 + v1), 2), (float32x4_t)xmmword_1B6E50D70, *(float32x4_t *)((char *)&v39 + v1), 3);
    v1 += 16;
  }
  while (v1 != 64);
  uint64_t v30 = 0;
  v32.i64[0] = 0;
  v32.i32[2] = 0;
  v31.i32[0] = 0;
  v31.i64[1] = 0;
  v31.i32[1] = v17.i32[1];
  v32.i32[3] = v17.i32[3];
  float32x4_t v33 = (float32x4_t)vzip2q_s32(v24, v26);
  long long v39 = v43;
  long long v40 = v44;
  float32x4_t v41 = v45;
  long long v42 = v46;
  do
  {
    *(long long *)((char *)&v43 + v30) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v17.u32[0], COERCE_FLOAT(*(long long *)((char *)&v39 + v30))), v31, *(float32x2_t *)((char *)&v39 + v30), 1), v18, *(float32x4_t *)((char *)&v39 + v30), 2), v32, *(float32x4_t *)((char *)&v39 + v30), 3);
    v30 += 16;
  }
  while (v30 != 64);
  uint64_t v34 = 0;
  float32x4_t v35 = (float32x4_t)vzip2q_s32(v25, v27);
  long long v39 = v43;
  long long v40 = v44;
  float32x4_t v41 = v45;
  long long v42 = v46;
  do
  {
    *(long long *)((char *)&v43 + v34) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v28, COERCE_FLOAT(*(long long *)((char *)&v39 + v34))), v33, *(float32x2_t *)((char *)&v39 + v34), 1), v29, *(float32x4_t *)((char *)&v39 + v34), 2), v35, *(float32x4_t *)((char *)&v39 + v34), 3);
    v34 += 16;
  }
  while (v34 != 64);
  uint64_t v36 = 0;
  long long v39 = v43;
  long long v40 = v44;
  float32x4_t v41 = v45;
  long long v42 = v46;
  do
  {
    *(long long *)((char *)&v43 + v36) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v2, COERCE_FLOAT(*(long long *)((char *)&v39 + v36))), v3, *(float32x2_t *)((char *)&v39 + v36), 1), v19, *(float32x4_t *)((char *)&v39 + v36), 2), (float32x4_t)xmmword_1B6E4F3A0, *(float32x4_t *)((char *)&v39 + v36), 3);
    v36 += 16;
  }
  while (v36 != 64);
  float32x4_t v37 = vmulq_n_f32(v21, *(float *)v7.i32);
  v37.i32[1] = vnegq_f32(v37).i32[1];
  return *(double *)v37.i64;
}

void sub_1B6470B84(unint64_t *a1, size_t a2)
{
  int8x16_t v5 = (char *)a1[1];
  float32x4_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    int32x2_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      uint64_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      int8x16_t v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t **sub_1B6470CBC(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  int32x2_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        int32x2_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        int32x2_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = operator new(0x30uLL);
    v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    sub_1B644FF08(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *sub_1B6470D80(uint64_t **a1, unsigned int *a2, uint64_t a3, unsigned int **a4)
{
  int32x2_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        int32x2_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        int32x2_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v11 + 28) = **a4;
    sub_1B644FF08(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void sub_1B6470E40(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0) {
      abort();
    }
    int8x16_t v5 = (char *)a1[1];
    unint64_t v6 = operator new(__sz);
    int32x2_t v7 = &v5[(void)v6 - v2];
    unsigned int v8 = v7;
    if (v5 != (char *)v2)
    {
      unint64_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }
      while (v5 != (char *)v2);
      unsigned int v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
    {
      operator delete((void *)v2);
    }
  }
}

void sub_1B6470EF8(void **a1, unint64_t a2)
{
  float32x4_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)sub_1B645A9E0(v3, a2);
    int32x2_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    unint64_t v9 = &v6[2 * v8];
    char v10 = (char *)*a1;
    unint64_t v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        __int16 v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t sub_1B6470F98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F0FB4300;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(void *)(a1 + 560) = 0;
  *(void *)(a1 + 576) = 0;
  *(_DWORD *)(a1 + 584) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = a2;
  uint64_t v9 = sub_1B644558C(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 24) = v9;
  uint64_t v17 = sub_1B64B28FC(v9, v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 32) = v17;
  *(_WORD *)(a1 + 48) = 15;
  sub_1B6624920(v17, 0xFu);
  return a1;
}

void sub_1B6471048(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 576);
  if (v3) {

  }
  float32x4_t v4 = *(void **)(v1 + 560);
  if (v4) {

  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B647106C(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB4300;
  sub_1B6624994(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 48));
  unint64_t v2 = *(void **)(a1 + 576);
  if (v2) {

  }
  uint64_t v3 = *(void **)(a1 + 560);
  if (v3) {

  }
  return a1;
}

void sub_1B64710D0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 576);
  if (v3) {

  }
  float32x4_t v4 = *(void **)(v1 + 560);
  if (v4) {

  }
  _Unwind_Resume(exception_object);
}

void sub_1B64710F8(uint64_t a1)
{
  sub_1B647106C(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6471130(uint64_t a1, CFX::RG::RenderGraphContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 16), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = objc_msgSend_resourceManager(v11, v12, v13, v14);
  uint64_t v23 = sub_1B644558C(*(void *)(a1 + 16), v16, v17, v18, v19, v20, v21, v22);
  float32x4_t v31 = sub_1B6446564(*(uint64_t **)(a1 + 16), v24, v25, v26, v27, v28, v29, v30);
  if (v31 && sub_1B64A3B48((uint64_t)v31, v32, v33, v34, v35, v36, v37, v38))
  {
    BOOL v39 = sub_1B64B2810(v23, 0) != 0;
    BOOL v75 = v39;
    unsigned int v74 = sub_1B6626FAC(*(void *)(a1 + 32));
    int v40 = sub_1B6626FBC(*(void *)(a1 + 32));
    unsigned int v72 = *(_DWORD *)(a3 + 172);
    BOOL v73 = v40 != 0;
    unint64_t v41 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v74) ^ ((0x9DDFEA08EB382D69 * v74) >> 47));
    unint64_t v42 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ (v40 != 0))) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ (v40 != 0))));
    unint64_t v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    unint64_t v44 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) ^ ((0x9DDFEA08EB382D69 * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) >> 47));
    unint64_t v45 = 0x9DDFEA08EB382D69
        * (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v72)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v72)));
    unint64_t v46 = 0x9DDFEA08EB382D69 * (v45 ^ (v45 >> 47));
    if (*(void *)(a1 + 552) != v46)
    {
      *(void *)(a1 + 552) = v46;
      sub_1B6626AF8(*(void *)(a1 + 32), *(void *)(a1 + 16));
      id v47 = objc_alloc_init(MEMORY[0x1E4F35228]);
      objc_msgSend_setConstantValue_type_withName_(v47, v48, (uint64_t)&v74, 33, @"LightCount");
      objc_msgSend_setConstantValue_type_withName_(v47, v49, (uint64_t)&v75, 53, @"has_IBL");
      objc_msgSend_setConstantValue_type_withName_(v47, v50, (uint64_t)&v73, 33, @"raytracing_use_function_constant");
      objc_msgSend_setConstantValue_type_withName_(v47, v51, (uint64_t)&v72, 33, @"quality_mode");
      uint64_t v52 = sub_1B6626EDC(*(void *)(a1 + 32));
      uint64_t v54 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_linkedFunctions_(v15, v53, @"vfx_rt_subsurface_trace", (uint64_t)v47, v52);

      uint64_t v55 = *(void **)(a1 + 560);
      if (v55 != (void *)v54)
      {
        if (v55) {

        }
        *(void *)(a1 + 560) = v54;
      }
      *(_DWORD *)(a1 + 460) = 0;
      sub_1B6626E64(*(void *)(a1 + 32));
    }
    float32x4_t v56 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, *(const CFX::RG::Resource **)(a3 + 248));
    unint64_t v60 = *v56;
    unint64_t v61 = v56[1];
    unint64_t v62 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v60) ^ ((0x9DDFEA08EB382D69 * v60) >> 47));
    unint64_t v63 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)));
    unint64_t v64 = 0x9DDFEA08EB382D69 * (v63 ^ (v63 >> 47));
    if (*(void *)(a1 + 568) != v64)
    {
      *(void *)(a1 + 568) = v64;
      unint64_t v65 = v60 >> 1;
      unint64_t v66 = v61 >> 1;
      uint64_t v67 = objc_msgSend_device(v11, v57, v58, v59);
      uint64_t v69 = objc_msgSend_newBufferWithLength_options_(v67, v68, 96 * v65 * (unint64_t)v66, 32);
      float64x2_t v70 = *(void **)(a1 + 576);
      if (v70 != (void *)v69)
      {
        uint64_t v71 = v69;
        if (v70) {

        }
        *(void *)(a1 + 576) = v71;
      }
      *(_DWORD *)(a1 + 460) = 0;
    }
  }
}

uint64_t *sub_1B64713D8(uint64_t *a1, uint64_t a2, uint64_t a3, CFX::RG::RenderGraphContext *a4, uint64_t a5)
{
  uint64_t v8 = *(void *)a5;
  v33[0] = (uint64_t)"RTSubsurfaceTracePass";
  v33[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAD98, memory_order_acquire) & 1) == 0)
  {
    uint64_t v32 = a3;
    uint64_t v30 = a2;
    int v31 = __cxa_guard_acquire(&qword_1E9DDAD98);
    a2 = v30;
    a3 = v32;
    if (v31)
    {
      qword_1E9DDAD90 = (uint64_t)sub_1B6472CA8("RT_SUBSURFACE_TRACE", 0x13u);
      __cxa_guard_release(&qword_1E9DDAD98);
      a2 = v30;
      a3 = v32;
    }
  }
  sub_1B653860C((uint64_t)a1, a2, a3, v33, qword_1E9DDAD90, 0);
  *a1 = (uint64_t)&unk_1F0FB4320;
  a1[47] = a5;
  a1[48] = 0;
  a1[49] = 0;
  a1[50] = 0;
  uint64_t v16 = (void *)sub_1B6445900(a1[46], v9, v10, v11, v12, v13, v14, v15);
  a1[49] = (uint64_t)v16;
  a1[50] = objc_msgSend_resourceManager(v16, v17, v18, v19);
  uint64_t v20 = (CFX::CrossFrameResourceManager *)*((void *)a4 + 4);
  unint64_t v21 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v22 = CFX::CrossFrameResourceManager::get(v20, v21);
  a1[48] = v22;
  if (!v22)
  {
    CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    v33[0] = a1[46];
    sub_1B64715A4();
  }
  sub_1B6471130(v22, a4, a1[47], v23, v24, v25, v26, v27);
  uint64_t v28 = a1[47];
  *(void *)(v28 + 312) = a1[48] + 64;
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(v28 + 272));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a1[47] + 240));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a5 + 248));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a5 + 176));
  return a1;
}

void sub_1B647158C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B64715A4()
{
}

void sub_1B647160C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A1C40FAE558D7);
  _Unwind_Resume(a1);
}

void sub_1B6471634(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)(a1 + 384) + 560))
  {
    uint64_t v10 = *a3;
    uint64_t v11 = sub_1B644558C(*(void *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    uint64_t v19 = sub_1B6446564(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      if (sub_1B64A3B48((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26))
      {
        uint64_t v34 = sub_1B6446564(*(uint64_t **)(a1 + 368), v27, v28, v29, v30, v31, v32, v33);
        sub_1B63E0460((uint64_t)v34, (uint64_t)v177, v35, v36, v37, v38, v39, v40);
        unint64_t v41 = (long long *)sub_1B6447988(*(void *)(a1 + 368), 1);
        long long v171 = v41[1];
        long long v172 = *v41;
        long long v169 = v41[3];
        long long v170 = v41[2];
        __n128 v176 = sub_1B64471F4(*(void *)(a1 + 368), 0, v42, v43, v44, v45, v46, v47);
        uint64_t v173 = v11;
        uint64_t v55 = sub_1B64B28FC(v11, v48, v49, v50, v51, v52, v53, v54);
        sub_1B6626AF8(v55, *(void *)(a1 + 368));
        id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 264));
        id v57 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 248));
        id v58 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 256));
        id v59 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 280));
        id v60 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 176));
        id v61 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 240));
        objc_msgSend_setTexture_atIndex_(v10, v62, (uint64_t)Texture, 0);
        uint64_t v168 = v57;
        objc_msgSend_setTexture_atIndex_(v10, v63, (uint64_t)v57, 1);
        objc_msgSend_setTexture_atIndex_(v10, v64, (uint64_t)v58, 2);
        objc_msgSend_setTexture_atIndex_(v10, v65, (uint64_t)v59, 3);
        objc_msgSend_setTexture_atIndex_(v10, v66, (uint64_t)v60, 4);
        objc_msgSend_setTexture_atIndex_(v10, v67, (uint64_t)v61, 5);
        objc_msgSend_setTexture_atIndex_(v10, v68, *(void *)(*(void *)(a1 + 384) + 544), 9);
        float32x2_t v174 = sub_1B6447FE4(**(float32x2_t ***)(a1 + 376), 0, v69, v70);
        uint64_t v71 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        v71[4] = v172;
        v71[5] = v171;
        v71[6] = v170;
        v71[7] = v169;
        uint64_t v78 = sub_1B649CD50(v177, (uint64_t)&v176, v72, v73, v74, v75, v76, v77);
        uint64_t v79 = 0;
        long long v80 = *((_OWORD *)v78 + 1);
        long long v81 = *((_OWORD *)v78 + 2);
        long long v82 = *((_OWORD *)v78 + 3);
        uint64_t v83 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        v83[12] = *(_OWORD *)v78;
        v83[13] = v80;
        v83[14] = v81;
        v83[15] = v82;
        uint64_t v84 = *(float32x4_t **)(a1 + 384);
        float32x4_t v85 = v84[16];
        float32x4_t v86 = v84[17];
        float32x4_t v87 = v84[18];
        float32x4_t v88 = v84[19];
        float32x4_t v89 = v84[9];
        float32x4_t v90 = v84[10];
        float32x4_t v91 = v84[11];
        v178[0] = v84[8];
        v178[1] = v89;
        v178[2] = v90;
        v178[3] = v91;
        do
        {
          v179[v79] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v85, COERCE_FLOAT(*(_OWORD *)&v178[v79])), v86, *(float32x2_t *)v178[v79].f32, 1), v87, v178[v79], 2), v88, v178[v79], 3);
          ++v79;
        }
        while (v79 != 4);
        long long v92 = v179[1];
        long long v93 = v179[2];
        long long v94 = v179[3];
        uint64_t v95 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        *uint64_t v95 = v179[0];
        v95[1] = v92;
        v95[2] = v93;
        v95[3] = v94;
        *(simd_float4x4 *)(*(void *)(*(void *)(a1 + 376) + 312) + 128) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 384) + 128));
        *(simd_float4x4 *)(*(void *)(*(void *)(a1 + 376) + 312) + 256) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 384) + 64));
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 384) = (float)((float)(unint64_t)objc_msgSend_width(Texture, v96, v97, v98)
                                                                               * v174.f32[0])
                                                                       * 0.5;
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 388) = vmuls_lane_f32((float)(unint64_t)objc_msgSend_height(Texture, v99, v100, v101), v174, 1)* 0.5;
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 400) = *(_OWORD *)(*(void *)(a1 + 376) + 208);
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 416) = *(_OWORD *)(*(void *)(a1 + 376) + 224);
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 448) = *(_OWORD *)(*(void *)(a1 + 376) + 192);
        uint64_t v102 = *(void *)(a1 + 376);
        uint64_t v103 = *(void *)(v102 + 312);
        *(float *)(v103 + 432) = (float)*(int *)(v102 + 184);
        objc_msgSend_setBytes_length_atIndex_(v10, v104, v103, 480, 8);
        uint64_t v105 = sub_1B64B2810(v173, 0);
        if (v105) {
          float v113 = sub_1B64763AC(v105, (uint64_t)v106, v107, v108, v109, v110, v111, v112);
        }
        else {
          float v113 = 0.0;
        }
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 464) = v113;
        objc_msgSend_setBuffer_offset_atIndex_(v10, v106, *(void *)(*(void *)(a1 + 384) + 576), 0, 10);
        uint64_t v114 = sub_1B6626EB4(v55);
        objc_msgSend_useHeap_(v10, v115, v114, v116);
        uint64_t v117 = sub_1B6626EC4(v55);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v118, v117, 0, 0);
        uint64_t v119 = sub_1B6626EBC(v55);
        objc_msgSend_setAccelerationStructure_atBufferIndex_(v10, v120, v119, 1);
        if (sub_1B6626FAC(v55))
        {
          uint64_t v121 = sub_1B6626ECC(v55);
          objc_msgSend_setBuffer_offset_atIndex_(v10, v122, v121, 0, 2);
        }
        if (sub_1B6626FBC(v55))
        {
          uint64_t v129 = *(void *)(a1 + 384);
          uint64_t v130 = *(void *)(v129 + 560);
          if (!v130)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v123, v124, v125, v126, v127, v128, (uint64_t)"_ptr != NULL");
            uint64_t v130 = *(void *)(v129 + 560);
          }
          uint64_t v131 = (void *)sub_1B653EFB8(v130);
          uint64_t v132 = sub_1B6626EE4(v55, v131);
          objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v10, v133, (uint64_t)v132, 3);
        }
        else
        {
          uint64_t v132 = 0;
        }
        uint64_t v134 = sub_1B6626ED4(v55);
        unsigned int v138 = sub_1B6626FCC(v55, v135, v136, v137);
        objc_msgSend_useResources_count_usage_(v10, v139, v134, v138, 1);
        uint64_t v146 = *(void *)(a1 + 384);
        uint64_t v147 = *(void *)(v146 + 560);
        if (!v147)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v140, v141, v142, v143, v144, v145, (uint64_t)"_ptr != NULL");
          uint64_t v147 = *(void *)(v146 + 560);
        }
        uint64_t v148 = sub_1B653EFB8(v147);
        objc_msgSend_setComputePipelineState_(v10, v149, v148, v150);
        unint64_t v154 = (unint64_t)objc_msgSend_width(v168, v151, v152, v153) >> 1;
        unint64_t v164 = (unint64_t)objc_msgSend_height(v168, v155, v156, v157) >> 1;
        uint64_t v165 = *(void *)(a1 + 384);
        uint64_t v166 = *(void *)(v165 + 560);
        if (!v166)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v158, v159, v160, v161, v162, v163, (uint64_t)"_ptr != NULL");
          uint64_t v166 = *(void *)(v165 + 560);
        }
        uint64_t v167 = (void *)sub_1B653EFB8(v166);
        v175[0] = v154;
        v175[1] = v164;
        v175[2] = 1;
        RGMTLComputeCommandEncoderDispatchOnGrid2D(v10, v167, (uint64_t)v175, 1);

        sub_1B6626E64(v55);
      }
    }
  }
}

uint64_t sub_1B6471B94(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  v46[0] = (uint64_t)"RTSubsurfaceUpscalePass";
  v46[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDADA8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v43 = a2;
    uint64_t v44 = a3;
    int v42 = __cxa_guard_acquire(&qword_1E9DDADA8);
    a2 = v43;
    a3 = v44;
    if (v42)
    {
      qword_1E9DDADA0 = (uint64_t)sub_1B6472CA8("RT_SUBSURFACE_UPSCALE", 0x15u);
      __cxa_guard_release(&qword_1E9DDADA8);
      a2 = v43;
      a3 = v44;
    }
  }
  sub_1B653860C(a1, a2, a3, v46, qword_1E9DDADA0, 0);
  *(void *)a1 = &unk_1F0FB4550;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  uint64_t v16 = (void *)sub_1B6445900(*(void *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
  *(void *)(a1 + 400) = v16;
  *(void *)(a1 + 408) = objc_msgSend_resourceManager(v16, v17, v18, v19);
  unint64_t v20 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v21 = CFX::CrossFrameResourceManager::get(a4[4], v20);
  *(void *)(a1 + 384) = v21;
  if (!v21)
  {
    *(void *)(a1 + 384) = sub_1B6471D54(a4[4], v20);
    uint64_t v29 = (void *)sub_1B6445900(*(void *)(a1 + 368), v22, v23, v24, v25, v26, v27, v28);
    uint64_t v33 = objc_msgSend_resourceManager(v29, v30, v31, v32);
    uint64_t v34 = *(void *)(a1 + 384);
    uint64_t v37 = objc_msgSend_newComputePipelineStateWithFunctionName_(v33, v35, @"vfx_rt_subsurface_upscale", v36);
    uint64_t v38 = *(void **)(v34 + 16);
    if (v38 != (void *)v37)
    {
      if (v38) {

      }
      *(void *)(v34 + 16) = v37;
    }
  }
  uint64_t v39 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(*(void *)(a1 + 376) + 8), MTLPixelFormatRGBA16Float, (uint64_t)v45);
  uint64_t v40 = sub_1B63CFDE4(v39, (uint64_t)"SubsurfaceUpscale", v45);
  *(void *)(a1 + 392) = v40;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v40);
  return a1;
}

void sub_1B6471D34(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6471D54(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B6471DE0(uint64_t result, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(result + 384) + 16))
  {
    uint64_t v4 = result;
    int64_t v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(result + 376) + 312), 480, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 264));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 248));
    objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
    objc_msgSend_setBuffer_offset_atIndex_(v5, v10, *(void *)(*(void *)(v4 + 376) + 304), 0, 0);
    id v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 392));
    objc_msgSend_setTexture_atIndex_(v5, v12, (uint64_t)v11, 10);
    uint64_t v19 = *(void *)(v4 + 384);
    uint64_t v20 = *(void *)(v19 + 16);
    if (!v20)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v13, v14, v15, v16, v17, v18, (uint64_t)"_ptr != NULL");
      uint64_t v20 = *(void *)(v19 + 16);
    }
    uint64_t v22 = sub_1B653EFB8(v20);
    return objc_msgSend_dispatch_onTexture2D_(v5, v21, v22, (uint64_t)v11);
  }
  return result;
}

uint64_t sub_1B6471F28(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  uint64_t v9 = *(void *)a5;
  v28[0] = (uint64_t)"RTSubsurfaceTemporalDenoisePass";
  v28[1] = v9;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDADB8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v26 = a3;
    int v25 = __cxa_guard_acquire(&qword_1E9DDADB8);
    a3 = v26;
    if (v25)
    {
      qword_1E9DDADB0 = (uint64_t)sub_1B6472CA8("RT_SUBSURFACE_TEMPORAL_DENOISE", 0x1Eu);
      __cxa_guard_release(&qword_1E9DDADB8);
      a3 = v26;
    }
  }
  sub_1B653860C(a1, a2, a3, v28, qword_1E9DDADB0, 0);
  *(void *)a1 = &unk_1F0FB4DD0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  uint64_t v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 416) = v17;
  *(void *)(a1 + 424) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, *(const CFX::RG::Resource **)(a5 + 248));
  unint64_t v21 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v22 = CFX::CrossFrameResourceManager::get(a4[4], v21);
  *(void *)(a1 + 384) = v22;
  if (!v22) {
    operator new();
  }
  uint64_t v23 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(*(void *)(a1 + 376) + 8), MTLPixelFormatRGBA16Float, (uint64_t)v27);
  *(void *)(a1 + 408) = sub_1B63CFDE4(v23, (uint64_t)"SubsurfaceUpscale", v27);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 376) + 272));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 408));
  return a1;
}

void sub_1B6472130(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6472150(uint64_t result, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(result + 384) + 16))
  {
    uint64_t v4 = result;
    int64_t v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(result + 376) + 312), 480, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 392));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 264));
    uint64_t v8 = *(void *)(v4 + 376);
    uint64_t v9 = *(const CFX::RG::Resource **)(v8 + 288);
    if (v9)
    {
      id v10 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v9);
      uint64_t v8 = *(void *)(v4 + 376);
    }
    else
    {
      id v10 = 0;
    }
    id v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v8 + 272));
    objc_msgSend_setTexture_atIndex_(v5, v12, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v13, (uint64_t)v7, 1);
    objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)v10, 2);
    objc_msgSend_setTexture_atIndex_(v5, v15, (uint64_t)v11, 3);
    id v16 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 408));
    id v17 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 400));
    objc_msgSend_setTexture_atIndex_(v5, v18, (uint64_t)v16, 10);
    objc_msgSend_setTexture_atIndex_(v5, v19, (uint64_t)v17, 11);
    uint64_t v26 = *(void *)(v4 + 384);
    uint64_t v27 = *(void *)(v26 + 16);
    if (!v27)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v20, v21, v22, v23, v24, v25, (uint64_t)"_ptr != NULL");
      uint64_t v27 = *(void *)(v26 + 16);
    }
    uint64_t v29 = sub_1B653EFB8(v27);
    return objc_msgSend_dispatch_onTexture2D_(v5, v28, v29, (uint64_t)v16);
  }
  return result;
}

uint64_t sub_1B64722FC(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v9 = *a5;
  *(void *)&v35[0] = "RTSubsurfaceSpatialDenoisePass";
  *((void *)&v35[0] + 1) = v9;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDADC8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v33 = a3;
    int v34 = __cxa_guard_acquire(&qword_1E9DDADC8);
    a3 = v33;
    if (v34)
    {
      qword_1E9DDADC0 = (uint64_t)sub_1B6472CA8("RT_SUBSURFACE_SPATIAL_DENOISE", 0x1Du);
      __cxa_guard_release(&qword_1E9DDADC8);
      a3 = v33;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)v35, qword_1E9DDADC0, 0);
  *(void *)a1 = &unk_1F0FB4CF0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(void *)(a1 + 416) = 0;
  id v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 408) = v17;
  *(void *)(a1 + 416) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  uint64_t v21 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[31]);
  unsigned int v22 = *v21;
  unsigned int v23 = v21[1];
  unint64_t v24 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v25 = CFX::CrossFrameResourceManager::get(a4[4], v24);
  *(void *)(a1 + 384) = v25;
  if (!v25) {
    operator new();
  }
  memset(v35, 0, sizeof(v35));
  if (v22 <= 1) {
    __int16 v26 = 1;
  }
  else {
    __int16 v26 = v22;
  }
  if (v23 <= 1) {
    __int16 v27 = 1;
  }
  else {
    __int16 v27 = v23;
  }
  RGTextureDescriptorMake2D(v26, v27, 115, (uint64_t)v35);
  unint64_t v28 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v29 = 0x9DDFEA08EB382D69
      * (v28 ^ ((0x9DDFEA08EB382D69 * (v28 ^ LOWORD(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ LOWORD(v35[0]))));
  unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47));
  uint64_t v31 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v30 ^ ((0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))))) ^ ((0x9DDFEA08EB382D69 * (v30 ^ ((0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))))) >> 47)));
  *(void *)(a1 + 392) = v31;
  if (!v31) {
    operator new();
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 376) + 272));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 392) + 8 * (*(unsigned char *)(*(void *)(a1 + 384) + 24) == 0) + 16));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 392) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 24) + 16));
  return a1;
}

void sub_1B64726A0(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1B64726CC(uint64_t a1, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(a1 + 384) + 16))
  {
    int64_t v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(a1 + 376) + 312), 480, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 264));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 248));
    objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 1);
    objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 2);
    id v10 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400));
    id v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 392)+ 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 24)+ 16));
    int v56 = 1065353216;
    objc_msgSend_setBytes_length_atIndex_(v5, v12, (uint64_t)&v56, 4, 9);
    objc_msgSend_setTexture_atIndex_(v5, v13, (uint64_t)v10, 0);
    objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)v11, 10);
    uint64_t v21 = *(void *)(a1 + 384);
    uint64_t v22 = *(void *)(v21 + 16);
    if (!v22)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
      uint64_t v22 = *(void *)(v21 + 16);
    }
    uint64_t v23 = sub_1B653EFB8(v22);
    objc_msgSend_dispatch_onTexture2D_(v5, v24, v23, (uint64_t)v11);
    int v56 = 0x40000000;
    objc_msgSend_setBytes_length_atIndex_(v5, v25, (uint64_t)&v56, 4, 9);
    objc_msgSend_setTexture_atIndex_(v5, v26, (uint64_t)v11, 0);
    objc_msgSend_setTexture_atIndex_(v5, v27, (uint64_t)v10, 10);
    uint64_t v34 = *(void *)(a1 + 384);
    uint64_t v35 = *(void *)(v34 + 16);
    if (!v35)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v28, v29, v30, v31, v32, v33, (uint64_t)"_ptr != NULL");
      uint64_t v35 = *(void *)(v34 + 16);
    }
    uint64_t v36 = sub_1B653EFB8(v35);
    objc_msgSend_dispatch_onTexture2D_(v5, v37, v36, (uint64_t)v11);
    int v56 = 1082130432;
    objc_msgSend_setBytes_length_atIndex_(v5, v38, (uint64_t)&v56, 4, 9);
    objc_msgSend_setTexture_atIndex_(v5, v39, (uint64_t)v10, 0);
    objc_msgSend_setTexture_atIndex_(v5, v40, (uint64_t)v11, 10);
    uint64_t v47 = *(void *)(a1 + 384);
    uint64_t v48 = *(void *)(v47 + 16);
    if (!v48)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v41, v42, v43, v44, v45, v46, (uint64_t)"_ptr != NULL");
      uint64_t v48 = *(void *)(v47 + 16);
    }
    uint64_t v49 = sub_1B653EFB8(v48);
    objc_msgSend_dispatch_onTexture2D_(v5, v50, v49, (uint64_t)v11);
    uint64_t v51 = *(void *)(*(void *)(a1 + 376) + 312);
    long long v52 = *(_OWORD *)(v51 + 272);
    *(_OWORD *)(v51 + 320) = *(_OWORD *)(v51 + 256);
    *(_OWORD *)(v51 + 336) = v52;
    __n128 result = *(__n128 *)(v51 + 288);
    long long v54 = *(_OWORD *)(v51 + 304);
    *(__n128 *)(v51 + 352) = result;
    *(_OWORD *)(v51 + 368) = v54;
    uint64_t v55 = *(void *)(a1 + 384);
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 396);
    *(unsigned char *)(v55 + 24) ^= 1u;
  }
  return result;
}

CFX::RG::Pass *sub_1B6472950(CFX::RG::RenderGraphContext *a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a1);
  int64_t v5 = (CFX::RG::Pass *)sub_1B6472A58(v4, a1, (uint64_t)a2);
  a2[38] = *(void *)(*((void *)v5 + 48) + 576);
  unint64_t v6 = (uint64_t *)sub_1B6472AB0(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  CFX::RG::Pass::dependsOn(v6, v5);
  id v7 = (uint64_t *)sub_1B6472B08(v4, (CFX::CrossFrameResourceManager **)a1, (uint64_t)a2);
  uint64_t v8 = (CFX::RG::Resource *)v6[49];
  v7[49] = (uint64_t)v8;
  CFX::RG::Pass::readFrom(v7, v8);
  CFX::RG::Pass::dependsOn(v7, (CFX::RG::Pass *)v6);
  uint64_t v9 = (uint64_t *)sub_1B6472B60(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  id v10 = (CFX::RG::Resource *)v7[51];
  v9[50] = (uint64_t)v10;
  CFX::RG::Pass::readFrom(v9, v10);
  CFX::RG::Pass::dependsOn(v9, (CFX::RG::Pass *)v7);
  id v11 = *(CFX::RG::Resource **)(v9[49] + 8 * (*(unsigned char *)(v9[48] + 24) == 0) + 16);
  v7[50] = (uint64_t)v11;
  CFX::RG::Pass::readFrom(v7, v11);
  a2[37] = *(void *)(v9[49] + 8 * *(unsigned __int8 *)(v9[48] + 24) + 16);
  return v5;
}

uint64_t sub_1B6472A58(uint64_t *a1, CFX::RG::RenderGraphContext *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = (uint64_t)sub_1B6473094(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6472AB0(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64730F4(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6472B08(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6473154(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6472B60(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64731B4(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6472BBC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6472BF8(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6472C34(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6472C70(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B6472CA8(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      uint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      __n128 result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B6472D94(void *a1)
{
  *a1 = &unk_1F0FB4530;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6472DE0(void *a1)
{
  *a1 = &unk_1F0FB4530;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6472E4C(void *a1)
{
  *a1 = &unk_1F0FB4DB0;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6472E98(void *a1)
{
  *a1 = &unk_1F0FB4DB0;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6472F04(void *a1)
{
  *a1 = &unk_1F0FB4CB0;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6472F50(void *a1)
{
  *a1 = &unk_1F0FB4CB0;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6472FBC(void *a1)
{
  *a1 = &unk_1F0FB4CD0;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B6473018(void *a1)
{
  *a1 = &unk_1F0FB4CD0;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t *sub_1B6473094(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::RG::RenderGraphContext *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = (uint64_t *)sub_1B63C8330(v10, 0x198u, 8u);
  return sub_1B64713D8(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64730F4(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A0u, 8u);
  return sub_1B6471B94(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6473154(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B6471F28(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64731B4(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A8u, 8u);
  return sub_1B64722FC(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6473214(void *a1, const char *a2, void *a3, void *a4)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = objc_msgSend_count(a3, a2, (uint64_t)a3, (uint64_t)a4);
  if (v7 != objc_msgSend_count(a4, v8, v9, v10))
  {
    NSLog(&cfstr_ErrorRangesAnd.isa);
    return 0;
  }
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  uint64_t v12 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v11, (uint64_t)&v72, (uint64_t)v78, 16);
  if (v12)
  {
    uint64_t v16 = v12;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = *(void *)v73;
    while (2)
    {
      for (uint64_t i = 0; i != v16; ++i)
      {
        if (*(void *)v73 != v19) {
          objc_enumerationMutation(a3);
        }
        unint64_t v21 = objc_msgSend_rangeValue(*(void **)(*((void *)&v72 + 1) + 8 * i), v13, v14, v15);
        if (v21 < (unint64_t)v17)
        {
          NSLog(&cfstr_ErrorRangesMus.isa);
          return 0;
        }
        uint64_t v17 = &v13[v21];
        v18 += (uint64_t)v13;
      }
      uint64_t v16 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v13, (uint64_t)&v72, (uint64_t)v78, 16);
      if (v16) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  uint64_t v23 = objc_msgSend_countByEnumeratingWithState_objects_count_(a4, v13, (uint64_t)&v68, (uint64_t)v77, 16);
  if (v23)
  {
    uint64_t v27 = v23;
    uint64_t v28 = 0;
    uint64_t v29 = *(void *)v69;
    do
    {
      for (uint64_t j = 0; j != v27; ++j)
      {
        if (*(void *)v69 != v29) {
          objc_enumerationMutation(a4);
        }
        v28 += objc_msgSend_length(*(void **)(*((void *)&v68 + 1) + 8 * j), v24, v25, v26);
      }
      uint64_t v27 = objc_msgSend_countByEnumeratingWithState_objects_count_(a4, v24, (uint64_t)&v68, (uint64_t)v77, 16);
    }
    while (v27);
  }
  else
  {
    uint64_t v28 = 0;
  }
  uint64_t v32 = v28 - v18 + objc_msgSend_length(a1, v24, v25, v26);
  if (v32 <= 0)
  {
    NSLog(&cfstr_ErrorIncorrect.isa);
    return 0;
  }
  unint64_t v63 = a1;
  uint64_t v34 = objc_msgSend_stringWithCapacity_(MEMORY[0x1E4F28E78], v31, v32, v33);
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  uint64_t v36 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v35, (uint64_t)&v64, (uint64_t)v76, 16);
  if (v36)
  {
    uint64_t v40 = v36;
    uint64_t v41 = 0;
    unint64_t v42 = 0;
    uint64_t v43 = *(void *)v65;
    do
    {
      for (uint64_t k = 0; k != v40; ++k)
      {
        if (*(void *)v65 != v43) {
          objc_enumerationMutation(a3);
        }
        unint64_t v46 = objc_msgSend_rangeValue(*(void **)(*((void *)&v64 + 1) + 8 * k), v37, v38, v39);
        uint64_t v47 = v45;
        uint64_t v48 = v46 - v42;
        if (v46 > v42)
        {
          uint64_t v49 = objc_msgSend_substringWithRange_(v63, v45, v42, v48);
          objc_msgSend_appendString_(v34, v50, v49, v51);
        }
        uint64_t v52 = objc_msgSend_objectAtIndexedSubscript_(a4, v45, v41 + k, v48);
        objc_msgSend_appendString_(v34, v53, v52, v54);
        unint64_t v42 = (unint64_t)&v47[v46];
      }
      uint64_t v40 = objc_msgSend_countByEnumeratingWithState_objects_count_(a3, v37, (uint64_t)&v64, (uint64_t)v76, 16);
      v41 += k;
    }
    while (v40);
  }
  else
  {
    unint64_t v42 = 0;
  }
  if (v42 < objc_msgSend_length(v63, v37, v38, v39))
  {
    uint64_t v58 = objc_msgSend_length(v63, v55, v56, v57);
    uint64_t v60 = objc_msgSend_substringWithRange_(v63, v59, v42, v58 - v42);
    objc_msgSend_appendString_(v34, v61, v60, v62);
  }
  return objc_msgSend_stringWithString_(NSString, v55, (uint64_t)v34, v57);
}

uint64_t sub_1B6473554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDADE8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDADE8))
  {
    qword_1E9DDADE0 = (uint64_t)sub_1B6473FBC("RENDER_ELEMENT_PASS", 0x13u);
    __cxa_guard_release(&qword_1E9DDADE8);
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a4, qword_1E9DDADE0, a5);
  *(void *)a1 = &unk_1F0FB3E70;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  uint64_t v17 = *(void *)(a4 + 40);
  uint64_t v19 = *(void *)(a4 + 56);
  uint64_t v18 = *(void *)(a4 + 64);
  uint64_t v20 = *(void *)(a4 + 72);
  uint64_t v21 = *(void *)(a4 + 80);
  uint64_t v40 = *(void *)(a4 + 88);
  uint64_t v38 = *(void *)(a4 + 48);
  uint64_t v39 = *(CFX::RG::Resource **)(a4 + 96);
  __int16 v22 = v19 != 0;
  if (v18)
  {
    uint64_t v23 = (void *)CFX::RG::Pass::commonRenderParameters((CFX::RG::Pass *)a1);
    v22 |= 0x804u;
    v23[12] = 0;
    v23[13] = 0;
    v23[14] = 0;
    v23[15] = 0x47EFFFFFE0000000;
  }
  int v24 = sub_1B64469B8(*(void *)(a4 + 8), v10, v11, v12, v13, v14, v15, v16);
  __int16 v25 = v22 | 0x80;
  if (!v20) {
    __int16 v25 = v22;
  }
  if (v21) {
    v25 |= 2u;
  }
  if (v18) {
    v25 |= 4u;
  }
  if (v40) {
    v25 |= 0x200u;
  }
  __int16 v26 = v25 | 8;
  if (!v39) {
    __int16 v26 = v25;
  }
  int v27 = *(unsigned __int8 *)(a4 + 24);
  if (v24) {
    BOOL v28 = v27 == 0;
  }
  else {
    BOOL v28 = 1;
  }
  if (!v28) {
    v26 |= 0x400u;
  }
  uint64_t v41 = 0;
  __int16 v42 = v26;
  if (*(unsigned char *)(a4 + 16) == 1)
  {
    char v29 = sub_1B6447B7C(*(void *)(a4 + 8));
    uint64_t v30 = (void *)&unk_1E9DDA000;
    LOBYTE(v27) = *(unsigned char *)(a4 + 24);
  }
  else
  {
    char v29 = 0;
    uint64_t v30 = &unk_1E9DDA000;
  }
  char v43 = v29;
  uint64_t v44 = 3;
  char v45 = 0;
  char v46 = v27;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDADE8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDADE8))
  {
    v30[444] = sub_1B6473FBC("RENDER_ELEMENT_PASS", 0x13u);
    __cxa_guard_release(&qword_1E9DDADE8);
  }
  uint64_t v47 = v30[444];
  if (*(unsigned char *)(a4 + 16) == 1) {
    char v31 = sub_1B63CBCB0(*(void *)(a4 + 8));
  }
  else {
    char v31 = 1;
  }
  *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 268) = v31;
  *(void *)(a1 + 392) = *(void *)(a4 + 32);
  uint64_t v32 = *(void *)(a1 + 368);
  v48[0] = a2;
  v48[1] = a3;
  uint64_t v33 = sub_1B63C8330(v48, 0x40u, 8u);
  sub_1B6460520(v33, v32, (uint64_t)&v41, *(void *)(a1 + 392));
  *(void *)(a1 + 384) = v34;
  if (v17)
  {
    if (*(void *)(a4 + 104)) {
      uint64_t v35 = 0x100000001;
    }
    else {
      uint64_t v35 = 0x100000002;
    }
    CFX::RG::Pass::renderTo(a1, v17, v35, 0);
  }
  if (v38)
  {
    if (*(void *)(a4 + 112)) {
      uint64_t v36 = 0x200000001;
    }
    else {
      uint64_t v36 = 0x200000002;
    }
    CFX::RG::Pass::renderTo(a1, v38, v36, -1);
  }
  if (v19) {
    CFX::RG::Pass::renderTo(a1, v19, 0x100000002, 2);
  }
  if (v18) {
    CFX::RG::Pass::renderTo(a1, v18, 0x100000002, 3);
  }
  if (v21) {
    CFX::RG::Pass::renderTo(a1, v21, 0x100000002, 4);
  }
  if (v20) {
    CFX::RG::Pass::renderTo(a1, v20, 0x100000002, 5);
  }
  if (v40) {
    CFX::RG::Pass::renderTo(a1, v40, 0x100000002, 6);
  }
  if (v39) {
    CFX::RG::Pass::readFrom((uint64_t *)a1, v39);
  }
  return a1;
}

void sub_1B64738E8(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B6473908(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = sub_1B6447B50(a1[46], (const char *)a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Main::Setup", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/RenderElementsPass.mm", 116, v6 | 0x300000000);
  *(double *)v7.i64 = sub_1B644780C((float32x4_t *)a1[46]);
  float32x4_t v12 = v7;
  uint64_t v8 = (float64x2_t *)(*(uint64_t (**)(uint64_t *))(*a1 + 32))(a1);
  float64x2_t *v8 = vcvtq_f64_f32(*(float32x2_t *)v12.f32);
  v8[1] = vcvt_hight_f64_f32(v12);
  uint64_t v9 = *(CFX::CrossFrameResourceManager **)(a2 + 32);
  unint64_t v10 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v11 = sub_1B64739F4(v9, v10);
  a1[50] = v11;
  sub_1B65A8DB4(a1[49], v11 + 2064, 0x10u);

  prof_endFlame();
}

void sub_1B64739E0(_Unwind_Exception *a1)
{
}

uint64_t sub_1B64739F4(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B6473A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = sub_1B6447B50(*(void *)(a1 + 368), (const char *)a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Main::Prepare", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/RenderElementsPass.mm", 126, v6 | 0x300000000);
  sub_1B6460548(*(void *)(a1 + 384), (const char *)a2, v7, v8);
  uint64_t v16 = (void *)sub_1B6445900(*(void *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
  uint64_t v24 = sub_1B644558C(*(void *)(a1 + 368), v17, v18, v19, v20, v21, v22, v23);
  uint64_t v32 = sub_1B64B28B0(v24, v25, v26, v27, v28, v29, v30, v31);
  unint64_t v33 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v32) ^ ((0x9DDFEA08EB382D69 * v32) >> 47));
  uint64_t v34 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), 0x9DDFEA08EB382D69 * (v33 ^ (v33 >> 47)));
  if (v34)
  {
    uint64_t v37 = *(void *)(v34 + 48);
    if (v37) {
      objc_msgSend__setReflectionProbeArrayTexture_(v16, v35, v37, v36);
    }
  }

  prof_endFlame();
}

void sub_1B6473B28(_Unwind_Exception *a1)
{
}

void sub_1B6473B48(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7 = sub_1B6447B50(a1[46], (const char *)a2, a3, a4);
  prof_beginFlameSmallData((uint64_t)"Main::Render", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/RenderElementsPass.mm", 142, v7 | 0x300000000);
  uint64_t v8 = (const CFX::RG::Resource *)a1[51];
  if (v8)
  {
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v8);
    objc_msgSend_useResource_usage_stages_(*(void **)a3, v10, (uint64_t)Texture, 1, 2);
  }
  if (*(unsigned char *)((*(uint64_t (**)(uint64_t *))(*a1 + 32))(a1) + 268) && (*(unsigned char *)(a1[49] + 121) & 1) != 0) {
    uint64_t v11 = (unint64_t)*(unsigned __int8 *)(a3 + 17) << 8;
  }
  else {
    uint64_t v11 = 0;
  }
  sub_1B6460C38(a1[48], (const char *)a2, a3, v11);
  sub_1B65A8E14(a1[49], a1[50] + 2064, 0x10u);
  sub_1B65A8E74(a1[49], a1[50] + 16, 0x10u);
  sub_1B65A8ED4(a1[49], a1[50] + 1040, 0x10u);
  if (sub_1B6447FD4(a1[46]) && *(unsigned char *)(a1[49] + 132))
  {
    unint64_t v14 = 0;
    do
    {
      float32x2_t v15 = sub_1B6447FE4((float32x2_t *)a1[46], 0, v12, v13);
      float32x2_t v18 = sub_1B6447FE4((float32x2_t *)a1[46], (const char *)1, v16, v17);
      uint64_t v19 = 0;
      uint64_t v20 = (int8x16_t *)(a1[50] + (v14 << 6));
      int8x16_t v21 = v20[67];
      *(float32x2_t *)v22.i8 = vadd_f32(vsub_f32(v18, v15), *(float32x2_t *)v21.i8);
      v22.i64[1] = vextq_s8(v21, v21, 8uLL).u64[0];
      v20[67] = v22;
      uint64_t v23 = a1[50];
      uint64_t v24 = (float32x4_t *)(v23 + (v14 << 6));
      float32x4_t v25 = v24[65];
      float32x4_t v26 = v24[66];
      float32x4_t v27 = v24[67];
      float32x4_t v28 = v24[68];
      float32x4_t v29 = v24[2];
      float32x4_t v30 = v24[3];
      float32x4_t v31 = v24[4];
      v36[0] = v24[1];
      v36[1] = v29;
      v36[2] = v30;
      v36[3] = v31;
      do
      {
        v37[v19] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, COERCE_FLOAT(v36[v19])), v26, *(float32x2_t *)&v36[v19], 1), v27, (float32x4_t)v36[v19], 2), v28, (float32x4_t)v36[v19], 3);
        ++v19;
      }
      while (v19 != 4);
      long long v32 = v37[1];
      long long v33 = v37[2];
      long long v34 = v37[3];
      uint64_t v35 = (_OWORD *)(v23 + (v14 << 6));
      v35[129] = v37[0];
      v35[130] = v32;
      v35[131] = v33;
      v35[132] = v34;
      ++v14;
    }
    while (v14 < *(unsigned __int8 *)(a1[49] + 132));
  }

  prof_endFlame();
}

void sub_1B6473D50(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6473D6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDADF8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v20 = a2;
    uint64_t v21 = a3;
    int v19 = __cxa_guard_acquire(&qword_1E9DDADF8);
    uint64_t v8 = (void *)&unk_1E9DDA000;
    a2 = v20;
    a3 = v21;
    if (v19)
    {
      qword_1E9DDADF0 = (uint64_t)sub_1B6473FBC("LINEARIZE_DEPTH_PASS", 0x14u);
      __cxa_guard_release(&qword_1E9DDADF8);
      uint64_t v8 = (void *)&unk_1E9DDA000;
      a2 = v20;
      a3 = v21;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8[446], 0);
  *(void *)a1 = &unk_1F0FB3D88;
  long long v9 = *(_OWORD *)(a5 + 24);
  long long v10 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 416) = v10;
  *(_OWORD *)(a1 + 384) = v9;
  long long v11 = *(_OWORD *)(a5 + 72);
  long long v12 = *(_OWORD *)(a5 + 88);
  long long v13 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 480) = v13;
  *(_OWORD *)(a1 + 432) = v11;
  *(_OWORD *)(a1 + 448) = v12;
  long long v14 = *(_OWORD *)(a5 + 136);
  long long v15 = *(_OWORD *)(a5 + 152);
  long long v16 = *(_OWORD *)(a5 + 168);
  *(void *)(a1 + 544) = *(void *)(a5 + 184);
  *(_OWORD *)(a1 + 512) = v15;
  *(_OWORD *)(a1 + 528) = v16;
  *(_OWORD *)(a1 + 496) = v14;
  *(void *)(a1 + 568) = 0;
  *(_OWORD *)(a1 + 552) = 0u;
  CFX::RG::TextureDescriptorReference::withSampleCount((_OWORD *)(a1 + 392), 1, (uint64_t)&v23);
  *((void *)&v24 + 1) = 25;
  LOBYTE(v25) = 1;
  void v22[6] = v29;
  v22[7] = v30;
  v22[8] = v31;
  v22[9] = v32;
  v22[4] = v27;
  _OWORD v22[5] = v28;
  v22[2] = v25;
  long long v22[3] = v26;
  v22[0] = v23;
  v22[1] = v24;
  uint64_t v17 = sub_1B63CFDE4(a4, (uint64_t)"LINEAR_DEPTH", v22);
  *(void *)(a1 + 568) = v17;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v17, 0x100000000, 0);
  return a1;
}

void sub_1B6473F04(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6473F18(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDADD8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v9 = a2;
    uint64_t v10 = a1;
    int v7 = __cxa_guard_acquire(&qword_1E9DDADD8);
    uint64_t v2 = (_DWORD *)&unk_1E9DDA000;
    int v8 = v7;
    a2 = v9;
    a1 = v10;
    if (v8)
    {
      qword_1E9DDADD0 = (uint64_t)sub_1B6473FBC("VFX-Depth-Linear", 0x10u);
      __cxa_guard_release(&qword_1E9DDADD8);
      uint64_t v2 = (_DWORD *)&unk_1E9DDA000;
      a2 = v9;
      a1 = v10;
    }
  }
  uint64_t v3 = *(CFX::GPUResourceManager **)(a2 + 24);
  uint64_t v4 = *(const CFX::RG::Resource **)(a1 + 568);
  unsigned int v5 = v2[884];

  return CFX::GPUResourceManager::registerNamedFrameResource(v3, v4, v5);
}

unsigned __int8 *sub_1B6473FBC(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      uint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      __n128 result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void sub_1B64740A8(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::CrossFrameResourceManager::get(a2[4], v4);
  *(void *)(a1 + 552) = v5;
  if (!v5)
  {
    *(void *)(a1 + 552) = sub_1B64741C8(a2[4], v4);
    long long v13 = (void *)sub_1B6445900(*(void *)(a1 + 368), v6, v7, v8, v9, v10, v11, v12);
    uint64_t v17 = objc_msgSend_resourceManager(v13, v14, v15, v16);
    uint64_t v18 = *(void *)(CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 568))+ 16);
    int v19 = (void *)sub_1B653EFAC((uint64_t)v17);
    uint64_t v23 = objc_msgSend_frameworkLibrary(v19, v20, v21, v22);
    uint64_t v24 = *(void *)(a1 + 552);
    memset(v30, 0, sizeof(v30));
    uint64_t v31 = 0;
    uint64_t v32 = v23;
    uint64_t v33 = v18;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    char v45 = @"vertex_draw_quad";
    char v46 = @"linearize_depth2";
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    uint64_t v27 = objc_msgSend_newRenderPipelineStateWithDesc_(v17, v25, (uint64_t)v30, v26);
    long long v28 = *(void **)(v24 + 16);
    if (v28 != (void *)v27)
    {
      uint64_t v29 = v27;
      if (v28) {

      }
      *(void *)(v24 + 16) = v29;
    }
  }
}

uint64_t sub_1B64741C8(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void *sub_1B6474250(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 368), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v21 = objc_msgSend_renderEncoder(v10, v11, v12, v13);
  __n128 result = *(void **)(a1 + 384);
  if (result || (__n128 result = (void *)sub_1B6446564(*(uint64_t **)(a1 + 368), v14, v15, v16, v17, v18, v19, v20)) != 0)
  {
    __n128 result = sub_1B64A3B48((uint64_t)result, v14, v15, v16, v17, v18, v19, v20);
    if (result)
    {
      uint64_t v30 = sub_1B649D3DC((uint64_t)result, v23, v24, v25, v26, v27, v28, v29);
      float v32 = *(float *)(v30 + 4);
      float v31 = *(float *)(v30 + 8);
      float32_t v33 = v31 - v32;
      v34.f32[0] = v31 * v32;
      __asm { FMOV            V3.2S, #1.0 }
      _D3.f32[0] = v33;
      v34.f32[1] = v31;
      float32x2_t v56 = vdiv_f32(_D3, v34);
      uint64_t v57 = 0;
      uint64_t v58 = 0;
      uint64_t v59 = 0;
      sub_1B649F334(*(void *)(v21 + 24), &v56, 8uLL, &v57);
      objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v21 + 16), v40, v58, v59, 0);
      uint64_t v48 = *(void *)(a1 + 552);
      uint64_t v49 = *(void **)(v48 + 16);
      if (!v49)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v42, v43, v44, v45, v46, v47, (uint64_t)"_ptr != NULL");
        uint64_t v49 = *(void **)(v48 + 16);
      }
      uint64_t v50 = objc_msgSend_state(v49, v41, v42, v43);
      objc_msgSend_setRenderPipelineState_(*(void **)(v21 + 16), v51, v50, v52);
      id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
      sub_1B63C6ED0(v21, Texture, 0, v54);
      return (void *)sub_1B63F0064(v21, v55);
    }
  }
  return result;
}

uint64_t *sub_1B6474360(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v70 = 0;
  long long v71 = &v70;
  uint64_t v72 = 0x2020000000;
  char v73 = 0;
  uint64_t v10 = sub_1B644558C(*(void *)(a2 + 8), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B64B20C4(v10, v11, v12, v13, v14, v15, v16, v17);
  if (v18 && sub_1B644805C(*(void *)(a2 + 8)))
  {
    uint64_t v19 = (void *)sub_1B6355ECC(v18);
    v69[0] = MEMORY[0x1E4F143A8];
    v69[1] = 3221225472;
    v69[2] = sub_1B6474758;
    v69[3] = &unk_1E6142540;
    v69[4] = &v70;
    objc_msgSend_enumerateDrawCall_(v19, v20, (uint64_t)v69, v21);
  }
  unint64_t v22 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v10) ^ ((0x9DDFEA08EB382D69 * v10) >> 47));
  *(void *)&long long v35 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
  uint64_t v23 = (uint64_t *)sub_1B64747A4(a1, a2, (uint64_t *)&v35);
  if (*(void *)(a2 + 104))
  {
    *(void *)&long long v35 = *(void *)(a2 + 104);
    DWORD2(v35) = 0;
    uint64_t v36 = *(void *)(a2 + 40);
    uint64_t v37 = 0x100000000;
    CopyPass = (CFX::RG::Pass *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy input color", &v35);
    CFX::RG::Pass::dependsOn(v23, CopyPass);
  }
  if (*(void *)(a2 + 112))
  {
    *(void *)&long long v35 = *(void *)(a2 + 112);
    DWORD2(v35) = 0;
    uint64_t v36 = *(void *)(a2 + 48);
    uint64_t v37 = 0x100000000;
    uint64_t v25 = (CFX::RG::Pass *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy input depth", &v35);
    CFX::RG::Pass::dependsOn(v23, v25);
  }
  if (*((unsigned char *)v71 + 24))
  {
    uint64_t v26 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)(a2 + 48));
    CFX::RG::TextureDescriptorReference::withSampleCount(v26, 1, (uint64_t)&v59);
    v58[6] = v65;
    v58[7] = v66;
    v58[8] = v67;
    v58[9] = v68;
    v58[2] = v61;
    v58[3] = v62;
    v58[4] = v63;
    v58[5] = v64;
    v58[0] = v59;
    v58[1] = v60;
    uint64_t v27 = sub_1B63CFDE4(a1, (uint64_t)"DEPTH PREPASS", v58);
    uint64_t v28 = *(void *)(a2 + 8);
    v48[0] = "Depth prepass";
    v48[1] = v28;
    __int16 v49 = *(_WORD *)(a2 + 16);
    char v50 = 0;
    uint64_t v51 = *(void *)(a2 + 32);
    uint64_t v52 = 0;
    uint64_t v53 = v27;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    unint64_t v29 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v10 ^ 1)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ 1)) >> 47) ^ 1);
    *(void *)&long long v35 = 0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47));
    uint64_t v30 = (CFX::RG::Pass *)sub_1B64747A4(a1, (uint64_t)v48, (uint64_t *)&v35);
    uint64_t v31 = *(void *)(a2 + 8);
    *(void *)&long long v35 = "Linearize depth";
    *((void *)&v35 + 1) = v31;
    LOWORD(v36) = 0;
    uint64_t v37 = sub_1B6450668(*(void *)(a2 + 32));
    long long v44 = v65;
    long long v45 = v66;
    long long v46 = v67;
    long long v47 = v68;
    long long v40 = v61;
    long long v41 = v62;
    long long v42 = v63;
    long long v43 = v64;
    long long v38 = v59;
    long long v39 = v60;
    float v32 = (uint64_t *)sub_1B64747FC(a1, a1, (uint64_t)&v35);
    v32[70] = (uint64_t)v27;
    CFX::RG::Pass::readFrom(v32, v27);
    CFX::RG::Pass::dependsOn(v32, v30);
    CFX::RG::Pass::dependsOn(v23, (CFX::RG::Pass *)v32);
    float32_t v33 = (CFX::RG::Resource *)v32[71];
    CFX::RG::Pass::readFrom(v23, v33);
    v23[51] = (uint64_t)v33;
  }
  _Block_object_dispose(&v70, 8);
  return v23;
}

void sub_1B647470C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6474758(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t result = objc_msgSend_needsLinearDepth(a2, (const char *)a2, a3, a4);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  *(unsigned char *)(v4 + 24) = result;
  return result;
}

uint64_t sub_1B64747A4(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6474A1C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B64747FC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6474A7C(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6474858(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6474894(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B64748CC(uint64_t result)
{
  uint64_t v1 = 0;
  *(unsigned char *)(result + 8) = 0;
  *(void *)uint64_t result = &unk_1F0FB3E50;
  do
  {
    uint64_t v2 = (_OWORD *)(result + v1);
    v2[129] = xmmword_1B6E4F300;
    v2[130] = xmmword_1B6E4F320;
    v2[131] = xmmword_1B6E4F2E0;
    v2[132] = xmmword_1B6E4F370;
    v2[1] = xmmword_1B6E4F300;
    v2[2] = xmmword_1B6E4F320;
    v2[3] = xmmword_1B6E4F2E0;
    v2[4] = xmmword_1B6E4F370;
    v2[65] = xmmword_1B6E4F300;
    v2[66] = xmmword_1B6E4F320;
    v2[67] = xmmword_1B6E4F2E0;
    v1 += 64;
    v2[68] = xmmword_1B6E4F370;
  }
  while (v1 != 1024);
  return result;
}

void sub_1B6474950()
{
}

void *sub_1B6474964(void *a1)
{
  *a1 = &unk_1F0FB3D68;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B64749B0(void *a1)
{
  *a1 = &unk_1F0FB3D68;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B6474A1C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B6473554(v8, *a3, a3[1], a4, *a5);
}

uint64_t sub_1B6474A7C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x240u, 8u);
  return sub_1B6473D6C(v8, *a3, a3[1], a4, a5);
}

float32x4_t sub_1B6474ADC(float32x4_t *a1, float32x4_t *a2, uint64_t a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = (float *)(a3 + 32);
    uint64_t v5 = a2 + 2;
    uint64_t v6 = a1 + 2;
    uint64_t v7 = a4;
    do
    {
      float32x4_t v8 = v5[-2];
      float32x4_t v9 = v5[-1];
      float32x4_t v10 = *v5;
      float32x4_t v11 = v5[1];
      v5 += 4;
      float32x4_t v12 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, *(v4 - 8)), v9, *(v4 - 7)), v10, *(v4 - 6)), v11, *(v4 - 5));
      float32x4_t v13 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, *(v4 - 4)), v9, *(v4 - 3)), v10, *(v4 - 2)), v11, *(v4 - 1));
      float32x4_t v14 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, *v4), v9, v4[1]), v10, v4[2]), v11, v4[3]);
      float32x4_t result = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, v4[4]), v9, v4[5]), v10, v4[6]), v11, v4[7]);
      v6[-2] = v12;
      v6[-1] = v13;
      *uint64_t v6 = v14;
      v6[1] = result;
      v6 += 4;
      v4 += 16;
      --v7;
    }
    while (v7);
  }
  return result;
}

float32x4_t *sub_1B6474B70(float32x4_t *result, uint64_t a2, unsigned int a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7)
{
  if (a3)
  {
    uint64_t v7 = a3;
    float32x4_t v8 = (float *)(a2 + 32);
    float32x4_t v9 = result + 2;
    do
    {
      v9[-2] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a4, *(v8 - 8)), a5, *(v8 - 7)), a6, *(v8 - 6)), a7, *(v8 - 5));
      v9[-1] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a4, *(v8 - 4)), a5, *(v8 - 3)), a6, *(v8 - 2)), a7, *(v8 - 1));
      *float32x4_t v9 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a4, *v8), a5, v8[1]), a6, v8[2]), a7, v8[3]);
      v9[1] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a4, v8[4]), a5, v8[5]), a6, v8[6]), a7, v8[7]);
      v8 += 16;
      v9 += 4;
      --v7;
    }
    while (v7);
  }
  return result;
}

int32x4_t sub_1B6474C04(uint64_t a1, int32x4_t *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    uint64_t v4 = (float *)(a1 + 32);
    uint64_t v5 = a2 + 2;
    do
    {
      int32x4_t v6 = v5[-2];
      int32x4_t v7 = v5[-1];
      int32x4_t v8 = *v5;
      int32x4_t v9 = v5[1];
      v5 += 4;
      float32x4_t v10 = v4 - 8;
      float32x2x2_t v11 = (float32x2x2_t)vzip1q_s32(v6, v8);
      v14.val[0] = (float32x2_t)vzip2q_s32(v6, v8).u64[0];
      int32x4_t v12 = vzip1q_s32(v7, v9);
      v14.val[1] = (float32x2_t)vzip2q_s32(v7, v9).u64[0];
      int32x4_t result = vzip2q_s32((int32x4_t)v11, v12);
      vst2_f32(v10, v11);
      *((int32x4_t *)v4 - 1) = result;
      vst2_f32(v4, v14);
      v4 += 12;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t vfx_frustum_classify_aabb(float32x4_t *a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3 = a1[1];
  float32x4_t v4 = a1[2];
  float32x4_t v5 = a1[3];
  int32x4_t v6 = (int32x4_t)vmulq_f32(a2, *a1);
  int32x4_t v7 = (int32x4_t)vmulq_f32(a2, v3);
  int32x4_t v8 = (int32x4_t)vmulq_f32(a2, v4);
  int32x4_t v9 = (int32x4_t)vmulq_f32(a2, v5);
  int32x4_t v10 = vzip1q_s32(v6, v8);
  int32x4_t v11 = vzip2q_s32(v6, v8);
  int32x4_t v12 = vzip1q_s32(v7, v9);
  int32x4_t v13 = vzip2q_s32(v7, v9);
  float32x4_t v14 = vaddq_f32((float32x4_t)vzip2q_s32(v11, v13), vaddq_f32((float32x4_t)vzip1q_s32(v11, v13), vaddq_f32((float32x4_t)vzip1q_s32(v10, v12), (float32x4_t)vzip2q_s32(v10, v12))));
  int32x4_t v15 = (int32x4_t)vmulq_f32(a3, vabsq_f32(*a1));
  int32x4_t v16 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v3));
  int32x4_t v17 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v4));
  int32x4_t v18 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v5));
  int32x4_t v19 = vzip1q_s32(v15, v17);
  int32x4_t v20 = vzip2q_s32(v15, v17);
  int32x4_t v21 = vzip1q_s32(v16, v18);
  int32x4_t v22 = vzip2q_s32(v16, v18);
  int8x16_t v23 = (int8x16_t)vmaxnmq_f32(vsubq_f32(vabsq_f32(v14), vaddq_f32((float32x4_t)vzip2q_s32(v20, v22), vaddq_f32((float32x4_t)vzip1q_s32(v20, v22), vaddq_f32((float32x4_t)vzip1q_s32(v19, v21), (float32x4_t)vzip2q_s32(v19, v21))))), (float32x4_t)0);
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  float32x4_t v24 = (float32x4_t)vbslq_s8((int8x16_t)v22, (int8x16_t)v14, v23);
  if ((vmaxvq_u32((uint32x4_t)vcltzq_f32(v24)) & 0x80000000) != 0) {
    return 1;
  }
  float32x4_t v26 = a1[4];
  float32x4_t v25 = a1[5];
  int32x4_t v27 = (int32x4_t)vmulq_f32(a2, v26);
  int32x4_t v28 = (int32x4_t)vmulq_f32(a2, v25);
  int8x16_t v29 = (int8x16_t)vzip1q_s32(v27, v28);
  int8x16_t v30 = (int8x16_t)vzip2q_s32(v27, v28);
  *(float32x2_t *)v30.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), vadd_f32(*(float32x2_t *)v30.i8, vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL))));
  int32x4_t v31 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v26));
  int32x4_t v32 = (int32x4_t)vmulq_f32(a3, vabsq_f32(v25));
  int8x16_t v33 = (int8x16_t)vzip1q_s32(v31, v32);
  int8x16_t v34 = (int8x16_t)vzip2q_s32(v31, v32);
  float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)0x8000000080000000, *(int8x8_t *)v30.i8, (int8x8_t)vmaxnm_f32(vsub_f32(vabs_f32(*(float32x2_t *)v30.i8), vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), vadd_f32(*(float32x2_t *)v34.i8, vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL))))), 0));
  *(int32x2_t *)v34.i8 = vcltz_f32(v35);
  if ((vpmax_u32(*(uint32x2_t *)v34.i8, *(uint32x2_t *)v34.i8).u32[0] & 0x80000000) != 0) {
    return 1;
  }
  *(float32x2_t *)v36.f32 = vmul_f32(*(float32x2_t *)v24.f32, v35);
  v36.i64[1] = vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL).u64[0];
  return (vmaxvq_u32((uint32x4_t)vceqzq_f32(v36)) >> 30) & 2;
}

double sub_1B6474DB0(float32x4_t a1)
{
  __float2 v1 = __sincosf_stret(0.5 * a1.f32[0]);
  __float2 v2 = __sincosf_stret(vmuls_lane_f32(0.5, *(float32x2_t *)a1.f32, 1));
  __float2 v3 = __sincosf_stret(vmuls_lane_f32(0.5, a1, 2));
  v4.f32[0] = (float)(v3.__cosval * (float)(v1.__sinval * v2.__sinval))
            + (float)((float)(v1.__cosval * v2.__cosval) * v3.__sinval);
  v4.f32[1] = (float)(v3.__sinval * (float)(v1.__cosval * v2.__sinval))
            + (float)((float)(v1.__sinval * v2.__cosval) * v3.__cosval);
  v4.f32[2] = (float)((float)(v1.__cosval * v2.__sinval) * v3.__cosval)
            - (float)((float)(v1.__sinval * v2.__cosval) * v3.__sinval);
  float32x4_t v10 = v4;
  acosf((float)((float)(v1.__cosval * v2.__cosval) * v3.__cosval)- (float)((float)(v1.__sinval * v2.__sinval) * v3.__sinval));
  int32x4_t v5 = (int32x4_t)vmulq_f32(v10, v10);
  v5.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1))).u32[0];
  float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  *(void *)&double result = vmulq_n_f32(v10, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]).u64[0];
  return result;
}

void sub_1B6474EA4(float32x4_t a1)
{
  float v1 = a1.f32[3];
  __float2 v2 = __sincosf_stret(a1.f32[3]);
  float32x4_t v3 = vmulq_f32(a1, a1);
  v3.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u64[0];
  float32x4_t v4 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 0);
  float v5 = 1.0 - v2.__cosval;
  v4.i32[3] = 0;
  float32x4_t v6 = vrsqrteq_f32(v4);
  float32x4_t v7 = vmulq_f32(v6, vrsqrtsq_f32(v4, vmulq_f32(v6, v6)));
  int32x4_t v8 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v3.f32[0] != 0.0)), 0x1FuLL));
  v8.i32[3] = 0;
  int8x16_t v9 = (int8x16_t)vcltzq_s32(v8);
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v15 = vmulq_f32((float32x4_t)vbslq_s8(v9, (int8x16_t)vmulq_f32(v7, vrsqrtsq_f32(v4, vmulq_f32(v7, v7))), _Q2), a1);
  float v16 = vmuls_lane_f32(v2.__sinval, v15, 2)
      + (float)(vmuls_lane_f32(v15.f32[0], *(float32x2_t *)v15.f32, 1) * (float)(1.0 - v2.__cosval));
  float v22 = v15.f32[0];
  if (v16 <= 0.998)
  {
    if (v16 >= -0.998)
    {
      float v19 = v15.f32[1];
      float v20 = v15.f32[2];
      atan2f((float)(v5 * (float)-(float)(v15.f32[0] * v15.f32[2])) + (float)(v15.f32[1] * v2.__sinval), 1.0 - (float)((float)((float)(v20 * v20) + (float)(v19 * v19)) * v5));
      asinf(v16);
      atan2f((float)(v5 * (float)-(float)(v19 * v20)) + (float)(v22 * v2.__sinval), 1.0 - (float)((float)((float)(v20 * v20) + (float)(v22 * v22)) * v5));
    }
    else
    {
      __float2 v18 = __sincosf_stret(v1 * 0.5);
      atan2f(v18.__sinval * v22, v18.__cosval);
    }
  }
  else
  {
    __float2 v17 = __sincosf_stret(v1 * 0.5);
    atan2f(v17.__sinval * v22, v17.__cosval);
  }
}

uint64_t sub_1B6475058(int a1)
{
  if (a1 == 3) {
    return -1;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B6475064(int a1, int a2)
{
  if ((byte_1E9DDAE00 & 1) == 0)
  {
    dword_1E9DDAE04[0] = 16777473;
    word_1E9DDAE08 = 257;
    unk_1E9DDAE0A = 0;
    byte_1E9DDAE0E = 0;
    byte_1E9DDAE15 = 0;
    unk_1E9DDAE0F = 0;
    unk_1E9DDAE13 = 256;
    unk_1E9DDAE16 = 0x101010101010101;
    unk_1E9DDAE1D = 16843009;
    qword_1E9DDAE24 = 0x101010100000000;
    word_1E9DDAE2C = 257;
    unk_1E9DDAE2E = 16843008;
    unk_1E9DDAE32 = 0;
    unk_1E9DDAE3A = 0x101010100010000;
    word_1E9DDAE42 = 0;
    qword_1E9DDAE44 = 0x101010101010101;
    *(uint64_t *)((char *)&qword_1E9DDAE44 + 5) = 0x101010101010101;
    unk_1E9DDAE59 = 0;
    unk_1E9DDAE51 = 0;
    unk_1E9DDAE60 = 0;
    byte_1E9DDAE00 = 1;
  }
  return *((unsigned __int8 *)&dword_1E9DDAE04[5 * a1] + a2);
}

void sub_1B6475114(CFTypeRef *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"effect");
  }
  switch(a2)
  {
    case 0:
      float32x4_t v10 = a1 + 4;
      goto LABEL_21;
    case 1:
      float32x4_t v10 = a1 + 5;
      goto LABEL_21;
    case 2:
      float32x4_t v10 = a1 + 6;
      goto LABEL_21;
    case 3:
      float32x4_t v10 = a1 + 7;
      goto LABEL_21;
    case 4:
      float32x4_t v10 = a1 + 8;
      goto LABEL_21;
    case 5:
      float32x4_t v10 = a1 + 9;
      goto LABEL_21;
    case 6:
      float32x4_t v10 = a1 + 10;
      goto LABEL_21;
    case 7:
      float32x4_t v10 = a1 + 12;
      goto LABEL_21;
    case 8:
      float32x4_t v10 = a1 + 11;
      goto LABEL_21;
    case 9:
      float32x4_t v10 = a1 + 13;
      goto LABEL_21;
    case 10:
      float32x4_t v10 = a1 + 14;
      goto LABEL_21;
    case 11:
      float32x4_t v10 = a1 + 16;
      goto LABEL_21;
    case 12:
      float32x4_t v10 = a1 + 17;
      goto LABEL_21;
    case 13:
      float32x4_t v10 = a1 + 18;
      goto LABEL_21;
    case 14:
      float32x4_t v10 = a1 + 19;
      goto LABEL_21;
    case 15:
      float32x4_t v10 = a1 + 20;
      goto LABEL_21;
    case 16:
      float32x4_t v10 = a1 + 15;
LABEL_21:
      if (*v10)
      {
        CFRelease(*v10);
        *float32x4_t v10 = 0;
      }
      break;
    default:
      return;
  }
}

void *sub_1B6475264(int a1)
{
  uint64_t v1 = a1 - 1;
  if (v1 > 0xE) {
    return &unk_1E9DCA250;
  }
  else {
    return *(&off_1E6142600 + v1);
  }
}

uint64_t sub_1B6475290(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"profile");
  }
  switch(a2)
  {
    case 0:
      int32x4_t v11 = (uint64_t *)(a1 + 32);
      goto LABEL_22;
    case 1:
      int32x4_t v11 = (uint64_t *)(a1 + 40);
      goto LABEL_22;
    case 2:
      int32x4_t v11 = (uint64_t *)(a1 + 48);
      goto LABEL_22;
    case 3:
      int32x4_t v11 = (uint64_t *)(a1 + 56);
      goto LABEL_22;
    case 4:
      int32x4_t v11 = (uint64_t *)(a1 + 64);
      goto LABEL_22;
    case 5:
      int32x4_t v11 = (uint64_t *)(a1 + 72);
      goto LABEL_22;
    case 6:
      int32x4_t v11 = (uint64_t *)(a1 + 80);
      goto LABEL_22;
    case 7:
      int32x4_t v11 = (uint64_t *)(a1 + 96);
      goto LABEL_22;
    case 8:
      int32x4_t v11 = (uint64_t *)(a1 + 88);
      goto LABEL_22;
    case 9:
      int32x4_t v11 = (uint64_t *)(a1 + 104);
      goto LABEL_22;
    case 10:
      int32x4_t v11 = (uint64_t *)(a1 + 112);
      goto LABEL_22;
    case 11:
      int32x4_t v11 = (uint64_t *)(a1 + 128);
      goto LABEL_22;
    case 12:
      int32x4_t v11 = (uint64_t *)(a1 + 136);
      goto LABEL_22;
    case 13:
      int32x4_t v11 = (uint64_t *)(a1 + 144);
      goto LABEL_22;
    case 14:
      int32x4_t v11 = (uint64_t *)(a1 + 152);
      goto LABEL_22;
    case 15:
      int32x4_t v11 = (uint64_t *)(a1 + 160);
      goto LABEL_22;
    case 16:
      int32x4_t v11 = (uint64_t *)(a1 + 120);
LABEL_22:
      uint64_t result = *v11;
      if (v8)
      {
        if (!result)
        {
          uint64_t v13 = sub_1B647541C(a1, a2);
          *int32x4_t v11 = v13;
          float32x4_t v14 = (float *)sub_1B6475264(a2);
          sub_1B64754D0(v13, v14, v15, v16, v17, v18, v19, v20);
          uint64_t result = *v11;
        }
      }
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t sub_1B647541C(uint64_t a1, int a2)
{
  if (qword_1E9DDAE80 != -1) {
    dispatch_once(&qword_1E9DDAE80, &unk_1F0FB68A8);
  }
  uint64_t result = sub_1B63C8D44(qword_1E9DDAE78, 0x50uLL);
  *(unsigned char *)(result + 58) = a2;
  *(void *)(result + 80) = 0xFFFFFFFE3F800000;
  *(void *)(result + 88) = a1;
  uint64_t v5 = a2 - 4;
  if (v5 > 0x15) {
    __int16 v6 = 256;
  }
  else {
    __int16 v6 = word_1B6E50E46[v5];
  }
  if (a2 == 16) {
    __int16 v7 = 4096;
  }
  else {
    __int16 v7 = 7680;
  }
  *(_WORD *)(result + 56) = v6 | v7 | *(_WORD *)(result + 56) & 0xE0FF;
  return result;
}

void sub_1B64754D0(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  v18[0] = 0;
  v18[1] = 0;
  sub_1B6476CAC(a1, 2, a3, a4, a5, a6, a7, a8);
  if (!a2)
  {
    a2 = (float *)v18;
    sub_1B63C8F2C((float *)v18, 0.0, 0.0, 0.0, 1.0);
  }
  if (!sub_1B63C8DC4(a2, (float *)(a1 + 16)))
  {
    BOOL v10 = sub_1B63C8EC8((float *)(a1 + 16));
    *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
    if (*(unsigned char *)(a1 + 58) == 4 && !v10) {
      sub_1B63C8EC8((float *)(a1 + 16));
    }
    sub_1B6476D28(a1, 0, v11, v12, v13, v14, v15, v16, v17);
  }
}

__CFString *sub_1B647559C(unsigned int a1)
{
  if (a1 > 4) {
    return @"VFXhadingModelInvalid";
  }
  else {
    return off_1E6142678[a1];
  }
}

void sub_1B64755C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_12:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dst");
    if (a1) {
      goto LABEL_4;
    }
    goto LABEL_13;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"src");
  if (!a2) {
    goto LABEL_12;
  }
LABEL_3:
  if (a1) {
    goto LABEL_4;
  }
LABEL_13:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
LABEL_4:
  sub_1B6475724(a2, *(unsigned int *)(a1 + 24), a3, a4, a5, a6, a7, a8);
  for (uint64_t i = 0; i != 5; ++i)
  {
    uint64_t v17 = byte_1B6E50E41[i];
    float v18 = sub_1B64758EC((float *)a1, byte_1B6E50E41[i], v10, v11, v12, v13, v14, v15);
    sub_1B64757F0(a2, v17, v19, v20, v21, v22, v23, v24, v18);
  }
  unsigned __int8 v25 = 0;
  do
  {
    uint64_t v26 = sub_1B6475290(a1, (char)v25, 0, v11, v12, v13, v14, v15);
    if (v26)
    {
      uint64_t v28 = v26;
      uint64_t v29 = sub_1B6475290(a2, (char)v25, 1, v11, v12, v13, v14, v15);
      sub_1B6475968(v28, v29, v30, v31, v32, v33, v34, v35, v37);
    }
    unsigned int v36 = v25++;
  }
  while (v36 < 0x11);
  *(_DWORD *)(a2 + 201) = *(_DWORD *)(a2 + 201) & 0xFFFFFFFE | *(_DWORD *)(a1 + 201) & 1;
  sub_1B6475B1C(a2, *(unsigned __int8 *)(a1 + 184), v27, v11, v12, v13, v14, v15);
  *(_DWORD *)(a2 + 201) = *(_DWORD *)(a2 + 201) & 0xFFFFFFEF | (16 * ((*(_DWORD *)(a1 + 201) >> 4) & 1));
}

void sub_1B6475724(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  if (*(_DWORD *)(a1 + 24) != v8)
  {
    *(_DWORD *)(a1 + 24) = v8;
    sub_1B6475D58(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B64757A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  return *(unsigned int *)(a1 + 24);
}

void sub_1B64757F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  int v10 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  switch(v10)
  {
    case 19:
      float v12 = *(float *)(a1 + 176);
      if (v12 == a9) {
        return;
      }
      *(float *)(a1 + 176) = a9;
      break;
    case 18:
      float v12 = *(float *)(a1 + 172);
      if (v12 == a9) {
        return;
      }
      *(float *)(a1 + 172) = a9;
      break;
    case 17:
      *(float *)(a1 + 168) = a9;
      goto LABEL_17;
    default:
      return;
  }
  if (a9 == 0.0 || v12 == 0.0)
  {
LABEL_17:
    sub_1B6475D58(a1, a2, a3, a4, a5, a6, a7, a8);
    return;
  }
  uint64_t v13 = *(void *)(a1 + 16);

  sub_1B64AF754(v13, a2, a3, a4, a5, a6, a7, a8);
}

float sub_1B64758EC(float *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  if (a2 == 19) {
    return a1[44];
  }
  if (a2 == 18) {
    return a1[43];
  }
  float result = 0.0;
  if (a2 == 17) {
    return a1[42];
  }
  return result;
}

void sub_1B6475968(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int16 v11 = *(_WORD *)(a1 + 56);
  switch((char)v11)
  {
    case 0:
      if ((_BYTE)v11) {
        float v12 = 0;
      }
      else {
        float v12 = *(const void **)(a1 + 16);
      }
      sub_1B64762E4(a2, v12, a3, a4, a5, a6, a7, a8, v57);
      break;
    case 1:
      if (v11 == 1) {
        uint64_t v13 = *(const void **)(a1 + 16);
      }
      else {
        uint64_t v13 = 0;
      }
      sub_1B647708C(a2, v13, a3, a4, a5, a6, a7, a8, v57);
      break;
    case 2:
      sub_1B64754D0(a2, (float *)(a1 + 16), a3, a4, a5, a6, a7, a8);
      break;
    case 3:
      if (v11 == 4) {
        uint64_t v14 = *(const void **)(a1 + 16);
      }
      else {
        uint64_t v14 = 0;
      }
      sub_1B64778E8(a2, v14, a3, a4, a5, a6, a7, a8, v57);
      break;
    case 4:
      uint64_t v15 = (const void *)sub_1B64774C4(a1, a2, a3, a4, a5, a6, a7, a8);
      sub_1B647767C(a2, v15, v16, v17, v18, v19, v20, v21, v57);
      break;
    case 5:
      if (v11 == 5) {
        uint64_t v22 = *(const void **)(a1 + 16);
      }
      else {
        uint64_t v22 = 0;
      }
      sub_1B6477988(a2, v22, a3, a4, a5, a6, a7, a8, v57);
      break;
    case 6:
      if (v11 == 6) {
        uint64_t v23 = *(const void **)(a1 + 16);
      }
      else {
        uint64_t v23 = 0;
      }
      sub_1B6477A70(a2, v23, a3, a4, a5, a6, a7, a8, v57);
      break;
    default:
      break;
  }
  sub_1B64766D8(a2, *(CFTypeRef *)(a1 + 64), a3, a4, a5, a6, a7, a8, v57);
  if (*(void *)(a1 + 72))
  {
    uint64_t v31 = sub_1B63CA51C(0x40uLL);
    *(void *)(a2 + 72) = v31;
    uint64_t v32 = *(_OWORD **)(a1 + 72);
    long long v34 = v32[2];
    long long v33 = v32[3];
    long long v35 = v32[1];
    *uint64_t v31 = *v32;
    v31[1] = v35;
    v31[2] = v34;
    v31[3] = v33;
  }
  uint64_t v36 = sub_1B647650C(a1, v24, v25, v26, v27, v28, v29, v30);
  sub_1B6476570(a2, v36, v37, v38, v39, v40, v41, v42, v58);
  sub_1B6477BB4(a2, (*(unsigned __int16 *)(a1 + 56) >> 9) & 0xF, v43, v44, v45, v46, v47, v48, v59);
  float v56 = *(float *)(a1 + 80);

  sub_1B64763F8(a2, v56, v49, v50, v51, v52, v53, v54, v55, a9);
}

void sub_1B6475B1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  if (*(unsigned __int8 *)(a1 + 184) != v8)
  {
    *(unsigned char *)(a1 + 184) = v8;
    sub_1B6475D58(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B6475B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  sub_1B6475724(a1, 3, a3, a4, a5, a6, a7, a8);
  for (uint64_t i = 0; i != 17; ++i)
    sub_1B6475114((CFTypeRef *)a1, byte_1B6E50E30[i], v9, v10, v11, v12, v13, v14);
  for (uint64_t j = 0; j != 5; ++j)
  {
    uint64_t v17 = byte_1B6E50E41[j];
    if ((v17 - 17) >= 2) {
      float v18 = 0.0;
    }
    else {
      float v18 = 1.0;
    }
    sub_1B64757F0(a1, v17, v9, v10, v11, v12, v13, v14, v18);
  }
  *(unsigned char *)(a1 + 184) = 0;
  int v19 = *(_DWORD *)(a1 + 201);
  *(void *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(unsigned char *)(a1 + 200) = 1;
  *(_DWORD *)(a1 + 201) = v19 & 0xFFFFFFAC;
}

double sub_1B6475C80()
{
  if (!qword_1E9DDAE68)
  {
    qword_1E9DDAE68 = sub_1B63C8D10(&qword_1E9DDAE68);
    qword_1EB974520 = (uint64_t)sub_1B6478164;
    double result = *(double *)&xmmword_1F0FB87D8;
    xmmword_1EB974510 = xmmword_1F0FB87D8;
  }
  return result;
}

uint64_t sub_1B6475CE8(uint64_t a1)
{
  if (qword_1E9DDAE70 != -1) {
    dispatch_once(&qword_1E9DDAE70, &unk_1F0FB5828);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1E9DDAE68, 0xC0uLL);
  uint64_t v10 = v2;
  if (v2)
  {
    *(void *)(v2 + 16) = a1;
    sub_1B6475B9C(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return v10;
}

void sub_1B6475D58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)(a1 + 16);
  if (v9)
  {
    uint64_t v10 = sub_1B63F4F54(v9, a2, a3, a4, a5, a6, a7, a8);
    sub_1B64B1F18(v10, 3, *(const void **)(a1 + 16), 0, v11, v12, v13, v14);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: orphan effect common profile detected", a3, a4, a5, a6, a7, a8, v23);
  }
  uint64_t v22 = *(void *)(a1 + 16);

  sub_1B64AF754(v22, v15, v16, v17, v18, v19, v20, v21);
}

void *sub_1B6475DBC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  uint64_t v10 = sub_1B6475290(a1, a2, 0, a4, a5, a6, a7, a8);
  if (v10 && *(unsigned char *)(v10 + 56) == 2) {
    return (void *)(v10 + 16);
  }

  return sub_1B6475264(a2);
}

uint64_t sub_1B6475E50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 56) == 2) {
    return a1 + 16;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B6475EA8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v27 = *(float32x4_t *)sub_1B6475DBC(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = sub_1B6475290(a1, a2, 0, v10, v11, v12, v13, v14);
  if (v15 && sub_1B6475F88(v15, v16, v17, v18, v19, v20, v21, v22)) {
    sub_1B63C8F2C(v27.f32, 1.0, 1.0, 1.0, 1.0);
  }
  float v23 = sub_1B6476060(a1, a2, v17, v18, v19, v20, v21, v22);
  if (v23 != 1.0)
  {
    if (a2 == 5)
    {
      *(float *)v24.i32 = 1.0 - v23;
      *(float32x2_t *)v27.f32 = vmla_n_f32((float32x2_t)vdup_lane_s32(v24, 0), *(float32x2_t *)v27.f32, v23);
      float v25 = (float)(1.0 - v23) + (float)(v23 * v27.f32[2]);
    }
    else
    {
      if (a2 == 4)
      {
        float32x4_t v27 = vmulq_n_f32(v27, v23);
        return v27.i64[0];
      }
      *(float32x2_t *)v27.f32 = vmul_n_f32(*(float32x2_t *)v27.f32, v23);
      float v25 = v23 * v27.f32[2];
    }
    v27.f32[2] = v25;
  }
  return v27.i64[0];
}

BOOL sub_1B6475F88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"materialProperty");
  }
  __int16 v15 = *(_WORD *)(a1 + 56);
  if (!(_BYTE)v15)
  {
    uint64_t v18 = *(void *)(a1 + 16);
    if (v18)
    {
      if (sub_1B643C62C(v18, a2, a3, a4, a5, a6, a7, a8)) {
        return 1;
      }
      __int16 v15 = *(_WORD *)(a1 + 56);
    }
  }
  if (v15 == 5 && *(void *)(a1 + 16) || sub_1B64774C4(a1, a2, a3, a4, a5, a6, a7, a8)) {
    return 1;
  }
  int v16 = *(unsigned __int8 *)(a1 + 56);
  return (v16 == 4 || v16 == 1) && *(void *)(a1 + 16) != 0;
}

float sub_1B6476060(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  uint64_t v10 = sub_1B6475290(a1, a2, 0, a4, a5, a6, a7, a8);
  if (v10) {
    return *(float *)(v10 + 80);
  }
  else {
    return 1.0;
  }
}

float sub_1B64760CC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(result) = sub_1B6475EA8(a1, a2, a3, a4, a5, a6, a7, a8);
  return result;
}

void sub_1B64760E8(uint64_t a1, int a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  uint64_t v11 = sub_1B6475290(a1, a2, 1, a4, a5, a6, a7, a8);
  if (v11)
  {
    sub_1B64754D0(v11, a3, v12, v13, v14, v15, v16, v17);
  }
}

uint64_t sub_1B647617C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  uint64_t result = sub_1B6475290(a1, a2, 0, a4, a5, a6, a7, a8);
  if (result)
  {
    if (*(unsigned char *)(result + 56)) {
      return 0;
    }
    else {
      return *(void *)(result + 16);
    }
  }
  return result;
}

uint64_t sub_1B64761F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 56)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 16);
  }
}

void sub_1B647624C(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  uint64_t v12 = sub_1B6475290(a1, a2, a3 != 0, a4, a5, a6, a7, a8);
  if (v12)
  {
    sub_1B64762E4(v12, a3, v13, v14, v15, v16, v17, v18, a9);
  }
}

void sub_1B64762E4(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  uint64_t v11 = *(const void **)(a1 + 16);
  sub_1B6476CAC(a1, 0, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = *(const void **)(a1 + 16);
  if (v18 != a2)
  {
    if (v18)
    {
      CFRelease(v18);
      *(void *)(a1 + 16) = 0;
    }
    if (a2) {
      CFTypeRef v19 = CFRetain(a2);
    }
    else {
      CFTypeRef v19 = 0;
    }
    *(void *)(a1 + 16) = v19;
  }
  if (v11 != a2)
  {
    sub_1B6476D28(a1, 1, v12, v13, v14, v15, v16, v17, a9);
  }
}

float sub_1B64763AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  return *(float *)(a1 + 80);
}

void sub_1B64763F8(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a4, a5, a6, a7, a8, a9, (uint64_t)"materialProperty");
  }
  if (*(float *)(a1 + 80) != a2)
  {
    *(float *)(a1 + 80) = a2;
    sub_1B6476D28(a1, 0, a4, a5, a6, a7, a8, a9, a10);
  }
}

uint64_t sub_1B6476488(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  uint64_t v10 = sub_1B6475290(a1, a2, 0, a4, a5, a6, a7, a8);
  if (!v10) {
    return -1;
  }
  int v11 = *(_DWORD *)(v10 + 84);
  if (v11 == -2)
  {
    if (*(unsigned char *)(v10 + 58) == 3) {
      return -1;
    }
    else {
      return 0;
    }
  }
  return v11;
}

uint64_t sub_1B647650C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  int v9 = *(_DWORD *)(a1 + 84);
  if (v9 == -2)
  {
    if (*(unsigned char *)(a1 + 58) == 3) {
      return -1;
    }
    else {
      return 0;
    }
  }
  return v9;
}

void sub_1B6476570(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(_DWORD *)(a1 + 84) != a2)
  {
    *(_DWORD *)(a1 + 84) = a2;
    sub_1B6476D28(a1, 0, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B64765F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  return *(void *)(a1 + 64);
}

void sub_1B6476640(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  uint64_t v12 = sub_1B6475290(a1, a2, a3 != 0, a4, a5, a6, a7, a8);
  if (v12)
  {
    sub_1B64766D8(v12, a3, v13, v14, v15, v16, v17, v18, a9);
  }
}

void sub_1B64766D8(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  CFTypeRef v11 = *(CFTypeRef *)(a1 + 64);
  if (v11 != cf)
  {
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 64) = 0;
    }
    if (cf) {
      CFTypeRef v12 = CFRetain(cf);
    }
    else {
      CFTypeRef v12 = 0;
    }
    *(void *)(a1 + 64) = v12;
    sub_1B6476D28(a1, 0, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B647677C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  int v9 = *(_DWORD *)(a1 + 24);
  if (v9 >= 5)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXCommonProfileGetHashCode: inconsistency error", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile->_shadingModel < CFXShadingModelCount && CFXShadingModelCount < 15");
    LOWORD(v9) = *(_WORD *)(a1 + 24);
  }
  __int16 v10 = v9 | (16 * *(unsigned __int8 *)(a1 + 200));
  if (sub_1B64AF3EC(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8)) {
    __int16 v11 = 32;
  }
  else {
    __int16 v11 = 0;
  }
  return (unsigned __int16)(v10 | v11 | ((*(_WORD *)(a1 + 201) & 1) << 6) | (32 * *(_WORD *)(a1 + 201)) & 0x780 | ((*(unsigned char *)(a1 + 184) & 0xF) << 11));
}

uint64_t sub_1B647683C(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B6475290((uint64_t)a1, a2, 0, a4, a5, a6, a7, a8);
  if (a2 >= 0x11)
  {
    if ((a2 - 17) >= 3) {
      return 0;
    }
    else {
      return 16 * (sub_1B64758EC(a1, a2, v11, v12, v13, v14, v15, v16) == 0.0);
    }
  }
  else
  {
    return sub_1B64768B8(v10, a2, v11, v12, v13, v14, v15, v16);
  }
}

uint64_t sub_1B64768B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    goto LABEL_11;
  }
  BOOL v9 = sub_1B6475F88(a1, a2, a3, a4, a5, a6, a7, a8);
  int v10 = 1;
  if (!v9)
  {
    LODWORD(a2) = *(unsigned __int8 *)(a1 + 58);
    BOOL v14 = a2 > 0x10 || ((1 << a2) & 0x10640) == 0;
    if (!v14)
    {
      BOOL v11 = 0;
      BOOL v12 = 0;
      BOOL v13 = 0;
      int v10 = 0;
      goto LABEL_13;
    }
    if (*(unsigned char *)(a1 + 56) == 2)
    {
      uint64_t v15 = (float *)(a1 + 16);
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v15 = (float *)sub_1B6475264((char)a2);
LABEL_12:
    BOOL v13 = sub_1B63C8E84(v15);
    BOOL v12 = sub_1B63C8EC8(v15);
    int v10 = 0;
    int v16 = 0;
    int v17 = 0;
    int v18 = 0;
    BOOL v11 = v15[3] >= 1.0;
    if (!a1) {
      goto LABEL_16;
    }
    goto LABEL_13;
  }
  BOOL v11 = 0;
  BOOL v12 = 0;
  BOOL v13 = 0;
LABEL_13:
  int v16 = (*(float *)(a1 + 80) != 1.0) << 12;
  int v19 = (*(unsigned __int16 *)(a1 + 56) >> 9) & 0xF;
  BOOL v14 = v19 == 15;
  int v18 = v19 << 13;
  if (v14) {
    int v18 = 0;
  }
  int v17 = v10;
LABEL_16:
  if (v13) {
    int v20 = 2;
  }
  else {
    int v20 = 0;
  }
  if (v12) {
    int v21 = 4;
  }
  else {
    int v21 = 0;
  }
  if (v11) {
    int v22 = 8;
  }
  else {
    int v22 = 0;
  }
  return v17 | v16 | v20 | v21 | v18 | v22;
}

void sub_1B64769F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  if (((((*(_DWORD *)(a1 + 201) & 1) == 0) ^ v8) & 1) == 0)
  {
    *(_DWORD *)(a1 + 201) = *(_DWORD *)(a1 + 201) & 0xFFFFFFFE | v8;
    sub_1B6475D58(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B6476A84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  return *(_DWORD *)(a1 + 201) & 1;
}

void sub_1B6476AD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  if (*(unsigned __int8 *)(a1 + 200) != v8)
  {
    *(unsigned char *)(a1 + 200) = v8;
    *(_DWORD *)(a1 + 201) |= 2u;
    sub_1B6475D58(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_1B6476B60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  return *(unsigned __int8 *)(a1 + 200);
}

uint64_t sub_1B6476BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  return *(unsigned __int8 *)(a1 + 184);
}

uint64_t sub_1B6476BF8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B6475290(a1, a2, 0, a4, a5, a6, a7, a8);
  if (result)
  {
    return sub_1B6475F88(result, v9, v10, v11, v12, v13, v14, v15);
  }
  return result;
}

uint64_t sub_1B6476C30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commonProfile");
  }
  return (*(unsigned __int8 *)(a1 + 201) >> 2) & 1;
}

uint64_t sub_1B6476C80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B6476BF8(a1, 7, a3, a4, a5, a6, a7, a8);
}

float sub_1B6476C88(uint64_t a1)
{
  return *(float *)(a1 + 180);
}

void sub_1B6476C90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (*(float *)(a1 + 180) != a9)
  {
    *(float *)(a1 + 180) = a9;
    sub_1B64AF754(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B6476CAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned __int8 *)(a1 + 56) != v9)
  {
    sub_1B64794F0(a1, a2, a3, a4, a5, a6, a7, a8);
    if (v9 == 2) {
      *(_OWORD *)(a1 + 16) = *(_OWORD *)sub_1B6475264(*(char *)(a1 + 58));
    }
    *(unsigned char *)(a1 + 56) = v9;
  }
}

void sub_1B6476D28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(char *)(a1 + 58) <= 19 && (uint64_t v11 = *(void *)(a1 + 88)) != 0)
  {
    if (v9) {
      *(_DWORD *)(v11 + 201) &= ~0x40u;
    }
    sub_1B6475D58(v11, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    int v12 = *(unsigned __int8 *)(a1 + 58);
    if ((v12 - 21) < 2)
    {
      int v22 = *(float32x4_t **)(a1 + 88);
      if (v22)
      {
        sub_1B6494664(v22, a2, a3, a4, a5, a6, a7, a8, a9);
      }
    }
    else if (v12 == 24)
    {
      uint64_t v23 = *(void *)(a1 + 88);
      if (v23)
      {
        CFTypeID v24 = CFGetTypeID(*(CFTypeRef *)(a1 + 88));
        if (v9)
        {
          if (v24 == sub_1B6494820())
          {
            sub_1B6494760(v23, v25, v26, v27, v28, v29, v30, v31);
          }
          else
          {
            if (v24 != sub_1B64B19F4()) {
              sub_1B63F2F54(17, @"Assertion '%s' failed. LightingEnvironment not set on a Light or a World", v40, v41, v42, v43, v44, v45, (uint64_t)"typeID == CFXWorldGetTypeID()");
            }
            sub_1B64B377C(v23, v39, v40, v41, v42, v43, v44, v45);
            sub_1B65E5064(v23, (const void *)a1, v46, v47, v48, v49, v50, v51, a9);
          }
        }
        else if (v24 == sub_1B64B19F4())
        {
          sub_1B65E52B4(v23, (const void *)a1);
        }
      }
    }
    else if (v12 == 26)
    {
      uint64_t v13 = *(void **)(a1 + 88);
      if (v13)
      {
        CFTypeID v14 = CFGetTypeID(v13);
        if (v14 == sub_1B63CD970())
        {
          sub_1B63CE8F0(v13, v15, v16, v17, v18, v19, v20, v21);
        }
        else if (v14 == sub_1B64AEBD0())
        {
          sub_1B64AFC88((uint64_t)v13, v32, v33, v34, v35, v36, v37, v38);
        }
      }
    }
  }
}

uint64_t sub_1B6476F6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  return a1 + 16;
}

uint64_t sub_1B6476FB8(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 56)) {
    return !*(void *)(a1 + 16);
  }
  if (*(unsigned char *)(a1 + 56) != 2) {
    return 0;
  }
  uint64_t v2 = (float *)sub_1B6475264(*(char *)(a1 + 58));

  return sub_1B63C8DC4((float *)(a1 + 16), v2);
}

uint64_t sub_1B647702C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 56) == 1) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

void sub_1B647708C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  uint64_t v11 = *(const void **)(a1 + 16);
  sub_1B6476CAC(a1, 1, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = *(const void **)(a1 + 16);
  if (v18 != a2)
  {
    if (v18)
    {
      CFRelease(v18);
      *(void *)(a1 + 16) = 0;
    }
    if (a2) {
      CFTypeRef v19 = CFRetain(a2);
    }
    else {
      CFTypeRef v19 = 0;
    }
    *(void *)(a1 + 16) = v19;
    *(void *)(a1 + 40) = 0;
  }
  if (v11 != a2)
  {
    sub_1B6476D28(a1, 1, v12, v13, v14, v15, v16, v17, a9);
  }
}

uint64_t sub_1B6477158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 56) != 1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. invalid content type", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty->_contentsType == kCFXContentTypeAsset");
  }
  return *(void *)(a1 + 40);
}

void sub_1B64771CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  *(void *)(a1 + 40) = a2;
}

uint64_t sub_1B647721C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  return *(void *)(a1 + 72);
}

BOOL sub_1B6477268(uint64_t a1)
{
  return *(void *)(a1 + 72) != 0;
}

void sub_1B6477278(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  uint64_t v10 = *(float32x4_t **)(a1 + 72);
  uint64_t v11 = (float32x4_t *)MEMORY[0x1E4F149A0];
  if (v10)
  {
    float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x3727C5ACu);
    unsigned int v13 = vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(v10[1], *(float32x4_t *)(MEMORY[0x1E4F149A0] + 16))), (int8x16_t)vcgeq_f32(v12, vabdq_f32(*v10, *MEMORY[0x1E4F149A0]))), vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(v10[2], *(float32x4_t *)(MEMORY[0x1E4F149A0] + 32))), (int8x16_t)vcgeq_f32(v12, vabdq_f32(v10[3], *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48)))))) >> 31;
    if (!a2)
    {
      *uint64_t v10 = (float32x4_t)xmmword_1B6E4F300;
      v10[1] = (float32x4_t)xmmword_1B6E4F320;
      void v10[2] = (float32x4_t)xmmword_1B6E4F2E0;
      v10[3] = (float32x4_t)xmmword_1B6E4F370;
      goto LABEL_9;
    }
  }
  else
  {
    if (!a2) {
      return;
    }
    uint64_t v10 = (float32x4_t *)malloc_type_malloc(0x40uLL, 0x1000040FA0F61DDuLL);
    *(void *)(a1 + 72) = v10;
    unsigned int v13 = 1;
  }
  float32x4_t v14 = *a2;
  float32x4_t v15 = a2[1];
  float32x4_t v16 = a2[3];
  void v10[2] = a2[2];
  v10[3] = v16;
  *uint64_t v10 = v14;
  v10[1] = v15;
LABEL_9:
  sub_1B6476D28(a1, 0, a3, a4, a5, a6, a7, a8, v29);
  CFTypeID v24 = *(float32x4_t **)(a1 + 72);
  if (v24)
  {
    float32x4_t v25 = (float32x4_t)vdupq_n_s32(0x3727C5ACu);
    unsigned int v26 = vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v25, vabdq_f32(v24[1], v11[1])), (int8x16_t)vcgeq_f32(v25, vabdq_f32(*v24, *v11))), vandq_s8((int8x16_t)vcgeq_f32(v25, vabdq_f32(v24[2], v11[2])), (int8x16_t)vcgeq_f32(v25, vabdq_f32(v24[3], v11[3]))))) >> 31;
  }
  else
  {
    unsigned int v26 = 1;
  }
  if (v26 != v13 && *(unsigned char *)(a1 + 58) == 24)
  {
    uint64_t v27 = *(void **)(a1 + 88);
    if (v27)
    {
      uint64_t v28 = (const void *)sub_1B63F4F54(v27, v17, v18, v19, v20, v21, v22, v23);
      sub_1B6595A0C(@"kCFXNotificationEngineContextInvalidatePasses", v28, 0, 1u);
    }
  }
}

uint64_t sub_1B6477464(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 56) == 5) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B64774C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  int v9 = *(unsigned __int8 *)(a1 + 56);
  if (v9 == 5)
  {
    uint64_t v10 = a1 + 32;
    return *(void *)v10;
  }
  if (v9 == 3)
  {
    uint64_t v10 = a1 + 16;
    return *(void *)v10;
  }
  return 0;
}

uint64_t sub_1B6477538(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 56) == 4) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

BOOL sub_1B6477598(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"materialProperty");
  }
  return *(unsigned char *)(a1 + 56) == 6 && *(void *)(a1 + 16) != 0;
}

uint64_t sub_1B647761C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 56) == 6) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

void sub_1B647767C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  uint64_t v11 = *(const void **)(a1 + 16);
  sub_1B6476CAC(a1, 3, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = *(const void **)(a1 + 16);
  if (v18 != a2)
  {
    if (v18)
    {
      CFRelease(v18);
      *(void *)(a1 + 16) = 0;
    }
    if (a2) {
      CFTypeRef v19 = CFRetain(a2);
    }
    else {
      CFTypeRef v19 = 0;
    }
    *(void *)(a1 + 16) = v19;
  }
  if (v11 != a2)
  {
    sub_1B6476D28(a1, 1, v12, v13, v14, v15, v16, v17, a9);
  }
}

void sub_1B6477744(uint64_t a1, int *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  uint64_t v11 = *(const char **)(a1 + 64);
  if (!v11) {
    uint64_t v11 = (const char *)sub_1B643DF24();
  }
  switch(*(unsigned char *)(a1 + 56))
  {
    case 0:
      uint64_t v12 = *(void *)(a1 + 16);
      if (!v12 || !sub_1B643C62C(*(void *)(a1 + 16), (uint64_t)v11, (uint64_t)a3, a4, a5, a6, a7, a8)) {
        return;
      }
      if ((sub_1B64778A8(a1) & 2) != 0 && sub_1B643BD8C(v12, v13, v14, v15, v16, v17, v18, v19))
      {
        int v20 = 4;
      }
      else
      {
        unsigned int v32 = sub_1B643BE9C(v12, v13, v14, v15, v16, v17, v18, v19);
        if (v32 > 7)
        {
LABEL_21:
          char v21 = sub_1B643B768(v12, v13, v14, v15, v16, v17, v18, v19) ^ 1;
          goto LABEL_22;
        }
        int v20 = dword_1B6E50E74[v32];
      }
      *a2 = v20;
      goto LABEL_21;
    case 1:
      if (!*(void *)(a1 + 16)) {
        return;
      }
      char v21 = 1;
      int v22 = sub_1B6447B30(1u);
      goto LABEL_15;
    case 4:
      uint64_t v23 = *(void **)(a1 + 16);
      if (!v23) {
        return;
      }
      int v22 = sub_1B64D8748(v23, v11, (uint64_t)a3, a4);
      char v21 = 0;
LABEL_15:
      *a2 = v22;
      goto LABEL_22;
    case 5:
      uint64_t v24 = *(void *)(a1 + 16);
      if (!v24) {
        return;
      }
      *a2 = sub_1B6447B30(1u);
      char v21 = sub_1B6451AF0(v24, v25, v26, v27, v28, v29, v30, v31);
LABEL_22:
      *a3 = v21;
      return;
    default:
      return;
  }
}

uint64_t sub_1B64778A8(uint64_t a1)
{
  int v1 = *(char *)(a1 + 58);
  unsigned int v2 = v1 - 23;
  if (v1 == 3) {
    int v3 = 2;
  }
  else {
    int v3 = 0;
  }
  if (v1 == 25) {
    int v4 = 8;
  }
  else {
    int v4 = v3;
  }
  if (v2 < 2) {
    int v4 = 6;
  }
  return v4 | ((*(_WORD *)(a1 + 56) & 0x100) == 0);
}

void sub_1B64778E8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  sub_1B6476CAC(a1, 4, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = *(const void **)(a1 + 16);
  if (v17 != a2)
  {
    if (v17)
    {
      CFRelease(v17);
      *(void *)(a1 + 16) = 0;
    }
    if (a2) {
      CFTypeRef v18 = CFRetain(a2);
    }
    else {
      CFTypeRef v18 = 0;
    }
    *(void *)(a1 + 16) = v18;
  }

  sub_1B6476D28(a1, 1, v11, v12, v13, v14, v15, v16, a9);
}

void sub_1B6477988(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  uint64_t v11 = *(const void **)(a1 + 16);
  sub_1B6476CAC(a1, 5, a3, a4, a5, a6, a7, a8);
  CFTypeRef v18 = *(const void **)(a1 + 16);
  if (v18 != a2)
  {
    if (v18)
    {
      CFRelease(v18);
      *(void *)(a1 + 16) = 0;
    }
    if (a2) {
      CFTypeRef v19 = CFRetain(a2);
    }
    else {
      CFTypeRef v19 = 0;
    }
    *(void *)(a1 + 16) = v19;
    if (*(char *)(a1 + 58) <= 19)
    {
      uint64_t v20 = *(void *)(a1 + 88);
      if (v20) {
        *(_DWORD *)(v20 + 201) &= 0xFFF0007F;
      }
    }
  }
  if (v11 != a2)
  {
    sub_1B6476D28(a1, 1, v12, v13, v14, v15, v16, v17, a9);
  }
}

void sub_1B6477A70(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  if (*(unsigned char *)(a1 + 58) == 24)
  {
    uint64_t v11 = *(const void **)(a1 + 16);
    sub_1B6476CAC(a1, 6, a3, a4, a5, a6, a7, a8);
    CFTypeRef v18 = *(const void **)(a1 + 16);
    if (v18 != a2)
    {
      if (v18)
      {
        CFRelease(v18);
        *(void *)(a1 + 16) = 0;
      }
      if (a2) {
        CFTypeRef v19 = CFRetain(a2);
      }
      else {
        CFTypeRef v19 = 0;
      }
      *(void *)(a1 + 16) = v19;
      if (*(char *)(a1 + 58) <= 19)
      {
        uint64_t v20 = *(void *)(a1 + 88);
        if (v20) {
          *(_DWORD *)(v20 + 201) &= 0xFFF0007F;
        }
      }
    }
    if (v11 != a2)
    {
      sub_1B6476D28(a1, 1, v12, v13, v14, v15, v16, v17, a9);
    }
  }
}

uint64_t sub_1B6477B64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  return (*(unsigned __int16 *)(a1 + 56) >> 9) & 0xF;
}

void sub_1B6477BB4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  unsigned int v11 = *(unsigned __int16 *)(a1 + 56);
  if (((v11 >> 9) & 0xF) != a2)
  {
    *(_WORD *)(a1 + 56) = v11 & 0xE1FF | ((a2 & 0xF) << 9);
    sub_1B6476D28(a1, 0, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B6477C48()
{
  if (qword_1E9DDAE80 != -1) {
    dispatch_once(&qword_1E9DDAE80, &unk_1F0FB68A8);
  }
  return qword_1E9DDAE78;
}

double sub_1B6477C8C()
{
  if (!qword_1E9DDAE78)
  {
    qword_1E9DDAE78 = sub_1B63C8D10(&qword_1E9DDAE78);
    double result = *(double *)&xmmword_1F0FB8938;
    xmmword_1EB9751B8 = xmmword_1F0FB8938;
    qword_1EB9751C8 = (uint64_t)sub_1B6479714;
  }
  return result;
}

uint64_t sub_1B6477CF4(unsigned int a1)
{
  return (a1 > 0x19) | (0x1BE192Fu >> a1) & 1;
}

uint64_t sub_1B6477D14(uint64_t a1)
{
  return *(char *)(a1 + 58);
}

uint64_t sub_1B6477D1C(uint64_t a1)
{
  return HIBYTE(*(unsigned __int16 *)(a1 + 56)) & 1;
}

void sub_1B6477D28(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int16 v9 = *(_WORD *)(a1 + 56);
  if (((((v9 & 0x100) == 0) ^ a2) & 1) == 0)
  {
    if (a2) {
      __int16 v10 = 256;
    }
    else {
      __int16 v10 = 0;
    }
    *(_WORD *)(a1 + 56) = v9 & 0xFEFF | v10;
    sub_1B6476D28(a1, 0, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B6477D60(int a1, int a2)
{
  if (a1 == 3) {
    int v2 = 2;
  }
  else {
    int v2 = 0;
  }
  if (a1 == 25) {
    int v3 = 8;
  }
  else {
    int v3 = v2;
  }
  if ((a1 - 23) >= 2) {
    int v4 = v3;
  }
  else {
    int v4 = 6;
  }
  return v4 | a2 ^ 1u;
}

uint64_t sub_1B6477D94(unsigned int a1)
{
  return (a1 < 0x11) & (0x146D0u >> a1);
}

void sub_1B6477DB4(void *a1)
{
  sub_1B6595A0C(@"kCFXNotificationProfileWillDie", a1, 0, 1u);
  if (a1)
  {
    int v2 = (void *)a1[4];
    if (v2) {
      v2[11] = 0;
    }
    int v3 = (void *)a1[5];
    if (v3) {
      v3[11] = 0;
    }
    uint64_t v4 = a1[6];
    if (v4) {
      *(void *)(v4 + 88) = 0;
    }
    uint64_t v5 = a1[7];
    if (v5) {
      *(void *)(v5 + 88) = 0;
    }
    uint64_t v6 = a1[8];
    if (v6) {
      *(void *)(v6 + 88) = 0;
    }
    uint64_t v7 = a1[9];
    if (v7) {
      *(void *)(v7 + 88) = 0;
    }
    uint64_t v8 = a1[10];
    if (v8) {
      *(void *)(v8 + 88) = 0;
    }
    uint64_t v9 = a1[12];
    if (v9) {
      *(void *)(v9 + 88) = 0;
    }
    uint64_t v10 = a1[11];
    if (v10) {
      *(void *)(v10 + 88) = 0;
    }
    uint64_t v11 = a1[13];
    if (v11) {
      *(void *)(v11 + 88) = 0;
    }
    uint64_t v12 = a1[14];
    if (v12) {
      *(void *)(v12 + 88) = 0;
    }
    uint64_t v13 = a1[15];
    if (v13) {
      *(void *)(v13 + 88) = 0;
    }
    uint64_t v14 = a1[16];
    if (v14) {
      *(void *)(v14 + 88) = 0;
    }
    uint64_t v15 = a1[17];
    if (v15) {
      *(void *)(v15 + 88) = 0;
    }
    uint64_t v16 = a1[18];
    if (v16) {
      *(void *)(v16 + 88) = 0;
    }
    uint64_t v17 = a1[19];
    if (v17) {
      *(void *)(v17 + 88) = 0;
    }
    uint64_t v18 = a1[20];
    if (v18) {
      *(void *)(v18 + 88) = 0;
    }
    if (v2)
    {
      CFRelease(v2);
      a1[4] = 0;
      int v3 = (void *)a1[5];
    }
    if (v3)
    {
      CFRelease(v3);
      a1[5] = 0;
    }
    CFTypeRef v19 = (const void *)a1[6];
    if (v19)
    {
      CFRelease(v19);
      a1[6] = 0;
    }
    uint64_t v20 = (const void *)a1[7];
    if (v20)
    {
      CFRelease(v20);
      a1[7] = 0;
    }
    char v21 = (const void *)a1[8];
    if (v21)
    {
      CFRelease(v21);
      a1[8] = 0;
    }
    int v22 = (const void *)a1[9];
    if (v22)
    {
      CFRelease(v22);
      a1[9] = 0;
    }
    uint64_t v23 = (const void *)a1[10];
    if (v23)
    {
      CFRelease(v23);
      a1[10] = 0;
    }
    uint64_t v24 = (const void *)a1[12];
    if (v24)
    {
      CFRelease(v24);
      a1[12] = 0;
    }
    uint64_t v25 = (const void *)a1[11];
    if (v25)
    {
      CFRelease(v25);
      a1[11] = 0;
    }
    uint64_t v26 = (const void *)a1[13];
    if (v26)
    {
      CFRelease(v26);
      a1[13] = 0;
    }
    uint64_t v27 = (const void *)a1[14];
    if (v27)
    {
      CFRelease(v27);
      a1[14] = 0;
    }
    uint64_t v28 = (const void *)a1[16];
    if (v28)
    {
      CFRelease(v28);
      a1[16] = 0;
    }
    uint64_t v29 = (const void *)a1[17];
    if (v29)
    {
      CFRelease(v29);
      a1[17] = 0;
    }
    uint64_t v30 = (const void *)a1[18];
    if (v30)
    {
      CFRelease(v30);
      a1[18] = 0;
    }
    uint64_t v31 = (const void *)a1[19];
    if (v31)
    {
      CFRelease(v31);
      a1[19] = 0;
    }
    unsigned int v32 = (const void *)a1[20];
    if (v32)
    {
      CFRelease(v32);
      a1[20] = 0;
    }
    uint64_t v33 = (const void *)a1[15];
    if (v33)
    {
      CFRelease(v33);
      a1[15] = 0;
    }
  }
}

__CFString *sub_1B6477FD4(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<CFXCommonProfile %p :", a1);
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v3, v4, v5, v6, v7, v8, (uint64_t)"commonProfile");
  }
  uint64_t v9 = *(int *)(a1 + 24);
  if (v9 > 4) {
    uint64_t v10 = @"VFXhadingModelInvalid";
  }
  else {
    uint64_t v10 = off_1E6142678[v9];
  }
  CFStringAppendFormat(Mutable, 0, @" shadingModel:%@", v10);
  CFStringAppendFormat(Mutable, 0, @" perPixelLit:%d", *(unsigned __int8 *)(a1 + 200));
  CFStringAppendFormat(Mutable, 0, @" transparencyMode:%d", *(unsigned __int8 *)(a1 + 184));
  for (uint64_t i = 0; i != 20; ++i)
  {
    if (sub_1B6475064(*(_DWORD *)(a1 + 24), (char)i))
    {
      uint64_t v17 = sub_1B6475290(a1, (char)i, 0, v12, v13, v14, v15, v16);
      if (v17)
      {
        uint64_t v25 = v17;
        uint64_t v26 = off_1E6142560[i];
        BOOL v27 = sub_1B6475F88(v17, v18, v19, v20, v21, v22, v23, v24);
        CFStringAppendFormat(Mutable, 0, @"[%@] texture:%d xform:%d", v26, v27, *(void *)(v25 + 72) != 0);
      }
    }
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

__CFArray *sub_1B6478164(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 32;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v4, @"name", @"emission");
  CFDictionarySetValue(v4, @"type", v5);
  CFDictionarySetValue(v4, @"address", v7);
  CFDictionarySetValue(v4, @"semantic", v6);
  CFArrayAppendValue(Mutable, v4);
  CFRelease(v6);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v5);
  uint64_t v8 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 40;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v8, @"name", @"diffuse");
  CFDictionarySetValue(v8, @"type", v9);
  CFDictionarySetValue(v8, @"address", v11);
  CFDictionarySetValue(v8, @"semantic", v10);
  CFArrayAppendValue(Mutable, v8);
  CFRelease(v10);
  CFRelease(v8);
  CFRelease(v11);
  CFRelease(v9);
  uint64_t v12 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 48;
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v12, @"name", @"specular");
  CFDictionarySetValue(v12, @"type", v13);
  CFDictionarySetValue(v12, @"address", v15);
  CFDictionarySetValue(v12, @"semantic", v14);
  CFArrayAppendValue(Mutable, v12);
  CFRelease(v14);
  CFRelease(v12);
  CFRelease(v15);
  CFRelease(v13);
  uint64_t v16 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 56;
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v16, @"name", @"reflective");
  CFDictionarySetValue(v16, @"type", v17);
  CFDictionarySetValue(v16, @"address", v19);
  CFDictionarySetValue(v16, @"semantic", v18);
  CFArrayAppendValue(Mutable, v16);
  CFRelease(v18);
  CFRelease(v16);
  CFRelease(v19);
  CFRelease(v17);
  uint64_t v20 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 64;
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v20, @"name", @"transparent");
  CFDictionarySetValue(v20, @"type", v21);
  CFDictionarySetValue(v20, @"address", v23);
  CFDictionarySetValue(v20, @"semantic", v22);
  CFArrayAppendValue(Mutable, v20);
  CFRelease(v22);
  CFRelease(v20);
  CFRelease(v23);
  CFRelease(v21);
  uint64_t v24 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 72;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v24, @"name", @"multiply");
  CFDictionarySetValue(v24, @"type", v25);
  CFDictionarySetValue(v24, @"address", v27);
  CFDictionarySetValue(v24, @"semantic", v26);
  CFArrayAppendValue(Mutable, v24);
  CFRelease(v26);
  CFRelease(v24);
  CFRelease(v27);
  CFRelease(v25);
  uint64_t v28 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 80;
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v28, @"name", @"normal");
  CFDictionarySetValue(v28, @"type", v29);
  CFDictionarySetValue(v28, @"address", v31);
  CFDictionarySetValue(v28, @"semantic", v30);
  CFArrayAppendValue(Mutable, v28);
  CFRelease(v30);
  CFRelease(v28);
  CFRelease(v31);
  CFRelease(v29);
  unsigned int v32 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 104;
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v32, @"name", @"metalness");
  CFDictionarySetValue(v32, @"type", v33);
  CFDictionarySetValue(v32, @"address", v35);
  CFDictionarySetValue(v32, @"semantic", v34);
  CFArrayAppendValue(Mutable, v32);
  CFRelease(v34);
  CFRelease(v32);
  CFRelease(v35);
  CFRelease(v33);
  uint64_t v36 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 112;
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v39 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v36, @"name", @"roughness");
  CFDictionarySetValue(v36, @"type", v37);
  CFDictionarySetValue(v36, @"address", v39);
  CFDictionarySetValue(v36, @"semantic", v38);
  CFArrayAppendValue(Mutable, v36);
  CFRelease(v38);
  CFRelease(v36);
  CFRelease(v39);
  CFRelease(v37);
  uint64_t v40 = CFDictionaryCreateMutable(0, 4, v3, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 120;
  CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v42 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v43 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v40, @"name", @"displacement");
  CFDictionarySetValue(v40, @"type", v41);
  CFDictionarySetValue(v40, @"address", v43);
  CFDictionarySetValue(v40, @"semantic", v42);
  CFArrayAppendValue(Mutable, v40);
  CFRelease(v42);
  CFRelease(v40);
  CFRelease(v43);
  CFRelease(v41);
  uint64_t v44 = v3;
  uint64_t v45 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v46 = CFDictionaryCreateMutable(0, 4, v44, MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 128;
  CFNumberRef v47 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v48 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v49 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v46, @"name", @"clearCoat");
  CFDictionarySetValue(v46, @"type", v47);
  CFDictionarySetValue(v46, @"address", v49);
  CFDictionarySetValue(v46, @"semantic", v48);
  CFArrayAppendValue(Mutable, v46);
  CFRelease(v48);
  CFRelease(v46);
  CFRelease(v49);
  CFRelease(v47);
  uint64_t v50 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v45);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 136;
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v53 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v50, @"name", @"clearCoatRoughness");
  CFDictionarySetValue(v50, @"type", v51);
  CFDictionarySetValue(v50, @"address", v53);
  CFDictionarySetValue(v50, @"semantic", v52);
  CFArrayAppendValue(Mutable, v50);
  CFRelease(v52);
  CFRelease(v50);
  CFRelease(v53);
  CFRelease(v51);
  uint64_t v54 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v55 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 144;
  CFNumberRef v56 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v57 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v55, @"name", @"clearCoatNormal");
  CFDictionarySetValue(v55, @"type", v56);
  CFDictionarySetValue(v55, @"address", v58);
  CFDictionarySetValue(v55, @"semantic", v57);
  CFArrayAppendValue(Mutable, v55);
  CFRelease(v57);
  CFRelease(v55);
  CFRelease(v58);
  CFRelease(v56);
  uint64_t v59 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v54);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 152;
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v61 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v62 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v59, @"name", @"subsurface");
  CFDictionarySetValue(v59, @"type", v60);
  CFDictionarySetValue(v59, @"address", v62);
  CFDictionarySetValue(v59, @"semantic", v61);
  CFArrayAppendValue(Mutable, v59);
  CFRelease(v61);
  CFRelease(v59);
  CFRelease(v62);
  CFRelease(v60);
  long long v63 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  long long v64 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  long long v65 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v95 = 2;
  int valuePtr = 5;
  uint64_t v94 = a1 + 160;
  CFNumberRef v66 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v67 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v68 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v65, @"name", @"subsurfaceRadius");
  CFDictionarySetValue(v65, @"type", v66);
  CFDictionarySetValue(v65, @"address", v68);
  CFDictionarySetValue(v65, @"semantic", v67);
  CFArrayAppendValue(Mutable, v65);
  CFRelease(v67);
  CFRelease(v65);
  CFRelease(v68);
  CFRelease(v66);
  long long v69 = CFDictionaryCreateMutable(0, 4, v63, v64);
  int v95 = 0;
  int valuePtr = 1;
  uint64_t v94 = a1 + 168;
  CFNumberRef v70 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v71 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v72 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v69, @"name", @"shininess");
  CFDictionarySetValue(v69, @"type", v70);
  CFDictionarySetValue(v69, @"address", v72);
  CFDictionarySetValue(v69, @"semantic", v71);
  CFArrayAppendValue(Mutable, v69);
  CFRelease(v71);
  CFRelease(v69);
  CFRelease(v72);
  CFRelease(v70);
  char v73 = CFDictionaryCreateMutable(0, 4, v63, v64);
  int v95 = 0;
  int valuePtr = 1;
  uint64_t v94 = a1 + 172;
  CFNumberRef v74 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v75 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v76 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v73, @"name", @"indexOfRefraction");
  CFDictionarySetValue(v73, @"type", v74);
  CFDictionarySetValue(v73, @"address", v76);
  CFDictionarySetValue(v73, @"semantic", v75);
  CFArrayAppendValue(Mutable, v73);
  CFRelease(v75);
  CFRelease(v73);
  CFRelease(v76);
  CFRelease(v74);
  uint64_t v77 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v64);
  int v95 = 0;
  int valuePtr = 1;
  uint64_t v94 = a1 + 176;
  CFNumberRef v78 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v79 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v80 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v77, @"name", @"fresnelExponent");
  CFDictionarySetValue(v77, @"type", v78);
  CFDictionarySetValue(v77, @"address", v80);
  CFDictionarySetValue(v77, @"semantic", v79);
  CFArrayAppendValue(Mutable, v77);
  CFRelease(v79);
  CFRelease(v77);
  CFRelease(v80);
  CFRelease(v78);
  long long v81 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v64);
  int v95 = 0;
  int valuePtr = 2;
  uint64_t v94 = a1 + 24;
  CFNumberRef v82 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v83 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v84 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v81, @"name", @"shadingModel");
  CFDictionarySetValue(v81, @"type", v82);
  CFDictionarySetValue(v81, @"address", v84);
  CFDictionarySetValue(v81, @"semantic", v83);
  CFArrayAppendValue(Mutable, v81);
  CFRelease(v83);
  CFRelease(v81);
  CFRelease(v84);
  CFRelease(v82);
  float32x4_t v85 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v64);
  int v95 = 0;
  int valuePtr = 2;
  uint64_t v94 = a1 + 184;
  CFNumberRef v86 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v87 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v88 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v85, @"name", @"transparencyMode");
  CFDictionarySetValue(v85, @"type", v86);
  CFDictionarySetValue(v85, @"address", v88);
  CFDictionarySetValue(v85, @"semantic", v87);
  CFArrayAppendValue(Mutable, v85);
  CFRelease(v87);
  CFRelease(v85);
  CFRelease(v88);
  CFRelease(v86);
  float32x4_t v89 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v64);
  int v95 = 0;
  int valuePtr = 2;
  uint64_t v94 = a1 + 192;
  CFNumberRef v90 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v91 = CFNumberCreate(0, kCFNumberSInt32Type, &v95);
  CFNumberRef v92 = CFNumberCreate(0, kCFNumberLongType, &v94);
  CFDictionarySetValue(v89, @"name", @"imagesCount");
  CFDictionarySetValue(v89, @"type", v90);
  CFDictionarySetValue(v89, @"address", v92);
  CFDictionarySetValue(v89, @"semantic", v91);
  CFArrayAppendValue(Mutable, v89);
  CFRelease(v91);
  CFRelease(v89);
  CFRelease(v92);
  CFRelease(v90);
  return Mutable;
}

void sub_1B6479470(uint64_t a1, void *a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12 = sub_1B647677C(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  memcpy(a2, a3, a4);
  if (v12 != sub_1B647677C(a1, v13, v14, v15, v16, v17, v18, v19)) {
    sub_1B6475D58(a1, v20, v21, v22, v23, v24, v25, v26);
  }
  uint64_t v27 = *(void *)(a1 + 16);

  sub_1B64AF754(v27, v20, v21, v22, v23, v24, v25, v26);
}

void sub_1B64794F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"materialProperty");
  }
  unsigned int v9 = *(unsigned __int8 *)(a1 + 56);
  if (v9 <= 6)
  {
    if (v9 == 2)
    {
      CFNumberRef v11 = (void *)(a1 + 16);
    }
    else
    {
      CFNumberRef v11 = (void *)(a1 + 16);
      CFNumberRef v10 = *(const void **)(a1 + 16);
      if (!v10) {
        goto LABEL_9;
      }
      CFRelease(v10);
    }
    *CFNumberRef v11 = 0;
  }
LABEL_9:
  int v12 = *(const void **)(a1 + 32);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 32) = 0;
  }
}

void sub_1B647957C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = (void *)a1[9];
  if (v9) {
    free(v9);
  }
  sub_1B64794F0((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  CFNumberRef v10 = (const void *)a1[8];
  if (v10)
  {
    CFRelease(v10);
    a1[8] = 0;
  }
  CFNumberRef v11 = (const void *)a1[6];
  if (v11)
  {
    CFRelease(v11);
    a1[6] = 0;
  }
}

CFStringRef sub_1B64795D0(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXMaterialProperty>");
}

CFStringRef sub_1B6479604(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXMaterialProperty>");
}

void sub_1B6479638(uint64_t a1, void *__s1, void *__s2, size_t __n)
{
  if (memcmp(__s1, __s2, __n))
  {
    memcpy(__s1, __s2, __n);
    if (!a1) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v9, v10, v11, v12, v13, v14, (uint64_t)"materialProperty");
    }
    if (*(char *)(a1 + 58) <= 19)
    {
      uint64_t v15 = *(void *)(a1 + 88);
      if (v15)
      {
        if ((void *)(a1 + 16) == __s2 && *(unsigned char *)(a1 + 56) != 2) {
          *(_DWORD *)(v15 + 201) &= ~0x40u;
        }
        sub_1B6475D58(v15, v8, v9, v10, v11, v12, v13, v14);
      }
    }
  }
}

__CFArray *sub_1B6479714(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  switch(*(unsigned char *)(a1 + 56))
  {
    case 0:
      uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v34 = 2;
      int valuePtr = 5;
      uint64_t v33 = a1 + 16;
      CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
      CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v33);
      CFNumberRef v7 = @"image";
      goto LABEL_9;
    case 1:
      uint64_t v8 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v34 = 2;
      int valuePtr = 5;
      uint64_t v33 = a1 + 16;
      CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
      CFNumberRef v11 = CFNumberCreate(0, kCFNumberLongType, &v33);
      CFDictionarySetValue(v8, @"name", @"asset");
      CFDictionarySetValue(v8, @"type", v9);
      CFDictionarySetValue(v8, @"address", v11);
      CFDictionarySetValue(v8, @"semantic", v10);
      CFArrayAppendValue(Mutable, v8);
      CFRelease(v10);
      CFRelease(v8);
      CFRelease(v11);
      CFRelease(v9);
      goto LABEL_4;
    case 2:
      uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v34 = 0;
      int valuePtr = 12;
      uint64_t v33 = a1 + 16;
      CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
      CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v33);
      CFNumberRef v7 = @"color";
      goto LABEL_9;
    case 3:
LABEL_4:
      uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v34 = 2;
      int valuePtr = 5;
      uint64_t v33 = a1 + 16;
      CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
      CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v33);
      CFNumberRef v7 = @"texture";
      goto LABEL_9;
    case 4:
      uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v34 = 2;
      int valuePtr = 5;
      uint64_t v33 = a1 + 16;
      CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
      CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v33);
      CFNumberRef v7 = @"mtltexture";
      goto LABEL_9;
    case 5:
      uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v34 = 2;
      int valuePtr = 5;
      uint64_t v33 = a1 + 16;
      CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
      CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v33);
      CFNumberRef v7 = @"imageProxy";
      goto LABEL_9;
    case 6:
      uint64_t v3 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v34 = 2;
      int valuePtr = 5;
      uint64_t v33 = a1 + 16;
      CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
      CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v33);
      CFNumberRef v7 = @"precomputedLightingEnvironment";
LABEL_9:
      CFDictionarySetValue(v3, @"name", v7);
      CFDictionarySetValue(v3, @"type", v4);
      CFDictionarySetValue(v3, @"address", v6);
      CFDictionarySetValue(v3, @"semantic", v5);
      CFArrayAppendValue(Mutable, v3);
      CFRelease(v5);
      CFRelease(v3);
      CFRelease(v6);
      CFRelease(v4);
      break;
    default:
      break;
  }
  uint64_t v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v14 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v34 = 2;
  int valuePtr = 5;
  uint64_t v33 = a1 + 64;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  uint64_t v16 = Mutable;
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
  uint64_t v18 = a1;
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v33);
  CFDictionarySetValue(v14, @"name", @"sampler");
  CFDictionarySetValue(v14, @"type", v15);
  CFDictionarySetValue(v14, @"address", v19);
  CFDictionarySetValue(v14, @"semantic", v17);
  CFArrayAppendValue(v16, v14);
  CFRelease(v17);
  CFRelease(v14);
  CFRelease(v19);
  CFRelease(v15);
  uint64_t v20 = CFDictionaryCreateMutable(0, 4, v12, v13);
  int v34 = 2;
  int valuePtr = 5;
  uint64_t v33 = v18 + 72;
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberLongType, &v33);
  CFDictionarySetValue(v20, @"name", @"transforms");
  CFDictionarySetValue(v20, @"type", v21);
  CFDictionarySetValue(v20, @"address", v23);
  CFDictionarySetValue(v20, @"semantic", v22);
  CFArrayAppendValue(v16, v20);
  CFRelease(v22);
  CFRelease(v20);
  CFRelease(v23);
  CFRelease(v21);
  uint64_t v24 = CFDictionaryCreateMutable(0, 4, v12, v13);
  int v34 = 0;
  int valuePtr = 2;
  uint64_t v33 = v18 + 84;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberLongType, &v33);
  CFDictionarySetValue(v24, @"name", @"uvSet");
  CFDictionarySetValue(v24, @"type", v25);
  CFDictionarySetValue(v24, @"address", v27);
  CFDictionarySetValue(v24, @"semantic", v26);
  CFArrayAppendValue(v16, v24);
  CFRelease(v26);
  CFRelease(v24);
  CFRelease(v27);
  CFRelease(v25);
  uint64_t v28 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v13);
  int v34 = 0;
  int valuePtr = 1;
  uint64_t v33 = v18 + 80;
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v34);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &v33);
  CFDictionarySetValue(v28, @"name", @"intensity");
  CFDictionarySetValue(v28, @"type", v29);
  CFDictionarySetValue(v28, @"address", v31);
  CFDictionarySetValue(v28, @"semantic", v30);
  CFArrayAppendValue(v16, v28);
  CFRelease(v30);
  CFRelease(v28);
  CFRelease(v31);
  CFRelease(v29);
  return v16;
}

uint64_t sub_1B647A364(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_begin(MEMORY[0x1E4F39CF8], a2, a3, a4);
  if (!pthread_main_np()) {
    objc_msgSend_activateBackground_(MEMORY[0x1E4F39CF8], v5, 1, v6);
  }
  objc_msgSend_setValue_forKey_(MEMORY[0x1E4F39CF8], v5, MEMORY[0x1E4F1CC38], *MEMORY[0x1E4F3A5A8]);
  if (*(unsigned char *)(a1 + 72)) {
    objc_msgSend_setLayer_(*(void **)(a1 + 32), v7, *(void *)(a1 + 40), v9);
  }
  if (*(unsigned char *)(a1 + 73))
  {
    CFNumberRef v10 = objc_msgSend_layerToFocusForRenderedLayer_(*(void **)(a1 + 48), v7, *(void *)(a1 + 40), v9);
    int v17 = objc_msgSend_usesBoundsInPixels(*(void **)(a1 + 48), v11, v12, v13);
    uint64_t v18 = *(void **)(a1 + 40);
    if (v10 != v18)
    {
      objc_msgSend_setAnchorPoint_(*(void **)(a1 + 40), v14, v15, v16, 0.0, 0.0);
      objc_msgSend_setAnchorPoint_(v10, v19, v20, v21, 0.0, 0.0);
      objc_msgSend_setPosition_(*(void **)(a1 + 40), v22, v23, v24, 0.0, 0.0);
      objc_msgSend_setPosition_(v10, v25, v26, v27, 0.0, 0.0);
    }
    objc_msgSend_bounds(v10, v14, v15, v16);
    double v29 = v28;
    double v31 = v30;
    if (v17)
    {
      objc_msgSend_contentsScale(v10, v7, v8, v9);
      double v29 = v32 * v29;
      double v31 = v32 * v31;
    }
    if (v29 != 0.0 || v31 != 0.0)
    {
      double v33 = *(double *)(a1 + 56) / v29;
      double v34 = *(double *)(a1 + 64) / v31;
      int shouldFlip = objc_msgSend_shouldFlip(*(void **)(a1 + 48), v7, v8, v9);
      if (shouldFlip)
      {
        if (v10 == v18)
        {
          objc_msgSend_anchorPoint(*(void **)(a1 + 40), v35, v36, v37);
          CGFloat v46 = v29 * ((v33 + -1.0) * v45);
          objc_msgSend_anchorPoint(*(void **)(a1 + 40), v47, v48, v49);
          CATransform3DMakeTranslation(&v80, v46, v31 * ((v34 + -1.0) * v50), 0.0);
          CFNumberRef v51 = *(void **)(a1 + 40);
          CATransform3D v79 = v80;
          objc_msgSend_setTransform_(v51, v52, (uint64_t)&v79, v53);
        }
        else
        {
          CATransform3DMakeTranslation(&v82, 0.0, *(CGFloat *)(a1 + 64), 0.0);
          CFNumberRef v39 = *(void **)(a1 + 40);
          CATransform3D v81 = v82;
          objc_msgSend_setTransform_(v39, v40, (uint64_t)&v81, v41);
        }
      }
      else
      {
        CATransform3DMakeTranslation(&v78, 0.0, 0.0, 0.0);
        CFNumberRef v42 = *(void **)(a1 + 40);
        CATransform3D v77 = v78;
        objc_msgSend_setTransform_(v42, v43, (uint64_t)&v77, v44);
      }
      CATransform3DMakeScale(&a, v33, v34, 1.0);
      CFNumberRef v57 = *(void **)(a1 + 40);
      if (v57) {
        objc_msgSend_transform(v57, v54, v55, v56);
      }
      else {
        memset(&b, 0, sizeof(b));
      }
      CATransform3DConcat(&v76, &a, &b);
      CFNumberRef v58 = *(void **)(a1 + 40);
      CATransform3D v73 = v76;
      objc_msgSend_setTransform_(v58, v59, (uint64_t)&v73, v60);
      if (shouldFlip)
      {
        CATransform3DMakeScale(&v71, 1.0, -1.0, 1.0);
        long long v64 = *(void **)(a1 + 40);
        if (v64) {
          objc_msgSend_transform(v64, v61, v62, v63);
        }
        else {
          memset(&v70, 0, sizeof(v70));
        }
        CATransform3DConcat(&v72, &v71, &v70);
        long long v65 = *(void **)(a1 + 40);
        CATransform3D v69 = v72;
        objc_msgSend_setTransform_(v65, v66, (uint64_t)&v69, v67);
      }
    }
  }
  return objc_msgSend_commit(MEMORY[0x1E4F39CF8], v7, v8, v9);
}

uint64_t sub_1B647ACD4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 64);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  }
  return result;
}

__CFArray *sub_1B647ACF4(uint64_t a1)
{
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFNumberRef v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFNumberRef v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v23 = 2;
  int valuePtr = 5;
  uint64_t v22 = a1 + 64;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v5, @"name", @"LOD");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  uint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v23 = 0;
  int valuePtr = 1;
  uint64_t v22 = a1 + 72;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v9, @"name", @"threshold");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v23 = 0;
  int valuePtr = 2;
  uint64_t v22 = a1 + 76;
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v13, @"name", @"thresholdType");
  CFDictionarySetValue(v13, @"type", v14);
  CFDictionarySetValue(v13, @"address", v16);
  CFDictionarySetValue(v13, @"semantic", v15);
  CFArrayAppendValue(Mutable, v13);
  CFRelease(v15);
  CFRelease(v13);
  CFRelease(v16);
  CFRelease(v14);
  int v17 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v23 = 0;
  int valuePtr = 2;
  uint64_t v22 = a1 + 48;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberSInt32Type, &v23);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberLongType, &v22);
  CFDictionarySetValue(v17, @"name", @"worldRef");
  CFDictionarySetValue(v17, @"type", v18);
  CFDictionarySetValue(v17, @"address", v20);
  CFDictionarySetValue(v17, @"semantic", v19);
  CFArrayAppendValue(Mutable, v17);
  CFRelease(v19);
  CFRelease(v17);
  CFRelease(v20);
  CFRelease(v18);
  return Mutable;
}

uint64_t sub_1B647B0FC()
{
  if (qword_1EB995520 != -1) {
    dispatch_once(&qword_1EB995520, &unk_1F0FB5848);
  }
  return qword_1EB995528;
}

double sub_1B647B140()
{
  if (!qword_1EB995528)
  {
    qword_1EB995528 = sub_1B63C8D10(&qword_1EB995528);
    double result = *(double *)&xmmword_1F0FB88E0;
    unk_1EB984268 = xmmword_1F0FB88E0;
    unk_1EB984278 = *(_OWORD *)algn_1F0FB88F0;
    qword_1EB984288 = qword_1F0FB8900;
    qword_1EB984250 = (uint64_t)sub_1B647ACF4;
  }
  return result;
}

uint64_t sub_1B647B1B4(const void *a1, int a2, float a3)
{
  if (qword_1EB995520 != -1) {
    dispatch_once(&qword_1EB995520, &unk_1F0FB5848);
  }
  uint64_t v6 = sub_1B63C8D44(qword_1EB995528, 0x40uLL);
  *(_DWORD *)(v6 + 76) = a2;
  *(float *)(v6 + 72) = a3;
  CFNumberRef v7 = *(const void **)(v6 + 64);
  if (v7 != a1)
  {
    if (v7)
    {
      CFRelease(v7);
      *(void *)(v6 + 64) = 0;
    }
    if (a1) {
      CFTypeRef v8 = CFRetain(a1);
    }
    else {
      CFTypeRef v8 = 0;
    }
    *(void *)(v6 + 64) = v8;
  }
  return v6;
}

uint64_t sub_1B647B264(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"lod");
  }
  return *(void *)(a1 + 64);
}

uint64_t sub_1B647B2B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"lod");
  }
  return *(unsigned int *)(a1 + 76);
}

float sub_1B647B2FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"lod");
  }
  return *(float *)(a1 + 72);
}

id sub_1B647B34C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(const void **)(a1 + 64);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 64) = 0;
  }

  return sub_1B658325C(a1, a2, a3, a4, a5, a6, a7, a8);
}

CFStringRef sub_1B647B390(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXLOD>");
}

CFStringRef sub_1B647B3C4(const void *a1)
{
  CFAllocatorRef v1 = CFGetAllocator(a1);

  return CFStringCreateWithFormat(v1, 0, @"<CFXLOD>");
}

uint64_t sub_1B647B3F8(CFDataRef theData, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a5) {
    return 0;
  }
  if (theData)
  {
    CFIndex Length = CFDataGetLength(theData);
    MutableCFSetRef Copy = CFDataCreateMutableCopy(0, Length, theData);
  }
  else
  {
    CFIndex v19 = a4 * a3 * sub_1B63CA534(a5, a2, a3, a4, a5, a6, a7, a8);
    MutableCFSetRef Copy = CFDataCreateMutable(0, 0);
    CFDataSetLength(MutableCopy, v19);
  }
  uint64_t v18 = sub_1B641CF98(MutableCopy, a2, a3, a4, a5, v14, v15, v16);
  CFRelease(MutableCopy);
  if (v18) {
    *(unsigned char *)(v18 + 88) |= 1u;
  }
  return v18;
}

uint64_t sub_1B647B4C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t result = sub_1B653465C(v8);
  uint64_t v17 = result - a4;
  if (result > a4)
  {
    uint64_t v18 = (int)sub_1B641D56C(a1, v10, v11, v12, v13, v14, v15, v16) - 1;
    float v19 = 1.0;
    float v20 = 1.0;
    if (v18 <= 5)
    {
      float v19 = flt_1B6E50EA8[v18];
      float v20 = flt_1B6E50EC0[(int)v18];
    }
    uint64_t result = sub_1B65349B8(v8);
    if (a3 >= 1)
    {
      uint64_t v21 = result;
      uint64_t v22 = 0;
      uint64_t v23 = a2 + a4;
      uint64_t v24 = a2 + 8 * a4;
      uint64_t v25 = a2 + 4 * a4;
      do
      {
        uint64_t v26 = 0;
        do
        {
          if (v17 - 1 == v26) {
            float v27 = v20;
          }
          else {
            float v27 = v19;
          }
          uint64_t result = sub_1B6534654(v8);
          if ((int)result > 5)
          {
            if (result != 6)
            {
              if (result != 15) {
                goto LABEL_19;
              }
LABEL_16:
              *(unsigned char *)(v23 + v26) = (int)v27;
              goto LABEL_19;
            }
            *(double *)(v24 + 8 * v26) = v27;
          }
          else if (result == 1)
          {
            *(float *)(v25 + 4 * v26) = v27;
          }
          else if (result == 4)
          {
            goto LABEL_16;
          }
LABEL_19:
          ++v26;
        }
        while (v17 != v26);
        ++v22;
        v23 += v21;
        v24 += v21;
        v25 += v21;
      }
      while (v22 != a3);
    }
  }
  return result;
}

void sub_1B647B618(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v11 = *(void **)(a1 + 64);
  uint64_t v12 = sub_1B6534884(v11, a2, a3, a4, a5, a6, a7, a8);
  __n128 v13 = a9;
  v13.n128_u32[3] = 0;
  float32x4_t v29 = (float32x4_t)v13;
  int v21 = sub_1B6534780((uint64_t)v11, v14, v15, v16, v17, v18, v19, v20);

  sub_1B65D6678(v21, (uint64_t)v12, v22, v23, v24, v25, v26, v27, v29);
}

void sub_1B647B6A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v11 = *(void **)(a1 + 64);
  uint64_t v12 = sub_1B6534884(v11, a2, a3, a4, a5, a6, a7, a8);
  int v20 = sub_1B6534780((uint64_t)v11, v13, v14, v15, v16, v17, v18, v19);

  sub_1B65D6678(v20, (uint64_t)v12, v21, v22, v23, v24, v25, v26, a9);
}

__CFData *sub_1B647B72C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v10 = *(void **)(a1 + 64);
  CFDataRef v11 = (const __CFData *)sub_1B6534790((uint64_t)v10, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B65349B8((uint64_t)v10);
  if (!v11) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"data");
  }
  CFIndex Length = CFDataGetLength(v11);
  if (Length != sub_1B6534800((uint64_t)v10) * v18) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. We do not support appending to really complicated interleavings", v20, v21, v22, v23, v24, v25, (uint64_t)"(size_t)CFDataGetLength(data) == stride * CFXSourceAccessorGetCount(accessor)");
  }
  CFIndex v26 = CFDataGetLength(v11);
  CFDataSetLength(v11, v26 + v18 * (void)a2);
  uint64_t v27 = sub_1B6534800((uint64_t)v10);
  sub_1B65349EC((uint64_t)v10, (uint64_t)&a2[v27]);

  return sub_1B6534884(v10, v27, v28, v29, v30, v31, v32, v33);
}

uint64_t sub_1B647B844(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = sub_1B647B72C(a1, (const char *)a3, a3, a4, a5, a6, a7, a8);
  uint64_t v13 = sub_1B65349B8(v11);
  if (a3 >= 1)
  {
    uint64_t v14 = v13;
    uint64_t v15 = (float *)(a2 + 4);
    uint64_t v16 = a3;
    uint64_t v17 = v12;
    do
    {
      int v18 = sub_1B6534654(v11);
      if (v18 > 5)
      {
        if (v18 == 6)
        {
          *(double *)uint64_t v17 = *(v15 - 1);
          *((double *)v17 + 1) = *v15;
          *((double *)v17 + 2) = v15[1];
          goto LABEL_14;
        }
        if (v18 == 15) {
          goto LABEL_11;
        }
      }
      else
      {
        if (v18 == 1)
        {
          *(float *)uint64_t v17 = *(v15 - 1);
          *((float *)v17 + 1) = *v15;
          *((float *)v17 + 2) = v15[1];
          goto LABEL_14;
        }
        if (v18 == 4)
        {
LABEL_11:
          *(unsigned char *)uint64_t v17 = (int)*(v15 - 1);
          *((unsigned char *)v17 + 1) = (int)*v15;
          *((unsigned char *)v17 + 2) = (int)v15[1];
          goto LABEL_14;
        }
      }
      sub_1B63F2F54(16, @"Error: CFXMeshSourceAppendVector3 - Type not supported", v19, v20, v21, v22, v23, v24, v26);
LABEL_14:
      uint64_t v17 = (__CFData *)((char *)v17 + v14);
      v15 += 4;
      --v16;
    }
    while (v16);
  }

  return sub_1B647B4C8(a1, (uint64_t)v12, a3, 3);
}

uint64_t sub_1B647B9C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshSource");
  }
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = sub_1B647B72C(a1, (const char *)a3, a3, a4, a5, a6, a7, a8);
  uint64_t v13 = sub_1B65349B8(v11);
  if (a3 >= 1)
  {
    uint64_t v14 = v13;
    uint64_t v15 = (float *)(a2 + 4);
    uint64_t v16 = v12;
    for (uint64_t i = a3; i; --i)
    {
      int v18 = sub_1B6534654(v11);
      if (v18 > 5)
      {
        if (v18 == 6)
        {
          *(double *)uint64_t v16 = COERCE_FLOAT(*(void *)(v15 - 1));
          *((double *)v16 + 1) = *v15;
          goto LABEL_14;
        }
        if (v18 == 15) {
          goto LABEL_11;
        }
      }
      else
      {
        if (v18 == 1)
        {
          *(_DWORD *)uint64_t v16 = *(void *)(v15 - 1);
          *((float *)v16 + 1) = *v15;
          goto LABEL_14;
        }
        if (v18 == 4)
        {
LABEL_11:
          *(unsigned char *)uint64_t v16 = (int)COERCE_FLOAT(*(void *)(v15 - 1));
          *((unsigned char *)v16 + 1) = (int)*v15;
          goto LABEL_14;
        }
      }
      sub_1B63F2F54(16, @"Error: CFXMeshSourceAppendVector2 - Type not supported", v19, v20, v21, v22, v23, v24, v26);
LABEL_14:
      v15 += 2;
      uint64_t v16 = (__CFData *)((char *)v16 + v14);
    }
  }

  return sub_1B647B4C8(a1, (uint64_t)v12, a3, 2);
}

uint64_t sub_1B647BB2C(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 <= 0x14 && (int v8 = a3, ((1 << a3) & 0x108052) != 0))
  {
    uint64_t v11 = sub_1B63CA534(a3, a2, a3, a4, a5, a6, a7, a8);
    int v18 = (const void *)sub_1B6534714(v8, a2, 0, v11 * a2, 0);
    if (!v18) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"accessor");
    }
    uint64_t v25 = sub_1B641D0F8(v18, a1);
    if (!v25) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v19, v20, v21, v22, v23, v24, (uint64_t)"meshSource");
    }
    sub_1B6534974((uint64_t)v18, v25);
    CFRelease(v18);
    *(unsigned char *)(v25 + 88) |= 4u;
  }
  else
  {
    sub_1B63F2F54(16, @"Error: CFXMeshSourceCreate: unsupported type", a3, a4, a5, a6, a7, a8, v27);
    return 0;
  }
  return v25;
}

void sub_1B647BC34(uint64_t a1, uint64_t a2)
{
  if ((sub_1B6536C9C(a1) & 1) == 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Cannot set volatile data of a non volatile source", v4, v5, v6, v7, v8, v9, (uint64_t)"CFXMeshSourceIsVolatile(source)");
  }

  sub_1B6536BAC(a1, a2, v4, v5, v6, v7, v8, v9);
}

BOOL sub_1B647BCA0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B6536A44(a1, a2, a3, a4, a5, a6, a7, a8) != 0;
}

uint64_t sub_1B647BCC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"source");
  }
  return *(unsigned __int8 *)(a1 + 98);
}

uint64_t sub_1B647C114(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B647C144()
{
  if (qword_1E9DDAE90 != -1) {
    dispatch_once_f(&qword_1E9DDAE90, &qword_1E9DDAE88, (dispatch_function_t)sub_1B647C114);
  }
  uint64_t result = sub_1B63C8D44(qword_1E9DDAE88, 0xF0uLL);
  *(_DWORD *)(result + 232) = 3;
  return result;
}

void sub_1B647C1A8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v11 = *(_DWORD *)(a1 + 232);
  if (v11 == 2)
  {
    unsigned int v12 = 48;
    goto LABEL_5;
  }
  if (v11 == 3)
  {
    unsigned int v12 = 112;
LABEL_5:
    uint64_t v13 = malloc_type_calloc((a2 + 4), v12, 0xDC1EB90AuLL);
    uint64_t v20 = malloc_type_calloc((a2 + 4), 0x10uLL, 0x1000040451B5BE8uLL);
    if (*(void *)(a1 + 24))
    {
      if (!*(_DWORD *)(a1 + 36)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v14, v15, v16, v17, v18, v19, (uint64_t)"probesSystem->_probesCapacity");
      }
      if (!*(void *)(a1 + 16)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v14, v15, v16, v17, v18, v19, (uint64_t)"probesSystem->_probesPositions");
      }
      memcpy(v13, *(const void **)(a1 + 24), (*(_DWORD *)(a1 + 36) + 4) * v12);
      free(*(void **)(a1 + 24));
      memcpy(v20, *(const void **)(a1 + 16), 16 * (*(_DWORD *)(a1 + 36) + 4));
      free(*(void **)(a1 + 16));
    }
    *(void *)(a1 + 16) = v20;
    *(void *)(a1 + 24) = v13;
    *(_DWORD *)(a1 + 36) = a2;
    return;
  }

  sub_1B63F2F54(16, @"Error: unsupported SH order", a3, a4, a5, a6, a7, a8, a9);
}

void sub_1B647C30C(uint64_t a1)
{
  uint64_t v7 = *(unsigned int *)(a1 + 224);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 16) + 64;
    uint64_t v9 = *(void *)(a1 + 192);
    uint64_t v10 = *(void *)(a1 + 64) + 32;
    int v11 = (int *)(*(void *)(a1 + 48) + 8);
    do
    {
      uint64_t v12 = v11[1];
      if (v12 == 0x7FFFFFFF)
      {
        uint64_t v13 = *(v11 - 2);
        uint64_t v14 = *(v11 - 1);
        uint64_t v15 = *v11;
        _Q3 = *(float32x4_t *)(v9 + 16 * v15);
        float32x4_t v17 = *(float32x4_t *)(v8 + 16 * v15);
        _Q7 = vsubq_f32(*(float32x4_t *)(v8 + 16 * v13), v17);
        _Q17 = vsubq_f32(*(float32x4_t *)(v9 + 16 * v13), _Q3);
        _Q16 = vsubq_f32(*(float32x4_t *)(v8 + 16 * v14), v17);
        _Q4 = vsubq_f32(*(float32x4_t *)(v9 + 16 * v14), _Q3);
        _S19 = _Q4.i32[2];
        _S20 = _Q4.i32[1];
        _Q22.f32[0] = vmuls_lane_f32(-_Q17.f32[2], *(float32x2_t *)_Q4.f32, 1);
        _S24 = vmuls_lane_f32(_Q4.f32[0], _Q17, 2);
        _S27 = vmuls_lane_f32(_Q17.f32[0], *(float32x2_t *)_Q4.f32, 1);
        __asm
        {
          FMLS            S26, S27, V3.S[2]
          FMLS            S26, S24, V3.S[1]
          FMLS            S26, S22, V3.S[0]
          FMLA            S22, S19, V17.S[1]
        }
        float v33 = -_Q17.f32[0];
        __asm { FMLS            S24, S19, V17.S[0] }
        _Q22.i32[1] = _S24;
        _Q22.i32[2] = vmlas_n_f32((float)-_Q17.f32[1] * _Q4.f32[0], _Q4.f32[1], _Q17.f32[0]);
        _S24 = vmuls_lane_f32(_Q7.f32[0], *(float32x2_t *)_Q4.f32, 1);
        __asm { FMLS            S30, S24, V3.S[2] }
        _S24 = _Q16.f32[1];
        _S31 = vmuls_lane_f32(_Q17.f32[0], *(float32x2_t *)_Q16.f32, 1);
        __asm { FMLS            S30, S31, V3.S[2] }
        _S23 = (float)-_Q17.f32[1] * _Q16.f32[0];
        __asm { FMLS            S30, S23, V3.S[2] }
        _S31 = vmuls_lane_f32(_Q4.f32[0], _Q7, 2);
        __asm { FMLS            S30, S31, V3.S[1] }
        _S31 = vmuls_lane_f32(-_Q7.f32[2], *(float32x2_t *)_Q4.f32, 1);
        __asm { FMLS            S30, S31, V3.S[0] }
        _S31 = vmuls_lane_f32(_Q16.f32[0], _Q17, 2);
        __asm { FMLS            S30, S31, V3.S[1] }
        _Q21.f32[0] = vmuls_lane_f32(-_Q17.f32[2], *(float32x2_t *)_Q16.f32, 1);
        __asm { FMLS            S30, S21, V3.S[0] }
        _Q21.f32[0] = vmuls_lane_f32(-_Q7.f32[0], _Q4, 2);
        __asm { FMLS            S30, S21, V3.S[1] }
        _Q21.f32[0] = vmuls_lane_f32(_Q4.f32[2], *(float32x2_t *)_Q7.f32, 1);
        __asm { FMLS            S30, S21, V3.S[0] }
        _S9 = _Q16.i32[2];
        _S10 = vmuls_lane_f32(-_Q17.f32[0], _Q16, 2);
        __asm { FMLS            S30, S10, V3.S[1] }
        _S11 = vmuls_lane_f32(_Q17.f32[1], _Q16, 2);
        __asm { FMLS            S30, S11, V3.S[0] }
        float32x4_t v56 = vmulq_f32(v17, _Q22);
        _Q22.f32[3] = _S30
                    - vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 2), vaddq_f32(v56, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 1))).f32[0];
        __asm
        {
          FMLA            S21, S9, V17.S[1]
          FMLS            S21, S24, V17.S[2]
          FMLS            S21, S20, V7.S[2]
          FMLS            S10, S19, V7.S[0]
          FMLA            S10, S4, V7.S[2]
          FMLA            S10, S16, V17.S[2]
          FMLS            S29, S16, V17.S[1]
        }
        _Q21.i32[1] = _S10;
        _Q21.i32[2] = _S29;
        _Q17.f32[0] = vmuls_lane_f32(_Q7.f32[0], *(float32x2_t *)_Q16.f32, 1);
        float v61 = (float)-_Q7.f32[1] * _Q16.f32[0];
        __asm { FMLS            S18, S17, V3.S[2] }
        _Q17.f32[0] = vmuls_lane_f32(-_Q7.f32[0], _Q16, 2);
        __asm { FMLS            S18, S17, V3.S[1] }
        _Q17.f32[0] = vmuls_lane_f32(_Q7.f32[1], _Q16, 2);
        __asm { FMLS            S18, S17, V3.S[0] }
        _S20 = vmuls_lane_f32(_Q16.f32[0], _Q7, 2);
        __asm { FMLS            S18, S20, V3.S[1] }
        _Q16.f32[0] = vmuls_lane_f32(-_Q7.f32[2], *(float32x2_t *)_Q16.f32, 1);
        __asm { FMLS            S18, S16, V3.S[0] }
        float32x4_t v68 = vmulq_f32(v17, _Q21);
        _Q21.f32[3] = _S18
                    - vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).f32[0];
        __asm
        {
          FMLS            S17, S24, V7.S[2]
          FMLS            S20, S9, V7.S[0]
        }
        *(float *)&unsigned int v70 = vmlas_n_f32(v61, _S24, _Q7.f32[0]);
        v72.i64[0] = __PAIR64__(_S20, _Q17.u32[0]);
        v72.i64[1] = v70;
        _Q5 = vmulq_f32(v17, v72);
        v72.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q5, 2), vaddq_f32(_Q5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q5.f32, 1))).f32[0];
        _Q5.f32[0] = vmuls_lane_f32(_Q17.f32[1], _Q4, 2);
        __asm { FMLS            S26, S5, V3.S[0] }
        _Q4.f32[0] = vmuls_lane_f32(v33, _Q4, 2);
        __asm { FMLS            S26, S4, V3.S[1] }
        if (fabsf(*(float *)_D26.i32) > 0.0001)
        {
          float32x4_t v74 = (float32x4_t)vdupq_lane_s32(_D26, 0);
          _Q22 = vdivq_f32(_Q22, v74);
          _Q21 = vdivq_f32(_Q21, v74);
          float32x4_t v72 = vdivq_f32(v72, v74);
        }
        *(float32x4_t *)(v10 - 32) = _Q22;
        *(float32x4_t *)(v10 - 16) = _Q21;
        *(float32x4_t *)uint64_t v10 = v72;
      }
      else
      {
        float32x4_t v75 = *(float32x4_t *)(v8 + 16 * v12);
        v76.columns[0] = (simd_float3)vsubq_f32(*(float32x4_t *)(v8 + 16 * *(v11 - 2)), v75);
        v76.columns[1] = (simd_float3)vsubq_f32(*(float32x4_t *)(v8 + 16 * *(v11 - 1)), v75);
        v76.columns[2] = (simd_float3)vsubq_f32(*(float32x4_t *)(v8 + 16 * *v11), v75);
        v76.columns[0].i32[3] = HIDWORD(v1);
        v76.columns[1].i32[3] = HIDWORD(v3);
        v76.columns[2].i32[3] = HIDWORD(v2);
        simd_float3x3 v77 = __invert_f3(v76);
        *(_OWORD *)(v10 - 16) = 0u;
        *(_OWORD *)uint64_t v10 = 0u;
        v77.columns[0].i32[3] = 0;
        v77.columns[1].i32[3] = *(_DWORD *)(v10 - 4);
        *(simd_float3 *)(v10 - 32) = v77.columns[0];
        *(simd_float3 *)(v10 - 16) = v77.columns[1];
        v77.columns[2].i32[3] = *(_DWORD *)(v10 + 12);
        *(simd_float3 *)uint64_t v10 = v77.columns[2];
      }
      v10 += 48;
      v11 += 12;
      --v7;
    }
    while (v7);
  }
}

void sub_1B647C620(uint64_t a1, unsigned int a2)
{
  long long v64 = malloc_type_calloc(8uLL, (*(_DWORD *)(a1 + 32) + 4), 0x47021FF1uLL);
  if (a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v62 = a2;
    uint64_t v5 = v4 + 16;
    uint64_t v6 = v64;
    do
    {
      uint64_t v7 = 0;
      uint64_t v8 = v4 + 48 * v3;
      uint64_t v9 = &dword_1B6E50F38;
      do
      {
        *(_DWORD *)(v5 + v7) = -1;
        int v10 = *(_DWORD *)(v8 + 4 * *(v9 - 2));
        if (v10 >= *(_DWORD *)(v8 + 4 * *(v9 - 1))) {
          int v10 = *(_DWORD *)(v8 + 4 * *(v9 - 1));
        }
        if (v10 >= *(_DWORD *)(v8 + 4 * *v9)) {
          int v10 = *(_DWORD *)(v8 + 4 * *v9);
        }
        uint64_t v11 = v6[v10];
        if (!v11)
        {
          uint64_t v12 = v10;
          uint64_t v11 = sub_1B649185C();
          v64[v12] = v11;
          uint64_t v6 = v64;
        }
        v9 += 3;
        sub_1B6492824(v11, v3);
        v7 += 4;
      }
      while (v7 != 16);
      ++v3;
      v5 += 48;
    }
    while (v3 != a2);
    for (uint64_t i = 0; i != v62; ++i)
    {
      uint64_t v20 = 0;
      uint64_t v63 = v4 + 48 * i;
      do
      {
        uint64_t v21 = v4 + 48 * i + 4 * v20;
        int v23 = *(_DWORD *)(v21 + 16);
        uint64_t v22 = (_DWORD *)(v21 + 16);
        if (v23 == -1)
        {
          uint64_t v24 = &dword_1B6E50F30[3 * v20];
          uint64_t v25 = *(int *)(v63 + 4 * *v24);
          uint64_t v26 = *(int *)(v63 + 4 * v24[1]);
          uint64_t v27 = *(int *)(v63 + 4 * v24[2]);
          if (v25 >= v26) {
            uint64_t v28 = v26;
          }
          else {
            uint64_t v28 = v25;
          }
          if (v25 <= v26) {
            uint64_t v29 = v26;
          }
          else {
            uint64_t v29 = v25;
          }
          if (v28 >= v27) {
            uint64_t v30 = v27;
          }
          else {
            uint64_t v30 = v28;
          }
          if (v29 <= v27) {
            uint64_t v31 = v27;
          }
          else {
            uint64_t v31 = v29;
          }
          if (v30 != v26 && v31 != v26) {
            uint64_t v27 = v26;
          }
          if (v30 == v25 || v31 == v25) {
            uint64_t v34 = v27;
          }
          else {
            uint64_t v34 = v25;
          }
          uint64_t v35 = v64[v30];
          if (!v35) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. _computeNeighbourIndexes - missing tetrahedron", v13, v14, v15, v16, v17, v18, (uint64_t)"tetrahedronIndexes");
          }
          uint64_t v36 = sub_1B64918B0(v35);
          if (v36 != -1)
          {
            uint64_t v37 = v36;
            uint64_t v38 = -1;
            do
            {
              if (v37 == i)
              {
                uint64_t v39 = -1;
              }
              else
              {
                unint64_t v40 = 0;
                uint64_t v41 = v4 + 48 * v37;
                CFNumberRef v42 = &dword_1B6E50F38;
                do
                {
                  uint64_t v43 = *(int *)(v41 + 4 * *(v42 - 2));
                  uint64_t v44 = *(int *)(v41 + 4 * *(v42 - 1));
                  uint64_t v45 = *(int *)(v41 + 4 * *v42);
                  if (v43 >= v44) {
                    uint64_t v46 = *(int *)(v41 + 4 * *(v42 - 1));
                  }
                  else {
                    uint64_t v46 = *(int *)(v41 + 4 * *(v42 - 2));
                  }
                  if (v43 <= v44) {
                    uint64_t v47 = *(int *)(v41 + 4 * *(v42 - 1));
                  }
                  else {
                    uint64_t v47 = *(int *)(v41 + 4 * *(v42 - 2));
                  }
                  if (v46 >= v45) {
                    uint64_t v46 = *(int *)(v41 + 4 * *v42);
                  }
                  if (v47 <= v45) {
                    uint64_t v47 = *(int *)(v41 + 4 * *v42);
                  }
                  if (v46 == v44 || v47 == v44) {
                    uint64_t v44 = *(int *)(v41 + 4 * *v42);
                  }
                  if (v46 == v43 || v47 == v43) {
                    uint64_t v43 = v44;
                  }
                  BOOL v51 = v46 == v30 && v43 == v34;
                  BOOL v52 = v47 == v31;
                  if (v51 && v52) {
                    uint64_t v39 = v37;
                  }
                  else {
                    uint64_t v39 = -1;
                  }
                  if (v51 && v52) {
                    uint64_t v38 = v40;
                  }
                  BOOL v53 = v39 != -1 || v40++ >= 3;
                  v42 += 3;
                }
                while (!v53);
              }
              uint64_t v54 = sub_1B6491924(v35, v37);
              if (v39 != -1) {
                break;
              }
              uint64_t v37 = v54;
            }
            while (v54 != -1);
            if (v39 != -1)
            {
              uint64_t v55 = v4 + 48 * v39 + 4 * v38;
              int v57 = *(_DWORD *)(v55 + 16);
              float32x4_t v56 = (_DWORD *)(v55 + 16);
              if (v57 != -1) {
                sub_1B63F2F54(17, @"Assertion '%s' failed. overwrite a neighbour index", v13, v14, v15, v16, v17, v18, (uint64_t)"_tetrahedrons[tetraderonIndex].neighbourIndexes[otherTetraderonFaceIndex] == -1");
              }
              *uint64_t v22 = v39;
              *float32x4_t v56 = i;
            }
          }
        }
        ++v20;
      }
      while (v20 != 4);
    }
  }
  unint64_t v58 = *(unsigned int *)(a1 + 32);
  if (v58)
  {
    for (unint64_t j = 0; j < v58; ++j)
    {
      uint64_t v60 = (const void *)v64[j];
      if (v60)
      {
        CFRelease(v60);
        v64[j] = 0;
        unint64_t v58 = *(unsigned int *)(a1 + 32);
      }
    }
  }

  free(v64);
}

void sub_1B647C968(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (*(_DWORD *)(a1 + 36) < a2) {
      sub_1B647C1A8(a1, a2, a3, a4, a5, a6, a7, a8, v10);
    }
  }
  else
  {
    free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    free(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    sub_1B647C9DC((void **)a1);
    *(_DWORD *)(a1 + 36) = 0;
  }
  *(_DWORD *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 228) = 1;
}

void sub_1B647C9DC(void **a1)
{
  a1[6] = 0;
  free(a1[8]);
  a1[8] = 0;
  free(a1[24]);
  a1[24] = 0;
}

void sub_1B647CA20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  v51.n128_u32[2] = 0;
  uint64_t v10 = a2 + 4;
  v51.n128_u64[0] = 0;
  sub_1B64A1EC8(a3, &v51, a3, a4, a5, a6, a7, a8);
  *(__n128 *)(*(void *)(a1 + 16) + 16 * v10) = v51;
  uint64_t v11 = *(unsigned int *)(a1 + 232);
  CFDataRef v19 = (const __CFData *)sub_1B6497530(a4, v12, v13, v14, v15, v16, v17, v18);
  if (v19)
  {
    CFDataRef v20 = v19;
    int v21 = v11 * v11;
    if (12 * v11 * (unint64_t)v11 != CFDataGetLength(v19)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. wrong data size for SH", v22, v23, v24, v25, v26, v27, (uint64_t)"sh_sizeof(shOrder) == (size_t)CFDataGetLength(irradianceSH)");
    }
    BytePtr = CFDataGetBytePtr(v20);
    uint64_t v35 = &BytePtr[4 * v21];
    v52[0] = BytePtr;
    v52[1] = v35;
    uint64_t v36 = &BytePtr[8 * v21];
    v52[2] = v36;
    if (v11 == 3)
    {
      uint64_t v38 = 0;
      uint64_t v39 = *(void *)(a1 + 24);
      float32x2_t v40 = (float32x2_t)vdup_n_s32(0xBEA6C6BC);
      do
      {
        uint64_t v41 = v52[v38];
        v42.i32[0] = *(_DWORD *)(v41 + 12);
        v42.i32[1] = *(_DWORD *)(v41 + 4);
        *(float32x2_t *)&long long v43 = vmul_f32(v42, v40);
        *((float *)&v43 + 2) = *(float *)(v41 + 8) * 0.32573;
        *((float *)&v43 + 3) = (float)(*(float *)(v41 + 24) * -0.078848) + (float)(*(float *)v41 * 0.28209);
        *(&v53 + v38++) = v43;
      }
      while (v38 != 3);
      uint64_t v44 = 0;
      uint64_t v45 = (_OWORD *)(v39 + 112 * v10);
      long long v46 = v54;
      *uint64_t v45 = v53;
      v45[1] = v46;
      v45[2] = v55;
      do
      {
        *(&v53 + v44) = (__int128)vmulq_f32(*(float32x4_t *)(v52[v44] + 16), (float32x4_t)xmmword_1B6E50F00);
        ++v44;
      }
      while (v44 != 3);
      uint64_t v47 = (_OWORD *)(v39 + 112 * v10);
      long long v48 = v54;
      v47[3] = v53;
      v47[4] = v48;
      v47[5] = v55;
      v49.i32[0] = *((_DWORD *)BytePtr + 8);
      v49.i32[1] = *((_DWORD *)v35 + 8);
      *(float32x2_t *)&long long v50 = vmul_f32(v49, (float32x2_t)vdup_n_s32(0x3E0BD8A0u));
      *((void *)&v50 + 1) = __PAIR64__(1.0, *((float *)v36 + 8) * 0.13657);
      v47[6] = v50;
    }
    else if (v11 == 2)
    {
      uint64_t v37 = (_OWORD *)(*(void *)(a1 + 24) + 48 * v10);
      *uint64_t v37 = *(_OWORD *)BytePtr;
      v37[1] = *(_OWORD *)v35;
      v37[2] = *(_OWORD *)v36;
    }
    else
    {
      sub_1B63F2F54(16, @"Error: SH order unsupported : %d", v29, v30, v31, v32, v33, v34, v11);
    }
  }
}

void sub_1B647CC78(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 240) = a2;
  *(void *)(a1 + 248) = 0;
  if (!*(unsigned char *)(a1 + 228)) {
    return;
  }
  *(unsigned char *)(a1 + 228) = 0;
  if (*(_DWORD *)(a1 + 32) <= 3u)
  {
    *(_DWORD *)(a1 + 224) = 0;
    return;
  }
  sub_1B647C9DC((void **)a1);
  size_t v2 = (100 * *(_DWORD *)(a1 + 32) + 400);
  *(void *)(a1 + 48) = malloc_type_valloc(16 * (v2 + 2 * v2), 0x1000040EED21634uLL);
  *(void *)(a1 + 64) = malloc_type_valloc(16 * (v2 + 2 * v2), 0x1000040EED21634uLL);
  uint64_t v3 = malloc_type_calloc(8uLL, v2, 0xD31E8CEEuLL);
  uint64_t v159 = malloc_type_calloc(0xCuLL, v2, 0xF3A354A8uLL);
  uint64_t v149 = malloc_type_calloc(8uLL, v2, 0x84CFB5CAuLL);
  unsigned int v146 = v2;
  uint64_t v4 = malloc_type_calloc(v2, 1uLL, 0x100004077774924uLL);
  uint64_t v5 = v4;
  uint64_t v6 = *(float32x4_t **)(a1 + 48);
  uint64_t v7 = *(unsigned int *)(a1 + 32);
  uint64_t v150 = *(void *)(a1 + 16);
  uint64_t v143 = v7;
  if (v7)
  {
    uint64_t v8 = (float32x4_t *)(*(void *)(a1 + 16) + 64);
    float32x4_t v9 = 0uLL;
    uint64_t v10 = v8;
    do
    {
      float32x4_t v11 = *v10++;
      v12.i32[1] = v11.i32[1];
      float32x4_t v9 = vaddq_f32(v9, v11);
      --v7;
    }
    while (v7);
    uint64_t v13 = v143;
    *(float *)v12.i32 = (float)v143;
    float32x4_t v14 = vdivq_f32(v9, (float32x4_t)vdupq_lane_s32(v12, 0));
    int32x2_t v15 = 0;
    do
    {
      float32x4_t v16 = *v8++;
      float32x4_t v17 = vsubq_f32(v14, v16);
      float32x4_t v18 = vmulq_f32(v17, v17);
      float v19 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0];
      if (*(float *)v15.i32 <= v19) {
        *(float *)v15.i32 = v19;
      }
      --v13;
    }
    while (v13);
  }
  else
  {
    float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x7FC00000u);
    int32x2_t v15 = 0;
  }
  uint64_t v20 = 0;
  *(float *)v15.i32 = (float)(sqrtf(*(float *)v15.i32) * 9.0) / 2.4495;
  float32x4_t v21 = (float32x4_t)vdupq_lane_s32(v15, 0);
  do
  {
    *(float32x4_t *)(v150 + v20 * 16) = vmlaq_f32(v14, v21, (float32x4_t)xmmword_1B6E50F70[v20]);
    ++v20;
  }
  while (v20 != 4);
  *uint64_t v6 = (float32x4_t)xmmword_1B6E4B1A0;
  *uint64_t v4 = 1;
  if (!sub_1B647E1DC(v6, v150)) {
    sub_1B63F2F54(16, @"Error: _buildTetrahedrons - failed with first tetrahedron", v22, v23, v24, v25, v26, v27, v140);
  }
  uint64_t v28 = v143;
  if (!v143)
  {
    LODWORD(v30) = 1;
    goto LABEL_144;
  }
  uint64_t v145 = 0;
  uint64_t v142 = v6 + 2;
  uint64_t v29 = 12;
  LODWORD(v30) = 1;
  uint64_t v152 = v5;
  uint64_t v153 = v3;
  uint64_t v151 = v6;
  do
  {
    while (!v30)
    {
      unsigned int v87 = 0;
      if (++v145 == v28) {
        goto LABEL_159;
      }
    }
    uint64_t v31 = 0;
    unsigned int v147 = 0;
    float32x4_t v32 = *(float32x4_t *)(v150 + 16 * (v145 + 4));
    unsigned int v144 = v30;
    uint64_t v33 = v30;
    uint64_t v34 = v142;
    do
    {
      float32x4_t v35 = vsubq_f32(v32, *v34);
      float32x4_t v36 = vmulq_f32(v35, v35);
      if (COERCE_FLOAT(HIDWORD(*(unsigned long long *)v34)) + 0.00001 >= vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0])
      {
        v3[v147] = v31;
        v5[v31] = 0;
        ++v147;
      }
      ++v31;
      v34 += 3;
    }
    while (v33 != v31);
    if (!v147)
    {
      LODWORD(v30) = v144;
      goto LABEL_140;
    }
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    unint64_t v39 = v147;
    do
    {
      uint64_t v40 = 0;
      uint64_t v148 = v37;
      uint64_t v41 = v3[v37];
      float32x2_t v42 = &v6[3 * v41];
      unint64_t v154 = v42;
      uint64_t v155 = v41;
      do
      {
        uint64_t v43 = 0;
        uint64_t v44 = &dword_1B6E50F30[3 * v40];
        uint64_t v45 = v44[1];
        uint64_t v46 = v42->i32[*v44];
        uint64_t v47 = v42->i32[v45];
        uint64_t v48 = v44[2];
        uint64_t v49 = v42->i32[v48];
        if (v46 >= v47) {
          uint64_t v50 = v42->i32[v45];
        }
        else {
          uint64_t v50 = v46;
        }
        if (v46 <= v47) {
          uint64_t v51 = v42->i32[v45];
        }
        else {
          uint64_t v51 = v46;
        }
        if (v50 >= v49) {
          uint64_t v50 = v42->i32[v48];
        }
        if (v51 <= v49) {
          uint64_t v51 = v42->i32[v48];
        }
        if (v50 == v47 || v51 == v47) {
          uint64_t v47 = v42->i32[v48];
        }
        if (v50 != v46 && v51 != v46) {
          uint64_t v47 = v46;
        }
        BOOL v54 = 1;
        while (1)
        {
          uint64_t v55 = v3[v43];
          if (v55 != v41) {
            break;
          }
LABEL_79:
          BOOL v54 = ++v43 < v39;
          if (v43 == v39) {
            goto LABEL_82;
          }
        }
        uint64_t v56 = 0;
        int v57 = &v6[3 * v55];
        while (1)
        {
          uint64_t v58 = v57->i32[dword_1B6E50F30[v56]];
          uint64_t v22 = v57->i32[dword_1B6E50F30[v56 + 1]];
          uint64_t v59 = v57->i32[dword_1B6E50F30[v56 + 2]];
          if (v58 >= v22) {
            uint64_t v23 = v57->i32[dword_1B6E50F30[v56 + 1]];
          }
          else {
            uint64_t v23 = v57->i32[dword_1B6E50F30[v56]];
          }
          if (v58 <= v22) {
            uint64_t v24 = v57->i32[dword_1B6E50F30[v56 + 1]];
          }
          else {
            uint64_t v24 = v57->i32[dword_1B6E50F30[v56]];
          }
          if (v23 >= v59) {
            uint64_t v23 = v57->i32[dword_1B6E50F30[v56 + 2]];
          }
          if (v24 <= v59) {
            uint64_t v24 = v57->i32[dword_1B6E50F30[v56 + 2]];
          }
          if (v23 != v22 && v24 != v22) {
            uint64_t v59 = v57->i32[dword_1B6E50F30[v56 + 1]];
          }
          if (v23 != v58 && v24 != v58) {
            uint64_t v59 = v57->i32[dword_1B6E50F30[v56]];
          }
          BOOL v62 = v23 == v50 && v59 == v47;
          if (v62 && v24 == v51) {
            break;
          }
          v56 += 3;
          if (v56 == 12) {
            goto LABEL_79;
          }
        }
        if (!v54)
        {
LABEL_82:
          uint64_t v156 = v40;
          unint64_t v64 = 0;
          uint64_t v65 = v38;
          CFNumberRef v66 = &v159[3 * v38];
          *CFNumberRef v66 = v46;
          v66[1] = v42->i32[v45];
          uint64_t v157 = v66;
          void v66[2] = v42->i32[v48];
          do
          {
            unint64_t v67 = v64;
            if (v64 == 3) {
              break;
            }
            ++v64;
            uint64_t v68 = v67 == 2 ? 0 : v67 + 1;
            uint64_t v69 = v38;
            if (v38)
            {
              uint64_t v70 = 0;
              unint64_t v71 = 0;
              float32x4_t v72 = v159;
              int v73 = v157[v67];
              int v74 = v157[v68];
              do
              {
                uint64_t v75 = 0;
                unsigned int v76 = 0;
                do
                {
                  int v77 = v72[v75];
                  if (v77 == v73 || v77 == v74) {
                    ++v76;
                  }
                  ++v75;
                }
                while (v75 != 3);
                if (v76 >= 3) {
                  sub_1B63F2F54(17, @"Assertion '%s' failed. _faceHasEdgeSharedWithMoreThanTwoOtherOpenFace", v22, v23, v24, v29, v38, v39, (uint64_t)"vCount <=2");
                }
                if (v76 == 2) {
                  ++v71;
                }
                ++v70;
                v72 += 3;
              }
              while (v70 != v65);
            }
            else
            {
              unint64_t v71 = 0;
            }
            uint64_t v38 = v69;
          }
          while (v71 < 2);
          if (v67 <= 2) {
            uint64_t v38 = v38;
          }
          else {
            uint64_t v38 = (v38 + 1);
          }
          uint64_t v5 = v152;
          uint64_t v3 = v153;
          uint64_t v6 = v151;
          uint64_t v29 = 12;
          unint64_t v39 = v147;
          float32x2_t v42 = v154;
          uint64_t v41 = v155;
          uint64_t v40 = v156;
        }
        ++v40;
      }
      while (v40 != 4);
      v149[v148] = v41;
      uint64_t v37 = v148 + 1;
    }
    while (v148 + 1 != v39);
    if (!v38)
    {
      LODWORD(v30) = v144;
      unsigned int v81 = v147;
LABEL_127:
      uint64_t v88 = 0;
      uint64_t v89 = v81;
      int v90 = v30 - 1;
      uint64_t v158 = v81;
      do
      {
        uint64_t v91 = v149[v88];
        int v92 = v90;
        do
        {
          uint64_t v93 = v92;
          int v94 = v5[v92--];
          if (v94) {
            BOOL v95 = 0;
          }
          else {
            BOOL v95 = v91 < v93;
          }
        }
        while (v95);
        LODWORD(v30) = v30 - 1;
        if (v91 >= v93)
        {
          if (v30 > v91)
          {
            int v102 = v30;
            sub_1B63F2F54(17, @"Assertion '%s' failed. validTetraCount > indexToRecycle", v22, v23, v24, v29, v38, v39, (uint64_t)"validTetraCount <= (uint32_t)indexToRecycle");
            LODWORD(v30) = v102;
          }
        }
        else
        {
          if (!v94)
          {
            int v96 = v30;
            sub_1B63F2F54(17, @"Assertion '%s' failed. will make an invalid tetrahedron valid", v22, v23, v24, v29, v38, v39, (uint64_t)"tetrahedronIsValid[indexValid]");
            LODWORD(v30) = v96;
            uint64_t v89 = v158;
          }
          uint64_t v97 = (long long *)&v6[3 * (int)v93];
          long long v98 = *v97;
          long long v99 = v97[1];
          long long v100 = v97[2];
          f32 = (_OWORD *)v6[3 * v91].f32;
          f32[1] = v99;
          f32[2] = v100;
          _OWORD *f32 = v98;
          v5[v91] = 1;
          v5[v93] = 0;
        }
        ++v88;
        --v90;
      }
      while (v88 != v89);
      goto LABEL_140;
    }
    uint64_t v79 = v38;
    CATransform3D v80 = v159 + 2;
    uint64_t v30 = v144;
    unsigned int v81 = v147;
    do
    {
      if (v81)
      {
        uint64_t v82 = v30;
        unsigned int v83 = v81 - 1;
        uint64_t v84 = v149[v81 - 1];
      }
      else
      {
        uint64_t v82 = (v30 + 1);
        uint64_t v84 = v30;
        if (v30 >= v146) {
          sub_1B63F2F54(16, @"Error: tetrahedrisation: index out of bounds", v22, v23, v24, v29, v38, v39, v140);
        }
        unsigned int v83 = 0;
      }
      v5[v84] = 1;
      __int32 v85 = *v80;
      CFNumberRef v86 = &v6[3 * v84];
      v86->i64[0] = *((void *)v80 - 1);
      v86->i32[2] = v85;
      v86->i32[3] = v145 + 4;
      if (sub_1B647E1DC(v86, v150))
      {
        uint64_t v30 = v82;
        unsigned int v81 = v83;
      }
      else
      {
        v5[v84] = 0;
        v149[v83] = v84;
        unsigned int v81 = v83 + 1;
        uint64_t v30 = v82;
      }
      v80 += 3;
      --v79;
    }
    while (v79);
    if (v81) {
      goto LABEL_127;
    }
LABEL_140:
    uint64_t v28 = v143;
    ++v145;
    uint64_t v29 = 12;
  }
  while (v145 != v143);
  if (!v30)
  {
    unsigned int v87 = 0;
    goto LABEL_159;
  }
LABEL_144:
  uint64_t v103 = 0;
  __asm { FMOV            V0.4S, #0.25 }
  do
  {
    uint64_t v108 = 0;
    uint64_t v109 = (int *)&v6[3 * v103];
    float32x4_t v110 = vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(*(float32x4_t *)(v150 + 16 * *v109), *(float32x4_t *)(v150 + 16 * v109[1])), *(float32x4_t *)(v150 + 16 * v109[2])), *(float32x4_t *)(v150 + 16 * v109[3])), _Q0);
    do
    {
      uint64_t v111 = dword_1B6E50F30[v108];
      uint64_t v112 = dword_1B6E50F30[v108 + 1];
      uint64_t v113 = v109[v111];
      float32x4_t v114 = *(float32x4_t *)(v150 + 16 * v113);
      uint64_t v115 = v109[v112];
      float32x4_t v116 = vsubq_f32(*(float32x4_t *)(v150 + 16 * v115), v114);
      float32x4_t v117 = vsubq_f32(*(float32x4_t *)(v150 + 16 * v109[dword_1B6E50F30[v108 + 2]]), v114);
      float32x4_t v118 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v117, (int32x4_t)v117), (int8x16_t)v117, 0xCuLL), vnegq_f32(v116)), v117, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v116, (int32x4_t)v116), (int8x16_t)v116, 0xCuLL));
      float32x4_t v119 = vmulq_f32(v118, v118);
      v119.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v119.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v119, 2), v119)).u64[0];
      float32x4_t v120 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v119.f32, 0);
      v120.i32[3] = 0;
      float32x4_t v121 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v118, (int32x4_t)v118), (int8x16_t)v118, 0xCuLL);
      float32x4_t v122 = vrsqrteq_f32(v120);
      float32x4_t v123 = vmulq_f32(v122, vrsqrtsq_f32(v120, vmulq_f32(v122, v122)));
      int32x4_t v124 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v119.f32[0] != 0.0)), 0x1FuLL));
      v124.i32[3] = 0;
      float32x4_t v125 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v124), (int8x16_t)vmulq_f32(v121, vmulq_f32(v123, vrsqrtsq_f32(v120, vmulq_f32(v123, v123)))), (int8x16_t)v121);
      float32x4_t v126 = vmulq_f32(v114, v125);
      float32x4_t v127 = vmulq_f32(v110, v125);
      if (vsubq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v127, 2), vaddq_f32(v127, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v127.f32, 1))), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v126, 2), vaddq_f32(v126, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v126.f32, 1)))).f32[0] > 0.0)
      {
        v109[v111] = v115;
        v109[v112] = v113;
      }
      v108 += 3;
    }
    while (v108 != 12);
    ++v103;
  }
  while (v103 != v30);
  uint64_t v128 = 0;
  unsigned int v87 = 0;
  v129.i64[0] = 0x300000003;
  v129.i64[1] = 0x300000003;
  uint64_t v130 = v6;
  do
  {
    if (v130->i32[0] >= 4 && v130->i32[1] >= 4 && v130->i32[2] >= 4 && v130->i32[3] >= 4)
    {
      if (v128 != v87)
      {
        uint64_t v131 = &v6[3 * v87];
        float32x4_t v132 = *v130;
        float32x4_t v133 = v130[2];
        v131[1] = v130[1];
        v131[2] = v133;
        *uint64_t v131 = v132;
      }
      v6[3 * v87] = (float32x4_t)vaddq_s32((int32x4_t)v6[3 * v87], v129);
      ++v87;
    }
    ++v128;
    v130 += 3;
  }
  while (v30 != v128);
LABEL_159:
  *(_DWORD *)(a1 + 224) = v87;
  sub_1B647C620(a1, v87);
  sub_1B647C30C(a1);
  unsigned int v135 = *(_DWORD *)(a1 + 224);
  if (v135)
  {
    uint64_t v136 = (float32x4_t *)(*(void *)(a1 + 48) + 32);
    float32x4_t v137 = 0uLL;
    uint64_t v138 = *(unsigned int *)(a1 + 224);
    do
    {
      float32x4_t v139 = *v136;
      v136 += 3;
      v134.i32[1] = v139.i32[1];
      float32x4_t v137 = vaddq_f32(v137, v139);
      --v138;
    }
    while (v138);
  }
  else
  {
    float32x4_t v137 = 0uLL;
  }
  *(float *)v134.i32 = (float)v135;
  *(float32x4_t *)(a1 + 208) = vdivq_f32(v137, (float32x4_t)vdupq_lane_s32(v134, 0));
  free(v3);
  free(v159);
  free(v149);

  free(v5);
}

uint64_t sub_1B647D614(uint64_t result)
{
  *(void *)(result + 240) = 0;
  return result;
}

void sub_1B647D61C(float a1, float a2, float a3)
{
  float v3 = (float)((float)((float)(a3 * -27.0) + (float)((float)(a1 * 9.0) * a2))
             + (float)((float)((float)(a1 * -2.0) * a1) * a1))
     / 54.0;
  float v4 = (float)((float)((float)(a2 * 3.0) - (float)(a1 * a1)) / 9.0)
     * (float)((float)((float)((float)(a2 * 3.0) - (float)(a1 * a1)) / 9.0)
             * (float)((float)((float)(a2 * 3.0) - (float)(a1 * a1)) / 9.0));
  float v5 = v4 + (float)(v3 * v3);
  if (v5 >= 0.0)
  {
    float v10 = sqrtf(v5);
    cbrtf(v3 + v10);
    cbrtf(v3 - v10);
  }
  else
  {
    float v6 = acosf(v3 / sqrtf(-v4));
    cosf(v6 / 3.0);
    double v7 = v6;
    float v8 = (v7 + 6.28318531) / 3.0;
    cosf(v8);
    float v9 = (v7 + 12.5663706) / 3.0;
    cosf(v9);
  }
}

__n64 sub_1B647D748(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4 = vsubq_f32(a2, a1);
  float32x4_t v5 = vsubq_f32(a3, a1);
  float32x4_t v6 = vsubq_f32(a4, a1);
  float32x4_t v7 = vmulq_f32(v4, v4);
  v7.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).u32[0];
  float32x4_t v8 = vmulq_f32(v4, v5);
  float32x4_t v9 = vmulq_f32(v5, v5);
  v8.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
  LODWORD(v10) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).u32[0];
  float32x4_t v11 = vmulq_f32(v4, v6);
  v11.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
  float32x4_t v12 = vmulq_f32(v5, v6);
  v12.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0];
  v5.f32[0] = -v8.f32[0];
  v8.f32[0] = vmlas_n_f32((float)-v8.f32[0] * v8.f32[0], v10, v7.f32[0]);
  float v13 = vmlas_n_f32(v5.f32[0] * v12.f32[0], v11.f32[0], v10) / v8.f32[0];
  result.n64_f32[0] = (float)(1.0 - v13)
                    - (float)(vmlas_n_f32(v5.f32[0] * v11.f32[0], v12.f32[0], v7.f32[0]) / v8.f32[0]);
  result.n64_f32[1] = v13;
  return result;
}

BOOL sub_1B647D7F4(uint64_t a1, unsigned int *a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t a9, float a10)
{
  unsigned int v10 = *(_DWORD *)(a1 + 224);
  if (!v10) {
    return 0;
  }
  float32x4_t v12 = (float32x4_t)a9;
  uint64_t v13 = *(void *)(a1 + 16) + 64;
  uint64_t v14 = *(void *)(a1 + 48);
  uint64_t v43 = *(void *)(a1 + 64);
  uint64_t v15 = *(void *)(a1 + 192);
  float32x4_t v38 = (float32x4_t)vdupq_laneq_s32(a9, 2);
  float32x4_t v39 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.i8, 1);
  if (*a2 >= v10) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = *a2;
  }
  float32x4_t v44 = (float32x4_t)vdupq_n_s32(0xB8D1B717);
  while (1)
  {
    float32x4_t v17 = (int *)(v14 + 48 * v16);
    uint64_t v18 = v17[3];
    if (v18 == 0x7FFFFFFF)
    {
      uint64_t v20 = *v17;
      uint64_t v19 = v17[1];
      float32x4_t v21 = *(float32x4_t *)(v13 + 16 * v20);
      uint64_t v22 = v17[2];
      float32x4_t v23 = vsubq_f32(*(float32x4_t *)(v13 + 16 * v19), v21);
      float32x4_t v24 = vsubq_f32(*(float32x4_t *)(v13 + 16 * v22), v21);
      int8x16_t v25 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), vnegq_f32(v23)), v24, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL));
      float32x4_t v26 = vmulq_f32(vsubq_f32(v12, v21), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), v25, 0xCuLL));
      float32x4_t v27 = (float32x4_t)xmmword_1B6E50860;
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0] >= 0.0)
      {
        float32x4_t v28 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(v43 + 48 * v16), v12.f32[0]), v39, *(float32x4_t *)(v43 + 48 * v16 + 16)), v38, *(float32x4_t *)(v43 + 48 * v16 + 32));
        float32x4_t v40 = *(float32x4_t *)(v13 + 16 * v20);
        float32x4_t v41 = *(float32x4_t *)(v13 + 16 * v19);
        float32x4_t v42 = *(float32x4_t *)(v13 + 16 * v22);
        sub_1B647D61C(v28.f32[0], v28.f32[1], v28.f32[2]);
        *(__n64 *)v30.f32 = sub_1B647D748(vmlaq_n_f32(v40, *(float32x4_t *)(v15 + 16 * v20), v29), vmlaq_n_f32(v41, *(float32x4_t *)(v15 + 16 * v19), v29), vmlaq_n_f32(v42, *(float32x4_t *)(v15 + 16 * v22), v29), (float32x4_t)a9);
        float32x4_t v12 = (float32x4_t)a9;
        float32x4_t v27 = v30;
        v27.i32[3] = 0;
      }
    }
    else
    {
      *(double *)v31.i64 = sub_1B647DAA0(*(float32x4_t *)(v43 + 48 * v16), *(float32x4_t *)(v43 + 48 * v16 + 16), *(float32x4_t *)(v43 + 48 * v16 + 32), *(float32x4_t *)(v13 + 16 * v18), v12);
      float32x4_t v12 = (float32x4_t)a9;
      float32x4_t v27 = v31;
    }
    if ((vminvq_u32((uint32x4_t)vcgtq_f32(v27, v44)) & 0x80000000) != 0)
    {
      *a3 = v27;
      *a2 = v16;
      return *(float *)(v14 + 48 * v16 + 44) >= a10;
    }
    float v32 = v27.f32[1];
    uint64_t v33 = v27.f32[1] < v27.f32[0];
    if (v27.f32[1] >= v27.f32[0]) {
      float v32 = v27.f32[0];
    }
    if (v27.f32[2] < v32)
    {
      float v32 = v27.f32[2];
      uint64_t v33 = 2;
    }
    if (v27.f32[3] < v32) {
      uint64_t v33 = 3;
    }
    unsigned int v34 = *(_DWORD *)(v14 + 48 * v16 + 4 * dword_1B6E50F60[v33] + 16);
    if (v34 == -1) {
      break;
    }
    unsigned int v16 = v34;
    if (!--v10) {
      return 0;
    }
  }
  if (v16 == -1)
  {
    float32x4_t v46 = v27;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Should never have been outside the tetras", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"lastIndex != (uint32_t)-1");
    float32x4_t v27 = v46;
  }
  *a3 = v27;
  *a2 = v16;
  return 1;
}

double sub_1B647DAA0(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t v5 = vsubq_f32(a5, a4);
  *(void *)&double result = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, v5.f32[0]), a2, *(float32x2_t *)v5.f32, 1), a3, v5, 2).u64[0];
  return result;
}

void sub_1B647DAD0(void *a1, unsigned int a2, float32x4_t a3, float a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = a1[2] + 64;
  float32x4_t v12 = (int *)(a1[6] + 48 * a2);
  long long v29 = xmmword_1B6E50F10;
  *((float *)&v29 + 2) = 0.25098 * a4;
  sub_1B642AB40(a1[31], 0, (float *)&v29, a6, a7, a8, a9, a10, *(float32x4_t *)(v11 + 16 * *v12), a3);
  sub_1B642AB40(a1[31], 0, (float *)&v29, v13, v14, v15, v16, v17, *(float32x4_t *)(v11 + 16 * v12[1]), a3);
  sub_1B642AB40(a1[31], 0, (float *)&v29, v18, v19, v20, v21, v22, *(float32x4_t *)(v11 + 16 * v12[2]), a3);
  sub_1B642AB40(a1[31], 0, (float *)&v29, v23, v24, v25, v26, v27, *(float32x4_t *)(v11 + 16 * v12[3]), a3);
}

float32x4_t sub_1B647DBA8(uint64_t a1, unsigned int *a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t a9)
{
  if (!a2)
  {
    int32x4_t v31 = a9;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"cacheIndex");
    a9 = v31;
  }
  __n128 v32 = 0uLL;
  BOOL v12 = sub_1B647D7F4(a1, a2, (float32x4_t *)&v32, a4, a5, a6, a7, a8, a9, 0.0);
  uint64_t v13 = (int *)(*(void *)(a1 + 48) + 48 * *a2);
  uint64_t v14 = *(void *)(a1 + 24) + 192;
  if (v12)
  {
    uint64_t v15 = (float32x4_t *)(v14 + 48 * *v13);
    float32x4_t result = (float32x4_t)v32;
    float32x4_t v17 = vmulq_n_f32(*v15, v32.n128_f32[0]);
    *a3 = v17;
    float32x4_t v18 = vmulq_n_f32(v15[1], result.f32[0]);
    a3[1] = v18;
    float32x4_t v19 = vmulq_n_f32(v15[2], result.f32[0]);
    a3[2] = v19;
    uint64_t v20 = (float32x4_t *)(v14 + 48 * v13[1]);
    float32x4_t v21 = vmlaq_lane_f32(v17, *v20, *(float32x2_t *)result.f32, 1);
    *a3 = v21;
    float32x4_t v22 = vmlaq_lane_f32(v18, v20[1], *(float32x2_t *)result.f32, 1);
    a3[1] = v22;
    float32x4_t v23 = vmlaq_lane_f32(v19, v20[2], *(float32x2_t *)result.f32, 1);
    a3[2] = v23;
    uint64_t v24 = (float32x4_t *)(v14 + 48 * v13[2]);
    float32x4_t v25 = vmlaq_laneq_f32(v21, *v24, result, 2);
    *a3 = v25;
    float32x4_t v26 = vmlaq_laneq_f32(v22, v24[1], result, 2);
    a3[1] = v26;
    float32x4_t v27 = vmlaq_laneq_f32(v23, v24[2], result, 2);
    a3[2] = v27;
    float32x4_t v28 = (float32x4_t *)(v14 + 48 * v13[3]);
    *a3 = vmlaq_laneq_f32(v25, *v28, result, 3);
    a3[1] = vmlaq_laneq_f32(v26, v28[1], result, 3);
    a3[2] = vmlaq_laneq_f32(v27, v28[2], result, 3);
  }
  else
  {
    uint64_t v29 = v14 + 48 * *v13;
    float32x4_t result = *(float32x4_t *)v29;
    float32x4_t v30 = *(float32x4_t *)(v29 + 32);
    a3[1] = *(float32x4_t *)(v29 + 16);
    a3[2] = v30;
    *a3 = result;
  }
  return result;
}

float32x4_t sub_1B647DD14(void *a1, unsigned int *a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t a9)
{
  int32x4_t v53 = a9;
  if (!a2)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"cacheIndex");
    a9 = v53;
  }
  float32x4_t v55 = 0uLL;
  if (sub_1B647D7F4((uint64_t)a1, a2, &v55, a4, a5, a6, a7, a8, a9, 0.0))
  {
    float32x4_t v18 = (float32x4_t)v53;
    float32x4_t v19 = v55;
    if (a1[31])
    {
      float32x4_t v54 = v55;
      sub_1B647DAD0(a1, *a2, v18, v55.f32[0], v12, v13, v14, v15, v16, v17);
      float32x4_t v19 = v54;
    }
    uint64_t v20 = (int *)(a1[6] + 48 * *a2);
    uint64_t v21 = a1[3] + 448;
    float32x4_t v22 = (float32x4_t *)(v21 + 112 * *v20);
    float32x4_t v23 = vmulq_n_f32(*v22, v19.f32[0]);
    *a3 = v23;
    float32x4_t v24 = vmulq_n_f32(v22[1], v19.f32[0]);
    a3[1] = v24;
    float32x4_t v25 = vmulq_n_f32(v22[2], v19.f32[0]);
    a3[2] = v25;
    float32x4_t v26 = vmulq_n_f32(v22[3], v19.f32[0]);
    a3[3] = v26;
    float32x4_t v27 = vmulq_n_f32(v22[4], v19.f32[0]);
    a3[4] = v27;
    float32x4_t v28 = vmulq_n_f32(v22[5], v19.f32[0]);
    a3[5] = v28;
    float32x4_t v29 = vmulq_n_f32(v22[6], v19.f32[0]);
    a3[6] = v29;
    float32x4_t v30 = (float32x4_t *)(v21 + 112 * v20[1]);
    float32x4_t v31 = vmlaq_lane_f32(v23, *v30, *(float32x2_t *)v19.f32, 1);
    *a3 = v31;
    float32x4_t v32 = vmlaq_lane_f32(v24, v30[1], *(float32x2_t *)v19.f32, 1);
    a3[1] = v32;
    float32x4_t v33 = vmlaq_lane_f32(v25, v30[2], *(float32x2_t *)v19.f32, 1);
    a3[2] = v33;
    float32x4_t v34 = vmlaq_lane_f32(v26, v30[3], *(float32x2_t *)v19.f32, 1);
    a3[3] = v34;
    float32x4_t v35 = vmlaq_lane_f32(v27, v30[4], *(float32x2_t *)v19.f32, 1);
    a3[4] = v35;
    float32x4_t v36 = vmlaq_lane_f32(v28, v30[5], *(float32x2_t *)v19.f32, 1);
    a3[5] = v36;
    float32x4_t v37 = vmlaq_lane_f32(v29, v30[6], *(float32x2_t *)v19.f32, 1);
    a3[6] = v37;
    float32x4_t v38 = (float32x4_t *)(v21 + 112 * v20[2]);
    float32x4_t v39 = vmlaq_laneq_f32(v31, *v38, v19, 2);
    *a3 = v39;
    float32x4_t v40 = vmlaq_laneq_f32(v32, v38[1], v19, 2);
    a3[1] = v40;
    float32x4_t v41 = vmlaq_laneq_f32(v33, v38[2], v19, 2);
    a3[2] = v41;
    float32x4_t v42 = vmlaq_laneq_f32(v34, v38[3], v19, 2);
    a3[3] = v42;
    float32x4_t v43 = vmlaq_laneq_f32(v35, v38[4], v19, 2);
    a3[4] = v43;
    float32x4_t v44 = vmlaq_laneq_f32(v36, v38[5], v19, 2);
    a3[5] = v44;
    float32x4_t result = vmlaq_laneq_f32(v37, v38[6], v19, 2);
    a3[6] = result;
    int v46 = v20[3];
    if (v46 <= 2147483645)
    {
      uint64_t v47 = (float32x4_t *)(v21 + 112 * v46);
      *a3 = vmlaq_laneq_f32(v39, *v47, v19, 3);
      a3[1] = vmlaq_laneq_f32(v40, v47[1], v19, 3);
      a3[2] = vmlaq_laneq_f32(v41, v47[2], v19, 3);
      a3[3] = vmlaq_laneq_f32(v42, v47[3], v19, 3);
      a3[4] = vmlaq_laneq_f32(v43, v47[4], v19, 3);
      a3[5] = vmlaq_laneq_f32(v44, v47[5], v19, 3);
      float32x4_t result = vmlaq_laneq_f32(result, v47[6], v19, 3);
      a3[6] = result;
    }
  }
  else
  {
    uint64_t v48 = (float32x4_t *)a1[3];
    float32x4_t v49 = v48[28];
    float32x4_t v50 = v48[30];
    a3[1] = v48[29];
    a3[2] = v50;
    *a3 = v49;
    float32x4_t result = v48[31];
    float32x4_t v51 = v48[32];
    float32x4_t v52 = v48[34];
    a3[5] = v48[33];
    a3[6] = v52;
    a3[3] = result;
    a3[4] = v51;
  }
  return result;
}

__n128 sub_1B647DF78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 result)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 232) == 3)
  {
    if (a3 != 108) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. wrong data size for SH", a3, a4, a5, a6, a7, a8, (uint64_t)"sh_sizeof(shOrder) == (size_t)shLength");
    }
    uint64_t v11 = 0;
    v20[0] = a2;
    v20[1] = a2 + 36;
    v20[2] = a2 + 72;
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0xBEA6C6BC);
    do
    {
      uint64_t v13 = v20[v11];
      v14.i32[0] = *(_DWORD *)(v13 + 12);
      v14.i32[1] = *(_DWORD *)(v13 + 4);
      *(float32x2_t *)&long long v15 = vmul_f32(v14, v12);
      *((float *)&v15 + 2) = *(float *)(v13 + 8) * 0.32573;
      *((float *)&v15 + 3) = (float)(*(float *)(v13 + 24) * -0.078848) + (float)(*(float *)v13 * 0.28209);
      *(&v21 + v11++) = v15;
    }
    while (v11 != 3);
    uint64_t v16 = 0;
    long long v17 = v22;
    *(_OWORD *)(a1 + 80) = v21;
    *(_OWORD *)(a1 + 96) = v17;
    *(_OWORD *)(a1 + 112) = v23;
    do
    {
      *(&v21 + v16) = (__int128)vmulq_f32(*(float32x4_t *)(v20[v16] + 16), (float32x4_t)xmmword_1B6E50F00);
      ++v16;
    }
    while (v16 != 3);
    long long v18 = v22;
    *(_OWORD *)(a1 + 128) = v21;
    *(_OWORD *)(a1 + 144) = v18;
    *(_OWORD *)(a1 + 160) = v23;
    v19.i32[0] = *(_DWORD *)(a2 + 32);
    v19.i32[1] = *(_DWORD *)(a2 + 68);
    result.n128_u64[0] = (unint64_t)vmul_f32(v19, (float32x2_t)vdup_n_s32(0x3E0BD8A0u));
    result.n128_f32[2] = *(float *)(a2 + 104) * 0.13657;
    result.n128_u32[3] = 1.0;
    *(__n128 *)(a1 + 176) = result;
  }
  return result;
}

uint64_t sub_1B647E10C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 232);
}

void sub_1B647E118(void **a1)
{
  free(a1[3]);
  free(a1[2]);

  sub_1B647C9DC(a1);
}

CFStringRef sub_1B647E15C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXLightProbesSystem %p>", a1);
}

CFStringRef sub_1B647E19C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXLightProbesSystem %p>", a1);
}

BOOL sub_1B647E1DC(float32x4_t *a1, uint64_t a2)
{
  float32x4_t v2 = *(float32x4_t *)(a2 + 16 * a1->i32[0]);
  float32x4_t v3 = *(float32x4_t *)(a2 + 16 * a1->i32[1]);
  float32x4_t v4 = *(float32x4_t *)(a2 + 16 * a1->i32[2]);
  float32x4_t v5 = *(float32x4_t *)(a2 + 16 * a1->i32[3]);
  int8x16_t v6 = (int8x16_t)vsubq_f32(v3, v2);
  double v7 = *(float *)v6.i32;
  int8x16_t v8 = (int8x16_t)vsubq_f32(v4, v2);
  double v9 = *(float *)&v8.i32[1];
  int8x16_t v10 = (int8x16_t)vsubq_f32(v5, v2);
  _D20 = *(float *)&v10.i32[1];
  v12.i32[0] = vextq_s8(v8, v8, 8uLL).u32[0];
  v12.i32[1] = v8.i32[0];
  v8.i32[0] = vextq_s8(v10, v10, 8uLL).u32[0];
  v8.i32[1] = v10.i32[0];
  _Q5 = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 4uLL));
  float64x2_t v14 = vcvtq_f64_f32(*(float32x2_t *)v8.i8);
  float64x2_t v15 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v14.f64[0], 0);
  v15.f64[0] = _D20;
  _Q17 = vcvtq_f64_f32(v12);
  float64x2_t v17 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&_Q17.f64[0], 0);
  v17.f64[0] = v9;
  float64x2_t v18 = vmlaq_f64(vmulq_f64(_Q17, vnegq_f64(v15)), v14, v17);
  __asm
  {
    FMLA            D22, D20, V17.D[1]
    FMLA            D23, D22, V5.D[1]
  }
  double v25 = fabs(_D23);
  if (v25 < 0.00001)
  {
    __asm { FMOV            V4.4S, #0.25 }
    float32x4_t v34 = vsubq_f32(vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v2, v3), v4), v5), _Q4), v2);
  }
  else
  {
    float64_t v26 = -_Q17.f64[1] * _Q5.f64[0] + v7 * v9;
    double v27 = vmlad_n_f64(-(v7 * _D20), v14.f64[1], _Q5.f64[0]);
    double v28 = vmlad_n_f64(_D20 * _D20 + v14.f64[1] * v14.f64[1], v14.f64[0], v14.f64[0]);
    double v29 = vmlad_n_f64(v9 * v9 + _Q17.f64[1] * _Q17.f64[1], _Q17.f64[0], _Q17.f64[0]);
    double v30 = vmulq_f64(_Q5, _Q5).f64[0] + v7 * v7 + _Q5.f64[1] * _Q5.f64[1];
    double v31 = (v29 * v27 + v30 * _D22 + v28 * v26) * (0.5 / _D23);
    *(void *)&v32.f64[0] = vdupq_laneq_s64((int64x2_t)_Q5, 1).u64[0];
    v32.f64[1] = v7;
    float32x4_t v34 = (float32x4_t)vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_f64(vmulq_f64(vnegq_f64(_Q5), v14), v32, v15), v29), v18, v30), vmlaq_f64(vmulq_f64(v32, vnegq_f64(v17)), _Q17, _Q5), v28), 0.5 / _D23);
    *(float32x2_t *)v34.f32 = vcvt_f32_f64((float64x2_t)v34);
    float32_t v33 = v31;
    v34.f32[2] = v33;
  }
  float32x4_t v36 = vaddq_f32(v2, v34);
  float32x4_t v37 = vmulq_f32(v34, v34);
  v36.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u32[0];
  a1[2] = v36;
  return v25 >= 0.00001;
}

uint64_t sub_1B647E35C(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

void *sub_1B647E38C(uint64_t a1, CFIndex a2)
{
  if (qword_1E9DDAEA0 != -1) {
    dispatch_once_f(&qword_1E9DDAEA0, &qword_1E9DDAE98, (dispatch_function_t)sub_1B647E35C);
  }
  int8x16_t v10 = (void *)sub_1B63C8D44(qword_1E9DDAE98, 0x18uLL);
  if (!v10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v4, v5, v6, v7, v8, v9, (uint64_t)"edges");
  }
  void v10[2] = 0;
  v10[3] = 0;
  uint64_t v11 = sub_1B64ABD78(a1, a2, 1, v5, v6, v7, v8, v9);
  uint64_t v12 = sub_1B63D11E8((uint64_t)v11);
  float32x2_t v19 = sub_1B64ACF7C(a1, 1, v13, v14, v15, v16, v17, v18);
  uint64_t v27 = sub_1B641D8A0((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26);
  int64_t v28 = (uint64_t)(float)(v27 * v27);
  float32_t v33 = malloc_type_calloc(1uLL, v28, 0x90787BC3uLL);
  if (v12 < 1)
  {
    v10[3] = 0;
  }
  else
  {
    unint64_t v67 = v10 + 2;
    uint64_t v68 = v10;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    do
    {
      uint64_t v36 = sub_1B63D14A0((uint64_t)v11, v34, 0, 0, v29, v30, v31, v32);
      uint64_t v41 = sub_1B63D14A0((uint64_t)v11, v34, 1, 0, v37, v38, v39, v40);
      uint64_t v46 = sub_1B63D14A0((uint64_t)v11, v34, 2, 0, v42, v43, v44, v45);
      if (v36 >= v41) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = v36;
      }
      if (v36 <= v41) {
        uint64_t v48 = v41;
      }
      else {
        uint64_t v48 = v36;
      }
      uint64_t v49 = v48 + v47 * v27;
      if (!v33[v49])
      {
        v33[v49] = 1;
        ++v35;
      }
      if (v41 >= v46) {
        uint64_t v50 = v46;
      }
      else {
        uint64_t v50 = v41;
      }
      if (v41 <= v46) {
        uint64_t v51 = v46;
      }
      else {
        uint64_t v51 = v41;
      }
      uint64_t v52 = v51 + v50 * v27;
      if (!v33[v52])
      {
        v33[v52] = 1;
        ++v35;
      }
      if (v46 >= v36) {
        uint64_t v53 = v36;
      }
      else {
        uint64_t v53 = v46;
      }
      if (v46 <= v36) {
        uint64_t v54 = v36;
      }
      else {
        uint64_t v54 = v46;
      }
      uint64_t v55 = v54 + v53 * v27;
      if (!v33[v55])
      {
        v33[v55] = 1;
        ++v35;
      }
      ++v34;
    }
    while (v12 != v34);
    int8x16_t v10 = v68;
    v68[3] = v35;
    if (v35)
    {
      uint64_t v56 = (char *)malloc_type_malloc(16 * v35, 0x1000040451B5BE8uLL);
      *unint64_t v67 = v56;
      if (v28 < 1)
      {
        uint64_t v64 = 0;
      }
      else
      {
        uint64_t v63 = 0;
        uint64_t v64 = 0;
        do
        {
          if (v33[v63])
          {
            uint64_t v65 = (uint64_t *)&v56[16 * v64];
            *uint64_t v65 = v63 / v27;
            v65[1] = v63 + -v27 * (v63 / v27);
            ++v64;
          }
          ++v63;
        }
        while (v28 != v63);
      }
      if (v64 != v68[3]) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. memory smasher found in CFXEdgeArrayCreateFromMeshElement (%ld != %ld)", v57, v58, v59, v60, v61, v62, (uint64_t)"edgeCount == edges->_count");
      }
    }
  }
  free(v33);
  v10[4] = v10[3];
  return v10;
}

uint64_t sub_1B647E620(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"edges");
  }
  return *(void *)(a1 + 24);
}

uint64_t sub_1B647E66C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"edges");
  }
  if (*(void *)(a1 + 24) <= a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXEdgeArrayGetEdgeAtIndex index out of bounds", a3, a4, a5, a6, a7, a8, (uint64_t)"index < edges->_count");
  }
  return *(void *)(a1 + 16) + 16 * a2;
}

uint64_t sub_1B647E6E8(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

void *sub_1B647E718(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"element");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"vertices");
LABEL_3:
  if (qword_1E9DDAEB0 != -1) {
    dispatch_once_f(&qword_1E9DDAEB0, &qword_1E9DDAEA8, (dispatch_function_t)sub_1B647E6E8);
  }
  uint64_t v11 = (void *)sub_1B63C8D44(qword_1E9DDAEA8, 0x30uLL);
  size_t v19 = sub_1B641D8A0(a2, v12, v13, v14, v15, v16, v17, v18);
  if (a3) {
    int64_t v20 = *(void *)(a3 + 24);
  }
  else {
    int64_t v20 = 0;
  }
  uint64_t v21 = sub_1B63D11E8(a1);
  if (!v19) {
    return 0;
  }
  int64_t v22 = v21;
  v11[2] = malloc_type_calloc(8uLL, v19, 0xE4C4B12FuLL);
  void v11[5] = v19;
  v11[7] = v22;
  if (v22 >= 1)
  {
    for (uint64_t i = 0; i != v22; ++i)
    {
      for (uint64_t j = 0; j != 3; ++j)
      {
        uint64_t v29 = sub_1B63D14A0(a1, i, j, 0, v23, v24, v25, v26);
        uint64_t v30 = *(void *)(v11[2] + 8 * v29);
        if (!v30)
        {
          *(void *)(v11[2] + 8 * v29) = sub_1B649185C();
          uint64_t v30 = *(void *)(v11[2] + 8 * v29);
        }
        sub_1B6492824(v30, i);
      }
    }
  }
  if (v20)
  {
    v11[3] = malloc_type_calloc(8uLL, v20, 0xC800F8E9uLL);
    v11[6] = v20;
    v11[4] = malloc_type_calloc(0x18uLL, v22, 0xDED69EC2uLL);
    uint64_t v37 = malloc_type_calloc(1uLL, v22, 0xBE71C7ACuLL);
    if (v20 >= 1)
    {
      for (uint64_t k = 0; k != v20; ++k)
      {
        uint64_t v39 = (void *)sub_1B647E66C(a3, k, v31, v32, v33, v34, v35, v36);
        uint64_t v40 = sub_1B6492834(*(void *)(v11[2] + 8 * *v39), *(void *)(v11[2] + 8 * v39[1]));
        *(void *)(v11[3] + 8 * k) = v40;
        uint64_t v41 = sub_1B64918B0(v40);
        if (v41 != -1)
        {
          for (uint64_t m = v41; m != -1; uint64_t m = sub_1B6491924(v40, m))
          {
            unsigned int v43 = v37[m];
            if (v43 >= 3)
            {
              sub_1B63F2F54(17, @"Assertion '%s' failed. CFXTriangulationInfoCreateFromMeshElement - edge out of bounds", v31, v32, v33, v34, v35, v36, (uint64_t)"edgeIndexesPerFaceCounter[j] <= 2");
              unsigned int v43 = v37[m];
            }
            uint64_t v44 = v11[4] + 24 * m;
            v37[m] = v43 + 1;
            *(void *)(v44 + 8 * v43) = k;
          }
        }
      }
    }
    free(v37);
  }
  return v11;
}

uint64_t sub_1B647E9C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"info");
  }
  return *(void *)(a1 + 32) + 24 * a2;
}

void sub_1B647EA24(uint64_t a1)
{
  long long v1 = *(void **)(a1 + 16);
  if (v1) {
    free(v1);
  }
}

CFStringRef sub_1B647EA34()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFXEdgeArray>");
}

CFStringRef sub_1B647EA50()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFXEdgeArray>");
}

void sub_1B647EA70(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(const void **)(a1[3] + 8 * i);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(a1[3] + 8 * i) = 0;
        uint64_t v2 = a1[6];
      }
    }
  }
  uint64_t v5 = a1[5];
  if (v5 >= 1)
  {
    for (uint64_t j = 0; j < v5; ++j)
    {
      uint64_t v7 = *(const void **)(a1[2] + 8 * j);
      if (v7)
      {
        CFRelease(v7);
        *(void *)(a1[2] + 8 * j) = 0;
        uint64_t v5 = a1[5];
      }
    }
  }
  uint64_t v8 = (void *)a1[3];
  if (v8) {
    free(v8);
  }
  uint64_t v9 = (void *)a1[2];
  if (v9) {
    free(v9);
  }
  int8x16_t v10 = (void *)a1[4];
  if (v10)
  {
    free(v10);
  }
}

CFStringRef sub_1B647EB3C()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFXTriangulationInfo>");
}

CFStringRef sub_1B647EB58()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFXTriangulationInfo>");
}

uint64_t sub_1B647EB74(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B647EBA4()
{
  if (qword_1E9DDAEC0 != -1) {
    dispatch_once_f(&qword_1E9DDAEC0, &qword_1E9DDAEB8, (dispatch_function_t)sub_1B647EB74);
  }
  uint64_t v6 = sub_1B63C8D44(qword_1E9DDAEB8, 0x28uLL);
  if (!v6) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v0, v1, v2, v3, v4, v5, (uint64_t)"MeshElementEditor");
  }
  return v6;
}

uint64_t sub_1B647EC38(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"element");
  }
  if (sub_1B63D0C08((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8))
  {
    sub_1B63F2F54(16, @"Error: CFXMeshElementEditorCreateWithMeshElement: mesh element is not a triangle array", v10, v11, v12, v13, v14, v15, v19);
    return 0;
  }
  else
  {
    uint64_t v16 = sub_1B647EBA4();
    CFDataRef v17 = (const __CFData *)sub_1B63D0F38((uint64_t)a1, (_DWORD *)(v16 + 40));
    *(void *)(v16 + 16) = CFRetain(a1);
    *(void *)(v16 + 48) = sub_1B63D11E8((uint64_t)a1);
    *(void *)(v16 + 32) = CFDataCreateMutableCopy(0, 3 * a2 * *(unsigned int *)(v16 + 40), v17);
  }
  return v16;
}

uint64_t sub_1B647ED00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 32));
  uint64_t v13 = *(unsigned int *)(a1 + 40);
  uint64_t v14 = (3 * a2 + a3) * v13;
  switch(v13)
  {
    case 4:
      return *(unsigned int *)&MutableBytePtr[v14];
    case 2:
      return *(unsigned __int16 *)&MutableBytePtr[v14];
    case 1:
      return (char)MutableBytePtr[v14];
  }
  sub_1B63F2F54(16, @"Error: _CFXMeshElementEditorSetIndex unknown bytes per index", v7, v8, v9, v10, v11, v12, v16);
  return -1;
}

void sub_1B647ED8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 32));
  uint64_t v20 = *(unsigned int *)(a1 + 40);
  int v21 = v20 - 1;
  uint64_t v22 = (3 * a2 + a3) * v20;
  switch(v21)
  {
    case 0:
      MutableBytePtr[v22] = a4;
      break;
    case 1:
      *(_WORD *)&MutableBytePtr[v22] = a4;
      break;
    case 3:
      *(_DWORD *)&MutableBytePtr[v22] = a4;
      break;
    case 7:
      *(void *)&MutableBytePtr[v22] = a4;
      break;
    default:
      sub_1B63F2F54(16, @"Error: _CFXMeshElementEditorSetIndex unknown bytes per index", v14, v15, v16, v17, v18, v19, a9);
      break;
  }
}

void sub_1B647EE6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"editor");
  }
  uint64_t v14 = *(const void **)(a1 + 24);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 24) = 0;
  }
  if (*(void *)(a1 + 48) >= a2)
  {
    uint64_t v15 = sub_1B647ED00(a1, a2, 1);
    uint64_t v16 = sub_1B647ED00(a1, a2, 2);
    uint64_t v17 = *(void *)(a1 + 48);
    CFDataRef v18 = *(const __CFData **)(a1 + 32);
    CFIndex Length = CFDataGetLength(v18);
    CFDataSetLength(v18, Length + (9 * *(_DWORD *)(a1 + 40)));
    sub_1B647ED8C(a1, a2, 1, a4, v20, v21, v22, v23, v64);
    sub_1B647ED8C(a1, a2, 2, a3, v24, v25, v26, v27, v65);
    sub_1B647ED8C(a1, v17, 0, a3, v28, v29, v30, v31, v66);
    sub_1B647ED8C(a1, v17, 1, a5, v32, v33, v34, v35, v67);
    sub_1B647ED8C(a1, v17, 2, v16, v36, v37, v38, v39, v68);
    sub_1B647ED8C(a1, v17 + 1, 0, a3, v40, v41, v42, v43, v69);
    sub_1B647ED8C(a1, v17 + 1, 1, a4, v44, v45, v46, v47, v70);
    sub_1B647ED8C(a1, v17 + 1, 2, a5, v48, v49, v50, v51, v71);
    sub_1B647ED8C(a1, v17 + 2, 0, a4, v52, v53, v54, v55, v72);
    sub_1B647ED8C(a1, v17 + 2, 1, v15, v56, v57, v58, v59, v73);
    sub_1B647ED8C(a1, v17 + 2, 2, a5, v60, v61, v62, v63, v74);
    *(void *)(a1 + 48) += 3;
  }
  else
  {
    sub_1B63F2F54(16, @"Error: CFXMeshElementEditorSubdivideTriangleAtIndex: triangleIndex out of bounds", a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1B647F078(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"editor");
  }
  uint64_t v9 = *(void *)(a1 + 24);
  if (!v9)
  {
    uint64_t v9 = sub_1B63D0314();
    char v17 = sub_1B63D0C54(*(void *)(a1 + 16), v10, v11, v12, v13, v14, v15, v16);
    sub_1B63D0D7C(v9, v17, v18, v19, v20, v21, v22, v23);
    CFDataRef Copy = CFDataCreateCopy(0, *(CFDataRef *)(a1 + 32));
    sub_1B63D05D4(v9, 0, *(void *)(a1 + 48), Copy, *(unsigned int *)(a1 + 40), v25, v26, v27);
    CFRelease(Copy);
    *(void *)(a1 + 24) = v9;
  }
  return v9;
}

void sub_1B647F128(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
}

CFStringRef sub_1B647F178()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFXMeshElementEditor>");
}

CFStringRef sub_1B647F194()
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFXMeshElementEditor>");
}

double sub_1B647F1B0(uint64_t a1)
{
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(unsigned char *)(a1 + 133) = 1;
  *(void *)&double result = 83951873;
  *(_DWORD *)(a1 + 129) = 83951873;
  return result;
}

void sub_1B647F1D4(void *a1)
{
  sub_1B65A2BA0((uint64_t)a1);
  sub_1B656D4E8((uint64_t)a1);
  uint64_t v2 = (const void *)a1[19];
  if (v2)
  {
    CFRelease(v2);
    a1[19] = 0;
  }
  uint64_t v3 = (const void *)a1[18];
  if (v3)
  {
    CFRelease(v3);
    a1[18] = 0;
  }
  uint64_t v4 = (const void *)a1[17];
  if (v4)
  {
    CFRelease(v4);
    a1[17] = 0;
  }
}

CFTypeRef sub_1B647F230(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 133) = *(unsigned char *)(a1 + 133);
  *(_DWORD *)(a2 + 128) = *(_DWORD *)(a1 + 128);
  *(unsigned char *)(a2 + 132) = *(unsigned char *)(a1 + 132);
  sub_1B65A2BA0(a2);
  sub_1B656D4E8(a2);
  uint64_t v4 = *(const void **)(a2 + 152);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 152) = 0;
  }
  CFTypeRef v5 = *(CFTypeRef *)(a2 + 144);
  CFTypeRef v6 = *(CFTypeRef *)(a1 + 144);
  if (v5 != v6)
  {
    if (v5)
    {
      CFRelease(*(CFTypeRef *)(a2 + 144));
      *(void *)(a2 + 144) = 0;
      CFTypeRef v6 = *(CFTypeRef *)(a1 + 144);
    }
    if (v6) {
      CFTypeRef v6 = CFRetain(v6);
    }
    *(void *)(a2 + 144) = v6;
  }
  CFTypeRef v7 = *(CFTypeRef *)(a2 + 136);
  CFTypeRef result = *(CFTypeRef *)(a1 + 136);
  if (v7 != result)
  {
    if (v7)
    {
      CFRelease(*(CFTypeRef *)(a2 + 136));
      *(void *)(a2 + 136) = 0;
      CFTypeRef result = *(CFTypeRef *)(a1 + 136);
    }
    if (result) {
      CFTypeRef result = CFRetain(result);
    }
    *(void *)(a2 + 136) = result;
  }
  return result;
}

BOOL sub_1B647F2EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *(unsigned char *)(a1 + 200);
  int v9 = v8 & 0xC;
  if ((v8 & 0xC) == 0)
  {
    uint64_t v11 = sub_1B63CCE68(a1, a2, a3, a4, a5, a6, a7, a8);
    CFArrayRef v18 = (const __CFArray *)sub_1B64AD3C4(v11, 0, v12, v13, v14, v15, v16, v17);
    CFIndex Count = CFArrayGetCount(v18);
    if (Count < 1)
    {
LABEL_6:
      int v9 = 4;
    }
    else
    {
      CFIndex v20 = Count;
      CFIndex v21 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v18, v21);
        char v30 = sub_1B63D0C08((uint64_t)ValueAtIndex, v23, v24, v25, v26, v27, v28, v29);
        if (!sub_1B63D0E64(v30)) {
          break;
        }
        if (v20 == ++v21) {
          goto LABEL_6;
        }
      }
      int v9 = 8;
    }
    *(unsigned char *)(a1 + 200) = v9 | v8 & 0xF3;
  }
  return v9 == 4;
}

BOOL sub_1B647F390(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 176) != 4 && sub_1B647F2EC(a1, a2, a3, a4, a5, a6, a7, a8);
}

BOOL sub_1B647F3B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *(unsigned char *)(a1 + 128) && *(unsigned char *)(a1 + 176) == 4 && sub_1B647F2EC(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B647F3D0(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a1[8].n128_u8[0];
  if (v10 != a2)
  {
    a1[8].n128_u8[0] = a2;
    uint64_t v11 = (const void *)a1[9].n128_u64[1];
    if (v11)
    {
      CFRelease(v11);
      a1[9].n128_u64[1] = 0;
    }
    sub_1B63CCBEC((uint64_t)a1);
  }
  uint64_t v12 = a1[11].n128_u8[0];

  sub_1B647F448(a1, v12, v12, v10, a2, a6, a7, a8);
}

void sub_1B647F448(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v9 = a4;
  int v10 = a3;
  int v11 = a2;
  if ((sub_1B65A2AB0(a1, a2, a3, a4, a5, a6, a7, a8) & 1) == 0
    && (v10 == 4 ? (BOOL v20 = v8 == 0) : (BOOL v20 = 1),
        v20 ? (int v21 = 0) : (int v21 = 1),
        v11 == 4 ? (BOOL v22 = v9 == 0) : (BOOL v22 = 1),
        v22 ? (int v23 = 0) : (int v23 = 1),
        v23 == v21))
  {
    if ((v11 == 0) != (v10 != 0)) {
      return;
    }
    uint64_t v24 = 6;
  }
  else
  {
    uint64_t v24 = 7;
  }
  uint64_t v25 = sub_1B63F4F54(a1, v13, v14, v15, v16, v17, v18, v19);

  sub_1B64B1F18(v25, v24, a1, 0, v26, v27, v28, v29);
}

uint64_t sub_1B647F50C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 129);
}

void sub_1B647F514(__n128 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[8].n128_u8[1] != a2)
  {
    a1[8].n128_u8[1] = a2;
    int v9 = (const void *)a1[9].n128_u64[1];
    if (v9)
    {
      CFRelease(v9);
      a1[9].n128_u64[1] = 0;
    }
    sub_1B63CCBEC((uint64_t)a1);
  }
  uint64_t v10 = a1[11].n128_u8[0];
  uint64_t v11 = a1[8].n128_u8[0];

  sub_1B647F448(a1, v10, v10, v11, v11, a6, a7, a8);
}

uint64_t sub_1B647F580(uint64_t a1)
{
  return *(unsigned int *)(a1 + 130);
}

void sub_1B647F588(uint64_t a1, int a2)
{
  if (a2 != *(_DWORD *)(a1 + 130))
  {
    *(_DWORD *)(a1 + 130) = a2;
    uint64_t v3 = *(const void **)(a1 + 152);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 152) = 0;
    }
    sub_1B63CCBEC(a1);
    uint64_t v7 = *(unsigned __int8 *)(a1 + 176);
    uint64_t v8 = *(unsigned __int8 *)(a1 + 128);
    sub_1B647F448((__n128 *)a1, v7, v7, v8, v8, v4, v5, v6);
  }
}

void sub_1B647F610(__n128 *a1, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)a1[9].n128_u64[0];
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      a1[9].n128_u64[0] = 0;
    }
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    a1[9].n128_u64[0] = (unint64_t)v5;
    uint64_t v6 = (const void *)a1[9].n128_u64[1];
    if (v6)
    {
      CFRelease(v6);
      a1[9].n128_u64[1] = 0;
    }
    sub_1B63CCBEC((uint64_t)a1);
  }
  sub_1B656D494((uint64_t)a1);
  uint64_t v10 = a1[11].n128_u8[0];
  uint64_t v11 = a1[8].n128_u8[0];

  sub_1B647F448(a1, v10, v10, v11, v11, v7, v8, v9);
}

void sub_1B647F6A8(__n128 *a1, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)a1[8].n128_u64[1];
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      a1[8].n128_u64[1] = 0;
    }
    if (cf) {
      CFTypeRef v5 = CFRetain(cf);
    }
    else {
      CFTypeRef v5 = 0;
    }
    a1[8].n128_u64[1] = (unint64_t)v5;
    uint64_t v6 = (const void *)a1[9].n128_u64[1];
    if (v6)
    {
      CFRelease(v6);
      a1[9].n128_u64[1] = 0;
    }
    sub_1B63CCBEC((uint64_t)a1);
  }
  sub_1B656D494((uint64_t)a1);
  uint64_t v10 = a1[11].n128_u8[0];
  uint64_t v11 = a1[8].n128_u8[0];

  sub_1B647F448(a1, v10, v10, v11, v11, v7, v8, v9);
}

BOOL sub_1B647F740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *(unsigned char *)(a1 + 176) == 4 && *(unsigned char *)(a1 + 128) && sub_1B647F2EC(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B647F760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F0FB4740;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(void *)(a1 + 560) = 0;
  *(void *)(a1 + 600) = 0;
  *(_DWORD *)(a1 + 608) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(unsigned char *)(a1 + 592) = 0;
  *(void *)(a1 + 16) = a2;
  uint64_t v9 = sub_1B644558C(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 24) = v9;
  uint64_t v17 = sub_1B64B28FC(v9, v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 32) = v17;
  *(_WORD *)(a1 + 48) = 15;
  sub_1B6624920(v17, 0xFu);
  return a1;
}

void sub_1B647F838(_Unwind_Exception *a1)
{
  sub_1B644E78C(v4, 0);
  sub_1B6E306F8(v3, v2, v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B647F860(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB4740;
  sub_1B6624994(*(int16x4_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 48));
  sub_1B644E78C((CFX::RG::Resource **)(a1 + 600), 0);
  for (uint64_t i = 584; i != 568; i -= 8)
  {
    uint64_t v3 = *(void **)(a1 + i);
    if (v3) {
  }
    }
  uint64_t v4 = *(void **)(a1 + 560);
  if (v4) {

  }
  return a1;
}

void sub_1B647F8E0(_Unwind_Exception *a1)
{
  sub_1B644E78C((CFX::RG::Resource **)(v1 + 600), 0);
  sub_1B6E30764(v1 + 592, v1 + 576, v1);
  _Unwind_Resume(a1);
}

void sub_1B647F90C(uint64_t a1)
{
  sub_1B647F860(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B647F944(uint64_t a1, CFX::RG::RenderGraphContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 16), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = objc_msgSend_resourceManager(v11, v12, v13, v14);
  uint64_t v23 = sub_1B644558C(*(void *)(a1 + 16), v16, v17, v18, v19, v20, v21, v22);
  uint64_t v31 = sub_1B6446564(*(uint64_t **)(a1 + 16), v24, v25, v26, v27, v28, v29, v30);
  if (v31 && sub_1B64A3B48((uint64_t)v31, v32, v33, v34, v35, v36, v37, v38))
  {
    BOOL v39 = sub_1B64B2810(v23, 0) != 0;
    BOOL v94 = v39;
    unsigned int v93 = sub_1B6626FAC(*(void *)(a1 + 32));
    BOOL v40 = sub_1B6626FBC(*(void *)(a1 + 32)) != 0;
    unsigned int v91 = *(_DWORD *)(a3 + 172);
    BOOL v92 = v40;
    unint64_t v41 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v93) ^ ((0x9DDFEA08EB382D69 * v93) >> 47));
    unint64_t v42 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ v40)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47))) ^ v40)));
    unint64_t v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    unint64_t v44 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) ^ ((0x9DDFEA08EB382D69 * (v43 ^ ((0x9DDFEA08EB382D69 * (v43 ^ v39)) >> 47) ^ (0x9DDFEA08EB382D69 * (v43 ^ v39)))) >> 47));
    unint64_t v45 = 0x9DDFEA08EB382D69
        * (v44 ^ ((0x9DDFEA08EB382D69 * (v44 ^ v91)) >> 47) ^ (0x9DDFEA08EB382D69 * (v44 ^ v91)));
    unint64_t v46 = 0x9DDFEA08EB382D69 * (v45 ^ (v45 >> 47));
    if (*(void *)(a1 + 552) != v46)
    {
      *(void *)(a1 + 552) = v46;
      sub_1B6626AF8(*(void *)(a1 + 32), *(void *)(a1 + 16));
      id v47 = objc_alloc_init(MEMORY[0x1E4F35228]);
      objc_msgSend_setConstantValue_type_withName_(v47, v48, (uint64_t)&v93, 33, @"LightCount");
      objc_msgSend_setConstantValue_type_withName_(v47, v49, (uint64_t)&v94, 53, @"has_IBL");
      objc_msgSend_setConstantValue_type_withName_(v47, v50, (uint64_t)&v92, 33, @"raytracing_use_function_constant");
      objc_msgSend_setConstantValue_type_withName_(v47, v51, (uint64_t)&v91, 33, @"quality_mode");
      uint64_t v52 = sub_1B6626EDC(*(void *)(a1 + 32));
      uint64_t v54 = objc_msgSend_newComputePipelineStateWithFunctionName_constantValues_linkedFunctions_(v15, v53, @"vfx_rt_indirect_diffuse_trace", (uint64_t)v47, v52);

      uint64_t v55 = *(void **)(a1 + 560);
      if (v55 != (void *)v54)
      {
        if (v55) {

        }
        *(void *)(a1 + 560) = v54;
      }
      *(_DWORD *)(a1 + 460) = 0;
      sub_1B6626E64(*(void *)(a1 + 32));
    }
    uint64_t v56 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, *(const CFX::RG::Resource **)(a3 + 240));
    uint64_t v60 = *v56;
    uint64_t v61 = v56[1];
    unint64_t v62 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v60) ^ ((0x9DDFEA08EB382D69 * v60) >> 47));
    unint64_t v63 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                          * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47))) ^ v61)));
    unint64_t v64 = 0x9DDFEA08EB382D69 * (v63 ^ (v63 >> 47));
    if (*(void *)(a1 + 568) != v64)
    {
      *(void *)(a1 + 568) = v64;
      unsigned int v65 = v60 >> 1;
      unsigned int v66 = v61 >> 1;
      unsigned int v67 = (v61 >> 1) * (v60 >> 1);
      uint64_t v68 = objc_msgSend_device(v11, v57, v58, v59);
      uint64_t v69 = 96 * v67;
      uint64_t v71 = objc_msgSend_newBufferWithLength_options_(v68, v70, v69, 32);
      uint64_t v75 = *(void **)(a1 + 576);
      if (v75 != (void *)v71)
      {
        uint64_t v76 = v71;
        if (v75) {

        }
        *(void *)(a1 + 576) = v76;
      }
      int v77 = objc_msgSend_device(v11, v72, v73, v74);
      uint64_t v79 = objc_msgSend_newBufferWithLength_options_(v77, v78, v69, 32);
      CATransform3D v80 = *(void **)(a1 + 584);
      if (v80 != (void *)v79)
      {
        uint64_t v81 = v79;
        if (v80) {

        }
        *(void *)(a1 + 584) = v81;
      }
      *(_DWORD *)(a1 + 460) = 0;
      long long v89 = 0u;
      long long v90 = 0u;
      long long v87 = 0u;
      long long v88 = 0u;
      long long v86 = 0u;
      if (v65 <= 1) {
        __int16 v82 = 1;
      }
      else {
        __int16 v82 = v65;
      }
      if (v66 <= 1) {
        __int16 v83 = 1;
      }
      else {
        __int16 v83 = v66;
      }
      RGTextureDescriptorMake2D(v82, v83, 25, (uint64_t)&v86);
      CFX::RG::RenderGraphContext::currentBuilder(a2);
      v85[2] = v88;
      _OWORD v85[3] = v89;
      v85[4] = v90;
      v85[0] = v86;
      v85[1] = v87;
      int v96 = "distanceTex";
      char v95 = 2;
      sub_1B6458BE8((uint64_t *)&v96, (uint64_t)v85, &v95);
      sub_1B644E78C((CFX::RG::Resource **)(a1 + 600), v84);
    }
    *(unsigned char *)(a1 + 592) ^= 1u;
  }
}

uint64_t *sub_1B647FCAC(uint64_t *a1, uint64_t a2, uint64_t a3, CFX::RG::RenderGraphContext *a4, uint64_t a5)
{
  uint64_t v8 = *(void *)a5;
  v34[0] = (uint64_t)"RTIndirectDiffuseTracePass";
  v34[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAED0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v33 = a3;
    uint64_t v31 = a2;
    int v32 = __cxa_guard_acquire(&qword_1E9DDAED0);
    a2 = v31;
    a3 = v33;
    if (v32)
    {
      byte_1E9DDAEC8 = 1;
      __cxa_guard_release(&qword_1E9DDAED0);
      a2 = v31;
      a3 = v33;
    }
  }
  if (byte_1E9DDAEC8) {
    uint64_t v9 = 0xA1BA6B715A2CCB31;
  }
  else {
    uint64_t v9 = 0;
  }
  sub_1B653860C((uint64_t)a1, a2, a3, v34, v9, 0);
  *a1 = (uint64_t)&unk_1F0FB4760;
  a1[47] = a5;
  a1[48] = 0;
  a1[49] = 0;
  a1[50] = 0;
  uint64_t v17 = (void *)sub_1B6445900(a1[46], v10, v11, v12, v13, v14, v15, v16);
  a1[49] = (uint64_t)v17;
  a1[50] = objc_msgSend_resourceManager(v17, v18, v19, v20);
  uint64_t v21 = (CFX::CrossFrameResourceManager *)*((void *)a4 + 4);
  unint64_t v22 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v23 = CFX::CrossFrameResourceManager::get(v21, v22);
  a1[48] = v23;
  if (!v23)
  {
    CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
    v34[0] = a1[46];
    sub_1B647FE94();
  }
  sub_1B647F944(v23, a4, a1[47], v24, v25, v26, v27, v28);
  uint64_t v29 = a1[48];
  *(void *)(a1[47] + 312) = v29 + 64;
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(v29 + 600));
  CFX::RG::Pass::writeTo(a1, *(CFX::RG::Resource **)(a1[48] + 600));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a1[47] + 256));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a5 + 240));
  CFX::RG::Pass::readFrom(a1, *(CFX::RG::Resource **)(a5 + 176));
  return a1;
}

void sub_1B647FE7C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B647FE94()
{
}

void sub_1B647FEFC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A1C4028DC6F4DLL);
  _Unwind_Resume(a1);
}

void sub_1B647FF24(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)(a1 + 384) + 560))
  {
    uint64_t v10 = *a3;
    uint64_t v11 = sub_1B644558C(*(void *)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    uint64_t v19 = sub_1B6446564(*(uint64_t **)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      if (sub_1B64A3B48((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26))
      {
        uint64_t v34 = sub_1B6446564(*(uint64_t **)(a1 + 368), v27, v28, v29, v30, v31, v32, v33);
        sub_1B63E0460((uint64_t)v34, (uint64_t)v181, v35, v36, v37, v38, v39, v40);
        unint64_t v41 = (long long *)sub_1B6447988(*(void *)(a1 + 368), 1);
        long long v175 = v41[1];
        long long v176 = *v41;
        long long v173 = v41[3];
        long long v174 = v41[2];
        __n128 v180 = sub_1B64471F4(*(void *)(a1 + 368), 0, v42, v43, v44, v45, v46, v47);
        uint64_t v55 = sub_1B64B28FC(v11, v48, v49, v50, v51, v52, v53, v54);
        sub_1B6626AF8(v55, *(void *)(a1 + 368));
        id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 248));
        id v57 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 240));
        id v58 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 264));
        id v59 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 176));
        id v60 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 256));
        id v61 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 384) + 600));
        objc_msgSend_setTexture_atIndex_(v10, v62, (uint64_t)Texture, 0);
        uint64_t v177 = v57;
        objc_msgSend_setTexture_atIndex_(v10, v63, (uint64_t)v57, 1);
        objc_msgSend_setTexture_atIndex_(v10, v64, (uint64_t)v58, 2);
        objc_msgSend_setTexture_atIndex_(v10, v65, (uint64_t)v59, 3);
        objc_msgSend_setTexture_atIndex_(v10, v66, (uint64_t)v60, 4);
        objc_msgSend_setTexture_atIndex_(v10, v67, (uint64_t)v61, 5);
        uint64_t v68 = sub_1B64B2810(v11, 0);
        if (v68)
        {
          uint64_t v72 = objc_msgSend_textureForMaterialProperty_(*(void **)(a1 + 392), v69, v68, v71);
          if (v72) {
            objc_msgSend_setTexture_atIndex_(v10, v73, v72, 6);
          }
        }
        float32x2_t v178 = sub_1B6447FE4(**(float32x2_t ***)(a1 + 376), 0, v70, v71);
        uint64_t v74 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        v74[4] = v176;
        v74[5] = v175;
        v74[6] = v174;
        v74[7] = v173;
        uint64_t v81 = sub_1B649CD50(v181, (uint64_t)&v180, v75, v76, v77, v78, v79, v80);
        uint64_t v82 = 0;
        long long v83 = *((_OWORD *)v81 + 1);
        long long v84 = *((_OWORD *)v81 + 2);
        long long v85 = *((_OWORD *)v81 + 3);
        long long v86 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        v86[12] = *(_OWORD *)v81;
        v86[13] = v83;
        v86[14] = v84;
        v86[15] = v85;
        long long v87 = *(float32x4_t **)(a1 + 384);
        float32x4_t v88 = v87[16];
        float32x4_t v89 = v87[17];
        float32x4_t v90 = v87[18];
        float32x4_t v91 = v87[19];
        float32x4_t v92 = v87[9];
        float32x4_t v93 = v87[10];
        float32x4_t v94 = v87[11];
        v182[0] = v87[8];
        v182[1] = v92;
        v182[2] = v93;
        v182[3] = v94;
        do
        {
          v183[v82] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v88, COERCE_FLOAT(*(_OWORD *)&v182[v82])), v89, *(float32x2_t *)v182[v82].f32, 1), v90, v182[v82], 2), v91, v182[v82], 3);
          ++v82;
        }
        while (v82 != 4);
        long long v95 = v183[1];
        long long v96 = v183[2];
        long long v97 = v183[3];
        long long v98 = *(_OWORD **)(*(void *)(a1 + 376) + 312);
        *long long v98 = v183[0];
        v98[1] = v95;
        v98[2] = v96;
        v98[3] = v97;
        *(simd_float4x4 *)(*(void *)(*(void *)(a1 + 376) + 312) + 128) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 384) + 128));
        *(simd_float4x4 *)(*(void *)(*(void *)(a1 + 376) + 312) + 256) = __invert_f4(*(simd_float4x4 *)(*(void *)(a1 + 384) + 64));
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 384) = (float)((float)(unint64_t)objc_msgSend_width(Texture, v99, v100, v101)
                                                                               * v178.f32[0])
                                                                       * 0.5;
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 388) = vmuls_lane_f32((float)(unint64_t)objc_msgSend_height(Texture, v102, v103, v104), v178, 1)* 0.5;
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 400) = *(_OWORD *)(*(void *)(a1 + 376) + 208);
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 416) = *(_OWORD *)(*(void *)(a1 + 376) + 224);
        *(_OWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 448) = *(_OWORD *)(*(void *)(a1 + 376) + 192);
        uint64_t v105 = *(void *)(a1 + 376);
        uint64_t v106 = *(void *)(v105 + 312);
        *(float *)(v106 + 432) = (float)*(int *)(v105 + 184);
        objc_msgSend_setBytes_length_atIndex_(v10, v107, v106, 480, 8);
        uint64_t v108 = sub_1B64B2810(v11, 0);
        if (v108) {
          float v116 = sub_1B64763AC(v108, (uint64_t)v109, v110, v111, v112, v113, v114, v115);
        }
        else {
          float v116 = 0.0;
        }
        *(float *)(*(void *)(*(void *)(a1 + 376) + 312) + 464) = v116;
        objc_msgSend_setTexture_atIndex_(v10, v109, *(void *)(*(void *)(a1 + 384) + 544), 9);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v117, *(void *)(*(void *)(a1 + 384) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 592) + 576), 0, 10);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v118, *(void *)(*(void *)(a1 + 384) + 8 * (*(unsigned char *)(*(void *)(a1 + 384) + 592) == 0) + 576), 0, 11);
        uint64_t v119 = sub_1B6626EB4(v55);
        objc_msgSend_useHeap_(v10, v120, v119, v121);
        uint64_t v122 = sub_1B6626EC4(v55);
        objc_msgSend_setBuffer_offset_atIndex_(v10, v123, v122, 0, 0);
        uint64_t v124 = sub_1B6626EBC(v55);
        objc_msgSend_setAccelerationStructure_atBufferIndex_(v10, v125, v124, 1);
        if (sub_1B6626FAC(v55))
        {
          uint64_t v126 = sub_1B6626ECC(v55);
          objc_msgSend_setBuffer_offset_atIndex_(v10, v127, v126, 0, 2);
        }
        if (sub_1B6626FBC(v55))
        {
          uint64_t v134 = *(void *)(a1 + 384);
          uint64_t v135 = *(void *)(v134 + 560);
          if (!v135)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v128, v129, v130, v131, v132, v133, (uint64_t)"_ptr != NULL");
            uint64_t v135 = *(void *)(v134 + 560);
          }
          uint64_t v136 = (void *)sub_1B653EFB8(v135);
          float32x4_t v137 = sub_1B6626EE4(v55, v136);
          objc_msgSend_setIntersectionFunctionTable_atBufferIndex_(v10, v138, (uint64_t)v137, 3);
        }
        else
        {
          float32x4_t v137 = 0;
        }
        uint64_t v139 = sub_1B6626ED4(v55);
        unsigned int v143 = sub_1B6626FCC(v55, v140, v141, v142);
        objc_msgSend_useResources_count_usage_(v10, v144, v139, v143, 1);
        uint64_t v151 = *(void *)(a1 + 384);
        uint64_t v152 = *(void *)(v151 + 560);
        if (!v152)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v145, v146, v147, v148, v149, v150, (uint64_t)"_ptr != NULL");
          uint64_t v152 = *(void *)(v151 + 560);
        }
        uint64_t v153 = sub_1B653EFB8(v152);
        objc_msgSend_setComputePipelineState_(v10, v154, v153, v155);
        unint64_t v159 = (unint64_t)objc_msgSend_width(v177, v156, v157, v158) >> 1;
        unint64_t v169 = (unint64_t)objc_msgSend_height(v177, v160, v161, v162) >> 1;
        uint64_t v170 = *(void *)(a1 + 384);
        uint64_t v171 = *(void *)(v170 + 560);
        if (!v171)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v163, v164, v165, v166, v167, v168, (uint64_t)"_ptr != NULL");
          uint64_t v171 = *(void *)(v170 + 560);
        }
        long long v172 = (void *)sub_1B653EFB8(v171);
        v179[0] = v159;
        v179[1] = v169;
        v179[2] = 1;
        RGMTLComputeCommandEncoderDispatchOnGrid2D(v10, v172, (uint64_t)v179, 1);

        sub_1B6626E64(v55);
      }
    }
  }
}

uint64_t sub_1B64804E8(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  uint64_t v33 = "RTIndirectDiffuseSpatialReSTIRPass";
  uint64_t v34 = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAEE0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v30 = a3;
    uint64_t v31 = a2;
    int v32 = __cxa_guard_acquire(&qword_1E9DDAEE0);
    a2 = v31;
    a3 = v30;
    if (v32)
    {
      qword_1E9DDAED8 = (uint64_t)sub_1B6481CFC("RT_INDIRECT_DIFFUSE_SPATIAL_RESTIR", 0x22u);
      __cxa_guard_release(&qword_1E9DDAEE0);
      a2 = v31;
      a3 = v30;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)&v33, qword_1E9DDAED8, 0);
  *(void *)a1 = &unk_1F0FB4F40;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  uint64_t v9 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[30]);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  uint64_t v19 = (void *)sub_1B6445900(*(void *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
  *(void *)(a1 + 400) = v19;
  *(void *)(a1 + 408) = objc_msgSend_resourceManager(v19, v20, v21, v22, v33, v34);
  unint64_t v23 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v24 = CFX::CrossFrameResourceManager::get(a4[4], v23);
  *(void *)(a1 + 384) = v24;
  if (!v24) {
    operator new();
  }
  unint64_t v25 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v26 = 0x9DDFEA08EB382D69
      * (v25 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v10)));
  unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  uint64_t v28 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v27 ^ ((0x9DDFEA08EB382D69 * (v27 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v27 ^ v11)))) ^ ((0x9DDFEA08EB382D69 * (v27 ^ ((0x9DDFEA08EB382D69 * (v27 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v27 ^ v11)))) >> 47)));
  *(void *)(a1 + 392) = v28;
  if (!v28) {
    operator new();
  }
  return a1;
}

void sub_1B648086C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6480894(uint64_t result, uint64_t a2, void **a3)
{
  uint64_t v3 = *(void *)(result + 384);
  if (*(void *)(v3 + 16) && *(void *)(v3 + 24))
  {
    CFTypeRef v5 = (void *)result;
    uint64_t v6 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(result + 376) + 312), 480, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v5[47] + 248));
    id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v5[47] + 240));
    id v9 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v5[47] + 288));
    objc_msgSend_setTexture_atIndex_(v6, v10, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v6, v11, (uint64_t)v8, 1);
    objc_msgSend_setTexture_atIndex_(v6, v12, (uint64_t)v9, 2);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v13, *(void *)(v5[47] + 296), 0, 0);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v14, *(void *)(v5[49] + 16), 0, 1);
    uint64_t v21 = v5[48];
    uint64_t v22 = *(void *)(v21 + 16);
    if (!v22)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v15, v16, v17, v18, v19, v20, (uint64_t)"_ptr != NULL");
      uint64_t v22 = *(void *)(v21 + 16);
    }
    uint64_t v23 = sub_1B653EFB8(v22);
    objc_msgSend_setComputePipelineState_(v6, v24, v23, v25);
    unint64_t v29 = (unint64_t)objc_msgSend_width(v8, v26, v27, v28) >> 1;
    unint64_t v39 = (unint64_t)objc_msgSend_height(v8, v30, v31, v32) >> 1;
    uint64_t v40 = v5[48];
    uint64_t v41 = *(void *)(v40 + 16);
    if (!v41)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v33, v34, v35, v36, v37, v38, (uint64_t)"_ptr != NULL");
      uint64_t v41 = *(void *)(v40 + 16);
    }
    uint64_t v42 = (void *)sub_1B653EFB8(v41);
    v66[0] = v29;
    v66[1] = v39;
    void v66[2] = 1;
    RGMTLComputeCommandEncoderDispatchOnGrid2D(v6, v42, (uint64_t)v66, 1);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v43, *(void *)(v5[49] + 16), 0, 0);
    objc_msgSend_setBuffer_offset_atIndex_(v6, v44, *(void *)(v5[49] + 24), 0, 1);
    uint64_t v51 = v5[48];
    uint64_t v52 = *(void *)(v51 + 24);
    if (!v52)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v45, v46, v47, v48, v49, v50, (uint64_t)"_ptr != NULL");
      uint64_t v52 = *(void *)(v51 + 24);
    }
    uint64_t v53 = sub_1B653EFB8(v52);
    objc_msgSend_setComputePipelineState_(v6, v54, v53, v55);
    uint64_t v62 = v5[48];
    uint64_t v63 = *(void *)(v62 + 24);
    if (!v63)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v56, v57, v58, v59, v60, v61, (uint64_t)"_ptr != NULL");
      uint64_t v63 = *(void *)(v62 + 24);
    }
    unint64_t v64 = (void *)sub_1B653EFB8(v63);
    v65[0] = v29;
    v65[1] = v39;
    v65[2] = 1;
    return RGMTLComputeCommandEncoderDispatchOnGrid2D(v6, v64, (uint64_t)v65, 1);
  }
  return result;
}

uint64_t sub_1B6480AFC(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v8 = *a5;
  v46[0] = (uint64_t)"RTIndirectDiffuseUpscalePass";
  v46[1] = v8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAEF0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v43 = a2;
    uint64_t v44 = a3;
    int v42 = __cxa_guard_acquire(&qword_1E9DDAEF0);
    a2 = v43;
    a3 = v44;
    if (v42)
    {
      qword_1E9DDAEE8 = (uint64_t)sub_1B6481CFC("RT_INDIRECT_DIFFUSE_UPSCALE", 0x1Bu);
      __cxa_guard_release(&qword_1E9DDAEF0);
      a2 = v43;
      a3 = v44;
    }
  }
  sub_1B653860C(a1, a2, a3, v46, qword_1E9DDAEE8, 0);
  *(void *)a1 = &unk_1F0FB4B40;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  uint64_t v16 = (void *)sub_1B6445900(*(void *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
  *(void *)(a1 + 400) = v16;
  *(void *)(a1 + 408) = objc_msgSend_resourceManager(v16, v17, v18, v19);
  unint64_t v20 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v21 = CFX::CrossFrameResourceManager::get(a4[4], v20);
  *(void *)(a1 + 384) = v21;
  if (!v21)
  {
    *(void *)(a1 + 384) = sub_1B6480CBC(a4[4], v20);
    unint64_t v29 = (void *)sub_1B6445900(*(void *)(a1 + 368), v22, v23, v24, v25, v26, v27, v28);
    uint64_t v33 = objc_msgSend_resourceManager(v29, v30, v31, v32);
    uint64_t v34 = *(void *)(a1 + 384);
    uint64_t v37 = objc_msgSend_newComputePipelineStateWithFunctionName_(v33, v35, @"vfx_rt_indirect_diffuse_upscale", v36);
    uint64_t v38 = *(void **)(v34 + 16);
    if (v38 != (void *)v37)
    {
      if (v38) {

      }
      *(void *)(v34 + 16) = v37;
    }
  }
  unint64_t v39 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(*(void *)(a1 + 376) + 8), MTLPixelFormatRGBA16Float, (uint64_t)v45);
  uint64_t v40 = sub_1B63CFDE4(v39, (uint64_t)"IndirectDiffuseUpscale", v45);
  *(void *)(a1 + 392) = v40;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v40);
  return a1;
}

void sub_1B6480C9C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6480CBC(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B6480D48(uint64_t result, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(result + 384) + 16))
  {
    uint64_t v4 = result;
    CFTypeRef v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(result + 376) + 312), 480, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 248));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 240));
    objc_msgSend_setTexture_atIndex_(v5, v8, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)v7, 1);
    objc_msgSend_setBuffer_offset_atIndex_(v5, v10, *(void *)(*(void *)(v4 + 376) + 304), 0, 0);
    id v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 392));
    objc_msgSend_setTexture_atIndex_(v5, v12, (uint64_t)v11, 10);
    uint64_t v19 = *(void *)(v4 + 384);
    uint64_t v20 = *(void *)(v19 + 16);
    if (!v20)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v13, v14, v15, v16, v17, v18, (uint64_t)"_ptr != NULL");
      uint64_t v20 = *(void *)(v19 + 16);
    }
    uint64_t v22 = sub_1B653EFB8(v20);
    return objc_msgSend_dispatch_onTexture2D_(v5, v21, v22, (uint64_t)v11);
  }
  return result;
}

uint64_t sub_1B6480E90(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  uint64_t v9 = *(void *)a5;
  v28[0] = (uint64_t)"RTIndirectDiffuseTemporalDenoisePass";
  v28[1] = v9;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAF00, memory_order_acquire) & 1) == 0)
  {
    uint64_t v26 = a3;
    int v25 = __cxa_guard_acquire(&qword_1E9DDAF00);
    a3 = v26;
    if (v25)
    {
      qword_1E9DDAEF8 = (uint64_t)sub_1B6481CFC("RT_INDIRECT_DIFFUSE_TEMPORAL_DENOISE", 0x24u);
      __cxa_guard_release(&qword_1E9DDAF00);
      a3 = v26;
    }
  }
  sub_1B653860C(a1, a2, a3, v28, qword_1E9DDAEF8, 0);
  *(void *)a1 = &unk_1F0FB50B0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  uint64_t v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 416) = v17;
  *(void *)(a1 + 424) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, *(const CFX::RG::Resource **)(a5 + 240));
  unint64_t v21 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v22 = CFX::CrossFrameResourceManager::get(a4[4], v21);
  *(void *)(a1 + 384) = v22;
  if (!v22) {
    operator new();
  }
  uint64_t v23 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder((CFX::RG::RenderGraphContext *)a4);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)(*(void *)(a1 + 376) + 8), MTLPixelFormatRGBA16Float, (uint64_t)v27);
  *(void *)(a1 + 408) = sub_1B63CFDE4(v23, (uint64_t)"IndirectDiffuseUpscale", v27);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 376) + 256));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 408));
  return a1;
}

void sub_1B6481098(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B64810B8(uint64_t result, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(result + 384) + 16))
  {
    uint64_t v4 = result;
    CFTypeRef v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(result + 376) + 312), 480, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 392));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(v4 + 376) + 248));
    uint64_t v8 = *(void *)(v4 + 376);
    uint64_t v9 = *(const CFX::RG::Resource **)(v8 + 272);
    if (v9)
    {
      id v10 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v9);
      uint64_t v8 = *(void *)(v4 + 376);
    }
    else
    {
      id v10 = 0;
    }
    id v11 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v8 + 256));
    objc_msgSend_setTexture_atIndex_(v5, v12, (uint64_t)Texture, 0);
    objc_msgSend_setTexture_atIndex_(v5, v13, (uint64_t)v7, 1);
    objc_msgSend_setTexture_atIndex_(v5, v14, (uint64_t)v10, 2);
    objc_msgSend_setTexture_atIndex_(v5, v15, (uint64_t)v11, 3);
    id v16 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 408));
    id v17 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(v4 + 400));
    objc_msgSend_setTexture_atIndex_(v5, v18, (uint64_t)v16, 10);
    objc_msgSend_setTexture_atIndex_(v5, v19, (uint64_t)v17, 11);
    uint64_t v26 = *(void *)(v4 + 384);
    uint64_t v27 = *(void *)(v26 + 16);
    if (!v27)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v20, v21, v22, v23, v24, v25, (uint64_t)"_ptr != NULL");
      uint64_t v27 = *(void *)(v26 + 16);
    }
    uint64_t v29 = sub_1B653EFB8(v27);
    return objc_msgSend_dispatch_onTexture2D_(v5, v28, v29, (uint64_t)v16);
  }
  return result;
}

uint64_t sub_1B6481264(uint64_t a1, uint64_t a2, uint64_t a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  uint64_t v9 = *a5;
  *(void *)&v35[0] = "RTIndirectDiffuseSpatialDenoisePass";
  *((void *)&v35[0] + 1) = v9;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDAF10, memory_order_acquire) & 1) == 0)
  {
    uint64_t v33 = a3;
    int v34 = __cxa_guard_acquire(&qword_1E9DDAF10);
    a3 = v33;
    if (v34)
    {
      qword_1E9DDAF08 = (uint64_t)sub_1B6481CFC("RT_INDIRECT_DIFFUSE_SPATIAL_DENOISE", 0x23u);
      __cxa_guard_release(&qword_1E9DDAF10);
      a3 = v33;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)v35, qword_1E9DDAF08, 0);
  *(void *)a1 = &unk_1F0FB4FD0;
  *(void *)(a1 + 376) = a5;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(void *)(a1 + 416) = 0;
  id v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
  *(void *)(a1 + 408) = v17;
  *(void *)(a1 + 416) = objc_msgSend_resourceManager(v17, v18, v19, v20);
  uint64_t v21 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a4, (const CFX::RG::Resource *)a5[30]);
  unsigned int v22 = *v21;
  unsigned int v23 = v21[1];
  unint64_t v24 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v25 = CFX::CrossFrameResourceManager::get(a4[4], v24);
  *(void *)(a1 + 384) = v25;
  if (!v25) {
    operator new();
  }
  memset(v35, 0, sizeof(v35));
  if (v22 <= 1) {
    __int16 v26 = 1;
  }
  else {
    __int16 v26 = v22;
  }
  if (v23 <= 1) {
    __int16 v27 = 1;
  }
  else {
    __int16 v27 = v23;
  }
  RGTextureDescriptorMake2D(v26, v27, 115, (uint64_t)v35);
  unint64_t v28 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v29 = 0x9DDFEA08EB382D69
      * (v28 ^ ((0x9DDFEA08EB382D69 * (v28 ^ LOWORD(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ LOWORD(v35[0]))));
  unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47));
  uint64_t v31 = CFX::CrossFrameResourceManager::get(a4[4], 0x9DDFEA08EB382D69* ((0x9DDFEA08EB382D69* (v30 ^ ((0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))))) ^ ((0x9DDFEA08EB382D69 * (v30 ^ ((0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))) >> 47) ^ (0x9DDFEA08EB382D69 * (v30 ^ WORD1(v35[0]))))) >> 47)));
  *(void *)(a1 + 392) = v31;
  if (!v31) {
    operator new();
  }
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 376) + 256));
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 392) + 8 * (*(unsigned char *)(*(void *)(a1 + 384) + 24) == 0) + 16));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(*(void *)(a1 + 392) + 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 24) + 16));
  return a1;
}

void sub_1B6481608(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1B6481634(uint64_t a1, uint64_t a2, void **a3)
{
  if (*(void *)(*(void *)(a1 + 384) + 16))
  {
    CFTypeRef v5 = *a3;
    objc_msgSend_setBytes_length_atIndex_(*a3, (const char *)a2, *(void *)(*(void *)(a1 + 376) + 312), 480, 8);
    id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 248));
    id v7 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 240));
    id v8 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 376) + 288));
    objc_msgSend_setTexture_atIndex_(v5, v9, (uint64_t)Texture, 1);
    objc_msgSend_setTexture_atIndex_(v5, v10, (uint64_t)v7, 2);
    objc_msgSend_setTexture_atIndex_(v5, v11, (uint64_t)v8, 3);
    id v12 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 400));
    id v13 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(*(void *)(a1 + 392)+ 8 * *(unsigned __int8 *)(*(void *)(a1 + 384) + 24)+ 16));
    int v58 = 1065353216;
    objc_msgSend_setBytes_length_atIndex_(v5, v14, (uint64_t)&v58, 4, 9);
    objc_msgSend_setTexture_atIndex_(v5, v15, (uint64_t)v12, 0);
    objc_msgSend_setTexture_atIndex_(v5, v16, (uint64_t)v13, 10);
    uint64_t v23 = *(void *)(a1 + 384);
    uint64_t v24 = *(void *)(v23 + 16);
    if (!v24)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v17, v18, v19, v20, v21, v22, (uint64_t)"_ptr != NULL");
      uint64_t v24 = *(void *)(v23 + 16);
    }
    uint64_t v25 = sub_1B653EFB8(v24);
    objc_msgSend_dispatch_onTexture2D_(v5, v26, v25, (uint64_t)v13);
    int v58 = 0x40000000;
    objc_msgSend_setBytes_length_atIndex_(v5, v27, (uint64_t)&v58, 4, 9);
    objc_msgSend_setTexture_atIndex_(v5, v28, (uint64_t)v13, 0);
    objc_msgSend_setTexture_atIndex_(v5, v29, (uint64_t)v12, 10);
    uint64_t v36 = *(void *)(a1 + 384);
    uint64_t v37 = *(void *)(v36 + 16);
    if (!v37)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v30, v31, v32, v33, v34, v35, (uint64_t)"_ptr != NULL");
      uint64_t v37 = *(void *)(v36 + 16);
    }
    uint64_t v38 = sub_1B653EFB8(v37);
    objc_msgSend_dispatch_onTexture2D_(v5, v39, v38, (uint64_t)v13);
    int v58 = 1082130432;
    objc_msgSend_setBytes_length_atIndex_(v5, v40, (uint64_t)&v58, 4, 9);
    objc_msgSend_setTexture_atIndex_(v5, v41, (uint64_t)v12, 0);
    objc_msgSend_setTexture_atIndex_(v5, v42, (uint64_t)v13, 10);
    uint64_t v49 = *(void *)(a1 + 384);
    uint64_t v50 = *(void *)(v49 + 16);
    if (!v50)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v43, v44, v45, v46, v47, v48, (uint64_t)"_ptr != NULL");
      uint64_t v50 = *(void *)(v49 + 16);
    }
    uint64_t v51 = sub_1B653EFB8(v50);
    objc_msgSend_dispatch_onTexture2D_(v5, v52, v51, (uint64_t)v13);
    uint64_t v53 = *(void *)(*(void *)(a1 + 376) + 312);
    long long v54 = *(_OWORD *)(v53 + 272);
    *(_OWORD *)(v53 + 320) = *(_OWORD *)(v53 + 256);
    *(_OWORD *)(v53 + 336) = v54;
    __n128 result = *(__n128 *)(v53 + 288);
    long long v56 = *(_OWORD *)(v53 + 304);
    *(__n128 *)(v53 + 352) = result;
    *(_OWORD *)(v53 + 368) = v56;
    uint64_t v57 = *(void *)(a1 + 384);
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 376) + 312) + 396);
    *(unsigned char *)(v57 + 24) ^= 1u;
  }
  return result;
}

CFX::RG::Pass *sub_1B64818DC(CFX::RG::RenderGraphContext *a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a1);
  CFTypeRef v5 = (CFX::RG::Pass *)sub_1B6481A18(v4, a1, (uint64_t)a2);
  uint64_t v6 = *((void *)v5 + 48);
  uint64_t v7 = *(void *)(v6 + 8 * *(unsigned __int8 *)(v6 + 592) + 576);
  a2[36] = *(void *)(v6 + 600);
  a2[37] = v7;
  id v8 = (uint64_t *)sub_1B6481A70(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  CFX::RG::Pass::dependsOn(v8, v5);
  a2[38] = *(void *)(v8[49] + 24);
  uint64_t v9 = (uint64_t *)sub_1B6481AC8(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  CFX::RG::Pass::dependsOn(v9, (CFX::RG::Pass *)v8);
  uint64_t v10 = (uint64_t *)sub_1B6481B20(v4, (CFX::CrossFrameResourceManager **)a1, (uint64_t)a2);
  uint64_t v11 = (CFX::RG::Resource *)v9[49];
  v10[49] = (uint64_t)v11;
  CFX::RG::Pass::readFrom(v10, v11);
  CFX::RG::Pass::dependsOn(v10, (CFX::RG::Pass *)v9);
  id v12 = (uint64_t *)sub_1B6481B78(v4, (CFX::CrossFrameResourceManager **)a1, a2);
  id v13 = (CFX::RG::Resource *)v10[51];
  v12[50] = (uint64_t)v13;
  CFX::RG::Pass::readFrom(v12, v13);
  CFX::RG::Pass::dependsOn(v12, (CFX::RG::Pass *)v10);
  uint64_t v14 = *(CFX::RG::Resource **)(v12[49] + 8 * (*(unsigned char *)(v12[48] + 24) == 0) + 16);
  v10[50] = (uint64_t)v14;
  CFX::RG::Pass::readFrom(v10, v14);
  a2[35] = *(void *)(v12[49] + 8 * *(unsigned __int8 *)(v12[48] + 24) + 16);
  return v5;
}

uint64_t sub_1B6481A18(uint64_t *a1, CFX::RG::RenderGraphContext *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = (uint64_t)sub_1B6482298(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6481A70(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64822F8(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6481AC8(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6482358(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6481B20(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B64823B8(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B6481B78(uint64_t *a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B6482418(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B6481BD4(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6481C10(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6481C4C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6481C88(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B6481CC4(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B6481CFC(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      uint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      __n128 result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B6481DE8(void *a1)
{
  *a1 = &unk_1F0FB4F00;
  for (uint64_t i = 3; i != 1; --i)
  {
    uint64_t v3 = (void *)a1[i];
    if (v3) {
  }
    }
  return a1;
}

void sub_1B6481E44(void *a1)
{
  *a1 = &unk_1F0FB4F00;
  uint64_t v2 = 3;
  while (1)
  {
    uint64_t v3 = (void *)a1[v2];
    if (v3) {

    }
    if (--v2 == 1)
    {
      JUMPOUT(0x1BA9B6D80);
    }
  }
}

void *sub_1B6481EC0(void *a1)
{
  *a1 = &unk_1F0FB4F20;
  for (uint64_t i = 3; i != 1; --i)
  {
    uint64_t v3 = (void *)a1[i];
    if (v3) {
  }
    }
  return a1;
}

void sub_1B6481F1C(void *a1)
{
  *a1 = &unk_1F0FB4F20;
  uint64_t v2 = 3;
  while (1)
  {
    uint64_t v3 = (void *)a1[v2];
    if (v3) {

    }
    if (--v2 == 1)
    {
      JUMPOUT(0x1BA9B6D80);
    }
  }
}

void *sub_1B6481F98(void *a1)
{
  *a1 = &unk_1F0FB4B20;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6481FE4(void *a1)
{
  *a1 = &unk_1F0FB4B20;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6482050(void *a1)
{
  *a1 = &unk_1F0FB5090;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B648209C(void *a1)
{
  *a1 = &unk_1F0FB5090;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B6482108(void *a1)
{
  *a1 = &unk_1F0FB4F90;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B6482154(void *a1)
{
  *a1 = &unk_1F0FB4F90;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B64821C0(void *a1)
{
  *a1 = &unk_1F0FB4FB0;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);
  return a1;
}

void sub_1B648221C(void *a1)
{
  *a1 = &unk_1F0FB4FB0;
  for (uint64_t i = 3; i != 1; --i)
    sub_1B644E78C((CFX::RG::Resource **)&a1[i], 0);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t *sub_1B6482298(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::RG::RenderGraphContext *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  id v8 = (uint64_t *)sub_1B63C8330(v10, 0x198u, 8u);
  return sub_1B647FCAC(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64822F8(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A0u, 8u);
  return sub_1B64804E8(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6482358(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A0u, 8u);
  return sub_1B6480AFC(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B64823B8(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B6480E90(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B6482418(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::CrossFrameResourceManager **a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1A8u, 8u);
  return sub_1B6481264(v8, *a3, a3[1], a4, a5);
}

id sub_1B6482478(id obj)
{
  return objc_storeWeak(qword_1EB985DC0, obj);
}

void sub_1B64824B8(void *a1)
{
  id v1 = a1;
  id WeakRetained = objc_loadWeakRetained(qword_1EB985DC0);

  if (WeakRetained == v1)
  {
    objc_storeWeak(qword_1EB985DC0, 0);
  }
}

id sub_1B6482524(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  id v8 = a3;
  id v9 = a4;
  objc_initWeak(&location, a1);
  uint64_t v10 = [VFXDisplayLink alloc];
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  v14[2] = sub_1B6482650;
  v14[3] = &unk_1E61426F0;
  objc_copyWeak(&v15, &location);
  id v12 = objc_msgSend_initWithQueue_screen_policy_block_(v10, v11, (uint64_t)v8, (uint64_t)v9, a5, v14);
  objc_destroyWeak(&v15);
  objc_destroyWeak(&location);

  return v12;
}

void sub_1B648262C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B6482650(uint64_t a1, double a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v7 = WeakRetained;
    objc_msgSend_VFX_displayLinkCallback_(WeakRetained, v4, v5, v6, a2);
    id WeakRetained = v7;
  }
}

void sub_1B64828BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B64828EC(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (id *)(a1 + 48);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  memset(&v37, 0, sizeof(v37));
  if (WeakRetained)
  {
    uint64_t v4 = objc_opt_class();
    int v15 = objc_msgSend_usesSeparateWorkGroup(v4, v5, v6, v7);
    if (v15)
    {
      sub_1B63F2F54(0, @"Info: [VFXView] Using separate work group", v9, v10, v11, v12, v13, v14, *(uint64_t *)&v37.sig);
      os_workgroup_attr_set_flags();
      uint64_t v16 = (OS_os_workgroup *)os_workgroup_create();
      os_workgroup_join(v16, &v37);
    }
    else
    {
      uint64_t v16 = 0;
    }
    uint64_t v17 = objc_msgSend_renderer(WeakRetained, v8, v9, v10, *(_OWORD *)&v37.sig, *(_OWORD *)&v37.opaque[12], *(void *)&v37.opaque[28], v38);
    uint64_t v21 = objc_msgSend__renderingQueue(v17, v18, v19, v20);
    uint64_t v23 = objc_msgSend_VFX_setupDisplayLinkWithQueue_screen_policy_(WeakRetained, v22, (uint64_t)v21, *(void *)(a1 + 32), *(void *)(a1 + 56));

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v16 = 0;
    int v15 = 0;
  }

  __int16 v27 = objc_msgSend_currentRunLoop(MEMORY[0x1E4F1CAC0], v24, v25, v26);
  pthread_setname_np("com.apple.VFXview-renderer");
  pthread_set_fixedpriority_self();
  id v28 = objc_loadWeakRetained(v2);

  if (v28)
  {
    uint64_t v29 = *MEMORY[0x1E4F1C3A0];
    do
    {
      uint64_t v30 = (void *)MEMORY[0x1BA9B76E0]();
      uint64_t v34 = objc_msgSend_dateWithTimeIntervalSinceNow_(MEMORY[0x1E4F1C9C8], v31, v32, v33, 1.0);
      objc_msgSend_runMode_beforeDate_(v27, v35, v29, (uint64_t)v34);

      id v36 = objc_loadWeakRetained(v2);
    }
    while (v36);
  }
  if (v15) {
    os_workgroup_leave(v16, &v37);
  }
}

uint64_t sub_1B6482AE8(uint64_t a1)
{
  pthread_t v2 = 0;
  return pthread_create(&v2, (const pthread_attr_t *)(a1 + 32), (void *(__cdecl *)(void *))sub_1B6482B28, *(void **)(a1 + 96));
}

void sub_1B6482B28(void *a1)
{
  id v1 = a1;
  if (qword_1EB9860D8[0] != -1) {
    dispatch_once(qword_1EB9860D8, &unk_1F0FB5868);
  }
  uint64_t v2 = pthread_setspecific(qword_1EB9860D0, v1);
  uint64_t v3 = (void *)MEMORY[0x1BA9B76E0](v2);
  v1[2](v1);
  pthread_exit(0);
}

uint64_t sub_1B6482BA0()
{
  return pthread_key_create((pthread_key_t *)&qword_1EB9860D0, (void (__cdecl *)(void *))j___Block_release);
}

id sub_1B6483094(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id result = (id)objc_msgSend_setWithArray_(MEMORY[0x1E4F1CAD0], a2, (uint64_t)&unk_1F103BF30, a4);
  qword_1E9DDAF18 = (uint64_t)result;
  return result;
}

void sub_1B6483174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1B648318C(uint64_t a1, void *a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_name(a2, (const char *)a2, (uint64_t)a3, a4);
  uint64_t result = objc_msgSend_isEqualToString_(v6, v7, *(void *)(a1 + 32), v8);
  if (result)
  {
    if (++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) == 2) {
      *a3 = 1;
    }
  }
  return result;
}

void sub_1B64838C0(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
}

uint64_t sub_1B6483CA8(uint64_t a1, const char *a2)
{
  return objc_msgSend__applyUnsharing_alreadyShared_(*(void **)(a1 + 32), a2, (uint64_t)a2, *(void *)(a1 + 40));
}

uint64_t sub_1B6483CB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](*(void *)(a1 + 32), sel__applyOverride_forKeyPath_, a3, a2);
}

uint64_t sub_1B6484248(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (objc_msgSend_light(a2, (const char *)a2, a3, a4))
  {
    uint64_t v8 = objc_msgSend_light(a2, v5, v6, v7);
    id v12 = (id)objc_msgSend_copy(v8, v9, v10, v11);
    objc_msgSend_setLight_(a2, v13, (uint64_t)v12, v14);
  }
  uint64_t result = objc_msgSend_camera(a2, v5, v6, v7);
  if (result)
  {
    uint64_t v19 = objc_msgSend_camera(a2, v16, v17, v18);
    id v24 = (id)objc_msgSend_copy(v19, v20, v21, v22);
    return objc_msgSend_setCamera_(a2, v23, (uint64_t)v24, v25);
  }
  return result;
}

BOOL sub_1B64846F8(uint64_t a1, unsigned int a2, int a3, void *a4)
{
  uint64_t v8 = a3;
  bzero(a4, 4 * a3);
  if ((int)a2 < 1)
  {
    BOOL v10 = 1;
  }
  else
  {
    uint64_t v9 = 0;
    BOOL v10 = 0;
    int v11 = 0;
    uint64_t v12 = (a3 + 1);
    uint64_t v13 = 4 * a2;
    uint64_t v14 = 4 * (a2 - 1) * a2;
    uint64_t v15 = v14 + 4;
    uint64_t v16 = 1;
    uint64_t v17 = a1;
    uint64_t v18 = a1;
    do
    {
      unint64_t v19 = v9 + 1;
      uint64_t v20 = v9 * a2;
      if (v9 + 1 >= (unint64_t)a2)
      {
        int v22 = v9;
      }
      else
      {
        uint64_t v21 = 1;
        int v22 = v9;
        do
        {
          if (fabsf(*(float *)(v18 + 4 * v21)) > fabsf(*(float *)(a1 + 4 * (v20 + v22)))) {
            int v22 = v9 + v21;
          }
          ++v21;
        }
        while (v9 - a2 + v21);
      }
      if (v9 != v22 && v9 <= v8)
      {
        uint64_t v23 = 0;
        uint64_t v24 = v17 + 4 * v22;
        uint64_t v25 = v12;
        do
        {
          int v26 = *(_DWORD *)(v18 + v23);
          *(_DWORD *)(v18 + v23) = *(_DWORD *)(v24 + v23);
          *(_DWORD *)(v24 + v23) = v26;
          v23 += v13;
          --v25;
        }
        while (v25);
      }
      uint64_t v27 = v9 + (int)(v11 * a2);
      if (fabsf(*(float *)(a1 + 4 * v27)) >= 0.000001)
      {
        uint64_t v28 = v15;
        uint64_t v29 = v16;
        if (v19 < a2)
        {
          do
          {
            uint64_t v30 = a1;
            uint64_t v31 = a2;
            do
            {
              --v31;
              *(float *)(v30 + v28) = *(float *)(v30 + v28)
                                    - (float)((float)(*(float *)(v30 + v14) * *(float *)(a1 + 4 * (v29 + v20)))
                                            / *(float *)(a1 + 4 * v27));
              v30 -= 4 * a2;
            }
            while (v31 > v9);
            ++v29;
            v28 += 4;
          }
          while (v29 != a2);
        }
      }
      else if (v9 < v8)
      {
        return v10;
      }
      ++v11;
      --v12;
      ++v16;
      v18 += v13 + 4;
      v17 += v13;
      v15 += 4;
      v14 += 4;
      ++v9;
      BOOL v10 = v19 >= a2;
    }
    while (v19 != a2);
  }
  if (a3 >= 1)
  {
    uint64_t v32 = 0;
    uint64_t v33 = a1 + 4 * (v8 + (int)v8 * (uint64_t)(int)a2) - 4;
    uint64_t v34 = 4 * (int)a2;
    uint64_t v35 = v8;
    do
    {
      float v36 = 0.0;
      if (v35 < v8)
      {
        os_workgroup_join_token_opaque_s v37 = (float *)v33;
        uint64_t v38 = v32;
        do
        {
          float v36 = v36 + (float)(*v37 * *((float *)a4 + v8 + v38));
          os_workgroup_join_token_opaque_s v37 = (float *)((char *)v37 + v34);
          ++v38;
        }
        while (v38);
      }
      *((float *)a4 + v35 - 1) = (float)(*(float *)(a1 + 4 * (v35 - 1 + (int)(a3 * a2))) - v36)
                               / *(float *)(a1 + 4 * (int)((a2 + 1) * (v35 - 1)));
      --v32;
      v33 += v34 ^ 0xFFFFFFFFFFFFFFFCLL;
    }
    while (v35-- > 1);
  }
  return v10;
}

void sub_1B64850B0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9B6D80](v1, 0x10A0C400A278675);
  _Unwind_Resume(a1);
}

void sub_1B6485B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  prof_endFlame();
  _Unwind_Resume(a1);
}

void sub_1B6485BC8(uint64_t a1, uint64_t a2)
{
}

void sub_1B6485BD8(uint64_t a1)
{
}

void sub_1B6485BE4(uint64_t a1, void *a2)
{
  prof_eventSmallData(1, (uint64_t)"Current CB creation to completion", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1202, *(unsigned int *)(a1 + 48) | 0x300000000);
  objc_msgSend_GPUEndTime(a2, v4, v5, v6);
  double v8 = v7;
  objc_msgSend_GPUStartTime(a2, v9, v10, v11);
  *(double *)(*(void *)(*(void *)(a1 + 32) + 16) + 200) = v8 - v12;
  if (objc_msgSend_status(a2, v13, v14, v15) != 4)
  {
    objc_msgSend_commandBufferDidCompleteWithError_(*(void **)(*(void *)(a1 + 32) + 112), v16, (uint64_t)a2, v17);
    uint64_t v21 = objc_msgSend_status(a2, v18, v19, v20);
    objc_msgSend_error(a2, v22, v23, v24);
    objc_msgSend_logs(a2, v25, v26, v27);
    sub_1B63F2F54(16, @"Error: Main command buffer execution failed with status %d, error: %@\n%@", v28, v29, v30, v31, v32, v33, v21);
    Weauint64_t k = objc_loadWeak((id *)(*(void *)(a1 + 32) + 18512));
    objc_msgSend_renderContext_commandBufferDidCompleteWithError_(Weak, v35, *(void *)(a1 + 32), (uint64_t)a2);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
  atomic_fetch_add((atomic_uint *volatile)(*(void *)(a1 + 32) + 176), 0xFFFFFFFF);

  prof_commit();
}

void sub_1B6486150(_Unwind_Exception *a1)
{
}

uint64_t sub_1B6486178(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)a1;
  if (!v9)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_encoder != nil");
    uint64_t v9 = *(void **)a1;
  }
  uint64_t result = objc_msgSend_endEncoding(v9, a2, a3, a4);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  return result;
}

void sub_1B64861D0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_kernelStartTime(a2, (const char *)a2, a3, a4);
  double v7 = v6;
  objc_msgSend_kernelEndTime(a2, v8, v9, v10);
  double v12 = v11;
  uint64_t v13 = *(unsigned int *)(a1 + 32) | 0x300000000;
  unint64_t v14 = prof_clockTicksFromSecondsMonotonic(v7);
  unint64_t v15 = prof_clockTicksFromSecondsMonotonic(v12);
  prof_eventTimeRangeSmallData(v14, v15, (uint64_t)"Resource CB kernel time", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1256, v13);
  objc_msgSend_GPUStartTime(a2, v16, v17, v18);
  double v20 = v19;
  objc_msgSend_GPUEndTime(a2, v21, v22, v23);
  double v25 = v24;
  uint64_t v26 = *(unsigned int *)(a1 + 32) | 0x300000000;
  unint64_t v27 = prof_clockTicksFromSecondsMonotonic(v20);
  unint64_t v28 = prof_clockTicksFromSecondsMonotonic(v25);

  prof_eventTimeRangeSmallData(v27, v28, (uint64_t)"Resource CB GPU time", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1257, v26);
}

uint64_t sub_1B64862C8(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v4 = *(void **)(a1 + 32);
  if (isKindOfClass)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v3, (uint64_t)&v11, (uint64_t)v15, 16);
    if (result)
    {
      uint64_t v6 = result;
      uint64_t v7 = *(void *)v12;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v4);
          }
          (*(void (**)(void))(*(void *)(*((void *)&v11 + 1) + 8 * v8++) + 16))();
        }
        while (v6 != v8);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v9, (uint64_t)&v11, (uint64_t)v15, 16);
        uint64_t v6 = result;
      }
      while (result);
    }
  }
  else
  {
    uint64_t v10 = (uint64_t (*)(void *))v4[2];
    return v10(v4);
  }
  return result;
}

void sub_1B6486424(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_kernelStartTime(a2, (const char *)a2, a3, a4);
  double v7 = v6;
  objc_msgSend_kernelEndTime(a2, v8, v9, v10);
  double v12 = v11;
  uint64_t v13 = *(unsigned int *)(a1 + 40) | 0x300000000;
  unint64_t v14 = prof_clockTicksFromSecondsMonotonic(v7);
  unint64_t v15 = prof_clockTicksFromSecondsMonotonic(v12);
  prof_eventTimeRangeSmallData(v14, v15, (uint64_t)"Kernel time", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1288, v13);
  objc_msgSend_GPUStartTime(a2, v16, v17, v18);
  double v20 = v19;
  objc_msgSend_GPUEndTime(a2, v21, v22, v23);
  double v25 = v24;
  uint64_t v26 = *(unsigned int *)(a1 + 40) | 0x300000000;
  unint64_t v27 = prof_clockTicksFromSecondsMonotonic(v20);
  unint64_t v28 = prof_clockTicksFromSecondsMonotonic(v25);
  prof_eventTimeRangeSmallData(v27, v28, (uint64_t)"CommandBuffer GPU time", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1289, v26);
  if (*(unsigned char *)(*(void *)(a1 + 32) + 505))
  {
    uint64_t v32 = objc_msgSend_sharedCaptureManager(MEMORY[0x1E4F351E0], v29, v30, v31);
    objc_msgSend_stopCapture(v32, v33, v34, v35);
    *(unsigned char *)(*(void *)(a1 + 32) + 505) = 0;
  }
}

uint64_t sub_1B6486534(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v4 = *(void **)(a1 + 32);
  if (isKindOfClass)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v3, (uint64_t)&v11, (uint64_t)v15, 16);
    if (result)
    {
      uint64_t v6 = result;
      uint64_t v7 = *(void *)v12;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v4);
          }
          (*(void (**)(void))(*(void *)(*((void *)&v11 + 1) + 8 * v8++) + 16))();
        }
        while (v6 != v8);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v9, (uint64_t)&v11, (uint64_t)v15, 16);
        uint64_t v6 = result;
      }
      while (result);
    }
  }
  else
  {
    uint64_t v10 = (uint64_t (*)(void *))v4[2];
    return v10(v4);
  }
  return result;
}

void sub_1B6486690(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_presentedTime(a2, (const char *)a2, a3, a4);
  if (v9 == 0.0)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32) | 0x300000000;
    prof_eventSmallData(2, (uint64_t)"Drawable present skipped", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1346, v10);
  }
  else
  {
    objc_msgSend_presentedTime(a2, v6, v7, v8);
    uint64_t v11 = *(unsigned int *)(a1 + 32) | 0x300000000;
    unint64_t v13 = prof_clockTicksFromSecondsMonotonic(v12);
    prof_eventTimeSmallData(2, v13, (uint64_t)"Presented time", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1348, v11);
  }
}

uint64_t sub_1B6486744(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v4 = *(void **)(a1 + 32);
  if (isKindOfClass)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v3, (uint64_t)&v11, (uint64_t)v15, 16);
    if (result)
    {
      uint64_t v6 = result;
      uint64_t v7 = *(void *)v12;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v4);
          }
          (*(void (**)(void))(*(void *)(*((void *)&v11 + 1) + 8 * v8++) + 16))();
        }
        while (v6 != v8);
        uint64_t result = objc_msgSend_countByEnumeratingWithState_objects_count_(v4, v9, (uint64_t)&v11, (uint64_t)v15, 16);
        uint64_t v6 = result;
      }
      while (result);
    }
  }
  else
  {
    uint64_t v10 = (uint64_t (*)(void *))v4[2];
    return v10(v4);
  }
  return result;
}

void sub_1B6486BB8(uint64_t a1, void *a2)
{
  prof_eventSmallData(1, (uint64_t)"Resource CB creation to completion", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/NewRenderer/VFXMTLRenderContext.mm", 1706, *(unsigned int *)(*(void *)(a1 + 32) + 8) | 0x300000000);
  if (objc_msgSend_status(a2, v4, v5, v6) != 4)
  {
    objc_msgSend_commandBufferDidCompleteWithError_(*(void **)(*(void *)(a1 + 32) + 112), v7, (uint64_t)a2, v8);
    uint64_t v12 = objc_msgSend_status(a2, v9, v10, v11);
    objc_msgSend_error(a2, v13, v14, v15);
    objc_msgSend_logs(a2, v16, v17, v18);
    sub_1B63F2F54(16, @"Error: Resource command buffer execution failed with status %d, error: %@\n%@", v19, v20, v21, v22, v23, v24, v12);
    Weauint64_t k = objc_loadWeak((id *)(*(void *)(a1 + 32) + 18512));
    objc_msgSend_renderContext_commandBufferDidCompleteWithError_(Weak, v26, *(void *)(a1 + 32), (uint64_t)a2);
  }

  prof_commit();
}

double sub_1B6487024(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, double result)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    uint64_t v7 = objc_msgSend_contents(a2, (const char *)a2, a3, a4);
    uint64_t v11 = objc_msgSend_length(a2, v8, v9, v10);
    *(void *)&uint64_t result = sub_1B647DF78(v5, v7, v11, v12, v13, v14, v15, v16, v17).n128_u64[0];
  }
  return result;
}

__n128 sub_1B648852C(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v26 = 0;
  uint64x2_t v25 = 0uLL;
  sub_1B6451B68(a1, (uint64_t)&v26, (uint64_t)&v25.i64[1], (uint64_t)&v25, a5, a6, a7, a8);
  unsigned int v9 = sub_1B64479E4((uint64_t)a2);
  unsigned int v11 = v9;
  if (!v26)
  {
    switch(v9)
    {
      case 4u:
        _Q0.n128_u64[0] = 1065353216;
        goto LABEL_14;
      case 3u:
        _Q0.n128_u64[0] = 0x3F80000000000000;
LABEL_16:
        __n128 v24 = _Q0;
        __asm { FMOV            V0.2S, #1.0 }
        goto LABEL_19;
      case 2u:
        goto LABEL_11;
    }
LABEL_17:
    __asm { FMOV            V0.2S, #1.0 }
    goto LABEL_18;
  }
  if (v9 == 4) {
    goto LABEL_17;
  }
  if (v9 != 3)
  {
    if (v9 == 2)
    {
      _Q0.n128_u64[0] = 0x3F80000000000000;
LABEL_14:
      __n128 v24 = _Q0;
      __asm { FMOV            V0.2S, #1.0 }
      goto LABEL_19;
    }
    _Q0.n128_u64[0] = 1065353216;
    goto LABEL_16;
  }
LABEL_11:
  __asm { FMOV            V0.2S, #1.0 }
  _Q0.n128_u64[0] = 0;
LABEL_18:
  __n128 v24 = _Q0;
LABEL_19:
  __n128 v19 = sub_1B64479C4(a2);
  v19.n128_u64[0] = vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL).u64[0];
  float32x2_t v20 = vmul_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v11 < 3), 0x1FuLL)), (int8x8_t)vrev64_s32((int32x2_t)v19.n128_u64[0]), (int8x8_t)v19.n128_u64[0]), vcvt_f32_f64(vcvtq_f64_u64(v25)));
  if (v20.f32[0] <= v20.f32[1])
  {
    if (v20.f32[0] < v20.f32[1])
    {
      float v23 = v20.f32[0] / v20.f32[1];
      __n128 result = v24;
      result.n128_f32[0] = (float)((float)(v24.n128_f32[0] + -0.5) * v23) + 0.5;
    }
    else
    {
      return v24;
    }
  }
  else
  {
    float v21 = v20.f32[1] / v20.f32[0];
    __n128 result = v24;
    result.n128_f32[1] = (float)((float)(v24.n128_f32[1] + -0.5) * v21) + 0.5;
  }
  return result;
}

uint64_t sub_1B6488D80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"rendererElement");
  }
  uint64_t v11 = sub_1B63F1678(a2);
  uint64_t v87 = *(void *)(a1 + 144);
  uint64_t v12 = *(void *)(a1 + 544);
  if (sub_1B63F17CC(a2, v13, v14, v15, v16, v17, v18, v19)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Hidden nodes should have been removed from the pipeline already", v21, v22, v23, v24, v25, v26, (uint64_t)"CFXRendererElementIsHidden(rendererElement) != true");
  }
  if (v11 && sub_1B64A0C9C(v11, v20, v21, v22, v23, v24, v25, v26) <= 0.0 && (*(_WORD *)(a2 + 80) & 7) != 4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Fully transparents objects should have been removed from the pipeline already", v27, v28, v29, v30, v31, v32, (uint64_t)"theNode==NULL || CFXNodeGetOpacity(theNode) > 0 || (rendererElement->_renderableAttributeKind == kCFXRenderableAttributeKindVFXCore)");
  }
  if (sub_1B63F1400(a2))
  {
    uint64_t v40 = (unsigned char *)(a1 + 18552);
    if (!*(void *)(a2 + 48)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. RenderElement external encoder is nil", v34, v35, v36, v37, v38, v39, (uint64_t)"rendererElement->_handler.encoder");
    }
    ++*(_DWORD *)(*(void *)(a1 + 16) + 8);
    if (a3)
    {
      *(_WORD *)(a1 + 18556) = *(_WORD *)(a3 + 13280);
      uint64_t result = sub_1B64469B8(v87, (uint64_t)v33, v34, v35, v36, v37, v38, v39);
      *(_DWORD *)(a1 + 18560) = result;
      int v42 = *(unsigned __int8 *)(a3 + 12769);
      *uint64_t v40 = v42;
      if (v42 && *(__int16 *)(a2 + 80) < 0) {
        return result;
      }
    }
    else
    {
      *(_WORD *)(a1 + 18556) = 0;
      *(_DWORD *)(a1 + 18560) = sub_1B64469B8(v87, (uint64_t)v33, v34, v35, v36, v37, v38, v39);
      *uint64_t v40 = 0;
    }
    (*(void (**)(void))(*(void *)(a2 + 48) + 16))();
    return objc_msgSend__clearRenderCaches((void *)a1, v81, v82, v83);
  }
  else
  {
    uint64_t v43 = *(void *)(a2 + 40);
    if (!v43
      && ((uint64_t v84 = *(void *)(a2 + 32)) == 0
       || (uint64_t v43 = sub_1B64AFA68(v84, (uint64_t)v33, v34, v35, v36, v37, v38, v39)) == 0)
      || a3 && *(void *)a3 && (*(unsigned char *)(*(void *)a3 + 186) & 0x10) != 0)
    {
      return objc_msgSend_drawRenderElement_withPass_((void *)a1, v33, a2, v12);
    }
    else
    {
      uint64_t result = sub_1B651528C();
      if (v43 != result)
      {
        uint64_t v86 = sub_1B63F17A8(a2);
        uint64_t result = sub_1B6515384(v43, v44, v45, v46, v47, v48, v49, v50);
        if (result >= 1)
        {
          uint64_t v57 = result;
          for (uint64_t i = 0; i != v57; ++i)
          {
            uint64_t v59 = sub_1B6515448(v43, i, v51, v52, v53, v54, v55, v56);
            uint64_t result = sub_1B65F6E90(v59, v60, v61, v62, v63, v64, v65, v66);
            if ((result & 1) == 0)
            {
              int v68 = sub_1B65F6CFC(v59, v67, v51, v52, v53, v54, v55, v56);
              v88[0] = v59;
              v88[1] = v43;
              v88[2] = v11;
              v88[3] = v87;
              v88[5] = 0;
              v88[6] = 0;
              uint64_t v69 = *(void *)(v59 + 280);
              v88[4] = a3 + 160;
              v88[7] = v69;
              v88[8] = a2;
              v88[9] = *(unsigned __int8 *)(a3 + 25);
              uint64_t v89 = 0;
              LOWORD(v89) = *(_WORD *)(a3 + 27);
              sub_1B65F854C((uint64_t)v88);
              switch(v68)
              {
                case 1:
                case 7:
                  sub_1B65F8560((uint64_t)v88);
                  break;
                case 2:
                  uint64_t v77 = sub_1B65F9130(v59, (uint64_t)v70, v71, v72, v73, v74, v75, v76);
                  if (v77) {
                    uint64_t v80 = v77;
                  }
                  else {
                    uint64_t v80 = v86;
                  }
                  if (v80) {
                    objc_msgSend_setRasterizerStates_((void *)a1, v78, v80, v79);
                  }
                  objc_msgSend_drawRenderElement_withPass_((void *)a1, v78, a2, v59);
                  break;
                case 3:
                case 6:
                case 8:
                  break;
                case 4:
                  objc_msgSend_drawFullScreenQuadForPass_((void *)a1, v70, v59, v72);
                  break;
                default:
                  sub_1B63F2F54(16, @"Error: CFXEngineContextRenderRenderGraph - unknown draw instruction", v71, v72, v73, v74, v75, v76, v85);
                  break;
              }
              uint64_t result = sub_1B65F8574((uint64_t)v88);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1B6489B18()
{
  p_superclass = &OBJC_METACLASS____TtCV3VFX25ParticleAngleVelocityInit6System.superclass;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9812A0, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EB9812A0);
    p_superclass = &OBJC_METACLASS____TtCV3VFX25ParticleAngleVelocityInit6System.superclass;
    if (v2)
    {
      byte_1EB9812A8 = 17;
      __cxa_guard_release(&qword_1EB9812A0);
      p_superclass = (__objc2_class **)(&OBJC_METACLASS____TtCV3VFX25ParticleAngleVelocityInit6System + 8);
    }
  }
  return *((unsigned __int8 *)p_superclass + 680);
}

uint64_t sub_1B648BB64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  *(void *)(*(void *)(result + 32) + 16416) = a2;
  if (a2)
  {
    uint64_t v10 = (_OWORD *)sub_1B651004C(*(void *)(*(void *)(result + 32) + 568), *(_DWORD *)(a2 + 88), a3, a4, a5, a6, a7, a8);
    long long v18 = v10[1];
    long long v19 = v10[2];
    long long v20 = v10[3];
    uint64_t v21 = *(_OWORD **)(v8 + 32);
    v21[822] = *v10;
    v21[823] = v18;
    v21[824] = v19;
    v21[825] = v20;
    uint64_t v22 = *(void *)(v8 + 48);
    if (v22 && *(_DWORD *)(v8 + 72) == 1)
    {
      uint64_t v56 = 0;
      uint64_t v23 = sub_1B6525800(v22, &v56);
      if (v56 != 3) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. there should be exactly one transposed matrix in here", v12, v13, v14, v15, v16, v17, (uint64_t)"vectorCount == 3");
      }
      unint64_t v24 = 0;
      int32x4_t v25 = *(int32x4_t *)(v23 + 16);
      int32x4_t v26 = *(int32x4_t *)(v23 + 32);
      float32x2x2_t v27 = (float32x2x2_t)vzip1q_s32(*(int32x4_t *)v23, v26);
      float32x2x2_t v28 = (float32x2x2_t)vzip2q_s32(*(int32x4_t *)v23, v26);
      int32x4_t v29 = vzip1q_s32(v25, (int32x4_t)0);
      int32x4_t v30 = vzip2q_s32(v25, (int32x4_t)xmmword_1B6E4F370);
      uint64_t v31 = *(float32x4_t **)(v8 + 32);
      float32x4_t v32 = v31[822];
      float32x4_t v33 = v31[823];
      float32x4_t v34 = v31[824];
      float32x4_t v35 = v31[825];
      uint64_t v36 = (float *)v57;
      vst2_f32(v36, v27);
      v36 += 4;
      *(int32x4_t *)uint64_t v36 = vzip2q_s32((int32x4_t)v27, v29);
      uint64_t v37 = (float *)v58;
      vst2_f32(v37, v28);
      v58[1] = vzip2q_s32((int32x4_t)v28, v30);
      do
      {
        v59[v24 / 0x10] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v32, COERCE_FLOAT(*(_OWORD *)&v57[v24])), v33, *(float32x2_t *)&v57[v24], 1), v34, *(float32x4_t *)&v57[v24], 2), v35, *(float32x4_t *)&v57[v24], 3);
        v24 += 16;
      }
      while (v24 != 64);
      float32x4_t v38 = (float32x4_t)v59[1];
      float32x4_t v39 = (float32x4_t)v59[2];
      float32x4_t v40 = (float32x4_t)v59[3];
      v31[822] = (float32x4_t)v59[0];
      v31[823] = v38;
      v31[824] = v39;
      v31[825] = v40;
    }
    uint64_t result = sub_1B64A2250(a2, v11, v12, v13, v14, v15, v16, v17);
    long long v41 = *(_OWORD *)(result + 16);
    long long v42 = *(_OWORD *)(result + 32);
    long long v43 = *(_OWORD *)(result + 48);
    uint64_t v44 = *(_OWORD **)(v8 + 32);
    v44[826] = *(_OWORD *)result;
    v44[827] = v41;
    v44[828] = v42;
    v44[829] = v43;
  }
  else
  {
    long long v45 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 16);
    long long v46 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 32);
    long long v47 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 48);
    uint64_t v48 = *(_OWORD **)(result + 32);
    v48[822] = *MEMORY[0x1E4F149A0];
    v48[823] = v45;
    v48[824] = v46;
    v48[825] = v47;
    uint64_t v49 = *(_OWORD **)(result + 32);
    v49[829] = v49[825];
    v49[828] = v49[824];
    v49[827] = v49[823];
    v49[826] = v49[822];
  }
  *(_DWORD *)(*(void *)(v8 + 32) + 16424) = 0;
  *(void *)(*(void *)(v8 + 32) + 16432) = *(void *)(v8 + 56);
  if (*(_DWORD *)(v8 + 76))
  {
    unint64_t v50 = 0;
    do
    {
      uint64_t result = objc_msgSend_semanticsCount(*(void **)(v8 + 40), (const char *)a2, a3, a4);
      if (result >= 1)
      {
        uint64_t v51 = 0;
        for (uint64_t i = 0; i < result; ++i)
        {
          (*(void (**)(void))(*(void *)(*(void *)(*(void *)(v8 + 40) + 48) + v51) + 16))();
          uint64_t result = objc_msgSend_semanticsCount(*(void **)(v8 + 40), v53, v54, v55);
          v51 += 16;
        }
      }
      ++v50;
    }
    while (v50 < *(unsigned int *)(v8 + 76));
  }
  return result;
}

__n128 sub_1B648CFAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(a4 + 13152);
  long long v5 = *(_OWORD *)(a4 + 13168);
  long long v6 = *(_OWORD *)(a4 + 13200);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a4 + 13184);
  *(_OWORD *)(a2 + 48) = v6;
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v5;
  return result;
}

void sub_1B648CFC8(uint64_t a1, simd_float4x4 *a2, uint64_t a3, uint64_t a4)
{
  *a2 = __invert_f4(*(simd_float4x4 *)(a4 + 13152));
}

__n128 sub_1B648D004(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  int v6 = *(_DWORD *)(a4 + 16424);
  if ((v6 & 2) == 0)
  {
    *(_DWORD *)(a4 + 16424) = v6 | 2;
    if (a6)
    {
      uint64_t v7 = 0;
      long long v8 = *(_OWORD *)(a4 + 13152);
      long long v9 = *(_OWORD *)(a4 + 13168);
      long long v10 = *(_OWORD *)(a4 + 13184);
      long long v11 = *(_OWORD *)(a4 + 13200);
      do
      {
        uint64_t v12 = 0;
        uint64_t v13 = (float32x4_t *)(a4 + 592 + 784 * v7);
        float32x4_t v14 = *v13;
        float32x4_t v15 = v13[1];
        float32x4_t v16 = v13[2];
        float32x4_t v17 = v13[3];
        v26[0] = v8;
        v26[1] = v9;
        v26[2] = v10;
        v26[3] = v11;
        do
        {
          v27[v12] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(v26[v12])), v15, *(float32x2_t *)&v26[v12], 1), v16, (float32x4_t)v26[v12], 2), v17, (float32x4_t)v26[v12], 3);
          ++v12;
        }
        while (v12 != 4);
        long long v18 = v27[1];
        long long v19 = v27[2];
        long long v20 = v27[3];
        uint64_t v21 = (_OWORD *)(a4 + 14304 + (v7 << 6));
        *uint64_t v21 = v27[0];
        v21[1] = v18;
        v21[2] = v19;
        v21[3] = v20;
        ++v7;
      }
      while (v7 != a6);
    }
  }
  uint64_t v22 = a4 + ((unint64_t)a5 << 6);
  __n128 result = *(__n128 *)(v22 + 14304);
  long long v24 = *(_OWORD *)(v22 + 14320);
  long long v25 = *(_OWORD *)(v22 + 14352);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v22 + 14336);
  *(_OWORD *)(a2 + 48) = v25;
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v24;
  return result;
}

void sub_1B648D0D8(uint64_t a1, simd_float4x4 *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  int v6 = *(_DWORD *)(a4 + 16424);
  if ((v6 & 2) == 0)
  {
    *(_DWORD *)(a4 + 16424) = v6 | 2;
    if (a6)
    {
      uint64_t v7 = 0;
      long long v8 = *(_OWORD *)(a4 + 13152);
      long long v9 = *(_OWORD *)(a4 + 13168);
      long long v10 = *(_OWORD *)(a4 + 13184);
      long long v11 = *(_OWORD *)(a4 + 13200);
      do
      {
        uint64_t v12 = 0;
        uint64_t v13 = (float32x4_t *)(a4 + 592 + 784 * v7);
        float32x4_t v14 = *v13;
        float32x4_t v15 = v13[1];
        float32x4_t v16 = v13[2];
        float32x4_t v17 = v13[3];
        v22[0] = v8;
        v22[1] = v9;
        v22[2] = v10;
        long long v22[3] = v11;
        do
        {
          v23[v12] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(v22[v12])), v15, *(float32x2_t *)&v22[v12], 1), v16, (float32x4_t)v22[v12], 2), v17, (float32x4_t)v22[v12], 3);
          ++v12;
        }
        while (v12 != 4);
        long long v18 = v23[1];
        long long v19 = v23[2];
        long long v20 = v23[3];
        uint64_t v21 = (_OWORD *)(a4 + 14304 + (v7 << 6));
        *uint64_t v21 = v23[0];
        v21[1] = v18;
        v21[2] = v19;
        v21[3] = v20;
        ++v7;
      }
      while (v7 != a6);
    }
  }
  *a2 = __invert_f4(*(simd_float4x4 *)(a4 + ((unint64_t)a5 << 6) + 14304));
}

__n128 sub_1B648D1CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  int v6 = (int *)(a4 + 16424);
  int v7 = *(_DWORD *)(a4 + 16424);
  if ((v7 & 1) == 0)
  {
    *int v6 = v7 | 1;
    if ((v7 & 2) == 0)
    {
      *int v6 = v7 | 3;
      if (!a6) {
        goto LABEL_11;
      }
      uint64_t v8 = 0;
      long long v9 = *(_OWORD *)(a4 + 13152);
      long long v10 = *(_OWORD *)(a4 + 13168);
      long long v11 = *(_OWORD *)(a4 + 13184);
      long long v12 = *(_OWORD *)(a4 + 13200);
      do
      {
        uint64_t v13 = 0;
        float32x4_t v14 = (float32x4_t *)(a4 + 592 + 784 * v8);
        float32x4_t v15 = *v14;
        float32x4_t v16 = v14[1];
        float32x4_t v17 = v14[2];
        float32x4_t v18 = v14[3];
        v47[0] = v9;
        v47[1] = v10;
        v47[2] = v11;
        v47[3] = v12;
        do
        {
          v48[v13] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v15, COERCE_FLOAT(v47[v13])), v16, *(float32x2_t *)&v47[v13], 1), v17, (float32x4_t)v47[v13], 2), v18, (float32x4_t)v47[v13], 3);
          ++v13;
        }
        while (v13 != 4);
        long long v19 = v48[1];
        long long v20 = v48[2];
        long long v21 = v48[3];
        uint64_t v22 = (_OWORD *)(a4 + 14304 + (v8 << 6));
        *uint64_t v22 = v48[0];
        v22[1] = v19;
        v22[2] = v20;
        long long v22[3] = v21;
        ++v8;
      }
      while (v8 != a6);
    }
    if (a6)
    {
      uint64_t v23 = a4 + 13280;
      uint64_t v24 = a6;
      __asm { FMOV            V0.4S, #1.0 }
      do
      {
        float32x4_t v30 = *(float32x4_t *)(v23 + 1024);
        float32x4_t v31 = *(float32x4_t *)(v23 + 1040);
        float32x4_t v32 = *(float32x4_t *)(v23 + 1056);
        long long v33 = *(_OWORD *)(v23 + 1072);
        int32x4_t v34 = (int32x4_t)vmulq_f32(v30, v30);
        int32x4_t v35 = (int32x4_t)vmulq_f32(v31, v31);
        int32x4_t v36 = (int32x4_t)vmulq_f32(v32, v32);
        int32x4_t v37 = vzip2q_s32(v34, v36);
        float32x4_t v38 = (float32x4_t)vzip1q_s32(vzip1q_s32(v34, v36), v35);
        float32x4_t v39 = (float32x4_t)vtrn2q_s32(v34, v35);
        v39.i32[2] = v36.i32[1];
        float32x4_t v40 = vaddq_f32((float32x4_t)vzip1q_s32(v37, vdupq_laneq_s32(v35, 2)), vaddq_f32(v38, v39));
        int32x4_t v41 = vceqzq_f32(v40);
        v41.i32[3] = 0;
        float32x4_t v42 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v41), (int8x16_t)v40, (int8x16_t)vdivq_f32(_Q0, v40));
        *(float32x4_t *)uint64_t v23 = vmulq_n_f32(v30, v42.f32[0]);
        *(float32x4_t *)(v23 + 16) = vmulq_lane_f32(v31, *(float32x2_t *)v42.f32, 1);
        *(float32x4_t *)(v23 + 32) = vmulq_laneq_f32(v32, v42, 2);
        *(_OWORD *)(v23 + 48) = v33;
        v23 += 64;
        --v24;
      }
      while (v24);
    }
  }
LABEL_11:
  uint64_t v43 = a4 + ((unint64_t)a5 << 6);
  __n128 result = *(__n128 *)(v43 + 13280);
  long long v45 = *(_OWORD *)(v43 + 13296);
  long long v46 = *(_OWORD *)(v43 + 13328);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v43 + 13312);
  *(_OWORD *)(a2 + 48) = v46;
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v45;
  return result;
}

__n128 sub_1B648D334(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  int v6 = *(_DWORD *)(a4 + 16424);
  if ((v6 & 4) == 0)
  {
    *(_DWORD *)(a4 + 16424) = v6 | 4;
    if (a6)
    {
      uint64_t v7 = 0;
      long long v8 = *(_OWORD *)(a4 + 13152);
      long long v9 = *(_OWORD *)(a4 + 13168);
      long long v10 = *(_OWORD *)(a4 + 13184);
      long long v11 = *(_OWORD *)(a4 + 13200);
      do
      {
        uint64_t v12 = 0;
        uint64_t v13 = (float32x4_t *)(a4 + 592 + 784 * v7);
        float32x4_t v14 = v13[12];
        float32x4_t v15 = v13[13];
        float32x4_t v16 = v13[14];
        float32x4_t v17 = v13[15];
        v26[0] = v8;
        v26[1] = v9;
        v26[2] = v10;
        v26[3] = v11;
        do
        {
          v27[v12] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(v26[v12])), v15, *(float32x2_t *)&v26[v12], 1), v16, (float32x4_t)v26[v12], 2), v17, (float32x4_t)v26[v12], 3);
          ++v12;
        }
        while (v12 != 4);
        long long v18 = v27[1];
        long long v19 = v27[2];
        long long v20 = v27[3];
        long long v21 = (_OWORD *)(a4 + 15328 + (v7 << 6));
        *long long v21 = v27[0];
        v21[1] = v18;
        v21[2] = v19;
        v21[3] = v20;
        ++v7;
      }
      while (v7 != a6);
    }
  }
  uint64_t v22 = a4 + ((unint64_t)a5 << 6);
  __n128 result = *(__n128 *)(v22 + 15328);
  long long v24 = *(_OWORD *)(v22 + 15344);
  long long v25 = *(_OWORD *)(v22 + 15376);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v22 + 15360);
  *(_OWORD *)(a2 + 48) = v25;
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v24;
  return result;
}

__n128 sub_1B648D408(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(a4 + 13216);
  long long v5 = *(_OWORD *)(a4 + 13232);
  long long v6 = *(_OWORD *)(a4 + 13264);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a4 + 13248);
  *(_OWORD *)(a2 + 48) = v6;
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v5;
  return result;
}

float sub_1B648D424(uint64_t a1, float *a2, uint64_t a3, uint64_t a4)
{
  float result = *(float *)(a4 + 1048);
  *a2 = result;
  return result;
}

void sub_1B648D430(uint64_t a1, simd_float4x4 *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  int v6 = *(_DWORD *)(a4 + 16424);
  if ((v6 & 4) == 0)
  {
    *(_DWORD *)(a4 + 16424) = v6 | 4;
    if (a6)
    {
      uint64_t v7 = 0;
      long long v8 = *(_OWORD *)(a4 + 13152);
      long long v9 = *(_OWORD *)(a4 + 13168);
      long long v10 = *(_OWORD *)(a4 + 13184);
      long long v11 = *(_OWORD *)(a4 + 13200);
      do
      {
        uint64_t v12 = 0;
        uint64_t v13 = (float32x4_t *)(a4 + 592 + 784 * v7);
        float32x4_t v14 = v13[12];
        float32x4_t v15 = v13[13];
        float32x4_t v16 = v13[14];
        float32x4_t v17 = v13[15];
        v22[0] = v8;
        v22[1] = v9;
        v22[2] = v10;
        long long v22[3] = v11;
        do
        {
          v23[v12] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(v22[v12])), v15, *(float32x2_t *)&v22[v12], 1), v16, (float32x4_t)v22[v12], 2), v17, (float32x4_t)v22[v12], 3);
          ++v12;
        }
        while (v12 != 4);
        long long v18 = v23[1];
        long long v19 = v23[2];
        long long v20 = v23[3];
        long long v21 = (_OWORD *)(a4 + 15328 + (v7 << 6));
        *long long v21 = v23[0];
        v21[1] = v18;
        v21[2] = v19;
        v21[3] = v20;
        ++v7;
      }
      while (v7 != a6);
    }
  }
  *a2 = __invert_f4(*(simd_float4x4 *)(a4 + ((unint64_t)a5 << 6) + 15328));
}

__n128 sub_1B648D524(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4)
{
  sub_1B649F7D4(a4[1026].i64[0], &v9);
  float32x4_t v6 = v9;
  float32x4_t v7 = v10;
  a4[1022] = vsubq_f32(v9, v10);
  a4[1023] = vaddq_f32(v6, v7);
  __n128 result = (__n128)a4[1023];
  *(float32x4_t *)a2 = a4[1022];
  *(__n128 *)(a2 + 16) = result;
  return result;
}

__n128 sub_1B648D57C(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4)
{
  sub_1B649F7D4(a4[1026].i64[0], &v13);
  float32x4_t v6 = a4[822];
  float32x4_t v7 = a4[823];
  float32x4_t v8 = a4[824];
  float32x4_t v9 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a4[825], v8, v13, 2), v7, *(float32x2_t *)v13.f32, 1), v6, v13.f32[0]);
  v9.i32[3] = v13.i32[3];
  float32x4_t v10 = (float32x4_t)v14;
  v10.i32[1] = v14.i32[0];
  v10.i32[2] = v14.i32[0];
  float32x4_t v11 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v14.i8, 1), v14), vabsq_f32(v7)), v10, vabsq_f32(v6)), (float32x4_t)vzip2q_s32(vtrn1q_s32(v14, v14), v14), vabsq_f32(v8));
  a4[1024] = vsubq_f32(v9, v11);
  a4[1025] = vaddq_f32(v11, v9);
  __n128 result = (__n128)a4[1025];
  *(float32x4_t *)a2 = a4[1024];
  *(__n128 *)(a2 + 16) = result;
  return result;
}

void sub_1B648D628(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a4 + 16416);
  if (v9) {
    sub_1B64A2F68(v9, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    float v10 = 1.0;
  }
  *a2 = v10;
}

__n128 sub_1B648D660(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  float32x4_t v11 = (void *)sub_1B63C2948(*(void *)(a4 + 528), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = sub_1B647E10C((uint64_t)v11);
  if (v12 == 3)
  {
    sub_1B647DD14(v11, *(unsigned int **)(a4 + 16432), &v34, v13, v14, v15, v16, v17, *(int32x4_t *)(a4 + 13200));
    if (v9 != 112) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. size mismatch for sh coefficients", v26, v27, v28, v29, v30, v31, (uint64_t)"size == sizeof(coefs)");
    }
    long long v32 = v39;
    *(_OWORD *)(a2 + 64) = v38;
    *(_OWORD *)(a2 + 80) = v32;
    *(_OWORD *)(a2 + 96) = v40;
    long long v33 = v35;
    *(float32x4_t *)a2 = v34;
    *(_OWORD *)(a2 + 16) = v33;
    __n128 result = v37;
    *(_OWORD *)(a2 + 32) = v36;
    *(__n128 *)(a2 + 48) = result;
  }
  else if (v12 == 2)
  {
    sub_1B647DBA8((uint64_t)v11, *(unsigned int **)(a4 + 16432), &v34, v13, v14, v15, v16, v17, *(int32x4_t *)(a4 + 13200));
    if (v9 != 48) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. size mismatch for sh coefficients", v19, v20, v21, v22, v23, v24, (uint64_t)"size == sizeof(coefs)");
    }
    long long v25 = v35;
    *(float32x4_t *)a2 = v34;
    *(_OWORD *)(a2 + 16) = v25;
    result.n128_u64[0] = v36;
    *(_OWORD *)(a2 + 32) = v36;
  }
  return result;
}

uint64_t sub_1B648D75C(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B64A3808(*(void *)(a4 + 16416), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  *a2 = result;
  return result;
}

void sub_1B648D788(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(char *)(a2 + 9);
  uint64_t v7 = *(char *)(a2 + 10);
  float32x4_t v8 = objc_msgSend_bufferAtIndices_(*(void **)(a3 + 18144), (const char *)a2, *(unsigned __int16 *)(a2 + 9), a4);
  if (objc_msgSend_buffer(v8, v9, v10, v11))
  {
    uint64_t v15 = *(void **)(a2 + 16);
    if (v15)
    {
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      uint64_t v16 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v12, (uint64_t)&v39, (uint64_t)v46, 16);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)v40;
        do
        {
          for (uint64_t i = 0; i != v17; ++i)
          {
            if (*(void *)v40 != v18) {
              objc_enumerationMutation(v15);
            }
            objc_msgSend_useResource_usage_stages_(*(void **)(*(void *)(a3 + 248) + 16), v12, *(void *)(*((void *)&v39 + 1) + 8 * i), 4, 255);
          }
          uint64_t v17 = objc_msgSend_countByEnumeratingWithState_objects_count_(v15, v12, (uint64_t)&v39, (uint64_t)v46, 16);
        }
        while (v17);
      }
    }
    uint64_t v20 = *(void *)(a3 + 248);
    uint64_t v21 = objc_msgSend_buffer(v8, v12, v13, v14);
    uint64_t v26 = objc_msgSend_offset(v8, v22, v23, v24);
    int v27 = *(unsigned __int16 *)(a2 + 9);
    if ((_BYTE)v27 != 0xFF) {
      objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v20 + 16), v25, v21, v26, (char)v27);
    }
    if ((~v27 & 0xFF00) != 0) {
      objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v20 + 16), v25, v21, v26, (uint64_t)(__int16)v27 >> 8);
    }
  }
  else if (v6 != -1 {
         && !objc_msgSend_vertexBufferBoundAt_(*(void **)(*(void *)(a3 + 248) + 16), v12, v6, v14)
  }
         || v7 != -1
         && !objc_msgSend_fragmentBufferBoundAt_(*(void **)(*(void *)(a3 + 248) + 16), v12, v7, v14))
  {
    uint64_t v29 = *(void *)(a3 + 248);
    uint64_t v30 = objc_msgSend_binding((void *)a2, v12, v28, v14);
    uint64_t v34 = objc_msgSend_bufferDataSize(v30, v31, v32, v33);
    int v35 = *(unsigned __int16 *)(a2 + 9);
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    sub_1B649F150(*(void *)(v29 + 24), v34, &v43);
    bzero(v43, v34);
    uint64_t v37 = v44;
    uint64_t v38 = v45;
    if ((_BYTE)v35 != 0xFF) {
      objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v29 + 16), v36, v44, v45, (char)v35);
    }
    if ((~v35 & 0xFF00) != 0) {
      objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v29 + 16), v36, v37, v38, (uint64_t)(__int16)v35 >> 8);
    }
  }
}

uint64_t sub_1B648D9F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_textureAtIndices_(*(void **)(a3 + 18144), (const char *)a2, *(unsigned __int16 *)(a2 + 9), a4);
  uint64_t v10 = (void *)result;
  if (!result)
  {
    uint64_t v11 = objc_msgSend_binding((void *)a2, v7, v8, v9);
    uint64_t v15 = objc_msgSend_textureType(v11, v12, v13, v14);
    uint64_t v10 = objc_msgSend_defaultTextureForTextureType_(*(void **)(a3 + 112), v16, v15, v17);
    uint64_t result = (uint64_t)objc_loadWeak((id *)(a3 + 18504));
    if (result)
    {
      uint64_t v18 = (void *)result;
      uint64_t v19 = objc_msgSend_stringWithFormat_(NSString, v7, @"Unable to find texture for binding %@ and shadable %@", v9, a2, *(void *)(a3 + 18144));
      uint64_t result = objc_msgSend_renderContext_didFallbackToDefaultTextureForSource_message_(v18, v20, a3, a2, v19);
    }
  }
  uint64_t v21 = *(void *)(a3 + 248);
  __int16 v22 = *(_WORD *)(a2 + 9);
  if ((_BYTE)v22 != 0xFF) {
    uint64_t result = sub_1B6491380(*(void *)(a3 + 248), v10, (char)v22, v9);
  }
  if ((~v22 & 0xFF00) != 0) {
    uint64_t result = sub_1B63C6ED0(v21, v10, (uint64_t)v22 >> 8, v9);
  }
  uint64_t v23 = *(unsigned __int8 *)(a2 + 11);
  uint64_t v24 = *(unsigned __int8 *)(a2 + 12);
  if (v24 != 255 || v23 != 255)
  {
    uint64_t result = objc_msgSend_samplerAtIndices_(*(void **)(a3 + 18144), v7, v23 | (v24 << 8), v9);
    uint64_t v26 = result;
    uint64_t v27 = *(void *)(a3 + 248);
    if (v23 != 255) {
      uint64_t result = objc_msgSend_setVertexSamplerState_atIndex_(*(void **)(v27 + 16), v25, result, (char)v23);
    }
    if (v24 != 255)
    {
      uint64_t v28 = *(void **)(v27 + 16);
      return objc_msgSend_setFragmentSamplerState_atIndex_(v28, v25, v26, (char)v24);
    }
  }
  return result;
}

uint64_t sub_1B648DB88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_samplerAtIndices_(*(void **)(a3 + 18144), (const char *)a2, *(unsigned __int16 *)(a2 + 9), a4);
  uint64_t v8 = result;
  uint64_t v9 = *(void *)(a3 + 248);
  int v10 = *(unsigned __int16 *)(a2 + 9);
  if ((_BYTE)v10 != 0xFF) {
    uint64_t result = objc_msgSend_setVertexSamplerState_atIndex_(*(void **)(v9 + 16), v7, result, (char)v10);
  }
  if ((~v10 & 0xFF00) != 0)
  {
    uint64_t v11 = *(void **)(v9 + 16);
    return objc_msgSend_setFragmentSamplerState_atIndex_(v11, v7, v8, (uint64_t)(__int16)v10 >> 8);
  }
  return result;
}

void sub_1B648DC30(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3[31];
  uint64_t v4 = a3[2137];
  uint64_t v5 = a3[2138];
  int v6 = *(unsigned __int16 *)(a2 + 9);
  if (*(unsigned char *)(a2 + 9) != 0xFF) {
    objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v3 + 16), (const char *)a2, a3[2137], v5, (char)v6);
  }
  if ((~v6 & 0xFF00) != 0)
  {
    uint64_t v7 = *(void **)(v3 + 16);
    objc_msgSend_setFragmentBuffer_offset_atIndex_(v7, (const char *)a2, v4, v5, (uint64_t)(__int16)v6 >> 8);
  }
}

uint64_t sub_1B648DCCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v9 = *(_DWORD *)(a3 + 17112);
  int v3 = *(unsigned __int16 *)(a2 + 9);
  uint64_t v4 = *(void *)(a3 + 248);
  int v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t result = (uint64_t)sub_1B649F334(*(void *)(v4 + 24), &v9, 4uLL, &v10);
  uint64_t v7 = v11;
  uint64_t v8 = v12;
  if ((_BYTE)v3 != 0xFF) {
    uint64_t result = objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v4 + 16), v6, v11, v12, (char)v3);
  }
  if ((~v3 & 0xFF00) != 0) {
    return objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v4 + 16), v6, v7, v8, (uint64_t)(__int16)v3 >> 8);
  }
  return result;
}

uint64_t sub_1B648DD80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { FMOV            V0.4S, #1.0 }
  long long v23 = _Q0;
  uint64_t v10 = *(void *)(a3 + 18104);
  if (v10)
  {
    float v11 = *(float *)(a3 + 1268) * *(float *)(a3 + 740);
    *(float *)&unsigned int v19 = sub_1B63D11B8(v10) * v11;
    float v18 = sub_1B63D11C8(*(void *)(a3 + 18104));
    DWORD2(v23) = sub_1B63D11D8(*(void *)(a3 + 18104));
    *(void *)&long long v23 = __PAIR64__(LODWORD(v18), v19);
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t result = (uint64_t)sub_1B649F334(*(void *)(a3 + 384), &v23, 0x10uLL, &v20);
  uint64_t v14 = *(void *)(a3 + 248);
  uint64_t v16 = v21;
  uint64_t v15 = v22;
  int v17 = *(unsigned __int16 *)(a2 + 9);
  if ((_BYTE)v17 != 0xFF) {
    uint64_t result = objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v14 + 16), v13, v21, v22, (char)v17);
  }
  if ((~v17 & 0xFF00) != 0) {
    return objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v14 + 16), v13, v16, v15, (uint64_t)(__int16)v17 >> 8);
  }
  return result;
}

void sub_1B648DE7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a3 + 248);
  uint64_t v5 = *(void **)(a3 + 17000);
  __int16 v6 = *(_WORD *)(a2 + 9);
  if (*(unsigned char *)(a2 + 9) != 0xFF) {
    sub_1B6491380(v4, v5, (char)v6, a4);
  }
  if ((~v6 & 0xFF00) != 0)
  {
    sub_1B63C6ED0(v4, v5, (uint64_t)v6 >> 8, a4);
  }
}

void sub_1B648DF0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a3 + 248);
  uint64_t v5 = *(void **)(a3 + 17008);
  __int16 v6 = *(_WORD *)(a2 + 9);
  if (*(unsigned char *)(a2 + 9) != 0xFF) {
    sub_1B6491380(v4, v5, (char)v6, a4);
  }
  if ((~v6 & 0xFF00) != 0)
  {
    sub_1B63C6ED0(v4, v5, (uint64_t)v6 >> 8, a4);
  }
}

void *sub_1B648DF9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_areaLightPrecomputedDataTexture(*(void **)(a3 + 112), (const char *)a2, a3, a4);
  uint64_t v8 = result;
  uint64_t v9 = *(void *)(a3 + 248);
  __int16 v10 = *(_WORD *)(a2 + 9);
  if ((_BYTE)v10 != 0xFF) {
    uint64_t result = (void *)sub_1B6491380(v9, result, (char)v10, v7);
  }
  if ((~v10 & 0xFF00) != 0)
  {
    return (void *)sub_1B63C6ED0(v9, v8, (uint64_t)v10 >> 8, v7);
  }
  return result;
}

void sub_1B648E03C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a3 + 512);
  if (!v5)
  {
    sub_1B63E0E48(v9, 32, 1.0, 1.0, 1.0);
    uint64_t v5 = objc_msgSend_newBufferWithBytes_length_options_(*(void **)(a3 + 120), v6, (uint64_t)v9, 512, 0);
    *(void *)(a3 + 512) = v5;
  }
  uint64_t v7 = *(void *)(a3 + 248);
  int v8 = *(unsigned __int16 *)(a2 + 9);
  if ((_BYTE)v8 != 0xFF) {
    objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v7 + 16), (const char *)a2, v5, 0, (char)v8);
  }
  if ((~v8 & 0xFF00) != 0) {
    objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v7 + 16), (const char *)a2, v5, 0, (uint64_t)(__int16)v8 >> 8);
  }
}

void sub_1B648E134(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = sub_1B6475290(*(void *)(a4 + 18152), a2, 0, a4, a5, a6, a7, a8);
  if (v13)
  {
    uint64_t v14 = objc_msgSend_textureForMaterialProperty_((void *)a4, v10, v13, v12);
    uint64_t v63 = (uint64_t)v14;
    uint64_t v22 = sub_1B64765F4(v13, v15, v16, v17, v18, v19, v20, v21);
    if (v14) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  long long v23 = objc_msgSend_binding((void *)a3, v10, v11, v12);
  uint64_t v27 = objc_msgSend_textureType(v23, v24, v25, v26);
  uint64_t v14 = objc_msgSend_defaultTextureForTextureType_(*(void **)(a4 + 112), v28, v27, v29);
  uint64_t v63 = (uint64_t)v14;
  if (!v14) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v30, v31, v32, v33, v34, v35, (uint64_t)"texture");
  }
  Weauint64_t k = objc_loadWeak((id *)(a4 + 18504));
  if (Weak)
  {
    uint64_t v37 = Weak;
    uint64_t v62 = a3;
    uint64_t v38 = objc_msgSend_stringWithFormat_(NSString, v10, @"Unable to find texture for binding %@ and effect materialProperty %@", v12);
    objc_msgSend_renderContext_didFallbackToDefaultTextureForSource_message_(v37, v39, a4, a3, v38);
  }
LABEL_9:
  if (!v22) {
    uint64_t v22 = sub_1B643DF24();
  }
  uint64_t v40 = *(char *)(a3 + 11);
  uint64_t v41 = *(char *)(a3 + 12);
  if (objc_msgSend_pixelFormat(v14, v10, v11, v12) == 520 || objc_msgSend_pixelFormat(v14, v42, v43, v44) == 500)
  {
    uint64_t v52 = sub_1B653E820(*(void *)(a4 + 112), v22);
    uint64_t v53 = *(void **)(*(void *)(a4 + 248) + 16);
    if (*(unsigned __int8 *)(a3 + 9) != 255) {
      sub_1B63F2F54(16, @"Unreachable code: Not supported", v46, v47, v48, v49, v50, v51, v62);
    }
    if (*(unsigned __int8 *)(a3 + 10) != 255)
    {
      sub_1B64D95D4(*(__IOSurface **)(a4 + 240), (const char *)&v63, 1, v47);
      objc_msgSend_setFragmentTexture_atTextureIndex_samplerState_atSamplerIndex_(v53, v54, v63, *(char *)(a3 + 10), v52, v41);
    }
  }
  else
  {
    uint64_t v55 = *(void *)(a4 + 248);
    __int16 v56 = *(_WORD *)(a3 + 9);
    if ((_BYTE)v56 != 0xFF) {
      sub_1B6491380(*(void *)(a4 + 248), v14, (char)v56, v45);
    }
    if ((~v56 & 0xFF00) != 0) {
      sub_1B63C6ED0(v55, v14, (uint64_t)v56 >> 8, v45);
    }
    if (v41 != -1 || v40 != -1)
    {
      uint64_t v59 = sub_1B653E820(*(void *)(a4 + 112), v22);
      uint64_t v60 = *(void *)(a4 + 248);
      if (v40 != -1) {
        objc_msgSend_setVertexSamplerState_atIndex_(*(void **)(v60 + 16), v58, (uint64_t)v59, v40);
      }
      if (v41 != -1)
      {
        uint64_t v61 = *(void **)(v60 + 16);
        objc_msgSend_setFragmentSamplerState_atIndex_(v61, v58, (uint64_t)v59, v41);
      }
    }
  }
}

uint64_t sub_1B648E3C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(char *)(a1 + 40), a2, a3);
}

void sub_1B648E3E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a3 + 17120);
  if (v4)
  {
    uint64_t v5 = *(void *)(a3 + 248);
    __int16 v6 = *(_WORD *)(a2 + 9);
    if (*(unsigned char *)(a2 + 9) != 0xFF) {
      sub_1B6491380(v5, v4, (char)v6, a4);
    }
    if ((~v6 & 0xFF00) != 0)
    {
      sub_1B63C6ED0(v5, v4, (uint64_t)v6 >> 8, a4);
    }
  }
}

void sub_1B648E47C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a3 + 8 * *(void *)(a1 + 32);
  uint64_t v7 = *(void **)(v6 + 17128);
  if (v7)
  {
    uint64_t v8 = *(void *)(v6 + 17192);
  }
  else
  {
    uint64_t v10 = objc_msgSend_binding((void *)a2, (const char *)a2, a3, a4);
    uint64_t v14 = objc_msgSend_textureType(v10, v11, v12, v13);
    uint64_t v7 = objc_msgSend_defaultTextureForTextureType_(*(void **)(a3 + 112), v15, v14, v16);
    Weauint64_t k = objc_loadWeak((id *)(a3 + 18504));
    if (Weak)
    {
      long long v23 = Weak;
      uint64_t v24 = objc_msgSend_stringWithFormat_(NSString, (const char *)a2, @"Unable to find IES or gobo texture for binding %@", a4, a2);
      objc_msgSend_renderContext_didFallbackToDefaultTextureForSource_message_(v23, v25, a3, a2, v24);
    }
    uint64_t v8 = *(void *)(a3 + 8 * *(void *)(a1 + 32) + 17192);
    if (!v7) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v18, a4, v19, v20, v21, v22, (uint64_t)"texture");
    }
  }
  uint64_t v26 = *(void *)(a3 + 248);
  __int16 v27 = *(_WORD *)(a2 + 9);
  if (*(unsigned char *)(a2 + 9) != 0xFF) {
    sub_1B6491380(*(void *)(a3 + 248), v7, (char)v27, a4);
  }
  if ((~v27 & 0xFF00) != 0) {
    sub_1B63C6ED0(v26, v7, (uint64_t)v27 >> 8, a4);
  }
  int v28 = *(unsigned __int8 *)(a2 + 11);
  uint64_t v29 = *(char *)(a2 + 12);
  if (v29 != -1 || v28 != 255)
  {
    uint64_t v30 = *(void *)(a3 + 248);
    if ((char)v28 != -1) {
      objc_msgSend_setVertexSamplerState_atIndex_(*(void **)(v30 + 16), (const char *)a2, v8, (char)v28);
    }
    if (v29 != -1)
    {
      uint64_t v31 = *(void **)(v30 + 16);
      objc_msgSend_setFragmentSamplerState_atIndex_(v31, (const char *)a2, v8, v29);
    }
  }
}

__n128 sub_1B648E628(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(__n128 **)(a4 + 8 * *(void *)(a1 + 32) + 16568);
  __n128 result = *v4;
  *a2 = *v4;
  return result;
}

uint64_t sub_1B648E640(uint64_t result, float32x4_t *a2, uint64_t a3, float32x4_t *a4)
{
  if (a4[1048].i8[0])
  {
    float32x4_t v4 = *(float32x4_t *)(a4[1035].i64[*(void *)(result + 32) + 1] + 16);
    float32x4_t v5 = vaddq_f32(a4[1043], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a4[1040], v4.f32[0]), a4[1041], *(float32x2_t *)v4.f32, 1), a4[1042], v4, 2));
  }
  else
  {
    float32x4_t v5 = *(float32x4_t *)(a4[1035].i64[*(void *)(result + 32) + 1] + 16);
  }
  *a2 = v5;
  return result;
}

uint64_t sub_1B648E698(uint64_t result, float32x4_t *a2, uint64_t a3, float32x4_t *a4)
{
  if (a4[1048].i8[0])
  {
    float32x4_t v4 = *(float32x4_t *)(a4[1035].i64[*(void *)(result + 32) + 1] + 32);
    float32x4_t v5 = vmlaq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a4[1040], v4.f32[0]), a4[1041], *(float32x2_t *)v4.f32, 1), a4[1042], v4, 2), (float32x4_t)0, a4[1043]);
  }
  else
  {
    float32x4_t v5 = *(float32x4_t *)(a4[1035].i64[*(void *)(result + 32) + 1] + 32);
  }
  *a2 = v5;
  return result;
}

__n128 sub_1B648E6F4(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(*(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568) + 64);
  *a2 = result;
  return result;
}

__n128 sub_1B648E70C(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(*(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568) + 48);
  *a2 = result;
  return result;
}

__n128 sub_1B648E724(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568);
  __n128 result = *(__n128 *)(v4 + 128);
  long long v6 = *(_OWORD *)(v4 + 144);
  long long v7 = *(_OWORD *)(v4 + 160);
  long long v8 = *(_OWORD *)(v4 + 176);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v6;
  *(_OWORD *)(a2 + 32) = v7;
  *(_OWORD *)(a2 + 48) = v8;
  return result;
}

__n128 sub_1B648E744(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(*(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568) + 80);
  *a2 = result;
  return result;
}

__n128 sub_1B648E75C(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(*(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568) + 96);
  *a2 = result;
  return result;
}

void *sub_1B648E774(uint64_t a1, void *__dst, uint64_t __n, simd_float4x4 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  size_t v11 = __n;
  if (__n >= 0x101) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Cannot set more than 4 matrices for cascade shadows", __n, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"size <= (sizeof(simd_float4x4) * CFX_MAX_CASCADE_COUNT)");
  }
  if (a4[262].columns[0].i8[0])
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      uint64_t v13 = (float32x4_t *)(a4[258].columns[3].i64[*(void *)(a1 + 32) + 1] + (i << 6));
      float32x4_t v23 = v13[8];
      float32x4_t v24 = v13[9];
      float32x4_t v21 = v13[11];
      float32x4_t v22 = v13[10];
      simd_float4x4 v30 = __invert_f4(a4[260]);
      uint64_t v14 = 0;
      simd_float4x4 v25 = v30;
      do
      {
        v26[v14] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v23, COERCE_FLOAT(*(_OWORD *)&v25.columns[v14])), v24, *(float32x2_t *)v25.columns[v14].f32, 1), v22, (float32x4_t)v25.columns[v14], 2), v21, (float32x4_t)v25.columns[v14], 3);
        ++v14;
      }
      while (v14 != 4);
      long long v15 = v26[1];
      long long v16 = v26[2];
      long long v17 = v26[3];
      uint64_t v18 = &__src[64 * i];
      *uint64_t v18 = v26[0];
      v18[1] = v15;
      void v18[2] = v16;
      v18[3] = v17;
    }
    return memcpy(__dst, __src, v11);
  }
  else
  {
    uint64_t v20 = (const void *)(a4[258].columns[3].i64[*(void *)(a1 + 32) + 1] + 128);
    return memcpy(__dst, v20, v11);
  }
}

float sub_1B648E93C(uint64_t a1, float *a2, uint64_t a3, uint64_t a4)
{
  float result = *(float *)(*(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568) + 116);
  *a2 = result;
  return result;
}

__n128 sub_1B648E954(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(*(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568) + 384);
  *a2 = result;
  return result;
}

__n128 sub_1B648E96C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568);
  __n128 result = *(__n128 *)(v4 + 128);
  long long v6 = *(_OWORD *)(v4 + 144);
  long long v7 = *(_OWORD *)(v4 + 160);
  long long v8 = *(_OWORD *)(v4 + 176);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v6;
  *(_OWORD *)(a2 + 32) = v7;
  *(_OWORD *)(a2 + 48) = v8;
  return result;
}

__n128 sub_1B648E98C(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  __n128 result = *(__n128 *)(*(void *)(a4 + 8 * *(void *)(a1 + 32) + 16568) + 384);
  *a2 = result;
  return result;
}

void sub_1B648E9A4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a3[2157];
  uint64_t v11 = a3[2158];
  uint64_t v12 = a3[*(void *)(a1 + 32) + 2159];
  if (!v10) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"buffer");
  }
  uint64_t v13 = v12 + v11;
  uint64_t v14 = a3[31];
  int v15 = *(unsigned __int16 *)(a2 + 9);
  if ((_BYTE)v15 != 0xFF) {
    objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v14 + 16), (const char *)a2, v10, v13, (char)v15);
  }
  if ((~v15 & 0xFF00) != 0)
  {
    long long v16 = *(void **)(v14 + 16);
    objc_msgSend_setFragmentBuffer_offset_atIndex_(v16, (const char *)a2, v10, v13, (uint64_t)(__int16)v15 >> 8);
  }
}

void *sub_1B648EA90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = objc_msgSend_specularDFGDiffuseHammonTextureWithRenderContext_(*(void **)(a3 + 112), (const char *)a2, a3, a4);
  long long v8 = result;
  uint64_t v9 = *(void *)(a3 + 248);
  __int16 v10 = *(_WORD *)(a2 + 9);
  if ((_BYTE)v10 != 0xFF) {
    __n128 result = (void *)sub_1B6491380(v9, result, (char)v10, v7);
  }
  if ((~v10 & 0xFF00) != 0)
  {
    return (void *)sub_1B63C6ED0(v9, v8, (uint64_t)v10 >> 8, v7);
  }
  return result;
}

uint64_t sub_1B648EB30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B644558C(*(void *)(a3 + 144), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v11 = sub_1B64B2810(v10, 0);
  if (!v11
    || (uint64_t v19 = v11, !sub_1B6475F88(v11, (uint64_t)v12, v13, v14, v15, v16, v17, v18))
    && !sub_1B6477598(v19, (uint64_t)v12, v20, v14, v21, v22, v23, v24)
    || (uint64_t result = objc_msgSend_radianceTextureForMaterialProperty_((void *)a3, v12, v19, v14),
        (uint64_t v26 = (void *)result) == 0))
  {
    if (!sub_1B64463F8(*(void *)(a3 + 144), (uint64_t)v12, v13, v14, v15, v16, v17, v18)
      || (uint64_t result = objc_msgSend_defaultLightingEnvironmentRadianceTexture(*(void **)(a3 + 112), v27, v28, v14),
          (uint64_t v26 = (void *)result) == 0))
    {
      uint64_t result = objc_msgSend_defaultCubeTexture(*(void **)(a3 + 112), v27, v28, v14);
      uint64_t v26 = (void *)result;
    }
  }
  uint64_t v29 = *(void *)(a3 + 248);
  __int16 v30 = *(_WORD *)(a2 + 9);
  if ((_BYTE)v30 != 0xFF) {
    uint64_t result = sub_1B6491380(v29, v26, (char)v30, v14);
  }
  if ((~v30 & 0xFF00) != 0)
  {
    return sub_1B63C6ED0(v29, v26, (uint64_t)v30 >> 8, v14);
  }
  return result;
}

uint64_t sub_1B648EC2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B644558C(*(void *)(a3 + 144), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v11 = sub_1B64B2810(v10, 0);
  if (!v11
    || (uint64_t v19 = v11, !sub_1B6475F88(v11, (uint64_t)v12, v13, v14, v15, v16, v17, v18))
    && !sub_1B6477598(v19, (uint64_t)v12, v20, v14, v21, v22, v23, v24)
    || (uint64_t result = objc_msgSend_irradianceTextureForMaterialProperty_((void *)a3, v12, v19, v14),
        (uint64_t v26 = (void *)result) == 0))
  {
    if (!sub_1B64463F8(*(void *)(a3 + 144), (uint64_t)v12, v13, v14, v15, v16, v17, v18)
      || (uint64_t result = objc_msgSend_defaultLightingEnvironmentIrradianceTexture(*(void **)(a3 + 112), v27, v28, v14),
          (uint64_t v26 = (void *)result) == 0))
    {
      uint64_t result = objc_msgSend_defaultCubeTexture(*(void **)(a3 + 112), v27, v28, v14);
      uint64_t v26 = (void *)result;
    }
  }
  uint64_t v29 = *(void *)(a3 + 248);
  __int16 v30 = *(_WORD *)(a2 + 9);
  if ((_BYTE)v30 != 0xFF) {
    uint64_t result = sub_1B6491380(v29, v26, (char)v30, v14);
  }
  if ((~v30 & 0xFF00) != 0)
  {
    return sub_1B63C6ED0(v29, v26, (uint64_t)v30 >> 8, v14);
  }
  return result;
}

void sub_1B648ED28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a3 + 17344);
  uint64_t v5 = *(void *)(a3 + 248);
  __int16 v6 = *(_WORD *)(a2 + 9);
  if (*(unsigned char *)(a2 + 9) != 0xFF) {
    sub_1B6491380(v5, v4, (char)v6, a4);
  }
  if ((~v6 & 0xFF00) != 0)
  {
    sub_1B63C6ED0(v5, v4, (uint64_t)v6 >> 8, a4);
  }
}

uint64_t sub_1B648EDB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = (uint64_t)sub_1B6447A60(*(void *)(a3 + 144), @"VFX-SSAO", a3, a4, a5, a6, a7, a8);
  uint64_t v14 = (void *)result;
  if (!result)
  {
    uint64_t v14 = objc_msgSend_defaultTexture(*(void **)(a3 + 112), v11, v12, v13);
    uint64_t result = (uint64_t)objc_loadWeak((id *)(a3 + 18504));
    if (result)
    {
      uint64_t v16 = (void *)result;
      uint64_t v17 = objc_msgSend_stringWithFormat_(NSString, v15, @"Unable to find \"VFX-SSAO\" texture in render graph for binding %@", v13, a2);
      uint64_t result = objc_msgSend_renderContext_didFallbackToDefaultTextureForSource_message_(v16, v18, a3, a2, v17);
    }
  }
  uint64_t v19 = *(void *)(a3 + 248);
  __int16 v20 = *(_WORD *)(a2 + 9);
  if ((_BYTE)v20 != 0xFF) {
    uint64_t result = sub_1B6491380(v19, v14, (char)v20, v13);
  }
  if ((~v20 & 0xFF00) != 0)
  {
    return sub_1B63C6ED0(v19, v14, (uint64_t)v20 >> 8, v13);
  }
  return result;
}

uint64_t sub_1B648EEBC(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v7 = objc_msgSend_frequency(a2, (const char *)a2, a3, (uint64_t)a4);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  void v10[2] = sub_1B648EF5C;
  v10[3] = &unk_1E61429E0;
  v10[4] = a2;
  return objc_msgSend_addResourceBindingsForArgument_frequency_needsRenderResource_block_(a4, v8, a3, v7, 0, v10);
}

uint64_t sub_1B648EF5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_WORD *)(a3 + 317) = *(_WORD *)(a2 + 9);
  uint64_t v10 = *(id **)(a3 + 18176);
  if (v10) {
    sub_1B6583674(v10);
  }
  uint64_t v11 = *(id **)(a3 + 18128);
  if (v11) {
    sub_1B6583674(v11);
  }
  sub_1B644689C(*(void *)(a3 + 144), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = *(uint64_t (**)(void))(objc_msgSend_block(*(void **)(a1 + 32), v12, v13, v14) + 16);

  return v15();
}

void sub_1B648F178(uint64_t a1, uint64_t a2)
{
  if (sub_1B647BC9C(a2))
  {
    uint64_t v11 = sub_1B641E1A8(a2, v4, v5, v6, v7, v8, v9, v10);
    sub_1B65349EC(v11, *(void *)(a1 + 32));
    uint64_t v19 = *(void *)(a1 + 40) + sub_1B6534BD0(v11, v12, v13, v14, v15, v16, v17, v18);
    sub_1B647BC34(a2, v19);
  }
}

void sub_1B648F2E4(uint64_t a1, uint64_t a2)
{
  if (sub_1B647BC9C(a2))
  {
    sub_1B647BC34(a2, 0);
  }
}

void sub_1B6490B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1B6490B98(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commandBuffer");
    if (a3) {
      goto LABEL_3;
    }
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commandEncoder");
    goto LABEL_3;
  }
  if (!a3) {
    goto LABEL_5;
  }
LABEL_3:
  *(void *)(a1 + 8) = a2;
  uint64_t result = objc_msgSend_setEncoder_(*(void **)(a1 + 16), a2, a3, a4);
  *(void *)(a1 + 24) = a4;
  *(_DWORD *)a1 = 1;
  *(unsigned char *)(a1 + 4) = 1;
  *(unsigned char *)(a1 + 32) = 0;
  return result;
}

void sub_1B6490F80(_Unwind_Exception *a1)
{
  sub_1B6491404(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6491380(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = (uint64_t)a2;
  if (a2 && (objc_msgSend_conformsToProtocol_(a2, (const char *)a2, (uint64_t)&unk_1F108B030, a4) & 1) == 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. texture is not a MTLTexture", v6, a4, v7, v8, v9, v10, (uint64_t)"!texture || [texture conformsToProtocol:@protocol(MTLTexture)]");
  }
  sub_1B64D95D4(*(__IOSurface **)(a1 + 8), (const char *)&v13, 1, a4);
  return objc_msgSend_setVertexTexture_atIndex_(*(void **)(a1 + 16), v11, v13, a3);
}

uint64_t sub_1B6491404(uint64_t a1)
{
  int v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      operator delete(v2);
      int v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

char *sub_1B6491450(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (*((void *)v11 + 2) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v11 = (char *)operator new(0xB0uLL);
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = v7;
  *((void *)v11 + 2) = **a4;
  *((void *)v11 + 21) = 0;
  *(_OWORD *)(v11 + 152) = 0u;
  *(_OWORD *)(v11 + 136) = 0u;
  *(_OWORD *)(v11 + 120) = 0u;
  *(_OWORD *)(v11 + 104) = 0u;
  *(_OWORD *)(v11 + 88) = 0u;
  *(_OWORD *)(v11 + 72) = 0u;
  *(_OWORD *)(v11 + 56) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_1B63C8630(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  __int16 v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *(void *)uint64_t v11 = *v20;
LABEL_38:
    *__int16 v20 = v11;
    goto LABEL_39;
  }
  *(void *)uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*(void *)v11)
  {
    unint64_t v21 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    __int16 v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1B6491688(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B649169C(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

double sub_1B64916CC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    char v4 = *(unsigned char *)(a1 + 16);
    *(unsigned char *)(a1 + 16) = v4 | 3;
    if ((*(unsigned char *)(a2 + 16) & 1) == 0)
    {
      if ((*(unsigned char *)(a2 + 16) & 2) != 0)
      {
        long long v6 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 24) = v6;
        *(unsigned char *)(a1 + 16) = v4 & 0xFC | 2;
      }
      else
      {
        *(unsigned char *)(a1 + 16) = v4 & 0xFC | 2;
        if (*(unsigned char *)(a2 + 16))
        {
          uint64_t v5 = 0;
        }
        else if ((*(unsigned char *)(a2 + 16) & 2) != 0)
        {
          uint64_t v5 = 1;
        }
        else
        {
          uint64_t v5 = *(void *)(*(void *)(a2 + 24) + 8);
        }
        *(unsigned char *)(a1 + 16) = v4 & 0xFC;
        unint64_t v7 = malloc_type_calloc(16 * v5 + 56, 1uLL, 0x382B03EuLL);
        *(void *)(a1 + 24) = v7;
        uint64_t v8 = a1 + 24;
        v7[6] = 0;
        **(void **)(a1 + 24) = v5;
        *(void *)(*(void *)(a1 + 24) + 8) = v5;
        *(void *)(*(void *)(a1 + 24) + 16) = 0;
        uint64_t v9 = a1 + 24;
        if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
          uint64_t v9 = *(void *)v8 + 56;
        }
        uint64_t v10 = (void *)(a2 + 24);
        if ((*(unsigned char *)(a2 + 16) & 2) == 0) {
          uint64_t v10 = (void *)(*v10 + 56);
        }
        if (v5 >= 1)
        {
          uint64_t v11 = (void *)(v9 + 8);
          do
          {
            long long v12 = *(_OWORD *)v10;
            v10 += 2;
            *(void *)&long long v6 = v12;
            *(_OWORD *)(v11 - 1) = v12;
            *(void *)&long long v12 = *v11;
            v11 += 2;
            *(void *)(*(void *)v8 + 16) += v12;
            --v5;
          }
          while (v5);
        }
      }
    }
  }
  return *(double *)&v6;
}

uint64_t sub_1B64917F4()
{
  if (qword_1EB996E68 != -1) {
    dispatch_once_f(&qword_1EB996E68, &qword_1EB9954F8, (dispatch_function_t)sub_1B649169C);
  }
  CFTypeID v0 = qword_1EB9954F8;

  return sub_1B63C8D44(v0, 0x18uLL);
}

uint64_t sub_1B649185C()
{
  uint64_t result = sub_1B64917F4();
  *(unsigned char *)(result + 16) |= 0xBu;
  return result;
}

uint64_t sub_1B6491884(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    uint64_t v1 = a1 + 32;
  }
  else {
    uint64_t v1 = *(void *)(a1 + 24) + 16;
  }
  return *(void *)v1;
}

uint64_t sub_1B64918B0(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 1) == 0)
  {
    uint64_t v1 = (uint64_t *)(a1 + 24);
    if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
      return *v1;
    }
    uint64_t v2 = *v1;
    if (*(void *)(v2 + 8))
    {
      uint64_t v1 = (uint64_t *)(v2 + 56);
      return *v1;
    }
  }
  return -1;
}

uint64_t sub_1B64918E0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  uint64_t v1 = (uint64_t *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v4 = 0;
    return v1[2 * v4];
  }
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(v2 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v1 = (uint64_t *)(v2 + 56);
  uint64_t v4 = v3 - 1;
  return v1[2 * v4];
}

uint64_t sub_1B6491924(uint64_t a1, uint64_t a2)
{
  return sub_1B6491930(a1, a2, 0, 1);
}

uint64_t sub_1B6491930(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 16)) {
    return -1;
  }
  char v5 = a3;
  uint64_t v6 = a2;
  if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v10 = *(void **)(a1 + 24);
    BOOL v15 = (char *)v10 + *(void *)(a1 + 32);
    uint64_t v16 = (uint64_t)(v15 - 1);
    if (a4)
    {
      if (a3)
      {
        if ((uint64_t)v10 < a2)
        {
          if ((uint64_t)v15 > a2) {
            return v6;
          }
          pthread_t v8 = 0;
LABEL_47:
          uint64_t v27 = sub_1B6491C30(a1, v6);
          if (v27 == -1) {
            return -1;
          }
          uint64_t v28 = a1 + 24;
          if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
            uint64_t v29 = (void *)(a1 + 24);
          }
          else {
            uint64_t v29 = v10 + 7;
          }
          uint64_t v30 = v29[2 * v27];
          if (v6 <= v30) {
            uint64_t v16 = v30;
          }
          else {
            uint64_t v16 = v6;
          }
          if ((pthread_t)v10[6] == v8)
          {
            v10[4] = v27;
            *(void *)(*(void *)v28 + 40) = v16 - v30;
            uint64_t v26 = *(void *)v28;
            goto LABEL_56;
          }
          return v16;
        }
      }
      else if ((uint64_t)v10 <= a2)
      {
        if (v16 > a2) {
          return a2 + 1;
        }
        pthread_t v8 = 0;
LABEL_45:
        if (v6 == 0x7FFFFFFFFFFFFFFFLL) {
          return -1;
        }
        ++v6;
        goto LABEL_47;
      }
      return *(void *)(a1 + 24);
    }
    if (a3)
    {
      if (v16 <= a2) {
        return v16;
      }
      uint64_t v16 = a2;
      if ((uint64_t)v10 <= a2) {
        return v16;
      }
      goto LABEL_32;
    }
    if ((uint64_t)v15 <= a2) {
      return v16;
    }
    if ((uint64_t)v10 < a2) {
      return a2 - 1;
    }
    goto LABEL_30;
  }
  pthread_t v8 = pthread_self();
  uint64_t v9 = a1 + 24;
  uint64_t v10 = *(void **)(a1 + 24);
  if ((pthread_t)v10[6] == v8 && v10[3] == v6)
  {
    if ((v5 & 1) == 0)
    {
      uint64_t v11 = v10 + 7;
      if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
        uint64_t v11 = (void *)(a1 + 24);
      }
      if (a4)
      {
        uint64_t v12 = v10[4];
        if (v11[2 * v12 + 1] - 1 > v10[5])
        {
          v10[3] = v6 + 1;
          uint64_t v13 = *(void *)v9;
          uint64_t v14 = *(void *)(*(void *)v9 + 40) + 1;
LABEL_59:
          *(void *)(v13 + 40) = v14;
          return *(void *)(*(void *)v9 + 24);
        }
        uint64_t v31 = (*(unsigned char *)(a1 + 16) & 1) == 0;
        if ((*(unsigned char *)(a1 + 16) & 3) == 0) {
          uint64_t v31 = v10[1];
        }
        uint64_t v32 = v12 + 1;
        if (v32 < v31)
        {
          v10[4] = v32;
          uint64_t v33 = v11[2 * *(void *)(*(void *)v9 + 32)];
          *(void *)(*(void *)v9 + 40) = 0;
          *(void *)(*(void *)v9 + 24) = v33;
          return *(void *)(*(void *)v9 + 24);
        }
      }
      else
      {
        if ((uint64_t)v10[5] >= 1)
        {
          v10[3] = v6 - 1;
          uint64_t v13 = *(void *)v9;
          uint64_t v14 = *(void *)(*(void *)v9 + 40) - 1;
          goto LABEL_59;
        }
        uint64_t v34 = v10[4];
        BOOL v35 = v34 < 1;
        uint64_t v36 = v34 - 1;
        if (!v35)
        {
          v10[4] = v36;
          uint64_t v37 = &v11[2 * *(void *)(*(void *)v9 + 32)];
          uint64_t v38 = *v37;
          *(void *)(*(void *)v9 + 40) = v37[1] - 1;
          *(void *)(*(void *)v9 + 24) = *(void *)(*(void *)v9 + 40) + v38;
          return *(void *)(*(void *)v9 + 24);
        }
      }
      v10[6] = 0;
      return -1;
    }
    return v6;
  }
  if (a4)
  {
    if (v5) {
      goto LABEL_47;
    }
    goto LABEL_45;
  }
  if ((v5 & 1) == 0)
  {
LABEL_30:
    if (!v6) {
      return -1;
    }
    --v6;
  }
LABEL_32:
  uint64_t v17 = sub_1B64920A8(a1, v6);
  if (v17 == -1) {
    return -1;
  }
  uint64_t v18 = v17;
  uint64_t v19 = a1 + 24;
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    __int16 v20 = (void *)(a1 + 24);
  }
  else {
    __int16 v20 = v10 + 7;
  }
  unint64_t v21 = &v20[2 * v17];
  uint64_t v22 = *v21;
  uint64_t v23 = v21[1] + *v21;
  if (v6 >= v23) {
    uint64_t v16 = v23 - 1;
  }
  else {
    uint64_t v16 = v6;
  }
  pthread_t v24 = pthread_self();
  uint64_t v25 = *(void *)(a1 + 24);
  if (*(pthread_t *)(v25 + 48) == v24)
  {
    *(void *)(v25 + 32) = v18;
    *(void *)(*(void *)v19 + 40) = v16 - v22;
    uint64_t v26 = *(void *)v19;
LABEL_56:
    *(void *)(v26 + 24) = v16;
  }
  return v16;
}

uint64_t sub_1B6491C30(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    goto LABEL_6;
  }
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(v3 + 8);
  BOOL v5 = v4 == 1;
  BOOL v6 = v4 < 1;
  uint64_t v7 = v4 - 1;
  if (v6) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(v3 + 56);
  if (!v5)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v7;
    do
    {
      uint64_t v11 = v10 + v9;
      if (v10 + v9 < 0 != __OFADD__(v10, v9)) {
        ++v11;
      }
      uint64_t result = v11 >> 1;
      uint64_t v12 = &v2[2 * (v11 >> 1)];
      if (*v12 <= a2)
      {
        if (v12[1] + *v12 > a2) {
          return result;
        }
        uint64_t v9 = result + 1;
      }
      else
      {
        uint64_t v10 = result;
      }
    }
    while (v9 < v10);
    goto LABEL_7;
  }
LABEL_6:
  uint64_t v7 = 0;
  uint64_t v9 = 0;
LABEL_7:
  if (v2[2 * v9 + 1] + v2[2 * v9] > a2) {
    return v9;
  }
  if (v9 < v7) {
    return v9 + 1;
  }
  return -1;
}

uint64_t sub_1B6491CE0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  uint64_t v4 = a1 + 24;
  if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    if (*(void *)v4 <= a2) {
      return *(void *)(a1 + 32) + *(void *)v4 > a2;
    }
    return 0;
  }
  BOOL v5 = *(_opaque_pthread_t **)(*(void *)v4 + 48);
  if (v5 != pthread_self())
  {
    char v6 = *(unsigned char *)(a1 + 16);
    goto LABEL_5;
  }
  uint64_t v12 = *(void *)v4;
  if (*(void *)(*(void *)v4 + 24) != a2)
  {
    char v6 = *(unsigned char *)(a1 + 16);
    uint64_t v13 = v12 + 56;
    if ((v6 & 2) != 0) {
      uint64_t v13 = v4;
    }
    uint64_t v14 = (void *)(v13 + 16 * *(void *)(v12 + 32));
    if (*v14 > a2 || v14[1] + *v14 <= a2)
    {
LABEL_5:
      if ((v6 & 1) == 0)
      {
        if ((v6 & 2) != 0) {
          goto LABEL_9;
        }
        uint64_t v7 = *(void *)(*(void *)v4 + 8);
        if (v7 >= 1)
        {
          uint64_t v4 = *(void *)v4 + 56;
          uint64_t v8 = v7 - 1;
          if (v7 != 1)
          {
            uint64_t v15 = 0;
            do
            {
              uint64_t v16 = v15 + v8;
              if (v15 + v8 < 0 != __OFADD__(v15, v8)) {
                ++v16;
              }
              uint64_t v9 = v16 >> 1;
              uint64_t v17 = (void *)(v4 + 16 * v9);
              if (*v17 <= a2)
              {
                if (v17[1] + *v17 > a2) {
                  return v9 != -1;
                }
                uint64_t v15 = v9 + 1;
              }
              else
              {
                uint64_t v8 = v9;
              }
            }
            while (v15 < v8);
            uint64_t v9 = v15;
LABEL_10:
            uint64_t v10 = (void *)(v4 + 16 * v9);
            if (*v10 <= a2 && v10[1] + *v10 > a2) {
              return v9 != -1;
            }
            goto LABEL_12;
          }
LABEL_9:
          uint64_t v9 = 0;
          goto LABEL_10;
        }
      }
LABEL_12:
      uint64_t v9 = -1;
      return v9 != -1;
    }
  }
  return 1;
}

void sub_1B6491E48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    uint64_t v6 = a2 + a3;
    uint64_t v7 = sub_1B64920A8(a1, a2);
    if (v7 == -1) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = v7;
    }
    uint64_t v14 = a1 + 24;
    for (uint64_t i = 16 * v13; ; i += 16)
    {
      uint64_t v16 = (*(unsigned char *)(a1 + 16) & 1) == 0;
      if ((*(unsigned char *)(a1 + 16) & 3) == 0) {
        uint64_t v16 = *(void *)(*(void *)v14 + 8);
      }
      if (v13 >= v16) {
        goto LABEL_25;
      }
      uint64_t v17 = a1 + 24;
      if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
        uint64_t v17 = *(void *)v14 + 56;
      }
      uint64_t v18 = (uint64_t *)(v17 + i);
      uint64_t v19 = *v18;
      uint64_t v8 = v6 - *v18;
      if (v6 < *v18) {
        break;
      }
      uint64_t v20 = v18[1] + v19;
      if (a2 < v19)
      {
        uint64_t v19 = a2;
        if (v6 <= v20) {
          uint64_t v8 = v20 - a2;
        }
        else {
          uint64_t v8 = v3;
        }
        if (v6 <= v20) {
          uint64_t v3 = v20 - a2;
        }
LABEL_24:
        sub_1B6492254(a1, v13, v19, v8, v9, v10, v11, v12);
LABEL_25:
        if (*(unsigned char *)(a1 + 16))
        {
          if (v13) {
            goto LABEL_40;
          }
          uint64_t v22 = 1;
        }
        else
        {
          if ((*(unsigned char *)(a1 + 16) & 2) == 0)
          {
            uint64_t v21 = *(void *)(*(void *)v14 + 8);
            if (v21 == v13)
            {
              uint64_t v22 = v21 + 1;
              goto LABEL_33;
            }
LABEL_40:
            while (1)
            {
              if (*(unsigned char *)(a1 + 16)) {
                uint64_t v28 = 0;
              }
              else {
                uint64_t v28 = (*(unsigned char *)(a1 + 16) & 2) != 0 ? 1 : *(void *)(*(void *)v14 + 8);
              }
              if (v13 >= v28 - 1) {
                break;
              }
              uint64_t v29 = a1 + 24;
              if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
                uint64_t v29 = *(void *)v14 + 56;
              }
              uint64_t v30 = (uint64_t *)(v29 + 16 * v13);
              uint64_t v31 = *v30;
              uint64_t v32 = v30[1];
              uint64_t v33 = (uint64_t *)(v29 + 16 * (v13 + 1));
              uint64_t v34 = v32 + v31;
              if (v34 < *v33) {
                break;
              }
              uint64_t v35 = v33[1] + *v33;
              if (v34 < v35)
              {
                sub_1B6492254(a1, v13, v31, v35 - v31, v9, v10, v11, v12);
                sub_1B6492328(a1, ++v13, v36, v37, v38, v39, v40, v41);
              }
              else
              {
                sub_1B6492328(a1, v13 + 1, v31, v8, v9, v10, v11, v12);
              }
            }
            return;
          }
          if (v13 != 1) {
            goto LABEL_40;
          }
          uint64_t v22 = 2;
        }
LABEL_33:
        sub_1B6492A6C(a1, v22);
        char v23 = *(unsigned char *)(a1 + 16);
        if ((v23 & 2) != 0)
        {
          *(void *)(a1 + 24) = a2;
          *(void *)(a1 + 32) = v3;
        }
        else
        {
          *(void *)(*(void *)(a1 + 24) + 48) = 0;
          uint64_t v24 = *(void *)(a1 + 24);
          if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
            uint64_t v25 = a1 + 24;
          }
          else {
            uint64_t v25 = v24 + 56;
          }
          uint64_t v26 = *(void *)(v24 + 8);
          *(void *)(v24 + 8) = v26 + 1;
          uint64_t v27 = (uint64_t *)(v25 + 16 * v26);
          *uint64_t v27 = a2;
          v27[1] = v3;
          *(void *)(*(void *)(a1 + 24) + 16) += v3;
          char v23 = *(unsigned char *)(a1 + 16);
        }
        *(unsigned char *)(a1 + 16) = v23 & 0xFE;
        goto LABEL_40;
      }
      if (v6 <= v20) {
        return;
      }
      if (v20 >= a2) {
        goto LABEL_24;
      }
      ++v13;
    }
    sub_1B6492148(a1, a2, v3, v13, v9, v10, v11, v12);
  }
}

uint64_t sub_1B64920A8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 2) != 0) {
    goto LABEL_5;
  }
  uint64_t v3 = *v2;
  uint64_t v4 = *(void *)(v3 + 8);
  if (v4 < 1) {
    return -1;
  }
  uint64_t v2 = (uint64_t *)(v3 + 56);
  uint64_t v5 = v4 - 1;
  if (v4 != 1)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v10 = v5 + v6;
      if (v5 + v6 < 0 != __OFADD__(v5, v6)) {
        ++v10;
      }
      uint64_t result = v10 >> 1;
      uint64_t v11 = &v2[2 * (v10 >> 1)];
      if (*v11 <= a2)
      {
        if (v11[1] + *v11 > a2) {
          return result;
        }
        uint64_t v6 = result + 1;
      }
      else
      {
        uint64_t v5 = result;
      }
    }
    while (v6 < v5);
    goto LABEL_6;
  }
LABEL_5:
  uint64_t v6 = 0;
LABEL_6:
  uint64_t v7 = v2[2 * v6];
  uint64_t v8 = v6 - 1;
  if (v6 <= 0) {
    uint64_t v8 = -1;
  }
  if (v7 > a2) {
    return v8;
  }
  else {
    return v6;
  }
}

void sub_1B6492148(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v12 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v12 = 1;
  }
  else
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (v12 >= a4)
  {
    sub_1B6492A6C(a1, v12 + 1);
    uint64_t v13 = (void *)(a1 + 24);
    if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
      uint64_t v13 = (void *)(*v13 + 56);
    }
    if (v12 > a4)
    {
      uint64_t v14 = &v13[2 * v12];
      do
      {
        --v12;
        *uint64_t v14 = *(v14 - 1);
        --v14;
      }
      while (v12 > a4);
    }
    uint64_t v15 = &v13[2 * a4];
    *uint64_t v15 = a2;
    v15[1] = a3;
    char v16 = *(unsigned char *)(a1 + 16);
    if ((v16 & 2) == 0)
    {
      *(void *)(*(void *)(a1 + 24) + 48) = 0;
      ++*(void *)(*(void *)(a1 + 24) + 8);
      *(void *)(*(void *)(a1 + 24) + 16) += a3;
      char v16 = *(unsigned char *)(a1 + 16);
    }
    *(unsigned char *)(a1 + 16) = v16 & 0xFE;
  }
  else
  {
    sub_1B63F2F54(16, @"Error: Index %ld out of range bounds [0...%ld]", a3, a4, a5, a6, a7, a8, a4);
  }
}

void sub_1B6492254(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v8 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (a4 <= 0)
  {
    sub_1B6492328(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else if (v8 >= a2)
  {
    uint64_t v9 = a1 + 24;
    uint64_t v10 = a1 + 24;
    if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
      uint64_t v10 = *(void *)v9 + 56;
    }
    uint64_t v11 = (uint64_t *)(v10 + 16 * a2);
    uint64_t v12 = v11[1];
    *uint64_t v11 = a3;
    v11[1] = a4;
    if ((*(unsigned char *)(a1 + 16) & 2) == 0)
    {
      *(void *)(*(void *)v9 + 48) = 0;
      *(void *)(*(void *)v9 + 16) -= v12;
      *(void *)(*(void *)v9 + 16) += a4;
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: Index %ld out of range bounds [0...%ld]", a3, a4, a5, a6, a7, a8, a2);
  }
}

void sub_1B6492328(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *(unsigned char *)(a1 + 16);
  if (v8)
  {
    uint64_t v9 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (v9 >= a2)
  {
    uint64_t v10 = (void *)(a1 + 24);
    if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
      uint64_t v10 = (void *)(*v10 + 56);
    }
    uint64_t v11 = &v10[2 * a2];
    uint64_t v12 = v11[1];
    if (a2 + 1 < v9)
    {
      uint64_t v13 = v11 + 2;
      uint64_t v14 = ~a2 + v9;
      do
      {
        *(v13 - 1) = *v13;
        ++v13;
        --v14;
      }
      while (v14);
      char v8 = *(unsigned char *)(a1 + 16);
    }
    if ((v8 & 2) != 0)
    {
      char v15 = v8 | 1;
    }
    else
    {
      *(void *)(*(void *)(a1 + 24) + 48) = 0;
      --*(void *)(*(void *)(a1 + 24) + 8);
      *(void *)(*(void *)(a1 + 24) + 16) -= v12;
      char v15 = *(unsigned char *)(a1 + 16) & 0xFE | (*(void *)(*(void *)(a1 + 24) + 8) == 0);
    }
    *(unsigned char *)(a1 + 16) = v15;
  }
  else
  {
    sub_1B63F2F54(16, @"Error: Index %ld out of range bounds [0...%ld]", a3, a4, a5, a6, a7, a8, a2);
  }
}

void sub_1B6492424(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 && a2 != a1)
  {
    if ((*(unsigned char *)(a1 + 16) & 1) == 0 && ((*(unsigned char *)(a1 + 16) & 2) != 0 || *(void *)(*(void *)(a1 + 24) + 8)))
    {
      if (*(unsigned char *)(a2 + 16)) {
        return;
      }
      if ((*(unsigned char *)(a2 + 16) & 2) != 0)
      {
        uint64_t v10 = 1;
      }
      else
      {
        uint64_t v10 = *(void *)(*(void *)(a2 + 24) + 8);
        if (v10 < 1) {
          return;
        }
      }
      for (uint64_t i = 0; i != v10; ++i)
      {
        uint64_t v12 = sub_1B6492540(a2, i, a3, a4, a5, a6, a7, a8);
        sub_1B6491E48(a1, v12, v13);
      }
    }
    else
    {
      sub_1B64924FC(a1);
      sub_1B64916CC(a1, a2);
    }
  }
}

void sub_1B64924FC(uint64_t a1)
{
  char v2 = *(unsigned char *)(a1 + 16);
  if ((v2 & 2) == 0)
  {
    uint64_t v3 = *(void **)(a1 + 24);
    if (v3)
    {
      free(v3);
      char v2 = *(unsigned char *)(a1 + 16);
    }
    *(void *)(a1 + 24) = 0;
  }
  *(unsigned char *)(a1 + 16) = v2 | 3;
}

uint64_t sub_1B6492540(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10 = *(unsigned char *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 0;
  }
  else if ((*(unsigned char *)(a1 + 16) & 2) != 0)
  {
    uint64_t v11 = 1;
  }
  else
  {
    uint64_t v11 = *(void *)(*(void *)(a1 + 24) + 8);
  }
  if (v11 < a2)
  {
    sub_1B63F2F54(16, @"Error: Index %ld out of bounds [0...%ld]", a3, a4, a5, a6, a7, a8, a2);
    char v10 = *(unsigned char *)(a1 + 16);
  }
  uint64_t v12 = (void *)(a1 + 24);
  if ((v10 & 2) == 0) {
    uint64_t v12 = (void *)(*v12 + 56);
  }
  return v12[2 * a2];
}

void sub_1B64925C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    if (a2 < 1)
    {
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = sub_1B6491C30(a1, a2);
      if (v11 == -1) {
        return;
      }
    }
    uint64_t v12 = a2 + a3;
    uint64_t v13 = a1 + 24;
    while (1)
    {
      if (*(unsigned char *)(a1 + 16)) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = (*(unsigned char *)(a1 + 16) & 2) != 0 ? 1 : *(void *)(*(void *)v13 + 8);
      }
      if (v11 >= v14) {
        break;
      }
      uint64_t v15 = a1 + 24;
      if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
        uint64_t v15 = *(void *)v13 + 56;
      }
      char v16 = (uint64_t *)(v15 + 16 * v11);
      uint64_t v17 = *v16;
      if (v12 < *v16) {
        break;
      }
      uint64_t v18 = v16[1] + v17;
      if (a2 > v17)
      {
        if (v18 > v12)
        {
          sub_1B6492254(a1, v11, v12, v18 - v12, a5, a6, a7, a8);
          sub_1B6492148(a1, v17, a2 - v17, v11, v20, v21, v22, v23);
          return;
        }
        if (a2 < v18) {
          sub_1B6492254(a1, v11, v17, a2 - v17, a5, a6, a7, a8);
        }
        ++v11;
      }
      else
      {
        uint64_t v19 = v18 - v12;
        if (v18 > v12)
        {
          sub_1B6492254(a1, v11, v12, v19, a5, a6, a7, a8);
          return;
        }
        sub_1B6492328(a1, v11, a3, v19, a5, a6, a7, a8);
      }
    }
  }
}

void sub_1B6492754(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2
    && (*(unsigned char *)(a1 + 16) & 1) == 0
    && ((*(unsigned char *)(a1 + 16) & 2) != 0 || *(uint64_t *)(*(void *)(a1 + 24) + 8) >= 1))
  {
    if (a2 == a1)
    {
      sub_1B64924FC(a2);
    }
    else
    {
      if (*(unsigned char *)(a2 + 16)) {
        return;
      }
      if ((*(unsigned char *)(a2 + 16) & 2) != 0)
      {
        uint64_t v10 = 1;
      }
      else
      {
        uint64_t v10 = *(void *)(*(void *)(a2 + 24) + 8);
        if (v10 < 1) {
          return;
        }
      }
      for (uint64_t i = 0; i != v10; ++i)
      {
        uint64_t v12 = sub_1B6492540(a2, i, a3, a4, a5, a6, a7, a8);
        sub_1B64925C8(a1, v12, v13, v13, v14, v15, v16, v17);
      }
    }
  }
}

void sub_1B6492824(uint64_t a1, uint64_t a2)
{
}

void sub_1B649282C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B6492834(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1B64917F4();
  *(unsigned char *)(v4 + 16) |= 0xBu;
  uint64_t v5 = (unsigned char *)sub_1B64917F4();
  v5[16] |= 0xBu;
  sub_1B6492424(v4, a1, v6, v7, v8, v9, v10, v11);
  sub_1B6492424((uint64_t)v5, a1, v12, v13, v14, v15, v16, v17);
  sub_1B6492754((uint64_t)v5, a2, v18, v19, v20, v21, v22, v23);
  sub_1B6492754(v4, (uint64_t)v5, v24, v25, v26, v27, v28, v29);
  CFRelease(v5);
  return v4;
}

void sub_1B64928D4(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 2) == 0)
  {
    uint64_t v1 = *(void **)(a1 + 24);
    if (v1) {
      free(v1);
    }
  }
}

__CFString *sub_1B64928F0(uint64_t a1)
{
  CFDictionaryRef Mutable = CFStringCreateMutable(0, 256);
  CFStringAppend(Mutable, @"indexSet ");
  if (*(unsigned char *)(a1 + 16)) {
    goto LABEL_15;
  }
  if ((*(unsigned char *)(a1 + 16) & 2) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (*(void *)(v3 + 16))
    {
      uint64_t v4 = *(void *)(v3 + 8);
      CFStringAppendFormat(Mutable, 0, @"[number of indexes: %lu (in %lu ranges), indexes: ("), *(void *)(v3 + 16), v4;
      if (v4 < 1)
      {
        CFStringRef v9 = @"]");
        goto LABEL_16;
      }
      uint64_t v5 = v3 + 56;
      goto LABEL_8;
    }
LABEL_15:
    CFStringRef v9 = @"(no index)";
    goto LABEL_16;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (!v6) {
    goto LABEL_15;
  }
  uint64_t v5 = a1 + 24;
  uint64_t v4 = 1;
  CFStringAppendFormat(Mutable, 0, @"[number of indexes: %lu (in %lu ranges), indexes: ("), v6, 1;
LABEL_8:
  uint64_t v7 = 0;
  uint64_t v8 = (uint64_t *)(v5 + 8);
  CFStringRef v9 = @"]");
  do
  {
    if (v7) {
      CFStringAppend(Mutable, @" ");
    }
    uint64_t v10 = *(v8 - 1);
    uint64_t v11 = *v8;
    CFStringAppendFormat(Mutable, 0, @"%lu", v10);
    if (v11 >= 2) {
      CFStringAppendFormat(Mutable, 0, @"-%lu", v10 + v11 - 1);
    }
    ++v7;
    v8 += 2;
  }
  while (v4 != v7);
LABEL_16:
  CFStringAppend(Mutable, v9);
  return Mutable;
}

__n128 sub_1B6492A6C(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a1 + 16);
  if ((v3 & 2) != 0) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = **(void **)(a1 + 24);
  }
  if (v4 < a2)
  {
    if (a2 == 1)
    {
      *(unsigned char *)(a1 + 16) = v3 | 2;
    }
    else
    {
      uint64_t v5 = 2 * v4;
      if (v5 <= a2) {
        uint64_t v5 = a2;
      }
      if (a2 >= 4) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = 4;
      }
      if ((*(unsigned char *)(a1 + 16) & 2) != 0)
      {
        BOOL v8 = (v3 & 1) == 0;
        if (*(unsigned char *)(a1 + 16)) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = *(void *)(a1 + 32);
        }
        uint64_t v10 = (void *)(a1 + 24);
        __n128 v12 = *(__n128 *)(a1 + 24);
        *(unsigned char *)(a1 + 16) = v3 & 0xFD;
        uint64_t v11 = malloc_type_calloc(16 * v6 + 56, 1uLL, 0x3964E8B3uLL);
        *(void *)(a1 + 24) = v11;
        v11[6] = 0;
        **(void **)(a1 + 24) = v6;
        *(void *)(*(void *)(a1 + 24) + 8) = v8;
        *(void *)(*(void *)(a1 + 24) + 16) = v9;
        if ((*(unsigned char *)(a1 + 16) & 2) == 0) {
          uint64_t v10 = (void *)(*v10 + 56);
        }
        __n128 result = v12;
        *(__n128 *)uint64_t v10 = v12;
      }
      else
      {
        *(void *)(a1 + 24) = malloc_type_realloc(*(void **)(a1 + 24), 16 * v6 + 56, 0xE75AF901uLL);
      }
    }
  }
  return result;
}

id sub_1B6492B90(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (const void *)a1[15];
  if (v9)
  {
    CFRelease(v9);
    a1[15] = 0;
  }
  uint64_t v10 = (const void *)a1[12];
  if (v10)
  {
    CFRelease(v10);
    a1[12] = 0;
  }
  uint64_t v11 = (const void *)a1[8];
  if (v11)
  {
    CFRelease(v11);
    a1[8] = 0;
  }

  return sub_1B658325C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
}